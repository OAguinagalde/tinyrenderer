//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (188)
//--------------------------------------------------------------------------------
pub const TS_STATUS = extern struct {
    dwDynamicFlags: u32,
    dwStaticFlags: u32,
};

pub const TS_TEXTCHANGE = extern struct {
    acpStart: i32,
    acpOldEnd: i32,
    acpNewEnd: i32,
};

pub const TsActiveSelEnd = extern enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TS_AE_NONE = TsActiveSelEnd.NONE;
pub const TS_AE_START = TsActiveSelEnd.START;
pub const TS_AE_END = TsActiveSelEnd.END;

pub const TS_SELECTIONSTYLE = extern struct {
    ase: TsActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TS_SELECTION_ACP = extern struct {
    acpStart: i32,
    acpEnd: i32,
    style: TS_SELECTIONSTYLE,
};

pub const TS_SELECTION_ANCHOR = extern struct {
    paStart: *IAnchor,
    paEnd: *IAnchor,
    style: TS_SELECTIONSTYLE,
};

pub const TS_ATTRVAL = extern struct {
    idAttr: Guid,
    dwOverlapId: u32,
    varValue: VARIANT,
};

pub const TsLayoutCode = extern enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TS_LC_CREATE = TsLayoutCode.CREATE;
pub const TS_LC_CHANGE = TsLayoutCode.CHANGE;
pub const TS_LC_DESTROY = TsLayoutCode.DESTROY;

pub const TsRunType = extern enum(i32) {
    PLAIN = 0,
    HIDDEN = 1,
    OPAQUE = 2,
};
pub const TS_RT_PLAIN = TsRunType.PLAIN;
pub const TS_RT_HIDDEN = TsRunType.HIDDEN;
pub const TS_RT_OPAQUE = TsRunType.OPAQUE;

pub const TS_RUNINFO = extern struct {
    uCount: u32,
    type: TsRunType,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACP_Value = @import("../zig.zig").Guid.initString("28888fe3-c2a0-483a-a3ea-8cb1ce51ff3d");
pub const IID_ITextStoreACP = &IID_ITextStoreACP_Value;
pub const ITextStoreACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: fn(
            self: *const ITextStoreACP,
            riid: *const Guid,
            punk: *IUnknown,
            dwMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: fn(
            self: *const ITextStoreACP,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: fn(
            self: *const ITextStoreACP,
            dwLockFlags: u32,
            phrSession: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITextStoreACP,
            pdcs: *TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: fn(
            self: *const ITextStoreACP,
            acpTestStart: i32,
            acpTestEnd: i32,
            cch: u32,
            pacpResultStart: *i32,
            pacpResultEnd: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextStoreACP,
            ulIndex: u32,
            ulCount: u32,
            pSelection: [*]TS_SELECTION_ACP,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const ITextStoreACP,
            ulCount: u32,
            pSelection: [*]const TS_SELECTION_ACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStoreACP,
            acpStart: i32,
            acpEnd: i32,
            pchPlain: [*:0]u16,
            cchPlainReq: u32,
            pcchPlainRet: *u32,
            prgRunInfo: [*]TS_RUNINFO,
            cRunInfoReq: u32,
            pcRunInfoRet: *u32,
            pacpNext: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStoreACP,
            dwFlags: u32,
            acpStart: i32,
            acpEnd: i32,
            pchText: [*:0]const u16,
            cch: u32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextStoreACP,
            acpStart: i32,
            acpEnd: i32,
            ppDataObject: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: fn(
            self: *const ITextStoreACP,
            acpPos: i32,
            rguidService: *const Guid,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: fn(
            self: *const ITextStoreACP,
            pguidService: *const Guid,
            pFormatEtc: *const FORMATETC,
            pfInsertable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: fn(
            self: *const ITextStoreACP,
            dwFlags: u32,
            acpStart: i32,
            acpEnd: i32,
            pDataObject: *IDataObject,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: fn(
            self: *const ITextStoreACP,
            dwFlags: u32,
            pchText: [*:0]const u16,
            cch: u32,
            pacpStart: *i32,
            pacpEnd: *i32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: fn(
            self: *const ITextStoreACP,
            dwFlags: u32,
            pDataObject: *IDataObject,
            pacpStart: *i32,
            pacpEnd: *i32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: fn(
            self: *const ITextStoreACP,
            dwFlags: u32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: fn(
            self: *const ITextStoreACP,
            acpPos: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: fn(
            self: *const ITextStoreACP,
            acpPos: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: fn(
            self: *const ITextStoreACP,
            acpStart: i32,
            acpHalt: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
            pacpNext: *i32,
            pfFound: *BOOL,
            plFoundOffset: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: fn(
            self: *const ITextStoreACP,
            ulCount: u32,
            paAttrVals: [*]TS_ATTRVAL,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndACP: fn(
            self: *const ITextStoreACP,
            pacp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: fn(
            self: *const ITextStoreACP,
            pvcView: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetACPFromPoint: fn(
            self: *const ITextStoreACP,
            vcView: u32,
            ptScreen: *const POINT,
            dwFlags: u32,
            pacp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: fn(
            self: *const ITextStoreACP,
            vcView: u32,
            acpStart: i32,
            acpEnd: i32,
            prc: *RECT,
            pfClipped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: fn(
            self: *const ITextStoreACP,
            vcView: u32,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: fn(
            self: *const ITextStoreACP,
            vcView: u32,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_AdviseSink(self: *const T, riid: *const Guid, punk: *IUnknown, dwMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).AdviseSink(@ptrCast(*const ITextStoreACP, self), riid, punk, dwMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_UnadviseSink(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).UnadviseSink(@ptrCast(*const ITextStoreACP, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_RequestLock(self: *const T, dwLockFlags: u32, phrSession: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).RequestLock(@ptrCast(*const ITextStoreACP, self), dwLockFlags, phrSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetStatus(self: *const T, pdcs: *TS_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetStatus(@ptrCast(*const ITextStoreACP, self), pdcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_QueryInsert(self: *const T, acpTestStart: i32, acpTestEnd: i32, cch: u32, pacpResultStart: *i32, pacpResultEnd: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).QueryInsert(@ptrCast(*const ITextStoreACP, self), acpTestStart, acpTestEnd, cch, pacpResultStart, pacpResultEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ACP, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetSelection(@ptrCast(*const ITextStoreACP, self), ulIndex, ulCount, pSelection, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).SetSelection(@ptrCast(*const ITextStoreACP, self), ulCount, pSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetText(self: *const T, acpStart: i32, acpEnd: i32, pchPlain: [*:0]u16, cchPlainReq: u32, pcchPlainRet: *u32, prgRunInfo: [*]TS_RUNINFO, cRunInfoReq: u32, pcRunInfoRet: *u32, pacpNext: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetText(@ptrCast(*const ITextStoreACP, self), acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainRet, prgRunInfo, cRunInfoReq, pcRunInfoRet, pacpNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_SetText(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pchText: [*:0]const u16, cch: u32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).SetText(@ptrCast(*const ITextStoreACP, self), dwFlags, acpStart, acpEnd, pchText, cch, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetFormattedText(self: *const T, acpStart: i32, acpEnd: i32, ppDataObject: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextStoreACP, self), acpStart, acpEnd, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetEmbedded(self: *const T, acpPos: i32, rguidService: *const Guid, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetEmbedded(@ptrCast(*const ITextStoreACP, self), acpPos, rguidService, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_QueryInsertEmbedded(self: *const T, pguidService: *const Guid, pFormatEtc: *const FORMATETC, pfInsertable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).QueryInsertEmbedded(@ptrCast(*const ITextStoreACP, self), pguidService, pFormatEtc, pfInsertable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_InsertEmbedded(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pDataObject: *IDataObject, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).InsertEmbedded(@ptrCast(*const ITextStoreACP, self), dwFlags, acpStart, acpEnd, pDataObject, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, pacpStart: *i32, pacpEnd: *i32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).InsertTextAtSelection(@ptrCast(*const ITextStoreACP, self), dwFlags, pchText, cch, pacpStart, pacpEnd, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: *IDataObject, pacpStart: *i32, pacpEnd: *i32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).InsertEmbeddedAtSelection(@ptrCast(*const ITextStoreACP, self), dwFlags, pDataObject, pacpStart, pacpEnd, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).RequestSupportedAttrs(@ptrCast(*const ITextStoreACP, self), dwFlags, cFilterAttrs, paFilterAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_RequestAttrsAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).RequestAttrsAtPosition(@ptrCast(*const ITextStoreACP, self), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_RequestAttrsTransitioningAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).RequestAttrsTransitioningAtPosition(@ptrCast(*const ITextStoreACP, self), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_FindNextAttrTransition(self: *const T, acpStart: i32, acpHalt: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pacpNext: *i32, pfFound: *BOOL, plFoundOffset: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).FindNextAttrTransition(@ptrCast(*const ITextStoreACP, self), acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, pacpNext, pfFound, plFoundOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).RetrieveRequestedAttrs(@ptrCast(*const ITextStoreACP, self), ulCount, paAttrVals, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetEndACP(self: *const T, pacp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetEndACP(@ptrCast(*const ITextStoreACP, self), pacp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetActiveView(self: *const T, pvcView: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetActiveView(@ptrCast(*const ITextStoreACP, self), pvcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetACPFromPoint(self: *const T, vcView: u32, ptScreen: *const POINT, dwFlags: u32, pacp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetACPFromPoint(@ptrCast(*const ITextStoreACP, self), vcView, ptScreen, dwFlags, pacp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetTextExt(self: *const T, vcView: u32, acpStart: i32, acpEnd: i32, prc: *RECT, pfClipped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetTextExt(@ptrCast(*const ITextStoreACP, self), vcView, acpStart, acpEnd, prc, pfClipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetScreenExt(self: *const T, vcView: u32, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetScreenExt(@ptrCast(*const ITextStoreACP, self), vcView, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP_GetWnd(self: *const T, vcView: u32, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP.VTable, self.vtable).GetWnd(@ptrCast(*const ITextStoreACP, self), vcView, phwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoreACP2_Value = @import("../zig.zig").Guid.initString("f86ad89f-5fe4-4b8d-bb9f-ef3797a84f1f");
pub const IID_ITextStoreACP2 = &IID_ITextStoreACP2_Value;
pub const ITextStoreACP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: fn(
            self: *const ITextStoreACP2,
            riid: *const Guid,
            punk: *IUnknown,
            dwMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: fn(
            self: *const ITextStoreACP2,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: fn(
            self: *const ITextStoreACP2,
            dwLockFlags: u32,
            phrSession: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITextStoreACP2,
            pdcs: *TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: fn(
            self: *const ITextStoreACP2,
            acpTestStart: i32,
            acpTestEnd: i32,
            cch: u32,
            pacpResultStart: *i32,
            pacpResultEnd: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextStoreACP2,
            ulIndex: u32,
            ulCount: u32,
            pSelection: [*]TS_SELECTION_ACP,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const ITextStoreACP2,
            ulCount: u32,
            pSelection: [*]const TS_SELECTION_ACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStoreACP2,
            acpStart: i32,
            acpEnd: i32,
            pchPlain: [*:0]u16,
            cchPlainReq: u32,
            pcchPlainRet: *u32,
            prgRunInfo: [*]TS_RUNINFO,
            cRunInfoReq: u32,
            pcRunInfoRet: *u32,
            pacpNext: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStoreACP2,
            dwFlags: u32,
            acpStart: i32,
            acpEnd: i32,
            pchText: [*:0]const u16,
            cch: u32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextStoreACP2,
            acpStart: i32,
            acpEnd: i32,
            ppDataObject: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: fn(
            self: *const ITextStoreACP2,
            acpPos: i32,
            rguidService: *const Guid,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: fn(
            self: *const ITextStoreACP2,
            pguidService: *const Guid,
            pFormatEtc: *const FORMATETC,
            pfInsertable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: fn(
            self: *const ITextStoreACP2,
            dwFlags: u32,
            acpStart: i32,
            acpEnd: i32,
            pDataObject: *IDataObject,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: fn(
            self: *const ITextStoreACP2,
            dwFlags: u32,
            pchText: [*:0]const u16,
            cch: u32,
            pacpStart: *i32,
            pacpEnd: *i32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: fn(
            self: *const ITextStoreACP2,
            dwFlags: u32,
            pDataObject: *IDataObject,
            pacpStart: *i32,
            pacpEnd: *i32,
            pChange: *TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: fn(
            self: *const ITextStoreACP2,
            dwFlags: u32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: fn(
            self: *const ITextStoreACP2,
            acpPos: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: fn(
            self: *const ITextStoreACP2,
            acpPos: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: fn(
            self: *const ITextStoreACP2,
            acpStart: i32,
            acpHalt: i32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
            pacpNext: *i32,
            pfFound: *BOOL,
            plFoundOffset: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: fn(
            self: *const ITextStoreACP2,
            ulCount: u32,
            paAttrVals: [*]TS_ATTRVAL,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndACP: fn(
            self: *const ITextStoreACP2,
            pacp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: fn(
            self: *const ITextStoreACP2,
            pvcView: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetACPFromPoint: fn(
            self: *const ITextStoreACP2,
            vcView: u32,
            ptScreen: *const POINT,
            dwFlags: u32,
            pacp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: fn(
            self: *const ITextStoreACP2,
            vcView: u32,
            acpStart: i32,
            acpEnd: i32,
            prc: *RECT,
            pfClipped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: fn(
            self: *const ITextStoreACP2,
            vcView: u32,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_AdviseSink(self: *const T, riid: *const Guid, punk: *IUnknown, dwMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).AdviseSink(@ptrCast(*const ITextStoreACP2, self), riid, punk, dwMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_UnadviseSink(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).UnadviseSink(@ptrCast(*const ITextStoreACP2, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_RequestLock(self: *const T, dwLockFlags: u32, phrSession: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).RequestLock(@ptrCast(*const ITextStoreACP2, self), dwLockFlags, phrSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetStatus(self: *const T, pdcs: *TS_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetStatus(@ptrCast(*const ITextStoreACP2, self), pdcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_QueryInsert(self: *const T, acpTestStart: i32, acpTestEnd: i32, cch: u32, pacpResultStart: *i32, pacpResultEnd: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).QueryInsert(@ptrCast(*const ITextStoreACP2, self), acpTestStart, acpTestEnd, cch, pacpResultStart, pacpResultEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ACP, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetSelection(@ptrCast(*const ITextStoreACP2, self), ulIndex, ulCount, pSelection, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).SetSelection(@ptrCast(*const ITextStoreACP2, self), ulCount, pSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetText(self: *const T, acpStart: i32, acpEnd: i32, pchPlain: [*:0]u16, cchPlainReq: u32, pcchPlainRet: *u32, prgRunInfo: [*]TS_RUNINFO, cRunInfoReq: u32, pcRunInfoRet: *u32, pacpNext: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetText(@ptrCast(*const ITextStoreACP2, self), acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainRet, prgRunInfo, cRunInfoReq, pcRunInfoRet, pacpNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_SetText(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pchText: [*:0]const u16, cch: u32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).SetText(@ptrCast(*const ITextStoreACP2, self), dwFlags, acpStart, acpEnd, pchText, cch, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetFormattedText(self: *const T, acpStart: i32, acpEnd: i32, ppDataObject: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextStoreACP2, self), acpStart, acpEnd, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetEmbedded(self: *const T, acpPos: i32, rguidService: *const Guid, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetEmbedded(@ptrCast(*const ITextStoreACP2, self), acpPos, rguidService, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_QueryInsertEmbedded(self: *const T, pguidService: *const Guid, pFormatEtc: *const FORMATETC, pfInsertable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).QueryInsertEmbedded(@ptrCast(*const ITextStoreACP2, self), pguidService, pFormatEtc, pfInsertable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_InsertEmbedded(self: *const T, dwFlags: u32, acpStart: i32, acpEnd: i32, pDataObject: *IDataObject, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).InsertEmbedded(@ptrCast(*const ITextStoreACP2, self), dwFlags, acpStart, acpEnd, pDataObject, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, pacpStart: *i32, pacpEnd: *i32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).InsertTextAtSelection(@ptrCast(*const ITextStoreACP2, self), dwFlags, pchText, cch, pacpStart, pacpEnd, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: *IDataObject, pacpStart: *i32, pacpEnd: *i32, pChange: *TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).InsertEmbeddedAtSelection(@ptrCast(*const ITextStoreACP2, self), dwFlags, pDataObject, pacpStart, pacpEnd, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).RequestSupportedAttrs(@ptrCast(*const ITextStoreACP2, self), dwFlags, cFilterAttrs, paFilterAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_RequestAttrsAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).RequestAttrsAtPosition(@ptrCast(*const ITextStoreACP2, self), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_RequestAttrsTransitioningAtPosition(self: *const T, acpPos: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).RequestAttrsTransitioningAtPosition(@ptrCast(*const ITextStoreACP2, self), acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_FindNextAttrTransition(self: *const T, acpStart: i32, acpHalt: i32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pacpNext: *i32, pfFound: *BOOL, plFoundOffset: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).FindNextAttrTransition(@ptrCast(*const ITextStoreACP2, self), acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, pacpNext, pfFound, plFoundOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).RetrieveRequestedAttrs(@ptrCast(*const ITextStoreACP2, self), ulCount, paAttrVals, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetEndACP(self: *const T, pacp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetEndACP(@ptrCast(*const ITextStoreACP2, self), pacp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetActiveView(self: *const T, pvcView: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetActiveView(@ptrCast(*const ITextStoreACP2, self), pvcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetACPFromPoint(self: *const T, vcView: u32, ptScreen: *const POINT, dwFlags: u32, pacp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetACPFromPoint(@ptrCast(*const ITextStoreACP2, self), vcView, ptScreen, dwFlags, pacp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetTextExt(self: *const T, vcView: u32, acpStart: i32, acpEnd: i32, prc: *RECT, pfClipped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetTextExt(@ptrCast(*const ITextStoreACP2, self), vcView, acpStart, acpEnd, prc, pfClipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACP2_GetScreenExt(self: *const T, vcView: u32, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACP2.VTable, self.vtable).GetScreenExt(@ptrCast(*const ITextStoreACP2, self), vcView, prc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPSink_Value = @import("../zig.zig").Guid.initString("22d44c94-a419-4542-a272-ae26093ececf");
pub const IID_ITextStoreACPSink = &IID_ITextStoreACPSink_Value;
pub const ITextStoreACPSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: fn(
            self: *const ITextStoreACPSink,
            dwFlags: TEXT_STORE_TEXT_CHANGE_FLAGS,
            pChange: *const TS_TEXTCHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: fn(
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLayoutChange: fn(
            self: *const ITextStoreACPSink,
            lcode: TsLayoutCode,
            vcView: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: fn(
            self: *const ITextStoreACPSink,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttrsChange: fn(
            self: *const ITextStoreACPSink,
            acpStart: i32,
            acpEnd: i32,
            cAttrs: u32,
            paAttrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLockGranted: fn(
            self: *const ITextStoreACPSink,
            dwLockFlags: TEXT_STORE_LOCK_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStartEditTransaction: fn(
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: fn(
            self: *const ITextStoreACPSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnTextChange(self: *const T, dwFlags: TEXT_STORE_TEXT_CHANGE_FLAGS, pChange: *const TS_TEXTCHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnTextChange(@ptrCast(*const ITextStoreACPSink, self), dwFlags, pChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnSelectionChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnSelectionChange(@ptrCast(*const ITextStoreACPSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnLayoutChange(self: *const T, lcode: TsLayoutCode, vcView: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnLayoutChange(@ptrCast(*const ITextStoreACPSink, self), lcode, vcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnStatusChange(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnStatusChange(@ptrCast(*const ITextStoreACPSink, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnAttrsChange(self: *const T, acpStart: i32, acpEnd: i32, cAttrs: u32, paAttrs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnAttrsChange(@ptrCast(*const ITextStoreACPSink, self), acpStart, acpEnd, cAttrs, paAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnLockGranted(self: *const T, dwLockFlags: TEXT_STORE_LOCK_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnLockGranted(@ptrCast(*const ITextStoreACPSink, self), dwLockFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnStartEditTransaction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnStartEditTransaction(@ptrCast(*const ITextStoreACPSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSink_OnEndEditTransaction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSink.VTable, self.vtable).OnEndEditTransaction(@ptrCast(*const ITextStoreACPSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TsGravity = extern enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_GR_BACKWARD = TsGravity.BACKWARD;
pub const TS_GR_FORWARD = TsGravity.FORWARD;

pub const TsShiftDir = extern enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TS_SD_BACKWARD = TsShiftDir.BACKWARD;
pub const TS_SD_FORWARD = TsShiftDir.FORWARD;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAnchor_Value = @import("../zig.zig").Guid.initString("0feb7e34-5a60-4356-8ef7-abdec2ff7cf8");
pub const IID_IAnchor = &IID_IAnchor_Value;
pub const IAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGravity: fn(
            self: *const IAnchor,
            gravity: TsGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const IAnchor,
            pgravity: *TsGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IAnchor,
            paWith: *IAnchor,
            pfEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const IAnchor,
            paWith: *IAnchor,
            plResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shift: fn(
            self: *const IAnchor,
            dwFlags: u32,
            cchReq: i32,
            pcch: *i32,
            paHaltAnchor: *IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftTo: fn(
            self: *const IAnchor,
            paSite: *IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftRegion: fn(
            self: *const IAnchor,
            dwFlags: u32,
            dir: TsShiftDir,
            pfNoRegion: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChangeHistoryMask: fn(
            self: *const IAnchor,
            dwMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChangeHistory: fn(
            self: *const IAnchor,
            pdwHistory: *ANCHOR_CHANGE_HISTORY_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearChangeHistory: fn(
            self: *const IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IAnchor,
            ppaClone: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_SetGravity(self: *const T, gravity: TsGravity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).SetGravity(@ptrCast(*const IAnchor, self), gravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_GetGravity(self: *const T, pgravity: *TsGravity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).GetGravity(@ptrCast(*const IAnchor, self), pgravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_IsEqual(self: *const T, paWith: *IAnchor, pfEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).IsEqual(@ptrCast(*const IAnchor, self), paWith, pfEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_Compare(self: *const T, paWith: *IAnchor, plResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).Compare(@ptrCast(*const IAnchor, self), paWith, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_Shift(self: *const T, dwFlags: u32, cchReq: i32, pcch: *i32, paHaltAnchor: *IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).Shift(@ptrCast(*const IAnchor, self), dwFlags, cchReq, pcch, paHaltAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_ShiftTo(self: *const T, paSite: *IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).ShiftTo(@ptrCast(*const IAnchor, self), paSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_ShiftRegion(self: *const T, dwFlags: u32, dir: TsShiftDir, pfNoRegion: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).ShiftRegion(@ptrCast(*const IAnchor, self), dwFlags, dir, pfNoRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_SetChangeHistoryMask(self: *const T, dwMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).SetChangeHistoryMask(@ptrCast(*const IAnchor, self), dwMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_GetChangeHistory(self: *const T, pdwHistory: *ANCHOR_CHANGE_HISTORY_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).GetChangeHistory(@ptrCast(*const IAnchor, self), pdwHistory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_ClearChangeHistory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).ClearChangeHistory(@ptrCast(*const IAnchor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchor_Clone(self: *const T, ppaClone: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnchor.VTable, self.vtable).Clone(@ptrCast(*const IAnchor, self), ppaClone);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchor_Value = @import("../zig.zig").Guid.initString("9b2077b0-5f18-4dec-bee9-3cc722f5dfe0");
pub const IID_ITextStoreAnchor = &IID_ITextStoreAnchor_Value;
pub const ITextStoreAnchor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: fn(
            self: *const ITextStoreAnchor,
            riid: *const Guid,
            punk: *IUnknown,
            dwMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: fn(
            self: *const ITextStoreAnchor,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestLock: fn(
            self: *const ITextStoreAnchor,
            dwLockFlags: u32,
            phrSession: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITextStoreAnchor,
            pdcs: *TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsert: fn(
            self: *const ITextStoreAnchor,
            paTestStart: *IAnchor,
            paTestEnd: *IAnchor,
            cch: u32,
            ppaResultStart: **IAnchor,
            ppaResultEnd: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextStoreAnchor,
            ulIndex: u32,
            ulCount: u32,
            pSelection: [*]TS_SELECTION_ANCHOR,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const ITextStoreAnchor,
            ulCount: u32,
            pSelection: [*]const TS_SELECTION_ANCHOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            pchText: [*:0]u16,
            cchReq: u32,
            pcch: *u32,
            fUpdateAnchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            pchText: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextStoreAnchor,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            ppDataObject: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            paPos: *IAnchor,
            rguidService: *const Guid,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            pDataObject: *IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSupportedAttrs: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsAtPosition: fn(
            self: *const ITextStoreAnchor,
            paPos: *IAnchor,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAttrsTransitioningAtPosition: fn(
            self: *const ITextStoreAnchor,
            paPos: *IAnchor,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextAttrTransition: fn(
            self: *const ITextStoreAnchor,
            paStart: *IAnchor,
            paHalt: *IAnchor,
            cFilterAttrs: u32,
            paFilterAttrs: [*]const Guid,
            dwFlags: u32,
            pfFound: *BOOL,
            plFoundOffset: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrieveRequestedAttrs: fn(
            self: *const ITextStoreAnchor,
            ulCount: u32,
            paAttrVals: [*]TS_ATTRVAL,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITextStoreAnchor,
            ppaStart: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITextStoreAnchor,
            ppaEnd: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: fn(
            self: *const ITextStoreAnchor,
            pvcView: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnchorFromPoint: fn(
            self: *const ITextStoreAnchor,
            vcView: u32,
            ptScreen: *const POINT,
            dwFlags: u32,
            ppaSite: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: fn(
            self: *const ITextStoreAnchor,
            vcView: u32,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            prc: *RECT,
            pfClipped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: fn(
            self: *const ITextStoreAnchor,
            vcView: u32,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: fn(
            self: *const ITextStoreAnchor,
            vcView: u32,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertEmbedded: fn(
            self: *const ITextStoreAnchor,
            pguidService: *const Guid,
            pFormatEtc: *const FORMATETC,
            pfInsertable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextAtSelection: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            pchText: [*:0]const u16,
            cch: u32,
            ppaStart: **IAnchor,
            ppaEnd: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: fn(
            self: *const ITextStoreAnchor,
            dwFlags: u32,
            pDataObject: *IDataObject,
            ppaStart: **IAnchor,
            ppaEnd: **IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_AdviseSink(self: *const T, riid: *const Guid, punk: *IUnknown, dwMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).AdviseSink(@ptrCast(*const ITextStoreAnchor, self), riid, punk, dwMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_UnadviseSink(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).UnadviseSink(@ptrCast(*const ITextStoreAnchor, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_RequestLock(self: *const T, dwLockFlags: u32, phrSession: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).RequestLock(@ptrCast(*const ITextStoreAnchor, self), dwLockFlags, phrSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetStatus(self: *const T, pdcs: *TS_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetStatus(@ptrCast(*const ITextStoreAnchor, self), pdcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_QueryInsert(self: *const T, paTestStart: *IAnchor, paTestEnd: *IAnchor, cch: u32, ppaResultStart: **IAnchor, ppaResultEnd: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).QueryInsert(@ptrCast(*const ITextStoreAnchor, self), paTestStart, paTestEnd, cch, ppaResultStart, ppaResultEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetSelection(self: *const T, ulIndex: u32, ulCount: u32, pSelection: [*]TS_SELECTION_ANCHOR, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetSelection(@ptrCast(*const ITextStoreAnchor, self), ulIndex, ulCount, pSelection, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_SetSelection(self: *const T, ulCount: u32, pSelection: [*]const TS_SELECTION_ANCHOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).SetSelection(@ptrCast(*const ITextStoreAnchor, self), ulCount, pSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetText(self: *const T, dwFlags: u32, paStart: *IAnchor, paEnd: *IAnchor, pchText: [*:0]u16, cchReq: u32, pcch: *u32, fUpdateAnchor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetText(@ptrCast(*const ITextStoreAnchor, self), dwFlags, paStart, paEnd, pchText, cchReq, pcch, fUpdateAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_SetText(self: *const T, dwFlags: u32, paStart: *IAnchor, paEnd: *IAnchor, pchText: [*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).SetText(@ptrCast(*const ITextStoreAnchor, self), dwFlags, paStart, paEnd, pchText, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetFormattedText(self: *const T, paStart: *IAnchor, paEnd: *IAnchor, ppDataObject: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextStoreAnchor, self), paStart, paEnd, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetEmbedded(self: *const T, dwFlags: u32, paPos: *IAnchor, rguidService: *const Guid, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetEmbedded(@ptrCast(*const ITextStoreAnchor, self), dwFlags, paPos, rguidService, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_InsertEmbedded(self: *const T, dwFlags: u32, paStart: *IAnchor, paEnd: *IAnchor, pDataObject: *IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).InsertEmbedded(@ptrCast(*const ITextStoreAnchor, self), dwFlags, paStart, paEnd, pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_RequestSupportedAttrs(self: *const T, dwFlags: u32, cFilterAttrs: u32, paFilterAttrs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).RequestSupportedAttrs(@ptrCast(*const ITextStoreAnchor, self), dwFlags, cFilterAttrs, paFilterAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_RequestAttrsAtPosition(self: *const T, paPos: *IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).RequestAttrsAtPosition(@ptrCast(*const ITextStoreAnchor, self), paPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_RequestAttrsTransitioningAtPosition(self: *const T, paPos: *IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).RequestAttrsTransitioningAtPosition(@ptrCast(*const ITextStoreAnchor, self), paPos, cFilterAttrs, paFilterAttrs, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_FindNextAttrTransition(self: *const T, paStart: *IAnchor, paHalt: *IAnchor, cFilterAttrs: u32, paFilterAttrs: [*]const Guid, dwFlags: u32, pfFound: *BOOL, plFoundOffset: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).FindNextAttrTransition(@ptrCast(*const ITextStoreAnchor, self), paStart, paHalt, cFilterAttrs, paFilterAttrs, dwFlags, pfFound, plFoundOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_RetrieveRequestedAttrs(self: *const T, ulCount: u32, paAttrVals: [*]TS_ATTRVAL, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).RetrieveRequestedAttrs(@ptrCast(*const ITextStoreAnchor, self), ulCount, paAttrVals, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetStart(self: *const T, ppaStart: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetStart(@ptrCast(*const ITextStoreAnchor, self), ppaStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetEnd(self: *const T, ppaEnd: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetEnd(@ptrCast(*const ITextStoreAnchor, self), ppaEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetActiveView(self: *const T, pvcView: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetActiveView(@ptrCast(*const ITextStoreAnchor, self), pvcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetAnchorFromPoint(self: *const T, vcView: u32, ptScreen: *const POINT, dwFlags: u32, ppaSite: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetAnchorFromPoint(@ptrCast(*const ITextStoreAnchor, self), vcView, ptScreen, dwFlags, ppaSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetTextExt(self: *const T, vcView: u32, paStart: *IAnchor, paEnd: *IAnchor, prc: *RECT, pfClipped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetTextExt(@ptrCast(*const ITextStoreAnchor, self), vcView, paStart, paEnd, prc, pfClipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetScreenExt(self: *const T, vcView: u32, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetScreenExt(@ptrCast(*const ITextStoreAnchor, self), vcView, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_GetWnd(self: *const T, vcView: u32, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).GetWnd(@ptrCast(*const ITextStoreAnchor, self), vcView, phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_QueryInsertEmbedded(self: *const T, pguidService: *const Guid, pFormatEtc: *const FORMATETC, pfInsertable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).QueryInsertEmbedded(@ptrCast(*const ITextStoreAnchor, self), pguidService, pFormatEtc, pfInsertable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_InsertTextAtSelection(self: *const T, dwFlags: u32, pchText: [*:0]const u16, cch: u32, ppaStart: **IAnchor, ppaEnd: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).InsertTextAtSelection(@ptrCast(*const ITextStoreAnchor, self), dwFlags, pchText, cch, ppaStart, ppaEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchor_InsertEmbeddedAtSelection(self: *const T, dwFlags: u32, pDataObject: *IDataObject, ppaStart: **IAnchor, ppaEnd: **IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchor.VTable, self.vtable).InsertEmbeddedAtSelection(@ptrCast(*const ITextStoreAnchor, self), dwFlags, pDataObject, ppaStart, ppaEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreAnchorSink_Value = @import("../zig.zig").Guid.initString("aa80e905-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreAnchorSink = &IID_ITextStoreAnchorSink_Value;
pub const ITextStoreAnchorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTextChange: fn(
            self: *const ITextStoreAnchorSink,
            dwFlags: TEXT_STORE_CHANGE_FLAGS,
            paStart: *IAnchor,
            paEnd: *IAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: fn(
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLayoutChange: fn(
            self: *const ITextStoreAnchorSink,
            lcode: TsLayoutCode,
            vcView: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: fn(
            self: *const ITextStoreAnchorSink,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttrsChange: fn(
            self: *const ITextStoreAnchorSink,
            paStart: *IAnchor,
            paEnd: *IAnchor,
            cAttrs: u32,
            paAttrs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLockGranted: fn(
            self: *const ITextStoreAnchorSink,
            dwLockFlags: TEXT_STORE_LOCK_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStartEditTransaction: fn(
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: fn(
            self: *const ITextStoreAnchorSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnTextChange(self: *const T, dwFlags: TEXT_STORE_CHANGE_FLAGS, paStart: *IAnchor, paEnd: *IAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnTextChange(@ptrCast(*const ITextStoreAnchorSink, self), dwFlags, paStart, paEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnSelectionChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnSelectionChange(@ptrCast(*const ITextStoreAnchorSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnLayoutChange(self: *const T, lcode: TsLayoutCode, vcView: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnLayoutChange(@ptrCast(*const ITextStoreAnchorSink, self), lcode, vcView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnStatusChange(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnStatusChange(@ptrCast(*const ITextStoreAnchorSink, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnAttrsChange(self: *const T, paStart: *IAnchor, paEnd: *IAnchor, cAttrs: u32, paAttrs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnAttrsChange(@ptrCast(*const ITextStoreAnchorSink, self), paStart, paEnd, cAttrs, paAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnLockGranted(self: *const T, dwLockFlags: TEXT_STORE_LOCK_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnLockGranted(@ptrCast(*const ITextStoreAnchorSink, self), dwLockFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnStartEditTransaction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnStartEditTransaction(@ptrCast(*const ITextStoreAnchorSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorSink_OnEndEditTransaction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorSink.VTable, self.vtable).OnEndEditTransaction(@ptrCast(*const ITextStoreAnchorSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarMgr_Value = @import("../zig.zig").Guid.initString("87955690-e627-11d2-8ddb-00105a2799b5");
pub const IID_ITfLangBarMgr = &IID_ITfLangBarMgr_Value;
pub const ITfLangBarMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseEventSink: fn(
            self: *const ITfLangBarMgr,
            pSink: *ITfLangBarEventSink,
            hwnd: HWND,
            dwFlags: u32,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseEventSink: fn(
            self: *const ITfLangBarMgr,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadMarshalInterface: fn(
            self: *const ITfLangBarMgr,
            dwThreadId: u32,
            dwType: u32,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadLangBarItemMgr: fn(
            self: *const ITfLangBarMgr,
            dwThreadId: u32,
            pplbi: **ITfLangBarItemMgr,
            pdwThreadid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputProcessorProfiles: fn(
            self: *const ITfLangBarMgr,
            dwThreadId: u32,
            ppaip: **ITfInputProcessorProfiles,
            pdwThreadid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreLastFocus: fn(
            self: *const ITfLangBarMgr,
            pdwThreadId: *u32,
            fPrev: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModalInput: fn(
            self: *const ITfLangBarMgr,
            pSink: *ITfLangBarEventSink,
            dwThreadId: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowFloating: fn(
            self: *const ITfLangBarMgr,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowFloatingStatus: fn(
            self: *const ITfLangBarMgr,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_AdviseEventSink(self: *const T, pSink: *ITfLangBarEventSink, hwnd: HWND, dwFlags: u32, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).AdviseEventSink(@ptrCast(*const ITfLangBarMgr, self), pSink, hwnd, dwFlags, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_UnadviseEventSink(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).UnadviseEventSink(@ptrCast(*const ITfLangBarMgr, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_GetThreadMarshalInterface(self: *const T, dwThreadId: u32, dwType: u32, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).GetThreadMarshalInterface(@ptrCast(*const ITfLangBarMgr, self), dwThreadId, dwType, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_GetThreadLangBarItemMgr(self: *const T, dwThreadId: u32, pplbi: **ITfLangBarItemMgr, pdwThreadid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).GetThreadLangBarItemMgr(@ptrCast(*const ITfLangBarMgr, self), dwThreadId, pplbi, pdwThreadid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_GetInputProcessorProfiles(self: *const T, dwThreadId: u32, ppaip: **ITfInputProcessorProfiles, pdwThreadid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).GetInputProcessorProfiles(@ptrCast(*const ITfLangBarMgr, self), dwThreadId, ppaip, pdwThreadid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_RestoreLastFocus(self: *const T, pdwThreadId: *u32, fPrev: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).RestoreLastFocus(@ptrCast(*const ITfLangBarMgr, self), pdwThreadId, fPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_SetModalInput(self: *const T, pSink: *ITfLangBarEventSink, dwThreadId: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).SetModalInput(@ptrCast(*const ITfLangBarMgr, self), pSink, dwThreadId, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_ShowFloating(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).ShowFloating(@ptrCast(*const ITfLangBarMgr, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarMgr_GetShowFloatingStatus(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarMgr.VTable, self.vtable).GetShowFloatingStatus(@ptrCast(*const ITfLangBarMgr, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarEventSink_Value = @import("../zig.zig").Guid.initString("18a4e900-e0ae-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarEventSink = &IID_ITfLangBarEventSink_Value;
pub const ITfLangBarEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: fn(
            self: *const ITfLangBarEventSink,
            dwThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnThreadTerminate: fn(
            self: *const ITfLangBarEventSink,
            dwThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnThreadItemChange: fn(
            self: *const ITfLangBarEventSink,
            dwThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnModalInput: fn(
            self: *const ITfLangBarEventSink,
            dwThreadId: u32,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowFloating: fn(
            self: *const ITfLangBarEventSink,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFloatingRect: fn(
            self: *const ITfLangBarEventSink,
            dwThreadId: u32,
            rguid: *const Guid,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_OnSetFocus(self: *const T, dwThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).OnSetFocus(@ptrCast(*const ITfLangBarEventSink, self), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_OnThreadTerminate(self: *const T, dwThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).OnThreadTerminate(@ptrCast(*const ITfLangBarEventSink, self), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_OnThreadItemChange(self: *const T, dwThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).OnThreadItemChange(@ptrCast(*const ITfLangBarEventSink, self), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_OnModalInput(self: *const T, dwThreadId: u32, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).OnModalInput(@ptrCast(*const ITfLangBarEventSink, self), dwThreadId, uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_ShowFloating(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).ShowFloating(@ptrCast(*const ITfLangBarEventSink, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarEventSink_GetItemFloatingRect(self: *const T, dwThreadId: u32, rguid: *const Guid, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarEventSink.VTable, self.vtable).GetItemFloatingRect(@ptrCast(*const ITfLangBarEventSink, self), dwThreadId, rguid, prc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemSink_Value = @import("../zig.zig").Guid.initString("57dbe1a0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemSink = &IID_ITfLangBarItemSink_Value;
pub const ITfLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdate: fn(
            self: *const ITfLangBarItemSink,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemSink_OnUpdate(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemSink.VTable, self.vtable).OnUpdate(@ptrCast(*const ITfLangBarItemSink, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLangBarItems_Value = @import("../zig.zig").Guid.initString("583f34d0-de25-11d2-afdd-00105a2799b5");
pub const IID_IEnumTfLangBarItems = &IID_IEnumTfLangBarItems_Value;
pub const IEnumTfLangBarItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfLangBarItems,
            ppEnum: **IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfLangBarItems,
            ulCount: u32,
            ppItem: [*]*ITfLangBarItem,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfLangBarItems,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLangBarItems_Clone(self: *const T, ppEnum: **IEnumTfLangBarItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLangBarItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfLangBarItems, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLangBarItems_Next(self: *const T, ulCount: u32, ppItem: [*]*ITfLangBarItem, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLangBarItems.VTable, self.vtable).Next(@ptrCast(*const IEnumTfLangBarItems, self), ulCount, ppItem, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLangBarItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLangBarItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfLangBarItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLangBarItems_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLangBarItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfLangBarItems, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LANGBARITEMINFO = extern struct {
    clsidService: Guid,
    guidItem: Guid,
    dwStyle: u32,
    ulSort: u32,
    szDescription: [32]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemMgr_Value = @import("../zig.zig").Guid.initString("ba468c55-9956-4fb1-a59d-52a7dd7cc6aa");
pub const IID_ITfLangBarItemMgr = &IID_ITfLangBarItemMgr_Value;
pub const ITfLangBarItemMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumItems: fn(
            self: *const ITfLangBarItemMgr,
            ppEnum: **IEnumTfLangBarItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const ITfLangBarItemMgr,
            rguid: *const Guid,
            ppItem: **ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddItem: fn(
            self: *const ITfLangBarItemMgr,
            punk: *ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveItem: fn(
            self: *const ITfLangBarItemMgr,
            punk: *ITfLangBarItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseItemSink: fn(
            self: *const ITfLangBarItemMgr,
            punk: *ITfLangBarItemSink,
            pdwCookie: *u32,
            rguidItem: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseItemSink: fn(
            self: *const ITfLangBarItemMgr,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFloatingRect: fn(
            self: *const ITfLangBarItemMgr,
            dwThreadId: u32,
            rguid: *const Guid,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsStatus: fn(
            self: *const ITfLangBarItemMgr,
            ulCount: u32,
            prgguid: [*]const Guid,
            pdwStatus: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemNum: fn(
            self: *const ITfLangBarItemMgr,
            pulCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItems: fn(
            self: *const ITfLangBarItemMgr,
            ulCount: u32,
            ppItem: [*]*ITfLangBarItem,
            pInfo: [*]TF_LANGBARITEMINFO,
            pdwStatus: [*]u32,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseItemsSink: fn(
            self: *const ITfLangBarItemMgr,
            ulCount: u32,
            ppunk: [*]*ITfLangBarItemSink,
            pguidItem: [*]const Guid,
            pdwCookie: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseItemsSink: fn(
            self: *const ITfLangBarItemMgr,
            ulCount: u32,
            pdwCookie: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_EnumItems(self: *const T, ppEnum: **IEnumTfLangBarItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).EnumItems(@ptrCast(*const ITfLangBarItemMgr, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_GetItem(self: *const T, rguid: *const Guid, ppItem: **ITfLangBarItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).GetItem(@ptrCast(*const ITfLangBarItemMgr, self), rguid, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_AddItem(self: *const T, punk: *ITfLangBarItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).AddItem(@ptrCast(*const ITfLangBarItemMgr, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_RemoveItem(self: *const T, punk: *ITfLangBarItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).RemoveItem(@ptrCast(*const ITfLangBarItemMgr, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_AdviseItemSink(self: *const T, punk: *ITfLangBarItemSink, pdwCookie: *u32, rguidItem: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).AdviseItemSink(@ptrCast(*const ITfLangBarItemMgr, self), punk, pdwCookie, rguidItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_UnadviseItemSink(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).UnadviseItemSink(@ptrCast(*const ITfLangBarItemMgr, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_GetItemFloatingRect(self: *const T, dwThreadId: u32, rguid: *const Guid, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).GetItemFloatingRect(@ptrCast(*const ITfLangBarItemMgr, self), dwThreadId, rguid, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_GetItemsStatus(self: *const T, ulCount: u32, prgguid: [*]const Guid, pdwStatus: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).GetItemsStatus(@ptrCast(*const ITfLangBarItemMgr, self), ulCount, prgguid, pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_GetItemNum(self: *const T, pulCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).GetItemNum(@ptrCast(*const ITfLangBarItemMgr, self), pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_GetItems(self: *const T, ulCount: u32, ppItem: [*]*ITfLangBarItem, pInfo: [*]TF_LANGBARITEMINFO, pdwStatus: [*]u32, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).GetItems(@ptrCast(*const ITfLangBarItemMgr, self), ulCount, ppItem, pInfo, pdwStatus, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_AdviseItemsSink(self: *const T, ulCount: u32, ppunk: [*]*ITfLangBarItemSink, pguidItem: [*]const Guid, pdwCookie: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).AdviseItemsSink(@ptrCast(*const ITfLangBarItemMgr, self), ulCount, ppunk, pguidItem, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemMgr_UnadviseItemsSink(self: *const T, ulCount: u32, pdwCookie: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemMgr.VTable, self.vtable).UnadviseItemsSink(@ptrCast(*const ITfLangBarItemMgr, self), ulCount, pdwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItem_Value = @import("../zig.zig").Guid.initString("73540d69-edeb-4ee9-96c9-23aa30b25916");
pub const IID_ITfLangBarItem = &IID_ITfLangBarItem_Value;
pub const ITfLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: fn(
            self: *const ITfLangBarItem,
            pInfo: *TF_LANGBARITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITfLangBarItem,
            pdwStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const ITfLangBarItem,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTooltipString: fn(
            self: *const ITfLangBarItem,
            pbstrToolTip: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItem_GetInfo(self: *const T, pInfo: *TF_LANGBARITEMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItem.VTable, self.vtable).GetInfo(@ptrCast(*const ITfLangBarItem, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItem_GetStatus(self: *const T, pdwStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItem.VTable, self.vtable).GetStatus(@ptrCast(*const ITfLangBarItem, self), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItem_Show(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItem.VTable, self.vtable).Show(@ptrCast(*const ITfLangBarItem, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItem_GetTooltipString(self: *const T, pbstrToolTip: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItem.VTable, self.vtable).GetTooltipString(@ptrCast(*const ITfLangBarItem, self), pbstrToolTip);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemSink_Value = @import("../zig.zig").Guid.initString("1449d9ab-13cf-4687-aa3e-8d8b18574396");
pub const IID_ITfSystemLangBarItemSink = &IID_ITfSystemLangBarItemSink_Value;
pub const ITfSystemLangBarItemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitMenu: fn(
            self: *const ITfSystemLangBarItemSink,
            pMenu: *ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: fn(
            self: *const ITfSystemLangBarItemSink,
            wID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItemSink_InitMenu(self: *const T, pMenu: *ITfMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItemSink.VTable, self.vtable).InitMenu(@ptrCast(*const ITfSystemLangBarItemSink, self), pMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItemSink_OnMenuSelect(self: *const T, wID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItemSink.VTable, self.vtable).OnMenuSelect(@ptrCast(*const ITfSystemLangBarItemSink, self), wID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItem_Value = @import("../zig.zig").Guid.initString("1e13e9ec-6b33-4d4a-b5eb-8a92f029f356");
pub const IID_ITfSystemLangBarItem = &IID_ITfSystemLangBarItem_Value;
pub const ITfSystemLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIcon: fn(
            self: *const ITfSystemLangBarItem,
            hIcon: HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTooltipString: fn(
            self: *const ITfSystemLangBarItem,
            pchToolTip: [*:0]u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItem_SetIcon(self: *const T, hIcon: HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItem.VTable, self.vtable).SetIcon(@ptrCast(*const ITfSystemLangBarItem, self), hIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItem_SetTooltipString(self: *const T, pchToolTip: [*:0]u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItem.VTable, self.vtable).SetTooltipString(@ptrCast(*const ITfSystemLangBarItem, self), pchToolTip, cch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemLangBarItemText_Value = @import("../zig.zig").Guid.initString("5c4ce0e5-ba49-4b52-ac6b-3b397b4f701f");
pub const IID_ITfSystemLangBarItemText = &IID_ITfSystemLangBarItemText_Value;
pub const ITfSystemLangBarItemText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItemText: fn(
            self: *const ITfSystemLangBarItemText,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemText: fn(
            self: *const ITfSystemLangBarItemText,
            pbstrText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItemText_SetItemText(self: *const T, pch: [*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItemText.VTable, self.vtable).SetItemText(@ptrCast(*const ITfSystemLangBarItemText, self), pch, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemLangBarItemText_GetItemText(self: *const T, pbstrText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemLangBarItemText.VTable, self.vtable).GetItemText(@ptrCast(*const ITfSystemLangBarItemText, self), pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSystemDeviceTypeLangBarItem_Value = @import("../zig.zig").Guid.initString("45672eb9-9059-46a2-838d-4530355f6a77");
pub const IID_ITfSystemDeviceTypeLangBarItem = &IID_ITfSystemDeviceTypeLangBarItem_Value;
pub const ITfSystemDeviceTypeLangBarItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIconMode: fn(
            self: *const ITfSystemDeviceTypeLangBarItem,
            dwFlags: LANG_BAR_ITEM_ICON_MODE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconMode: fn(
            self: *const ITfSystemDeviceTypeLangBarItem,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemDeviceTypeLangBarItem_SetIconMode(self: *const T, dwFlags: LANG_BAR_ITEM_ICON_MODE_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemDeviceTypeLangBarItem.VTable, self.vtable).SetIconMode(@ptrCast(*const ITfSystemDeviceTypeLangBarItem, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSystemDeviceTypeLangBarItem_GetIconMode(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSystemDeviceTypeLangBarItem.VTable, self.vtable).GetIconMode(@ptrCast(*const ITfSystemDeviceTypeLangBarItem, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBIClick = extern enum(i32) {
    RIGHT = 1,
    LEFT = 2,
};
pub const TF_LBI_CLK_RIGHT = TfLBIClick.RIGHT;
pub const TF_LBI_CLK_LEFT = TfLBIClick.LEFT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemButton_Value = @import("../zig.zig").Guid.initString("28c7f1d0-de25-11d2-afdd-00105a2799b5");
pub const IID_ITfLangBarItemButton = &IID_ITfLangBarItemButton_Value;
pub const ITfLangBarItemButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: fn(
            self: *const ITfLangBarItemButton,
            click: TfLBIClick,
            pt: POINT,
            prcArea: *const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitMenu: fn(
            self: *const ITfLangBarItemButton,
            pMenu: *ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: fn(
            self: *const ITfLangBarItemButton,
            wID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const ITfLangBarItemButton,
            phIcon: *HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITfLangBarItemButton,
            pbstrText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfLangBarItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemButton_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: *const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemButton.VTable, self.vtable).OnClick(@ptrCast(*const ITfLangBarItemButton, self), click, pt, prcArea);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemButton_InitMenu(self: *const T, pMenu: *ITfMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemButton.VTable, self.vtable).InitMenu(@ptrCast(*const ITfLangBarItemButton, self), pMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemButton_OnMenuSelect(self: *const T, wID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemButton.VTable, self.vtable).OnMenuSelect(@ptrCast(*const ITfLangBarItemButton, self), wID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemButton_GetIcon(self: *const T, phIcon: *HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemButton.VTable, self.vtable).GetIcon(@ptrCast(*const ITfLangBarItemButton, self), phIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemButton_GetText(self: *const T, pbstrText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemButton.VTable, self.vtable).GetText(@ptrCast(*const ITfLangBarItemButton, self), pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmapButton_Value = @import("../zig.zig").Guid.initString("a26a0525-3fae-4fa0-89ee-88a964f9f1b5");
pub const IID_ITfLangBarItemBitmapButton = &IID_ITfLangBarItemBitmapButton_Value;
pub const ITfLangBarItemBitmapButton = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: fn(
            self: *const ITfLangBarItemBitmapButton,
            click: TfLBIClick,
            pt: POINT,
            prcArea: *const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitMenu: fn(
            self: *const ITfLangBarItemBitmapButton,
            pMenu: *ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMenuSelect: fn(
            self: *const ITfLangBarItemBitmapButton,
            wID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: fn(
            self: *const ITfLangBarItemBitmapButton,
            pszDefault: *const SIZE,
            psz: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawBitmap: fn(
            self: *const ITfLangBarItemBitmapButton,
            bmWidth: i32,
            bmHeight: i32,
            dwFlags: u32,
            phbmp: *HBITMAP,
            phbmpMask: *HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITfLangBarItemBitmapButton,
            pbstrText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfLangBarItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: *const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).OnClick(@ptrCast(*const ITfLangBarItemBitmapButton, self), click, pt, prcArea);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_InitMenu(self: *const T, pMenu: *ITfMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).InitMenu(@ptrCast(*const ITfLangBarItemBitmapButton, self), pMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_OnMenuSelect(self: *const T, wID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).OnMenuSelect(@ptrCast(*const ITfLangBarItemBitmapButton, self), wID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_GetPreferredSize(self: *const T, pszDefault: *const SIZE, psz: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).GetPreferredSize(@ptrCast(*const ITfLangBarItemBitmapButton, self), pszDefault, psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_DrawBitmap(self: *const T, bmWidth: i32, bmHeight: i32, dwFlags: u32, phbmp: *HBITMAP, phbmpMask: *HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).DrawBitmap(@ptrCast(*const ITfLangBarItemBitmapButton, self), bmWidth, bmHeight, dwFlags, phbmp, phbmpMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmapButton_GetText(self: *const T, pbstrText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmapButton.VTable, self.vtable).GetText(@ptrCast(*const ITfLangBarItemBitmapButton, self), pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBitmap_Value = @import("../zig.zig").Guid.initString("73830352-d722-4179-ada5-f045c98df355");
pub const IID_ITfLangBarItemBitmap = &IID_ITfLangBarItemBitmap_Value;
pub const ITfLangBarItemBitmap = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: fn(
            self: *const ITfLangBarItemBitmap,
            click: TfLBIClick,
            pt: POINT,
            prcArea: *const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: fn(
            self: *const ITfLangBarItemBitmap,
            pszDefault: *const SIZE,
            psz: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawBitmap: fn(
            self: *const ITfLangBarItemBitmap,
            bmWidth: i32,
            bmHeight: i32,
            dwFlags: u32,
            phbmp: *HBITMAP,
            phbmpMask: *HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfLangBarItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmap_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: *const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmap.VTable, self.vtable).OnClick(@ptrCast(*const ITfLangBarItemBitmap, self), click, pt, prcArea);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmap_GetPreferredSize(self: *const T, pszDefault: *const SIZE, psz: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmap.VTable, self.vtable).GetPreferredSize(@ptrCast(*const ITfLangBarItemBitmap, self), pszDefault, psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBitmap_DrawBitmap(self: *const T, bmWidth: i32, bmHeight: i32, dwFlags: u32, phbmp: *HBITMAP, phbmpMask: *HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBitmap.VTable, self.vtable).DrawBitmap(@ptrCast(*const ITfLangBarItemBitmap, self), bmWidth, bmHeight, dwFlags, phbmp, phbmpMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfLBBalloonStyle = extern enum(i32) {
    RECO = 0,
    SHOW = 1,
    MISS = 2,
};
pub const TF_LB_BALLOON_RECO = TfLBBalloonStyle.RECO;
pub const TF_LB_BALLOON_SHOW = TfLBBalloonStyle.SHOW;
pub const TF_LB_BALLOON_MISS = TfLBBalloonStyle.MISS;

pub const TF_LBBALLOONINFO = extern struct {
    style: TfLBBalloonStyle,
    bstrText: BSTR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLangBarItemBalloon_Value = @import("../zig.zig").Guid.initString("01c2d285-d3c7-4b7b-b5b5-d97411d0c283");
pub const IID_ITfLangBarItemBalloon = &IID_ITfLangBarItemBalloon_Value;
pub const ITfLangBarItemBalloon = extern struct {
    pub const VTable = extern struct {
        base: ITfLangBarItem.VTable,
        OnClick: fn(
            self: *const ITfLangBarItemBalloon,
            click: TfLBIClick,
            pt: POINT,
            prcArea: *const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredSize: fn(
            self: *const ITfLangBarItemBalloon,
            pszDefault: *const SIZE,
            psz: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBalloonInfo: fn(
            self: *const ITfLangBarItemBalloon,
            pInfo: *TF_LBBALLOONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfLangBarItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBalloon_OnClick(self: *const T, click: TfLBIClick, pt: POINT, prcArea: *const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBalloon.VTable, self.vtable).OnClick(@ptrCast(*const ITfLangBarItemBalloon, self), click, pt, prcArea);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBalloon_GetPreferredSize(self: *const T, pszDefault: *const SIZE, psz: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBalloon.VTable, self.vtable).GetPreferredSize(@ptrCast(*const ITfLangBarItemBalloon, self), pszDefault, psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLangBarItemBalloon_GetBalloonInfo(self: *const T, pInfo: *TF_LBBALLOONINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLangBarItemBalloon.VTable, self.vtable).GetBalloonInfo(@ptrCast(*const ITfLangBarItemBalloon, self), pInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMenu_Value = @import("../zig.zig").Guid.initString("6f8a98e4-aaa0-4f15-8c5b-07e0df0a3dd8");
pub const IID_ITfMenu = &IID_ITfMenu_Value;
pub const ITfMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMenuItem: fn(
            self: *const ITfMenu,
            uId: u32,
            dwFlags: u32,
            hbmp: HBITMAP,
            hbmpMask: HBITMAP,
            pch: [*:0]const u16,
            cch: u32,
            ppMenu: **ITfMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMenu_AddMenuItem(self: *const T, uId: u32, dwFlags: u32, hbmp: HBITMAP, hbmpMask: HBITMAP, pch: [*:0]const u16, cch: u32, ppMenu: **ITfMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMenu.VTable, self.vtable).AddMenuItem(@ptrCast(*const ITfMenu, self), uId, dwFlags, hbmp, hbmpMask, pch, cch, ppMenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PERSISTENT_PROPERTY_HEADER_ACP = extern struct {
    guidType: Guid,
    ichStart: i32,
    cch: i32,
    cb: u32,
    dwPrivate: u32,
    clsidTIP: Guid,
};

pub const TF_LANGUAGEPROFILE = extern struct {
    clsid: Guid,
    langid: u16,
    catid: Guid,
    fActive: BOOL,
    guidProfile: Guid,
};

pub const TfAnchor = extern enum(i32) {
    START = 0,
    END = 1,
};
pub const TF_ANCHOR_START = TfAnchor.START;
pub const TF_ANCHOR_END = TfAnchor.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgr_Value = @import("../zig.zig").Guid.initString("aa80e801-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgr = &IID_ITfThreadMgr_Value;
pub const ITfThreadMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: fn(
            self: *const ITfThreadMgr,
            ptid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const ITfThreadMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDocumentMgr: fn(
            self: *const ITfThreadMgr,
            ppdim: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDocumentMgrs: fn(
            self: *const ITfThreadMgr,
            ppEnum: **IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: fn(
            self: *const ITfThreadMgr,
            ppdimFocus: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const ITfThreadMgr,
            pdimFocus: *ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateFocus: fn(
            self: *const ITfThreadMgr,
            hwnd: HWND,
            pdimNew: *ITfDocumentMgr,
            ppdimPrev: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsThreadFocus: fn(
            self: *const ITfThreadMgr,
            pfThreadFocus: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionProvider: fn(
            self: *const ITfThreadMgr,
            clsid: *const Guid,
            ppFuncProv: **ITfFunctionProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFunctionProviders: fn(
            self: *const ITfThreadMgr,
            ppEnum: **IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalCompartment: fn(
            self: *const ITfThreadMgr,
            ppCompMgr: **ITfCompartmentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_Activate(self: *const T, ptid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).Activate(@ptrCast(*const ITfThreadMgr, self), ptid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).Deactivate(@ptrCast(*const ITfThreadMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_CreateDocumentMgr(self: *const T, ppdim: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).CreateDocumentMgr(@ptrCast(*const ITfThreadMgr, self), ppdim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_EnumDocumentMgrs(self: *const T, ppEnum: **IEnumTfDocumentMgrs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).EnumDocumentMgrs(@ptrCast(*const ITfThreadMgr, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_GetFocus(self: *const T, ppdimFocus: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).GetFocus(@ptrCast(*const ITfThreadMgr, self), ppdimFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_SetFocus(self: *const T, pdimFocus: *ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).SetFocus(@ptrCast(*const ITfThreadMgr, self), pdimFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_AssociateFocus(self: *const T, hwnd: HWND, pdimNew: *ITfDocumentMgr, ppdimPrev: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).AssociateFocus(@ptrCast(*const ITfThreadMgr, self), hwnd, pdimNew, ppdimPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_IsThreadFocus(self: *const T, pfThreadFocus: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).IsThreadFocus(@ptrCast(*const ITfThreadMgr, self), pfThreadFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_GetFunctionProvider(self: *const T, clsid: *const Guid, ppFuncProv: **ITfFunctionProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).GetFunctionProvider(@ptrCast(*const ITfThreadMgr, self), clsid, ppFuncProv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_EnumFunctionProviders(self: *const T, ppEnum: **IEnumTfFunctionProviders) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).EnumFunctionProviders(@ptrCast(*const ITfThreadMgr, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr_GetGlobalCompartment(self: *const T, ppCompMgr: **ITfCompartmentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr.VTable, self.vtable).GetGlobalCompartment(@ptrCast(*const ITfThreadMgr, self), ppCompMgr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEx_Value = @import("../zig.zig").Guid.initString("3e90ade3-7594-4cb0-bb58-69628f5f458c");
pub const IID_ITfThreadMgrEx = &IID_ITfThreadMgrEx_Value;
pub const ITfThreadMgrEx = extern struct {
    pub const VTable = extern struct {
        base: ITfThreadMgr.VTable,
        ActivateEx: fn(
            self: *const ITfThreadMgrEx,
            ptid: *u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveFlags: fn(
            self: *const ITfThreadMgrEx,
            lpdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfThreadMgr.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEx_ActivateEx(self: *const T, ptid: *u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEx.VTable, self.vtable).ActivateEx(@ptrCast(*const ITfThreadMgrEx, self), ptid, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEx_GetActiveFlags(self: *const T, lpdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEx.VTable, self.vtable).GetActiveFlags(@ptrCast(*const ITfThreadMgrEx, self), lpdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfThreadMgr2_Value = @import("../zig.zig").Guid.initString("0ab198ef-6477-4ee8-8812-6780edb82d5e");
pub const IID_ITfThreadMgr2 = &IID_ITfThreadMgr2_Value;
pub const ITfThreadMgr2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: fn(
            self: *const ITfThreadMgr2,
            ptid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDocumentMgr: fn(
            self: *const ITfThreadMgr2,
            ppdim: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDocumentMgrs: fn(
            self: *const ITfThreadMgr2,
            ppEnum: **IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: fn(
            self: *const ITfThreadMgr2,
            ppdimFocus: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const ITfThreadMgr2,
            pdimFocus: *ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsThreadFocus: fn(
            self: *const ITfThreadMgr2,
            pfThreadFocus: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionProvider: fn(
            self: *const ITfThreadMgr2,
            clsid: *const Guid,
            ppFuncProv: **ITfFunctionProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFunctionProviders: fn(
            self: *const ITfThreadMgr2,
            ppEnum: **IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalCompartment: fn(
            self: *const ITfThreadMgr2,
            ppCompMgr: **ITfCompartmentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateEx: fn(
            self: *const ITfThreadMgr2,
            ptid: *u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveFlags: fn(
            self: *const ITfThreadMgr2,
            lpdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendKeystrokeHandling: fn(
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeKeystrokeHandling: fn(
            self: *const ITfThreadMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_Activate(self: *const T, ptid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).Activate(@ptrCast(*const ITfThreadMgr2, self), ptid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).Deactivate(@ptrCast(*const ITfThreadMgr2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_CreateDocumentMgr(self: *const T, ppdim: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).CreateDocumentMgr(@ptrCast(*const ITfThreadMgr2, self), ppdim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_EnumDocumentMgrs(self: *const T, ppEnum: **IEnumTfDocumentMgrs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).EnumDocumentMgrs(@ptrCast(*const ITfThreadMgr2, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_GetFocus(self: *const T, ppdimFocus: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).GetFocus(@ptrCast(*const ITfThreadMgr2, self), ppdimFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_SetFocus(self: *const T, pdimFocus: *ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).SetFocus(@ptrCast(*const ITfThreadMgr2, self), pdimFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_IsThreadFocus(self: *const T, pfThreadFocus: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).IsThreadFocus(@ptrCast(*const ITfThreadMgr2, self), pfThreadFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_GetFunctionProvider(self: *const T, clsid: *const Guid, ppFuncProv: **ITfFunctionProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).GetFunctionProvider(@ptrCast(*const ITfThreadMgr2, self), clsid, ppFuncProv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_EnumFunctionProviders(self: *const T, ppEnum: **IEnumTfFunctionProviders) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).EnumFunctionProviders(@ptrCast(*const ITfThreadMgr2, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_GetGlobalCompartment(self: *const T, ppCompMgr: **ITfCompartmentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).GetGlobalCompartment(@ptrCast(*const ITfThreadMgr2, self), ppCompMgr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_ActivateEx(self: *const T, ptid: *u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).ActivateEx(@ptrCast(*const ITfThreadMgr2, self), ptid, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_GetActiveFlags(self: *const T, lpdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).GetActiveFlags(@ptrCast(*const ITfThreadMgr2, self), lpdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_SuspendKeystrokeHandling(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).SuspendKeystrokeHandling(@ptrCast(*const ITfThreadMgr2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgr2_ResumeKeystrokeHandling(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgr2.VTable, self.vtable).ResumeKeystrokeHandling(@ptrCast(*const ITfThreadMgr2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadMgrEventSink_Value = @import("../zig.zig").Guid.initString("aa80e80e-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfThreadMgrEventSink = &IID_ITfThreadMgrEventSink_Value;
pub const ITfThreadMgrEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInitDocumentMgr: fn(
            self: *const ITfThreadMgrEventSink,
            pdim: *ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUninitDocumentMgr: fn(
            self: *const ITfThreadMgrEventSink,
            pdim: *ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSetFocus: fn(
            self: *const ITfThreadMgrEventSink,
            pdimFocus: *ITfDocumentMgr,
            pdimPrevFocus: *ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPushContext: fn(
            self: *const ITfThreadMgrEventSink,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPopContext: fn(
            self: *const ITfThreadMgrEventSink,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEventSink_OnInitDocumentMgr(self: *const T, pdim: *ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEventSink.VTable, self.vtable).OnInitDocumentMgr(@ptrCast(*const ITfThreadMgrEventSink, self), pdim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEventSink_OnUninitDocumentMgr(self: *const T, pdim: *ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEventSink.VTable, self.vtable).OnUninitDocumentMgr(@ptrCast(*const ITfThreadMgrEventSink, self), pdim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEventSink_OnSetFocus(self: *const T, pdimFocus: *ITfDocumentMgr, pdimPrevFocus: *ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEventSink.VTable, self.vtable).OnSetFocus(@ptrCast(*const ITfThreadMgrEventSink, self), pdimFocus, pdimPrevFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEventSink_OnPushContext(self: *const T, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEventSink.VTable, self.vtable).OnPushContext(@ptrCast(*const ITfThreadMgrEventSink, self), pic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadMgrEventSink_OnPopContext(self: *const T, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadMgrEventSink.VTable, self.vtable).OnPopContext(@ptrCast(*const ITfThreadMgrEventSink, self), pic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfConfigureSystemKeystrokeFeed_Value = @import("../zig.zig").Guid.initString("0d2c969a-bc9c-437c-84ee-951c49b1a764");
pub const IID_ITfConfigureSystemKeystrokeFeed = &IID_ITfConfigureSystemKeystrokeFeed_Value;
pub const ITfConfigureSystemKeystrokeFeed = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DisableSystemKeystrokeFeed: fn(
            self: *const ITfConfigureSystemKeystrokeFeed,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSystemKeystrokeFeed: fn(
            self: *const ITfConfigureSystemKeystrokeFeed,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfConfigureSystemKeystrokeFeed.VTable, self.vtable).DisableSystemKeystrokeFeed(@ptrCast(*const ITfConfigureSystemKeystrokeFeed, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfConfigureSystemKeystrokeFeed.VTable, self.vtable).EnableSystemKeystrokeFeed(@ptrCast(*const ITfConfigureSystemKeystrokeFeed, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDocumentMgrs_Value = @import("../zig.zig").Guid.initString("aa80e808-2021-11d2-93e0-0060b067b86e");
pub const IID_IEnumTfDocumentMgrs = &IID_IEnumTfDocumentMgrs_Value;
pub const IEnumTfDocumentMgrs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfDocumentMgrs,
            ppEnum: **IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfDocumentMgrs,
            ulCount: u32,
            rgDocumentMgr: [*]*ITfDocumentMgr,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfDocumentMgrs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfDocumentMgrs,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDocumentMgrs_Clone(self: *const T, ppEnum: **IEnumTfDocumentMgrs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDocumentMgrs.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfDocumentMgrs, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDocumentMgrs_Next(self: *const T, ulCount: u32, rgDocumentMgr: [*]*ITfDocumentMgr, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDocumentMgrs.VTable, self.vtable).Next(@ptrCast(*const IEnumTfDocumentMgrs, self), ulCount, rgDocumentMgr, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDocumentMgrs_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDocumentMgrs.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfDocumentMgrs, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDocumentMgrs_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDocumentMgrs.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfDocumentMgrs, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDocumentMgr_Value = @import("../zig.zig").Guid.initString("aa80e7f4-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfDocumentMgr = &IID_ITfDocumentMgr_Value;
pub const ITfDocumentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: fn(
            self: *const ITfDocumentMgr,
            tidOwner: u32,
            dwFlags: u32,
            punk: *IUnknown,
            ppic: **ITfContext,
            pecTextStore: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const ITfDocumentMgr,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pop: fn(
            self: *const ITfDocumentMgr,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTop: fn(
            self: *const ITfDocumentMgr,
            ppic: **ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBase: fn(
            self: *const ITfDocumentMgr,
            ppic: **ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumContexts: fn(
            self: *const ITfDocumentMgr,
            ppEnum: **IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_CreateContext(self: *const T, tidOwner: u32, dwFlags: u32, punk: *IUnknown, ppic: **ITfContext, pecTextStore: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).CreateContext(@ptrCast(*const ITfDocumentMgr, self), tidOwner, dwFlags, punk, ppic, pecTextStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_Push(self: *const T, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).Push(@ptrCast(*const ITfDocumentMgr, self), pic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_Pop(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).Pop(@ptrCast(*const ITfDocumentMgr, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_GetTop(self: *const T, ppic: **ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).GetTop(@ptrCast(*const ITfDocumentMgr, self), ppic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_GetBase(self: *const T, ppic: **ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).GetBase(@ptrCast(*const ITfDocumentMgr, self), ppic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDocumentMgr_EnumContexts(self: *const T, ppEnum: **IEnumTfContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDocumentMgr.VTable, self.vtable).EnumContexts(@ptrCast(*const ITfDocumentMgr, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfContexts_Value = @import("../zig.zig").Guid.initString("8f1a7ea6-1654-4502-a86e-b2902344d507");
pub const IID_IEnumTfContexts = &IID_IEnumTfContexts_Value;
pub const IEnumTfContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfContexts,
            ppEnum: **IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfContexts,
            ulCount: u32,
            rgContext: [*]*ITfContext,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfContexts,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContexts_Clone(self: *const T, ppEnum: **IEnumTfContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContexts.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfContexts, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContexts_Next(self: *const T, ulCount: u32, rgContext: [*]*ITfContext, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContexts.VTable, self.vtable).Next(@ptrCast(*const IEnumTfContexts, self), ulCount, rgContext, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContexts.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfContexts, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContexts_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContexts.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfContexts, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionView_Value = @import("../zig.zig").Guid.initString("d7540241-f9a1-4364-befc-dbcd2c4395b7");
pub const IID_ITfCompositionView = &IID_ITfCompositionView_Value;
pub const ITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOwnerClsid: fn(
            self: *const ITfCompositionView,
            pclsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: fn(
            self: *const ITfCompositionView,
            ppRange: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompositionView_GetOwnerClsid(self: *const T, pclsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompositionView.VTable, self.vtable).GetOwnerClsid(@ptrCast(*const ITfCompositionView, self), pclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompositionView_GetRange(self: *const T, ppRange: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompositionView.VTable, self.vtable).GetRange(@ptrCast(*const ITfCompositionView, self), ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumITfCompositionView_Value = @import("../zig.zig").Guid.initString("5efd22ba-7838-46cb-88e2-cadb14124f8f");
pub const IID_IEnumITfCompositionView = &IID_IEnumITfCompositionView_Value;
pub const IEnumITfCompositionView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumITfCompositionView,
            ppEnum: **IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumITfCompositionView,
            ulCount: u32,
            rgCompositionView: [*]*ITfCompositionView,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumITfCompositionView,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumITfCompositionView_Clone(self: *const T, ppEnum: **IEnumITfCompositionView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumITfCompositionView.VTable, self.vtable).Clone(@ptrCast(*const IEnumITfCompositionView, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumITfCompositionView_Next(self: *const T, ulCount: u32, rgCompositionView: [*]*ITfCompositionView, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumITfCompositionView.VTable, self.vtable).Next(@ptrCast(*const IEnumITfCompositionView, self), ulCount, rgCompositionView, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumITfCompositionView_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumITfCompositionView.VTable, self.vtable).Reset(@ptrCast(*const IEnumITfCompositionView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumITfCompositionView_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumITfCompositionView.VTable, self.vtable).Skip(@ptrCast(*const IEnumITfCompositionView, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfComposition_Value = @import("../zig.zig").Guid.initString("20168d64-5a8f-4a5a-b7bd-cfa29f4d0fd9");
pub const IID_ITfComposition = &IID_ITfComposition_Value;
pub const ITfComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: fn(
            self: *const ITfComposition,
            ppRange: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStart: fn(
            self: *const ITfComposition,
            ecWrite: u32,
            pNewStart: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEnd: fn(
            self: *const ITfComposition,
            ecWrite: u32,
            pNewEnd: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndComposition: fn(
            self: *const ITfComposition,
            ecWrite: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfComposition_GetRange(self: *const T, ppRange: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfComposition.VTable, self.vtable).GetRange(@ptrCast(*const ITfComposition, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfComposition_ShiftStart(self: *const T, ecWrite: u32, pNewStart: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfComposition.VTable, self.vtable).ShiftStart(@ptrCast(*const ITfComposition, self), ecWrite, pNewStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfComposition_ShiftEnd(self: *const T, ecWrite: u32, pNewEnd: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfComposition.VTable, self.vtable).ShiftEnd(@ptrCast(*const ITfComposition, self), ecWrite, pNewEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfComposition_EndComposition(self: *const T, ecWrite: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfComposition.VTable, self.vtable).EndComposition(@ptrCast(*const ITfComposition, self), ecWrite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompositionSink_Value = @import("../zig.zig").Guid.initString("a781718c-579a-4b15-a280-32b8577acc5e");
pub const IID_ITfCompositionSink = &IID_ITfCompositionSink_Value;
pub const ITfCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCompositionTerminated: fn(
            self: *const ITfCompositionSink,
            ecWrite: u32,
            pComposition: *ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompositionSink_OnCompositionTerminated(self: *const T, ecWrite: u32, pComposition: *ITfComposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompositionSink.VTable, self.vtable).OnCompositionTerminated(@ptrCast(*const ITfCompositionSink, self), ecWrite, pComposition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextComposition_Value = @import("../zig.zig").Guid.initString("d40c8aae-ac92-4fc7-9a11-0ee0e23aa39b");
pub const IID_ITfContextComposition = &IID_ITfContextComposition_Value;
pub const ITfContextComposition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartComposition: fn(
            self: *const ITfContextComposition,
            ecWrite: u32,
            pCompositionRange: *ITfRange,
            pSink: *ITfCompositionSink,
            ppComposition: **ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCompositions: fn(
            self: *const ITfContextComposition,
            ppEnum: **IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindComposition: fn(
            self: *const ITfContextComposition,
            ecRead: u32,
            pTestRange: *ITfRange,
            ppEnum: **IEnumITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TakeOwnership: fn(
            self: *const ITfContextComposition,
            ecWrite: u32,
            pComposition: *ITfCompositionView,
            pSink: *ITfCompositionSink,
            ppComposition: **ITfComposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextComposition_StartComposition(self: *const T, ecWrite: u32, pCompositionRange: *ITfRange, pSink: *ITfCompositionSink, ppComposition: **ITfComposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextComposition.VTable, self.vtable).StartComposition(@ptrCast(*const ITfContextComposition, self), ecWrite, pCompositionRange, pSink, ppComposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextComposition_EnumCompositions(self: *const T, ppEnum: **IEnumITfCompositionView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextComposition.VTable, self.vtable).EnumCompositions(@ptrCast(*const ITfContextComposition, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextComposition_FindComposition(self: *const T, ecRead: u32, pTestRange: *ITfRange, ppEnum: **IEnumITfCompositionView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextComposition.VTable, self.vtable).FindComposition(@ptrCast(*const ITfContextComposition, self), ecRead, pTestRange, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextComposition_TakeOwnership(self: *const T, ecWrite: u32, pComposition: *ITfCompositionView, pSink: *ITfCompositionSink, ppComposition: **ITfComposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextComposition.VTable, self.vtable).TakeOwnership(@ptrCast(*const ITfContextComposition, self), ecWrite, pComposition, pSink, ppComposition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionServices_Value = @import("../zig.zig").Guid.initString("86462810-593b-4916-9764-19c08e9ce110");
pub const IID_ITfContextOwnerCompositionServices = &IID_ITfContextOwnerCompositionServices_Value;
pub const ITfContextOwnerCompositionServices = extern struct {
    pub const VTable = extern struct {
        base: ITfContextComposition.VTable,
        TerminateComposition: fn(
            self: *const ITfContextOwnerCompositionServices,
            pComposition: *ITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfContextComposition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerCompositionServices_TerminateComposition(self: *const T, pComposition: *ITfCompositionView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerCompositionServices.VTable, self.vtable).TerminateComposition(@ptrCast(*const ITfContextOwnerCompositionServices, self), pComposition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerCompositionSink_Value = @import("../zig.zig").Guid.initString("5f20aa40-b57a-4f34-96ab-3576f377cc79");
pub const IID_ITfContextOwnerCompositionSink = &IID_ITfContextOwnerCompositionSink_Value;
pub const ITfContextOwnerCompositionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartComposition: fn(
            self: *const ITfContextOwnerCompositionSink,
            pComposition: *ITfCompositionView,
            pfOk: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateComposition: fn(
            self: *const ITfContextOwnerCompositionSink,
            pComposition: *ITfCompositionView,
            pRangeNew: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndComposition: fn(
            self: *const ITfContextOwnerCompositionSink,
            pComposition: *ITfCompositionView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerCompositionSink_OnStartComposition(self: *const T, pComposition: *ITfCompositionView, pfOk: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerCompositionSink.VTable, self.vtable).OnStartComposition(@ptrCast(*const ITfContextOwnerCompositionSink, self), pComposition, pfOk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerCompositionSink_OnUpdateComposition(self: *const T, pComposition: *ITfCompositionView, pRangeNew: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerCompositionSink.VTable, self.vtable).OnUpdateComposition(@ptrCast(*const ITfContextOwnerCompositionSink, self), pComposition, pRangeNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerCompositionSink_OnEndComposition(self: *const T, pComposition: *ITfCompositionView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerCompositionSink.VTable, self.vtable).OnEndComposition(@ptrCast(*const ITfContextOwnerCompositionSink, self), pComposition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextView_Value = @import("../zig.zig").Guid.initString("2433bf8e-0f9b-435c-ba2c-180611978c30");
pub const IID_ITfContextView = &IID_ITfContextView_Value;
pub const ITfContextView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeFromPoint: fn(
            self: *const ITfContextView,
            ec: u32,
            ppt: *const POINT,
            dwFlags: u32,
            ppRange: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: fn(
            self: *const ITfContextView,
            ec: u32,
            pRange: *ITfRange,
            prc: *RECT,
            pfClipped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: fn(
            self: *const ITfContextView,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: fn(
            self: *const ITfContextView,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextView_GetRangeFromPoint(self: *const T, ec: u32, ppt: *const POINT, dwFlags: u32, ppRange: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextView.VTable, self.vtable).GetRangeFromPoint(@ptrCast(*const ITfContextView, self), ec, ppt, dwFlags, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextView_GetTextExt(self: *const T, ec: u32, pRange: *ITfRange, prc: *RECT, pfClipped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextView.VTable, self.vtable).GetTextExt(@ptrCast(*const ITfContextView, self), ec, pRange, prc, pfClipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextView_GetScreenExt(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextView.VTable, self.vtable).GetScreenExt(@ptrCast(*const ITfContextView, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextView_GetWnd(self: *const T, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextView.VTable, self.vtable).GetWnd(@ptrCast(*const ITfContextView, self), phwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTfContextViews_Value = @import("../zig.zig").Guid.initString("f0c0f8dd-cf38-44e1-bb0f-68cf0d551c78");
pub const IID_IEnumTfContextViews = &IID_IEnumTfContextViews_Value;
pub const IEnumTfContextViews = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfContextViews,
            ppEnum: **IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfContextViews,
            ulCount: u32,
            rgViews: [*]*ITfContextView,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfContextViews,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContextViews_Clone(self: *const T, ppEnum: **IEnumTfContextViews) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContextViews.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfContextViews, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContextViews_Next(self: *const T, ulCount: u32, rgViews: [*]*ITfContextView, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContextViews.VTable, self.vtable).Next(@ptrCast(*const IEnumTfContextViews, self), ulCount, rgViews, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContextViews_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContextViews.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfContextViews, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfContextViews_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfContextViews.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfContextViews, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfActiveSelEnd = extern enum(i32) {
    NONE = 0,
    START = 1,
    END = 2,
};
pub const TF_AE_NONE = TfActiveSelEnd.NONE;
pub const TF_AE_START = TfActiveSelEnd.START;
pub const TF_AE_END = TfActiveSelEnd.END;

pub const TF_SELECTIONSTYLE = extern struct {
    ase: TfActiveSelEnd,
    fInterimChar: BOOL,
};

pub const TF_SELECTION = extern struct {
    range: *ITfRange,
    style: TF_SELECTIONSTYLE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContext_Value = @import("../zig.zig").Guid.initString("aa80e7fd-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContext = &IID_ITfContext_Value;
pub const ITfContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestEditSession: fn(
            self: *const ITfContext,
            tid: u32,
            pes: *ITfEditSession,
            dwFlags: TF_CONTEXT_EDIT_CONTEXT_FLAGS,
            phrSession: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InWriteSession: fn(
            self: *const ITfContext,
            tid: u32,
            pfWriteSession: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITfContext,
            ec: u32,
            ulIndex: u32,
            ulCount: u32,
            pSelection: [*]TF_SELECTION,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const ITfContext,
            ec: u32,
            ulCount: u32,
            pSelection: [*]const TF_SELECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITfContext,
            ec: u32,
            ppStart: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITfContext,
            ec: u32,
            ppEnd: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveView: fn(
            self: *const ITfContext,
            ppView: **ITfContextView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumViews: fn(
            self: *const ITfContext,
            ppEnum: **IEnumTfContextViews,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITfContext,
            pdcs: *TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITfContext,
            guidProp: *const Guid,
            ppProp: **ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppProperty: fn(
            self: *const ITfContext,
            guidProp: *const Guid,
            ppProp: **ITfReadOnlyProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TrackProperties: fn(
            self: *const ITfContext,
            prgProp: [*]const *const Guid,
            cProp: u32,
            prgAppProp: [*]const *const Guid,
            cAppProp: u32,
            ppProperty: **ITfReadOnlyProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProperties: fn(
            self: *const ITfContext,
            ppEnum: **IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentMgr: fn(
            self: *const ITfContext,
            ppDm: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRangeBackup: fn(
            self: *const ITfContext,
            ec: u32,
            pRange: *ITfRange,
            ppBackup: **ITfRangeBackup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_RequestEditSession(self: *const T, tid: u32, pes: *ITfEditSession, dwFlags: TF_CONTEXT_EDIT_CONTEXT_FLAGS, phrSession: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).RequestEditSession(@ptrCast(*const ITfContext, self), tid, pes, dwFlags, phrSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_InWriteSession(self: *const T, tid: u32, pfWriteSession: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).InWriteSession(@ptrCast(*const ITfContext, self), tid, pfWriteSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetSelection(self: *const T, ec: u32, ulIndex: u32, ulCount: u32, pSelection: [*]TF_SELECTION, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetSelection(@ptrCast(*const ITfContext, self), ec, ulIndex, ulCount, pSelection, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_SetSelection(self: *const T, ec: u32, ulCount: u32, pSelection: [*]const TF_SELECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).SetSelection(@ptrCast(*const ITfContext, self), ec, ulCount, pSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetStart(self: *const T, ec: u32, ppStart: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetStart(@ptrCast(*const ITfContext, self), ec, ppStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetEnd(self: *const T, ec: u32, ppEnd: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetEnd(@ptrCast(*const ITfContext, self), ec, ppEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetActiveView(self: *const T, ppView: **ITfContextView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetActiveView(@ptrCast(*const ITfContext, self), ppView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_EnumViews(self: *const T, ppEnum: **IEnumTfContextViews) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).EnumViews(@ptrCast(*const ITfContext, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetStatus(self: *const T, pdcs: *TS_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetStatus(@ptrCast(*const ITfContext, self), pdcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetProperty(self: *const T, guidProp: *const Guid, ppProp: **ITfProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetProperty(@ptrCast(*const ITfContext, self), guidProp, ppProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetAppProperty(self: *const T, guidProp: *const Guid, ppProp: **ITfReadOnlyProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetAppProperty(@ptrCast(*const ITfContext, self), guidProp, ppProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_TrackProperties(self: *const T, prgProp: [*]const *const Guid, cProp: u32, prgAppProp: [*]const *const Guid, cAppProp: u32, ppProperty: **ITfReadOnlyProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).TrackProperties(@ptrCast(*const ITfContext, self), prgProp, cProp, prgAppProp, cAppProp, ppProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_EnumProperties(self: *const T, ppEnum: **IEnumTfProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).EnumProperties(@ptrCast(*const ITfContext, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_GetDocumentMgr(self: *const T, ppDm: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).GetDocumentMgr(@ptrCast(*const ITfContext, self), ppDm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContext_CreateRangeBackup(self: *const T, ec: u32, pRange: *ITfRange, ppBackup: **ITfRangeBackup) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContext.VTable, self.vtable).CreateRangeBackup(@ptrCast(*const ITfContext, self), ec, pRange, ppBackup);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfQueryEmbedded_Value = @import("../zig.zig").Guid.initString("0fab9bdb-d250-4169-84e5-6be118fdd7a8");
pub const IID_ITfQueryEmbedded = &IID_ITfQueryEmbedded_Value;
pub const ITfQueryEmbedded = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInsertEmbedded: fn(
            self: *const ITfQueryEmbedded,
            pguidService: *const Guid,
            pFormatEtc: *const FORMATETC,
            pfInsertable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfQueryEmbedded_QueryInsertEmbedded(self: *const T, pguidService: *const Guid, pFormatEtc: *const FORMATETC, pfInsertable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfQueryEmbedded.VTable, self.vtable).QueryInsertEmbedded(@ptrCast(*const ITfQueryEmbedded, self), pguidService, pFormatEtc, pfInsertable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInsertAtSelection_Value = @import("../zig.zig").Guid.initString("55ce16ba-3014-41c1-9ceb-fade1446ac6c");
pub const IID_ITfInsertAtSelection = &IID_ITfInsertAtSelection_Value;
pub const ITfInsertAtSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertTextAtSelection: fn(
            self: *const ITfInsertAtSelection,
            ec: u32,
            dwFlags: INSERT_TEXT_AT_SELECTION_FLAGS,
            pchText: [*:0]const u16,
            cch: i32,
            ppRange: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbeddedAtSelection: fn(
            self: *const ITfInsertAtSelection,
            ec: u32,
            dwFlags: u32,
            pDataObject: *IDataObject,
            ppRange: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInsertAtSelection_InsertTextAtSelection(self: *const T, ec: u32, dwFlags: INSERT_TEXT_AT_SELECTION_FLAGS, pchText: [*:0]const u16, cch: i32, ppRange: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInsertAtSelection.VTable, self.vtable).InsertTextAtSelection(@ptrCast(*const ITfInsertAtSelection, self), ec, dwFlags, pchText, cch, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInsertAtSelection_InsertEmbeddedAtSelection(self: *const T, ec: u32, dwFlags: u32, pDataObject: *IDataObject, ppRange: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInsertAtSelection.VTable, self.vtable).InsertEmbeddedAtSelection(@ptrCast(*const ITfInsertAtSelection, self), ec, dwFlags, pDataObject, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextSink_Value = @import("../zig.zig").Guid.initString("01689689-7acb-4e9b-ab7c-7ea46b12b522");
pub const IID_ITfCleanupContextSink = &IID_ITfCleanupContextSink_Value;
pub const ITfCleanupContextSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCleanupContext: fn(
            self: *const ITfCleanupContextSink,
            ecWrite: u32,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCleanupContextSink_OnCleanupContext(self: *const T, ecWrite: u32, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCleanupContextSink.VTable, self.vtable).OnCleanupContext(@ptrCast(*const ITfCleanupContextSink, self), ecWrite, pic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCleanupContextDurationSink_Value = @import("../zig.zig").Guid.initString("45c35144-154e-4797-bed8-d33ae7bf8794");
pub const IID_ITfCleanupContextDurationSink = &IID_ITfCleanupContextDurationSink_Value;
pub const ITfCleanupContextDurationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartCleanupContext: fn(
            self: *const ITfCleanupContextDurationSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndCleanupContext: fn(
            self: *const ITfCleanupContextDurationSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCleanupContextDurationSink_OnStartCleanupContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCleanupContextDurationSink.VTable, self.vtable).OnStartCleanupContext(@ptrCast(*const ITfCleanupContextDurationSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCleanupContextDurationSink_OnEndCleanupContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCleanupContextDurationSink.VTable, self.vtable).OnEndCleanupContext(@ptrCast(*const ITfCleanupContextDurationSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadOnlyProperty_Value = @import("../zig.zig").Guid.initString("17d49a3d-f8b8-4b2f-b254-52319dd64c53");
pub const IID_ITfReadOnlyProperty = &IID_ITfReadOnlyProperty_Value;
pub const ITfReadOnlyProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const ITfReadOnlyProperty,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRanges: fn(
            self: *const ITfReadOnlyProperty,
            ec: u32,
            ppEnum: **IEnumTfRanges,
            pTargetRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ITfReadOnlyProperty,
            ec: u32,
            pRange: *ITfRange,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const ITfReadOnlyProperty,
            ppContext: **ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadOnlyProperty_GetType(self: *const T, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadOnlyProperty.VTable, self.vtable).GetType(@ptrCast(*const ITfReadOnlyProperty, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadOnlyProperty_EnumRanges(self: *const T, ec: u32, ppEnum: **IEnumTfRanges, pTargetRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadOnlyProperty.VTable, self.vtable).EnumRanges(@ptrCast(*const ITfReadOnlyProperty, self), ec, ppEnum, pTargetRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadOnlyProperty_GetValue(self: *const T, ec: u32, pRange: *ITfRange, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadOnlyProperty.VTable, self.vtable).GetValue(@ptrCast(*const ITfReadOnlyProperty, self), ec, pRange, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadOnlyProperty_GetContext(self: *const T, ppContext: **ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadOnlyProperty.VTable, self.vtable).GetContext(@ptrCast(*const ITfReadOnlyProperty, self), ppContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PROPERTYVAL = extern struct {
    guidId: Guid,
    varValue: VARIANT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfPropertyValue_Value = @import("../zig.zig").Guid.initString("8ed8981b-7c10-4d7d-9fb3-ab72e9c75f72");
pub const IID_IEnumTfPropertyValue = &IID_IEnumTfPropertyValue_Value;
pub const IEnumTfPropertyValue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfPropertyValue,
            ppEnum: **IEnumTfPropertyValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfPropertyValue,
            ulCount: u32,
            rgValues: [*]TF_PROPERTYVAL,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfPropertyValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfPropertyValue,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfPropertyValue_Clone(self: *const T, ppEnum: **IEnumTfPropertyValue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfPropertyValue.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfPropertyValue, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfPropertyValue_Next(self: *const T, ulCount: u32, rgValues: [*]TF_PROPERTYVAL, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfPropertyValue.VTable, self.vtable).Next(@ptrCast(*const IEnumTfPropertyValue, self), ulCount, rgValues, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfPropertyValue_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfPropertyValue.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfPropertyValue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfPropertyValue_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfPropertyValue.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfPropertyValue, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTracker_Value = @import("../zig.zig").Guid.initString("09d146cd-a544-4132-925b-7afa8ef322d0");
pub const IID_ITfMouseTracker = &IID_ITfMouseTracker_Value;
pub const ITfMouseTracker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: fn(
            self: *const ITfMouseTracker,
            range: *ITfRange,
            pSink: *ITfMouseSink,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseMouseSink: fn(
            self: *const ITfMouseTracker,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMouseTracker_AdviseMouseSink(self: *const T, range: *ITfRange, pSink: *ITfMouseSink, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMouseTracker.VTable, self.vtable).AdviseMouseSink(@ptrCast(*const ITfMouseTracker, self), range, pSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMouseTracker_UnadviseMouseSink(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMouseTracker.VTable, self.vtable).UnadviseMouseSink(@ptrCast(*const ITfMouseTracker, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseTrackerACP_Value = @import("../zig.zig").Guid.initString("3bdd78e2-c16e-47fd-b883-ce6facc1a208");
pub const IID_ITfMouseTrackerACP = &IID_ITfMouseTrackerACP_Value;
pub const ITfMouseTrackerACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseMouseSink: fn(
            self: *const ITfMouseTrackerACP,
            range: *ITfRangeACP,
            pSink: *ITfMouseSink,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseMouseSink: fn(
            self: *const ITfMouseTrackerACP,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMouseTrackerACP_AdviseMouseSink(self: *const T, range: *ITfRangeACP, pSink: *ITfMouseSink, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMouseTrackerACP.VTable, self.vtable).AdviseMouseSink(@ptrCast(*const ITfMouseTrackerACP, self), range, pSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMouseTrackerACP_UnadviseMouseSink(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMouseTrackerACP.VTable, self.vtable).UnadviseMouseSink(@ptrCast(*const ITfMouseTrackerACP, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMouseSink_Value = @import("../zig.zig").Guid.initString("a1adaaa2-3a24-449d-ac96-5183e7f5c217");
pub const IID_ITfMouseSink = &IID_ITfMouseSink_Value;
pub const ITfMouseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMouseEvent: fn(
            self: *const ITfMouseSink,
            uEdge: u32,
            uQuadrant: u32,
            dwBtnStatus: u32,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMouseSink_OnMouseEvent(self: *const T, uEdge: u32, uQuadrant: u32, dwBtnStatus: u32, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMouseSink.VTable, self.vtable).OnMouseEvent(@ptrCast(*const ITfMouseSink, self), uEdge, uQuadrant, dwBtnStatus, pfEaten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditRecord_Value = @import("../zig.zig").Guid.initString("42d4d099-7c1a-4a89-b836-6c6f22160df0");
pub const IID_ITfEditRecord = &IID_ITfEditRecord_Value;
pub const ITfEditRecord = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelectionStatus: fn(
            self: *const ITfEditRecord,
            pfChanged: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextAndPropertyUpdates: fn(
            self: *const ITfEditRecord,
            dwFlags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS,
            prgProperties: [*]const *const Guid,
            cProperties: u32,
            ppEnum: **IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfEditRecord_GetSelectionStatus(self: *const T, pfChanged: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfEditRecord.VTable, self.vtable).GetSelectionStatus(@ptrCast(*const ITfEditRecord, self), pfChanged);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfEditRecord_GetTextAndPropertyUpdates(self: *const T, dwFlags: GET_TEXT_AND_PROPERTY_UPDATES_FLAGS, prgProperties: [*]const *const Guid, cProperties: u32, ppEnum: **IEnumTfRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfEditRecord.VTable, self.vtable).GetTextAndPropertyUpdates(@ptrCast(*const ITfEditRecord, self), dwFlags, prgProperties, cProperties, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextEditSink_Value = @import("../zig.zig").Guid.initString("8127d409-ccd3-4683-967a-b43d5b482bf7");
pub const IID_ITfTextEditSink = &IID_ITfTextEditSink_Value;
pub const ITfTextEditSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEndEdit: fn(
            self: *const ITfTextEditSink,
            pic: *ITfContext,
            ecReadOnly: u32,
            pEditRecord: *ITfEditRecord,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTextEditSink_OnEndEdit(self: *const T, pic: *ITfContext, ecReadOnly: u32, pEditRecord: *ITfEditRecord) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTextEditSink.VTable, self.vtable).OnEndEdit(@ptrCast(*const ITfTextEditSink, self), pic, ecReadOnly, pEditRecord);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfLayoutCode = extern enum(i32) {
    CREATE = 0,
    CHANGE = 1,
    DESTROY = 2,
};
pub const TF_LC_CREATE = TfLayoutCode.CREATE;
pub const TF_LC_CHANGE = TfLayoutCode.CHANGE;
pub const TF_LC_DESTROY = TfLayoutCode.DESTROY;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextLayoutSink_Value = @import("../zig.zig").Guid.initString("2af2d06a-dd5b-4927-a0b4-54f19c91fade");
pub const IID_ITfTextLayoutSink = &IID_ITfTextLayoutSink_Value;
pub const ITfTextLayoutSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: fn(
            self: *const ITfTextLayoutSink,
            pic: *ITfContext,
            lcode: TfLayoutCode,
            pView: *ITfContextView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTextLayoutSink_OnLayoutChange(self: *const T, pic: *ITfContext, lcode: TfLayoutCode, pView: *ITfContextView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTextLayoutSink.VTable, self.vtable).OnLayoutChange(@ptrCast(*const ITfTextLayoutSink, self), pic, lcode, pView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfStatusSink_Value = @import("../zig.zig").Guid.initString("6b7d8d73-b267-4f69-b32e-1ca321ce4f45");
pub const IID_ITfStatusSink = &IID_ITfStatusSink_Value;
pub const ITfStatusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStatusChange: fn(
            self: *const ITfStatusSink,
            pic: *ITfContext,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfStatusSink_OnStatusChange(self: *const T, pic: *ITfContext, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfStatusSink.VTable, self.vtable).OnStatusChange(@ptrCast(*const ITfStatusSink, self), pic, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditTransactionSink_Value = @import("../zig.zig").Guid.initString("708fbf70-b520-416b-b06c-2c41ab44f8ba");
pub const IID_ITfEditTransactionSink = &IID_ITfEditTransactionSink_Value;
pub const ITfEditTransactionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartEditTransaction: fn(
            self: *const ITfEditTransactionSink,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndEditTransaction: fn(
            self: *const ITfEditTransactionSink,
            pic: *ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfEditTransactionSink_OnStartEditTransaction(self: *const T, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfEditTransactionSink.VTable, self.vtable).OnStartEditTransaction(@ptrCast(*const ITfEditTransactionSink, self), pic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfEditTransactionSink_OnEndEditTransaction(self: *const T, pic: *ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfEditTransactionSink.VTable, self.vtable).OnEndEditTransaction(@ptrCast(*const ITfEditTransactionSink, self), pic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwner_Value = @import("../zig.zig").Guid.initString("aa80e80c-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfContextOwner = &IID_ITfContextOwner_Value;
pub const ITfContextOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetACPFromPoint: fn(
            self: *const ITfContextOwner,
            ptScreen: *const POINT,
            dwFlags: u32,
            pacp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextExt: fn(
            self: *const ITfContextOwner,
            acpStart: i32,
            acpEnd: i32,
            prc: *RECT,
            pfClipped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScreenExt: fn(
            self: *const ITfContextOwner,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const ITfContextOwner,
            pdcs: *TS_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWnd: fn(
            self: *const ITfContextOwner,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttribute: fn(
            self: *const ITfContextOwner,
            rguidAttribute: *const Guid,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetACPFromPoint(self: *const T, ptScreen: *const POINT, dwFlags: u32, pacp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetACPFromPoint(@ptrCast(*const ITfContextOwner, self), ptScreen, dwFlags, pacp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetTextExt(self: *const T, acpStart: i32, acpEnd: i32, prc: *RECT, pfClipped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetTextExt(@ptrCast(*const ITfContextOwner, self), acpStart, acpEnd, prc, pfClipped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetScreenExt(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetScreenExt(@ptrCast(*const ITfContextOwner, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetStatus(self: *const T, pdcs: *TS_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetStatus(@ptrCast(*const ITfContextOwner, self), pdcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetWnd(self: *const T, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetWnd(@ptrCast(*const ITfContextOwner, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwner_GetAttribute(self: *const T, rguidAttribute: *const Guid, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwner.VTable, self.vtable).GetAttribute(@ptrCast(*const ITfContextOwner, self), rguidAttribute, pvarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextOwnerServices_Value = @import("../zig.zig").Guid.initString("b23eb630-3e1c-11d3-a745-0050040ab407");
pub const IID_ITfContextOwnerServices = &IID_ITfContextOwnerServices_Value;
pub const ITfContextOwnerServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLayoutChange: fn(
            self: *const ITfContextOwnerServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: fn(
            self: *const ITfContextOwnerServices,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAttributeChange: fn(
            self: *const ITfContextOwnerServices,
            rguidAttribute: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Serialize: fn(
            self: *const ITfContextOwnerServices,
            pProp: *ITfProperty,
            pRange: *ITfRange,
            pHdr: *TF_PERSISTENT_PROPERTY_HEADER_ACP,
            pStream: *IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unserialize: fn(
            self: *const ITfContextOwnerServices,
            pProp: *ITfProperty,
            pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            pStream: *IStream,
            pLoader: *ITfPersistentPropertyLoaderACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceLoadProperty: fn(
            self: *const ITfContextOwnerServices,
            pProp: *ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRange: fn(
            self: *const ITfContextOwnerServices,
            acpStart: i32,
            acpEnd: i32,
            ppRange: **ITfRangeACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_OnLayoutChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).OnLayoutChange(@ptrCast(*const ITfContextOwnerServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_OnStatusChange(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).OnStatusChange(@ptrCast(*const ITfContextOwnerServices, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_OnAttributeChange(self: *const T, rguidAttribute: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).OnAttributeChange(@ptrCast(*const ITfContextOwnerServices, self), rguidAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_Serialize(self: *const T, pProp: *ITfProperty, pRange: *ITfRange, pHdr: *TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: *IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).Serialize(@ptrCast(*const ITfContextOwnerServices, self), pProp, pRange, pHdr, pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_Unserialize(self: *const T, pProp: *ITfProperty, pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: *IStream, pLoader: *ITfPersistentPropertyLoaderACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).Unserialize(@ptrCast(*const ITfContextOwnerServices, self), pProp, pHdr, pStream, pLoader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_ForceLoadProperty(self: *const T, pProp: *ITfProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).ForceLoadProperty(@ptrCast(*const ITfContextOwnerServices, self), pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextOwnerServices_CreateRange(self: *const T, acpStart: i32, acpEnd: i32, ppRange: **ITfRangeACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextOwnerServices.VTable, self.vtable).CreateRange(@ptrCast(*const ITfContextOwnerServices, self), acpStart, acpEnd, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfContextKeyEventSink_Value = @import("../zig.zig").Guid.initString("0552ba5d-c835-4934-bf50-846aaa67432f");
pub const IID_ITfContextKeyEventSink = &IID_ITfContextKeyEventSink_Value;
pub const ITfContextKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyDown: fn(
            self: *const ITfContextKeyEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyUp: fn(
            self: *const ITfContextKeyEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyDown: fn(
            self: *const ITfContextKeyEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyUp: fn(
            self: *const ITfContextKeyEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextKeyEventSink_OnKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextKeyEventSink.VTable, self.vtable).OnKeyDown(@ptrCast(*const ITfContextKeyEventSink, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextKeyEventSink_OnKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextKeyEventSink.VTable, self.vtable).OnKeyUp(@ptrCast(*const ITfContextKeyEventSink, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextKeyEventSink_OnTestKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextKeyEventSink.VTable, self.vtable).OnTestKeyDown(@ptrCast(*const ITfContextKeyEventSink, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfContextKeyEventSink_OnTestKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfContextKeyEventSink.VTable, self.vtable).OnTestKeyUp(@ptrCast(*const ITfContextKeyEventSink, self), wParam, lParam, pfEaten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfEditSession_Value = @import("../zig.zig").Guid.initString("aa80e803-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfEditSession = &IID_ITfEditSession_Value;
pub const ITfEditSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoEditSession: fn(
            self: *const ITfEditSession,
            ec: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfEditSession_DoEditSession(self: *const T, ec: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfEditSession.VTable, self.vtable).DoEditSession(@ptrCast(*const ITfEditSession, self), ec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfGravity = extern enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_GRAVITY_BACKWARD = TfGravity.BACKWARD;
pub const TF_GRAVITY_FORWARD = TfGravity.FORWARD;

pub const TfShiftDir = extern enum(i32) {
    BACKWARD = 0,
    FORWARD = 1,
};
pub const TF_SD_BACKWARD = TfShiftDir.BACKWARD;
pub const TF_SD_FORWARD = TfShiftDir.FORWARD;

pub const TF_HALTCOND = extern struct {
    pHaltRange: *ITfRange,
    aHaltPos: TfAnchor,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRange_Value = @import("../zig.zig").Guid.initString("aa80e7ff-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfRange = &IID_ITfRange_Value;
pub const ITfRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetText: fn(
            self: *const ITfRange,
            ec: u32,
            dwFlags: u32,
            pchText: [*:0]u16,
            cchMax: u32,
            pcch: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITfRange,
            ec: u32,
            dwFlags: u32,
            pchText: [*:0]const u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITfRange,
            ec: u32,
            ppDataObject: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbedded: fn(
            self: *const ITfRange,
            ec: u32,
            rguidService: *const Guid,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEmbedded: fn(
            self: *const ITfRange,
            ec: u32,
            dwFlags: u32,
            pDataObject: *IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStart: fn(
            self: *const ITfRange,
            ec: u32,
            cchReq: i32,
            pcch: *i32,
            pHalt: *const TF_HALTCOND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEnd: fn(
            self: *const ITfRange,
            ec: u32,
            cchReq: i32,
            pcch: *i32,
            pHalt: *const TF_HALTCOND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStartToRange: fn(
            self: *const ITfRange,
            ec: u32,
            pRange: *ITfRange,
            aPos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEndToRange: fn(
            self: *const ITfRange,
            ec: u32,
            pRange: *ITfRange,
            aPos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftStartRegion: fn(
            self: *const ITfRange,
            ec: u32,
            dir: TfShiftDir,
            pfNoRegion: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShiftEndRegion: fn(
            self: *const ITfRange,
            ec: u32,
            dir: TfShiftDir,
            pfNoRegion: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEmpty: fn(
            self: *const ITfRange,
            ec: u32,
            pfEmpty: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const ITfRange,
            ec: u32,
            aPos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualStart: fn(
            self: *const ITfRange,
            ec: u32,
            pWith: *ITfRange,
            aPos: TfAnchor,
            pfEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualEnd: fn(
            self: *const ITfRange,
            ec: u32,
            pWith: *ITfRange,
            aPos: TfAnchor,
            pfEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareStart: fn(
            self: *const ITfRange,
            ec: u32,
            pWith: *ITfRange,
            aPos: TfAnchor,
            plResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEnd: fn(
            self: *const ITfRange,
            ec: u32,
            pWith: *ITfRange,
            aPos: TfAnchor,
            plResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdjustForInsert: fn(
            self: *const ITfRange,
            ec: u32,
            cchInsert: u32,
            pfInsertOk: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const ITfRange,
            pgStart: *TfGravity,
            pgEnd: *TfGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const ITfRange,
            ec: u32,
            gStart: TfGravity,
            gEnd: TfGravity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ITfRange,
            ppClone: **ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const ITfRange,
            ppContext: **ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_GetText(self: *const T, ec: u32, dwFlags: u32, pchText: [*:0]u16, cchMax: u32, pcch: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).GetText(@ptrCast(*const ITfRange, self), ec, dwFlags, pchText, cchMax, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_SetText(self: *const T, ec: u32, dwFlags: u32, pchText: [*:0]const u16, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).SetText(@ptrCast(*const ITfRange, self), ec, dwFlags, pchText, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_GetFormattedText(self: *const T, ec: u32, ppDataObject: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITfRange, self), ec, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_GetEmbedded(self: *const T, ec: u32, rguidService: *const Guid, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).GetEmbedded(@ptrCast(*const ITfRange, self), ec, rguidService, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_InsertEmbedded(self: *const T, ec: u32, dwFlags: u32, pDataObject: *IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).InsertEmbedded(@ptrCast(*const ITfRange, self), ec, dwFlags, pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftStart(self: *const T, ec: u32, cchReq: i32, pcch: *i32, pHalt: *const TF_HALTCOND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftStart(@ptrCast(*const ITfRange, self), ec, cchReq, pcch, pHalt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftEnd(self: *const T, ec: u32, cchReq: i32, pcch: *i32, pHalt: *const TF_HALTCOND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftEnd(@ptrCast(*const ITfRange, self), ec, cchReq, pcch, pHalt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftStartToRange(self: *const T, ec: u32, pRange: *ITfRange, aPos: TfAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftStartToRange(@ptrCast(*const ITfRange, self), ec, pRange, aPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftEndToRange(self: *const T, ec: u32, pRange: *ITfRange, aPos: TfAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftEndToRange(@ptrCast(*const ITfRange, self), ec, pRange, aPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftStartRegion(self: *const T, ec: u32, dir: TfShiftDir, pfNoRegion: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftStartRegion(@ptrCast(*const ITfRange, self), ec, dir, pfNoRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_ShiftEndRegion(self: *const T, ec: u32, dir: TfShiftDir, pfNoRegion: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).ShiftEndRegion(@ptrCast(*const ITfRange, self), ec, dir, pfNoRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_IsEmpty(self: *const T, ec: u32, pfEmpty: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).IsEmpty(@ptrCast(*const ITfRange, self), ec, pfEmpty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_Collapse(self: *const T, ec: u32, aPos: TfAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).Collapse(@ptrCast(*const ITfRange, self), ec, aPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_IsEqualStart(self: *const T, ec: u32, pWith: *ITfRange, aPos: TfAnchor, pfEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).IsEqualStart(@ptrCast(*const ITfRange, self), ec, pWith, aPos, pfEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_IsEqualEnd(self: *const T, ec: u32, pWith: *ITfRange, aPos: TfAnchor, pfEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).IsEqualEnd(@ptrCast(*const ITfRange, self), ec, pWith, aPos, pfEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_CompareStart(self: *const T, ec: u32, pWith: *ITfRange, aPos: TfAnchor, plResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).CompareStart(@ptrCast(*const ITfRange, self), ec, pWith, aPos, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_CompareEnd(self: *const T, ec: u32, pWith: *ITfRange, aPos: TfAnchor, plResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).CompareEnd(@ptrCast(*const ITfRange, self), ec, pWith, aPos, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_AdjustForInsert(self: *const T, ec: u32, cchInsert: u32, pfInsertOk: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).AdjustForInsert(@ptrCast(*const ITfRange, self), ec, cchInsert, pfInsertOk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_GetGravity(self: *const T, pgStart: *TfGravity, pgEnd: *TfGravity) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).GetGravity(@ptrCast(*const ITfRange, self), pgStart, pgEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_SetGravity(self: *const T, ec: u32, gStart: TfGravity, gEnd: TfGravity) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).SetGravity(@ptrCast(*const ITfRange, self), ec, gStart, gEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_Clone(self: *const T, ppClone: **ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).Clone(@ptrCast(*const ITfRange, self), ppClone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRange_GetContext(self: *const T, ppContext: **ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRange.VTable, self.vtable).GetContext(@ptrCast(*const ITfRange, self), ppContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeACP_Value = @import("../zig.zig").Guid.initString("057a6296-029b-4154-b79a-0d461d4ea94c");
pub const IID_ITfRangeACP = &IID_ITfRangeACP_Value;
pub const ITfRangeACP = extern struct {
    pub const VTable = extern struct {
        base: ITfRange.VTable,
        GetExtent: fn(
            self: *const ITfRangeACP,
            pacpAnchor: *i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtent: fn(
            self: *const ITfRangeACP,
            acpAnchor: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRangeACP_GetExtent(self: *const T, pacpAnchor: *i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRangeACP.VTable, self.vtable).GetExtent(@ptrCast(*const ITfRangeACP, self), pacpAnchor, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRangeACP_SetExtent(self: *const T, acpAnchor: i32, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRangeACP.VTable, self.vtable).SetExtent(@ptrCast(*const ITfRangeACP, self), acpAnchor, cch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITextStoreACPServices_Value = @import("../zig.zig").Guid.initString("aa80e901-2021-11d2-93e0-0060b067b86e");
pub const IID_ITextStoreACPServices = &IID_ITextStoreACPServices_Value;
pub const ITextStoreACPServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Serialize: fn(
            self: *const ITextStoreACPServices,
            pProp: *ITfProperty,
            pRange: *ITfRange,
            pHdr: *TF_PERSISTENT_PROPERTY_HEADER_ACP,
            pStream: *IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unserialize: fn(
            self: *const ITextStoreACPServices,
            pProp: *ITfProperty,
            pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            pStream: *IStream,
            pLoader: *ITfPersistentPropertyLoaderACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceLoadProperty: fn(
            self: *const ITextStoreACPServices,
            pProp: *ITfProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRange: fn(
            self: *const ITextStoreACPServices,
            acpStart: i32,
            acpEnd: i32,
            ppRange: **ITfRangeACP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPServices_Serialize(self: *const T, pProp: *ITfProperty, pRange: *ITfRange, pHdr: *TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: *IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPServices.VTable, self.vtable).Serialize(@ptrCast(*const ITextStoreACPServices, self), pProp, pRange, pHdr, pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPServices_Unserialize(self: *const T, pProp: *ITfProperty, pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP, pStream: *IStream, pLoader: *ITfPersistentPropertyLoaderACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPServices.VTable, self.vtable).Unserialize(@ptrCast(*const ITextStoreACPServices, self), pProp, pHdr, pStream, pLoader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPServices_ForceLoadProperty(self: *const T, pProp: *ITfProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPServices.VTable, self.vtable).ForceLoadProperty(@ptrCast(*const ITextStoreACPServices, self), pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPServices_CreateRange(self: *const T, acpStart: i32, acpEnd: i32, ppRange: **ITfRangeACP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPServices.VTable, self.vtable).CreateRange(@ptrCast(*const ITextStoreACPServices, self), acpStart, acpEnd, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfRangeBackup_Value = @import("../zig.zig").Guid.initString("463a506d-6992-49d2-9b88-93d55e70bb16");
pub const IID_ITfRangeBackup = &IID_ITfRangeBackup_Value;
pub const ITfRangeBackup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Restore: fn(
            self: *const ITfRangeBackup,
            ec: u32,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfRangeBackup_Restore(self: *const T, ec: u32, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfRangeBackup.VTable, self.vtable).Restore(@ptrCast(*const ITfRangeBackup, self), ec, pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPropertyStore_Value = @import("../zig.zig").Guid.initString("6834b120-88cb-11d2-bf45-00105a2799b5");
pub const IID_ITfPropertyStore = &IID_ITfPropertyStore_Value;
pub const ITfPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const ITfPropertyStore,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataType: fn(
            self: *const ITfPropertyStore,
            pdwReserved: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const ITfPropertyStore,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTextUpdated: fn(
            self: *const ITfPropertyStore,
            dwFlags: u32,
            pRangeNew: *ITfRange,
            pfAccept: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shrink: fn(
            self: *const ITfPropertyStore,
            pRangeNew: *ITfRange,
            pfFree: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Divide: fn(
            self: *const ITfPropertyStore,
            pRangeThis: *ITfRange,
            pRangeNew: *ITfRange,
            ppPropStore: **ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ITfPropertyStore,
            pPropStore: **ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyRangeCreator: fn(
            self: *const ITfPropertyStore,
            pclsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Serialize: fn(
            self: *const ITfPropertyStore,
            pStream: *IStream,
            pcb: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_GetType(self: *const T, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).GetType(@ptrCast(*const ITfPropertyStore, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_GetDataType(self: *const T, pdwReserved: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).GetDataType(@ptrCast(*const ITfPropertyStore, self), pdwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_GetData(self: *const T, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).GetData(@ptrCast(*const ITfPropertyStore, self), pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_OnTextUpdated(self: *const T, dwFlags: u32, pRangeNew: *ITfRange, pfAccept: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).OnTextUpdated(@ptrCast(*const ITfPropertyStore, self), dwFlags, pRangeNew, pfAccept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_Shrink(self: *const T, pRangeNew: *ITfRange, pfFree: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).Shrink(@ptrCast(*const ITfPropertyStore, self), pRangeNew, pfFree);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_Divide(self: *const T, pRangeThis: *ITfRange, pRangeNew: *ITfRange, ppPropStore: **ITfPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).Divide(@ptrCast(*const ITfPropertyStore, self), pRangeThis, pRangeNew, ppPropStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_Clone(self: *const T, pPropStore: **ITfPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).Clone(@ptrCast(*const ITfPropertyStore, self), pPropStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_GetPropertyRangeCreator(self: *const T, pclsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).GetPropertyRangeCreator(@ptrCast(*const ITfPropertyStore, self), pclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPropertyStore_Serialize(self: *const T, pStream: *IStream, pcb: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPropertyStore.VTable, self.vtable).Serialize(@ptrCast(*const ITfPropertyStore, self), pStream, pcb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfRanges_Value = @import("../zig.zig").Guid.initString("f99d3f40-8e32-11d2-bf46-00105a2799b5");
pub const IID_IEnumTfRanges = &IID_IEnumTfRanges_Value;
pub const IEnumTfRanges = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfRanges,
            ppEnum: **IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfRanges,
            ulCount: u32,
            ppRange: [*]*ITfRange,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfRanges,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfRanges_Clone(self: *const T, ppEnum: **IEnumTfRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfRanges.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfRanges, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfRanges_Next(self: *const T, ulCount: u32, ppRange: [*]*ITfRange, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfRanges.VTable, self.vtable).Next(@ptrCast(*const IEnumTfRanges, self), ulCount, ppRange, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfRanges_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfRanges.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfRanges, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfRanges_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfRanges.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfRanges, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCreatePropertyStore_Value = @import("../zig.zig").Guid.initString("2463fbf0-b0af-11d2-afc5-00105a2799b5");
pub const IID_ITfCreatePropertyStore = &IID_ITfCreatePropertyStore_Value;
pub const ITfCreatePropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStoreSerializable: fn(
            self: *const ITfCreatePropertyStore,
            guidProp: *const Guid,
            pRange: *ITfRange,
            pPropStore: *ITfPropertyStore,
            pfSerializable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyStore: fn(
            self: *const ITfCreatePropertyStore,
            guidProp: *const Guid,
            pRange: *ITfRange,
            cb: u32,
            pStream: *IStream,
            ppStore: **ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCreatePropertyStore_IsStoreSerializable(self: *const T, guidProp: *const Guid, pRange: *ITfRange, pPropStore: *ITfPropertyStore, pfSerializable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCreatePropertyStore.VTable, self.vtable).IsStoreSerializable(@ptrCast(*const ITfCreatePropertyStore, self), guidProp, pRange, pPropStore, pfSerializable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCreatePropertyStore_CreatePropertyStore(self: *const T, guidProp: *const Guid, pRange: *ITfRange, cb: u32, pStream: *IStream, ppStore: **ITfPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCreatePropertyStore.VTable, self.vtable).CreatePropertyStore(@ptrCast(*const ITfCreatePropertyStore, self), guidProp, pRange, cb, pStream, ppStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPersistentPropertyLoaderACP_Value = @import("../zig.zig").Guid.initString("4ef89150-0807-11d3-8df0-00105a2799b5");
pub const IID_ITfPersistentPropertyLoaderACP = &IID_ITfPersistentPropertyLoaderACP_Value;
pub const ITfPersistentPropertyLoaderACP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadProperty: fn(
            self: *const ITfPersistentPropertyLoaderACP,
            pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP,
            ppStream: **IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPersistentPropertyLoaderACP_LoadProperty(self: *const T, pHdr: *const TF_PERSISTENT_PROPERTY_HEADER_ACP, ppStream: **IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPersistentPropertyLoaderACP.VTable, self.vtable).LoadProperty(@ptrCast(*const ITfPersistentPropertyLoaderACP, self), pHdr, ppStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfProperty_Value = @import("../zig.zig").Guid.initString("e2449660-9542-11d2-bf46-00105a2799b5");
pub const IID_ITfProperty = &IID_ITfProperty_Value;
pub const ITfProperty = extern struct {
    pub const VTable = extern struct {
        base: ITfReadOnlyProperty.VTable,
        FindRange: fn(
            self: *const ITfProperty,
            ec: u32,
            pRange: *ITfRange,
            ppRange: **ITfRange,
            aPos: TfAnchor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueStore: fn(
            self: *const ITfProperty,
            ec: u32,
            pRange: *ITfRange,
            pPropStore: *ITfPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ITfProperty,
            ec: u32,
            pRange: *ITfRange,
            pvarValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ITfProperty,
            ec: u32,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfReadOnlyProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfProperty_FindRange(self: *const T, ec: u32, pRange: *ITfRange, ppRange: **ITfRange, aPos: TfAnchor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfProperty.VTable, self.vtable).FindRange(@ptrCast(*const ITfProperty, self), ec, pRange, ppRange, aPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfProperty_SetValueStore(self: *const T, ec: u32, pRange: *ITfRange, pPropStore: *ITfPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfProperty.VTable, self.vtable).SetValueStore(@ptrCast(*const ITfProperty, self), ec, pRange, pPropStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfProperty_SetValue(self: *const T, ec: u32, pRange: *ITfRange, pvarValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfProperty.VTable, self.vtable).SetValue(@ptrCast(*const ITfProperty, self), ec, pRange, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfProperty_Clear(self: *const T, ec: u32, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfProperty.VTable, self.vtable).Clear(@ptrCast(*const ITfProperty, self), ec, pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfProperties_Value = @import("../zig.zig").Guid.initString("19188cb0-aca9-11d2-afc5-00105a2799b5");
pub const IID_IEnumTfProperties = &IID_IEnumTfProperties_Value;
pub const IEnumTfProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfProperties,
            ppEnum: **IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfProperties,
            ulCount: u32,
            ppProp: [*]*ITfProperty,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfProperties,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfProperties_Clone(self: *const T, ppEnum: **IEnumTfProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfProperties.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfProperties, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfProperties_Next(self: *const T, ulCount: u32, ppProp: [*]*ITfProperty, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfProperties.VTable, self.vtable).Next(@ptrCast(*const IEnumTfProperties, self), ulCount, ppProp, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfProperties_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfProperties.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfProperties, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfProperties_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfProperties.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfProperties, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartment_Value = @import("../zig.zig").Guid.initString("bb08f7a9-607a-4384-8623-056892b64371");
pub const IID_ITfCompartment = &IID_ITfCompartment_Value;
pub const ITfCompartment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: fn(
            self: *const ITfCompartment,
            tid: u32,
            pvarValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ITfCompartment,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartment_SetValue(self: *const T, tid: u32, pvarValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartment.VTable, self.vtable).SetValue(@ptrCast(*const ITfCompartment, self), tid, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartment_GetValue(self: *const T, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartment.VTable, self.vtable).GetValue(@ptrCast(*const ITfCompartment, self), pvarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentEventSink_Value = @import("../zig.zig").Guid.initString("743abd5f-f26d-48df-8cc5-238492419b64");
pub const IID_ITfCompartmentEventSink = &IID_ITfCompartmentEventSink_Value;
pub const ITfCompartmentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: fn(
            self: *const ITfCompartmentEventSink,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartmentEventSink_OnChange(self: *const T, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartmentEventSink.VTable, self.vtable).OnChange(@ptrCast(*const ITfCompartmentEventSink, self), rguid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCompartmentMgr_Value = @import("../zig.zig").Guid.initString("7dcf57ac-18ad-438b-824d-979bffb74b7c");
pub const IID_ITfCompartmentMgr = &IID_ITfCompartmentMgr_Value;
pub const ITfCompartmentMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCompartment: fn(
            self: *const ITfCompartmentMgr,
            rguid: *const Guid,
            ppcomp: **ITfCompartment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearCompartment: fn(
            self: *const ITfCompartmentMgr,
            tid: u32,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCompartments: fn(
            self: *const ITfCompartmentMgr,
            ppEnum: **IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartmentMgr_GetCompartment(self: *const T, rguid: *const Guid, ppcomp: **ITfCompartment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartmentMgr.VTable, self.vtable).GetCompartment(@ptrCast(*const ITfCompartmentMgr, self), rguid, ppcomp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartmentMgr_ClearCompartment(self: *const T, tid: u32, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartmentMgr.VTable, self.vtable).ClearCompartment(@ptrCast(*const ITfCompartmentMgr, self), tid, rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCompartmentMgr_EnumCompartments(self: *const T, ppEnum: **IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCompartmentMgr.VTable, self.vtable).EnumCompartments(@ptrCast(*const ITfCompartmentMgr, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunction_Value = @import("../zig.zig").Guid.initString("db593490-098f-11d3-8df0-00105a2799b5");
pub const IID_ITfFunction = &IID_ITfFunction_Value;
pub const ITfFunction = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayName: fn(
            self: *const ITfFunction,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFunction_GetDisplayName(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFunction.VTable, self.vtable).GetDisplayName(@ptrCast(*const ITfFunction, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFunctionProvider_Value = @import("../zig.zig").Guid.initString("101d6610-0990-11d3-8df0-00105a2799b5");
pub const IID_ITfFunctionProvider = &IID_ITfFunctionProvider_Value;
pub const ITfFunctionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const ITfFunctionProvider,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const ITfFunctionProvider,
            pbstrDesc: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunction: fn(
            self: *const ITfFunctionProvider,
            rguid: *const Guid,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFunctionProvider_GetType(self: *const T, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFunctionProvider.VTable, self.vtable).GetType(@ptrCast(*const ITfFunctionProvider, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFunctionProvider_GetDescription(self: *const T, pbstrDesc: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFunctionProvider.VTable, self.vtable).GetDescription(@ptrCast(*const ITfFunctionProvider, self), pbstrDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFunctionProvider_GetFunction(self: *const T, rguid: *const Guid, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFunctionProvider.VTable, self.vtable).GetFunction(@ptrCast(*const ITfFunctionProvider, self), rguid, riid, ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfFunctionProviders_Value = @import("../zig.zig").Guid.initString("e4b24db0-0990-11d3-8df0-00105a2799b5");
pub const IID_IEnumTfFunctionProviders = &IID_IEnumTfFunctionProviders_Value;
pub const IEnumTfFunctionProviders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfFunctionProviders,
            ppEnum: **IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfFunctionProviders,
            ulCount: u32,
            ppCmdobj: [*]*ITfFunctionProvider,
            pcFetch: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfFunctionProviders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfFunctionProviders,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfFunctionProviders_Clone(self: *const T, ppEnum: **IEnumTfFunctionProviders) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfFunctionProviders.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfFunctionProviders, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfFunctionProviders_Next(self: *const T, ulCount: u32, ppCmdobj: [*]*ITfFunctionProvider, pcFetch: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfFunctionProviders.VTable, self.vtable).Next(@ptrCast(*const IEnumTfFunctionProviders, self), ulCount, ppCmdobj, pcFetch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfFunctionProviders_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfFunctionProviders.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfFunctionProviders, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfFunctionProviders_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfFunctionProviders.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfFunctionProviders, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfiles_Value = @import("../zig.zig").Guid.initString("1f02b6c5-7842-4ee6-8a0b-9a24183a95ca");
pub const IID_ITfInputProcessorProfiles = &IID_ITfInputProcessorProfiles_Value;
pub const ITfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            pchDesc: [*:0]const u16,
            cchDesc: u32,
            pchIconFile: [*:0]const u16,
            cchFile: u32,
            uIconIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputProcessorInfo: fn(
            self: *const ITfInputProcessorProfiles,
            ppEnum: **IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            catid: *const Guid,
            pclsid: *Guid,
            pguidProfile: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            rclsid: *const Guid,
            guidProfiles: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfiles: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            plangid: *u16,
            pguidProfile: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageProfileDescription: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            pbstrProfile: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLanguage: fn(
            self: *const ITfInputProcessorProfiles,
            plangid: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentLanguage: fn(
            self: *const ITfInputProcessorProfiles,
            langid: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageList: fn(
            self: *const ITfInputProcessorProfiles,
            ppLangId: [*]*u16,
            pulCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumLanguageProfiles: fn(
            self: *const ITfInputProcessorProfiles,
            langid: u16,
            ppEnum: **IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEnabledLanguageProfile: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            pfEnable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableLanguageProfileByDefault: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubstituteKeyboardLayout: fn(
            self: *const ITfInputProcessorProfiles,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            hKL: HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_Register(self: *const T, rclsid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).Register(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_Unregister(self: *const T, rclsid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).Unregister(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_AddLanguageProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, pchDesc: [*:0]const u16, cchDesc: u32, pchIconFile: [*:0]const u16, cchFile: u32, uIconIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).AddLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, pchDesc, cchDesc, pchIconFile, cchFile, uIconIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_RemoveLanguageProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).RemoveLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_EnumInputProcessorInfo(self: *const T, ppEnum: **IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).EnumInputProcessorInfo(@ptrCast(*const ITfInputProcessorProfiles, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_GetDefaultLanguageProfile(self: *const T, langid: u16, catid: *const Guid, pclsid: *Guid, pguidProfile: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).GetDefaultLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), langid, catid, pclsid, pguidProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_SetDefaultLanguageProfile(self: *const T, langid: u16, rclsid: *const Guid, guidProfiles: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).SetDefaultLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), langid, rclsid, guidProfiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_ActivateLanguageProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfiles: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).ActivateLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_GetActiveLanguageProfile(self: *const T, rclsid: *const Guid, plangid: *u16, pguidProfile: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).GetActiveLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, plangid, pguidProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_GetLanguageProfileDescription(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, pbstrProfile: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).GetLanguageProfileDescription(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, pbstrProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_GetCurrentLanguage(self: *const T, plangid: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).GetCurrentLanguage(@ptrCast(*const ITfInputProcessorProfiles, self), plangid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_ChangeCurrentLanguage(self: *const T, langid: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).ChangeCurrentLanguage(@ptrCast(*const ITfInputProcessorProfiles, self), langid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_GetLanguageList(self: *const T, ppLangId: [*]*u16, pulCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).GetLanguageList(@ptrCast(*const ITfInputProcessorProfiles, self), ppLangId, pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_EnumLanguageProfiles(self: *const T, langid: u16, ppEnum: **IEnumTfLanguageProfiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).EnumLanguageProfiles(@ptrCast(*const ITfInputProcessorProfiles, self), langid, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_EnableLanguageProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).EnableLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_IsEnabledLanguageProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, pfEnable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).IsEnabledLanguageProfile(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, pfEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_EnableLanguageProfileByDefault(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).EnableLanguageProfileByDefault(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfiles_SubstituteKeyboardLayout(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, hKL: HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfiles.VTable, self.vtable).SubstituteKeyboardLayout(@ptrCast(*const ITfInputProcessorProfiles, self), rclsid, langid, guidProfile, hKL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfilesEx_Value = @import("../zig.zig").Guid.initString("892f230f-fe00-4a41-a98e-fcd6de0d35ef");
pub const IID_ITfInputProcessorProfilesEx = &IID_ITfInputProcessorProfilesEx_Value;
pub const ITfInputProcessorProfilesEx = extern struct {
    pub const VTable = extern struct {
        base: ITfInputProcessorProfiles.VTable,
        SetLanguageProfileDisplayName: fn(
            self: *const ITfInputProcessorProfilesEx,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            pchFile: [*:0]const u16,
            cchFile: u32,
            uResId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfInputProcessorProfiles.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfilesEx_SetLanguageProfileDisplayName(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, pchFile: [*:0]const u16, cchFile: u32, uResId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfilesEx.VTable, self.vtable).SetLanguageProfileDisplayName(@ptrCast(*const ITfInputProcessorProfilesEx, self), rclsid, langid, guidProfile, pchFile, cchFile, uResId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileSubstituteLayout_Value = @import("../zig.zig").Guid.initString("4fd67194-1002-4513-bff2-c0ddf6258552");
pub const IID_ITfInputProcessorProfileSubstituteLayout = &IID_ITfInputProcessorProfileSubstituteLayout_Value;
pub const ITfInputProcessorProfileSubstituteLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubstituteKeyboardLayout: fn(
            self: *const ITfInputProcessorProfileSubstituteLayout,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            phKL: *HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileSubstituteLayout_GetSubstituteKeyboardLayout(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, phKL: *HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileSubstituteLayout.VTable, self.vtable).GetSubstituteKeyboardLayout(@ptrCast(*const ITfInputProcessorProfileSubstituteLayout, self), rclsid, langid, guidProfile, phKL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfActiveLanguageProfileNotifySink_Value = @import("../zig.zig").Guid.initString("b246cb75-a93e-4652-bf8c-b3fe0cfd7e57");
pub const IID_ITfActiveLanguageProfileNotifySink = &IID_ITfActiveLanguageProfileNotifySink_Value;
pub const ITfActiveLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: fn(
            self: *const ITfActiveLanguageProfileNotifySink,
            clsid: *const Guid,
            guidProfile: *const Guid,
            fActivated: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfActiveLanguageProfileNotifySink_OnActivated(self: *const T, clsid: *const Guid, guidProfile: *const Guid, fActivated: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfActiveLanguageProfileNotifySink.VTable, self.vtable).OnActivated(@ptrCast(*const ITfActiveLanguageProfileNotifySink, self), clsid, guidProfile, fActivated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLanguageProfiles_Value = @import("../zig.zig").Guid.initString("3d61bf11-ac5f-42c8-a4cb-931bcc28c744");
pub const IID_IEnumTfLanguageProfiles = &IID_IEnumTfLanguageProfiles_Value;
pub const IEnumTfLanguageProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfLanguageProfiles,
            ppEnum: **IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfLanguageProfiles,
            ulCount: u32,
            pProfile: [*]TF_LANGUAGEPROFILE,
            pcFetch: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfLanguageProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfLanguageProfiles,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLanguageProfiles_Clone(self: *const T, ppEnum: **IEnumTfLanguageProfiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLanguageProfiles.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfLanguageProfiles, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLanguageProfiles_Next(self: *const T, ulCount: u32, pProfile: [*]TF_LANGUAGEPROFILE, pcFetch: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLanguageProfiles.VTable, self.vtable).Next(@ptrCast(*const IEnumTfLanguageProfiles, self), ulCount, pProfile, pcFetch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLanguageProfiles_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLanguageProfiles.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfLanguageProfiles, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLanguageProfiles_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLanguageProfiles.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfLanguageProfiles, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLanguageProfileNotifySink_Value = @import("../zig.zig").Guid.initString("43c9fe15-f494-4c17-9de2-b8a4ac350aa8");
pub const IID_ITfLanguageProfileNotifySink = &IID_ITfLanguageProfileNotifySink_Value;
pub const ITfLanguageProfileNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLanguageChange: fn(
            self: *const ITfLanguageProfileNotifySink,
            langid: u16,
            pfAccept: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLanguageChanged: fn(
            self: *const ITfLanguageProfileNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLanguageProfileNotifySink_OnLanguageChange(self: *const T, langid: u16, pfAccept: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLanguageProfileNotifySink.VTable, self.vtable).OnLanguageChange(@ptrCast(*const ITfLanguageProfileNotifySink, self), langid, pfAccept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLanguageProfileNotifySink_OnLanguageChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLanguageProfileNotifySink.VTable, self.vtable).OnLanguageChanged(@ptrCast(*const ITfLanguageProfileNotifySink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_INPUTPROCESSORPROFILE = extern struct {
    dwProfileType: u32,
    langid: u16,
    clsid: Guid,
    guidProfile: Guid,
    catid: Guid,
    hklSubstitute: HKL,
    dwCaps: u32,
    hkl: HKL,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfInputProcessorProfileMgr_Value = @import("../zig.zig").Guid.initString("71c6e74c-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileMgr = &IID_ITfInputProcessorProfileMgr_Value;
pub const ITfInputProcessorProfileMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            dwProfileType: u32,
            langid: u16,
            clsid: *const Guid,
            guidProfile: *const Guid,
            hkl: HKL,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeactivateProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            dwProfileType: u32,
            langid: u16,
            clsid: *const Guid,
            guidProfile: *const Guid,
            hkl: HKL,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            dwProfileType: u32,
            langid: u16,
            clsid: *const Guid,
            guidProfile: *const Guid,
            hkl: HKL,
            pProfile: *TF_INPUTPROCESSORPROFILE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProfiles: fn(
            self: *const ITfInputProcessorProfileMgr,
            langid: u16,
            ppEnum: **IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseInputProcessor: fn(
            self: *const ITfInputProcessorProfileMgr,
            rclsid: *const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            pchDesc: [*:0]const u16,
            cchDesc: u32,
            pchIconFile: [*:0]const u16,
            cchFile: u32,
            uIconIndex: u32,
            hklsubstitute: HKL,
            dwPreferredLayout: u32,
            bEnabledByDefault: BOOL,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            rclsid: *const Guid,
            langid: u16,
            guidProfile: *const Guid,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveProfile: fn(
            self: *const ITfInputProcessorProfileMgr,
            catid: *const Guid,
            pProfile: *TF_INPUTPROCESSORPROFILE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_ActivateProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: *const Guid, guidProfile: *const Guid, hkl: HKL, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).ActivateProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), dwProfileType, langid, clsid, guidProfile, hkl, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_DeactivateProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: *const Guid, guidProfile: *const Guid, hkl: HKL, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).DeactivateProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), dwProfileType, langid, clsid, guidProfile, hkl, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_GetProfile(self: *const T, dwProfileType: u32, langid: u16, clsid: *const Guid, guidProfile: *const Guid, hkl: HKL, pProfile: *TF_INPUTPROCESSORPROFILE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).GetProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), dwProfileType, langid, clsid, guidProfile, hkl, pProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_EnumProfiles(self: *const T, langid: u16, ppEnum: **IEnumTfInputProcessorProfiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).EnumProfiles(@ptrCast(*const ITfInputProcessorProfileMgr, self), langid, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_ReleaseInputProcessor(self: *const T, rclsid: *const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).ReleaseInputProcessor(@ptrCast(*const ITfInputProcessorProfileMgr, self), rclsid, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_RegisterProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, pchDesc: [*:0]const u16, cchDesc: u32, pchIconFile: [*:0]const u16, cchFile: u32, uIconIndex: u32, hklsubstitute: HKL, dwPreferredLayout: u32, bEnabledByDefault: BOOL, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).RegisterProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), rclsid, langid, guidProfile, pchDesc, cchDesc, pchIconFile, cchFile, uIconIndex, hklsubstitute, dwPreferredLayout, bEnabledByDefault, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_UnregisterProfile(self: *const T, rclsid: *const Guid, langid: u16, guidProfile: *const Guid, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).UnregisterProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), rclsid, langid, guidProfile, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileMgr_GetActiveProfile(self: *const T, catid: *const Guid, pProfile: *TF_INPUTPROCESSORPROFILE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileMgr.VTable, self.vtable).GetActiveProfile(@ptrCast(*const ITfInputProcessorProfileMgr, self), catid, pProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfInputProcessorProfiles_Value = @import("../zig.zig").Guid.initString("71c6e74d-0f28-11d8-a82a-00065b84435c");
pub const IID_IEnumTfInputProcessorProfiles = &IID_IEnumTfInputProcessorProfiles_Value;
pub const IEnumTfInputProcessorProfiles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfInputProcessorProfiles,
            ppEnum: **IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfInputProcessorProfiles,
            ulCount: u32,
            pProfile: [*]TF_INPUTPROCESSORPROFILE,
            pcFetch: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfInputProcessorProfiles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfInputProcessorProfiles,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfInputProcessorProfiles_Clone(self: *const T, ppEnum: **IEnumTfInputProcessorProfiles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfInputProcessorProfiles.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfInputProcessorProfiles, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfInputProcessorProfiles_Next(self: *const T, ulCount: u32, pProfile: [*]TF_INPUTPROCESSORPROFILE, pcFetch: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfInputProcessorProfiles.VTable, self.vtable).Next(@ptrCast(*const IEnumTfInputProcessorProfiles, self), ulCount, pProfile, pcFetch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfInputProcessorProfiles_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfInputProcessorProfiles.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfInputProcessorProfiles, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfInputProcessorProfiles_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfInputProcessorProfiles.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfInputProcessorProfiles, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfInputProcessorProfileActivationSink_Value = @import("../zig.zig").Guid.initString("71c6e74e-0f28-11d8-a82a-00065b84435c");
pub const IID_ITfInputProcessorProfileActivationSink = &IID_ITfInputProcessorProfileActivationSink_Value;
pub const ITfInputProcessorProfileActivationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivated: fn(
            self: *const ITfInputProcessorProfileActivationSink,
            dwProfileType: u32,
            langid: u16,
            clsid: *const Guid,
            catid: *const Guid,
            guidProfile: *const Guid,
            hkl: HKL,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputProcessorProfileActivationSink_OnActivated(self: *const T, dwProfileType: u32, langid: u16, clsid: *const Guid, catid: *const Guid, guidProfile: *const Guid, hkl: HKL, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputProcessorProfileActivationSink.VTable, self.vtable).OnActivated(@ptrCast(*const ITfInputProcessorProfileActivationSink, self), dwProfileType, langid, clsid, catid, guidProfile, hkl, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_PRESERVEDKEY = extern struct {
    uVKey: u32,
    uModifiers: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeystrokeMgr_Value = @import("../zig.zig").Guid.initString("aa80e7f0-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeystrokeMgr = &IID_ITfKeystrokeMgr_Value;
pub const ITfKeystrokeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseKeyEventSink: fn(
            self: *const ITfKeystrokeMgr,
            tid: u32,
            pSink: *ITfKeyEventSink,
            fForeground: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseKeyEventSink: fn(
            self: *const ITfKeystrokeMgr,
            tid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeground: fn(
            self: *const ITfKeystrokeMgr,
            pclsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestKeyDown: fn(
            self: *const ITfKeystrokeMgr,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestKeyUp: fn(
            self: *const ITfKeystrokeMgr,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyDown: fn(
            self: *const ITfKeystrokeMgr,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyUp: fn(
            self: *const ITfKeystrokeMgr,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreservedKey: fn(
            self: *const ITfKeystrokeMgr,
            pic: *ITfContext,
            pprekey: *const TF_PRESERVEDKEY,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreservedKey: fn(
            self: *const ITfKeystrokeMgr,
            rguid: *const Guid,
            pprekey: *const TF_PRESERVEDKEY,
            pfRegistered: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreserveKey: fn(
            self: *const ITfKeystrokeMgr,
            tid: u32,
            rguid: *const Guid,
            prekey: *const TF_PRESERVEDKEY,
            pchDesc: [*:0]const u16,
            cchDesc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnpreserveKey: fn(
            self: *const ITfKeystrokeMgr,
            rguid: *const Guid,
            pprekey: *const TF_PRESERVEDKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreservedKeyDescription: fn(
            self: *const ITfKeystrokeMgr,
            rguid: *const Guid,
            pchDesc: [*:0]const u16,
            cchDesc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreservedKeyDescription: fn(
            self: *const ITfKeystrokeMgr,
            rguid: *const Guid,
            pbstrDesc: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulatePreservedKey: fn(
            self: *const ITfKeystrokeMgr,
            pic: *ITfContext,
            rguid: *const Guid,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_AdviseKeyEventSink(self: *const T, tid: u32, pSink: *ITfKeyEventSink, fForeground: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).AdviseKeyEventSink(@ptrCast(*const ITfKeystrokeMgr, self), tid, pSink, fForeground);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_UnadviseKeyEventSink(self: *const T, tid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).UnadviseKeyEventSink(@ptrCast(*const ITfKeystrokeMgr, self), tid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_GetForeground(self: *const T, pclsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).GetForeground(@ptrCast(*const ITfKeystrokeMgr, self), pclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_TestKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).TestKeyDown(@ptrCast(*const ITfKeystrokeMgr, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_TestKeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).TestKeyUp(@ptrCast(*const ITfKeystrokeMgr, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_KeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).KeyDown(@ptrCast(*const ITfKeystrokeMgr, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_KeyUp(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).KeyUp(@ptrCast(*const ITfKeystrokeMgr, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_GetPreservedKey(self: *const T, pic: *ITfContext, pprekey: *const TF_PRESERVEDKEY, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).GetPreservedKey(@ptrCast(*const ITfKeystrokeMgr, self), pic, pprekey, pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_IsPreservedKey(self: *const T, rguid: *const Guid, pprekey: *const TF_PRESERVEDKEY, pfRegistered: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).IsPreservedKey(@ptrCast(*const ITfKeystrokeMgr, self), rguid, pprekey, pfRegistered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_PreserveKey(self: *const T, tid: u32, rguid: *const Guid, prekey: *const TF_PRESERVEDKEY, pchDesc: [*:0]const u16, cchDesc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).PreserveKey(@ptrCast(*const ITfKeystrokeMgr, self), tid, rguid, prekey, pchDesc, cchDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_UnpreserveKey(self: *const T, rguid: *const Guid, pprekey: *const TF_PRESERVEDKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).UnpreserveKey(@ptrCast(*const ITfKeystrokeMgr, self), rguid, pprekey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_SetPreservedKeyDescription(self: *const T, rguid: *const Guid, pchDesc: [*:0]const u16, cchDesc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).SetPreservedKeyDescription(@ptrCast(*const ITfKeystrokeMgr, self), rguid, pchDesc, cchDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_GetPreservedKeyDescription(self: *const T, rguid: *const Guid, pbstrDesc: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).GetPreservedKeyDescription(@ptrCast(*const ITfKeystrokeMgr, self), rguid, pbstrDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeystrokeMgr_SimulatePreservedKey(self: *const T, pic: *ITfContext, rguid: *const Guid, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeystrokeMgr.VTable, self.vtable).SimulatePreservedKey(@ptrCast(*const ITfKeystrokeMgr, self), pic, rguid, pfEaten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyEventSink_Value = @import("../zig.zig").Guid.initString("aa80e7f5-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfKeyEventSink = &IID_ITfKeyEventSink_Value;
pub const ITfKeyEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetFocus: fn(
            self: *const ITfKeyEventSink,
            fForeground: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyDown: fn(
            self: *const ITfKeyEventSink,
            pic: *ITfContext,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTestKeyUp: fn(
            self: *const ITfKeyEventSink,
            pic: *ITfContext,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyDown: fn(
            self: *const ITfKeyEventSink,
            pic: *ITfContext,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyUp: fn(
            self: *const ITfKeyEventSink,
            pic: *ITfContext,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPreservedKey: fn(
            self: *const ITfKeyEventSink,
            pic: *ITfContext,
            rguid: *const Guid,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnSetFocus(self: *const T, fForeground: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnSetFocus(@ptrCast(*const ITfKeyEventSink, self), fForeground);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnTestKeyDown(self: *const T, pic: *ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnTestKeyDown(@ptrCast(*const ITfKeyEventSink, self), pic, wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnTestKeyUp(self: *const T, pic: *ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnTestKeyUp(@ptrCast(*const ITfKeyEventSink, self), pic, wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnKeyDown(self: *const T, pic: *ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnKeyDown(@ptrCast(*const ITfKeyEventSink, self), pic, wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnKeyUp(self: *const T, pic: *ITfContext, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnKeyUp(@ptrCast(*const ITfKeyEventSink, self), pic, wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyEventSink_OnPreservedKey(self: *const T, pic: *ITfContext, rguid: *const Guid, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyEventSink.VTable, self.vtable).OnPreservedKey(@ptrCast(*const ITfKeyEventSink, self), pic, rguid, pfEaten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfKeyTraceEventSink_Value = @import("../zig.zig").Guid.initString("1cd4c13b-1c36-4191-a70a-7f3e611f367d");
pub const IID_ITfKeyTraceEventSink = &IID_ITfKeyTraceEventSink_Value;
pub const ITfKeyTraceEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnKeyTraceDown: fn(
            self: *const ITfKeyTraceEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyTraceUp: fn(
            self: *const ITfKeyTraceEventSink,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyTraceEventSink_OnKeyTraceDown(self: *const T, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyTraceEventSink.VTable, self.vtable).OnKeyTraceDown(@ptrCast(*const ITfKeyTraceEventSink, self), wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfKeyTraceEventSink_OnKeyTraceUp(self: *const T, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfKeyTraceEventSink.VTable, self.vtable).OnKeyTraceUp(@ptrCast(*const ITfKeyTraceEventSink, self), wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfPreservedKeyNotifySink_Value = @import("../zig.zig").Guid.initString("6f77c993-d2b1-446e-853e-5912efc8a286");
pub const IID_ITfPreservedKeyNotifySink = &IID_ITfPreservedKeyNotifySink_Value;
pub const ITfPreservedKeyNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdated: fn(
            self: *const ITfPreservedKeyNotifySink,
            pprekey: *const TF_PRESERVEDKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfPreservedKeyNotifySink_OnUpdated(self: *const T, pprekey: *const TF_PRESERVEDKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfPreservedKeyNotifySink.VTable, self.vtable).OnUpdated(@ptrCast(*const ITfPreservedKeyNotifySink, self), pprekey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMessagePump_Value = @import("../zig.zig").Guid.initString("8f1b8ad8-0b6b-4874-90c5-bd76011e8f7c");
pub const IID_ITfMessagePump = &IID_ITfMessagePump_Value;
pub const ITfMessagePump = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PeekMessageA: fn(
            self: *const ITfMessagePump,
            pMsg: *MSG,
            hwnd: HWND,
            wMsgFilterMin: u32,
            wMsgFilterMax: u32,
            wRemoveMsg: u32,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageA: fn(
            self: *const ITfMessagePump,
            pMsg: *MSG,
            hwnd: HWND,
            wMsgFilterMin: u32,
            wMsgFilterMax: u32,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PeekMessageW: fn(
            self: *const ITfMessagePump,
            pMsg: *MSG,
            hwnd: HWND,
            wMsgFilterMin: u32,
            wMsgFilterMax: u32,
            wRemoveMsg: u32,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageW: fn(
            self: *const ITfMessagePump,
            pMsg: *MSG,
            hwnd: HWND,
            wMsgFilterMin: u32,
            wMsgFilterMax: u32,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMessagePump_PeekMessageA(self: *const T, pMsg: *MSG, hwnd: HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMsg: u32, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMessagePump.VTable, self.vtable).PeekMessageA(@ptrCast(*const ITfMessagePump, self), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMessagePump_GetMessageA(self: *const T, pMsg: *MSG, hwnd: HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMessagePump.VTable, self.vtable).GetMessageA(@ptrCast(*const ITfMessagePump, self), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMessagePump_PeekMessageW(self: *const T, pMsg: *MSG, hwnd: HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMsg: u32, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMessagePump.VTable, self.vtable).PeekMessageW(@ptrCast(*const ITfMessagePump, self), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMessagePump_GetMessageW(self: *const T, pMsg: *MSG, hwnd: HWND, wMsgFilterMin: u32, wMsgFilterMax: u32, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMessagePump.VTable, self.vtable).GetMessageW(@ptrCast(*const ITfMessagePump, self), pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, pfResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfThreadFocusSink_Value = @import("../zig.zig").Guid.initString("c0f1db0c-3a20-405c-a303-96b6010a885f");
pub const IID_ITfThreadFocusSink = &IID_ITfThreadFocusSink_Value;
pub const ITfThreadFocusSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetThreadFocus: fn(
            self: *const ITfThreadFocusSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKillThreadFocus: fn(
            self: *const ITfThreadFocusSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadFocusSink_OnSetThreadFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadFocusSink.VTable, self.vtable).OnSetThreadFocus(@ptrCast(*const ITfThreadFocusSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfThreadFocusSink_OnKillThreadFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfThreadFocusSink.VTable, self.vtable).OnKillThreadFocus(@ptrCast(*const ITfThreadFocusSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessor_Value = @import("../zig.zig").Guid.initString("aa80e7f7-2021-11d2-93e0-0060b067b86e");
pub const IID_ITfTextInputProcessor = &IID_ITfTextInputProcessor_Value;
pub const ITfTextInputProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: fn(
            self: *const ITfTextInputProcessor,
            ptim: *ITfThreadMgr,
            tid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const ITfTextInputProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTextInputProcessor_Activate(self: *const T, ptim: *ITfThreadMgr, tid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTextInputProcessor.VTable, self.vtable).Activate(@ptrCast(*const ITfTextInputProcessor, self), ptim, tid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTextInputProcessor_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTextInputProcessor.VTable, self.vtable).Deactivate(@ptrCast(*const ITfTextInputProcessor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTextInputProcessorEx_Value = @import("../zig.zig").Guid.initString("6e4e2102-f9cd-433d-b496-303ce03a6507");
pub const IID_ITfTextInputProcessorEx = &IID_ITfTextInputProcessorEx_Value;
pub const ITfTextInputProcessorEx = extern struct {
    pub const VTable = extern struct {
        base: ITfTextInputProcessor.VTable,
        ActivateEx: fn(
            self: *const ITfTextInputProcessorEx,
            ptim: *ITfThreadMgr,
            tid: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfTextInputProcessor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTextInputProcessorEx_ActivateEx(self: *const T, ptim: *ITfThreadMgr, tid: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTextInputProcessorEx.VTable, self.vtable).ActivateEx(@ptrCast(*const ITfTextInputProcessorEx, self), ptim, tid, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfClientId_Value = @import("../zig.zig").Guid.initString("d60a7b49-1b9f-4be2-b702-47e9dc05dec3");
pub const IID_ITfClientId = &IID_ITfClientId_Value;
pub const ITfClientId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientId: fn(
            self: *const ITfClientId,
            rclsid: *const Guid,
            ptid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfClientId_GetClientId(self: *const T, rclsid: *const Guid, ptid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfClientId.VTable, self.vtable).GetClientId(@ptrCast(*const ITfClientId, self), rclsid, ptid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_DA_LINESTYLE = extern enum(i32) {
    NONE = 0,
    SOLID = 1,
    DOT = 2,
    DASH = 3,
    SQUIGGLE = 4,
};
pub const TF_LS_NONE = TF_DA_LINESTYLE.NONE;
pub const TF_LS_SOLID = TF_DA_LINESTYLE.SOLID;
pub const TF_LS_DOT = TF_DA_LINESTYLE.DOT;
pub const TF_LS_DASH = TF_DA_LINESTYLE.DASH;
pub const TF_LS_SQUIGGLE = TF_DA_LINESTYLE.SQUIGGLE;

pub const TF_DA_COLORTYPE = extern enum(i32) {
    NONE = 0,
    SYSCOLOR = 1,
    COLORREF = 2,
};
pub const TF_CT_NONE = TF_DA_COLORTYPE.NONE;
pub const TF_CT_SYSCOLOR = TF_DA_COLORTYPE.SYSCOLOR;
pub const TF_CT_COLORREF = TF_DA_COLORTYPE.COLORREF;

pub const TF_DA_COLOR = extern struct {
    type: TF_DA_COLORTYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TF_DA_ATTR_INFO = extern enum(i32) {
    INPUT = 0,
    TARGET_CONVERTED = 1,
    CONVERTED = 2,
    TARGET_NOTCONVERTED = 3,
    INPUT_ERROR = 4,
    FIXEDCONVERTED = 5,
    OTHER = -1,
};
pub const TF_ATTR_INPUT = TF_DA_ATTR_INFO.INPUT;
pub const TF_ATTR_TARGET_CONVERTED = TF_DA_ATTR_INFO.TARGET_CONVERTED;
pub const TF_ATTR_CONVERTED = TF_DA_ATTR_INFO.CONVERTED;
pub const TF_ATTR_TARGET_NOTCONVERTED = TF_DA_ATTR_INFO.TARGET_NOTCONVERTED;
pub const TF_ATTR_INPUT_ERROR = TF_DA_ATTR_INFO.INPUT_ERROR;
pub const TF_ATTR_FIXEDCONVERTED = TF_DA_ATTR_INFO.FIXEDCONVERTED;
pub const TF_ATTR_OTHER = TF_DA_ATTR_INFO.OTHER;

pub const TF_DISPLAYATTRIBUTE = extern struct {
    crText: TF_DA_COLOR,
    crBk: TF_DA_COLOR,
    lsStyle: TF_DA_LINESTYLE,
    fBoldLine: BOOL,
    crLine: TF_DA_COLOR,
    bAttr: TF_DA_ATTR_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeInfo_Value = @import("../zig.zig").Guid.initString("70528852-2f26-4aea-8c96-215150578932");
pub const IID_ITfDisplayAttributeInfo = &IID_ITfDisplayAttributeInfo_Value;
pub const ITfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: fn(
            self: *const ITfDisplayAttributeInfo,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const ITfDisplayAttributeInfo,
            pbstrDesc: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeInfo: fn(
            self: *const ITfDisplayAttributeInfo,
            pda: *TF_DISPLAYATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAttributeInfo: fn(
            self: *const ITfDisplayAttributeInfo,
            pda: *const TF_DISPLAYATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeInfo_GetGUID(self: *const T, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeInfo.VTable, self.vtable).GetGUID(@ptrCast(*const ITfDisplayAttributeInfo, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeInfo_GetDescription(self: *const T, pbstrDesc: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeInfo.VTable, self.vtable).GetDescription(@ptrCast(*const ITfDisplayAttributeInfo, self), pbstrDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeInfo_GetAttributeInfo(self: *const T, pda: *TF_DISPLAYATTRIBUTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeInfo.VTable, self.vtable).GetAttributeInfo(@ptrCast(*const ITfDisplayAttributeInfo, self), pda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeInfo_SetAttributeInfo(self: *const T, pda: *const TF_DISPLAYATTRIBUTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeInfo.VTable, self.vtable).SetAttributeInfo(@ptrCast(*const ITfDisplayAttributeInfo, self), pda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeInfo.VTable, self.vtable).Reset(@ptrCast(*const ITfDisplayAttributeInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfDisplayAttributeInfo_Value = @import("../zig.zig").Guid.initString("7cef04d7-cb75-4e80-a7ab-5f5bc7d332de");
pub const IID_IEnumTfDisplayAttributeInfo = &IID_IEnumTfDisplayAttributeInfo_Value;
pub const IEnumTfDisplayAttributeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfDisplayAttributeInfo,
            ppEnum: **IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfDisplayAttributeInfo,
            ulCount: u32,
            rgInfo: [*]*ITfDisplayAttributeInfo,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfDisplayAttributeInfo,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDisplayAttributeInfo_Clone(self: *const T, ppEnum: **IEnumTfDisplayAttributeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDisplayAttributeInfo.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfDisplayAttributeInfo, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDisplayAttributeInfo_Next(self: *const T, ulCount: u32, rgInfo: [*]*ITfDisplayAttributeInfo, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDisplayAttributeInfo.VTable, self.vtable).Next(@ptrCast(*const IEnumTfDisplayAttributeInfo, self), ulCount, rgInfo, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDisplayAttributeInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDisplayAttributeInfo.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfDisplayAttributeInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfDisplayAttributeInfo_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfDisplayAttributeInfo.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfDisplayAttributeInfo, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeProvider_Value = @import("../zig.zig").Guid.initString("fee47777-163c-4769-996a-6e9c50ad8f54");
pub const IID_ITfDisplayAttributeProvider = &IID_ITfDisplayAttributeProvider_Value;
pub const ITfDisplayAttributeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumDisplayAttributeInfo: fn(
            self: *const ITfDisplayAttributeProvider,
            ppEnum: **IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAttributeInfo: fn(
            self: *const ITfDisplayAttributeProvider,
            guid: *const Guid,
            ppInfo: **ITfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeProvider_EnumDisplayAttributeInfo(self: *const T, ppEnum: **IEnumTfDisplayAttributeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeProvider.VTable, self.vtable).EnumDisplayAttributeInfo(@ptrCast(*const ITfDisplayAttributeProvider, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeProvider_GetDisplayAttributeInfo(self: *const T, guid: *const Guid, ppInfo: **ITfDisplayAttributeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeProvider.VTable, self.vtable).GetDisplayAttributeInfo(@ptrCast(*const ITfDisplayAttributeProvider, self), guid, ppInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeMgr_Value = @import("../zig.zig").Guid.initString("8ded7393-5db1-475c-9e71-a39111b0ff67");
pub const IID_ITfDisplayAttributeMgr = &IID_ITfDisplayAttributeMgr_Value;
pub const ITfDisplayAttributeMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: fn(
            self: *const ITfDisplayAttributeMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDisplayAttributeInfo: fn(
            self: *const ITfDisplayAttributeMgr,
            ppEnum: **IEnumTfDisplayAttributeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAttributeInfo: fn(
            self: *const ITfDisplayAttributeMgr,
            guid: *const Guid,
            ppInfo: **ITfDisplayAttributeInfo,
            pclsidOwner: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeMgr_OnUpdateInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeMgr.VTable, self.vtable).OnUpdateInfo(@ptrCast(*const ITfDisplayAttributeMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeMgr_EnumDisplayAttributeInfo(self: *const T, ppEnum: **IEnumTfDisplayAttributeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeMgr.VTable, self.vtable).EnumDisplayAttributeInfo(@ptrCast(*const ITfDisplayAttributeMgr, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeMgr_GetDisplayAttributeInfo(self: *const T, guid: *const Guid, ppInfo: **ITfDisplayAttributeInfo, pclsidOwner: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeMgr.VTable, self.vtable).GetDisplayAttributeInfo(@ptrCast(*const ITfDisplayAttributeMgr, self), guid, ppInfo, pclsidOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfDisplayAttributeNotifySink_Value = @import("../zig.zig").Guid.initString("ad56f402-e162-4f25-908f-7d577cf9bda9");
pub const IID_ITfDisplayAttributeNotifySink = &IID_ITfDisplayAttributeNotifySink_Value;
pub const ITfDisplayAttributeNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateInfo: fn(
            self: *const ITfDisplayAttributeNotifySink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfDisplayAttributeNotifySink_OnUpdateInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfDisplayAttributeNotifySink.VTable, self.vtable).OnUpdateInfo(@ptrCast(*const ITfDisplayAttributeNotifySink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCategoryMgr_Value = @import("../zig.zig").Guid.initString("c3acefb5-f69d-4905-938f-fcadcf4be830");
pub const IID_ITfCategoryMgr = &IID_ITfCategoryMgr_Value;
pub const ITfCategoryMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategory: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rcatid: *const Guid,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterCategory: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rcatid: *const Guid,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCategoriesInItem: fn(
            self: *const ITfCategoryMgr,
            rguid: *const Guid,
            ppEnum: **IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumItemsInCategory: fn(
            self: *const ITfCategoryMgr,
            rcatid: *const Guid,
            ppEnum: **IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindClosestCategory: fn(
            self: *const ITfCategoryMgr,
            rguid: *const Guid,
            pcatid: *Guid,
            ppcatidList: [*]const *const Guid,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUIDDescription: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rguid: *const Guid,
            pchDesc: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterGUIDDescription: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUIDDescription: fn(
            self: *const ITfCategoryMgr,
            rguid: *const Guid,
            pbstrDesc: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUIDDWORD: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rguid: *const Guid,
            dw: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterGUIDDWORD: fn(
            self: *const ITfCategoryMgr,
            rclsid: *const Guid,
            rguid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUIDDWORD: fn(
            self: *const ITfCategoryMgr,
            rguid: *const Guid,
            pdw: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGUID: fn(
            self: *const ITfCategoryMgr,
            rguid: *const Guid,
            pguidatom: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUID: fn(
            self: *const ITfCategoryMgr,
            guidatom: u32,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTfGuidAtom: fn(
            self: *const ITfCategoryMgr,
            guidatom: u32,
            rguid: *const Guid,
            pfEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_RegisterCategory(self: *const T, rclsid: *const Guid, rcatid: *const Guid, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).RegisterCategory(@ptrCast(*const ITfCategoryMgr, self), rclsid, rcatid, rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_UnregisterCategory(self: *const T, rclsid: *const Guid, rcatid: *const Guid, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).UnregisterCategory(@ptrCast(*const ITfCategoryMgr, self), rclsid, rcatid, rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_EnumCategoriesInItem(self: *const T, rguid: *const Guid, ppEnum: **IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).EnumCategoriesInItem(@ptrCast(*const ITfCategoryMgr, self), rguid, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_EnumItemsInCategory(self: *const T, rcatid: *const Guid, ppEnum: **IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).EnumItemsInCategory(@ptrCast(*const ITfCategoryMgr, self), rcatid, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_FindClosestCategory(self: *const T, rguid: *const Guid, pcatid: *Guid, ppcatidList: [*]const *const Guid, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).FindClosestCategory(@ptrCast(*const ITfCategoryMgr, self), rguid, pcatid, ppcatidList, ulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_RegisterGUIDDescription(self: *const T, rclsid: *const Guid, rguid: *const Guid, pchDesc: [*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).RegisterGUIDDescription(@ptrCast(*const ITfCategoryMgr, self), rclsid, rguid, pchDesc, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_UnregisterGUIDDescription(self: *const T, rclsid: *const Guid, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).UnregisterGUIDDescription(@ptrCast(*const ITfCategoryMgr, self), rclsid, rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_GetGUIDDescription(self: *const T, rguid: *const Guid, pbstrDesc: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).GetGUIDDescription(@ptrCast(*const ITfCategoryMgr, self), rguid, pbstrDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_RegisterGUIDDWORD(self: *const T, rclsid: *const Guid, rguid: *const Guid, dw: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).RegisterGUIDDWORD(@ptrCast(*const ITfCategoryMgr, self), rclsid, rguid, dw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_UnregisterGUIDDWORD(self: *const T, rclsid: *const Guid, rguid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).UnregisterGUIDDWORD(@ptrCast(*const ITfCategoryMgr, self), rclsid, rguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_GetGUIDDWORD(self: *const T, rguid: *const Guid, pdw: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).GetGUIDDWORD(@ptrCast(*const ITfCategoryMgr, self), rguid, pdw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_RegisterGUID(self: *const T, rguid: *const Guid, pguidatom: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).RegisterGUID(@ptrCast(*const ITfCategoryMgr, self), rguid, pguidatom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_GetGUID(self: *const T, guidatom: u32, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).GetGUID(@ptrCast(*const ITfCategoryMgr, self), guidatom, pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCategoryMgr_IsEqualTfGuidAtom(self: *const T, guidatom: u32, rguid: *const Guid, pfEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCategoryMgr.VTable, self.vtable).IsEqualTfGuidAtom(@ptrCast(*const ITfCategoryMgr, self), guidatom, rguid, pfEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSource_Value = @import("../zig.zig").Guid.initString("4ea48a35-60ae-446f-8fd6-e6a8d82459f7");
pub const IID_ITfSource = &IID_ITfSource_Value;
pub const ITfSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSink: fn(
            self: *const ITfSource,
            riid: *const Guid,
            punk: *IUnknown,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSink: fn(
            self: *const ITfSource,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSource_AdviseSink(self: *const T, riid: *const Guid, punk: *IUnknown, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSource.VTable, self.vtable).AdviseSink(@ptrCast(*const ITfSource, self), riid, punk, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSource_UnadviseSink(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSource.VTable, self.vtable).UnadviseSink(@ptrCast(*const ITfSource, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSourceSingle_Value = @import("../zig.zig").Guid.initString("73131f9c-56a9-49dd-b0ee-d046633f7528");
pub const IID_ITfSourceSingle = &IID_ITfSourceSingle_Value;
pub const ITfSourceSingle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSingleSink: fn(
            self: *const ITfSourceSingle,
            tid: u32,
            riid: *const Guid,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnadviseSingleSink: fn(
            self: *const ITfSourceSingle,
            tid: u32,
            riid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSourceSingle_AdviseSingleSink(self: *const T, tid: u32, riid: *const Guid, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSourceSingle.VTable, self.vtable).AdviseSingleSink(@ptrCast(*const ITfSourceSingle, self), tid, riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSourceSingle_UnadviseSingleSink(self: *const T, tid: u32, riid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSourceSingle.VTable, self.vtable).UnadviseSingleSink(@ptrCast(*const ITfSourceSingle, self), tid, riid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementMgr_Value = @import("../zig.zig").Guid.initString("ea1ea135-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementMgr = &IID_ITfUIElementMgr_Value;
pub const ITfUIElementMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: fn(
            self: *const ITfUIElementMgr,
            pElement: *ITfUIElement,
            pbShow: *BOOL,
            pdwUIElementId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateUIElement: fn(
            self: *const ITfUIElementMgr,
            dwUIElementId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUIElement: fn(
            self: *const ITfUIElementMgr,
            dwUIElementId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUIElement: fn(
            self: *const ITfUIElementMgr,
            dwUIELementId: u32,
            ppElement: **ITfUIElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumUIElements: fn(
            self: *const ITfUIElementMgr,
            ppEnum: **IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementMgr_BeginUIElement(self: *const T, pElement: *ITfUIElement, pbShow: *BOOL, pdwUIElementId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementMgr.VTable, self.vtable).BeginUIElement(@ptrCast(*const ITfUIElementMgr, self), pElement, pbShow, pdwUIElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementMgr_UpdateUIElement(self: *const T, dwUIElementId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementMgr.VTable, self.vtable).UpdateUIElement(@ptrCast(*const ITfUIElementMgr, self), dwUIElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementMgr_EndUIElement(self: *const T, dwUIElementId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementMgr.VTable, self.vtable).EndUIElement(@ptrCast(*const ITfUIElementMgr, self), dwUIElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementMgr_GetUIElement(self: *const T, dwUIELementId: u32, ppElement: **ITfUIElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementMgr.VTable, self.vtable).GetUIElement(@ptrCast(*const ITfUIElementMgr, self), dwUIELementId, ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementMgr_EnumUIElements(self: *const T, ppEnum: **IEnumTfUIElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementMgr.VTable, self.vtable).EnumUIElements(@ptrCast(*const ITfUIElementMgr, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfUIElements_Value = @import("../zig.zig").Guid.initString("887aa91e-acba-4931-84da-3c5208cf543f");
pub const IID_IEnumTfUIElements = &IID_IEnumTfUIElements_Value;
pub const IEnumTfUIElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfUIElements,
            ppEnum: **IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfUIElements,
            ulCount: u32,
            ppElement: [*]*ITfUIElement,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfUIElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfUIElements,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfUIElements_Clone(self: *const T, ppEnum: **IEnumTfUIElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfUIElements.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfUIElements, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfUIElements_Next(self: *const T, ulCount: u32, ppElement: [*]*ITfUIElement, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfUIElements.VTable, self.vtable).Next(@ptrCast(*const IEnumTfUIElements, self), ulCount, ppElement, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfUIElements_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfUIElements.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfUIElements, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfUIElements_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfUIElements.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfUIElements, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElementSink_Value = @import("../zig.zig").Guid.initString("ea1ea136-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElementSink = &IID_ITfUIElementSink_Value;
pub const ITfUIElementSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginUIElement: fn(
            self: *const ITfUIElementSink,
            dwUIElementId: u32,
            pbShow: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateUIElement: fn(
            self: *const ITfUIElementSink,
            dwUIElementId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUIElement: fn(
            self: *const ITfUIElementSink,
            dwUIElementId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementSink_BeginUIElement(self: *const T, dwUIElementId: u32, pbShow: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementSink.VTable, self.vtable).BeginUIElement(@ptrCast(*const ITfUIElementSink, self), dwUIElementId, pbShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementSink_UpdateUIElement(self: *const T, dwUIElementId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementSink.VTable, self.vtable).UpdateUIElement(@ptrCast(*const ITfUIElementSink, self), dwUIElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElementSink_EndUIElement(self: *const T, dwUIElementId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElementSink.VTable, self.vtable).EndUIElement(@ptrCast(*const ITfUIElementSink, self), dwUIElementId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfUIElement_Value = @import("../zig.zig").Guid.initString("ea1ea137-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfUIElement = &IID_ITfUIElement_Value;
pub const ITfUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDescription: fn(
            self: *const ITfUIElement,
            pbstrDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUID: fn(
            self: *const ITfUIElement,
            pguid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const ITfUIElement,
            bShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsShown: fn(
            self: *const ITfUIElement,
            pbShow: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElement_GetDescription(self: *const T, pbstrDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElement.VTable, self.vtable).GetDescription(@ptrCast(*const ITfUIElement, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElement_GetGUID(self: *const T, pguid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElement.VTable, self.vtable).GetGUID(@ptrCast(*const ITfUIElement, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElement_Show(self: *const T, bShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElement.VTable, self.vtable).Show(@ptrCast(*const ITfUIElement, self), bShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfUIElement_IsShown(self: *const T, pbShow: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfUIElement.VTable, self.vtable).IsShown(@ptrCast(*const ITfUIElement, self), pbShow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElement_Value = @import("../zig.zig").Guid.initString("ea1ea138-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfCandidateListUIElement = &IID_ITfCandidateListUIElement_Value;
pub const ITfCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: fn(
            self: *const ITfCandidateListUIElement,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentMgr: fn(
            self: *const ITfCandidateListUIElement,
            ppdim: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITfCandidateListUIElement,
            puCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITfCandidateListUIElement,
            puIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const ITfCandidateListUIElement,
            uIndex: u32,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageIndex: fn(
            self: *const ITfCandidateListUIElement,
            pIndex: [*]u32,
            uSize: u32,
            puPageCnt: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageIndex: fn(
            self: *const ITfCandidateListUIElement,
            pIndex: [*]u32,
            uPageCnt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPage: fn(
            self: *const ITfCandidateListUIElement,
            puPage: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfUIElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetUpdatedFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetUpdatedFlags(@ptrCast(*const ITfCandidateListUIElement, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetDocumentMgr(self: *const T, ppdim: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetDocumentMgr(@ptrCast(*const ITfCandidateListUIElement, self), ppdim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetCount(self: *const T, puCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetCount(@ptrCast(*const ITfCandidateListUIElement, self), puCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetSelection(self: *const T, puIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetSelection(@ptrCast(*const ITfCandidateListUIElement, self), puIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetString(self: *const T, uIndex: u32, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetString(@ptrCast(*const ITfCandidateListUIElement, self), uIndex, pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetPageIndex(self: *const T, pIndex: [*]u32, uSize: u32, puPageCnt: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetPageIndex(@ptrCast(*const ITfCandidateListUIElement, self), pIndex, uSize, puPageCnt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_SetPageIndex(self: *const T, pIndex: [*]u32, uPageCnt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).SetPageIndex(@ptrCast(*const ITfCandidateListUIElement, self), pIndex, uPageCnt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElement_GetCurrentPage(self: *const T, puPage: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElement.VTable, self.vtable).GetCurrentPage(@ptrCast(*const ITfCandidateListUIElement, self), puPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateListUIElementBehavior_Value = @import("../zig.zig").Guid.initString("85fad185-58ce-497a-9460-355366b64b9a");
pub const IID_ITfCandidateListUIElementBehavior = &IID_ITfCandidateListUIElementBehavior_Value;
pub const ITfCandidateListUIElementBehavior = extern struct {
    pub const VTable = extern struct {
        base: ITfCandidateListUIElement.VTable,
        SetSelection: fn(
            self: *const ITfCandidateListUIElementBehavior,
            nIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: fn(
            self: *const ITfCandidateListUIElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const ITfCandidateListUIElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfCandidateListUIElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElementBehavior_SetSelection(self: *const T, nIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElementBehavior.VTable, self.vtable).SetSelection(@ptrCast(*const ITfCandidateListUIElementBehavior, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElementBehavior_Finalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElementBehavior.VTable, self.vtable).Finalize(@ptrCast(*const ITfCandidateListUIElementBehavior, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateListUIElementBehavior_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateListUIElementBehavior.VTable, self.vtable).Abort(@ptrCast(*const ITfCandidateListUIElementBehavior, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfReadingInformationUIElement_Value = @import("../zig.zig").Guid.initString("ea1ea139-19df-11d7-a6d2-00065b84435c");
pub const IID_ITfReadingInformationUIElement = &IID_ITfReadingInformationUIElement_Value;
pub const ITfReadingInformationUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetUpdatedFlags: fn(
            self: *const ITfReadingInformationUIElement,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const ITfReadingInformationUIElement,
            ppic: **ITfContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const ITfReadingInformationUIElement,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxReadingStringLength: fn(
            self: *const ITfReadingInformationUIElement,
            pcchMax: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorIndex: fn(
            self: *const ITfReadingInformationUIElement,
            pErrorIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVerticalOrderPreferred: fn(
            self: *const ITfReadingInformationUIElement,
            pfVertical: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfUIElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_GetUpdatedFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).GetUpdatedFlags(@ptrCast(*const ITfReadingInformationUIElement, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_GetContext(self: *const T, ppic: **ITfContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).GetContext(@ptrCast(*const ITfReadingInformationUIElement, self), ppic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_GetString(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).GetString(@ptrCast(*const ITfReadingInformationUIElement, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_GetMaxReadingStringLength(self: *const T, pcchMax: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).GetMaxReadingStringLength(@ptrCast(*const ITfReadingInformationUIElement, self), pcchMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_GetErrorIndex(self: *const T, pErrorIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).GetErrorIndex(@ptrCast(*const ITfReadingInformationUIElement, self), pErrorIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReadingInformationUIElement_IsVerticalOrderPreferred(self: *const T, pfVertical: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReadingInformationUIElement.VTable, self.vtable).IsVerticalOrderPreferred(@ptrCast(*const ITfReadingInformationUIElement, self), pfVertical);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionUIElement_Value = @import("../zig.zig").Guid.initString("858f956a-972f-42a2-a2f2-0321e1abe209");
pub const IID_ITfTransitoryExtensionUIElement = &IID_ITfTransitoryExtensionUIElement_Value;
pub const ITfTransitoryExtensionUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetDocumentMgr: fn(
            self: *const ITfTransitoryExtensionUIElement,
            ppdim: **ITfDocumentMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfUIElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTransitoryExtensionUIElement_GetDocumentMgr(self: *const T, ppdim: **ITfDocumentMgr) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTransitoryExtensionUIElement.VTable, self.vtable).GetDocumentMgr(@ptrCast(*const ITfTransitoryExtensionUIElement, self), ppdim);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfTransitoryExtensionSink_Value = @import("../zig.zig").Guid.initString("a615096f-1c57-4813-8a15-55ee6e5a839c");
pub const IID_ITfTransitoryExtensionSink = &IID_ITfTransitoryExtensionSink_Value;
pub const ITfTransitoryExtensionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTransitoryExtensionUpdated: fn(
            self: *const ITfTransitoryExtensionSink,
            pic: *ITfContext,
            ecReadOnly: u32,
            pResultRange: *ITfRange,
            pCompositionRange: *ITfRange,
            pfDeleteResultRange: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfTransitoryExtensionSink_OnTransitoryExtensionUpdated(self: *const T, pic: *ITfContext, ecReadOnly: u32, pResultRange: *ITfRange, pCompositionRange: *ITfRange, pfDeleteResultRange: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfTransitoryExtensionSink.VTable, self.vtable).OnTransitoryExtensionUpdated(@ptrCast(*const ITfTransitoryExtensionSink, self), pic, ecReadOnly, pResultRange, pCompositionRange, pfDeleteResultRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfToolTipUIElement_Value = @import("../zig.zig").Guid.initString("52b18b5c-555d-46b2-b00a-fa680144fbdb");
pub const IID_ITfToolTipUIElement = &IID_ITfToolTipUIElement_Value;
pub const ITfToolTipUIElement = extern struct {
    pub const VTable = extern struct {
        base: ITfUIElement.VTable,
        GetString: fn(
            self: *const ITfToolTipUIElement,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfUIElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfToolTipUIElement_GetString(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfToolTipUIElement.VTable, self.vtable).GetString(@ptrCast(*const ITfToolTipUIElement, self), pstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionList_Value = @import("../zig.zig").Guid.initString("151d69f0-86f4-4674-b721-56911e797f47");
pub const IID_ITfReverseConversionList = &IID_ITfReverseConversionList_Value;
pub const ITfReverseConversionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const ITfReverseConversionList,
            puIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const ITfReverseConversionList,
            uIndex: u32,
            pbstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReverseConversionList_GetLength(self: *const T, puIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReverseConversionList.VTable, self.vtable).GetLength(@ptrCast(*const ITfReverseConversionList, self), puIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReverseConversionList_GetString(self: *const T, uIndex: u32, pbstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReverseConversionList.VTable, self.vtable).GetString(@ptrCast(*const ITfReverseConversionList, self), uIndex, pbstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversion_Value = @import("../zig.zig").Guid.initString("a415e162-157d-417d-8a8c-0ab26c7d2781");
pub const IID_ITfReverseConversion = &IID_ITfReverseConversion_Value;
pub const ITfReverseConversion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoReverseConversion: fn(
            self: *const ITfReverseConversion,
            lpstr: [*:0]const u16,
            ppList: **ITfReverseConversionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReverseConversion_DoReverseConversion(self: *const T, lpstr: [*:0]const u16, ppList: **ITfReverseConversionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReverseConversion.VTable, self.vtable).DoReverseConversion(@ptrCast(*const ITfReverseConversion, self), lpstr, ppList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITfReverseConversionMgr_Value = @import("../zig.zig").Guid.initString("b643c236-c493-41b6-abb3-692412775cc4");
pub const IID_ITfReverseConversionMgr = &IID_ITfReverseConversionMgr_Value;
pub const ITfReverseConversionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReverseConversion: fn(
            self: *const ITfReverseConversionMgr,
            langid: u16,
            guidProfile: *const Guid,
            dwflag: u32,
            ppReverseConversion: **ITfReverseConversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfReverseConversionMgr_GetReverseConversion(self: *const T, langid: u16, guidProfile: *const Guid, dwflag: u32, ppReverseConversion: **ITfReverseConversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfReverseConversionMgr.VTable, self.vtable).GetReverseConversion(@ptrCast(*const ITfReverseConversionMgr, self), langid, guidProfile, dwflag, ppReverseConversion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateString_Value = @import("../zig.zig").Guid.initString("581f317e-fd9d-443f-b972-ed00467c5d40");
pub const IID_ITfCandidateString = &IID_ITfCandidateString_Value;
pub const ITfCandidateString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetString: fn(
            self: *const ITfCandidateString,
            pbstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITfCandidateString,
            pnIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateString_GetString(self: *const T, pbstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateString.VTable, self.vtable).GetString(@ptrCast(*const ITfCandidateString, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateString_GetIndex(self: *const T, pnIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateString.VTable, self.vtable).GetIndex(@ptrCast(*const ITfCandidateString, self), pnIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfCandidates_Value = @import("../zig.zig").Guid.initString("defb1926-6c80-4ce8-87d4-d6b72b812bde");
pub const IID_IEnumTfCandidates = &IID_IEnumTfCandidates_Value;
pub const IEnumTfCandidates = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfCandidates,
            ppEnum: **IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfCandidates,
            ulCount: u32,
            ppCand: [*]*ITfCandidateString,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfCandidates,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfCandidates_Clone(self: *const T, ppEnum: **IEnumTfCandidates) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfCandidates.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfCandidates, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfCandidates_Next(self: *const T, ulCount: u32, ppCand: [*]*ITfCandidateString, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfCandidates.VTable, self.vtable).Next(@ptrCast(*const IEnumTfCandidates, self), ulCount, ppCand, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfCandidates_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfCandidates.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfCandidates, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfCandidates_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfCandidates.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfCandidates, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfCandidateResult = extern enum(i32) {
    FINALIZED = 0,
    SELECTED = 1,
    CANCELED = 2,
};
pub const CAND_FINALIZED = TfCandidateResult.FINALIZED;
pub const CAND_SELECTED = TfCandidateResult.SELECTED;
pub const CAND_CANCELED = TfCandidateResult.CANCELED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfCandidateList_Value = @import("../zig.zig").Guid.initString("a3ad50fb-9bdb-49e3-a843-6c76520fbf5d");
pub const IID_ITfCandidateList = &IID_ITfCandidateList_Value;
pub const ITfCandidateList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCandidates: fn(
            self: *const ITfCandidateList,
            ppEnum: **IEnumTfCandidates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidate: fn(
            self: *const ITfCandidateList,
            nIndex: u32,
            ppCand: **ITfCandidateString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateNum: fn(
            self: *const ITfCandidateList,
            pnCnt: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResult: fn(
            self: *const ITfCandidateList,
            nIndex: u32,
            imcr: TfCandidateResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateList_EnumCandidates(self: *const T, ppEnum: **IEnumTfCandidates) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateList.VTable, self.vtable).EnumCandidates(@ptrCast(*const ITfCandidateList, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateList_GetCandidate(self: *const T, nIndex: u32, ppCand: **ITfCandidateString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateList.VTable, self.vtable).GetCandidate(@ptrCast(*const ITfCandidateList, self), nIndex, ppCand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateList_GetCandidateNum(self: *const T, pnCnt: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateList.VTable, self.vtable).GetCandidateNum(@ptrCast(*const ITfCandidateList, self), pnCnt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfCandidateList_SetResult(self: *const T, nIndex: u32, imcr: TfCandidateResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfCandidateList.VTable, self.vtable).SetResult(@ptrCast(*const ITfCandidateList, self), nIndex, imcr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnReconversion_Value = @import("../zig.zig").Guid.initString("4cea93c0-0a58-11d3-8df0-00105a2799b5");
pub const IID_ITfFnReconversion = &IID_ITfFnReconversion_Value;
pub const ITfFnReconversion = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: fn(
            self: *const ITfFnReconversion,
            pRange: *ITfRange,
            ppNewRange: **ITfRange,
            pfConvertable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReconversion: fn(
            self: *const ITfFnReconversion,
            pRange: *ITfRange,
            ppCandList: **ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconvert: fn(
            self: *const ITfFnReconversion,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnReconversion_QueryRange(self: *const T, pRange: *ITfRange, ppNewRange: **ITfRange, pfConvertable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnReconversion.VTable, self.vtable).QueryRange(@ptrCast(*const ITfFnReconversion, self), pRange, ppNewRange, pfConvertable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnReconversion_GetReconversion(self: *const T, pRange: *ITfRange, ppCandList: **ITfCandidateList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnReconversion.VTable, self.vtable).GetReconversion(@ptrCast(*const ITfFnReconversion, self), pRange, ppCandList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnReconversion_Reconvert(self: *const T, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnReconversion.VTable, self.vtable).Reconvert(@ptrCast(*const ITfFnReconversion, self), pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPlayBack_Value = @import("../zig.zig").Guid.initString("a3a416a4-0f64-11d3-b5b7-00c04fc324a1");
pub const IID_ITfFnPlayBack = &IID_ITfFnPlayBack_Value;
pub const ITfFnPlayBack = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: fn(
            self: *const ITfFnPlayBack,
            pRange: *ITfRange,
            ppNewRange: **ITfRange,
            pfPlayable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Play: fn(
            self: *const ITfFnPlayBack,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnPlayBack_QueryRange(self: *const T, pRange: *ITfRange, ppNewRange: **ITfRange, pfPlayable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnPlayBack.VTable, self.vtable).QueryRange(@ptrCast(*const ITfFnPlayBack, self), pRange, ppNewRange, pfPlayable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnPlayBack_Play(self: *const T, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnPlayBack.VTable, self.vtable).Play(@ptrCast(*const ITfFnPlayBack, self), pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLangProfileUtil_Value = @import("../zig.zig").Guid.initString("a87a8574-a6c1-4e15-99f0-3d3965f548eb");
pub const IID_ITfFnLangProfileUtil = &IID_ITfFnLangProfileUtil_Value;
pub const ITfFnLangProfileUtil = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        RegisterActiveProfiles: fn(
            self: *const ITfFnLangProfileUtil,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProfileAvailableForLang: fn(
            self: *const ITfFnLangProfileUtil,
            langid: u16,
            pfAvailable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLangProfileUtil_RegisterActiveProfiles(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLangProfileUtil.VTable, self.vtable).RegisterActiveProfiles(@ptrCast(*const ITfFnLangProfileUtil, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLangProfileUtil_IsProfileAvailableForLang(self: *const T, langid: u16, pfAvailable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLangProfileUtil.VTable, self.vtable).IsProfileAvailableForLang(@ptrCast(*const ITfFnLangProfileUtil, self), langid, pfAvailable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigure_Value = @import("../zig.zig").Guid.initString("88f567c6-1757-49f8-a1b2-89234c1eeff9");
pub const IID_ITfFnConfigure = &IID_ITfFnConfigure_Value;
pub const ITfFnConfigure = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: fn(
            self: *const ITfFnConfigure,
            hwndParent: HWND,
            langid: u16,
            rguidProfile: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnConfigure_Show(self: *const T, hwndParent: HWND, langid: u16, rguidProfile: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnConfigure.VTable, self.vtable).Show(@ptrCast(*const ITfFnConfigure, self), hwndParent, langid, rguidProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterWord_Value = @import("../zig.zig").Guid.initString("bb95808a-6d8f-4bca-8400-5390b586aedf");
pub const IID_ITfFnConfigureRegisterWord = &IID_ITfFnConfigureRegisterWord_Value;
pub const ITfFnConfigureRegisterWord = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: fn(
            self: *const ITfFnConfigureRegisterWord,
            hwndParent: HWND,
            langid: u16,
            rguidProfile: *const Guid,
            bstrRegistered: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnConfigureRegisterWord_Show(self: *const T, hwndParent: HWND, langid: u16, rguidProfile: *const Guid, bstrRegistered: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnConfigureRegisterWord.VTable, self.vtable).Show(@ptrCast(*const ITfFnConfigureRegisterWord, self), hwndParent, langid, rguidProfile, bstrRegistered);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnConfigureRegisterEudc_Value = @import("../zig.zig").Guid.initString("b5e26ff5-d7ad-4304-913f-21a2ed95a1b0");
pub const IID_ITfFnConfigureRegisterEudc = &IID_ITfFnConfigureRegisterEudc_Value;
pub const ITfFnConfigureRegisterEudc = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: fn(
            self: *const ITfFnConfigureRegisterEudc,
            hwndParent: HWND,
            langid: u16,
            rguidProfile: *const Guid,
            bstrRegistered: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnConfigureRegisterEudc_Show(self: *const T, hwndParent: HWND, langid: u16, rguidProfile: *const Guid, bstrRegistered: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnConfigureRegisterEudc.VTable, self.vtable).Show(@ptrCast(*const ITfFnConfigureRegisterEudc, self), hwndParent, langid, rguidProfile, bstrRegistered);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnShowHelp_Value = @import("../zig.zig").Guid.initString("5ab1d30c-094d-4c29-8ea5-0bf59be87bf3");
pub const IID_ITfFnShowHelp = &IID_ITfFnShowHelp_Value;
pub const ITfFnShowHelp = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Show: fn(
            self: *const ITfFnShowHelp,
            hwndParent: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnShowHelp_Show(self: *const T, hwndParent: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnShowHelp.VTable, self.vtable).Show(@ptrCast(*const ITfFnShowHelp, self), hwndParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnBalloon_Value = @import("../zig.zig").Guid.initString("3bab89e4-5fbe-45f4-a5bc-dca36ad225a8");
pub const IID_ITfFnBalloon = &IID_ITfFnBalloon_Value;
pub const ITfFnBalloon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateBalloon: fn(
            self: *const ITfFnBalloon,
            style: TfLBBalloonStyle,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnBalloon_UpdateBalloon(self: *const T, style: TfLBBalloonStyle, pch: [*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnBalloon.VTable, self.vtable).UpdateBalloon(@ptrCast(*const ITfFnBalloon, self), style, pch, cch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfSapiObject = extern enum(i32) {
    RESMGR = 0,
    RECOCONTEXT = 1,
    RECOGNIZER = 2,
    VOICE = 3,
    DICTGRAM = 4,
    RECOGNIZERNOINIT = 5,
};
pub const GETIF_RESMGR = TfSapiObject.RESMGR;
pub const GETIF_RECOCONTEXT = TfSapiObject.RECOCONTEXT;
pub const GETIF_RECOGNIZER = TfSapiObject.RECOGNIZER;
pub const GETIF_VOICE = TfSapiObject.VOICE;
pub const GETIF_DICTGRAM = TfSapiObject.DICTGRAM;
pub const GETIF_RECOGNIZERNOINIT = TfSapiObject.RECOGNIZERNOINIT;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnGetSAPIObject_Value = @import("../zig.zig").Guid.initString("5c0ab7ea-167d-4f59-bfb5-4693755e90ca");
pub const IID_ITfFnGetSAPIObject = &IID_ITfFnGetSAPIObject_Value;
pub const ITfFnGetSAPIObject = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        Get: fn(
            self: *const ITfFnGetSAPIObject,
            sObj: TfSapiObject,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnGetSAPIObject_Get(self: *const T, sObj: TfSapiObject, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnGetSAPIObject.VTable, self.vtable).Get(@ptrCast(*const ITfFnGetSAPIObject, self), sObj, ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnPropertyUIStatus_Value = @import("../zig.zig").Guid.initString("2338ac6e-2b9d-44c0-a75e-ee64f256b3bd");
pub const IID_ITfFnPropertyUIStatus = &IID_ITfFnPropertyUIStatus_Value;
pub const ITfFnPropertyUIStatus = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetStatus: fn(
            self: *const ITfFnPropertyUIStatus,
            refguidProp: *const Guid,
            pdw: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const ITfFnPropertyUIStatus,
            refguidProp: *const Guid,
            dw: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnPropertyUIStatus_GetStatus(self: *const T, refguidProp: *const Guid, pdw: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnPropertyUIStatus.VTable, self.vtable).GetStatus(@ptrCast(*const ITfFnPropertyUIStatus, self), refguidProp, pdw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnPropertyUIStatus_SetStatus(self: *const T, refguidProp: *const Guid, dw: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnPropertyUIStatus.VTable, self.vtable).SetStatus(@ptrCast(*const ITfFnPropertyUIStatus, self), refguidProp, dw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMProcessor_Value = @import("../zig.zig").Guid.initString("7afbf8e7-ac4b-4082-b058-890899d3a010");
pub const IID_ITfFnLMProcessor = &IID_ITfFnLMProcessor_Value;
pub const ITfFnLMProcessor = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        QueryRange: fn(
            self: *const ITfFnLMProcessor,
            pRange: *ITfRange,
            ppNewRange: **ITfRange,
            pfAccepted: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryLangID: fn(
            self: *const ITfFnLMProcessor,
            langid: u16,
            pfAccepted: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReconversion: fn(
            self: *const ITfFnLMProcessor,
            pRange: *ITfRange,
            ppCandList: **ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconvert: fn(
            self: *const ITfFnLMProcessor,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryKey: fn(
            self: *const ITfFnLMProcessor,
            fUp: BOOL,
            vKey: WPARAM,
            lparamKeydata: LPARAM,
            pfInterested: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeKey: fn(
            self: *const ITfFnLMProcessor,
            fUp: BOOL,
            vKey: WPARAM,
            lparamKeyData: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeFunc: fn(
            self: *const ITfFnLMProcessor,
            pic: *ITfContext,
            refguidFunc: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_QueryRange(self: *const T, pRange: *ITfRange, ppNewRange: **ITfRange, pfAccepted: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).QueryRange(@ptrCast(*const ITfFnLMProcessor, self), pRange, ppNewRange, pfAccepted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_QueryLangID(self: *const T, langid: u16, pfAccepted: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).QueryLangID(@ptrCast(*const ITfFnLMProcessor, self), langid, pfAccepted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_GetReconversion(self: *const T, pRange: *ITfRange, ppCandList: **ITfCandidateList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).GetReconversion(@ptrCast(*const ITfFnLMProcessor, self), pRange, ppCandList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_Reconvert(self: *const T, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).Reconvert(@ptrCast(*const ITfFnLMProcessor, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_QueryKey(self: *const T, fUp: BOOL, vKey: WPARAM, lparamKeydata: LPARAM, pfInterested: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).QueryKey(@ptrCast(*const ITfFnLMProcessor, self), fUp, vKey, lparamKeydata, pfInterested);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_InvokeKey(self: *const T, fUp: BOOL, vKey: WPARAM, lparamKeyData: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).InvokeKey(@ptrCast(*const ITfFnLMProcessor, self), fUp, vKey, lparamKeyData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMProcessor_InvokeFunc(self: *const T, pic: *ITfContext, refguidFunc: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMProcessor.VTable, self.vtable).InvokeFunc(@ptrCast(*const ITfFnLMProcessor, self), pic, refguidFunc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnLMInternal_Value = @import("../zig.zig").Guid.initString("04b825b1-ac9a-4f7b-b5ad-c7168f1ee445");
pub const IID_ITfFnLMInternal = &IID_ITfFnLMInternal_Value;
pub const ITfFnLMInternal = extern struct {
    pub const VTable = extern struct {
        base: ITfFnLMProcessor.VTable,
        ProcessLattice: fn(
            self: *const ITfFnLMInternal,
            pRange: *ITfRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFnLMProcessor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnLMInternal_ProcessLattice(self: *const T, pRange: *ITfRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnLMInternal.VTable, self.vtable).ProcessLattice(@ptrCast(*const ITfFnLMInternal, self), pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TF_LMLATTELEMENT = extern struct {
    dwFrameStart: u32,
    dwFrameLen: u32,
    dwFlags: u32,
    Anonymous: _Anonymous_e__Union,
    bstrText: BSTR,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumTfLatticeElements_Value = @import("../zig.zig").Guid.initString("56988052-47da-4a05-911a-e3d941f17145");
pub const IID_IEnumTfLatticeElements = &IID_IEnumTfLatticeElements_Value;
pub const IEnumTfLatticeElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumTfLatticeElements,
            ppEnum: **IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumTfLatticeElements,
            ulCount: u32,
            rgsElements: [*]TF_LMLATTELEMENT,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTfLatticeElements,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLatticeElements_Clone(self: *const T, ppEnum: **IEnumTfLatticeElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLatticeElements.VTable, self.vtable).Clone(@ptrCast(*const IEnumTfLatticeElements, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLatticeElements_Next(self: *const T, ulCount: u32, rgsElements: [*]TF_LMLATTELEMENT, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLatticeElements.VTable, self.vtable).Next(@ptrCast(*const IEnumTfLatticeElements, self), ulCount, rgsElements, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLatticeElements_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLatticeElements.VTable, self.vtable).Reset(@ptrCast(*const IEnumTfLatticeElements, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTfLatticeElements_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTfLatticeElements.VTable, self.vtable).Skip(@ptrCast(*const IEnumTfLatticeElements, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfLMLattice_Value = @import("../zig.zig").Guid.initString("d4236675-a5bf-4570-9d42-5d6d7b02d59b");
pub const IID_ITfLMLattice = &IID_ITfLMLattice_Value;
pub const ITfLMLattice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryType: fn(
            self: *const ITfLMLattice,
            rguidType: *const Guid,
            pfSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumLatticeElements: fn(
            self: *const ITfLMLattice,
            dwFrameStart: u32,
            rguidType: *const Guid,
            ppEnum: **IEnumTfLatticeElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLMLattice_QueryType(self: *const T, rguidType: *const Guid, pfSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLMLattice.VTable, self.vtable).QueryType(@ptrCast(*const ITfLMLattice, self), rguidType, pfSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfLMLattice_EnumLatticeElements(self: *const T, dwFrameStart: u32, rguidType: *const Guid, ppEnum: **IEnumTfLatticeElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfLMLattice.VTable, self.vtable).EnumLatticeElements(@ptrCast(*const ITfLMLattice, self), dwFrameStart, rguidType, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfFnAdviseText_Value = @import("../zig.zig").Guid.initString("3527268b-7d53-4dd9-92b7-7296ae461249");
pub const IID_ITfFnAdviseText = &IID_ITfFnAdviseText_Value;
pub const ITfFnAdviseText = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        OnTextUpdate: fn(
            self: *const ITfFnAdviseText,
            pRange: *ITfRange,
            pchText: [*:0]const u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLatticeUpdate: fn(
            self: *const ITfFnAdviseText,
            pRange: *ITfRange,
            pLattice: *ITfLMLattice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnAdviseText_OnTextUpdate(self: *const T, pRange: *ITfRange, pchText: [*:0]const u16, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnAdviseText.VTable, self.vtable).OnTextUpdate(@ptrCast(*const ITfFnAdviseText, self), pRange, pchText, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnAdviseText_OnLatticeUpdate(self: *const T, pRange: *ITfRange, pLattice: *ITfLMLattice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnAdviseText.VTable, self.vtable).OnLatticeUpdate(@ptrCast(*const ITfFnAdviseText, self), pRange, pLattice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnSearchCandidateProvider_Value = @import("../zig.zig").Guid.initString("87a2ad8f-f27b-4920-8501-67602280175d");
pub const IID_ITfFnSearchCandidateProvider = &IID_ITfFnSearchCandidateProvider_Value;
pub const ITfFnSearchCandidateProvider = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetSearchCandidates: fn(
            self: *const ITfFnSearchCandidateProvider,
            bstrQuery: BSTR,
            bstrApplicationId: BSTR,
            pplist: **ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResult: fn(
            self: *const ITfFnSearchCandidateProvider,
            bstrQuery: BSTR,
            bstrApplicationID: BSTR,
            bstrResult: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnSearchCandidateProvider_GetSearchCandidates(self: *const T, bstrQuery: BSTR, bstrApplicationId: BSTR, pplist: **ITfCandidateList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnSearchCandidateProvider.VTable, self.vtable).GetSearchCandidates(@ptrCast(*const ITfFnSearchCandidateProvider, self), bstrQuery, bstrApplicationId, pplist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnSearchCandidateProvider_SetResult(self: *const T, bstrQuery: BSTR, bstrApplicationID: BSTR, bstrResult: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnSearchCandidateProvider.VTable, self.vtable).SetResult(@ptrCast(*const ITfFnSearchCandidateProvider, self), bstrQuery, bstrApplicationID, bstrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TfIntegratableCandidateListSelectionStyle = extern enum(i32) {
    ACTIVE_SELECTION = 0,
    IMPLIED_SELECTION = 1,
};
pub const STYLE_ACTIVE_SELECTION = TfIntegratableCandidateListSelectionStyle.ACTIVE_SELECTION;
pub const STYLE_IMPLIED_SELECTION = TfIntegratableCandidateListSelectionStyle.IMPLIED_SELECTION;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfIntegratableCandidateListUIElement_Value = @import("../zig.zig").Guid.initString("c7a6f54f-b180-416f-b2bf-7bf2e4683d7b");
pub const IID_ITfIntegratableCandidateListUIElement = &IID_ITfIntegratableCandidateListUIElement_Value;
pub const ITfIntegratableCandidateListUIElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIntegrationStyle: fn(
            self: *const ITfIntegratableCandidateListUIElement,
            guidIntegrationStyle: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionStyle: fn(
            self: *const ITfIntegratableCandidateListUIElement,
            ptfSelectionStyle: *TfIntegratableCandidateListSelectionStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyDown: fn(
            self: *const ITfIntegratableCandidateListUIElement,
            wParam: WPARAM,
            lParam: LPARAM,
            pfEaten: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowCandidateNumbers: fn(
            self: *const ITfIntegratableCandidateListUIElement,
            pfShow: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinalizeExactCompositionString: fn(
            self: *const ITfIntegratableCandidateListUIElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfIntegratableCandidateListUIElement_SetIntegrationStyle(self: *const T, guidIntegrationStyle: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfIntegratableCandidateListUIElement.VTable, self.vtable).SetIntegrationStyle(@ptrCast(*const ITfIntegratableCandidateListUIElement, self), guidIntegrationStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfIntegratableCandidateListUIElement_GetSelectionStyle(self: *const T, ptfSelectionStyle: *TfIntegratableCandidateListSelectionStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfIntegratableCandidateListUIElement.VTable, self.vtable).GetSelectionStyle(@ptrCast(*const ITfIntegratableCandidateListUIElement, self), ptfSelectionStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfIntegratableCandidateListUIElement_OnKeyDown(self: *const T, wParam: WPARAM, lParam: LPARAM, pfEaten: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfIntegratableCandidateListUIElement.VTable, self.vtable).OnKeyDown(@ptrCast(*const ITfIntegratableCandidateListUIElement, self), wParam, lParam, pfEaten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfIntegratableCandidateListUIElement_ShowCandidateNumbers(self: *const T, pfShow: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfIntegratableCandidateListUIElement.VTable, self.vtable).ShowCandidateNumbers(@ptrCast(*const ITfIntegratableCandidateListUIElement, self), pfShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfIntegratableCandidateListUIElement_FinalizeExactCompositionString(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfIntegratableCandidateListUIElement.VTable, self.vtable).FinalizeExactCompositionString(@ptrCast(*const ITfIntegratableCandidateListUIElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TKBLayoutType = extern enum(i32) {
    UNDEFINED = 0,
    CLASSIC = 1,
    OPTIMIZED = 2,
};
pub const TKBLT_UNDEFINED = TKBLayoutType.UNDEFINED;
pub const TKBLT_CLASSIC = TKBLayoutType.CLASSIC;
pub const TKBLT_OPTIMIZED = TKBLayoutType.OPTIMIZED;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnGetPreferredTouchKeyboardLayout_Value = @import("../zig.zig").Guid.initString("5f309a41-590a-4acc-a97f-d8efff13fdfc");
pub const IID_ITfFnGetPreferredTouchKeyboardLayout = &IID_ITfFnGetPreferredTouchKeyboardLayout_Value;
pub const ITfFnGetPreferredTouchKeyboardLayout = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetLayout: fn(
            self: *const ITfFnGetPreferredTouchKeyboardLayout,
            pTKBLayoutType: *TKBLayoutType,
            pwPreferredLayoutId: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnGetPreferredTouchKeyboardLayout_GetLayout(self: *const T, pTKBLayoutType: *TKBLayoutType, pwPreferredLayoutId: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnGetPreferredTouchKeyboardLayout.VTable, self.vtable).GetLayout(@ptrCast(*const ITfFnGetPreferredTouchKeyboardLayout, self), pTKBLayoutType, pwPreferredLayoutId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITfFnGetLinguisticAlternates_Value = @import("../zig.zig").Guid.initString("ea163ce2-7a65-4506-82a3-c528215da64e");
pub const IID_ITfFnGetLinguisticAlternates = &IID_ITfFnGetLinguisticAlternates_Value;
pub const ITfFnGetLinguisticAlternates = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        GetAlternates: fn(
            self: *const ITfFnGetLinguisticAlternates,
            pRange: *ITfRange,
            ppCandidateList: **ITfCandidateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnGetLinguisticAlternates_GetAlternates(self: *const T, pRange: *ITfRange, ppCandidateList: **ITfCandidateList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnGetLinguisticAlternates.VTable, self.vtable).GetAlternates(@ptrCast(*const ITfFnGetLinguisticAlternates, self), pRange, ppCandidateList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUIManagerEventSink_Value = @import("../zig.zig").Guid.initString("cd91d690-a7e8-4265-9b38-8bb3bbaba7de");
pub const IID_IUIManagerEventSink = &IID_IUIManagerEventSink_Value;
pub const IUIManagerEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWindowOpening: fn(
            self: *const IUIManagerEventSink,
            prcBounds: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowOpened: fn(
            self: *const IUIManagerEventSink,
            prcBounds: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowUpdating: fn(
            self: *const IUIManagerEventSink,
            prcUpdatedBounds: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowUpdated: fn(
            self: *const IUIManagerEventSink,
            prcUpdatedBounds: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowClosing: fn(
            self: *const IUIManagerEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnWindowClosed: fn(
            self: *const IUIManagerEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowOpening(self: *const T, prcBounds: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowOpening(@ptrCast(*const IUIManagerEventSink, self), prcBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowOpened(self: *const T, prcBounds: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowOpened(@ptrCast(*const IUIManagerEventSink, self), prcBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowUpdating(self: *const T, prcUpdatedBounds: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowUpdating(@ptrCast(*const IUIManagerEventSink, self), prcUpdatedBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowUpdated(self: *const T, prcUpdatedBounds: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowUpdated(@ptrCast(*const IUIManagerEventSink, self), prcUpdatedBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowClosing(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowClosing(@ptrCast(*const IUIManagerEventSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIManagerEventSink_OnWindowClosed(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIManagerEventSink.VTable, self.vtable).OnWindowClosed(@ptrCast(*const IUIManagerEventSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const InputScope = extern enum(i32) {
    DEFAULT = 0,
    URL = 1,
    FILE_FULLFILEPATH = 2,
    FILE_FILENAME = 3,
    EMAIL_USERNAME = 4,
    EMAIL_SMTPEMAILADDRESS = 5,
    LOGINNAME = 6,
    PERSONALNAME_FULLNAME = 7,
    PERSONALNAME_PREFIX = 8,
    PERSONALNAME_GIVENNAME = 9,
    PERSONALNAME_MIDDLENAME = 10,
    PERSONALNAME_SURNAME = 11,
    PERSONALNAME_SUFFIX = 12,
    ADDRESS_FULLPOSTALADDRESS = 13,
    ADDRESS_POSTALCODE = 14,
    ADDRESS_STREET = 15,
    ADDRESS_STATEORPROVINCE = 16,
    ADDRESS_CITY = 17,
    ADDRESS_COUNTRYNAME = 18,
    ADDRESS_COUNTRYSHORTNAME = 19,
    CURRENCY_AMOUNTANDSYMBOL = 20,
    CURRENCY_AMOUNT = 21,
    DATE_FULLDATE = 22,
    DATE_MONTH = 23,
    DATE_DAY = 24,
    DATE_YEAR = 25,
    DATE_MONTHNAME = 26,
    DATE_DAYNAME = 27,
    DIGITS = 28,
    NUMBER = 29,
    ONECHAR = 30,
    PASSWORD = 31,
    TELEPHONE_FULLTELEPHONENUMBER = 32,
    TELEPHONE_COUNTRYCODE = 33,
    TELEPHONE_AREACODE = 34,
    TELEPHONE_LOCALNUMBER = 35,
    TIME_FULLTIME = 36,
    TIME_HOUR = 37,
    TIME_MINORSEC = 38,
    NUMBER_FULLWIDTH = 39,
    ALPHANUMERIC_HALFWIDTH = 40,
    ALPHANUMERIC_FULLWIDTH = 41,
    CURRENCY_CHINESE = 42,
    BOPOMOFO = 43,
    HIRAGANA = 44,
    KATAKANA_HALFWIDTH = 45,
    KATAKANA_FULLWIDTH = 46,
    HANJA = 47,
    HANGUL_HALFWIDTH = 48,
    HANGUL_FULLWIDTH = 49,
    SEARCH = 50,
    FORMULA = 51,
    SEARCH_INCREMENTAL = 52,
    CHINESE_HALFWIDTH = 53,
    CHINESE_FULLWIDTH = 54,
    NATIVE_SCRIPT = 55,
    YOMI = 56,
    TEXT = 57,
    CHAT = 58,
    NAME_OR_PHONENUMBER = 59,
    EMAILNAME_OR_ADDRESS = 60,
    PRIVATE = 61,
    MAPS = 62,
    NUMERIC_PASSWORD = 63,
    NUMERIC_PIN = 64,
    ALPHANUMERIC_PIN = 65,
    ALPHANUMERIC_PIN_SET = 66,
    FORMULA_NUMBER = 67,
    CHAT_WITHOUT_EMOJI = 68,
    PHRASELIST = -1,
    REGULAREXPRESSION = -2,
    SRGS = -3,
    XML = -4,
    ENUMSTRING = -5,
};
pub const IS_DEFAULT = InputScope.DEFAULT;
pub const IS_URL = InputScope.URL;
pub const IS_FILE_FULLFILEPATH = InputScope.FILE_FULLFILEPATH;
pub const IS_FILE_FILENAME = InputScope.FILE_FILENAME;
pub const IS_EMAIL_USERNAME = InputScope.EMAIL_USERNAME;
pub const IS_EMAIL_SMTPEMAILADDRESS = InputScope.EMAIL_SMTPEMAILADDRESS;
pub const IS_LOGINNAME = InputScope.LOGINNAME;
pub const IS_PERSONALNAME_FULLNAME = InputScope.PERSONALNAME_FULLNAME;
pub const IS_PERSONALNAME_PREFIX = InputScope.PERSONALNAME_PREFIX;
pub const IS_PERSONALNAME_GIVENNAME = InputScope.PERSONALNAME_GIVENNAME;
pub const IS_PERSONALNAME_MIDDLENAME = InputScope.PERSONALNAME_MIDDLENAME;
pub const IS_PERSONALNAME_SURNAME = InputScope.PERSONALNAME_SURNAME;
pub const IS_PERSONALNAME_SUFFIX = InputScope.PERSONALNAME_SUFFIX;
pub const IS_ADDRESS_FULLPOSTALADDRESS = InputScope.ADDRESS_FULLPOSTALADDRESS;
pub const IS_ADDRESS_POSTALCODE = InputScope.ADDRESS_POSTALCODE;
pub const IS_ADDRESS_STREET = InputScope.ADDRESS_STREET;
pub const IS_ADDRESS_STATEORPROVINCE = InputScope.ADDRESS_STATEORPROVINCE;
pub const IS_ADDRESS_CITY = InputScope.ADDRESS_CITY;
pub const IS_ADDRESS_COUNTRYNAME = InputScope.ADDRESS_COUNTRYNAME;
pub const IS_ADDRESS_COUNTRYSHORTNAME = InputScope.ADDRESS_COUNTRYSHORTNAME;
pub const IS_CURRENCY_AMOUNTANDSYMBOL = InputScope.CURRENCY_AMOUNTANDSYMBOL;
pub const IS_CURRENCY_AMOUNT = InputScope.CURRENCY_AMOUNT;
pub const IS_DATE_FULLDATE = InputScope.DATE_FULLDATE;
pub const IS_DATE_MONTH = InputScope.DATE_MONTH;
pub const IS_DATE_DAY = InputScope.DATE_DAY;
pub const IS_DATE_YEAR = InputScope.DATE_YEAR;
pub const IS_DATE_MONTHNAME = InputScope.DATE_MONTHNAME;
pub const IS_DATE_DAYNAME = InputScope.DATE_DAYNAME;
pub const IS_DIGITS = InputScope.DIGITS;
pub const IS_NUMBER = InputScope.NUMBER;
pub const IS_ONECHAR = InputScope.ONECHAR;
pub const IS_PASSWORD = InputScope.PASSWORD;
pub const IS_TELEPHONE_FULLTELEPHONENUMBER = InputScope.TELEPHONE_FULLTELEPHONENUMBER;
pub const IS_TELEPHONE_COUNTRYCODE = InputScope.TELEPHONE_COUNTRYCODE;
pub const IS_TELEPHONE_AREACODE = InputScope.TELEPHONE_AREACODE;
pub const IS_TELEPHONE_LOCALNUMBER = InputScope.TELEPHONE_LOCALNUMBER;
pub const IS_TIME_FULLTIME = InputScope.TIME_FULLTIME;
pub const IS_TIME_HOUR = InputScope.TIME_HOUR;
pub const IS_TIME_MINORSEC = InputScope.TIME_MINORSEC;
pub const IS_NUMBER_FULLWIDTH = InputScope.NUMBER_FULLWIDTH;
pub const IS_ALPHANUMERIC_HALFWIDTH = InputScope.ALPHANUMERIC_HALFWIDTH;
pub const IS_ALPHANUMERIC_FULLWIDTH = InputScope.ALPHANUMERIC_FULLWIDTH;
pub const IS_CURRENCY_CHINESE = InputScope.CURRENCY_CHINESE;
pub const IS_BOPOMOFO = InputScope.BOPOMOFO;
pub const IS_HIRAGANA = InputScope.HIRAGANA;
pub const IS_KATAKANA_HALFWIDTH = InputScope.KATAKANA_HALFWIDTH;
pub const IS_KATAKANA_FULLWIDTH = InputScope.KATAKANA_FULLWIDTH;
pub const IS_HANJA = InputScope.HANJA;
pub const IS_HANGUL_HALFWIDTH = InputScope.HANGUL_HALFWIDTH;
pub const IS_HANGUL_FULLWIDTH = InputScope.HANGUL_FULLWIDTH;
pub const IS_SEARCH = InputScope.SEARCH;
pub const IS_FORMULA = InputScope.FORMULA;
pub const IS_SEARCH_INCREMENTAL = InputScope.SEARCH_INCREMENTAL;
pub const IS_CHINESE_HALFWIDTH = InputScope.CHINESE_HALFWIDTH;
pub const IS_CHINESE_FULLWIDTH = InputScope.CHINESE_FULLWIDTH;
pub const IS_NATIVE_SCRIPT = InputScope.NATIVE_SCRIPT;
pub const IS_YOMI = InputScope.YOMI;
pub const IS_TEXT = InputScope.TEXT;
pub const IS_CHAT = InputScope.CHAT;
pub const IS_NAME_OR_PHONENUMBER = InputScope.NAME_OR_PHONENUMBER;
pub const IS_EMAILNAME_OR_ADDRESS = InputScope.EMAILNAME_OR_ADDRESS;
pub const IS_PRIVATE = InputScope.PRIVATE;
pub const IS_MAPS = InputScope.MAPS;
pub const IS_NUMERIC_PASSWORD = InputScope.NUMERIC_PASSWORD;
pub const IS_NUMERIC_PIN = InputScope.NUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN = InputScope.ALPHANUMERIC_PIN;
pub const IS_ALPHANUMERIC_PIN_SET = InputScope.ALPHANUMERIC_PIN_SET;
pub const IS_FORMULA_NUMBER = InputScope.FORMULA_NUMBER;
pub const IS_CHAT_WITHOUT_EMOJI = InputScope.CHAT_WITHOUT_EMOJI;
pub const IS_PHRASELIST = InputScope.PHRASELIST;
pub const IS_REGULAREXPRESSION = InputScope.REGULAREXPRESSION;
pub const IS_SRGS = InputScope.SRGS;
pub const IS_XML = InputScope.XML;
pub const IS_ENUMSTRING = InputScope.ENUMSTRING;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope_Value = @import("../zig.zig").Guid.initString("fde1eaee-6924-4cdf-91e7-da38cff5559d");
pub const IID_ITfInputScope = &IID_ITfInputScope_Value;
pub const ITfInputScope = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputScopes: fn(
            self: *const ITfInputScope,
            pprgInputScopes: [*]*InputScope,
            pcCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPhrase: fn(
            self: *const ITfInputScope,
            ppbstrPhrases: [*]*BSTR,
            pcCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegularExpression: fn(
            self: *const ITfInputScope,
            pbstrRegExp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSRGS: fn(
            self: *const ITfInputScope,
            pbstrSRGS: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXML: fn(
            self: *const ITfInputScope,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope_GetInputScopes(self: *const T, pprgInputScopes: [*]*InputScope, pcCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope.VTable, self.vtable).GetInputScopes(@ptrCast(*const ITfInputScope, self), pprgInputScopes, pcCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope_GetPhrase(self: *const T, ppbstrPhrases: [*]*BSTR, pcCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope.VTable, self.vtable).GetPhrase(@ptrCast(*const ITfInputScope, self), ppbstrPhrases, pcCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope_GetRegularExpression(self: *const T, pbstrRegExp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope.VTable, self.vtable).GetRegularExpression(@ptrCast(*const ITfInputScope, self), pbstrRegExp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope_GetSRGS(self: *const T, pbstrSRGS: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope.VTable, self.vtable).GetSRGS(@ptrCast(*const ITfInputScope, self), pbstrSRGS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope_GetXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope.VTable, self.vtable).GetXML(@ptrCast(*const ITfInputScope, self), pbstrXML);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITfInputScope2_Value = @import("../zig.zig").Guid.initString("5731eaa0-6bc2-4681-a532-92fbb74d7c41");
pub const IID_ITfInputScope2 = &IID_ITfInputScope2_Value;
pub const ITfInputScope2 = extern struct {
    pub const VTable = extern struct {
        base: ITfInputScope.VTable,
        EnumWordList: fn(
            self: *const ITfInputScope2,
            ppEnumString: **IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfInputScope.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfInputScope2_EnumWordList(self: *const T, ppEnumString: **IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfInputScope2.VTable, self.vtable).EnumWordList(@ptrCast(*const ITfInputScope2, self), ppEnumString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfSpeechUIServer_Value = @import("../zig.zig").Guid.initString("90e9a944-9244-489f-a78f-de67afc013a7");
pub const IID_ITfSpeechUIServer = &IID_ITfSpeechUIServer_Value;
pub const ITfSpeechUIServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ITfSpeechUIServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowUI: fn(
            self: *const ITfSpeechUIServer,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateBalloon: fn(
            self: *const ITfSpeechUIServer,
            style: TfLBBalloonStyle,
            pch: [*:0]const u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSpeechUIServer_Initialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSpeechUIServer.VTable, self.vtable).Initialize(@ptrCast(*const ITfSpeechUIServer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSpeechUIServer_ShowUI(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSpeechUIServer.VTable, self.vtable).ShowUI(@ptrCast(*const ITfSpeechUIServer, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfSpeechUIServer_UpdateBalloon(self: *const T, style: TfLBBalloonStyle, pch: [*:0]const u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfSpeechUIServer.VTable, self.vtable).UpdateBalloon(@ptrCast(*const ITfSpeechUIServer, self), style, pch, cch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HKL = ?*opaque{};

pub const LANG_BAR_ITEM_ICON_MODE_FLAGS = extern enum(u32) {
    None = 0,
    N = 1,
};
pub const TF_DTLBI_USEPROFILEICON = LANG_BAR_ITEM_ICON_MODE_FLAGS.N;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TEXT_STORE_TEXT_CHANGE_FLAGS = extern enum(u32) {
    None = 0,
    N = 1,
    _,
};
pub const TS_ST_CORRECTION = TEXT_STORE_TEXT_CHANGE_FLAGS.N;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TEXT_STORE_CHANGE_FLAGS = extern enum(u32) {
    None = 0,
    N = 1,
    _,
};
pub const TS_TC_CORRECTION = TEXT_STORE_CHANGE_FLAGS.N;

pub const INSERT_TEXT_AT_SELECTION_FLAGS = extern enum(u32) {
    NOQUERY = 1,
    QUERYONLY = 2,
    NO_DEFAULT_COMPOSITION = 2147483648,
};
pub const TF_IAS_NOQUERY = INSERT_TEXT_AT_SELECTION_FLAGS.NOQUERY;
pub const TF_IAS_QUERYONLY = INSERT_TEXT_AT_SELECTION_FLAGS.QUERYONLY;
pub const TF_IAS_NO_DEFAULT_COMPOSITION = INSERT_TEXT_AT_SELECTION_FLAGS.NO_DEFAULT_COMPOSITION;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ANCHOR_CHANGE_HISTORY_FLAGS = extern enum(u32) {
    PRECEDING_DEL = 1,
    FOLLOWING_DEL = 2,
    _,
};
pub const TS_CH_PRECEDING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.PRECEDING_DEL;
pub const TS_CH_FOLLOWING_DEL = ANCHOR_CHANGE_HISTORY_FLAGS.FOLLOWING_DEL;

pub const TEXT_STORE_LOCK_FLAGS = extern enum(u32) {
    D = 2,
    WRITE = 6,
};
pub const TS_LF_READ = TEXT_STORE_LOCK_FLAGS.D;
pub const TS_LF_READWRITE = TEXT_STORE_LOCK_FLAGS.WRITE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GET_TEXT_AND_PROPERTY_UPDATES_FLAGS = extern enum(u32) {
    None = 0,
    T = 1,
    _,
};
pub const TF_GTP_INCL_TEXT = GET_TEXT_AND_PROPERTY_UPDATES_FLAGS.T;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TF_CONTEXT_EDIT_CONTEXT_FLAGS = extern enum(u32) {
    ASYNCDONTCARE = 0,
    SYNC = 1,
    READ = 2,
    READWRITE = 6,
    ASYNC = 8,
    _,
};
pub const TF_ES_ASYNCDONTCARE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNCDONTCARE;
pub const TF_ES_SYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.SYNC;
pub const TF_ES_READ = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READ;
pub const TF_ES_READWRITE = TF_CONTEXT_EDIT_CONTEXT_FLAGS.READWRITE;
pub const TF_ES_ASYNC = TF_CONTEXT_EDIT_CONTEXT_FLAGS.ASYNC;

// TODO: this type is limited to platform 'windows5.0'
const IID_ITfMSAAControl_Value = @import("../zig.zig").Guid.initString("b5f8fb3b-393f-4f7c-84cb-504924c2705a");
pub const IID_ITfMSAAControl = &IID_ITfMSAAControl_Value;
pub const ITfMSAAControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SystemEnableMSAA: fn(
            self: *const ITfMSAAControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SystemDisableMSAA: fn(
            self: *const ITfMSAAControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMSAAControl_SystemEnableMSAA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMSAAControl.VTable, self.vtable).SystemEnableMSAA(@ptrCast(*const ITfMSAAControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfMSAAControl_SystemDisableMSAA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfMSAAControl.VTable, self.vtable).SystemDisableMSAA(@ptrCast(*const ITfMSAAControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "MsCtfMonitor" fn InitLocalMsCtfMonitor(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "MsCtfMonitor" fn UninitLocalMsCtfMonitor(
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const IStream = @import("structured_storage.zig").IStream;
const MSG = @import("windows_and_messaging.zig").MSG;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const IEnumString = @import("com.zig").IEnumString;
const HRESULT = @import("com.zig").HRESULT;
const BSTR = @import("automation.zig").BSTR;
const RECT = @import("display_devices.zig").RECT;
const HBITMAP = @import("gdi.zig").HBITMAP;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const IEnumGUID = @import("com.zig").IEnumGUID;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const VARIANT = @import("automation.zig").VARIANT;
const IDataObject = @import("com.zig").IDataObject;
const FORMATETC = @import("com.zig").FORMATETC;
const POINT = @import("display_devices.zig").POINT;
const SIZE = @import("display_devices.zig").SIZE;
const HICON = @import("menus_and_resources.zig").HICON;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
