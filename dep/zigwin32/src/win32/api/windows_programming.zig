//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (927)
//--------------------------------------------------------------------------------
pub const HKEY_CLASSES_ROOT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483648));
pub const HKEY_CURRENT_USER = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483647));
pub const HKEY_LOCAL_MACHINE = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483646));
pub const HKEY_USERS = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483645));
pub const HKEY_PERFORMANCE_DATA = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483644));
pub const HKEY_PERFORMANCE_TEXT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483568));
pub const HKEY_PERFORMANCE_NLSTEXT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483552));
pub const HKEY_CURRENT_CONFIG = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483643));
pub const HKEY_DYN_DATA = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483642));
pub const HKEY_CURRENT_USER_LOCAL_SETTINGS = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483641));
pub const WLDP_LOCKDOWN_UNDEFINED = @as(u32, 0);
pub const WLDP_LOCKDOWN_DEFINED_FLAG = @as(u32, 2147483648);
pub const WLDP_LOCKDOWN_CONFIG_CI_FLAG = @as(u32, 1);
pub const WLDP_LOCKDOWN_CONFIG_CI_AUDIT_FLAG = @as(u32, 2);
pub const WLDP_LOCKDOWN_UMCIENFORCE_FLAG = @as(u32, 4);
pub const WLDP_LOCKDOWN_AUDIT_FLAG = @as(u32, 8);
pub const WLDP_LOCKDOWN_EXCLUSION_FLAG = @as(u32, 16);
pub const WLDP_HOST_INFORMATION_REVISION = @as(u32, 1);
pub const WLDP_FLAGS_SKIPSIGNATUREVALIDATION = @as(u32, 256);
pub const MAX_TDI_ENTITIES = @as(u32, 4096);
pub const INFO_CLASS_GENERIC = @as(u32, 256);
pub const INFO_CLASS_PROTOCOL = @as(u32, 512);
pub const INFO_CLASS_IMPLEMENTATION = @as(u32, 768);
pub const INFO_TYPE_PROVIDER = @as(u32, 256);
pub const INFO_TYPE_ADDRESS_OBJECT = @as(u32, 512);
pub const INFO_TYPE_CONNECTION = @as(u32, 768);
pub const ENTITY_LIST_ID = @as(u32, 0);
pub const INVALID_ENTITY_INSTANCE = @as(i32, -1);
pub const CONTEXT_SIZE = @as(u32, 16);
pub const ENTITY_TYPE_ID = @as(u32, 1);
pub const CO_TL_NBF = @as(u32, 1024);
pub const CO_TL_SPX = @as(u32, 1026);
pub const CO_TL_TCP = @as(u32, 1028);
pub const CO_TL_SPP = @as(u32, 1030);
pub const CL_TL_NBF = @as(u32, 1025);
pub const CL_TL_UDP = @as(u32, 1027);
pub const ER_ICMP = @as(u32, 896);
pub const CL_NL_IPX = @as(u32, 769);
pub const CL_NL_IP = @as(u32, 771);
pub const AT_ARP = @as(u32, 640);
pub const AT_NULL = @as(u32, 642);
pub const IF_GENERIC = @as(u32, 512);
pub const IF_MIB = @as(u32, 514);
pub const OBJECT_ISROOT = @as(i32, -2147483648);
pub const GUID_OptSurfaceKmodeInfo = Guid.initString("e05c8472-51d4-11d1-8cce-00a0c90629a8");
pub const GUID_OptSurfaceUmodeInfo = Guid.initString("9d792804-5fa8-11d1-8cd0-00a0c90629a8");
pub const GUID_UserModeDriverInfo = Guid.initString("f0b0e8e2-5f97-11d1-8cd0-00a0c90629a8");
pub const GUID_UserModeDriverPassword = Guid.initString("97f861b6-60a1-11d1-8cd0-00a0c90629a8");
pub const DDPF_NOVEL_TEXTURE_FORMAT = @as(i32, 1048576);
pub const DELETED_OK = @as(u32, 0);
pub const DELETED_LASTONE = @as(u32, 1);
pub const DELETED_NOTFOUND = @as(u32, 2);
pub const DCICOMMAND = @as(u32, 3075);
pub const DD_VERSION = @as(i32, 512);
pub const DD_RUNTIME_VERSION = @as(i32, 2306);
pub const DD_HAL_VERSION = @as(u32, 256);
pub const DDCREATEDRIVEROBJECT = @as(u32, 10);
pub const DDGET32BITDRIVERNAME = @as(u32, 11);
pub const DDNEWCALLBACKFNS = @as(u32, 12);
pub const DDVERSIONINFO = @as(u32, 13);
pub const MAX_PALETTE_SIZE = @as(u32, 256);
pub const D3DFMT_INTERNAL_D32 = @as(u32, 71);
pub const D3DFMT_INTERNAL_S1D15 = @as(u32, 72);
pub const D3DFMT_INTERNAL_D15S1 = @as(u32, 73);
pub const D3DFMT_INTERNAL_S8D24 = @as(u32, 74);
pub const D3DFMT_INTERNAL_D24S8 = @as(u32, 75);
pub const D3DFMT_INTERNAL_X8D24 = @as(u32, 76);
pub const D3DFMT_INTERNAL_D24X8 = @as(u32, 77);
pub const DDHAL_PLEASEALLOC_LINEARSIZE = @as(i32, 3);
pub const HEAPALIASINFO_MAPPEDREAL = @as(i32, 1);
pub const HEAPALIASINFO_MAPPEDDUMMY = @as(i32, 2);
pub const DDHAL_CB32_SETEXCLUSIVEMODE = @as(i32, 256);
pub const DDHAL_CB32_FLIPTOGDISURFACE = @as(i32, 512);
pub const DDHAL_MISCCB32_UPDATENONLOCALHEAP = @as(i32, 2);
pub const DDHAL_MISCCB32_GETHEAPALIGNMENT = @as(i32, 4);
pub const DDHAL_MISCCB32_GETSYSMEMBLTSTATUS = @as(i32, 8);
pub const DDRAWIPAL_256 = @as(i32, 1);
pub const DDRAWIPAL_16 = @as(i32, 2);
pub const DDRAWIPAL_GDI = @as(i32, 4);
pub const DDRAWIPAL_STORED_8 = @as(i32, 8);
pub const DDRAWIPAL_STORED_16 = @as(i32, 16);
pub const DDRAWIPAL_STORED_24 = @as(i32, 32);
pub const DDRAWIPAL_EXCLUSIVE = @as(i32, 64);
pub const DDRAWIPAL_INHEL = @as(i32, 128);
pub const DDRAWIPAL_DIRTY = @as(i32, 256);
pub const DDRAWIPAL_ALLOW256 = @as(i32, 512);
pub const DDRAWIPAL_4 = @as(i32, 1024);
pub const DDRAWIPAL_2 = @as(i32, 2048);
pub const DDRAWIPAL_STORED_8INDEX = @as(i32, 4096);
pub const DDRAWIPAL_ALPHA = @as(i32, 8192);
pub const DDRAWICLIP_WATCHWINDOW = @as(i32, 1);
pub const DDRAWICLIP_ISINITIALIZED = @as(i32, 2);
pub const DDRAWICLIP_INMASTERSPRITELIST = @as(i32, 4);
pub const DDAL_IMPLICIT = @as(i32, 1);
pub const ACCESSRECT_VRAMSTYLE = @as(i32, 1);
pub const ACCESSRECT_NOTHOLDINGWIN16LOCK = @as(i32, 2);
pub const ACCESSRECT_BROKEN = @as(i32, 4);
pub const PFINDEX_UNINITIALIZED = @as(u32, 0);
pub const DDRAWISURFGBL_MEMFREE = @as(i32, 1);
pub const DDRAWISURFGBL_SYSMEMREQUESTED = @as(i32, 2);
pub const DDRAWISURFGBL_ISGDISURFACE = @as(i32, 4);
pub const DDRAWISURFGBL_SOFTWAREAUTOFLIP = @as(i32, 8);
pub const DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK = @as(i32, 16);
pub const DDRAWISURFGBL_LOCKVRAMSTYLE = @as(i32, 32);
pub const DDRAWISURFGBL_LOCKBROKEN = @as(i32, 64);
pub const DDRAWISURFGBL_IMPLICITHANDLE = @as(i32, 128);
pub const DDRAWISURFGBL_ISCLIENTMEM = @as(i32, 256);
pub const DDRAWISURFGBL_HARDWAREOPSOURCE = @as(i32, 512);
pub const DDRAWISURFGBL_HARDWAREOPDEST = @as(i32, 1024);
pub const DDRAWISURFGBL_VPORTINTERLEAVED = @as(i32, 2048);
pub const DDRAWISURFGBL_VPORTDATA = @as(i32, 4096);
pub const DDRAWISURFGBL_LATEALLOCATELINEAR = @as(i32, 8192);
pub const DDRAWISURFGBL_SYSMEMEXECUTEBUFFER = @as(i32, 16384);
pub const DDRAWISURFGBL_FASTLOCKHELD = @as(i32, 32768);
pub const DDRAWISURFGBL_READONLYLOCKHELD = @as(i32, 65536);
pub const DDRAWISURFGBL_DX8SURFACE = @as(i32, 524288);
pub const DDRAWISURFGBL_DDHELDONTFREE = @as(i32, 1048576);
pub const DDRAWISURFGBL_NOTIFYWHENUNLOCKED = @as(i32, 2097152);
pub const DDRAWISURFGBL_RESERVED0 = @as(i32, -2147483648);
pub const DDRAWISURF_ATTACHED = @as(i32, 1);
pub const DDRAWISURF_IMPLICITCREATE = @as(i32, 2);
pub const DDRAWISURF_ISFREE = @as(i32, 4);
pub const DDRAWISURF_ATTACHED_FROM = @as(i32, 8);
pub const DDRAWISURF_IMPLICITROOT = @as(i32, 16);
pub const DDRAWISURF_PARTOFPRIMARYCHAIN = @as(i32, 32);
pub const DDRAWISURF_DATAISALIASED = @as(i32, 64);
pub const DDRAWISURF_HASDC = @as(i32, 128);
pub const DDRAWISURF_HASCKEYDESTOVERLAY = @as(i32, 256);
pub const DDRAWISURF_HASCKEYDESTBLT = @as(i32, 512);
pub const DDRAWISURF_HASCKEYSRCOVERLAY = @as(i32, 1024);
pub const DDRAWISURF_LOCKEXCLUDEDCURSOR = @as(i32, 4096);
pub const DDRAWISURF_SETGAMMA = @as(i32, 32768);
pub const DDRAWISURF_SW_CKEYDESTOVERLAY = @as(i32, 65536);
pub const DDRAWISURF_SW_CKEYDESTBLT = @as(i32, 131072);
pub const DDRAWISURF_SW_CKEYSRCOVERLAY = @as(i32, 262144);
pub const DDRAWISURF_SW_CKEYSRCBLT = @as(i32, 524288);
pub const DDRAWISURF_HW_CKEYDESTOVERLAY = @as(i32, 1048576);
pub const DDRAWISURF_HW_CKEYDESTBLT = @as(i32, 2097152);
pub const DDRAWISURF_HW_CKEYSRCOVERLAY = @as(i32, 4194304);
pub const DDRAWISURF_HW_CKEYSRCBLT = @as(i32, 8388608);
pub const DDRAWISURF_INMASTERSPRITELIST = @as(i32, 16777216);
pub const DDRAWISURF_HELCB = @as(i32, 33554432);
pub const DDRAWISURF_DCIBUSY = @as(i32, 536870912);
pub const DDRAWISURF_GETDCNULL = @as(i32, 1073741824);
pub const DDRAWISURF_STEREOSURFACELEFT = @as(i32, 536870912);
pub const DDRAWISURF_DCILOCK = @as(i32, -2147483648);
pub const DDMODEINFO_PALETTIZED = @as(u32, 1);
pub const DDMODEINFO_MODEX = @as(u32, 2);
pub const DDMODEINFO_UNSUPPORTED = @as(u32, 4);
pub const DDMODEINFO_STANDARDVGA = @as(u32, 8);
pub const DDMODEINFO_MAXREFRESH = @as(u32, 16);
pub const DDMODEINFO_STEREO = @as(u32, 32);
pub const DDRAWILCL_HASEXCLUSIVEMODE = @as(i32, 1);
pub const DDRAWILCL_ISFULLSCREEN = @as(i32, 2);
pub const DDRAWILCL_SETCOOPCALLED = @as(i32, 4);
pub const DDRAWILCL_ACTIVEYES = @as(i32, 8);
pub const DDRAWILCL_ACTIVENO = @as(i32, 16);
pub const DDRAWILCL_HOOKEDHWND = @as(i32, 32);
pub const DDRAWILCL_ALLOWMODEX = @as(i32, 64);
pub const DDRAWILCL_V1SCLBEHAVIOUR = @as(i32, 128);
pub const DDRAWILCL_MODEHASBEENCHANGED = @as(i32, 256);
pub const DDRAWILCL_CREATEDWINDOW = @as(i32, 512);
pub const DDRAWILCL_DIRTYDC = @as(i32, 1024);
pub const DDRAWILCL_DISABLEINACTIVATE = @as(i32, 2048);
pub const DDRAWILCL_CURSORCLIPPED = @as(i32, 4096);
pub const DDRAWILCL_EXPLICITMONITOR = @as(i32, 8192);
pub const DDRAWILCL_MULTITHREADED = @as(i32, 16384);
pub const DDRAWILCL_FPUSETUP = @as(i32, 32768);
pub const DDRAWILCL_POWEREDDOWN = @as(i32, 65536);
pub const DDRAWILCL_DIRECTDRAW7 = @as(i32, 131072);
pub const DDRAWILCL_ATTEMPTEDD3DCONTEXT = @as(i32, 262144);
pub const DDRAWILCL_FPUPRESERVE = @as(i32, 524288);
pub const DDRAWILCL_DX8DRIVER = @as(i32, 1048576);
pub const DDRAWILCL_DIRECTDRAW8 = @as(i32, 2097152);
pub const DDRAWI_xxxxxxxxx1 = @as(i32, 1);
pub const DDRAWI_xxxxxxxxx2 = @as(i32, 2);
pub const DDRAWI_VIRTUALDESKTOP = @as(i32, 8);
pub const DDRAWI_MODEX = @as(i32, 16);
pub const DDRAWI_DISPLAYDRV = @as(i32, 32);
pub const DDRAWI_FULLSCREEN = @as(i32, 64);
pub const DDRAWI_MODECHANGED = @as(i32, 128);
pub const DDRAWI_NOHARDWARE = @as(i32, 256);
pub const DDRAWI_PALETTEINIT = @as(i32, 512);
pub const DDRAWI_NOEMULATION = @as(i32, 1024);
pub const DDRAWI_HASCKEYDESTOVERLAY = @as(i32, 2048);
pub const DDRAWI_HASCKEYSRCOVERLAY = @as(i32, 4096);
pub const DDRAWI_HASGDIPALETTE = @as(i32, 8192);
pub const DDRAWI_EMULATIONINITIALIZED = @as(i32, 16384);
pub const DDRAWI_HASGDIPALETTE_EXCLUSIVE = @as(i32, 32768);
pub const DDRAWI_MODEXILLEGAL = @as(i32, 65536);
pub const DDRAWI_FLIPPEDTOGDI = @as(i32, 131072);
pub const DDRAWI_NEEDSWIN16FORVRAMLOCK = @as(i32, 262144);
pub const DDRAWI_PDEVICEVRAMBITCLEARED = @as(i32, 524288);
pub const DDRAWI_STANDARDVGA = @as(i32, 1048576);
pub const DDRAWI_EXTENDEDALIGNMENT = @as(i32, 2097152);
pub const DDRAWI_CHANGINGMODE = @as(i32, 4194304);
pub const DDRAWI_GDIDRV = @as(i32, 8388608);
pub const DDRAWI_ATTACHEDTODESKTOP = @as(i32, 16777216);
pub const DDRAWI_UMODELOADED = @as(i32, 33554432);
pub const DDRAWI_DDRAWDATANOTFETCHED = @as(i32, 67108864);
pub const DDRAWI_SECONDARYDRIVERLOADED = @as(i32, 134217728);
pub const DDRAWI_TESTINGMODES = @as(i32, 268435456);
pub const DDRAWI_DRIVERINFO2 = @as(i32, 536870912);
pub const DDRAWI_BADPDEV = @as(i32, 1073741824);
pub const DDRAWIVPORT_NOKERNELHANDLES = @as(u32, 8);
pub const DDRAWIVPORT_SOFTWARE_BOB = @as(u32, 16);
pub const DDRAWIVPORT_VBION = @as(u32, 32);
pub const DDRAWIVPORT_VIDEOON = @as(u32, 64);
pub const DDHALINFO_ISPRIMARYDISPLAY = @as(i32, 1);
pub const DDHALINFO_MODEXILLEGAL = @as(i32, 2);
pub const VDMCONTEXT_i386 = @as(u32, 65536);
pub const VDMCONTEXT_i486 = @as(u32, 65536);
pub const VDM_KGDT_R3_CODE = @as(u32, 24);
pub const VDM_MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const V86FLAGS_CARRY = @as(u32, 1);
pub const V86FLAGS_PARITY = @as(u32, 4);
pub const V86FLAGS_AUXCARRY = @as(u32, 16);
pub const V86FLAGS_ZERO = @as(u32, 64);
pub const V86FLAGS_SIGN = @as(u32, 128);
pub const V86FLAGS_TRACE = @as(u32, 256);
pub const V86FLAGS_INTERRUPT = @as(u32, 512);
pub const V86FLAGS_DIRECTION = @as(u32, 1024);
pub const V86FLAGS_OVERFLOW = @as(u32, 2048);
pub const V86FLAGS_IOPL = @as(u32, 12288);
pub const V86FLAGS_IOPL_BITS = @as(u32, 18);
pub const V86FLAGS_RESUME = @as(u32, 65536);
pub const V86FLAGS_V86 = @as(u32, 131072);
pub const V86FLAGS_ALIGNMENT = @as(u32, 262144);
pub const DCI_VERSION = @as(u32, 256);
pub const DCICREATEPRIMARYSURFACE = @as(u32, 1);
pub const DCICREATEOFFSCREENSURFACE = @as(u32, 2);
pub const DCICREATEOVERLAYSURFACE = @as(u32, 3);
pub const DCIENUMSURFACE = @as(u32, 4);
pub const DCIESCAPE = @as(u32, 5);
pub const DCI_OK = @as(u32, 0);
pub const DCI_FAIL_GENERIC = @as(i32, -1);
pub const DCI_FAIL_UNSUPPORTEDVERSION = @as(i32, -2);
pub const DCI_FAIL_INVALIDSURFACE = @as(i32, -3);
pub const DCI_FAIL_UNSUPPORTED = @as(i32, -4);
pub const DCI_ERR_CURRENTLYNOTAVAIL = @as(i32, -5);
pub const DCI_ERR_INVALIDRECT = @as(i32, -6);
pub const DCI_ERR_UNSUPPORTEDFORMAT = @as(i32, -7);
pub const DCI_ERR_UNSUPPORTEDMASK = @as(i32, -8);
pub const DCI_ERR_TOOBIGHEIGHT = @as(i32, -9);
pub const DCI_ERR_TOOBIGWIDTH = @as(i32, -10);
pub const DCI_ERR_TOOBIGSIZE = @as(i32, -11);
pub const DCI_ERR_OUTOFMEMORY = @as(i32, -12);
pub const DCI_ERR_INVALIDPOSITION = @as(i32, -13);
pub const DCI_ERR_INVALIDSTRETCH = @as(i32, -14);
pub const DCI_ERR_INVALIDCLIPLIST = @as(i32, -15);
pub const DCI_ERR_SURFACEISOBSCURED = @as(i32, -16);
pub const DCI_ERR_XALIGN = @as(i32, -17);
pub const DCI_ERR_YALIGN = @as(i32, -18);
pub const DCI_ERR_XYALIGN = @as(i32, -19);
pub const DCI_ERR_WIDTHALIGN = @as(i32, -20);
pub const DCI_ERR_HEIGHTALIGN = @as(i32, -21);
pub const DCI_STATUS_POINTERCHANGED = @as(u32, 1);
pub const DCI_STATUS_STRIDECHANGED = @as(u32, 2);
pub const DCI_STATUS_FORMATCHANGED = @as(u32, 4);
pub const DCI_STATUS_SURFACEINFOCHANGED = @as(u32, 8);
pub const DCI_STATUS_CHROMAKEYCHANGED = @as(u32, 16);
pub const DCI_STATUS_WASSTILLDRAWING = @as(u32, 32);
pub const DCI_SURFACE_TYPE = @as(u32, 15);
pub const DCI_PRIMARY = @as(u32, 0);
pub const DCI_OFFSCREEN = @as(u32, 1);
pub const DCI_OVERLAY = @as(u32, 2);
pub const DCI_VISIBLE = @as(u32, 16);
pub const DCI_CHROMAKEY = @as(u32, 32);
pub const DCI_1632_ACCESS = @as(u32, 64);
pub const DCI_DWORDSIZE = @as(u32, 128);
pub const DCI_DWORDALIGN = @as(u32, 256);
pub const DCI_WRITEONLY = @as(u32, 512);
pub const DCI_ASYNC = @as(u32, 1024);
pub const DCI_CAN_STRETCHX = @as(u32, 4096);
pub const DCI_CAN_STRETCHY = @as(u32, 8192);
pub const DCI_CAN_STRETCHXN = @as(u32, 16384);
pub const DCI_CAN_STRETCHYN = @as(u32, 32768);
pub const DCI_CANOVERLAY = @as(u32, 65536);
pub const TSF_Hardware = @as(u32, 1);
pub const TSF_Authenticated = @as(u32, 2);
pub const TSF_IPv6 = @as(u32, 4);
pub const TSF_SignatureAuthenticated = @as(u32, 8);
pub const FILE_FLAG_OPEN_REQUIRING_OPLOCK = @as(u32, 262144);
pub const PROGRESS_CONTINUE = @as(u32, 0);
pub const PROGRESS_CANCEL = @as(u32, 1);
pub const PROGRESS_STOP = @as(u32, 2);
pub const PROGRESS_QUIET = @as(u32, 3);
pub const COPY_FILE_FAIL_IF_EXISTS = @as(u32, 1);
pub const COPY_FILE_RESTARTABLE = @as(u32, 2);
pub const COPY_FILE_OPEN_SOURCE_FOR_WRITE = @as(u32, 4);
pub const COPY_FILE_ALLOW_DECRYPTED_DESTINATION = @as(u32, 8);
pub const COPY_FILE_COPY_SYMLINK = @as(u32, 2048);
pub const COPY_FILE_NO_BUFFERING = @as(u32, 4096);
pub const COPY_FILE_REQUEST_SECURITY_PRIVILEGES = @as(u32, 8192);
pub const COPY_FILE_RESUME_FROM_PAUSE = @as(u32, 16384);
pub const COPY_FILE_NO_OFFLOAD = @as(u32, 262144);
pub const COPY_FILE_IGNORE_EDP_BLOCK = @as(u32, 4194304);
pub const COPY_FILE_IGNORE_SOURCE_ENCRYPTION = @as(u32, 8388608);
pub const COPY_FILE_DONT_REQUEST_DEST_WRITE_DAC = @as(u32, 33554432);
pub const COPY_FILE_REQUEST_COMPRESSED_TRAFFIC = @as(u32, 268435456);
pub const COPY_FILE_OPEN_AND_COPY_REPARSE_POINT = @as(u32, 2097152);
pub const COPY_FILE_DIRECTORY = @as(u32, 128);
pub const COPY_FILE_SKIP_ALTERNATE_STREAMS = @as(u32, 32768);
pub const COPY_FILE_DISABLE_PRE_ALLOCATION = @as(u32, 67108864);
pub const COPY_FILE_ENABLE_LOW_FREE_SPACE_MODE = @as(u32, 134217728);
pub const PIPE_ACCESS_INBOUND = @as(u32, 1);
pub const PIPE_ACCESS_OUTBOUND = @as(u32, 2);
pub const PIPE_ACCESS_DUPLEX = @as(u32, 3);
pub const PIPE_WAIT = @as(u32, 0);
pub const PIPE_READMODE_BYTE = @as(u32, 0);
pub const PIPE_ACCEPT_REMOTE_CLIENTS = @as(u32, 0);
pub const PIPE_REJECT_REMOTE_CLIENTS = @as(u32, 8);
pub const PIPE_UNLIMITED_INSTANCES = @as(u32, 255);
pub const FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = @as(u32, 1);
pub const FAIL_FAST_NO_HARD_ERROR_DLG = @as(u32, 2);
pub const DTR_CONTROL_DISABLE = @as(u32, 0);
pub const DTR_CONTROL_ENABLE = @as(u32, 1);
pub const DTR_CONTROL_HANDSHAKE = @as(u32, 2);
pub const RTS_CONTROL_DISABLE = @as(u32, 0);
pub const RTS_CONTROL_ENABLE = @as(u32, 1);
pub const RTS_CONTROL_HANDSHAKE = @as(u32, 2);
pub const RTS_CONTROL_TOGGLE = @as(u32, 3);
pub const GMEM_NOCOMPACT = @as(u32, 16);
pub const GMEM_NODISCARD = @as(u32, 32);
pub const GMEM_MODIFY = @as(u32, 128);
pub const GMEM_DISCARDABLE = @as(u32, 256);
pub const GMEM_NOT_BANKED = @as(u32, 4096);
pub const GMEM_SHARE = @as(u32, 8192);
pub const GMEM_DDESHARE = @as(u32, 8192);
pub const GMEM_NOTIFY = @as(u32, 16384);
pub const GMEM_VALID_FLAGS = @as(u32, 32626);
pub const GMEM_INVALID_HANDLE = @as(u32, 32768);
pub const GMEM_DISCARDED = @as(u32, 16384);
pub const GMEM_LOCKCOUNT = @as(u32, 255);
pub const VOLUME_NAME_DOS = @as(u32, 0);
pub const VOLUME_NAME_GUID = @as(u32, 1);
pub const VOLUME_NAME_NT = @as(u32, 2);
pub const VOLUME_NAME_NONE = @as(u32, 4);
pub const DRIVE_UNKNOWN = @as(u32, 0);
pub const DRIVE_NO_ROOT_DIR = @as(u32, 1);
pub const DRIVE_REMOVABLE = @as(u32, 2);
pub const DRIVE_FIXED = @as(u32, 3);
pub const DRIVE_REMOTE = @as(u32, 4);
pub const DRIVE_CDROM = @as(u32, 5);
pub const DRIVE_RAMDISK = @as(u32, 6);
pub const FILE_TYPE_UNKNOWN = @as(u32, 0);
pub const FILE_TYPE_DISK = @as(u32, 1);
pub const FILE_TYPE_CHAR = @as(u32, 2);
pub const FILE_TYPE_PIPE = @as(u32, 3);
pub const FILE_TYPE_REMOTE = @as(u32, 32768);
pub const NOPARITY = @as(u32, 0);
pub const ODDPARITY = @as(u32, 1);
pub const EVENPARITY = @as(u32, 2);
pub const MARKPARITY = @as(u32, 3);
pub const SPACEPARITY = @as(u32, 4);
pub const ONESTOPBIT = @as(u32, 0);
pub const ONE5STOPBITS = @as(u32, 1);
pub const TWOSTOPBITS = @as(u32, 2);
pub const IGNORE = @as(u32, 0);
pub const INFINITE = @as(u32, 4294967295);
pub const CBR_110 = @as(u32, 110);
pub const CBR_300 = @as(u32, 300);
pub const CBR_600 = @as(u32, 600);
pub const CBR_1200 = @as(u32, 1200);
pub const CBR_2400 = @as(u32, 2400);
pub const CBR_4800 = @as(u32, 4800);
pub const CBR_9600 = @as(u32, 9600);
pub const CBR_14400 = @as(u32, 14400);
pub const CBR_19200 = @as(u32, 19200);
pub const CBR_38400 = @as(u32, 38400);
pub const CBR_56000 = @as(u32, 56000);
pub const CBR_57600 = @as(u32, 57600);
pub const CBR_115200 = @as(u32, 115200);
pub const CBR_128000 = @as(u32, 128000);
pub const CBR_256000 = @as(u32, 256000);
pub const CE_TXFULL = @as(u32, 256);
pub const CE_PTO = @as(u32, 512);
pub const CE_IOE = @as(u32, 1024);
pub const CE_DNS = @as(u32, 2048);
pub const CE_OOP = @as(u32, 4096);
pub const CE_MODE = @as(u32, 32768);
pub const IE_BADID = @as(i32, -1);
pub const IE_OPEN = @as(i32, -2);
pub const IE_NOPEN = @as(i32, -3);
pub const IE_MEMORY = @as(i32, -4);
pub const IE_DEFAULT = @as(i32, -5);
pub const IE_HARDWARE = @as(i32, -10);
pub const IE_BYTESIZE = @as(i32, -11);
pub const IE_BAUDRATE = @as(i32, -12);
pub const RESETDEV = @as(u32, 7);
pub const LPTx = @as(u32, 128);
pub const S_QUEUEEMPTY = @as(u32, 0);
pub const S_THRESHOLD = @as(u32, 1);
pub const S_ALLTHRESHOLD = @as(u32, 2);
pub const S_NORMAL = @as(u32, 0);
pub const S_LEGATO = @as(u32, 1);
pub const S_STACCATO = @as(u32, 2);
pub const S_PERIOD512 = @as(u32, 0);
pub const S_PERIOD1024 = @as(u32, 1);
pub const S_PERIOD2048 = @as(u32, 2);
pub const S_PERIODVOICE = @as(u32, 3);
pub const S_WHITE512 = @as(u32, 4);
pub const S_WHITE1024 = @as(u32, 5);
pub const S_WHITE2048 = @as(u32, 6);
pub const S_WHITEVOICE = @as(u32, 7);
pub const S_SERDVNA = @as(i32, -1);
pub const S_SEROFM = @as(i32, -2);
pub const S_SERMACT = @as(i32, -3);
pub const S_SERQFUL = @as(i32, -4);
pub const S_SERBDNT = @as(i32, -5);
pub const S_SERDLN = @as(i32, -6);
pub const S_SERDCC = @as(i32, -7);
pub const S_SERDTP = @as(i32, -8);
pub const S_SERDVL = @as(i32, -9);
pub const S_SERDMD = @as(i32, -10);
pub const S_SERDSH = @as(i32, -11);
pub const S_SERDPT = @as(i32, -12);
pub const S_SERDFQ = @as(i32, -13);
pub const S_SERDDR = @as(i32, -14);
pub const S_SERDSR = @as(i32, -15);
pub const S_SERDST = @as(i32, -16);
pub const NMPWAIT_NOWAIT = @as(u32, 1);
pub const OFS_MAXPATHNAME = @as(u32, 128);
pub const MAXINTATOM = @as(u32, 49152);
pub const SCS_32BIT_BINARY = @as(u32, 0);
pub const SCS_DOS_BINARY = @as(u32, 1);
pub const SCS_WOW_BINARY = @as(u32, 2);
pub const SCS_PIF_BINARY = @as(u32, 3);
pub const SCS_POSIX_BINARY = @as(u32, 4);
pub const SCS_OS216_BINARY = @as(u32, 5);
pub const SCS_64BIT_BINARY = @as(u32, 6);
pub const FIBER_FLAG_FLOAT_SWITCH = @as(u32, 1);
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = @as(u32, 1);
pub const FILE_SKIP_SET_EVENT_ON_HANDLE = @as(u32, 2);
pub const HINSTANCE_ERROR = @as(u32, 32);
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK = @as(u32, 255);
pub const FILE_ENCRYPTABLE = @as(u32, 0);
pub const FILE_IS_ENCRYPTED = @as(u32, 1);
pub const FILE_SYSTEM_ATTR = @as(u32, 2);
pub const FILE_ROOT_DIR = @as(u32, 3);
pub const FILE_SYSTEM_DIR = @as(u32, 4);
pub const FILE_UNKNOWN = @as(u32, 5);
pub const FILE_SYSTEM_NOT_SUPPORT = @as(u32, 6);
pub const FILE_USER_DISALLOWED = @as(u32, 7);
pub const FILE_READ_ONLY = @as(u32, 8);
pub const FILE_DIR_DISALLOWED = @as(u32, 9);
pub const EFS_USE_RECOVERY_KEYS = @as(u32, 1);
pub const CREATE_FOR_IMPORT = @as(u32, 1);
pub const CREATE_FOR_DIR = @as(u32, 2);
pub const OVERWRITE_HIDDEN = @as(u32, 4);
pub const EFSRPC_SECURE_ONLY = @as(u32, 8);
pub const EFS_DROP_ALTERNATE_STREAMS = @as(u32, 16);
pub const BACKUP_INVALID = @as(u32, 0);
pub const BACKUP_GHOSTED_FILE_EXTENTS = @as(u32, 11);
pub const STREAM_NORMAL_ATTRIBUTE = @as(u32, 0);
pub const STREAM_MODIFIED_WHEN_READ = @as(u32, 1);
pub const STREAM_CONTAINS_SECURITY = @as(u32, 2);
pub const STREAM_CONTAINS_PROPERTIES = @as(u32, 4);
pub const STREAM_SPARSE_ATTRIBUTE = @as(u32, 8);
pub const STREAM_CONTAINS_GHOSTED_FILE_EXTENTS = @as(u32, 16);
pub const SHUTDOWN_NORETRY = @as(u32, 1);
pub const PROTECTION_LEVEL_SAME = @as(u32, 4294967295);
pub const PROC_THREAD_ATTRIBUTE_NUMBER = @as(u32, 65535);
pub const PROC_THREAD_ATTRIBUTE_THREAD = @as(u32, 65536);
pub const PROC_THREAD_ATTRIBUTE_INPUT = @as(u32, 131072);
pub const PROC_THREAD_ATTRIBUTE_ADDITIVE = @as(u32, 262144);
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE = @as(u32, 1);
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE = @as(u32, 2);
pub const PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE = @as(u32, 4);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED = @as(u32, 1);
pub const PROCESS_CREATION_CHILD_PROCESS_OVERRIDE = @as(u32, 2);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED_UNLESS_SECURE = @as(u32, 4);
pub const PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT = @as(u32, 1);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_ENABLE_PROCESS_TREE = @as(u32, 1);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_DISABLE_PROCESS_TREE = @as(u32, 2);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_OVERRIDE = @as(u32, 4);
pub const ATOM_FLAG_GLOBAL = @as(u32, 2);
pub const BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = @as(u32, 1);
pub const BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = @as(u32, 65536);
pub const BASE_SEARCH_PATH_PERMANENT = @as(u32, 32768);
pub const COPYFILE2_MESSAGE_COPY_OFFLOAD = @as(i32, 1);
pub const EVENTLOG_FULL_INFO = @as(u32, 0);
pub const OPERATION_API_VERSION = @as(u32, 1);
pub const MAX_COMPUTERNAME_LENGTH = @as(u32, 15);
pub const LOGON32_PROVIDER_WINNT35 = @as(u32, 1);
pub const LOGON32_PROVIDER_VIRTUAL = @as(u32, 4);
pub const LOGON_ZERO_PASSWORD_BUFFER = @as(u32, 2147483648);
pub const HW_PROFILE_GUIDLEN = @as(u32, 39);
pub const DOCKINFO_UNDOCKED = @as(u32, 1);
pub const DOCKINFO_DOCKED = @as(u32, 2);
pub const DOCKINFO_USER_SUPPLIED = @as(u32, 4);
pub const TC_NORMAL = @as(u32, 0);
pub const TC_HARDERR = @as(u32, 1);
pub const TC_GP_TRAP = @as(u32, 2);
pub const TC_SIGNAL = @as(u32, 3);
pub const AC_LINE_OFFLINE = @as(u32, 0);
pub const AC_LINE_ONLINE = @as(u32, 1);
pub const AC_LINE_BACKUP_POWER = @as(u32, 2);
pub const AC_LINE_UNKNOWN = @as(u32, 255);
pub const BATTERY_FLAG_HIGH = @as(u32, 1);
pub const BATTERY_FLAG_LOW = @as(u32, 2);
pub const BATTERY_FLAG_CRITICAL = @as(u32, 4);
pub const BATTERY_FLAG_CHARGING = @as(u32, 8);
pub const BATTERY_FLAG_NO_BATTERY = @as(u32, 128);
pub const BATTERY_FLAG_UNKNOWN = @as(u32, 255);
pub const BATTERY_PERCENTAGE_UNKNOWN = @as(u32, 255);
pub const SYSTEM_STATUS_FLAG_POWER_SAVING_ON = @as(u32, 1);
pub const BATTERY_LIFE_UNKNOWN = @as(u32, 4294967295);
pub const ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID = @as(u32, 1);
pub const ACTCTX_FLAG_LANGID_VALID = @as(u32, 2);
pub const ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID = @as(u32, 4);
pub const ACTCTX_FLAG_RESOURCE_NAME_VALID = @as(u32, 8);
pub const ACTCTX_FLAG_SET_PROCESS_DEFAULT = @as(u32, 16);
pub const ACTCTX_FLAG_APPLICATION_NAME_VALID = @as(u32, 32);
pub const ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF = @as(u32, 64);
pub const ACTCTX_FLAG_HMODULE_VALID = @as(u32, 128);
pub const DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION = @as(u32, 1);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX = @as(u32, 1);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS = @as(u32, 2);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA = @as(u32, 4);
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED = @as(u32, 1);
pub const QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX = @as(u32, 4);
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE = @as(u32, 8);
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS = @as(u32, 16);
pub const QUERY_ACTCTX_FLAG_NO_ADDREF = @as(u32, 2147483648);
pub const RESTART_MAX_CMD_LINE = @as(u32, 1024);
pub const RECOVERY_DEFAULT_PING_INTERVAL = @as(u32, 5000);
pub const FILE_RENAME_FLAG_REPLACE_IF_EXISTS = @as(u32, 1);
pub const FILE_RENAME_FLAG_POSIX_SEMANTICS = @as(u32, 2);
pub const FILE_RENAME_FLAG_SUPPRESS_PIN_STATE_INHERITANCE = @as(u32, 4);
pub const FILE_DISPOSITION_FLAG_DO_NOT_DELETE = @as(u32, 0);
pub const FILE_DISPOSITION_FLAG_DELETE = @as(u32, 1);
pub const FILE_DISPOSITION_FLAG_POSIX_SEMANTICS = @as(u32, 2);
pub const FILE_DISPOSITION_FLAG_FORCE_IMAGE_SECTION_CHECK = @as(u32, 4);
pub const FILE_DISPOSITION_FLAG_ON_CLOSE = @as(u32, 8);
pub const FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE = @as(u32, 16);
pub const STORAGE_INFO_FLAGS_ALIGNED_DEVICE = @as(u32, 1);
pub const STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE = @as(u32, 2);
pub const STORAGE_INFO_OFFSET_UNKNOWN = @as(u32, 4294967295);
pub const REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK = @as(u32, 1);
pub const REMOTE_PROTOCOL_INFO_FLAG_OFFLINE = @as(u32, 2);
pub const REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE = @as(u32, 4);
pub const RPI_FLAG_SMB2_SHARECAP_TIMEWARP = @as(u32, 2);
pub const RPI_FLAG_SMB2_SHARECAP_DFS = @as(u32, 8);
pub const RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY = @as(u32, 16);
pub const RPI_FLAG_SMB2_SHARECAP_SCALEOUT = @as(u32, 32);
pub const RPI_FLAG_SMB2_SHARECAP_CLUSTER = @as(u32, 64);
pub const RPI_SMB2_FLAG_SERVERCAP_DFS = @as(u32, 1);
pub const RPI_SMB2_FLAG_SERVERCAP_LEASING = @as(u32, 2);
pub const RPI_SMB2_FLAG_SERVERCAP_LARGEMTU = @as(u32, 4);
pub const RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL = @as(u32, 8);
pub const RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES = @as(u32, 16);
pub const RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING = @as(u32, 32);
pub const SYMBOLIC_LINK_FLAG_DIRECTORY = @as(u32, 1);
pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE = @as(u32, 2);
pub const MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = @as(u32, 0);
pub const CODEINTEGRITY_OPTION_ENABLED = @as(u32, 1);
pub const CODEINTEGRITY_OPTION_TESTSIGN = @as(u32, 2);
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED = @as(u32, 4);
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED = @as(u32, 8);
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED = @as(u32, 16);
pub const CODEINTEGRITY_OPTION_TEST_BUILD = @as(u32, 32);
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD = @as(u32, 64);
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED = @as(u32, 128);
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD = @as(u32, 256);
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED = @as(u32, 512);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED = @as(u32, 1024);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED = @as(u32, 2048);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED = @as(u32, 4096);
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED = @as(u32, 8192);
pub const FILE_MAXIMUM_DISPOSITION = @as(u32, 5);
pub const FILE_DIRECTORY_FILE = @as(u32, 1);
pub const FILE_WRITE_THROUGH = @as(u32, 2);
pub const FILE_SEQUENTIAL_ONLY = @as(u32, 4);
pub const FILE_NO_INTERMEDIATE_BUFFERING = @as(u32, 8);
pub const FILE_SYNCHRONOUS_IO_ALERT = @as(u32, 16);
pub const FILE_SYNCHRONOUS_IO_NONALERT = @as(u32, 32);
pub const FILE_NON_DIRECTORY_FILE = @as(u32, 64);
pub const FILE_CREATE_TREE_CONNECTION = @as(u32, 128);
pub const FILE_COMPLETE_IF_OPLOCKED = @as(u32, 256);
pub const FILE_NO_EA_KNOWLEDGE = @as(u32, 512);
pub const FILE_OPEN_REMOTE_INSTANCE = @as(u32, 1024);
pub const FILE_RANDOM_ACCESS = @as(u32, 2048);
pub const FILE_DELETE_ON_CLOSE = @as(u32, 4096);
pub const FILE_OPEN_BY_FILE_ID = @as(u32, 8192);
pub const FILE_OPEN_FOR_BACKUP_INTENT = @as(u32, 16384);
pub const FILE_NO_COMPRESSION = @as(u32, 32768);
pub const FILE_OPEN_REQUIRING_OPLOCK = @as(u32, 65536);
pub const FILE_RESERVE_OPFILTER = @as(u32, 1048576);
pub const FILE_OPEN_REPARSE_POINT = @as(u32, 2097152);
pub const FILE_OPEN_NO_RECALL = @as(u32, 4194304);
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY = @as(u32, 8388608);
pub const FILE_VALID_OPTION_FLAGS = @as(u32, 16777215);
pub const FILE_VALID_PIPE_OPTION_FLAGS = @as(u32, 50);
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS = @as(u32, 50);
pub const FILE_VALID_SET_FLAGS = @as(u32, 54);
pub const FILE_SUPERSEDED = @as(u32, 0);
pub const FILE_OPENED = @as(u32, 1);
pub const FILE_CREATED = @as(u32, 2);
pub const FILE_OVERWRITTEN = @as(u32, 3);
pub const FILE_EXISTS = @as(u32, 4);
pub const FILE_DOES_NOT_EXIST = @as(u32, 5);
pub const AVRF_MAX_TRACES = @as(u32, 32);
pub const INCLUDED_FCI = @as(u32, 1);
pub const INCLUDED_FDI = @as(u32, 1);
pub const INCLUDED_TYPES_FCI_FDI = @as(u32, 1);
pub const CB_MAX_DISK = @as(i32, 2147483647);
pub const CB_MAX_FILENAME = @as(u32, 256);
pub const CB_MAX_CABINET_NAME = @as(u32, 256);
pub const CB_MAX_CAB_PATH = @as(u32, 256);
pub const CB_MAX_DISK_NAME = @as(u32, 256);
pub const DBG_SEGLOAD = @as(u32, 0);
pub const DBG_SEGMOVE = @as(u32, 1);
pub const DBG_SEGFREE = @as(u32, 2);
pub const DBG_MODLOAD = @as(u32, 3);
pub const DBG_MODFREE = @as(u32, 4);
pub const DBG_SINGLESTEP = @as(u32, 5);
pub const DBG_BREAK = @as(u32, 6);
pub const DBG_GPFAULT = @as(u32, 7);
pub const DBG_DIVOVERFLOW = @as(u32, 8);
pub const DBG_INSTRFAULT = @as(u32, 9);
pub const DBG_TASKSTART = @as(u32, 10);
pub const DBG_TASKSTOP = @as(u32, 11);
pub const DBG_DLLSTART = @as(u32, 12);
pub const DBG_DLLSTOP = @as(u32, 13);
pub const DBG_ATTACH = @as(u32, 14);
pub const DBG_TOOLHELP = @as(u32, 15);
pub const DBG_STACKFAULT = @as(u32, 16);
pub const DBG_WOWINIT = @as(u32, 17);
pub const DBG_TEMPBP = @as(u32, 18);
pub const DBG_MODMOVE = @as(u32, 19);
pub const DBG_INIT = @as(u32, 20);
pub const DBG_GPFAULT2 = @as(u32, 21);
pub const VDMEVENT_NEEDS_INTERACTIVE = @as(u32, 32768);
pub const VDMEVENT_VERBOSE = @as(u32, 16384);
pub const VDMEVENT_PE = @as(u32, 8192);
pub const VDMEVENT_ALLFLAGS = @as(u32, 57344);
pub const VDMEVENT_V86 = @as(u32, 1);
pub const VDMEVENT_PM16 = @as(u32, 2);
pub const MAX_MODULE_NAME = @as(u32, 9);
pub const MAX_PATH16 = @as(u32, 255);
pub const SN_CODE = @as(u32, 0);
pub const SN_DATA = @as(u32, 1);
pub const SN_V86 = @as(u32, 2);
pub const GLOBAL_ALL = @as(u32, 0);
pub const GLOBAL_LRU = @as(u32, 1);
pub const GLOBAL_FREE = @as(u32, 2);
pub const GT_UNKNOWN = @as(u32, 0);
pub const GT_DGROUP = @as(u32, 1);
pub const GT_DATA = @as(u32, 2);
pub const GT_CODE = @as(u32, 3);
pub const GT_TASK = @as(u32, 4);
pub const GT_RESOURCE = @as(u32, 5);
pub const GT_MODULE = @as(u32, 6);
pub const GT_FREE = @as(u32, 7);
pub const GT_INTERNAL = @as(u32, 8);
pub const GT_SENTINEL = @as(u32, 9);
pub const GT_BURGERMASTER = @as(u32, 10);
pub const GD_USERDEFINED = @as(u32, 0);
pub const GD_CURSORCOMPONENT = @as(u32, 1);
pub const GD_BITMAP = @as(u32, 2);
pub const GD_ICONCOMPONENT = @as(u32, 3);
pub const GD_MENU = @as(u32, 4);
pub const GD_DIALOG = @as(u32, 5);
pub const GD_STRING = @as(u32, 6);
pub const GD_FONTDIR = @as(u32, 7);
pub const GD_FONT = @as(u32, 8);
pub const GD_ACCELERATORS = @as(u32, 9);
pub const GD_RCDATA = @as(u32, 10);
pub const GD_ERRTABLE = @as(u32, 11);
pub const GD_CURSOR = @as(u32, 12);
pub const GD_ICON = @as(u32, 14);
pub const GD_NAMETABLE = @as(u32, 15);
pub const GD_MAX_RESOURCE = @as(u32, 15);
pub const VDMDBG_BREAK_DOSTASK = @as(u32, 1);
pub const VDMDBG_BREAK_WOWTASK = @as(u32, 2);
pub const VDMDBG_BREAK_LOADDLL = @as(u32, 4);
pub const VDMDBG_BREAK_EXCEPTIONS = @as(u32, 8);
pub const VDMDBG_BREAK_DEBUGGER = @as(u32, 16);
pub const VDMDBG_TRACE_HISTORY = @as(u32, 128);
pub const VDMDBG_BREAK_DIVIDEBYZERO = @as(u32, 256);
pub const VDMDBG_MAX_SYMBOL_BUFFER = @as(u32, 256);
pub const VDMADDR_V86 = @as(u32, 2);
pub const VDMADDR_PM16 = @as(u32, 4);
pub const VDMADDR_PM32 = @as(u32, 16);
pub const WINWATCHNOTIFY_START = @as(u32, 0);
pub const WINWATCHNOTIFY_STOP = @as(u32, 1);
pub const WINWATCHNOTIFY_DESTROY = @as(u32, 2);
pub const WINWATCHNOTIFY_CHANGING = @as(u32, 3);
pub const WINWATCHNOTIFY_CHANGED = @as(u32, 4);
pub const S_ASYNCHRONOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262632));
pub const RSC_FLAG_INF = @as(u32, 1);
pub const RSC_FLAG_SKIPDISKSPACECHECK = @as(u32, 2);
pub const RSC_FLAG_QUIET = @as(u32, 4);
pub const RSC_FLAG_NGCONV = @as(u32, 8);
pub const RSC_FLAG_UPDHLPDLLS = @as(u32, 16);
pub const RSC_FLAG_DELAYREGISTEROCX = @as(u32, 512);
pub const RSC_FLAG_SETUPAPI = @as(u32, 1024);
pub const ALINF_QUIET = @as(u32, 4);
pub const ALINF_NGCONV = @as(u32, 8);
pub const ALINF_UPDHLPDLLS = @as(u32, 16);
pub const ALINF_BKINSTALL = @as(u32, 32);
pub const ALINF_ROLLBACK = @as(u32, 64);
pub const ALINF_CHECKBKDATA = @as(u32, 128);
pub const ALINF_ROLLBKDOALL = @as(u32, 256);
pub const ALINF_DELAYREGISTEROCX = @as(u32, 512);
pub const AIF_WARNIFSKIP = @as(u32, 1);
pub const AIF_NOSKIP = @as(u32, 2);
pub const AIF_NOVERSIONCHECK = @as(u32, 4);
pub const AIF_FORCE_FILE_IN_USE = @as(u32, 8);
pub const AIF_NOOVERWRITE = @as(u32, 16);
pub const AIF_NO_VERSION_DIALOG = @as(u32, 32);
pub const AIF_REPLACEONLY = @as(u32, 1024);
pub const AIF_NOLANGUAGECHECK = @as(u32, 268435456);
pub const AIF_QUIET = @as(u32, 536870912);
pub const IE4_RESTORE = @as(u32, 1);
pub const IE4_BACKNEW = @as(u32, 2);
pub const IE4_NODELETENEW = @as(u32, 4);
pub const IE4_NOMESSAGES = @as(u32, 8);
pub const IE4_NOPROGRESS = @as(u32, 16);
pub const IE4_NOENUMKEY = @as(u32, 32);
pub const IE4_NO_CRC_MAPPING = @as(u32, 64);
pub const IE4_REGSECTION = @as(u32, 128);
pub const IE4_FRDOALL = @as(u32, 256);
pub const IE4_UPDREFCNT = @as(u32, 512);
pub const IE4_USEREFCNT = @as(u32, 1024);
pub const IE4_EXTRAINCREFCNT = @as(u32, 2048);
pub const IE4_REMOVREGBKDATA = @as(u32, 4096);
pub const AADBE_ADD_ENTRY = @as(u32, 1);
pub const AADBE_DEL_ENTRY = @as(u32, 2);
pub const ADN_DEL_IF_EMPTY = @as(u32, 1);
pub const ADN_DONT_DEL_SUBDIRS = @as(u32, 2);
pub const ADN_DONT_DEL_DIR = @as(u32, 4);
pub const ADN_DEL_UNC_PATHS = @as(u32, 8);
pub const LIS_QUIET = @as(u32, 1);
pub const LIS_NOGRPCONV = @as(u32, 2);
pub const RUNCMDS_QUIET = @as(u32, 1);
pub const RUNCMDS_NOWAIT = @as(u32, 2);
pub const RUNCMDS_DELAYPOSTCMD = @as(u32, 4);
pub const IME_MAXPROCESS = @as(u32, 32);
pub const CP_HWND = @as(u32, 0);
pub const CP_OPEN = @as(u32, 1);
pub const CP_DIRECT = @as(u32, 2);
pub const CP_LEVEL = @as(u32, 3);
pub const VK_DBE_ALPHANUMERIC = @as(u32, 240);
pub const VK_DBE_KATAKANA = @as(u32, 241);
pub const VK_DBE_HIRAGANA = @as(u32, 242);
pub const VK_DBE_SBCSCHAR = @as(u32, 243);
pub const VK_DBE_DBCSCHAR = @as(u32, 244);
pub const VK_DBE_ROMAN = @as(u32, 245);
pub const VK_DBE_NOROMAN = @as(u32, 246);
pub const VK_DBE_ENTERWORDREGISTERMODE = @as(u32, 247);
pub const VK_DBE_ENTERIMECONFIGMODE = @as(u32, 248);
pub const VK_DBE_FLUSHSTRING = @as(u32, 249);
pub const VK_DBE_CODEINPUT = @as(u32, 250);
pub const VK_DBE_NOCODEINPUT = @as(u32, 251);
pub const VK_DBE_DETERMINESTRING = @as(u32, 252);
pub const VK_DBE_ENTERDLGCONVERSIONMODE = @as(u32, 253);
pub const MCW_DEFAULT = @as(u32, 0);
pub const MCW_RECT = @as(u32, 1);
pub const MCW_WINDOW = @as(u32, 2);
pub const MCW_SCREEN = @as(u32, 4);
pub const MCW_VERTICAL = @as(u32, 8);
pub const MCW_HIDDEN = @as(u32, 16);
pub const IME_MODE_ALPHANUMERIC = @as(u32, 1);
pub const IME_MODE_SBCSCHAR = @as(u32, 2);
pub const IME_MODE_KATAKANA = @as(u32, 2);
pub const IME_MODE_HIRAGANA = @as(u32, 4);
pub const IME_MODE_HANJACONVERT = @as(u32, 4);
pub const IME_MODE_DBCSCHAR = @as(u32, 16);
pub const IME_MODE_ROMAN = @as(u32, 32);
pub const IME_MODE_NOROMAN = @as(u32, 64);
pub const IME_MODE_CODEINPUT = @as(u32, 128);
pub const IME_MODE_NOCODEINPUT = @as(u32, 256);
pub const IME_GETIMECAPS = @as(u32, 3);
pub const IME_SETOPEN = @as(u32, 4);
pub const IME_GETOPEN = @as(u32, 5);
pub const IME_GETVERSION = @as(u32, 7);
pub const IME_SETCONVERSIONWINDOW = @as(u32, 8);
pub const IME_SETCONVERSIONMODE = @as(u32, 16);
pub const IME_GETCONVERSIONMODE = @as(u32, 17);
pub const IME_SET_MODE = @as(u32, 18);
pub const IME_SENDVKEY = @as(u32, 19);
pub const IME_ENTERWORDREGISTERMODE = @as(u32, 24);
pub const IME_SETCONVERSIONFONTEX = @as(u32, 25);
pub const IME_BANJAtoJUNJA = @as(u32, 19);
pub const IME_JUNJAtoBANJA = @as(u32, 20);
pub const IME_JOHABtoKS = @as(u32, 21);
pub const IME_KStoJOHAB = @as(u32, 22);
pub const IMEA_INIT = @as(u32, 1);
pub const IMEA_NEXT = @as(u32, 2);
pub const IMEA_PREV = @as(u32, 3);
pub const IME_REQUEST_CONVERT = @as(u32, 1);
pub const IME_ENABLE_CONVERT = @as(u32, 2);
pub const INTERIM_WINDOW = @as(u32, 0);
pub const MODE_WINDOW = @as(u32, 1);
pub const HANJA_WINDOW = @as(u32, 2);
pub const IME_RS_ERROR = @as(u32, 1);
pub const IME_RS_NOIME = @as(u32, 2);
pub const IME_RS_TOOLONG = @as(u32, 5);
pub const IME_RS_ILLEGAL = @as(u32, 6);
pub const IME_RS_NOTFOUND = @as(u32, 7);
pub const IME_RS_NOROOM = @as(u32, 10);
pub const IME_RS_DISKERROR = @as(u32, 14);
pub const IME_RS_INVALID = @as(u32, 17);
pub const IME_RS_NEST = @as(u32, 18);
pub const IME_RS_SYSTEMMODAL = @as(u32, 19);
pub const WM_IME_REPORT = @as(u32, 640);
pub const IR_STRINGSTART = @as(u32, 256);
pub const IR_STRINGEND = @as(u32, 257);
pub const IR_OPENCONVERT = @as(u32, 288);
pub const IR_CHANGECONVERT = @as(u32, 289);
pub const IR_CLOSECONVERT = @as(u32, 290);
pub const IR_FULLCONVERT = @as(u32, 291);
pub const IR_IMESELECT = @as(u32, 304);
pub const IR_STRING = @as(u32, 320);
pub const IR_DBCSCHAR = @as(u32, 352);
pub const IR_UNDETERMINE = @as(u32, 368);
pub const IR_STRINGEX = @as(u32, 384);
pub const IR_MODEINFO = @as(u32, 400);
pub const WM_WNT_CONVERTREQUESTEX = @as(u32, 265);
pub const WM_CONVERTREQUEST = @as(u32, 266);
pub const WM_CONVERTRESULT = @as(u32, 267);
pub const WM_INTERIM = @as(u32, 268);
pub const WM_IMEKEYDOWN = @as(u32, 656);
pub const WM_IMEKEYUP = @as(u32, 657);
pub const ICW_MAX_ACCTNAME = @as(u32, 256);
pub const ICW_MAX_PASSWORD = @as(u32, 256);
pub const ICW_MAX_LOGONNAME = @as(u32, 256);
pub const ICW_MAX_SERVERNAME = @as(u32, 64);
pub const ICW_MAX_RASNAME = @as(u32, 256);
pub const ICW_MAX_EMAILNAME = @as(u32, 64);
pub const ICW_MAX_EMAILADDR = @as(u32, 128);
pub const ICW_CHECKSTATUS = @as(u32, 1);
pub const ICW_LAUNCHFULL = @as(u32, 256);
pub const ICW_LAUNCHMANUAL = @as(u32, 512);
pub const ICW_USE_SHELLNEXT = @as(u32, 1024);
pub const ICW_FULL_SMARTSTART = @as(u32, 2048);
pub const ICW_FULLPRESENT = @as(u32, 1);
pub const ICW_MANUALPRESENT = @as(u32, 2);
pub const ICW_ALREADYRUN = @as(u32, 4);
pub const ICW_LAUNCHEDFULL = @as(u32, 256);
pub const ICW_LAUNCHEDMANUAL = @as(u32, 512);
pub const ICW_USEDEFAULTS = @as(u32, 1);
pub const RRF_SUBKEY_WOW6464KEY = @as(u32, 65536);
pub const RRF_SUBKEY_WOW6432KEY = @as(u32, 131072);
pub const RRF_WOW64_MASK = @as(u32, 196608);
pub const RRF_NOEXPAND = @as(u32, 268435456);
pub const RRF_ZEROONFAILURE = @as(u32, 536870912);
pub const REG_PROCESS_APPKEY = @as(u32, 1);
pub const PROVIDER_KEEPS_VALUE_LENGTH = @as(u32, 1);
pub const REG_MUI_STRING_TRUNCATE = @as(u32, 1);
pub const REG_SECURE_CONNECTION = @as(u32, 1);
pub const PROC_THREAD_ATTRIBUTE_REPLACE_VALUE = @as(u32, 1);
pub const THREAD_POWER_THROTTLING_CURRENT_VERSION = @as(u32, 1);
pub const THREAD_POWER_THROTTLING_EXECUTION_SPEED = @as(u32, 1);
pub const PME_CURRENT_VERSION = @as(u32, 1);
pub const PME_FAILFAST_ON_COMMIT_FAIL_DISABLE = @as(u32, 0);
pub const PME_FAILFAST_ON_COMMIT_FAIL_ENABLE = @as(u32, 1);
pub const PROCESS_POWER_THROTTLING_CURRENT_VERSION = @as(u32, 1);
pub const PROCESS_POWER_THROTTLING_EXECUTION_SPEED = @as(u32, 1);
pub const PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND = @as(u32, 1);
pub const SCEX2_ALT_NETBIOS_NAME = @as(u32, 1);
pub const SURFACEALIGN_DISCARDABLE = @as(i32, 1);
pub const VMEMHEAP_LINEAR = @as(i32, 1);
pub const VMEMHEAP_RECTANGULAR = @as(i32, 2);
pub const VMEMHEAP_ALIGNMENT = @as(i32, 4);
pub const DDKERNELCAPS_SKIPFIELDS = @as(i32, 1);
pub const DDKERNELCAPS_AUTOFLIP = @as(i32, 2);
pub const DDKERNELCAPS_SETSTATE = @as(i32, 4);
pub const DDKERNELCAPS_LOCK = @as(i32, 8);
pub const DDKERNELCAPS_FLIPVIDEOPORT = @as(i32, 16);
pub const DDKERNELCAPS_FLIPOVERLAY = @as(i32, 32);
pub const DDKERNELCAPS_CAPTURE_SYSMEM = @as(i32, 64);
pub const DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM = @as(i32, 128);
pub const DDKERNELCAPS_FIELDPOLARITY = @as(i32, 256);
pub const DDKERNELCAPS_CAPTURE_INVERTED = @as(i32, 512);
pub const DDIRQ_DISPLAY_VSYNC = @as(i32, 1);
pub const DDIRQ_RESERVED1 = @as(i32, 2);
pub const DDIRQ_VPORT0_VSYNC = @as(i32, 4);
pub const DDIRQ_VPORT0_LINE = @as(i32, 8);
pub const DDIRQ_VPORT1_VSYNC = @as(i32, 16);
pub const DDIRQ_VPORT1_LINE = @as(i32, 32);
pub const DDIRQ_VPORT2_VSYNC = @as(i32, 64);
pub const DDIRQ_VPORT2_LINE = @as(i32, 128);
pub const DDIRQ_VPORT3_VSYNC = @as(i32, 256);
pub const DDIRQ_VPORT3_LINE = @as(i32, 512);
pub const DDIRQ_VPORT4_VSYNC = @as(i32, 1024);
pub const DDIRQ_VPORT4_LINE = @as(i32, 2048);
pub const DDIRQ_VPORT5_VSYNC = @as(i32, 4096);
pub const DDIRQ_VPORT5_LINE = @as(i32, 8192);
pub const DDIRQ_VPORT6_VSYNC = @as(i32, 16384);
pub const DDIRQ_VPORT6_LINE = @as(i32, 32768);
pub const DDIRQ_VPORT7_VSYNC = @as(i32, 65536);
pub const DDIRQ_VPORT7_LINE = @as(i32, 131072);
pub const DDIRQ_VPORT8_VSYNC = @as(i32, 262144);
pub const DDIRQ_VPORT8_LINE = @as(i32, 524288);
pub const DDIRQ_VPORT9_VSYNC = @as(i32, 65536);
pub const DDIRQ_VPORT9_LINE = @as(i32, 131072);
pub const FD_FLAGS_NOSYN = @as(u32, 1);
pub const LB_SRC_ADDR_USE_SRCADDR_FLAG = @as(u32, 1);
pub const LB_SRC_ADDR_USE_DSTADDR_FLAG = @as(u32, 2);
pub const LB_DST_ADDR_USE_SRCADDR_FLAG = @as(u32, 4);
pub const LB_DST_ADDR_USE_DSTADDR_FLAG = @as(u32, 8);
pub const LB_SRC_MASK_LATE_FLAG = @as(u32, 16);
pub const LB_DST_MASK_LATE_FLAG = @as(u32, 32);
pub const ERROR_BASE = @as(u32, 23000);
pub const PFERROR_NO_PF_INTERFACE = @as(u32, 23000);
pub const PFERROR_NO_FILTERS_GIVEN = @as(u32, 23001);
pub const PFERROR_BUFFER_TOO_SMALL = @as(u32, 23002);
pub const ERROR_IPV6_NOT_IMPLEMENTED = @as(u32, 23003);
pub const MAX_REASON_NAME_LEN = @as(u32, 64);
pub const MAX_REASON_DESC_LEN = @as(u32, 256);
pub const MAX_REASON_BUGID_LEN = @as(u32, 32);
pub const MAX_REASON_COMMENT_LEN = @as(u32, 512);
pub const SHUTDOWN_TYPE_LEN = @as(u32, 32);
pub const POLICY_SHOWREASONUI_NEVER = @as(u32, 0);
pub const POLICY_SHOWREASONUI_ALWAYS = @as(u32, 1);
pub const POLICY_SHOWREASONUI_WORKSTATIONONLY = @as(u32, 2);
pub const POLICY_SHOWREASONUI_SERVERONLY = @as(u32, 3);
pub const SNAPSHOT_POLICY_NEVER = @as(u32, 0);
pub const SNAPSHOT_POLICY_ALWAYS = @as(u32, 1);
pub const SNAPSHOT_POLICY_UNPLANNED = @as(u32, 2);
pub const MAX_NUM_REASONS = @as(u32, 256);
pub const _IID_IXmlReader = Guid.initString("7279fc81-709d-4095-b63d-69fe4b0d9030");
pub const _IID_IXmlWriter = Guid.initString("7279fc88-709d-4095-b63d-69fe4b0d9030");
pub const _IID_IXmlResolver = Guid.initString("7279fc82-709d-4095-b63d-69fe4b0d9030");

//--------------------------------------------------------------------------------
// Section: Types (602)
//--------------------------------------------------------------------------------
// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PROCESS_CREATION_FLAGS = extern enum(u32) {
    DEBUG_PROCESS = 1,
    DEBUG_ONLY_THIS_PROCESS = 2,
    CREATE_SUSPENDED = 4,
    DETACHED_PROCESS = 8,
    CREATE_NEW_CONSOLE = 16,
    NORMAL_PRIORITY_CLASS = 32,
    IDLE_PRIORITY_CLASS = 64,
    HIGH_PRIORITY_CLASS = 128,
    REALTIME_PRIORITY_CLASS = 256,
    CREATE_NEW_PROCESS_GROUP = 512,
    CREATE_UNICODE_ENVIRONMENT = 1024,
    CREATE_SEPARATE_WOW_VDM = 2048,
    CREATE_SHARED_WOW_VDM = 4096,
    CREATE_FORCEDOS = 8192,
    BELOW_NORMAL_PRIORITY_CLASS = 16384,
    ABOVE_NORMAL_PRIORITY_CLASS = 32768,
    INHERIT_PARENT_AFFINITY = 65536,
    INHERIT_CALLER_PRIORITY = 131072,
    CREATE_PROTECTED_PROCESS = 262144,
    EXTENDED_STARTUPINFO_PRESENT = 524288,
    PROCESS_MODE_BACKGROUND_BEGIN = 1048576,
    PROCESS_MODE_BACKGROUND_END = 2097152,
    CREATE_SECURE_PROCESS = 4194304,
    CREATE_BREAKAWAY_FROM_JOB = 16777216,
    CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432,
    CREATE_DEFAULT_ERROR_MODE = 67108864,
    CREATE_NO_WINDOW = 134217728,
    PROFILE_USER = 268435456,
    PROFILE_KERNEL = 536870912,
    PROFILE_SERVER = 1073741824,
    CREATE_IGNORE_SYSTEM_DEFAULT = 2147483648,
    _,
};
pub const DEBUG_PROCESS = PROCESS_CREATION_FLAGS.DEBUG_PROCESS;
pub const DEBUG_ONLY_THIS_PROCESS = PROCESS_CREATION_FLAGS.DEBUG_ONLY_THIS_PROCESS;
pub const CREATE_SUSPENDED = PROCESS_CREATION_FLAGS.CREATE_SUSPENDED;
pub const DETACHED_PROCESS = PROCESS_CREATION_FLAGS.DETACHED_PROCESS;
pub const CREATE_NEW_CONSOLE = PROCESS_CREATION_FLAGS.CREATE_NEW_CONSOLE;
pub const NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.NORMAL_PRIORITY_CLASS;
pub const IDLE_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.IDLE_PRIORITY_CLASS;
pub const HIGH_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.HIGH_PRIORITY_CLASS;
pub const REALTIME_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.REALTIME_PRIORITY_CLASS;
pub const CREATE_NEW_PROCESS_GROUP = PROCESS_CREATION_FLAGS.CREATE_NEW_PROCESS_GROUP;
pub const CREATE_UNICODE_ENVIRONMENT = PROCESS_CREATION_FLAGS.CREATE_UNICODE_ENVIRONMENT;
pub const CREATE_SEPARATE_WOW_VDM = PROCESS_CREATION_FLAGS.CREATE_SEPARATE_WOW_VDM;
pub const CREATE_SHARED_WOW_VDM = PROCESS_CREATION_FLAGS.CREATE_SHARED_WOW_VDM;
pub const CREATE_FORCEDOS = PROCESS_CREATION_FLAGS.CREATE_FORCEDOS;
pub const BELOW_NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.BELOW_NORMAL_PRIORITY_CLASS;
pub const ABOVE_NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.ABOVE_NORMAL_PRIORITY_CLASS;
pub const INHERIT_PARENT_AFFINITY = PROCESS_CREATION_FLAGS.INHERIT_PARENT_AFFINITY;
pub const INHERIT_CALLER_PRIORITY = PROCESS_CREATION_FLAGS.INHERIT_CALLER_PRIORITY;
pub const CREATE_PROTECTED_PROCESS = PROCESS_CREATION_FLAGS.CREATE_PROTECTED_PROCESS;
pub const EXTENDED_STARTUPINFO_PRESENT = PROCESS_CREATION_FLAGS.EXTENDED_STARTUPINFO_PRESENT;
pub const PROCESS_MODE_BACKGROUND_BEGIN = PROCESS_CREATION_FLAGS.PROCESS_MODE_BACKGROUND_BEGIN;
pub const PROCESS_MODE_BACKGROUND_END = PROCESS_CREATION_FLAGS.PROCESS_MODE_BACKGROUND_END;
pub const CREATE_SECURE_PROCESS = PROCESS_CREATION_FLAGS.CREATE_SECURE_PROCESS;
pub const CREATE_BREAKAWAY_FROM_JOB = PROCESS_CREATION_FLAGS.CREATE_BREAKAWAY_FROM_JOB;
pub const CREATE_PRESERVE_CODE_AUTHZ_LEVEL = PROCESS_CREATION_FLAGS.CREATE_PRESERVE_CODE_AUTHZ_LEVEL;
pub const CREATE_DEFAULT_ERROR_MODE = PROCESS_CREATION_FLAGS.CREATE_DEFAULT_ERROR_MODE;
pub const CREATE_NO_WINDOW = PROCESS_CREATION_FLAGS.CREATE_NO_WINDOW;
pub const PROFILE_USER = PROCESS_CREATION_FLAGS.PROFILE_USER;
pub const PROFILE_KERNEL = PROCESS_CREATION_FLAGS.PROFILE_KERNEL;
pub const PROFILE_SERVER = PROCESS_CREATION_FLAGS.PROFILE_SERVER;
pub const CREATE_IGNORE_SYSTEM_DEFAULT = PROCESS_CREATION_FLAGS.CREATE_IGNORE_SYSTEM_DEFAULT;

pub const HANDLE_FLAG_OPTIONS = extern enum(i32) {
    INHERIT = 1,
    PROTECT_FROM_CLOSE = 2,
};
pub const HANDLE_FLAG_INHERIT = HANDLE_FLAG_OPTIONS.INHERIT;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE = HANDLE_FLAG_OPTIONS.PROTECT_FROM_CLOSE;

pub const DUPLICATE_HANDLE_OPTIONS = extern enum(i32) {
    CLOSE_SOURCE = 1,
    SAME_ACCESS = 2,
};
pub const DUPLICATE_CLOSE_SOURCE = DUPLICATE_HANDLE_OPTIONS.CLOSE_SOURCE;
pub const DUPLICATE_SAME_ACCESS = DUPLICATE_HANDLE_OPTIONS.SAME_ACCESS;

pub const STD_HANDLE_TYPE = extern enum(u32) {
    INPUT_HANDLE = 4294967286,
    OUTPUT_HANDLE = 4294967285,
    ERROR_HANDLE = 4294967284,
};
pub const STD_INPUT_HANDLE = STD_HANDLE_TYPE.INPUT_HANDLE;
pub const STD_OUTPUT_HANDLE = STD_HANDLE_TYPE.OUTPUT_HANDLE;
pub const STD_ERROR_HANDLE = STD_HANDLE_TYPE.ERROR_HANDLE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const VER_FLAGS = extern enum(u32) {
    MINORVERSION = 1,
    MAJORVERSION = 2,
    BUILDNUMBER = 4,
    PLATFORMID = 8,
    SERVICEPACKMINOR = 16,
    SERVICEPACKMAJOR = 32,
    SUITENAME = 64,
    PRODUCT_TYPE = 128,
    _,
};
pub const VER_MINORVERSION = VER_FLAGS.MINORVERSION;
pub const VER_MAJORVERSION = VER_FLAGS.MAJORVERSION;
pub const VER_BUILDNUMBER = VER_FLAGS.BUILDNUMBER;
pub const VER_PLATFORMID = VER_FLAGS.PLATFORMID;
pub const VER_SERVICEPACKMINOR = VER_FLAGS.SERVICEPACKMINOR;
pub const VER_SERVICEPACKMAJOR = VER_FLAGS.SERVICEPACKMAJOR;
pub const VER_SUITENAME = VER_FLAGS.SUITENAME;
pub const VER_PRODUCT_TYPE = VER_FLAGS.PRODUCT_TYPE;

pub const REG_VALUE_TYPE = extern enum(u32) {
    NONE = 0,
    SZ = 1,
    EXPAND_SZ = 2,
    BINARY = 3,
    DWORD = 4,
    DWORD_LITTLE_ENDIAN = 4,
    DWORD_BIG_ENDIAN = 5,
    LINK = 6,
    MULTI_SZ = 7,
    RESOURCE_LIST = 8,
    FULL_RESOURCE_DESCRIPTOR = 9,
    RESOURCE_REQUIREMENTS_LIST = 10,
    QWORD = 11,
    QWORD_LITTLE_ENDIAN = 11,
};
pub const REG_NONE = REG_VALUE_TYPE.NONE;
pub const REG_SZ = REG_VALUE_TYPE.SZ;
pub const REG_EXPAND_SZ = REG_VALUE_TYPE.EXPAND_SZ;
pub const REG_BINARY = REG_VALUE_TYPE.BINARY;
pub const REG_DWORD = REG_VALUE_TYPE.DWORD;
pub const REG_DWORD_LITTLE_ENDIAN = REG_VALUE_TYPE.DWORD_LITTLE_ENDIAN;
pub const REG_DWORD_BIG_ENDIAN = REG_VALUE_TYPE.DWORD_BIG_ENDIAN;
pub const REG_LINK = REG_VALUE_TYPE.LINK;
pub const REG_MULTI_SZ = REG_VALUE_TYPE.MULTI_SZ;
pub const REG_RESOURCE_LIST = REG_VALUE_TYPE.RESOURCE_LIST;
pub const REG_FULL_RESOURCE_DESCRIPTOR = REG_VALUE_TYPE.FULL_RESOURCE_DESCRIPTOR;
pub const REG_RESOURCE_REQUIREMENTS_LIST = REG_VALUE_TYPE.RESOURCE_REQUIREMENTS_LIST;
pub const REG_QWORD = REG_VALUE_TYPE.QWORD;
pub const REG_QWORD_LITTLE_ENDIAN = REG_VALUE_TYPE.QWORD_LITTLE_ENDIAN;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const REG_SAM_FLAGS = extern enum(u32) {
    QUERY_VALUE = 1,
    SET_VALUE = 2,
    CREATE_SUB_KEY = 4,
    ENUMERATE_SUB_KEYS = 8,
    NOTIFY = 16,
    CREATE_LINK = 32,
    WOW64_32KEY = 512,
    WOW64_64KEY = 256,
    WOW64_RES = 768,
    READ = 131097,
    WRITE = 131078,
    EXECUTE = 131097,
    ALL_ACCESS = 983103,
    _,
};
pub const KEY_QUERY_VALUE = REG_SAM_FLAGS.QUERY_VALUE;
pub const KEY_SET_VALUE = REG_SAM_FLAGS.SET_VALUE;
pub const KEY_CREATE_SUB_KEY = REG_SAM_FLAGS.CREATE_SUB_KEY;
pub const KEY_ENUMERATE_SUB_KEYS = REG_SAM_FLAGS.ENUMERATE_SUB_KEYS;
pub const KEY_NOTIFY = REG_SAM_FLAGS.NOTIFY;
pub const KEY_CREATE_LINK = REG_SAM_FLAGS.CREATE_LINK;
pub const KEY_WOW64_32KEY = REG_SAM_FLAGS.WOW64_32KEY;
pub const KEY_WOW64_64KEY = REG_SAM_FLAGS.WOW64_64KEY;
pub const KEY_WOW64_RES = REG_SAM_FLAGS.WOW64_RES;
pub const KEY_READ = REG_SAM_FLAGS.READ;
pub const KEY_WRITE = REG_SAM_FLAGS.WRITE;
pub const KEY_EXECUTE = REG_SAM_FLAGS.EXECUTE;
pub const KEY_ALL_ACCESS = REG_SAM_FLAGS.ALL_ACCESS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const REG_OPEN_CREATE_OPTIONS = extern enum(u32) {
    RESERVED = 0,
    NON_VOLATILE = 0,
    VOLATILE = 1,
    CREATE_LINK = 2,
    BACKUP_RESTORE = 4,
    OPEN_LINK = 8,
    DONT_VIRTUALIZE = 16,
    _,
};
// TODO: enum 'REG_OPEN_CREATE_OPTIONS' has known issues with its value aliases

pub const REG_CREATE_KEY_DISPOSITION = extern enum(u32) {
    CREATED_NEW_KEY = 1,
    OPENED_EXISTING_KEY = 2,
};
pub const REG_CREATED_NEW_KEY = REG_CREATE_KEY_DISPOSITION.CREATED_NEW_KEY;
pub const REG_OPENED_EXISTING_KEY = REG_CREATE_KEY_DISPOSITION.OPENED_EXISTING_KEY;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FDISPILLFILE = extern struct {
    ach: [2]CHAR,
    cbFile: i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Cr0NpxState: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VDMCONTEXT = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VDMLDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: _HighWord_e__Union,
    const _HighWord_e__Union = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const MODULEENTRY = extern struct {
    dwSize: u32,
    szModule: [10]CHAR,
    hModule: HANDLE,
    wcUsage: u16,
    szExePath: [256]CHAR,
    wNext: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const GLOBALENTRY = extern struct {
    dwSize: u32,
    dwAddress: u32,
    dwBlockSize: u32,
    hBlock: HANDLE,
    wcLock: u16,
    wcPageLock: u16,
    wFlags: u16,
    wHeapPresent: BOOL,
    hOwner: HANDLE,
    wType: u16,
    wData: u16,
    dwNext: u32,
    dwNextAlt: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VDMGETTHREADSELECTORENTRYPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u32,
    param3: *VDMLDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VDMGETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *VDMCONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VDMSETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *VDMCONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub const IDirectDrawClipperVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawPaletteVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurfaceVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurface2Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurface3Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurface4Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurface7Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawColorControlVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDraw2Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDraw4Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDraw7Vtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawKernelVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawSurfaceKernelVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawGammaControlVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _D3DHAL_CALLBACKS = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _D3DHAL_GLOBALDRIVERDATA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const tcp_request_query_information_ex_xp = extern struct {
    ID: TDIObjectID,
    Context: [2]usize,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const tcp_request_query_information_ex32_xp = extern struct {
    ID: TDIObjectID,
    Context: [4]u32,
};

}, else => struct { } };

pub const FIRMWARE_TYPE = extern enum(i32) {
    Unknown = 0,
    Bios = 1,
    Uefi = 2,
    Max = 3,
};
pub const FirmwareTypeUnknown = FIRMWARE_TYPE.Unknown;
pub const FirmwareTypeBios = FIRMWARE_TYPE.Bios;
pub const FirmwareTypeUefi = FIRMWARE_TYPE.Uefi;
pub const FirmwareTypeMax = FIRMWARE_TYPE.Max;

pub const OSVERSIONINFOA = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]CHAR,
};

pub const OSVERSIONINFOW = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]u16,
};

pub const OSVERSIONINFOEXA = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]CHAR,
    wServicePackMajor: u16,
    wServicePackMinor: u16,
    wSuiteMask: u16,
    wProductType: u8,
    wReserved: u8,
};

pub const OSVERSIONINFOEXW = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]u16,
    wServicePackMajor: u16,
    wServicePackMinor: u16,
    wSuiteMask: u16,
    wProductType: u8,
    wReserved: u8,
};

pub const FILETIME = extern struct {
    dwLowDateTime: u32,
    dwHighDateTime: u32,
};

// TODO: this type has a FreeFunc 'RegCloseKey', what can Zig do with this information?
pub const HKEY = ?*opaque{};

pub const HWINWATCH = ?*opaque{};

pub const FEATURE_STATE_CHANGE_SUBSCRIPTION = isize;

pub const FH_SERVICE_PIPE_HANDLE = isize;

pub const SYSTEMTIME = extern struct {
    wYear: u16,
    wMonth: u16,
    wDayOfWeek: u16,
    wDay: u16,
    wHour: u16,
    wMinute: u16,
    wSecond: u16,
    wMilliseconds: u16,
};

pub const UpdateImpactLevel = extern enum(i32) {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
};
pub const UpdateImpactLevel_None = UpdateImpactLevel.None;
pub const UpdateImpactLevel_Low = UpdateImpactLevel.Low;
pub const UpdateImpactLevel_Medium = UpdateImpactLevel.Medium;
pub const UpdateImpactLevel_High = UpdateImpactLevel.High;

pub const UpdateAssessmentStatus = extern enum(i32) {
    Latest = 0,
    NotLatestSoftRestriction = 1,
    NotLatestHardRestriction = 2,
    NotLatestEndOfSupport = 3,
    NotLatestServicingTrain = 4,
    NotLatestDeferredFeature = 5,
    NotLatestDeferredQuality = 6,
    NotLatestPausedFeature = 7,
    NotLatestPausedQuality = 8,
    NotLatestManaged = 9,
    NotLatestUnknown = 10,
    NotLatestTargetedVersion = 11,
};
pub const UpdateAssessmentStatus_Latest = UpdateAssessmentStatus.Latest;
pub const UpdateAssessmentStatus_NotLatestSoftRestriction = UpdateAssessmentStatus.NotLatestSoftRestriction;
pub const UpdateAssessmentStatus_NotLatestHardRestriction = UpdateAssessmentStatus.NotLatestHardRestriction;
pub const UpdateAssessmentStatus_NotLatestEndOfSupport = UpdateAssessmentStatus.NotLatestEndOfSupport;
pub const UpdateAssessmentStatus_NotLatestServicingTrain = UpdateAssessmentStatus.NotLatestServicingTrain;
pub const UpdateAssessmentStatus_NotLatestDeferredFeature = UpdateAssessmentStatus.NotLatestDeferredFeature;
pub const UpdateAssessmentStatus_NotLatestDeferredQuality = UpdateAssessmentStatus.NotLatestDeferredQuality;
pub const UpdateAssessmentStatus_NotLatestPausedFeature = UpdateAssessmentStatus.NotLatestPausedFeature;
pub const UpdateAssessmentStatus_NotLatestPausedQuality = UpdateAssessmentStatus.NotLatestPausedQuality;
pub const UpdateAssessmentStatus_NotLatestManaged = UpdateAssessmentStatus.NotLatestManaged;
pub const UpdateAssessmentStatus_NotLatestUnknown = UpdateAssessmentStatus.NotLatestUnknown;
pub const UpdateAssessmentStatus_NotLatestTargetedVersion = UpdateAssessmentStatus.NotLatestTargetedVersion;

pub const UpdateAssessment = extern struct {
    status: UpdateAssessmentStatus,
    impact: UpdateImpactLevel,
    daysOutOfDate: u32,
};

pub const OSUpdateAssessment = extern struct {
    isEndOfSupport: BOOL,
    assessmentForCurrent: UpdateAssessment,
    assessmentForUpToDate: UpdateAssessment,
    securityStatus: UpdateAssessmentStatus,
    assessmentTime: FILETIME,
    releaseInfoTime: FILETIME,
    currentOSBuild: PWSTR,
    currentOSReleaseTime: FILETIME,
    upToDateOSBuild: PWSTR,
    upToDateOSReleaseTime: FILETIME,
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Spare0: u32,
};

}, else => struct { } };

pub const PSYMBOLSERVERCALLBACKPROC = fn(
    action: usize,
    data: u64,
    context: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const STRING = extern struct {
    Length: u16,
    MaximumLength: u16,
    Buffer: [*]u8,
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FDISPILLFILE = extern struct {
    ach: [2]CHAR,
    cbFile: i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const MODULEENTRY = extern struct {
    dwSize: u32,
    szModule: [10]CHAR,
    hModule: HANDLE,
    wcUsage: u16,
    szExePath: [256]CHAR,
    wNext: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const GLOBALENTRY = extern struct {
    dwSize: u32,
    dwAddress: u32,
    dwBlockSize: u32,
    hBlock: HANDLE,
    wcLock: u16,
    wcPageLock: u16,
    wFlags: u16,
    wHeapPresent: BOOL,
    hOwner: HANDLE,
    wType: u16,
    wData: u16,
    dwNext: u32,
    dwNextAlt: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VDMGETTHREADSELECTORENTRYPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u32,
    param3: *LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VDMGETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VDMSETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const tcp_request_query_information_ex_xp = extern struct {
    ID: TDIObjectID,
    Context: [4]usize,
};

}, else => struct { } };

pub const REG_SAVE_FORMAT = extern enum(u32) {
    STANDARD_FORMAT = 1,
    LATEST_FORMAT = 2,
    NO_COMPRESSION = 4,
};
pub const REG_STANDARD_FORMAT = REG_SAVE_FORMAT.STANDARD_FORMAT;
pub const REG_LATEST_FORMAT = REG_SAVE_FORMAT.LATEST_FORMAT;
pub const REG_NO_COMPRESSION = REG_SAVE_FORMAT.NO_COMPRESSION;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const VERIFIER_ENUM_RESOURCE_FLAGS = extern enum(u32) {
    DONT_RESOLVE_TRACES = 2,
    SUSPEND = 1,
    _,
};
pub const AVRF_ENUM_RESOURCES_FLAGS_DONT_RESOLVE_TRACES = VERIFIER_ENUM_RESOURCE_FLAGS.DONT_RESOLVE_TRACES;
pub const AVRF_ENUM_RESOURCES_FLAGS_SUSPEND = VERIFIER_ENUM_RESOURCE_FLAGS.SUSPEND;

pub const REG_RESTORE_KEY_FLAGS = extern enum(i32) {
    FORCE_RESTORE = 8,
    WHOLE_HIVE_VOLATILE = 1,
};
pub const REG_FORCE_RESTORE = REG_RESTORE_KEY_FLAGS.FORCE_RESTORE;
pub const REG_WHOLE_HIVE_VOLATILE = REG_RESTORE_KEY_FLAGS.WHOLE_HIVE_VOLATILE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const REG_NOTIFY_FILTER = extern enum(u32) {
    CHANGE_NAME = 1,
    CHANGE_ATTRIBUTES = 2,
    CHANGE_LAST_SET = 4,
    CHANGE_SECURITY = 8,
    THREAD_AGNOSTIC = 268435456,
    _,
};
pub const REG_NOTIFY_CHANGE_NAME = REG_NOTIFY_FILTER.CHANGE_NAME;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES = REG_NOTIFY_FILTER.CHANGE_ATTRIBUTES;
pub const REG_NOTIFY_CHANGE_LAST_SET = REG_NOTIFY_FILTER.CHANGE_LAST_SET;
pub const REG_NOTIFY_CHANGE_SECURITY = REG_NOTIFY_FILTER.CHANGE_SECURITY;
pub const REG_NOTIFY_THREAD_AGNOSTIC = REG_NOTIFY_FILTER.THREAD_AGNOSTIC;

pub const FDICREATE_CPU_TYPE = extern enum(u32) {
    @"286" = 0,
    @"386" = 1,
};
pub const cpu80286 = FDICREATE_CPU_TYPE.@"286";
pub const cpu80386 = FDICREATE_CPU_TYPE.@"386";

pub const USER_CET_ENVIRONMENT = extern enum(u32) {
    WIN32_PROCESS = 0,
    SGX2_ENCLAVE = 2,
    VBS_BASIC_ENCLAVE = 17,
};
pub const USER_CET_ENVIRONMENT_WIN32_PROCESS = USER_CET_ENVIRONMENT.WIN32_PROCESS;
pub const USER_CET_ENVIRONMENT_SGX2_ENCLAVE = USER_CET_ENVIRONMENT.SGX2_ENCLAVE;
pub const USER_CET_ENVIRONMENT_VBS_BASIC_ENCLAVE = USER_CET_ENVIRONMENT.VBS_BASIC_ENCLAVE;

pub const NT_CREATE_FILE_DISPOSITION = extern enum(u32) {
    SUPERSEDE = 0,
    CREATE = 2,
    OPEN = 1,
    OPEN_IF = 3,
    OVERWRITE = 4,
    OVERWRITE_IF = 5,
};
pub const FILE_SUPERSEDE = NT_CREATE_FILE_DISPOSITION.SUPERSEDE;
pub const FILE_CREATE = NT_CREATE_FILE_DISPOSITION.CREATE;
pub const FILE_OPEN = NT_CREATE_FILE_DISPOSITION.OPEN;
pub const FILE_OPEN_IF = NT_CREATE_FILE_DISPOSITION.OPEN_IF;
pub const FILE_OVERWRITE = NT_CREATE_FILE_DISPOSITION.OVERWRITE;
pub const FILE_OVERWRITE_IF = NT_CREATE_FILE_DISPOSITION.OVERWRITE_IF;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const RRF_RT = extern enum(u32) {
    ANY = 65535,
    DWORD = 24,
    QWORD = 72,
    REG_BINARY = 8,
    REG_DWORD = 16,
    REG_EXPAND_SZ = 4,
    REG_MULTI_SZ = 32,
    REG_NONE = 1,
    REG_QWORD = 64,
    REG_SZ = 2,
    _,
};
pub const RRF_RT_ANY = RRF_RT.ANY;
pub const RRF_RT_DWORD = RRF_RT.DWORD;
pub const RRF_RT_QWORD = RRF_RT.QWORD;
pub const RRF_RT_REG_BINARY = RRF_RT.REG_BINARY;
pub const RRF_RT_REG_DWORD = RRF_RT.REG_DWORD;
pub const RRF_RT_REG_EXPAND_SZ = RRF_RT.REG_EXPAND_SZ;
pub const RRF_RT_REG_MULTI_SZ = RRF_RT.REG_MULTI_SZ;
pub const RRF_RT_REG_NONE = RRF_RT.REG_NONE;
pub const RRF_RT_REG_QWORD = RRF_RT.REG_QWORD;
pub const RRF_RT_REG_SZ = RRF_RT.REG_SZ;

pub const OS_PRODUCT_TYPE = extern enum(u32) {
    BUSINESS = 6,
    BUSINESS_N = 16,
    CLUSTER_SERVER = 18,
    CLUSTER_SERVER_V = 64,
    CORE = 101,
    CORE_COUNTRYSPECIFIC = 99,
    CORE_N = 98,
    CORE_SINGLELANGUAGE = 100,
    DATACENTER_EVALUATION_SERVER = 80,
    DATACENTER_A_SERVER_CORE = 145,
    STANDARD_A_SERVER_CORE = 146,
    DATACENTER_SERVER = 8,
    DATACENTER_SERVER_CORE = 12,
    DATACENTER_SERVER_CORE_V = 39,
    DATACENTER_SERVER_V = 37,
    EDUCATION = 121,
    EDUCATION_N = 122,
    ENTERPRISE = 4,
    ENTERPRISE_E = 70,
    ENTERPRISE_EVALUATION = 72,
    ENTERPRISE_N = 27,
    ENTERPRISE_N_EVALUATION = 84,
    ENTERPRISE_S = 125,
    ENTERPRISE_S_EVALUATION = 129,
    ENTERPRISE_S_N = 126,
    ENTERPRISE_S_N_EVALUATION = 130,
    ENTERPRISE_SERVER = 10,
    ENTERPRISE_SERVER_CORE = 14,
    ENTERPRISE_SERVER_CORE_V = 41,
    ENTERPRISE_SERVER_IA64 = 15,
    ENTERPRISE_SERVER_V = 38,
    ESSENTIALBUSINESS_SERVER_ADDL = 60,
    ESSENTIALBUSINESS_SERVER_ADDLSVC = 62,
    ESSENTIALBUSINESS_SERVER_MGMT = 59,
    ESSENTIALBUSINESS_SERVER_MGMTSVC = 61,
    HOME_BASIC = 2,
    HOME_BASIC_E = 67,
    HOME_BASIC_N = 5,
    HOME_PREMIUM = 3,
    HOME_PREMIUM_E = 68,
    HOME_PREMIUM_N = 26,
    HOME_PREMIUM_SERVER = 34,
    HOME_SERVER = 19,
    HYPERV = 42,
    IOTUAP = 123,
    IOTUAPCOMMERCIAL = 131,
    MEDIUMBUSINESS_SERVER_MANAGEMENT = 30,
    MEDIUMBUSINESS_SERVER_MESSAGING = 32,
    MEDIUMBUSINESS_SERVER_SECURITY = 31,
    MOBILE_CORE = 104,
    MOBILE_ENTERPRISE = 133,
    MULTIPOINT_PREMIUM_SERVER = 77,
    MULTIPOINT_STANDARD_SERVER = 76,
    PRO_WORKSTATION = 161,
    PRO_WORKSTATION_N = 162,
    PROFESSIONAL = 48,
    PROFESSIONAL_E = 69,
    PROFESSIONAL_N = 49,
    PROFESSIONAL_WMC = 103,
    SB_SOLUTION_SERVER = 50,
    SB_SOLUTION_SERVER_EM = 54,
    SERVER_FOR_SB_SOLUTIONS = 51,
    SERVER_FOR_SB_SOLUTIONS_EM = 55,
    SERVER_FOR_SMALLBUSINESS = 24,
    SERVER_FOR_SMALLBUSINESS_V = 35,
    SERVER_FOUNDATION = 33,
    SMALLBUSINESS_SERVER = 9,
    SMALLBUSINESS_SERVER_PREMIUM = 25,
    SMALLBUSINESS_SERVER_PREMIUM_CORE = 63,
    SOLUTION_EMBEDDEDSERVER = 56,
    STANDARD_EVALUATION_SERVER = 79,
    STANDARD_SERVER = 7,
    STANDARD_SERVER_CORE_ = 13,
    STANDARD_SERVER_CORE_V = 40,
    STANDARD_SERVER_V = 36,
    STANDARD_SERVER_SOLUTIONS = 52,
    STANDARD_SERVER_SOLUTIONS_CORE = 53,
    STARTER = 11,
    STARTER_E = 66,
    STARTER_N = 47,
    STORAGE_ENTERPRISE_SERVER = 23,
    STORAGE_ENTERPRISE_SERVER_CORE = 46,
    STORAGE_EXPRESS_SERVER = 20,
    STORAGE_EXPRESS_SERVER_CORE = 43,
    STORAGE_STANDARD_EVALUATION_SERVER = 96,
    STORAGE_STANDARD_SERVER = 21,
    STORAGE_STANDARD_SERVER_CORE = 44,
    STORAGE_WORKGROUP_EVALUATION_SERVER = 95,
    STORAGE_WORKGROUP_SERVER = 22,
    STORAGE_WORKGROUP_SERVER_CORE = 45,
    ULTIMATE = 1,
    ULTIMATE_E = 71,
    ULTIMATE_N = 28,
    UNDEFINED = 0,
    WEB_SERVER = 17,
    WEB_SERVER_CORE = 29,
};
pub const PRODUCT_BUSINESS = OS_PRODUCT_TYPE.BUSINESS;
pub const PRODUCT_BUSINESS_N = OS_PRODUCT_TYPE.BUSINESS_N;
pub const PRODUCT_CLUSTER_SERVER = OS_PRODUCT_TYPE.CLUSTER_SERVER;
pub const PRODUCT_CLUSTER_SERVER_V = OS_PRODUCT_TYPE.CLUSTER_SERVER_V;
pub const PRODUCT_CORE = OS_PRODUCT_TYPE.CORE;
pub const PRODUCT_CORE_COUNTRYSPECIFIC = OS_PRODUCT_TYPE.CORE_COUNTRYSPECIFIC;
pub const PRODUCT_CORE_N = OS_PRODUCT_TYPE.CORE_N;
pub const PRODUCT_CORE_SINGLELANGUAGE = OS_PRODUCT_TYPE.CORE_SINGLELANGUAGE;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER = OS_PRODUCT_TYPE.DATACENTER_EVALUATION_SERVER;
pub const PRODUCT_DATACENTER_A_SERVER_CORE = OS_PRODUCT_TYPE.DATACENTER_A_SERVER_CORE;
pub const PRODUCT_STANDARD_A_SERVER_CORE = OS_PRODUCT_TYPE.STANDARD_A_SERVER_CORE;
pub const PRODUCT_DATACENTER_SERVER = OS_PRODUCT_TYPE.DATACENTER_SERVER;
pub const PRODUCT_DATACENTER_SERVER_CORE = OS_PRODUCT_TYPE.DATACENTER_SERVER_CORE;
pub const PRODUCT_DATACENTER_SERVER_CORE_V = OS_PRODUCT_TYPE.DATACENTER_SERVER_CORE_V;
pub const PRODUCT_DATACENTER_SERVER_V = OS_PRODUCT_TYPE.DATACENTER_SERVER_V;
pub const PRODUCT_EDUCATION = OS_PRODUCT_TYPE.EDUCATION;
pub const PRODUCT_EDUCATION_N = OS_PRODUCT_TYPE.EDUCATION_N;
pub const PRODUCT_ENTERPRISE = OS_PRODUCT_TYPE.ENTERPRISE;
pub const PRODUCT_ENTERPRISE_E = OS_PRODUCT_TYPE.ENTERPRISE_E;
pub const PRODUCT_ENTERPRISE_EVALUATION = OS_PRODUCT_TYPE.ENTERPRISE_EVALUATION;
pub const PRODUCT_ENTERPRISE_N = OS_PRODUCT_TYPE.ENTERPRISE_N;
pub const PRODUCT_ENTERPRISE_N_EVALUATION = OS_PRODUCT_TYPE.ENTERPRISE_N_EVALUATION;
pub const PRODUCT_ENTERPRISE_S = OS_PRODUCT_TYPE.ENTERPRISE_S;
pub const PRODUCT_ENTERPRISE_S_EVALUATION = OS_PRODUCT_TYPE.ENTERPRISE_S_EVALUATION;
pub const PRODUCT_ENTERPRISE_S_N = OS_PRODUCT_TYPE.ENTERPRISE_S_N;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION = OS_PRODUCT_TYPE.ENTERPRISE_S_N_EVALUATION;
pub const PRODUCT_ENTERPRISE_SERVER = OS_PRODUCT_TYPE.ENTERPRISE_SERVER;
pub const PRODUCT_ENTERPRISE_SERVER_CORE = OS_PRODUCT_TYPE.ENTERPRISE_SERVER_CORE;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V = OS_PRODUCT_TYPE.ENTERPRISE_SERVER_CORE_V;
pub const PRODUCT_ENTERPRISE_SERVER_IA64 = OS_PRODUCT_TYPE.ENTERPRISE_SERVER_IA64;
pub const PRODUCT_ENTERPRISE_SERVER_V = OS_PRODUCT_TYPE.ENTERPRISE_SERVER_V;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL = OS_PRODUCT_TYPE.ESSENTIALBUSINESS_SERVER_ADDL;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC = OS_PRODUCT_TYPE.ESSENTIALBUSINESS_SERVER_ADDLSVC;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT = OS_PRODUCT_TYPE.ESSENTIALBUSINESS_SERVER_MGMT;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC = OS_PRODUCT_TYPE.ESSENTIALBUSINESS_SERVER_MGMTSVC;
pub const PRODUCT_HOME_BASIC = OS_PRODUCT_TYPE.HOME_BASIC;
pub const PRODUCT_HOME_BASIC_E = OS_PRODUCT_TYPE.HOME_BASIC_E;
pub const PRODUCT_HOME_BASIC_N = OS_PRODUCT_TYPE.HOME_BASIC_N;
pub const PRODUCT_HOME_PREMIUM = OS_PRODUCT_TYPE.HOME_PREMIUM;
pub const PRODUCT_HOME_PREMIUM_E = OS_PRODUCT_TYPE.HOME_PREMIUM_E;
pub const PRODUCT_HOME_PREMIUM_N = OS_PRODUCT_TYPE.HOME_PREMIUM_N;
pub const PRODUCT_HOME_PREMIUM_SERVER = OS_PRODUCT_TYPE.HOME_PREMIUM_SERVER;
pub const PRODUCT_HOME_SERVER = OS_PRODUCT_TYPE.HOME_SERVER;
pub const PRODUCT_HYPERV = OS_PRODUCT_TYPE.HYPERV;
pub const PRODUCT_IOTUAP = OS_PRODUCT_TYPE.IOTUAP;
pub const PRODUCT_IOTUAPCOMMERCIAL = OS_PRODUCT_TYPE.IOTUAPCOMMERCIAL;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT = OS_PRODUCT_TYPE.MEDIUMBUSINESS_SERVER_MANAGEMENT;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING = OS_PRODUCT_TYPE.MEDIUMBUSINESS_SERVER_MESSAGING;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY = OS_PRODUCT_TYPE.MEDIUMBUSINESS_SERVER_SECURITY;
pub const PRODUCT_MOBILE_CORE = OS_PRODUCT_TYPE.MOBILE_CORE;
pub const PRODUCT_MOBILE_ENTERPRISE = OS_PRODUCT_TYPE.MOBILE_ENTERPRISE;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER = OS_PRODUCT_TYPE.MULTIPOINT_PREMIUM_SERVER;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER = OS_PRODUCT_TYPE.MULTIPOINT_STANDARD_SERVER;
pub const PRODUCT_PRO_WORKSTATION = OS_PRODUCT_TYPE.PRO_WORKSTATION;
pub const PRODUCT_PRO_WORKSTATION_N = OS_PRODUCT_TYPE.PRO_WORKSTATION_N;
pub const PRODUCT_PROFESSIONAL = OS_PRODUCT_TYPE.PROFESSIONAL;
pub const PRODUCT_PROFESSIONAL_E = OS_PRODUCT_TYPE.PROFESSIONAL_E;
pub const PRODUCT_PROFESSIONAL_N = OS_PRODUCT_TYPE.PROFESSIONAL_N;
pub const PRODUCT_PROFESSIONAL_WMC = OS_PRODUCT_TYPE.PROFESSIONAL_WMC;
pub const PRODUCT_SB_SOLUTION_SERVER = OS_PRODUCT_TYPE.SB_SOLUTION_SERVER;
pub const PRODUCT_SB_SOLUTION_SERVER_EM = OS_PRODUCT_TYPE.SB_SOLUTION_SERVER_EM;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS = OS_PRODUCT_TYPE.SERVER_FOR_SB_SOLUTIONS;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM = OS_PRODUCT_TYPE.SERVER_FOR_SB_SOLUTIONS_EM;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS = OS_PRODUCT_TYPE.SERVER_FOR_SMALLBUSINESS;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V = OS_PRODUCT_TYPE.SERVER_FOR_SMALLBUSINESS_V;
pub const PRODUCT_SERVER_FOUNDATION = OS_PRODUCT_TYPE.SERVER_FOUNDATION;
pub const PRODUCT_SMALLBUSINESS_SERVER = OS_PRODUCT_TYPE.SMALLBUSINESS_SERVER;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM = OS_PRODUCT_TYPE.SMALLBUSINESS_SERVER_PREMIUM;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE = OS_PRODUCT_TYPE.SMALLBUSINESS_SERVER_PREMIUM_CORE;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER = OS_PRODUCT_TYPE.SOLUTION_EMBEDDEDSERVER;
pub const PRODUCT_STANDARD_EVALUATION_SERVER = OS_PRODUCT_TYPE.STANDARD_EVALUATION_SERVER;
pub const PRODUCT_STANDARD_SERVER = OS_PRODUCT_TYPE.STANDARD_SERVER;
pub const PRODUCT_STANDARD_SERVER_CORE_ = OS_PRODUCT_TYPE.STANDARD_SERVER_CORE_;
pub const PRODUCT_STANDARD_SERVER_CORE_V = OS_PRODUCT_TYPE.STANDARD_SERVER_CORE_V;
pub const PRODUCT_STANDARD_SERVER_V = OS_PRODUCT_TYPE.STANDARD_SERVER_V;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS = OS_PRODUCT_TYPE.STANDARD_SERVER_SOLUTIONS;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE = OS_PRODUCT_TYPE.STANDARD_SERVER_SOLUTIONS_CORE;
pub const PRODUCT_STARTER = OS_PRODUCT_TYPE.STARTER;
pub const PRODUCT_STARTER_E = OS_PRODUCT_TYPE.STARTER_E;
pub const PRODUCT_STARTER_N = OS_PRODUCT_TYPE.STARTER_N;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER = OS_PRODUCT_TYPE.STORAGE_ENTERPRISE_SERVER;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE = OS_PRODUCT_TYPE.STORAGE_ENTERPRISE_SERVER_CORE;
pub const PRODUCT_STORAGE_EXPRESS_SERVER = OS_PRODUCT_TYPE.STORAGE_EXPRESS_SERVER;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE = OS_PRODUCT_TYPE.STORAGE_EXPRESS_SERVER_CORE;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER = OS_PRODUCT_TYPE.STORAGE_STANDARD_EVALUATION_SERVER;
pub const PRODUCT_STORAGE_STANDARD_SERVER = OS_PRODUCT_TYPE.STORAGE_STANDARD_SERVER;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE = OS_PRODUCT_TYPE.STORAGE_STANDARD_SERVER_CORE;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER = OS_PRODUCT_TYPE.STORAGE_WORKGROUP_EVALUATION_SERVER;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER = OS_PRODUCT_TYPE.STORAGE_WORKGROUP_SERVER;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE = OS_PRODUCT_TYPE.STORAGE_WORKGROUP_SERVER_CORE;
pub const PRODUCT_ULTIMATE = OS_PRODUCT_TYPE.ULTIMATE;
pub const PRODUCT_ULTIMATE_E = OS_PRODUCT_TYPE.ULTIMATE_E;
pub const PRODUCT_ULTIMATE_N = OS_PRODUCT_TYPE.ULTIMATE_N;
pub const PRODUCT_UNDEFINED = OS_PRODUCT_TYPE.UNDEFINED;
pub const PRODUCT_WEB_SERVER = OS_PRODUCT_TYPE.WEB_SERVER;
pub const PRODUCT_WEB_SERVER_CORE = OS_PRODUCT_TYPE.WEB_SERVER_CORE;

pub const PROCESSOR_FEATURE_ID = extern enum(u32) {
    ARM_64BIT_LOADSTORE_ATOMIC = 25,
    ARM_DIVIDE_INSTRUCTION_AVAILABLE = 24,
    ARM_EXTERNAL_CACHE_AVAILABLE = 26,
    ARM_FMAC_INSTRUCTIONS_AVAILABLE = 27,
    ARM_VFP_32_REGISTERS_AVAILABLE = 18,
    @"3DNOW_INSTRUCTIONS_AVAILABLE" = 7,
    CHANNELS_ENABLED = 16,
    COMPARE_EXCHANGE_DOUBLE = 2,
    COMPARE_EXCHANGE128 = 14,
    COMPARE64_EXCHANGE128 = 15,
    FASTFAIL_AVAILABLE = 23,
    FLOATING_POINT_EMULATED = 1,
    FLOATING_POINT_PRECISION_ERRATA = 0,
    MMX_INSTRUCTIONS_AVAILABLE = 3,
    NX_ENABLED = 12,
    PAE_ENABLED = 9,
    RDTSC_INSTRUCTION_AVAILABLE = 8,
    RDWRFSGSBASE_AVAILABLE = 22,
    SECOND_LEVEL_ADDRESS_TRANSLATION = 20,
    SSE3_INSTRUCTIONS_AVAILABLE = 13,
    VIRT_FIRMWARE_ENABLED = 21,
    XMMI_INSTRUCTIONS_AVAILABLE = 6,
    XMMI64_INSTRUCTIONS_AVAILABLE = 10,
    XSAVE_ENABLED = 17,
    ARM_V8_INSTRUCTIONS_AVAILABLE = 29,
    ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE = 30,
    ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE = 31,
    ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE = 34,
};
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC = PROCESSOR_FEATURE_ID.ARM_64BIT_LOADSTORE_ATOMIC;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_DIVIDE_INSTRUCTION_AVAILABLE;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_EXTERNAL_CACHE_AVAILABLE;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_FMAC_INSTRUCTIONS_AVAILABLE;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_VFP_32_REGISTERS_AVAILABLE;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.@"3DNOW_INSTRUCTIONS_AVAILABLE";
pub const PF_CHANNELS_ENABLED = PROCESSOR_FEATURE_ID.CHANNELS_ENABLED;
pub const PF_COMPARE_EXCHANGE_DOUBLE = PROCESSOR_FEATURE_ID.COMPARE_EXCHANGE_DOUBLE;
pub const PF_COMPARE_EXCHANGE128 = PROCESSOR_FEATURE_ID.COMPARE_EXCHANGE128;
pub const PF_COMPARE64_EXCHANGE128 = PROCESSOR_FEATURE_ID.COMPARE64_EXCHANGE128;
pub const PF_FASTFAIL_AVAILABLE = PROCESSOR_FEATURE_ID.FASTFAIL_AVAILABLE;
pub const PF_FLOATING_POINT_EMULATED = PROCESSOR_FEATURE_ID.FLOATING_POINT_EMULATED;
pub const PF_FLOATING_POINT_PRECISION_ERRATA = PROCESSOR_FEATURE_ID.FLOATING_POINT_PRECISION_ERRATA;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.MMX_INSTRUCTIONS_AVAILABLE;
pub const PF_NX_ENABLED = PROCESSOR_FEATURE_ID.NX_ENABLED;
pub const PF_PAE_ENABLED = PROCESSOR_FEATURE_ID.PAE_ENABLED;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE = PROCESSOR_FEATURE_ID.RDTSC_INSTRUCTION_AVAILABLE;
pub const PF_RDWRFSGSBASE_AVAILABLE = PROCESSOR_FEATURE_ID.RDWRFSGSBASE_AVAILABLE;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION = PROCESSOR_FEATURE_ID.SECOND_LEVEL_ADDRESS_TRANSLATION;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.SSE3_INSTRUCTIONS_AVAILABLE;
pub const PF_VIRT_FIRMWARE_ENABLED = PROCESSOR_FEATURE_ID.VIRT_FIRMWARE_ENABLED;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.XMMI_INSTRUCTIONS_AVAILABLE;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.XMMI64_INSTRUCTIONS_AVAILABLE;
pub const PF_XSAVE_ENABLED = PROCESSOR_FEATURE_ID.XSAVE_ENABLED;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_V8_INSTRUCTIONS_AVAILABLE;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE = PROCESSOR_FEATURE_ID.ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE;

pub const TDIENTITY_ENTITY_TYPE = extern enum(u32) {
    GENERIC_ENTITY = 0,
    AT_ENTITY = 640,
    CL_NL_ENTITY = 769,
    CO_NL_ENTITY = 768,
    CL_TL_ENTITY = 1025,
    CO_TL_ENTITY = 1024,
    ER_ENTITY = 896,
    IF_ENTITY = 512,
};
pub const GENERIC_ENTITY = TDIENTITY_ENTITY_TYPE.GENERIC_ENTITY;
pub const AT_ENTITY = TDIENTITY_ENTITY_TYPE.AT_ENTITY;
pub const CL_NL_ENTITY = TDIENTITY_ENTITY_TYPE.CL_NL_ENTITY;
pub const CO_NL_ENTITY = TDIENTITY_ENTITY_TYPE.CO_NL_ENTITY;
pub const CL_TL_ENTITY = TDIENTITY_ENTITY_TYPE.CL_TL_ENTITY;
pub const CO_TL_ENTITY = TDIENTITY_ENTITY_TYPE.CO_TL_ENTITY;
pub const ER_ENTITY = TDIENTITY_ENTITY_TYPE.ER_ENTITY;
pub const IF_ENTITY = TDIENTITY_ENTITY_TYPE.IF_ENTITY;

pub const THREAD_INFORMATION_CLASS = extern enum(i32) {
    MemoryPriority = 0,
    AbsoluteCpuPriority = 1,
    DynamicCodePolicy = 2,
    PowerThrottling = 3,
    InformationClassMax = 4,
};
pub const ThreadMemoryPriority = THREAD_INFORMATION_CLASS.MemoryPriority;
pub const ThreadAbsoluteCpuPriority = THREAD_INFORMATION_CLASS.AbsoluteCpuPriority;
pub const ThreadDynamicCodePolicy = THREAD_INFORMATION_CLASS.DynamicCodePolicy;
pub const ThreadPowerThrottling = THREAD_INFORMATION_CLASS.PowerThrottling;
pub const ThreadInformationClassMax = THREAD_INFORMATION_CLASS.InformationClassMax;

pub const SYSTEM_INFO = extern struct {
    Anonymous: _Anonymous_e__Union,
    dwPageSize: u32,
    lpMinimumApplicationAddress: *c_void,
    lpMaximumApplicationAddress: *c_void,
    dwActiveProcessorMask: usize,
    dwNumberOfProcessors: u32,
    dwProcessorType: u32,
    dwAllocationGranularity: u32,
    wProcessorLevel: u16,
    wProcessorRevision: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COMPUTER_NAME_FORMAT = extern enum(i32) {
    NetBIOS = 0,
    DnsHostname = 1,
    DnsDomain = 2,
    DnsFullyQualified = 3,
    PhysicalNetBIOS = 4,
    PhysicalDnsHostname = 5,
    PhysicalDnsDomain = 6,
    PhysicalDnsFullyQualified = 7,
    Max = 8,
};
pub const ComputerNameNetBIOS = COMPUTER_NAME_FORMAT.NetBIOS;
pub const ComputerNameDnsHostname = COMPUTER_NAME_FORMAT.DnsHostname;
pub const ComputerNameDnsDomain = COMPUTER_NAME_FORMAT.DnsDomain;
pub const ComputerNameDnsFullyQualified = COMPUTER_NAME_FORMAT.DnsFullyQualified;
pub const ComputerNamePhysicalNetBIOS = COMPUTER_NAME_FORMAT.PhysicalNetBIOS;
pub const ComputerNamePhysicalDnsHostname = COMPUTER_NAME_FORMAT.PhysicalDnsHostname;
pub const ComputerNamePhysicalDnsDomain = COMPUTER_NAME_FORMAT.PhysicalDnsDomain;
pub const ComputerNamePhysicalDnsFullyQualified = COMPUTER_NAME_FORMAT.PhysicalDnsFullyQualified;
pub const ComputerNameMax = COMPUTER_NAME_FORMAT.Max;

pub const LPFIBER_START_ROUTINE = fn(
    lpFiberParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFIBER_CALLOUT_ROUTINE = fn(
    lpParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const JIT_DEBUG_INFO = extern struct {
    dwSize: u32,
    dwProcessorArchitecture: u32,
    dwThreadID: u32,
    dwReserved0: u32,
    lpExceptionAddress: u64,
    lpExceptionRecord: u64,
    lpContextRecord: u64,
};

pub const DEP_SYSTEM_POLICY_TYPE = extern enum(i32) {
    PolicyAlwaysOff = 0,
    PolicyAlwaysOn = 1,
    PolicyOptIn = 2,
    PolicyOptOut = 3,
    TotalPolicyCount = 4,
};
pub const DEPPolicyAlwaysOff = DEP_SYSTEM_POLICY_TYPE.PolicyAlwaysOff;
pub const DEPPolicyAlwaysOn = DEP_SYSTEM_POLICY_TYPE.PolicyAlwaysOn;
pub const DEPPolicyOptIn = DEP_SYSTEM_POLICY_TYPE.PolicyOptIn;
pub const DEPPolicyOptOut = DEP_SYSTEM_POLICY_TYPE.PolicyOptOut;
pub const DEPTotalPolicyCount = DEP_SYSTEM_POLICY_TYPE.TotalPolicyCount;

pub const PROC_THREAD_ATTRIBUTE_NUM = extern enum(i32) {
    ParentProcess = 0,
    HandleList = 2,
    GroupAffinity = 3,
    PreferredNode = 4,
    IdealProcessor = 5,
    UmsThread = 6,
    MitigationPolicy = 7,
    SecurityCapabilities = 9,
    ProtectionLevel = 11,
    JobList = 13,
    ChildProcessPolicy = 14,
    AllApplicationPackagesPolicy = 15,
    Win32kFilter = 16,
    SafeOpenPromptOriginClaim = 17,
    DesktopAppPolicy = 18,
    PseudoConsole = 22,
};
pub const ProcThreadAttributeParentProcess = PROC_THREAD_ATTRIBUTE_NUM.ParentProcess;
pub const ProcThreadAttributeHandleList = PROC_THREAD_ATTRIBUTE_NUM.HandleList;
pub const ProcThreadAttributeGroupAffinity = PROC_THREAD_ATTRIBUTE_NUM.GroupAffinity;
pub const ProcThreadAttributePreferredNode = PROC_THREAD_ATTRIBUTE_NUM.PreferredNode;
pub const ProcThreadAttributeIdealProcessor = PROC_THREAD_ATTRIBUTE_NUM.IdealProcessor;
pub const ProcThreadAttributeUmsThread = PROC_THREAD_ATTRIBUTE_NUM.UmsThread;
pub const ProcThreadAttributeMitigationPolicy = PROC_THREAD_ATTRIBUTE_NUM.MitigationPolicy;
pub const ProcThreadAttributeSecurityCapabilities = PROC_THREAD_ATTRIBUTE_NUM.SecurityCapabilities;
pub const ProcThreadAttributeProtectionLevel = PROC_THREAD_ATTRIBUTE_NUM.ProtectionLevel;
pub const ProcThreadAttributeJobList = PROC_THREAD_ATTRIBUTE_NUM.JobList;
pub const ProcThreadAttributeChildProcessPolicy = PROC_THREAD_ATTRIBUTE_NUM.ChildProcessPolicy;
pub const ProcThreadAttributeAllApplicationPackagesPolicy = PROC_THREAD_ATTRIBUTE_NUM.AllApplicationPackagesPolicy;
pub const ProcThreadAttributeWin32kFilter = PROC_THREAD_ATTRIBUTE_NUM.Win32kFilter;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim = PROC_THREAD_ATTRIBUTE_NUM.SafeOpenPromptOriginClaim;
pub const ProcThreadAttributeDesktopAppPolicy = PROC_THREAD_ATTRIBUTE_NUM.DesktopAppPolicy;
pub const ProcThreadAttributePseudoConsole = PROC_THREAD_ATTRIBUTE_NUM.PseudoConsole;

pub const PGET_SYSTEM_WOW64_DIRECTORY_A = fn(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PGET_SYSTEM_WOW64_DIRECTORY_W = fn(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const HW_PROFILE_INFOA = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]CHAR,
    szHwProfileName: [80]CHAR,
};

pub const HW_PROFILE_INFOW = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]u16,
    szHwProfileName: [80]u16,
};

pub const TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: SYSTEMTIME,
    DaylightBias: i32,
};

pub const DYNAMIC_TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: SYSTEMTIME,
    DaylightBias: i32,
    TimeZoneKeyName: [128]u16,
    DynamicDaylightTimeDisabled: u8,
};

pub const ACTCTX_SECTION_KEYED_DATA_2600 = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: *c_void,
    ulLength: u32,
    lpSectionGlobalData: *c_void,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: *c_void,
    ulSectionTotalLength: u32,
    hActCtx: HANDLE,
    ulAssemblyRosterIndex: u32,
};

pub const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = extern struct {
    lpInformation: *c_void,
    lpSectionBase: *c_void,
    ulSectionLength: u32,
    lpSectionGlobalDataBase: *c_void,
    ulSectionGlobalDataLength: u32,
};

pub const ACTIVATION_CONTEXT_BASIC_INFORMATION = extern struct {
    hActCtx: HANDLE,
    dwFlags: u32,
};

pub const PQUERYACTCTXW_FUNC = fn(
    dwFlags: u32,
    hActCtx: HANDLE,
    pvSubInstance: ?*c_void,
    ulInfoClass: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?*c_void,
    cbBuffer: usize,
    pcbWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const APPLICATION_RECOVERY_CALLBACK = fn(
    pvParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const FILE_CASE_SENSITIVE_INFO = extern struct {
    Flags: u32,
};

pub const FILE_DISPOSITION_INFO_EX = extern struct {
    Flags: u32,
};

pub const val_context = extern struct {
    valuelen: i32,
    value_context: *c_void,
    val_buff_ptr: *c_void,
};

pub const pvalueA = extern struct {
    pv_valuename: PSTR,
    pv_valuelen: i32,
    pv_value_context: *c_void,
    pv_type: u32,
};

pub const pvalueW = extern struct {
    pv_valuename: PWSTR,
    pv_valuelen: i32,
    pv_value_context: *c_void,
    pv_type: u32,
};

pub const PQUERYHANDLER = fn(
    keycontext: *c_void,
    val_list: *val_context,
    num_vals: u32,
    outputbuffer: *c_void,
    total_outlen: *u32,
    input_blen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const provider_info = extern struct {
    pi_R0_1val: PQUERYHANDLER,
    pi_R0_allvals: PQUERYHANDLER,
    pi_R3_1val: PQUERYHANDLER,
    pi_R3_allvals: PQUERYHANDLER,
    pi_flags: u32,
    pi_key_context: *c_void,
};

pub const VALENTA = extern struct {
    ve_valuename: PSTR,
    ve_valuelen: u32,
    ve_valueptr: usize,
    ve_type: REG_VALUE_TYPE,
};

pub const VALENTW = extern struct {
    ve_valuename: PWSTR,
    ve_valuelen: u32,
    ve_valueptr: usize,
    ve_type: REG_VALUE_TYPE,
};

const CLSID_DOMDocument_Value = @import("../zig.zig").Guid.initString("2933bf90-7b36-11d2-b20e-00c04f983e60");
pub const CLSID_DOMDocument = &CLSID_DOMDocument_Value;

const CLSID_DOMFreeThreadedDocument_Value = @import("../zig.zig").Guid.initString("2933bf91-7b36-11d2-b20e-00c04f983e60");
pub const CLSID_DOMFreeThreadedDocument = &CLSID_DOMFreeThreadedDocument_Value;

const CLSID_XMLHTTPRequest_Value = @import("../zig.zig").Guid.initString("ed8c108e-4349-11d2-91a4-00c04f7969e8");
pub const CLSID_XMLHTTPRequest = &CLSID_XMLHTTPRequest_Value;

const CLSID_XMLDSOControl_Value = @import("../zig.zig").Guid.initString("550dda30-0541-11d2-9ca9-0060b0ec3d39");
pub const CLSID_XMLDSOControl = &CLSID_XMLDSOControl_Value;

const CLSID_XMLDocument_Value = @import("../zig.zig").Guid.initString("cfc399af-d876-11d0-9c10-00c04fc99c8e");
pub const CLSID_XMLDocument = &CLSID_XMLDocument_Value;

pub const XML_ERROR = extern struct {
    _nLine: u32,
    _pchBuf: BSTR,
    _cchBuf: u32,
    _ich: u32,
    _pszFound: BSTR,
    _pszExpected: BSTR,
    _reserved1: u32,
    _reserved2: u32,
};

pub const DOMNodeType = extern enum(i32) {
    INVALID = 0,
    ELEMENT = 1,
    ATTRIBUTE = 2,
    TEXT = 3,
    CDATA_SECTION = 4,
    ENTITY_REFERENCE = 5,
    ENTITY = 6,
    PROCESSING_INSTRUCTION = 7,
    COMMENT = 8,
    DOCUMENT = 9,
    DOCUMENT_TYPE = 10,
    DOCUMENT_FRAGMENT = 11,
    NOTATION = 12,
};
pub const NODE_INVALID = DOMNodeType.INVALID;
pub const NODE_ELEMENT = DOMNodeType.ELEMENT;
pub const NODE_ATTRIBUTE = DOMNodeType.ATTRIBUTE;
pub const NODE_TEXT = DOMNodeType.TEXT;
pub const NODE_CDATA_SECTION = DOMNodeType.CDATA_SECTION;
pub const NODE_ENTITY_REFERENCE = DOMNodeType.ENTITY_REFERENCE;
pub const NODE_ENTITY = DOMNodeType.ENTITY;
pub const NODE_PROCESSING_INSTRUCTION = DOMNodeType.PROCESSING_INSTRUCTION;
pub const NODE_COMMENT = DOMNodeType.COMMENT;
pub const NODE_DOCUMENT = DOMNodeType.DOCUMENT;
pub const NODE_DOCUMENT_TYPE = DOMNodeType.DOCUMENT_TYPE;
pub const NODE_DOCUMENT_FRAGMENT = DOMNodeType.DOCUMENT_FRAGMENT;
pub const NODE_NOTATION = DOMNodeType.NOTATION;

pub const XMLEMEM_TYPE = extern enum(i32) {
    ELEMENT = 0,
    TEXT = 1,
    COMMENT = 2,
    DOCUMENT = 3,
    DTD = 4,
    PI = 5,
    OTHER = 6,
};
pub const XMLELEMTYPE_ELEMENT = XMLEMEM_TYPE.ELEMENT;
pub const XMLELEMTYPE_TEXT = XMLEMEM_TYPE.TEXT;
pub const XMLELEMTYPE_COMMENT = XMLEMEM_TYPE.COMMENT;
pub const XMLELEMTYPE_DOCUMENT = XMLEMEM_TYPE.DOCUMENT;
pub const XMLELEMTYPE_DTD = XMLEMEM_TYPE.DTD;
pub const XMLELEMTYPE_PI = XMLEMEM_TYPE.PI;
pub const XMLELEMTYPE_OTHER = XMLEMEM_TYPE.OTHER;

const IID_IXMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("2933bf8f-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMImplementation = &IID_IXMLDOMImplementation_Value;
pub const IXMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        hasFeature: fn(
            self: *const IXMLDOMImplementation,
            feature: BSTR,
            version: BSTR,
            hasFeature: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMImplementation_hasFeature(self: *const T, feature: BSTR, version: BSTR, hasFeature: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMImplementation.VTable, self.vtable).hasFeature(@ptrCast(*const IXMLDOMImplementation, self), feature, version, hasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNode_Value = @import("../zig.zig").Guid.initString("2933bf80-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNode = &IID_IXMLDOMNode_Value;
pub const IXMLDOMNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: fn(
            self: *const IXMLDOMNode,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: fn(
            self: *const IXMLDOMNode,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: fn(
            self: *const IXMLDOMNode,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeType: fn(
            self: *const IXMLDOMNode,
            type: *DOMNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentNode: fn(
            self: *const IXMLDOMNode,
            parent: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: fn(
            self: *const IXMLDOMNode,
            childList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: fn(
            self: *const IXMLDOMNode,
            firstChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: fn(
            self: *const IXMLDOMNode,
            lastChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousSibling: fn(
            self: *const IXMLDOMNode,
            previousSibling: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextSibling: fn(
            self: *const IXMLDOMNode,
            nextSibling: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const IXMLDOMNode,
            attributeMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            refChild: VARIANT,
            outNewChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            oldChild: *IXMLDOMNode,
            outOldChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLDOMNode,
            childNode: *IXMLDOMNode,
            oldChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            outNewChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IXMLDOMNode,
            hasChild: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerDocument: fn(
            self: *const IXMLDOMNode,
            XMLDOMDocument: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IXMLDOMNode,
            deep: i16,
            cloneRoot: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeTypeString: fn(
            self: *const IXMLDOMNode,
            nodeType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IXMLDOMNode,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IXMLDOMNode,
            text: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_specified: fn(
            self: *const IXMLDOMNode,
            isSpecified: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_definition: fn(
            self: *const IXMLDOMNode,
            definitionNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeTypedValue: fn(
            self: *const IXMLDOMNode,
            typedValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeTypedValue: fn(
            self: *const IXMLDOMNode,
            typedValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataType: fn(
            self: *const IXMLDOMNode,
            dataTypeName: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataType: fn(
            self: *const IXMLDOMNode,
            dataTypeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xml: fn(
            self: *const IXMLDOMNode,
            xmlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transformNode: fn(
            self: *const IXMLDOMNode,
            stylesheet: *IXMLDOMNode,
            xmlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNodes: fn(
            self: *const IXMLDOMNode,
            queryString: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectSingleNode: fn(
            self: *const IXMLDOMNode,
            queryString: BSTR,
            resultNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parsed: fn(
            self: *const IXMLDOMNode,
            isParsed: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: fn(
            self: *const IXMLDOMNode,
            namespaceURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prefix: fn(
            self: *const IXMLDOMNode,
            prefixString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseName: fn(
            self: *const IXMLDOMNode,
            nameString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transformNodeToObject: fn(
            self: *const IXMLDOMNode,
            stylesheet: *IXMLDOMNode,
            outputObject: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeName(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeName(@ptrCast(*const IXMLDOMNode, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeValue(self: *const T, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeValue(@ptrCast(*const IXMLDOMNode, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeValue(self: *const T, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_nodeValue(@ptrCast(*const IXMLDOMNode, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeType(self: *const T, type: *DOMNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeType(@ptrCast(*const IXMLDOMNode, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parentNode(self: *const T, parent: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_parentNode(@ptrCast(*const IXMLDOMNode, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_childNodes(self: *const T, childList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_childNodes(@ptrCast(*const IXMLDOMNode, self), childList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_firstChild(self: *const T, firstChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_firstChild(@ptrCast(*const IXMLDOMNode, self), firstChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_lastChild(self: *const T, lastChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_lastChild(@ptrCast(*const IXMLDOMNode, self), lastChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_previousSibling(self: *const T, previousSibling: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_previousSibling(@ptrCast(*const IXMLDOMNode, self), previousSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nextSibling(self: *const T, nextSibling: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nextSibling(@ptrCast(*const IXMLDOMNode, self), nextSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_attributes(self: *const T, attributeMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_attributes(@ptrCast(*const IXMLDOMNode, self), attributeMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_insertBefore(self: *const T, newChild: *IXMLDOMNode, refChild: VARIANT, outNewChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).insertBefore(@ptrCast(*const IXMLDOMNode, self), newChild, refChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_replaceChild(self: *const T, newChild: *IXMLDOMNode, oldChild: *IXMLDOMNode, outOldChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).replaceChild(@ptrCast(*const IXMLDOMNode, self), newChild, oldChild, outOldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_removeChild(self: *const T, childNode: *IXMLDOMNode, oldChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).removeChild(@ptrCast(*const IXMLDOMNode, self), childNode, oldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_appendChild(self: *const T, newChild: *IXMLDOMNode, outNewChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).appendChild(@ptrCast(*const IXMLDOMNode, self), newChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_hasChildNodes(self: *const T, hasChild: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).hasChildNodes(@ptrCast(*const IXMLDOMNode, self), hasChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_ownerDocument(self: *const T, XMLDOMDocument: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IXMLDOMNode, self), XMLDOMDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_cloneNode(self: *const T, deep: i16, cloneRoot: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).cloneNode(@ptrCast(*const IXMLDOMNode, self), deep, cloneRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypeString(self: *const T, nodeType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeTypeString(@ptrCast(*const IXMLDOMNode, self), nodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_text(self: *const T, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_text(@ptrCast(*const IXMLDOMNode, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_text(self: *const T, text: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_text(@ptrCast(*const IXMLDOMNode, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_specified(self: *const T, isSpecified: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_specified(@ptrCast(*const IXMLDOMNode, self), isSpecified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_definition(self: *const T, definitionNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_definition(@ptrCast(*const IXMLDOMNode, self), definitionNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypedValue(self: *const T, typedValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeTypedValue(@ptrCast(*const IXMLDOMNode, self), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeTypedValue(self: *const T, typedValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_nodeTypedValue(@ptrCast(*const IXMLDOMNode, self), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_dataType(self: *const T, dataTypeName: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_dataType(@ptrCast(*const IXMLDOMNode, self), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_dataType(self: *const T, dataTypeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_dataType(@ptrCast(*const IXMLDOMNode, self), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_xml(self: *const T, xmlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_xml(@ptrCast(*const IXMLDOMNode, self), xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNode(self: *const T, stylesheet: *IXMLDOMNode, xmlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).transformNode(@ptrCast(*const IXMLDOMNode, self), stylesheet, xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectNodes(self: *const T, queryString: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).selectNodes(@ptrCast(*const IXMLDOMNode, self), queryString, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectSingleNode(self: *const T, queryString: BSTR, resultNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).selectSingleNode(@ptrCast(*const IXMLDOMNode, self), queryString, resultNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parsed(self: *const T, isParsed: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_parsed(@ptrCast(*const IXMLDOMNode, self), isParsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_namespaceURI(self: *const T, namespaceURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IXMLDOMNode, self), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_prefix(self: *const T, prefixString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_prefix(@ptrCast(*const IXMLDOMNode, self), prefixString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_baseName(self: *const T, nameString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_baseName(@ptrCast(*const IXMLDOMNode, self), nameString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNodeToObject(self: *const T, stylesheet: *IXMLDOMNode, outputObject: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).transformNodeToObject(@ptrCast(*const IXMLDOMNode, self), stylesheet, outputObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentFragment_Value = @import("../zig.zig").Guid.initString("3efaa413-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMDocumentFragment = &IID_IXMLDOMDocumentFragment_Value;
pub const IXMLDOMDocumentFragment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocument_Value = @import("../zig.zig").Guid.initString("2933bf81-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument = &IID_IXMLDOMDocument_Value;
pub const IXMLDOMDocument = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: fn(
            self: *const IXMLDOMDocument,
            documentType: **IXMLDOMDocumentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_implementation: fn(
            self: *const IXMLDOMDocument,
            impl: **IXMLDOMImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_documentElement: fn(
            self: *const IXMLDOMDocument,
            DOMElement: **IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_documentElement: fn(
            self: *const IXMLDOMDocument,
            DOMElement: *IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDOMDocument,
            tagName: BSTR,
            element: **IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFragment: fn(
            self: *const IXMLDOMDocument,
            docFrag: **IXMLDOMDocumentFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextNode: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            text: **IXMLDOMText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createComment: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            comment: **IXMLDOMComment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCDATASection: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            cdata: **IXMLDOMCDATASection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createProcessingInstruction: fn(
            self: *const IXMLDOMDocument,
            target: BSTR,
            data: BSTR,
            pi: **IXMLDOMProcessingInstruction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IXMLDOMDocument,
            name: BSTR,
            attribute: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEntityReference: fn(
            self: *const IXMLDOMDocument,
            name: BSTR,
            entityRef: **IXMLDOMEntityReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IXMLDOMDocument,
            tagName: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createNode: fn(
            self: *const IXMLDOMDocument,
            Type: VARIANT,
            name: BSTR,
            namespaceURI: BSTR,
            node: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nodeFromID: fn(
            self: *const IXMLDOMDocument,
            idString: BSTR,
            node: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        load: fn(
            self: *const IXMLDOMDocument,
            xmlSource: VARIANT,
            isSuccessful: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLDOMDocument,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parseError: fn(
            self: *const IXMLDOMDocument,
            errorObj: **IXMLDOMParseError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IXMLDOMDocument,
            urlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_async: fn(
            self: *const IXMLDOMDocument,
            isAsync: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_async: fn(
            self: *const IXMLDOMDocument,
            isAsync: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        loadXML: fn(
            self: *const IXMLDOMDocument,
            bstrXML: BSTR,
            isSuccessful: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        save: fn(
            self: *const IXMLDOMDocument,
            destination: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_validateOnParse: fn(
            self: *const IXMLDOMDocument,
            isValidating: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_validateOnParse: fn(
            self: *const IXMLDOMDocument,
            isValidating: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_resolveExternals: fn(
            self: *const IXMLDOMDocument,
            isResolving: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_resolveExternals: fn(
            self: *const IXMLDOMDocument,
            isResolving: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_preserveWhiteSpace: fn(
            self: *const IXMLDOMDocument,
            isPreserving: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_preserveWhiteSpace: fn(
            self: *const IXMLDOMDocument,
            isPreserving: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IXMLDOMDocument,
            readystatechangeSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondataavailable: fn(
            self: *const IXMLDOMDocument,
            ondataavailableSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontransformnode: fn(
            self: *const IXMLDOMDocument,
            ontransformnodeSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_doctype(self: *const T, documentType: **IXMLDOMDocumentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDOMDocument, self), documentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_implementation(self: *const T, impl: **IXMLDOMImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_implementation(@ptrCast(*const IXMLDOMDocument, self), impl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_documentElement(self: *const T, DOMElement: **IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_documentElement(@ptrCast(*const IXMLDOMDocument, self), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_putref_documentElement(self: *const T, DOMElement: *IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).putref_documentElement(@ptrCast(*const IXMLDOMDocument, self), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createElement(self: *const T, tagName: BSTR, element: **IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createElement(@ptrCast(*const IXMLDOMDocument, self), tagName, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createDocumentFragment(self: *const T, docFrag: **IXMLDOMDocumentFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createDocumentFragment(@ptrCast(*const IXMLDOMDocument, self), docFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createTextNode(self: *const T, data: BSTR, text: **IXMLDOMText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createTextNode(@ptrCast(*const IXMLDOMDocument, self), data, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createComment(self: *const T, data: BSTR, comment: **IXMLDOMComment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createComment(@ptrCast(*const IXMLDOMDocument, self), data, comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createCDATASection(self: *const T, data: BSTR, cdata: **IXMLDOMCDATASection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createCDATASection(@ptrCast(*const IXMLDOMDocument, self), data, cdata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createProcessingInstruction(self: *const T, target: BSTR, data: BSTR, pi: **IXMLDOMProcessingInstruction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createProcessingInstruction(@ptrCast(*const IXMLDOMDocument, self), target, data, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createAttribute(self: *const T, name: BSTR, attribute: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createAttribute(@ptrCast(*const IXMLDOMDocument, self), name, attribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createEntityReference(self: *const T, name: BSTR, entityRef: **IXMLDOMEntityReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createEntityReference(@ptrCast(*const IXMLDOMDocument, self), name, entityRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_getElementsByTagName(self: *const T, tagName: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IXMLDOMDocument, self), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createNode(self: *const T, Type: VARIANT, name: BSTR, namespaceURI: BSTR, node: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createNode(@ptrCast(*const IXMLDOMDocument, self), Type, name, namespaceURI, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_nodeFromID(self: *const T, idString: BSTR, node: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).nodeFromID(@ptrCast(*const IXMLDOMDocument, self), idString, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_load(self: *const T, xmlSource: VARIANT, isSuccessful: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).load(@ptrCast(*const IXMLDOMDocument, self), xmlSource, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_readyState(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDOMDocument, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_parseError(self: *const T, errorObj: **IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_parseError(@ptrCast(*const IXMLDOMDocument, self), errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_url(self: *const T, urlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_url(@ptrCast(*const IXMLDOMDocument, self), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_async(self: *const T, isAsync: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_async(@ptrCast(*const IXMLDOMDocument, self), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_async(self: *const T, isAsync: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_async(@ptrCast(*const IXMLDOMDocument, self), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).abort(@ptrCast(*const IXMLDOMDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_loadXML(self: *const T, bstrXML: BSTR, isSuccessful: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).loadXML(@ptrCast(*const IXMLDOMDocument, self), bstrXML, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_save(self: *const T, destination: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).save(@ptrCast(*const IXMLDOMDocument, self), destination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_validateOnParse(self: *const T, isValidating: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_validateOnParse(@ptrCast(*const IXMLDOMDocument, self), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_validateOnParse(self: *const T, isValidating: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_validateOnParse(@ptrCast(*const IXMLDOMDocument, self), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_resolveExternals(self: *const T, isResolving: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_resolveExternals(@ptrCast(*const IXMLDOMDocument, self), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_resolveExternals(self: *const T, isResolving: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_resolveExternals(@ptrCast(*const IXMLDOMDocument, self), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_preserveWhiteSpace(self: *const T, isPreserving: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_preserveWhiteSpace(@ptrCast(*const IXMLDOMDocument, self), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_preserveWhiteSpace(self: *const T, isPreserving: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_preserveWhiteSpace(@ptrCast(*const IXMLDOMDocument, self), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_onreadystatechange(self: *const T, readystatechangeSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IXMLDOMDocument, self), readystatechangeSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ondataavailable(self: *const T, ondataavailableSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IXMLDOMDocument, self), ondataavailableSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ontransformnode(self: *const T, ontransformnodeSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_ontransformnode(@ptrCast(*const IXMLDOMDocument, self), ontransformnodeSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNodeList_Value = @import("../zig.zig").Guid.initString("2933bf82-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNodeList = &IID_IXMLDOMNodeList_Value;
pub const IXMLDOMNodeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const IXMLDOMNodeList,
            index: i32,
            listItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLDOMNodeList,
            listLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IXMLDOMNodeList,
            nextItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IXMLDOMNodeList,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_item(self: *const T, index: i32, listItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get_item(@ptrCast(*const IXMLDOMNodeList, self), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_length(self: *const T, listLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMNodeList, self), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_nextNode(self: *const T, nextItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).nextNode(@ptrCast(*const IXMLDOMNodeList, self), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).reset(@ptrCast(*const IXMLDOMNodeList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMNodeList, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNamedNodeMap_Value = @import("../zig.zig").Guid.initString("2933bf83-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNamedNodeMap = &IID_IXMLDOMNamedNodeMap_Value;
pub const IXMLDOMNamedNodeMap = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            name: BSTR,
            namedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            newItem: *IXMLDOMNode,
            nameItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            name: BSTR,
            namedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const IXMLDOMNamedNodeMap,
            index: i32,
            listItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLDOMNamedNodeMap,
            listLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getQualifiedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            baseName: BSTR,
            namespaceURI: BSTR,
            qualifiedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeQualifiedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            baseName: BSTR,
            namespaceURI: BSTR,
            qualifiedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IXMLDOMNamedNodeMap,
            nextItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IXMLDOMNamedNodeMap,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getNamedItem(self: *const T, name: BSTR, namedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).getNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_setNamedItem(self: *const T, newItem: *IXMLDOMNode, nameItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).setNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), newItem, nameItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeNamedItem(self: *const T, name: BSTR, namedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).removeNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_item(self: *const T, index: i32, listItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get_item(@ptrCast(*const IXMLDOMNamedNodeMap, self), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_length(self: *const T, listLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMNamedNodeMap, self), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getQualifiedItem(self: *const T, baseName: BSTR, namespaceURI: BSTR, qualifiedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).getQualifiedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeQualifiedItem(self: *const T, baseName: BSTR, namespaceURI: BSTR, qualifiedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).removeQualifiedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_nextNode(self: *const T, nextItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).nextNode(@ptrCast(*const IXMLDOMNamedNodeMap, self), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).reset(@ptrCast(*const IXMLDOMNamedNodeMap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMNamedNodeMap, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCharacterData_Value = @import("../zig.zig").Guid.initString("2933bf84-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMCharacterData = &IID_IXMLDOMCharacterData_Value;
pub const IXMLDOMCharacterData = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IXMLDOMCharacterData,
            data: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IXMLDOMCharacterData,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLDOMCharacterData,
            dataLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        substringData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
            data: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IXMLDOMCharacterData,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_data(self: *const T, data: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).get_data(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_put_data(self: *const T, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).put_data(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_length(self: *const T, dataLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMCharacterData, self), dataLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_substringData(self: *const T, offset: i32, count: i32, data: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).substringData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_appendData(self: *const T, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).appendData(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_insertData(self: *const T, offset: i32, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).insertData(@ptrCast(*const IXMLDOMCharacterData, self), offset, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_deleteData(self: *const T, offset: i32, count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).deleteData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_replaceData(self: *const T, offset: i32, count: i32, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).replaceData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count, data);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("2933bf85-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMAttribute = &IID_IXMLDOMAttribute_Value;
pub const IXMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IXMLDOMAttribute,
            attributeName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IXMLDOMAttribute,
            attributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: fn(
            self: *const IXMLDOMAttribute,
            attributeValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_name(self: *const T, attributeName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).get_name(@ptrCast(*const IXMLDOMAttribute, self), attributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_value(self: *const T, attributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).get_value(@ptrCast(*const IXMLDOMAttribute, self), attributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_put_value(self: *const T, attributeValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).put_value(@ptrCast(*const IXMLDOMAttribute, self), attributeValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMElement_Value = @import("../zig.zig").Guid.initString("2933bf86-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMElement = &IID_IXMLDOMElement_Value;
pub const IXMLDOMElement = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: fn(
            self: *const IXMLDOMElement,
            tagName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IXMLDOMElement,
            DOMAttribute: *IXMLDOMAttribute,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IXMLDOMElement,
            DOMAttribute: *IXMLDOMAttribute,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IXMLDOMElement,
            tagName: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_get_tagName(self: *const T, tagName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLDOMElement, self), tagName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttribute(self: *const T, name: BSTR, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLDOMElement, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttribute(self: *const T, name: BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLDOMElement, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttribute(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLDOMElement, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttributeNode(self: *const T, name: BSTR, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getAttributeNode(@ptrCast(*const IXMLDOMElement, self), name, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttributeNode(self: *const T, DOMAttribute: *IXMLDOMAttribute, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).setAttributeNode(@ptrCast(*const IXMLDOMElement, self), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttributeNode(self: *const T, DOMAttribute: *IXMLDOMAttribute, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IXMLDOMElement, self), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getElementsByTagName(self: *const T, tagName: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IXMLDOMElement, self), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).normalize(@ptrCast(*const IXMLDOMElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMText_Value = @import("../zig.zig").Guid.initString("2933bf87-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMText = &IID_IXMLDOMText_Value;
pub const IXMLDOMText = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
        splitText: fn(
            self: *const IXMLDOMText,
            offset: i32,
            rightHandTextNode: **IXMLDOMText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMText_splitText(self: *const T, offset: i32, rightHandTextNode: **IXMLDOMText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMText.VTable, self.vtable).splitText(@ptrCast(*const IXMLDOMText, self), offset, rightHandTextNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMComment_Value = @import("../zig.zig").Guid.initString("2933bf88-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMComment = &IID_IXMLDOMComment_Value;
pub const IXMLDOMComment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("2933bf89-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMProcessingInstruction = &IID_IXMLDOMProcessingInstruction_Value;
pub const IXMLDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: fn(
            self: *const IXMLDOMProcessingInstruction,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: fn(
            self: *const IXMLDOMProcessingInstruction,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: fn(
            self: *const IXMLDOMProcessingInstruction,
            value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_target(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).get_target(@ptrCast(*const IXMLDOMProcessingInstruction, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_data(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).get_data(@ptrCast(*const IXMLDOMProcessingInstruction, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_put_data(self: *const T, value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).put_data(@ptrCast(*const IXMLDOMProcessingInstruction, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCDATASection_Value = @import("../zig.zig").Guid.initString("2933bf8a-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMCDATASection = &IID_IXMLDOMCDATASection_Value;
pub const IXMLDOMCDATASection = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMText.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMText.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentType_Value = @import("../zig.zig").Guid.initString("2933bf8b-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocumentType = &IID_IXMLDOMDocumentType_Value;
pub const IXMLDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IXMLDOMDocumentType,
            rootName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entities: fn(
            self: *const IXMLDOMDocumentType,
            entityMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notations: fn(
            self: *const IXMLDOMDocumentType,
            notationMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_name(self: *const T, rootName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_name(@ptrCast(*const IXMLDOMDocumentType, self), rootName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_entities(self: *const T, entityMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_entities(@ptrCast(*const IXMLDOMDocumentType, self), entityMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_notations(self: *const T, notationMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_notations(@ptrCast(*const IXMLDOMDocumentType, self), notationMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNotation_Value = @import("../zig.zig").Guid.initString("2933bf8c-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNotation = &IID_IXMLDOMNotation_Value;
pub const IXMLDOMNotation = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: fn(
            self: *const IXMLDOMNotation,
            publicID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: fn(
            self: *const IXMLDOMNotation,
            systemID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_publicId(self: *const T, publicID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNotation.VTable, self.vtable).get_publicId(@ptrCast(*const IXMLDOMNotation, self), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_systemId(self: *const T, systemID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNotation.VTable, self.vtable).get_systemId(@ptrCast(*const IXMLDOMNotation, self), systemID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntity_Value = @import("../zig.zig").Guid.initString("2933bf8d-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMEntity = &IID_IXMLDOMEntity_Value;
pub const IXMLDOMEntity = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: fn(
            self: *const IXMLDOMEntity,
            publicID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: fn(
            self: *const IXMLDOMEntity,
            systemID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notationName: fn(
            self: *const IXMLDOMEntity,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_publicId(self: *const T, publicID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_publicId(@ptrCast(*const IXMLDOMEntity, self), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_systemId(self: *const T, systemID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_systemId(@ptrCast(*const IXMLDOMEntity, self), systemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_notationName(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_notationName(@ptrCast(*const IXMLDOMEntity, self), name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntityReference_Value = @import("../zig.zig").Guid.initString("2933bf8e-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMEntityReference = &IID_IXMLDOMEntityReference_Value;
pub const IXMLDOMEntityReference = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseError_Value = @import("../zig.zig").Guid.initString("3efaa426-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseError = &IID_IXMLDOMParseError_Value;
pub const IXMLDOMParseError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCode: fn(
            self: *const IXMLDOMParseError,
            errorCode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: fn(
            self: *const IXMLDOMParseError,
            urlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_reason: fn(
            self: *const IXMLDOMParseError,
            reasonString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcText: fn(
            self: *const IXMLDOMParseError,
            sourceString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_line: fn(
            self: *const IXMLDOMParseError,
            lineNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_linepos: fn(
            self: *const IXMLDOMParseError,
            linePosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filepos: fn(
            self: *const IXMLDOMParseError,
            filePosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_errorCode(self: *const T, errorCode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_errorCode(@ptrCast(*const IXMLDOMParseError, self), errorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_url(self: *const T, urlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_url(@ptrCast(*const IXMLDOMParseError, self), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_reason(self: *const T, reasonString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_reason(@ptrCast(*const IXMLDOMParseError, self), reasonString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_srcText(self: *const T, sourceString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_srcText(@ptrCast(*const IXMLDOMParseError, self), sourceString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_line(self: *const T, lineNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_line(@ptrCast(*const IXMLDOMParseError, self), lineNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_linepos(self: *const T, linePosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_linepos(@ptrCast(*const IXMLDOMParseError, self), linePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_filepos(self: *const T, filePosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_filepos(@ptrCast(*const IXMLDOMParseError, self), filePosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXTLRuntime_Value = @import("../zig.zig").Guid.initString("3efaa425-272f-11d2-836f-0000f87a7782");
pub const IID_IXTLRuntime = &IID_IXTLRuntime_Value;
pub const IXTLRuntime = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        uniqueID: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        depth: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pDepth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        childNumber: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ancestorChildNumber: fn(
            self: *const IXTLRuntime,
            bstrNodeName: BSTR,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        absoluteChildNumber: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatIndex: fn(
            self: *const IXTLRuntime,
            lIndex: i32,
            bstrFormat: BSTR,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatNumber: fn(
            self: *const IXTLRuntime,
            dblNumber: f64,
            bstrFormat: BSTR,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatDate: fn(
            self: *const IXTLRuntime,
            varDate: VARIANT,
            bstrFormat: BSTR,
            varDestLocale: VARIANT,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatTime: fn(
            self: *const IXTLRuntime,
            varTime: VARIANT,
            bstrFormat: BSTR,
            varDestLocale: VARIANT,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_uniqueID(self: *const T, pNode: *IXMLDOMNode, pID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).uniqueID(@ptrCast(*const IXTLRuntime, self), pNode, pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_depth(self: *const T, pNode: *IXMLDOMNode, pDepth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).depth(@ptrCast(*const IXTLRuntime, self), pNode, pDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_childNumber(self: *const T, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).childNumber(@ptrCast(*const IXTLRuntime, self), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_ancestorChildNumber(self: *const T, bstrNodeName: BSTR, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).ancestorChildNumber(@ptrCast(*const IXTLRuntime, self), bstrNodeName, pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_absoluteChildNumber(self: *const T, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).absoluteChildNumber(@ptrCast(*const IXTLRuntime, self), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatIndex(self: *const T, lIndex: i32, bstrFormat: BSTR, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatIndex(@ptrCast(*const IXTLRuntime, self), lIndex, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatNumber(self: *const T, dblNumber: f64, bstrFormat: BSTR, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatNumber(@ptrCast(*const IXTLRuntime, self), dblNumber, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatDate(self: *const T, varDate: VARIANT, bstrFormat: BSTR, varDestLocale: VARIANT, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatDate(@ptrCast(*const IXTLRuntime, self), varDate, bstrFormat, varDestLocale, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatTime(self: *const T, varTime: VARIANT, bstrFormat: BSTR, varDestLocale: VARIANT, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatTime(@ptrCast(*const IXTLRuntime, self), varTime, bstrFormat, varDestLocale, pbstrFormattedString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_XMLDOMDocumentEvents_Value = @import("../zig.zig").Guid.initString("3efaa427-272f-11d2-836f-0000f87a7782");
pub const IID_XMLDOMDocumentEvents = &IID_XMLDOMDocumentEvents_Value;
pub const XMLDOMDocumentEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("ed8c108d-4349-11d2-91a4-00c04f7969e8");
pub const IID_IXMLHttpRequest = &IID_IXMLHttpRequest_Value;
pub const IXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        open: fn(
            self: *const IXMLHttpRequest,
            bstrMethod: BSTR,
            bstrUrl: BSTR,
            varAsync: VARIANT,
            bstrUser: VARIANT,
            bstrPassword: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRequestHeader: fn(
            self: *const IXMLHttpRequest,
            bstrHeader: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getResponseHeader: fn(
            self: *const IXMLHttpRequest,
            bstrHeader: BSTR,
            pbstrValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllResponseHeaders: fn(
            self: *const IXMLHttpRequest,
            pbstrHeaders: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IXMLHttpRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IXMLHttpRequest,
            plStatus: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_statusText: fn(
            self: *const IXMLHttpRequest,
            pbstrStatus: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseXML: fn(
            self: *const IXMLHttpRequest,
            ppBody: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: fn(
            self: *const IXMLHttpRequest,
            pbstrBody: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseBody: fn(
            self: *const IXMLHttpRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseStream: fn(
            self: *const IXMLHttpRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLHttpRequest,
            plState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IXMLHttpRequest,
            pReadyStateSink: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_open(self: *const T, bstrMethod: BSTR, bstrUrl: BSTR, varAsync: VARIANT, bstrUser: VARIANT, bstrPassword: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).open(@ptrCast(*const IXMLHttpRequest, self), bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_setRequestHeader(self: *const T, bstrHeader: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).setRequestHeader(@ptrCast(*const IXMLHttpRequest, self), bstrHeader, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getResponseHeader(self: *const T, bstrHeader: BSTR, pbstrValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).getResponseHeader(@ptrCast(*const IXMLHttpRequest, self), bstrHeader, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getAllResponseHeaders(self: *const T, pbstrHeaders: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).getAllResponseHeaders(@ptrCast(*const IXMLHttpRequest, self), pbstrHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).send(@ptrCast(*const IXMLHttpRequest, self), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).abort(@ptrCast(*const IXMLHttpRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_status(self: *const T, plStatus: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_status(@ptrCast(*const IXMLHttpRequest, self), plStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_statusText(self: *const T, pbstrStatus: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_statusText(@ptrCast(*const IXMLHttpRequest, self), pbstrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseXML(self: *const T, ppBody: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseXML(@ptrCast(*const IXMLHttpRequest, self), ppBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseText(self: *const T, pbstrBody: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IXMLHttpRequest, self), pbstrBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseBody(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseBody(@ptrCast(*const IXMLHttpRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseStream(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseStream(@ptrCast(*const IXMLHttpRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_readyState(self: *const T, plState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLHttpRequest, self), plState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_put_onreadystatechange(self: *const T, pReadyStateSink: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IXMLHttpRequest, self), pReadyStateSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDSOControl_Value = @import("../zig.zig").Guid.initString("310afa62-0575-11d2-9ca9-0060b0ec3d39");
pub const IID_IXMLDSOControl = &IID_IXMLDSOControl_Value;
pub const IXMLDSOControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLDocument: fn(
            self: *const IXMLDSOControl,
            ppDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XMLDocument: fn(
            self: *const IXMLDSOControl,
            ppDoc: *IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_JavaDSOCompatible: fn(
            self: *const IXMLDSOControl,
            fJavaDSOCompatible: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_JavaDSOCompatible: fn(
            self: *const IXMLDSOControl,
            fJavaDSOCompatible: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLDSOControl,
            state: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_XMLDocument(self: *const T, ppDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_XMLDocument(@ptrCast(*const IXMLDSOControl, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_XMLDocument(self: *const T, ppDoc: *IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).put_XMLDocument(@ptrCast(*const IXMLDSOControl, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_JavaDSOCompatible(@ptrCast(*const IXMLDSOControl, self), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).put_JavaDSOCompatible(@ptrCast(*const IXMLDSOControl, self), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_readyState(self: *const T, state: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDSOControl, self), state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElementCollection_Value = @import("../zig.zig").Guid.initString("65725580-9b5d-11d0-9bfe-00c04fc99c8e");
pub const IID_IXMLElementCollection = &IID_IXMLElementCollection_Value;
pub const IXMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: fn(
            self: *const IXMLElementCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLElementCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IXMLElementCollection,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IXMLElementCollection,
            var1: VARIANT,
            var2: VARIANT,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).put_length(@ptrCast(*const IXMLElementCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).get_length(@ptrCast(*const IXMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLElementCollection, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_item(self: *const T, var1: VARIANT, var2: VARIANT, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).item(@ptrCast(*const IXMLElementCollection, self), var1, var2, ppDisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument_Value = @import("../zig.zig").Guid.initString("f52e2b61-18a1-11d1-b105-00805f49916b");
pub const IID_IXMLDocument = &IID_IXMLDocument_Value;
pub const IXMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: fn(
            self: *const IXMLDocument,
            p: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: fn(
            self: *const IXMLDocument,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLDocument,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IXMLDocument,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdURL: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDocument,
            vType: VARIANT,
            var1: VARIANT,
            ppElem: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_root(self: *const T, p: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_root(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileSize(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_URL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_URL(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).put_URL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_mimeType(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_readyState(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDocument, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_charset(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_charset(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).put_charset(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_version(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_doctype(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_dtdURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_dtdURL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).createElement(@ptrCast(*const IXMLDocument, self), vType, var1, ppElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument2_Value = @import("../zig.zig").Guid.initString("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9");
pub const IID_IXMLDocument2 = &IID_IXMLDocument2_Value;
pub const IXMLDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: fn(
            self: *const IXMLDocument2,
            p: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: fn(
            self: *const IXMLDocument2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLDocument2,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: fn(
            self: *const IXMLDocument2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdURL: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDocument2,
            vType: VARIANT,
            var1: VARIANT,
            ppElem: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_async: fn(
            self: *const IXMLDocument2,
            pf: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_async: fn(
            self: *const IXMLDocument2,
            f: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_root(self: *const T, p: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_root(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileSize(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_URL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_URL(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_URL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_mimeType(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_readyState(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDocument2, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_charset(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_charset(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_charset(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_version(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_doctype(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_dtdURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_dtdURL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).createElement(@ptrCast(*const IXMLDocument2, self), vType, var1, ppElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_async(self: *const T, pf: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_async(@ptrCast(*const IXMLDocument2, self), pf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_async(self: *const T, f: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_async(@ptrCast(*const IXMLDocument2, self), f);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement_Value = @import("../zig.zig").Guid.initString("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e");
pub const IID_IXMLElement = &IID_IXMLElement_Value;
pub const IXMLElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: fn(
            self: *const IXMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tagName: fn(
            self: *const IXMLElement,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: fn(
            self: *const IXMLElement,
            ppParent: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
            PropertyValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
            PropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_children: fn(
            self: *const IXMLElement,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IXMLElement,
            plType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IXMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IXMLElement,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addChild: fn(
            self: *const IXMLElement,
            pChildElem: *IXMLElement,
            lIndex: i32,
            lReserved: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLElement,
            pChildElem: *IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_tagName(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).put_tagName(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_parent(self: *const T, ppParent: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_parent(@ptrCast(*const IXMLElement, self), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_setAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLElement, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_getAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLElement, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeAttribute(self: *const T, strPropertyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLElement, self), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_children(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_children(@ptrCast(*const IXMLElement, self), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_type(self: *const T, plType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_type(@ptrCast(*const IXMLElement, self), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_text(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_text(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).put_text(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_addChild(self: *const T, pChildElem: *IXMLElement, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).addChild(@ptrCast(*const IXMLElement, self), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeChild(self: *const T, pChildElem: *IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).removeChild(@ptrCast(*const IXMLElement, self), pChildElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement2_Value = @import("../zig.zig").Guid.initString("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9");
pub const IID_IXMLElement2 = &IID_IXMLElement2_Value;
pub const IXMLElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: fn(
            self: *const IXMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tagName: fn(
            self: *const IXMLElement2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: fn(
            self: *const IXMLElement2,
            ppParent: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
            PropertyValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
            PropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_children: fn(
            self: *const IXMLElement2,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const IXMLElement2,
            plType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: fn(
            self: *const IXMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: fn(
            self: *const IXMLElement2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addChild: fn(
            self: *const IXMLElement2,
            pChildElem: *IXMLElement2,
            lIndex: i32,
            lReserved: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLElement2,
            pChildElem: *IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const IXMLElement2,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_tagName(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).put_tagName(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_parent(self: *const T, ppParent: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_parent(@ptrCast(*const IXMLElement2, self), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_setAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_getAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeAttribute(self: *const T, strPropertyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_children(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_children(@ptrCast(*const IXMLElement2, self), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_type(self: *const T, plType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_type(@ptrCast(*const IXMLElement2, self), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_text(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_text(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).put_text(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_addChild(self: *const T, pChildElem: *IXMLElement2, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).addChild(@ptrCast(*const IXMLElement2, self), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeChild(self: *const T, pChildElem: *IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).removeChild(@ptrCast(*const IXMLElement2, self), pChildElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_attributes(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_attributes(@ptrCast(*const IXMLElement2, self), pp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLAttribute_Value = @import("../zig.zig").Guid.initString("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596");
pub const IID_IXMLAttribute = &IID_IXMLAttribute_Value;
pub const IXMLAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const IXMLAttribute,
            n: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: fn(
            self: *const IXMLAttribute,
            v: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_name(self: *const T, n: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLAttribute.VTable, self.vtable).get_name(@ptrCast(*const IXMLAttribute, self), n);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_value(self: *const T, v: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLAttribute.VTable, self.vtable).get_value(@ptrCast(*const IXMLAttribute, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLError_Value = @import("../zig.zig").Guid.initString("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e");
pub const IID_IXMLError = &IID_IXMLError_Value;
pub const IXMLError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: fn(
            self: *const IXMLError,
            pErrorReturn: *XML_ERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLError_GetErrorInfo(self: *const T, pErrorReturn: *XML_ERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLError.VTable, self.vtable).GetErrorInfo(@ptrCast(*const IXMLError, self), pErrorReturn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CLIENT_ID = extern struct {
    UniqueProcess: HANDLE,
    UniqueThread: HANDLE,
};

pub const LDR_DATA_TABLE_ENTRY = extern struct {
    Reserved1: [2]*c_void,
    InMemoryOrderLinks: LIST_ENTRY,
    Reserved2: [2]*c_void,
    DllBase: *c_void,
    Reserved3: [2]*c_void,
    FullDllName: UNICODE_STRING,
    Reserved4: [8]u8,
    Reserved5: [3]*c_void,
    Anonymous: _Anonymous_e__Union,
    TimeDateStamp: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PPS_POST_PROCESS_INIT_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OBJECT_ATTRIBUTES = extern struct {
    Length: u32,
    RootDirectory: HANDLE,
    ObjectName: *UNICODE_STRING,
    Attributes: u32,
    SecurityDescriptor: *c_void,
    SecurityQualityOfService: *c_void,
};

pub const IO_STATUS_BLOCK = extern struct {
    Anonymous: _Anonymous_e__Union,
    Information: usize,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PIO_APC_ROUTINE = fn(
    ApcContext: *c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PROCESS_BASIC_INFORMATION = extern struct {
    Reserved1: *c_void,
    PebBaseAddress: *PEB,
    Reserved2: [2]*c_void,
    UniqueProcessId: usize,
    Reserved3: *c_void,
};

pub const SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = extern struct {
    IdleTime: LARGE_INTEGER,
    KernelTime: LARGE_INTEGER,
    UserTime: LARGE_INTEGER,
    Reserved1: [2]LARGE_INTEGER,
    Reserved2: u32,
};

pub const SYSTEM_PROCESS_INFORMATION = extern struct {
    NextEntryOffset: u32,
    NumberOfThreads: u32,
    Reserved1: [48]u8,
    ImageName: UNICODE_STRING,
    BasePriority: i32,
    UniqueProcessId: HANDLE,
    Reserved2: *c_void,
    HandleCount: u32,
    SessionId: u32,
    Reserved3: *c_void,
    PeakVirtualSize: usize,
    VirtualSize: usize,
    Reserved4: u32,
    PeakWorkingSetSize: usize,
    WorkingSetSize: usize,
    Reserved5: *c_void,
    QuotaPagedPoolUsage: usize,
    Reserved6: *c_void,
    QuotaNonPagedPoolUsage: usize,
    PagefileUsage: usize,
    PeakPagefileUsage: usize,
    PrivatePageCount: usize,
    Reserved7: [6]LARGE_INTEGER,
};

pub const SYSTEM_THREAD_INFORMATION = extern struct {
    Reserved1: [3]LARGE_INTEGER,
    Reserved2: u32,
    StartAddress: *c_void,
    ClientId: CLIENT_ID,
    Priority: i32,
    BasePriority: i32,
    Reserved3: u32,
    ThreadState: u32,
    WaitReason: u32,
};

pub const SYSTEM_REGISTRY_QUOTA_INFORMATION = extern struct {
    RegistryQuotaAllowed: u32,
    RegistryQuotaUsed: u32,
    Reserved1: *c_void,
};

pub const SYSTEM_BASIC_INFORMATION = extern struct {
    Reserved1: [24]u8,
    Reserved2: [4]*c_void,
    NumberOfProcessors: i8,
};

pub const SYSTEM_TIMEOFDAY_INFORMATION = extern struct {
    Reserved1: [48]u8,
};

pub const SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    Reserved1: [312]u8,
};

pub const SYSTEM_EXCEPTION_INFORMATION = extern struct {
    Reserved1: [16]u8,
};

pub const SYSTEM_LOOKASIDE_INFORMATION = extern struct {
    Reserved1: [32]u8,
};

pub const SYSTEM_INTERRUPT_INFORMATION = extern struct {
    Reserved1: [24]u8,
};

pub const SYSTEM_POLICY_INFORMATION = extern struct {
    Reserved1: [2]*c_void,
    Reserved2: [3]u32,
};

pub const FILE_INFORMATION_CLASS = extern enum(i32) {
    n = 1,
};
pub const FileDirectoryInformation = FILE_INFORMATION_CLASS.n;

pub const PROCESSINFOCLASS = extern enum(i32) {
    BasicInformation = 0,
    DebugPort = 7,
    Wow64Information = 26,
    ImageFileName = 27,
    BreakOnTermination = 29,
};
pub const ProcessBasicInformation = PROCESSINFOCLASS.BasicInformation;
pub const ProcessDebugPort = PROCESSINFOCLASS.DebugPort;
pub const ProcessWow64Information = PROCESSINFOCLASS.Wow64Information;
pub const ProcessImageFileName = PROCESSINFOCLASS.ImageFileName;
pub const ProcessBreakOnTermination = PROCESSINFOCLASS.BreakOnTermination;

pub const THREADINFOCLASS = extern enum(i32) {
    g = 16,
};
pub const ThreadIsIoPending = THREADINFOCLASS.g;

pub const SYSTEM_CODEINTEGRITY_INFORMATION = extern struct {
    Length: u32,
    CodeIntegrityOptions: u32,
};

pub const SYSTEM_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    PerformanceInformation = 2,
    TimeOfDayInformation = 3,
    ProcessInformation = 5,
    ProcessorPerformanceInformation = 8,
    InterruptInformation = 23,
    ExceptionInformation = 33,
    RegistryQuotaInformation = 37,
    LookasideInformation = 45,
    CodeIntegrityInformation = 103,
    PolicyInformation = 134,
};
pub const SystemBasicInformation = SYSTEM_INFORMATION_CLASS.BasicInformation;
pub const SystemPerformanceInformation = SYSTEM_INFORMATION_CLASS.PerformanceInformation;
pub const SystemTimeOfDayInformation = SYSTEM_INFORMATION_CLASS.TimeOfDayInformation;
pub const SystemProcessInformation = SYSTEM_INFORMATION_CLASS.ProcessInformation;
pub const SystemProcessorPerformanceInformation = SYSTEM_INFORMATION_CLASS.ProcessorPerformanceInformation;
pub const SystemInterruptInformation = SYSTEM_INFORMATION_CLASS.InterruptInformation;
pub const SystemExceptionInformation = SYSTEM_INFORMATION_CLASS.ExceptionInformation;
pub const SystemRegistryQuotaInformation = SYSTEM_INFORMATION_CLASS.RegistryQuotaInformation;
pub const SystemLookasideInformation = SYSTEM_INFORMATION_CLASS.LookasideInformation;
pub const SystemCodeIntegrityInformation = SYSTEM_INFORMATION_CLASS.CodeIntegrityInformation;
pub const SystemPolicyInformation = SYSTEM_INFORMATION_CLASS.PolicyInformation;

pub const OBJECT_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    TypeInformation = 2,
};
pub const ObjectBasicInformation = OBJECT_INFORMATION_CLASS.BasicInformation;
pub const ObjectTypeInformation = OBJECT_INFORMATION_CLASS.TypeInformation;

pub const PUBLIC_OBJECT_BASIC_INFORMATION = extern struct {
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
    Reserved: [10]u32,
};

pub const PUBLIC_OBJECT_TYPE_INFORMATION = extern struct {
    TypeName: UNICODE_STRING,
    Reserved: [22]u32,
};

pub const KEY_VALUE_ENTRY = extern struct {
    ValueName: *UNICODE_STRING,
    DataLength: u32,
    DataOffset: u32,
    Type: u32,
};

pub const KEY_SET_INFORMATION_CLASS = extern enum(i32) {
    KeyWriteTimeInformation = 0,
    KeyWow64FlagsInformation = 1,
    KeyControlFlagsInformation = 2,
    KeySetVirtualizationInformation = 3,
    KeySetDebugInformation = 4,
    KeySetHandleTagsInformation = 5,
    MaxKeySetInfoClass = 6,
};
pub const KeyWriteTimeInformation = KEY_SET_INFORMATION_CLASS.KeyWriteTimeInformation;
pub const KeyWow64FlagsInformation = KEY_SET_INFORMATION_CLASS.KeyWow64FlagsInformation;
pub const KeyControlFlagsInformation = KEY_SET_INFORMATION_CLASS.KeyControlFlagsInformation;
pub const KeySetVirtualizationInformation = KEY_SET_INFORMATION_CLASS.KeySetVirtualizationInformation;
pub const KeySetDebugInformation = KEY_SET_INFORMATION_CLASS.KeySetDebugInformation;
pub const KeySetHandleTagsInformation = KEY_SET_INFORMATION_CLASS.KeySetHandleTagsInformation;
pub const MaxKeySetInfoClass = KEY_SET_INFORMATION_CLASS.MaxKeySetInfoClass;

pub const WINSTATIONINFOCLASS = extern enum(i32) {
    n = 8,
};
pub const WinStationInformation = WINSTATIONINFOCLASS.n;

pub const WINSTATIONINFORMATIONW = extern struct {
    Reserved2: [70]u8,
    LogonId: u32,
    Reserved3: [1140]u8,
};

pub const PWINSTATIONQUERYINFORMATIONW = fn(
    param0: HANDLE,
    param1: u32,
    param2: WINSTATIONINFOCLASS,
    param3: *c_void,
    param4: u32,
    param5: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const AVRF_BACKTRACE_INFORMATION = extern struct {
    Depth: u32,
    Index: u32,
    ReturnAddresses: [32]u64,
};

pub const eUserAllocationState = extern enum(i32) {
    Unknown = 0,
    Busy = 1,
    Free = 2,
};
pub const AllocationStateUnknown = eUserAllocationState.Unknown;
pub const AllocationStateBusy = eUserAllocationState.Busy;
pub const AllocationStateFree = eUserAllocationState.Free;

pub const eHeapAllocationState = extern enum(i32) {
    FullPageHeap = 1073741824,
    Metadata = -2147483648,
    StateMask = -65536,
};
pub const HeapFullPageHeap = eHeapAllocationState.FullPageHeap;
pub const HeapMetadata = eHeapAllocationState.Metadata;
pub const HeapStateMask = eHeapAllocationState.StateMask;

pub const eHeapEnumerationLevel = extern enum(i32) {
    Everything = 0,
    Stop = -1,
};
pub const HeapEnumerationEverything = eHeapEnumerationLevel.Everything;
pub const HeapEnumerationStop = eHeapEnumerationLevel.Stop;

pub const AVRF_HEAP_ALLOCATION = extern struct {
    HeapHandle: u64,
    UserAllocation: u64,
    UserAllocationSize: u64,
    Allocation: u64,
    AllocationSize: u64,
    UserAllocationState: u32,
    HeapState: u32,
    HeapContext: u64,
    BackTraceInformation: *AVRF_BACKTRACE_INFORMATION,
};

pub const eHANDLE_TRACE_OPERATIONS = extern enum(i32) {
    Unused = 0,
    OPEN = 1,
    CLOSE = 2,
    BADREF = 3,
};
pub const OperationDbUnused = eHANDLE_TRACE_OPERATIONS.Unused;
pub const OperationDbOPEN = eHANDLE_TRACE_OPERATIONS.OPEN;
pub const OperationDbCLOSE = eHANDLE_TRACE_OPERATIONS.CLOSE;
pub const OperationDbBADREF = eHANDLE_TRACE_OPERATIONS.BADREF;

pub const AVRF_HANDLE_OPERATION = extern struct {
    Handle: u64,
    ProcessId: u32,
    ThreadId: u32,
    OperationType: u32,
    Spare0: u32,
    BackTraceInformation: AVRF_BACKTRACE_INFORMATION,
};

pub const eAvrfResourceTypes = extern enum(i32) {
    HeapAllocation = 0,
    HandleTrace = 1,
    Max = 2,
};
pub const AvrfResourceHeapAllocation = eAvrfResourceTypes.HeapAllocation;
pub const AvrfResourceHandleTrace = eAvrfResourceTypes.HandleTrace;
pub const AvrfResourceMax = eAvrfResourceTypes.Max;

pub const AVRF_RESOURCE_ENUMERATE_CALLBACK = fn(
    ResourceDescription: *c_void,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const AVRF_HEAPALLOCATION_ENUMERATE_CALLBACK = fn(
    HeapAllocation: *AVRF_HEAP_ALLOCATION,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const AVRF_HANDLEOPERATION_ENUMERATE_CALLBACK = fn(
    HandleOperation: *AVRF_HANDLE_OPERATION,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

const CLSID_CameraUIControl_Value = @import("../zig.zig").Guid.initString("16d5a2be-b1c5-47b3-8eae-ccbcf452c7e8");
pub const CLSID_CameraUIControl = &CLSID_CameraUIControl_Value;

pub const CameraUIControlMode = extern enum(i32) {
    Browse = 0,
    Linear = 1,
};
pub const Browse = CameraUIControlMode.Browse;
pub const Linear = CameraUIControlMode.Linear;

pub const CameraUIControlLinearSelectionMode = extern enum(i32) {
    Single = 0,
    Multiple = 1,
};
pub const Single = CameraUIControlLinearSelectionMode.Single;
pub const Multiple = CameraUIControlLinearSelectionMode.Multiple;

pub const CameraUIControlCaptureMode = extern enum(i32) {
    PhotoOrVideo = 0,
    Photo = 1,
    Video = 2,
};
pub const PhotoOrVideo = CameraUIControlCaptureMode.PhotoOrVideo;
pub const Photo = CameraUIControlCaptureMode.Photo;
pub const Video = CameraUIControlCaptureMode.Video;

pub const CameraUIControlPhotoFormat = extern enum(i32) {
    Jpeg = 0,
    Png = 1,
    JpegXR = 2,
};
pub const Jpeg = CameraUIControlPhotoFormat.Jpeg;
pub const Png = CameraUIControlPhotoFormat.Png;
pub const JpegXR = CameraUIControlPhotoFormat.JpegXR;

pub const CameraUIControlVideoFormat = extern enum(i32) {
    Mp4 = 0,
    Wmv = 1,
};
pub const Mp4 = CameraUIControlVideoFormat.Mp4;
pub const Wmv = CameraUIControlVideoFormat.Wmv;

pub const CameraUIControlViewType = extern enum(i32) {
    SingleItem = 0,
    ItemList = 1,
};
pub const SingleItem = CameraUIControlViewType.SingleItem;
pub const ItemList = CameraUIControlViewType.ItemList;

// TODO: this type is limited to platform 'windows8.0'
const IID_ICameraUIControlEventCallback_Value = @import("../zig.zig").Guid.initString("1bfa0c2c-fbcd-4776-bda4-88bf974e74f4");
pub const IID_ICameraUIControlEventCallback = &IID_ICameraUIControlEventCallback_Value;
pub const ICameraUIControlEventCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartupComplete: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSuspendComplete: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnItemCaptured: fn(
            self: *const ICameraUIControlEventCallback,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnItemDeleted: fn(
            self: *const ICameraUIControlEventCallback,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnClosed: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnStartupComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnStartupComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnSuspendComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnSuspendComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemCaptured(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemCaptured(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemDeleted(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemDeleted(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnClosed(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnClosed(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICameraUIControl_Value = @import("../zig.zig").Guid.initString("b8733adf-3d68-4b8f-bb08-e28a0bed0376");
pub const IID_ICameraUIControl = &IID_ICameraUIControl_Value;
pub const ICameraUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Show: fn(
            self: *const ICameraUIControl,
            pWindow: *IUnknown,
            mode: CameraUIControlMode,
            selectionMode: CameraUIControlLinearSelectionMode,
            captureMode: CameraUIControlCaptureMode,
            photoFormat: CameraUIControlPhotoFormat,
            videoFormat: CameraUIControlVideoFormat,
            bHasCloseButton: BOOL,
            pEventCallback: ?*ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const ICameraUIControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const ICameraUIControl,
            pbDeferralRequired: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const ICameraUIControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentViewType: fn(
            self: *const ICameraUIControl,
            pViewType: *CameraUIControlViewType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveItem: fn(
            self: *const ICameraUIControl,
            pbstrActiveItemPath: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedItems: fn(
            self: *const ICameraUIControl,
            ppSelectedItemPaths: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveCapturedItem: fn(
            self: *const ICameraUIControl,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Show(self: *const T, pWindow: *IUnknown, mode: CameraUIControlMode, selectionMode: CameraUIControlLinearSelectionMode, captureMode: CameraUIControlCaptureMode, photoFormat: CameraUIControlPhotoFormat, videoFormat: CameraUIControlVideoFormat, bHasCloseButton: BOOL, pEventCallback: ?*ICameraUIControlEventCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Show(@ptrCast(*const ICameraUIControl, self), pWindow, mode, selectionMode, captureMode, photoFormat, videoFormat, bHasCloseButton, pEventCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Close(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Suspend(self: *const T, pbDeferralRequired: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Suspend(@ptrCast(*const ICameraUIControl, self), pbDeferralRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Resume(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetCurrentViewType(self: *const T, pViewType: *CameraUIControlViewType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetCurrentViewType(@ptrCast(*const ICameraUIControl, self), pViewType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetActiveItem(self: *const T, pbstrActiveItemPath: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetActiveItem(@ptrCast(*const ICameraUIControl, self), pbstrActiveItemPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetSelectedItems(self: *const T, ppSelectedItemPaths: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetSelectedItems(@ptrCast(*const ICameraUIControl, self), ppSelectedItemPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_RemoveCapturedItem(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).RemoveCapturedItem(@ptrCast(*const ICameraUIControl, self), pszPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ERF = extern struct {
    erfOper: i32,
    erfType: i32,
    fError: BOOL,
};

pub const FCIERROR = extern enum(i32) {
    NONE = 0,
    OPEN_SRC = 1,
    READ_SRC = 2,
    ALLOC_FAIL = 3,
    TEMP_FILE = 4,
    BAD_COMPR_TYPE = 5,
    CAB_FILE = 6,
    USER_ABORT = 7,
    MCI_FAIL = 8,
    CAB_FORMAT_LIMIT = 9,
};
pub const FCIERR_NONE = FCIERROR.NONE;
pub const FCIERR_OPEN_SRC = FCIERROR.OPEN_SRC;
pub const FCIERR_READ_SRC = FCIERROR.READ_SRC;
pub const FCIERR_ALLOC_FAIL = FCIERROR.ALLOC_FAIL;
pub const FCIERR_TEMP_FILE = FCIERROR.TEMP_FILE;
pub const FCIERR_BAD_COMPR_TYPE = FCIERROR.BAD_COMPR_TYPE;
pub const FCIERR_CAB_FILE = FCIERROR.CAB_FILE;
pub const FCIERR_USER_ABORT = FCIERROR.USER_ABORT;
pub const FCIERR_MCI_FAIL = FCIERROR.MCI_FAIL;
pub const FCIERR_CAB_FORMAT_LIMIT = FCIERROR.CAB_FORMAT_LIMIT;

pub const CCAB = extern struct {
    cb: u32,
    cbFolderThresh: u32,
    cbReserveCFHeader: u32,
    cbReserveCFFolder: u32,
    cbReserveCFData: u32,
    iCab: i32,
    iDisk: i32,
    fFailOnIncompressible: i32,
    setID: u16,
    szDisk: [256]CHAR,
    szCab: [256]CHAR,
    szCabPath: [256]CHAR,
};

pub const PFNFCIALLOC = fn(
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNFCIFREE = fn(
    memory: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNFCIOPEN = fn(
    pszFile: PSTR,
    oflag: i32,
    pmode: i32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

pub const PFNFCIREAD = fn(
    hf: isize,
    memory: *c_void,
    cb: u32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNFCIWRITE = fn(
    hf: isize,
    memory: *c_void,
    cb: u32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNFCICLOSE = fn(
    hf: isize,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCISEEK = fn(
    hf: isize,
    dist: i32,
    seektype: i32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIDELETE = fn(
    pszFile: PSTR,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETNEXTCABINET = fn(
    pccab: *CCAB,
    cbPrevCab: u32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFNFCIFILEPLACED = fn(
    pccab: *CCAB,
    pszFile: PSTR,
    cbFile: i32,
    fContinuation: BOOL,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETOPENINFO = fn(
    pszName: PSTR,
    pdate: *u16,
    ptime: *u16,
    pattribs: *u16,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

pub const PFNFCISTATUS = fn(
    typeStatus: u32,
    cb1: u32,
    cb2: u32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETTEMPFILE = fn(
    // TODO: what to do with BytesParamIndex 1?
    pszTempName: PSTR,
    cbTempName: i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const FDIERROR = extern enum(i32) {
    NONE = 0,
    CABINET_NOT_FOUND = 1,
    NOT_A_CABINET = 2,
    UNKNOWN_CABINET_VERSION = 3,
    CORRUPT_CABINET = 4,
    ALLOC_FAIL = 5,
    BAD_COMPR_TYPE = 6,
    MDI_FAIL = 7,
    TARGET_FILE = 8,
    RESERVE_MISMATCH = 9,
    WRONG_CABINET = 10,
    USER_ABORT = 11,
    EOF = 12,
};
pub const FDIERROR_NONE = FDIERROR.NONE;
pub const FDIERROR_CABINET_NOT_FOUND = FDIERROR.CABINET_NOT_FOUND;
pub const FDIERROR_NOT_A_CABINET = FDIERROR.NOT_A_CABINET;
pub const FDIERROR_UNKNOWN_CABINET_VERSION = FDIERROR.UNKNOWN_CABINET_VERSION;
pub const FDIERROR_CORRUPT_CABINET = FDIERROR.CORRUPT_CABINET;
pub const FDIERROR_ALLOC_FAIL = FDIERROR.ALLOC_FAIL;
pub const FDIERROR_BAD_COMPR_TYPE = FDIERROR.BAD_COMPR_TYPE;
pub const FDIERROR_MDI_FAIL = FDIERROR.MDI_FAIL;
pub const FDIERROR_TARGET_FILE = FDIERROR.TARGET_FILE;
pub const FDIERROR_RESERVE_MISMATCH = FDIERROR.RESERVE_MISMATCH;
pub const FDIERROR_WRONG_CABINET = FDIERROR.WRONG_CABINET;
pub const FDIERROR_USER_ABORT = FDIERROR.USER_ABORT;
pub const FDIERROR_EOF = FDIERROR.EOF;

pub const FDICABINETINFO = extern struct {
    cbCabinet: i32,
    cFolders: u16,
    cFiles: u16,
    setID: u16,
    iCabinet: u16,
    fReserve: BOOL,
    hasprev: BOOL,
    hasnext: BOOL,
};

pub const FDIDECRYPTTYPE = extern enum(i32) {
    NEW_CABINET = 0,
    NEW_FOLDER = 1,
    DECRYPT = 2,
};
pub const fdidtNEW_CABINET = FDIDECRYPTTYPE.NEW_CABINET;
pub const fdidtNEW_FOLDER = FDIDECRYPTTYPE.NEW_FOLDER;
pub const fdidtDECRYPT = FDIDECRYPTTYPE.DECRYPT;

pub const FDIDECRYPT = extern struct {
    fdidt: FDIDECRYPTTYPE,
    pvUser: *c_void,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNALLOC = fn(
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNFREE = fn(
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNOPEN = fn(
    pszFile: PSTR,
    oflag: i32,
    pmode: i32,
) callconv(@import("std").os.windows.WINAPI) isize;

pub const PFNREAD = fn(
    hf: isize,
    // TODO: what to do with BytesParamIndex 2?
    pv: *c_void,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNWRITE = fn(
    hf: isize,
    // TODO: what to do with BytesParamIndex 2?
    pv: *c_void,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNCLOSE = fn(
    hf: isize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNSEEK = fn(
    hf: isize,
    dist: i32,
    seektype: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFDIDECRYPT = fn(
    pfdid: *FDIDECRYPT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const FDINOTIFICATION = extern struct {
    cb: i32,
    psz1: PSTR,
    psz2: PSTR,
    psz3: PSTR,
    pv: *c_void,
    hf: isize,
    date: u16,
    time: u16,
    attribs: u16,
    setID: u16,
    iCabinet: u16,
    iFolder: u16,
    fdie: FDIERROR,
};

pub const FDINOTIFICATIONTYPE = extern enum(i32) {
    CABINET_INFO = 0,
    PARTIAL_FILE = 1,
    COPY_FILE = 2,
    CLOSE_FILE_INFO = 3,
    NEXT_CABINET = 4,
    ENUMERATE = 5,
};
pub const fdintCABINET_INFO = FDINOTIFICATIONTYPE.CABINET_INFO;
pub const fdintPARTIAL_FILE = FDINOTIFICATIONTYPE.PARTIAL_FILE;
pub const fdintCOPY_FILE = FDINOTIFICATIONTYPE.COPY_FILE;
pub const fdintCLOSE_FILE_INFO = FDINOTIFICATIONTYPE.CLOSE_FILE_INFO;
pub const fdintNEXT_CABINET = FDINOTIFICATIONTYPE.NEXT_CABINET;
pub const fdintENUMERATE = FDINOTIFICATIONTYPE.ENUMERATE;

pub const PFNFDINOTIFY = fn(
    fdint: FDINOTIFICATIONTYPE,
    pfdin: *FDINOTIFICATION,
) callconv(@import("std").os.windows.WINAPI) isize;

pub const VDMCONTEXT_WITHOUT_XSAVE = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
};

pub const SEGMENT_NOTE = extern struct {
    Selector1: u16,
    Selector2: u16,
    Segment: u16,
    Module: [10]CHAR,
    FileName: [256]CHAR,
    Type: u16,
    Length: u32,
};

pub const IMAGE_NOTE = extern struct {
    Module: [10]CHAR,
    FileName: [256]CHAR,
    hModule: u16,
    hTask: u16,
};

pub const TEMP_BP_NOTE = extern struct {
    Seg: u16,
    Offset: u32,
    bPM: BOOL,
};

pub const VDM_SEGINFO = extern struct {
    Selector: u16,
    SegNumber: u16,
    Length: u32,
    Type: u16,
    ModuleName: [9]CHAR,
    FileName: [255]CHAR,
};

pub const DEBUGEVENTPROC = fn(
    param0: *DEBUG_EVENT,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PROCESSENUMPROC = fn(
    dwProcessId: u32,
    dwAttributes: u32,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TASKENUMPROC = fn(
    dwThreadId: u32,
    hMod16: u16,
    hTask16: u16,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TASKENUMPROCEX = fn(
    dwThreadId: u32,
    hMod16: u16,
    hTask16: u16,
    pszModName: *i8,
    pszFileName: *i8,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMPROCESSEXCEPTIONPROC = fn(
    param0: *DEBUG_EVENT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETPOINTERPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u16,
    param3: u32,
    param4: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VDMKILLWOWPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMDETECTWOWPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMBREAKTHREADPROC = fn(
    param0: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSELECTORMODULEPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u16,
    param3: *u32,
    param4: PSTR,
    param5: u32,
    param6: PSTR,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETMODULESELECTORPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u32,
    param3: PSTR,
    param4: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMMODULEFIRSTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *MODULEENTRY,
    param3: DEBUGEVENTPROC,
    param4: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMMODULENEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *MODULEENTRY,
    param3: DEBUGEVENTPROC,
    param4: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGLOBALFIRSTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *GLOBALENTRY,
    param3: u16,
    param4: DEBUGEVENTPROC,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGLOBALNEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *GLOBALENTRY,
    param3: u16,
    param4: DEBUGEVENTPROC,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMENUMPROCESSWOWPROC = fn(
    param0: PROCESSENUMPROC,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMENUMTASKWOWPROC = fn(
    param0: u32,
    param1: TASKENUMPROC,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMENUMTASKWOWEXPROC = fn(
    param0: u32,
    param1: TASKENUMPROCEX,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMTERMINATETASKINWOWPROC = fn(
    param0: u32,
    param1: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMSTARTTASKINWOWPROC = fn(
    param0: u32,
    param1: PSTR,
    param2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETDBGFLAGSPROC = fn(
    param0: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VDMSETDBGFLAGSPROC = fn(
    param0: HANDLE,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMISMODULELOADEDPROC = fn(
    param0: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSEGMENTINFOPROC = fn(
    param0: u16,
    param1: u32,
    param2: BOOL,
    param3: VDM_SEGINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSYMBOLPROC = fn(
    param0: PSTR,
    param1: u16,
    param2: u32,
    param3: BOOL,
    param4: BOOL,
    param5: *[256]u8,
    param6: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETADDREXPRESSIONPROC = fn(
    param0: PSTR,
    param1: PSTR,
    param2: *u16,
    param3: *u32,
    param4: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const CLSID_EditionUpgradeHelper_Value = @import("../zig.zig").Guid.initString("01776df3-b9af-4e50-9b1c-56e93116d704");
pub const CLSID_EditionUpgradeHelper = &CLSID_EditionUpgradeHelper_Value;

const CLSID_EditionUpgradeBroker_Value = @import("../zig.zig").Guid.initString("c4270827-4f39-45df-9288-12ff6b85a921");
pub const CLSID_EditionUpgradeBroker = &CLSID_EditionUpgradeBroker_Value;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IEditionUpgradeHelper_Value = @import("../zig.zig").Guid.initString("d3e9e342-5deb-43b6-849e-6913b85d503a");
pub const IID_IEditionUpgradeHelper = &IID_IEditionUpgradeHelper_Value;
pub const IEditionUpgradeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanUpgrade: fn(
            self: *const IEditionUpgradeHelper,
            isAllowed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateOperatingSystem: fn(
            self: *const IEditionUpgradeHelper,
            contentId: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProductKeyUI: fn(
            self: *const IEditionUpgradeHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOsProductContentId: fn(
            self: *const IEditionUpgradeHelper,
            contentId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenuineLocalStatus: fn(
            self: *const IEditionUpgradeHelper,
            isGenuine: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_CanUpgrade(self: *const T, isAllowed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeHelper, self), isAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_UpdateOperatingSystem(self: *const T, contentId: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetOsProductContentId(self: *const T, contentId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetOsProductContentId(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetGenuineLocalStatus(self: *const T, isGenuine: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetGenuineLocalStatus(@ptrCast(*const IEditionUpgradeHelper, self), isGenuine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowsLockModeHelper_Value = @import("../zig.zig").Guid.initString("f342d19e-cc22-4648-bb5d-03ccf75b47c5");
pub const IID_IWindowsLockModeHelper = &IID_IWindowsLockModeHelper_Value;
pub const IWindowsLockModeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSMode: fn(
            self: *const IWindowsLockModeHelper,
            isSmode: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsLockModeHelper_GetSMode(self: *const T, isSmode: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowsLockModeHelper.VTable, self.vtable).GetSMode(@ptrCast(*const IWindowsLockModeHelper, self), isSmode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEditionUpgradeBroker_Value = @import("../zig.zig").Guid.initString("ff19cbcf-9455-4937-b872-6b7929a460af");
pub const IID_IEditionUpgradeBroker = &IID_IEditionUpgradeBroker_Value;
pub const IEditionUpgradeBroker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeParentWindow: fn(
            self: *const IEditionUpgradeBroker,
            parentHandle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateOperatingSystem: fn(
            self: *const IEditionUpgradeBroker,
            parameter: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProductKeyUI: fn(
            self: *const IEditionUpgradeBroker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUpgrade: fn(
            self: *const IEditionUpgradeBroker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_InitializeParentWindow(self: *const T, parentHandle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).InitializeParentWindow(@ptrCast(*const IEditionUpgradeBroker, self), parentHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_UpdateOperatingSystem(self: *const T, parameter: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeBroker, self), parameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeBroker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_CanUpgrade(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeBroker, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IContainerActivationHelper_Value = @import("../zig.zig").Guid.initString("b524f93f-80d5-4ec7-ae9e-d66e93ade1fa");
pub const IID_IContainerActivationHelper = &IID_IContainerActivationHelper_Value;
pub const IContainerActivationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanActivateClientVM: fn(
            self: *const IContainerActivationHelper,
            isAllowed: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContainerActivationHelper_CanActivateClientVM(self: *const T, isAllowed: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContainerActivationHelper.VTable, self.vtable).CanActivateClientVM(@ptrCast(*const IContainerActivationHelper, self), isAllowed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClipServiceNotificationHelper_Value = @import("../zig.zig").Guid.initString("c39948f0-6142-44fd-98ca-e1681a8d68b5");
pub const IID_IClipServiceNotificationHelper = &IID_IClipServiceNotificationHelper_Value;
pub const IClipServiceNotificationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowToast: fn(
            self: *const IClipServiceNotificationHelper,
            titleText: BSTR,
            bodyText: BSTR,
            packageName: BSTR,
            appId: BSTR,
            launchCommand: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClipServiceNotificationHelper_ShowToast(self: *const T, titleText: BSTR, bodyText: BSTR, packageName: BSTR, appId: BSTR, launchCommand: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClipServiceNotificationHelper.VTable, self.vtable).ShowToast(@ptrCast(*const IClipServiceNotificationHelper, self), titleText, bodyText, packageName, appId, launchCommand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FEATURE_CHANGE_TIME = extern enum(i32) {
    READ = 0,
    MODULE_RELOAD = 1,
    SESSION = 2,
    REBOOT = 3,
};
pub const FEATURE_CHANGE_TIME_READ = FEATURE_CHANGE_TIME.READ;
pub const FEATURE_CHANGE_TIME_MODULE_RELOAD = FEATURE_CHANGE_TIME.MODULE_RELOAD;
pub const FEATURE_CHANGE_TIME_SESSION = FEATURE_CHANGE_TIME.SESSION;
pub const FEATURE_CHANGE_TIME_REBOOT = FEATURE_CHANGE_TIME.REBOOT;

pub const FEATURE_ENABLED_STATE = extern enum(i32) {
    DEFAULT = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const FEATURE_ENABLED_STATE_DEFAULT = FEATURE_ENABLED_STATE.DEFAULT;
pub const FEATURE_ENABLED_STATE_DISABLED = FEATURE_ENABLED_STATE.DISABLED;
pub const FEATURE_ENABLED_STATE_ENABLED = FEATURE_ENABLED_STATE.ENABLED;

pub const FEATURE_ERROR = extern struct {
    hr: HRESULT,
    lineNumber: u16,
    file: [*:0]const u8,
    process: [*:0]const u8,
    module: [*:0]const u8,
    callerReturnAddressOffset: u32,
    callerModule: [*:0]const u8,
    message: [*:0]const u8,
    originLineNumber: u16,
    originFile: [*:0]const u8,
    originModule: [*:0]const u8,
    originCallerReturnAddressOffset: u32,
    originCallerModule: [*:0]const u8,
    originName: [*:0]const u8,
};

pub const PFEATURE_STATE_CHANGE_CALLBACK = fn(
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_FhConfigMgr_Value = @import("../zig.zig").Guid.initString("ed43bb3c-09e9-498a-9df6-2177244c6db4");
pub const CLSID_FhConfigMgr = &CLSID_FhConfigMgr_Value;

const CLSID_FhReassociation_Value = @import("../zig.zig").Guid.initString("4d728e35-16fa-4320-9e8b-bfd7100a8846");
pub const CLSID_FhReassociation = &CLSID_FhReassociation_Value;

pub const FH_TARGET_PROPERTY_TYPE = extern enum(i32) {
    FH_TARGET_NAME = 0,
    FH_TARGET_URL = 1,
    FH_TARGET_DRIVE_TYPE = 2,
    MAX_TARGET_PROPERTY = 3,
};
pub const FH_TARGET_NAME = FH_TARGET_PROPERTY_TYPE.FH_TARGET_NAME;
pub const FH_TARGET_URL = FH_TARGET_PROPERTY_TYPE.FH_TARGET_URL;
pub const FH_TARGET_DRIVE_TYPE = FH_TARGET_PROPERTY_TYPE.FH_TARGET_DRIVE_TYPE;
pub const MAX_TARGET_PROPERTY = FH_TARGET_PROPERTY_TYPE.MAX_TARGET_PROPERTY;

pub const FH_TARGET_DRIVE_TYPES = extern enum(i32) {
    UNKNOWN = 0,
    REMOVABLE = 2,
    FIXED = 3,
    REMOTE = 4,
};
pub const FH_DRIVE_UNKNOWN = FH_TARGET_DRIVE_TYPES.UNKNOWN;
pub const FH_DRIVE_REMOVABLE = FH_TARGET_DRIVE_TYPES.REMOVABLE;
pub const FH_DRIVE_FIXED = FH_TARGET_DRIVE_TYPES.FIXED;
pub const FH_DRIVE_REMOTE = FH_TARGET_DRIVE_TYPES.REMOTE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhTarget_Value = @import("../zig.zig").Guid.initString("d87965fd-2bad-4657-bd3b-9567eb300ced");
pub const IID_IFhTarget = &IID_IFhTarget_Value;
pub const IFhTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringProperty: fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumericalProperty: fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhTarget_GetStringProperty(self: *const T, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhTarget.VTable, self.vtable).GetStringProperty(@ptrCast(*const IFhTarget, self), PropertyType, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhTarget_GetNumericalProperty(self: *const T, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhTarget.VTable, self.vtable).GetNumericalProperty(@ptrCast(*const IFhTarget, self), PropertyType, PropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhScopeIterator_Value = @import("../zig.zig").Guid.initString("3197abce-532a-44c6-8615-f3666566a720");
pub const IID_IFhScopeIterator = &IID_IFhScopeIterator_Value;
pub const IFhScopeIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToNextItem: fn(
            self: *const IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IFhScopeIterator,
            Item: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhScopeIterator_MoveToNextItem(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhScopeIterator.VTable, self.vtable).MoveToNextItem(@ptrCast(*const IFhScopeIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhScopeIterator_GetItem(self: *const T, Item: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhScopeIterator.VTable, self.vtable).GetItem(@ptrCast(*const IFhScopeIterator, self), Item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FH_PROTECTED_ITEM_CATEGORY = extern enum(i32) {
    FH_FOLDER = 0,
    FH_LIBRARY = 1,
    MAX_PROTECTED_ITEM_CATEGORY = 2,
};
pub const FH_FOLDER = FH_PROTECTED_ITEM_CATEGORY.FH_FOLDER;
pub const FH_LIBRARY = FH_PROTECTED_ITEM_CATEGORY.FH_LIBRARY;
pub const MAX_PROTECTED_ITEM_CATEGORY = FH_PROTECTED_ITEM_CATEGORY.MAX_PROTECTED_ITEM_CATEGORY;

pub const FH_LOCAL_POLICY_TYPE = extern enum(i32) {
    FH_FREQUENCY = 0,
    FH_RETENTION_TYPE = 1,
    FH_RETENTION_AGE = 2,
    MAX_LOCAL_POLICY = 3,
};
pub const FH_FREQUENCY = FH_LOCAL_POLICY_TYPE.FH_FREQUENCY;
pub const FH_RETENTION_TYPE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_TYPE;
pub const FH_RETENTION_AGE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_AGE;
pub const MAX_LOCAL_POLICY = FH_LOCAL_POLICY_TYPE.MAX_LOCAL_POLICY;

pub const FH_RETENTION_TYPES = extern enum(i32) {
    FH_RETENTION_DISABLED = 0,
    FH_RETENTION_UNLIMITED = 1,
    FH_RETENTION_AGE_BASED = 2,
    MAX_RETENTION_TYPE = 3,
};
pub const FH_RETENTION_DISABLED = FH_RETENTION_TYPES.FH_RETENTION_DISABLED;
pub const FH_RETENTION_UNLIMITED = FH_RETENTION_TYPES.FH_RETENTION_UNLIMITED;
pub const FH_RETENTION_AGE_BASED = FH_RETENTION_TYPES.FH_RETENTION_AGE_BASED;
pub const MAX_RETENTION_TYPE = FH_RETENTION_TYPES.MAX_RETENTION_TYPE;

pub const FH_BACKUP_STATUS = extern enum(i32) {
    FH_STATUS_DISABLED = 0,
    FH_STATUS_DISABLED_BY_GP = 1,
    FH_STATUS_ENABLED = 2,
    FH_STATUS_REHYDRATING = 3,
    MAX_BACKUP_STATUS = 4,
};
pub const FH_STATUS_DISABLED = FH_BACKUP_STATUS.FH_STATUS_DISABLED;
pub const FH_STATUS_DISABLED_BY_GP = FH_BACKUP_STATUS.FH_STATUS_DISABLED_BY_GP;
pub const FH_STATUS_ENABLED = FH_BACKUP_STATUS.FH_STATUS_ENABLED;
pub const FH_STATUS_REHYDRATING = FH_BACKUP_STATUS.FH_STATUS_REHYDRATING;
pub const MAX_BACKUP_STATUS = FH_BACKUP_STATUS.MAX_BACKUP_STATUS;

pub const FH_DEVICE_VALIDATION_RESULT = extern enum(i32) {
    FH_ACCESS_DENIED = 0,
    FH_INVALID_DRIVE_TYPE = 1,
    FH_READ_ONLY_PERMISSION = 2,
    FH_CURRENT_DEFAULT = 3,
    FH_NAMESPACE_EXISTS = 4,
    FH_TARGET_PART_OF_LIBRARY = 5,
    FH_VALID_TARGET = 6,
    MAX_VALIDATION_RESULT = 7,
};
pub const FH_ACCESS_DENIED = FH_DEVICE_VALIDATION_RESULT.FH_ACCESS_DENIED;
pub const FH_INVALID_DRIVE_TYPE = FH_DEVICE_VALIDATION_RESULT.FH_INVALID_DRIVE_TYPE;
pub const FH_READ_ONLY_PERMISSION = FH_DEVICE_VALIDATION_RESULT.FH_READ_ONLY_PERMISSION;
pub const FH_CURRENT_DEFAULT = FH_DEVICE_VALIDATION_RESULT.FH_CURRENT_DEFAULT;
pub const FH_NAMESPACE_EXISTS = FH_DEVICE_VALIDATION_RESULT.FH_NAMESPACE_EXISTS;
pub const FH_TARGET_PART_OF_LIBRARY = FH_DEVICE_VALIDATION_RESULT.FH_TARGET_PART_OF_LIBRARY;
pub const FH_VALID_TARGET = FH_DEVICE_VALIDATION_RESULT.FH_VALID_TARGET;
pub const MAX_VALIDATION_RESULT = FH_DEVICE_VALIDATION_RESULT.MAX_VALIDATION_RESULT;

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhConfigMgr_Value = @import("../zig.zig").Guid.initString("6a5fea5b-bf8f-4ee5-b8c3-44d8a0d7331c");
pub const IID_IFhConfigMgr = &IID_IFhConfigMgr_Value;
pub const IFhConfigMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadConfiguration: fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDefaultConfiguration: fn(
            self: *const IFhConfigMgr,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveConfiguration: fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRemoveExcludeRule: fn(
            self: *const IFhConfigMgr,
            Add: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Item: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIncludeExcludeRules: fn(
            self: *const IFhConfigMgr,
            Include: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Iterator: **IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalPolicy: fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocalPolicy: fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStatus: fn(
            self: *const IFhConfigMgr,
            BackupStatus: *FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStatus: fn(
            self: *const IFhConfigMgr,
            BackupStatus: FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTarget: fn(
            self: *const IFhConfigMgr,
            DefaultTarget: **IFhTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateTarget: fn(
            self: *const IFhConfigMgr,
            TargetUrl: BSTR,
            ValidationResult: *FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProvisionAndSetNewTarget: fn(
            self: *const IFhConfigMgr,
            TargetUrl: BSTR,
            TargetName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDefaultTargetRecommendation: fn(
            self: *const IFhConfigMgr,
            Recommend: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProtectionStatus: fn(
            self: *const IFhConfigMgr,
            ProtectionState: *u32,
            ProtectedUntilTime: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_LoadConfiguration(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).LoadConfiguration(@ptrCast(*const IFhConfigMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_CreateDefaultConfiguration(self: *const T, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).CreateDefaultConfiguration(@ptrCast(*const IFhConfigMgr, self), OverwriteIfExists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SaveConfiguration(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SaveConfiguration(@ptrCast(*const IFhConfigMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_AddRemoveExcludeRule(self: *const T, Add: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Item: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).AddRemoveExcludeRule(@ptrCast(*const IFhConfigMgr, self), Add, Category, Item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetIncludeExcludeRules(self: *const T, Include: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Iterator: **IFhScopeIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetIncludeExcludeRules(@ptrCast(*const IFhConfigMgr, self), Include, Category, Iterator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetLocalPolicy(self: *const T, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetLocalPolicy(@ptrCast(*const IFhConfigMgr, self), LocalPolicyType, PolicyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SetLocalPolicy(self: *const T, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SetLocalPolicy(@ptrCast(*const IFhConfigMgr, self), LocalPolicyType, PolicyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetBackupStatus(self: *const T, BackupStatus: *FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetBackupStatus(@ptrCast(*const IFhConfigMgr, self), BackupStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SetBackupStatus(self: *const T, BackupStatus: FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SetBackupStatus(@ptrCast(*const IFhConfigMgr, self), BackupStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetDefaultTarget(self: *const T, DefaultTarget: **IFhTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetDefaultTarget(@ptrCast(*const IFhConfigMgr, self), DefaultTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ValidateTarget(self: *const T, TargetUrl: BSTR, ValidationResult: *FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ValidateTarget(@ptrCast(*const IFhConfigMgr, self), TargetUrl, ValidationResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ProvisionAndSetNewTarget(self: *const T, TargetUrl: BSTR, TargetName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ProvisionAndSetNewTarget(@ptrCast(*const IFhConfigMgr, self), TargetUrl, TargetName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ChangeDefaultTargetRecommendation(self: *const T, Recommend: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ChangeDefaultTargetRecommendation(@ptrCast(*const IFhConfigMgr, self), Recommend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_QueryProtectionStatus(self: *const T, ProtectionState: *u32, ProtectedUntilTime: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).QueryProtectionStatus(@ptrCast(*const IFhConfigMgr, self), ProtectionState, ProtectedUntilTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFhReassociation_Value = @import("../zig.zig").Guid.initString("6544a28a-f68d-47ac-91ef-16b2b36aa3ee");
pub const IID_IFhReassociation = &IID_IFhReassociation_Value;
pub const IFhReassociation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateTarget: fn(
            self: *const IFhReassociation,
            TargetUrl: BSTR,
            ValidationResult: *FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanTargetForConfigurations: fn(
            self: *const IFhReassociation,
            TargetUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigurationDetails: fn(
            self: *const IFhReassociation,
            Index: u32,
            UserName: *BSTR,
            PcName: *BSTR,
            BackupTime: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectConfiguration: fn(
            self: *const IFhReassociation,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformReassociation: fn(
            self: *const IFhReassociation,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_ValidateTarget(self: *const T, TargetUrl: BSTR, ValidationResult: *FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).ValidateTarget(@ptrCast(*const IFhReassociation, self), TargetUrl, ValidationResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_ScanTargetForConfigurations(self: *const T, TargetUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).ScanTargetForConfigurations(@ptrCast(*const IFhReassociation, self), TargetUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_GetConfigurationDetails(self: *const T, Index: u32, UserName: *BSTR, PcName: *BSTR, BackupTime: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).GetConfigurationDetails(@ptrCast(*const IFhReassociation, self), Index, UserName, PcName, BackupTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_SelectConfiguration(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).SelectConfiguration(@ptrCast(*const IFhReassociation, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_PerformReassociation(self: *const T, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).PerformReassociation(@ptrCast(*const IFhReassociation, self), OverwriteIfExists);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FhBackupStopReason = extern enum(i32) {
    InvalidStopReason = 0,
    LimitUserBusyMachineOnAC = 1,
    LimitUserIdleMachineOnDC = 2,
    LimitUserBusyMachineOnDC = 3,
    Cancelled = 4,
};
pub const BackupInvalidStopReason = FhBackupStopReason.InvalidStopReason;
pub const BackupLimitUserBusyMachineOnAC = FhBackupStopReason.LimitUserBusyMachineOnAC;
pub const BackupLimitUserIdleMachineOnDC = FhBackupStopReason.LimitUserIdleMachineOnDC;
pub const BackupLimitUserBusyMachineOnDC = FhBackupStopReason.LimitUserBusyMachineOnDC;
pub const BackupCancelled = FhBackupStopReason.Cancelled;

pub const DCICMD = extern struct {
    dwCommand: u32,
    dwParam1: u32,
    dwParam2: u32,
    dwVersion: u32,
    dwReserved: u32,
};

pub const DCICREATEINPUT = extern struct {
    cmd: DCICMD,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lpSurface: *c_void,
};

pub const DCISURFACEINFO = extern struct {
    dwSize: u32,
    dwDCICaps: u32,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    lStride: i32,
    dwBitCount: u32,
    dwOffSurface: usize,
    wSelSurface: u16,
    wReserved: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    BeginAccess: isize,
    EndAccess: isize,
    DestroySurface: isize,
};

pub const ENUM_CALLBACK = fn(
    lpSurfaceInfo: *DCISURFACEINFO,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DCIENUMINPUT = extern struct {
    cmd: DCICMD,
    rSrc: RECT,
    rDst: RECT,
    EnumCallback: isize,
    lpContext: *c_void,
};

pub const DCIOFFSCREEN = extern struct {
    dciInfo: DCISURFACEINFO,
    Draw: isize,
    SetClipList: isize,
    SetDestination: isize,
};

pub const DCIOVERLAY = extern struct {
    dciInfo: DCISURFACEINFO,
    dwChromakeyValue: u32,
    dwChromakeyMask: u32,
};

pub const WINWATCHNOTIFYPROC = fn(
    hww: HWINWATCH,
    hwnd: HWND,
    code: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WaaSAssessor_Value = @import("../zig.zig").Guid.initString("098ef871-fa9f-46af-8958-c083515d7c9c");
pub const CLSID_WaaSAssessor = &CLSID_WaaSAssessor_Value;

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IWaaSAssessor_Value = @import("../zig.zig").Guid.initString("2347bbef-1a3b-45a4-902d-3e09c269b45e");
pub const IID_IWaaSAssessor = &IID_IWaaSAssessor_Value;
pub const IWaaSAssessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOSUpdateAssessment: fn(
            self: *const IWaaSAssessor,
            result: *OSUpdateAssessment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaaSAssessor_GetOSUpdateAssessment(self: *const T, result: *OSUpdateAssessment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaaSAssessor.VTable, self.vtable).GetOSUpdateAssessment(@ptrCast(*const IWaaSAssessor, self), result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMEML = extern struct {
    next: *VMEML,
    ptr: usize,
    size: u32,
    bDiscardable: BOOL,
};

pub const VMEMR = extern struct {
    next: *VMEMR,
    prev: *VMEMR,
    pUp: *VMEMR,
    pDown: *VMEMR,
    pLeft: *VMEMR,
    pRight: *VMEMR,
    ptr: usize,
    size: u32,
    x: u32,
    y: u32,
    cx: u32,
    cy: u32,
    flags: u32,
    pBits: usize,
    bDiscardable: BOOL,
};

pub const PROCESS_LIST = extern struct {
    lpLink: *PROCESS_LIST,
    dwProcessId: u32,
    dwRefCnt: u32,
    dwAlphaDepth: u32,
    dwZDepth: u32,
};

pub const DDMONITORINFO = extern struct {
    Manufacturer: u16,
    Product: u16,
    SerialNumber: u32,
    DeviceIdentifier: Guid,
    Mode640x480: i32,
    Mode800x600: i32,
    Mode1024x768: i32,
    Mode1280x1024: i32,
    Mode1600x1200: i32,
    ModeReserved1: i32,
    ModeReserved2: i32,
    ModeReserved3: i32,
};

pub const DD32BITDRIVERDATA = extern struct {
    szName: [260]CHAR,
    szEntryPoint: [64]CHAR,
    dwContext: u32,
};

pub const DDVERSIONDATA = extern struct {
    dwHALVersion: u32,
    dwReserved1: usize,
    dwReserved2: usize,
};

pub const LPDD32BITDRIVERINIT = fn(
    dwContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VIDMEM = extern struct {
    dwFlags: u32,
    fpStart: usize,
    Anonymous1: _Anonymous1_e__Union,
    ddsCaps: DDSCAPS,
    ddsCapsAlt: DDSCAPS,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const VIDMEMINFO = extern struct {
    fpPrimary: usize,
    dwFlags: u32,
    dwDisplayWidth: u32,
    dwDisplayHeight: u32,
    lDisplayPitch: i32,
    ddpfDisplay: DDPIXELFORMAT,
    dwOffscreenAlign: u32,
    dwOverlayAlign: u32,
    dwTextureAlign: u32,
    dwZBufferAlign: u32,
    dwAlphaAlign: u32,
    dwNumHeaps: u32,
    pvmList: *VIDMEM,
};

pub const HEAPALIAS = extern struct {
    fpVidMem: usize,
    lpAlias: *c_void,
    dwAliasSize: u32,
};

pub const HEAPALIASINFO = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    dwNumHeaps: u32,
    lpAliases: *HEAPALIAS,
};

pub const IUNKNOWN_LIST = extern struct {
    lpLink: *IUNKNOWN_LIST,
    lpGuid: *Guid,
    lpIUnknown: *IUnknown,
};

pub const LPDDHEL_INIT = fn(
    param0: *DDRAWI_DIRECTDRAW_GBL,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPDDHAL_SETCOLORKEY = fn(
    param0: *DDHAL_DRVSETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_CANCREATESURFACE = fn(
    param0: *DDHAL_CANCREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const LPDDHAL_WAITFORVERTICALBLANK = fn() callconv(@import("std").os.windows.WINAPI) void;

pub const LPDDHAL_CREATESURFACE = fn(
    param0: *DDHAL_CREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_DESTROYDRIVER = fn(
    param0: *DDHAL_DESTROYDRIVERDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_SETMODE = fn(
    param0: *DDHAL_SETMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_CREATEPALETTE = fn(
    param0: *DDHAL_CREATEPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETSCANLINE = fn(
    param0: *DDHAL_GETSCANLINEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_SETEXCLUSIVEMODE = fn(
    param0: *DDHAL_SETEXCLUSIVEMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_FLIPTOGDISURFACE = fn(
    param0: *DDHAL_FLIPTOGDISURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETDRIVERINFO = fn(
    param0: *DDHAL_GETDRIVERINFODATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroyDriver: LPDDHAL_DESTROYDRIVER,
    CreateSurface: LPDDHAL_CREATESURFACE,
    SetColorKey: LPDDHAL_SETCOLORKEY,
    SetMode: LPDDHAL_SETMODE,
    WaitForVerticalBlank: LPDDHAL_WAITFORVERTICALBLANK,
    CanCreateSurface: LPDDHAL_CANCREATESURFACE,
    CreatePalette: LPDDHAL_CREATEPALETTE,
    GetScanLine: LPDDHAL_GETSCANLINE,
    SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
    FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
};

pub const LPDDHALPALCB_DESTROYPALETTE = fn(
    param0: *DDHAL_DESTROYPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALPALCB_SETENTRIES = fn(
    param0: *DDHAL_SETENTRIESDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDPALETTECALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
    SetEntries: LPDDHALPALCB_SETENTRIES,
};

pub const LPDDHALSURFCB_LOCK = fn(
    param0: *DDHAL_LOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_UNLOCK = fn(
    param0: *DDHAL_UNLOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_BLT = fn(
    param0: *DDHAL_BLTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_UPDATEOVERLAY = fn(
    param0: *DDHAL_UPDATEOVERLAYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETOVERLAYPOSITION = fn(
    param0: *DDHAL_SETOVERLAYPOSITIONDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETPALETTE = fn(
    param0: *DDHAL_SETPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_FLIP = fn(
    param0: *DDHAL_FLIPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_DESTROYSURFACE = fn(
    param0: *DDHAL_DESTROYSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETCLIPLIST = fn(
    param0: *DDHAL_SETCLIPLISTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_ADDATTACHEDSURFACE = fn(
    param0: *DDHAL_ADDATTACHEDSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETCOLORKEY = fn(
    param0: *DDHAL_SETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_GETBLTSTATUS = fn(
    param0: *DDHAL_GETBLTSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_GETFLIPSTATUS = fn(
    param0: *DDHAL_GETFLIPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDSURFACECALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
    Flip: LPDDHALSURFCB_FLIP,
    SetClipList: LPDDHALSURFCB_SETCLIPLIST,
    Lock: LPDDHALSURFCB_LOCK,
    Unlock: LPDDHALSURFCB_UNLOCK,
    Blt: LPDDHALSURFCB_BLT,
    SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
    AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
    GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
    GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
    UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
    SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
    reserved4: *c_void,
    SetPalette: LPDDHALSURFCB_SETPALETTE,
};

pub const LPDDHAL_GETAVAILDRIVERMEMORY = fn(
    param0: *DDHAL_GETAVAILDRIVERMEMORYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_UPDATENONLOCALHEAP = fn(
    param0: *DDHAL_UPDATENONLOCALHEAPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETHEAPALIGNMENT = fn(
    param0: *DDHAL_GETHEAPALIGNMENTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMISCELLANEOUSCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
    GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    GetSysmemBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
};

pub const LPDDHAL_CREATESURFACEEX = fn(
    param0: *DDHAL_CREATESURFACEEXDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETDRIVERSTATE = fn(
    param0: *DDHAL_GETDRIVERSTATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_DESTROYDDLOCAL = fn(
    param0: *DDHAL_DESTROYDDLOCALDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMISCELLANEOUS2CALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Reserved: *c_void,
    CreateSurfaceEx: LPDDHAL_CREATESURFACEEX,
    GetDriverState: LPDDHAL_GETDRIVERSTATE,
    DestroyDDLocal: LPDDHAL_DESTROYDDLOCAL,
};

pub const LPDDHALEXEBUFCB_CANCREATEEXEBUF = fn(
    param0: *DDHAL_CANCREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_CREATEEXEBUF = fn(
    param0: *DDHAL_CREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_DESTROYEXEBUF = fn(
    param0: *DDHAL_DESTROYSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_LOCKEXEBUF = fn(
    param0: *DDHAL_LOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_UNLOCKEXEBUF = fn(
    param0: *DDHAL_UNLOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDEXEBUFCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    CanCreateExecuteBuffer: LPDDHALEXEBUFCB_CANCREATEEXEBUF,
    CreateExecuteBuffer: LPDDHALEXEBUFCB_CREATEEXEBUF,
    DestroyExecuteBuffer: LPDDHALEXEBUFCB_DESTROYEXEBUF,
    LockExecuteBuffer: LPDDHALEXEBUFCB_LOCKEXEBUF,
    UnlockExecuteBuffer: LPDDHALEXEBUFCB_UNLOCKEXEBUF,
};

pub const LPDDHALVPORTCB_CANCREATEVIDEOPORT = fn(
    param0: *DDHAL_CANCREATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_CREATEVIDEOPORT = fn(
    param0: *DDHAL_CREATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_FLIP = fn(
    param0: *DDHAL_FLIPVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETBANDWIDTH = fn(
    param0: *DDHAL_GETVPORTBANDWIDTHDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETINPUTFORMATS = fn(
    param0: *DDHAL_GETVPORTINPUTFORMATDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETOUTPUTFORMATS = fn(
    param0: *DDHAL_GETVPORTOUTPUTFORMATDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETFIELD = fn(
    param0: *DDHAL_GETVPORTFIELDDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETLINE = fn(
    param0: *DDHAL_GETVPORTLINEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETVPORTCONNECT = fn(
    param0: *DDHAL_GETVPORTCONNECTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_DESTROYVPORT = fn(
    param0: *DDHAL_DESTROYVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETFLIPSTATUS = fn(
    param0: *DDHAL_GETVPORTFLIPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_UPDATE = fn(
    param0: *DDHAL_UPDATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_WAITFORSYNC = fn(
    param0: *DDHAL_WAITFORVPORTSYNCDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETSIGNALSTATUS = fn(
    param0: *DDHAL_GETVPORTSIGNALDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_COLORCONTROL = fn(
    param0: *DDHAL_VPORTCOLORDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDVIDEOPORTCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
    CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
    FlipVideoPort: LPDDHALVPORTCB_FLIP,
    GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
    GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
    GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
    lpReserved1: *c_void,
    GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
    GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
    GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
    DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
    GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
    UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
    WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
    GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
    ColorControl: LPDDHALVPORTCB_COLORCONTROL,
};

pub const LPDDHALCOLORCB_COLORCONTROL = fn(
    param0: *DDHAL_COLORCONTROLDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDCOLORCONTROLCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    ColorControl: LPDDHALCOLORCB_COLORCONTROL,
};

pub const LPDDHALKERNELCB_SYNCSURFACE = fn(
    param0: *DDHAL_SYNCSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALKERNELCB_SYNCVIDEOPORT = fn(
    param0: *DDHAL_SYNCVIDEOPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDKERNELCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    SyncSurfaceData: LPDDHALKERNELCB_SYNCSURFACE,
    SyncVideoPortData: LPDDHALKERNELCB_SYNCVIDEOPORT,
};

pub const LPDDGAMMACALIBRATORPROC = fn(
    param0: *DDGAMMARAMP,
    param1: *u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPDDHALMOCOMPCB_GETGUIDS = fn(
    param0: *DDHAL_GETMOCOMPGUIDSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETFORMATS = fn(
    param0: *DDHAL_GETMOCOMPFORMATSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_CREATE = fn(
    param0: *DDHAL_CREATEMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETCOMPBUFFINFO = fn(
    param0: *DDHAL_GETMOCOMPCOMPBUFFDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETINTERNALINFO = fn(
    param0: *DDHAL_GETINTERNALMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_BEGINFRAME = fn(
    param0: *DDHAL_BEGINMOCOMPFRAMEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_ENDFRAME = fn(
    param0: *DDHAL_ENDMOCOMPFRAMEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_RENDER = fn(
    param0: *DDHAL_RENDERMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_QUERYSTATUS = fn(
    param0: *DDHAL_QUERYMOCOMPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_DESTROY = fn(
    param0: *DDHAL_DESTROYMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMOTIONCOMPCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
    GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
    CreateMoComp: LPDDHALMOCOMPCB_CREATE,
    GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
    GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
    BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
    EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
    RenderMoComp: LPDDHALMOCOMPCB_RENDER,
    QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
    DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
};

pub const DDNONLOCALVIDMEMCAPS = extern struct {
    dwSize: u32,
    dwNLVBCaps: u32,
    dwNLVBCaps2: u32,
    dwNLVBCKeyCaps: u32,
    dwNLVBFXCaps: u32,
    dwNLVBRops: [8]u32,
};

pub const DDMORESURFACECAPS = extern struct {
    dwSize: u32,
    ddsCapsMore: DDSCAPSEX,
    ddsExtendedHeapRestrictions: [1]ExtendedHeapRestrictions,
    const ExtendedHeapRestrictions = u32; // TODO: generate this nested type!
};

pub const DDSTEREOMODE = extern struct {
    dwSize: u32,
    dwHeight: u32,
    dwWidth: u32,
    dwBpp: u32,
    dwRefreshRate: u32,
    bSupported: BOOL,
};

pub const DDRAWI_DDRAWPALETTE_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWPALETTE_LCL,
    lpLink: *DDRAWI_DDRAWPALETTE_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWPALETTE_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwProcessId: u32,
    lpColorTable: *PALETTEENTRY,
    Anonymous: _Anonymous_e__Union,
    dwDriverReserved: u32,
    dwContentsStamp: u32,
    dwSaveStamp: u32,
    dwHandle: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWPALETTE_LCL = extern struct {
    lpPalMore: u32,
    lpGbl: *DDRAWI_DDRAWPALETTE_GBL,
    dwUnused0: usize,
    dwLocalRefCnt: u32,
    pUnkOuter: *IUnknown,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwReserved1: usize,
    dwDDRAWReserved1: usize,
    dwDDRAWReserved2: usize,
    dwDDRAWReserved3: usize,
};

pub const DDRAWI_DDRAWCLIPPER_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWCLIPPER_LCL,
    lpLink: *DDRAWI_DDRAWCLIPPER_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWCLIPPER_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwProcessId: u32,
    dwReserved1: usize,
    hWnd: usize,
    lpStaticClipList: *RGNDATA,
};

pub const DDRAWI_DDRAWCLIPPER_LCL = extern struct {
    lpClipMore: u32,
    lpGbl: *DDRAWI_DDRAWCLIPPER_GBL,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwLocalRefCnt: u32,
    pUnkOuter: *IUnknown,
    lpDD_int: *DDRAWI_DIRECTDRAW_INT,
    dwReserved1: usize,
    pAddrefedThisOwner: *IUnknown,
};

pub const ATTACHLIST = extern struct {
    dwFlags: u32,
    lpLink: *ATTACHLIST,
    lpAttached: *DDRAWI_DDRAWSURFACE_LCL,
    lpIAttached: *DDRAWI_DDRAWSURFACE_INT,
};

pub const DBLNODE = extern struct {
    next: *DBLNODE,
    prev: *DBLNODE,
    object: *DDRAWI_DDRAWSURFACE_LCL,
    object_int: *DDRAWI_DDRAWSURFACE_INT,
};

pub const ACCESSRECTLIST = extern struct {
    lpLink: *ACCESSRECTLIST,
    rDest: RECT,
    lpOwner: *DDRAWI_DIRECTDRAW_LCL,
    lpSurfaceData: *c_void,
    dwFlags: u32,
    lpHeapAliasInfo: *HEAPALIASINFO,
};

pub const DDRAWI_DDRAWSURFACE_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWSURFACE_LCL,
    lpLink: *DDRAWI_DDRAWSURFACE_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWSURFACE_GBL = extern struct {
    dwRefCnt: u32,
    dwGlobalFlags: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    fpVidMem: usize,
    Anonymous4: _Anonymous4_e__Union,
    wHeight: u16,
    wWidth: u16,
    dwUsageCount: u32,
    dwReserved1: usize,
    ddpfSurface: DDPIXELFORMAT,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWSURFACE_GBL_MORE = extern struct {
    dwSize: u32,
    Anonymous: _Anonymous_e__Union,
    pPageTable: *u32,
    cPages: u32,
    dwSavedDCContext: usize,
    fpAliasedVidMem: usize,
    dwDriverReserved: usize,
    dwHELReserved: usize,
    cPageUnlocks: u32,
    hKernelSurface: usize,
    dwKernelRefCnt: u32,
    lpColorInfo: *DDCOLORCONTROL,
    fpNTAlias: usize,
    dwContentsStamp: u32,
    lpvUnswappedDriverReserved: *c_void,
    lpDDRAWReserved2: *c_void,
    dwDDRAWReserved1: u32,
    dwDDRAWReserved2: u32,
    fpAliasOfVidMem: usize,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWSURFACE_MORE = extern struct {
    dwSize: u32,
    lpIUnknowns: *IUNKNOWN_LIST,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwPageLockCount: u32,
    dwBytesAllocated: u32,
    lpDD_int: *DDRAWI_DIRECTDRAW_INT,
    dwMipMapCount: u32,
    lpDDIClipper: *DDRAWI_DDRAWCLIPPER_INT,
    lpHeapAliasInfo: *HEAPALIASINFO,
    dwOverlayFlags: u32,
    rgjunc: *c_void,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpddOverlayFX: *DDOVERLAYFX,
    ddsCapsEx: DDSCAPSEX,
    dwTextureStage: u32,
    lpDDRAWReserved: *c_void,
    lpDDRAWReserved2: *c_void,
    lpDDrawReserved3: *c_void,
    dwDDrawReserved4: u32,
    lpDDrawReserved5: *c_void,
    lpGammaRamp: *u32,
    lpOriginalGammaRamp: *u32,
    lpDDrawReserved6: *c_void,
    dwSurfaceHandle: u32,
    qwDDrawReserved8: [2]u32,
    lpDDrawReserved9: *c_void,
    cSurfaces: u32,
    pCreatedDDSurfaceDesc2: *DDSURFACEDESC2,
    slist: **DDRAWI_DDRAWSURFACE_LCL,
    dwFVF: u32,
    lpVB: *c_void,
};

pub const DDRAWI_DDRAWSURFACE_LCL = extern struct {
    lpSurfMore: *DDRAWI_DDRAWSURFACE_MORE,
    lpGbl: *DDRAWI_DDRAWSURFACE_GBL,
    hDDSurface: usize,
    lpAttachList: *ATTACHLIST,
    lpAttachListFrom: *ATTACHLIST,
    dwLocalRefCnt: u32,
    dwProcessId: u32,
    dwFlags: u32,
    ddsCaps: DDSCAPS,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    dwModeCreatedIn: u32,
    dwBackBufferCount: u32,
    ddckCKDestBlt: DDCOLORKEY,
    ddckCKSrcBlt: DDCOLORKEY,
    hDC: usize,
    dwReserved1: usize,
    ddckCKSrcOverlay: DDCOLORKEY,
    ddckCKDestOverlay: DDCOLORKEY,
    lpSurfaceOverlaying: *DDRAWI_DDRAWSURFACE_INT,
    dbnOverlayNode: DBLNODE,
    rcOverlaySrc: RECT,
    rcOverlayDest: RECT,
    dwClrXparent: u32,
    dwAlpha: u32,
    lOverlayX: i32,
    lOverlayY: i32,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const DDHALMODEINFO = extern struct {
    dwWidth: u32,
    dwHeight: u32,
    lPitch: i32,
    dwBPP: u32,
    wFlags: u16,
    wRefreshRate: u16,
    dwRBitMask: u32,
    dwGBitMask: u32,
    dwBBitMask: u32,
    dwAlphaBitMask: u32,
};

pub const DDRAWI_DIRECTDRAW_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DIRECTDRAW_LCL,
    lpLink: *DDRAWI_DIRECTDRAW_INT,
    dwIntRefCnt: u32,
};

pub const DDHAL_CALLBACKS = extern struct {
    cbDDCallbacks: DDHAL_DDCALLBACKS,
    cbDDSurfaceCallbacks: DDHAL_DDSURFACECALLBACKS,
    cbDDPaletteCallbacks: DDHAL_DDPALETTECALLBACKS,
    HALDD: DDHAL_DDCALLBACKS,
    HALDDSurface: DDHAL_DDSURFACECALLBACKS,
    HALDDPalette: DDHAL_DDPALETTECALLBACKS,
    HELDD: DDHAL_DDCALLBACKS,
    HELDDSurface: DDHAL_DDSURFACECALLBACKS,
    HELDDPalette: DDHAL_DDPALETTECALLBACKS,
    cbDDExeBufCallbacks: DDHAL_DDEXEBUFCALLBACKS,
    HALDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    HELDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    cbDDVideoPortCallbacks: DDHAL_DDVIDEOPORTCALLBACKS,
    HALDDVideoPort: DDHAL_DDVIDEOPORTCALLBACKS,
    cbDDColorControlCallbacks: DDHAL_DDCOLORCONTROLCALLBACKS,
    HALDDColorControl: DDHAL_DDCOLORCONTROLCALLBACKS,
    cbDDMiscellaneousCallbacks: DDHAL_DDMISCELLANEOUSCALLBACKS,
    HALDDMiscellaneous: DDHAL_DDMISCELLANEOUSCALLBACKS,
    cbDDKernelCallbacks: DDHAL_DDKERNELCALLBACKS,
    HALDDKernel: DDHAL_DDKERNELCALLBACKS,
    cbDDMotionCompCallbacks: DDHAL_DDMOTIONCOMPCALLBACKS,
    HALDDMotionComp: DDHAL_DDMOTIONCOMPCALLBACKS,
};

pub const DDRAWI_DIRECTDRAW_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    fpPrimaryOrig: usize,
    ddCaps: DDCORECAPS,
    dwInternal1: u32,
    dwUnused1: [9]u32,
    lpDDCBtmp: *DDHAL_CALLBACKS,
    dsList: *DDRAWI_DDRAWSURFACE_INT,
    palList: *DDRAWI_DDRAWPALETTE_INT,
    clipperList: *DDRAWI_DDRAWCLIPPER_INT,
    lp16DD: *DDRAWI_DIRECTDRAW_GBL,
    dwMaxOverlays: u32,
    dwCurrOverlays: u32,
    dwMonitorFrequency: u32,
    ddHELCaps: DDCORECAPS,
    dwUnused2: [50]u32,
    ddckCKDestOverlay: DDCOLORKEY,
    ddckCKSrcOverlay: DDCOLORKEY,
    vmiData: VIDMEMINFO,
    lpDriverHandle: *c_void,
    lpExclusiveOwner: *DDRAWI_DIRECTDRAW_LCL,
    dwModeIndex: u32,
    dwModeIndexOrig: u32,
    dwNumFourCC: u32,
    lpdwFourCC: *u32,
    dwNumModes: u32,
    lpModeInfo: *DDHALMODEINFO,
    plProcessList: PROCESS_LIST,
    dwSurfaceLockCount: u32,
    dwAliasedLockCnt: u32,
    dwReserved3: usize,
    hDD: usize,
    cObsolete: [12]CHAR,
    dwReserved1: u32,
    dwReserved2: u32,
    dbnOverlayRoot: DBLNODE,
    lpwPDeviceFlags: *u16,
    dwPDevice: u32,
    dwWin16LockCnt: u32,
    dwUnused3: u32,
    hInstance: u32,
    dwEvent16: u32,
    dwSaveNumModes: u32,
    lpD3DGlobalDriverData: usize,
    lpD3DHALCallbacks: usize,
    ddBothCaps: DDCORECAPS,
    lpDDVideoPortCaps: *DDVIDEOPORTCAPS,
    dvpList: *DDRAWI_DDVIDEOPORT_INT,
    lpD3DHALCallbacks2: usize,
    rectDevice: RECT,
    cMonitors: u32,
    gpbmiSrc: *c_void,
    gpbmiDest: *c_void,
    phaiHeapAliases: *HEAPALIASINFO,
    hKernelHandle: usize,
    pfnNotifyProc: usize,
    lpDDKernelCaps: *DDKERNELCAPS,
    lpddNLVCaps: *DDNONLOCALVIDMEMCAPS,
    lpddNLVHELCaps: *DDNONLOCALVIDMEMCAPS,
    lpddNLVBothCaps: *DDNONLOCALVIDMEMCAPS,
    lpD3DExtendedCaps: usize,
    dwDOSBoxEvent: u32,
    rectDesktop: RECT,
    cDriverName: [32]CHAR,
    lpD3DHALCallbacks3: usize,
    dwNumZPixelFormats: u32,
    lpZPixelFormats: *DDPIXELFORMAT,
    mcList: *DDRAWI_DDMOTIONCOMP_INT,
    hDDVxd: u32,
    ddsCapsMore: DDSCAPSEX,
};

pub const DDRAWI_DIRECTDRAW_LCL = extern struct {
    lpDDMore: u32,
    lpGbl: *DDRAWI_DIRECTDRAW_GBL,
    dwUnused0: u32,
    dwLocalFlags: u32,
    dwLocalRefCnt: u32,
    dwProcessId: u32,
    pUnkOuter: *IUnknown,
    dwObsolete1: u32,
    hWnd: usize,
    hDC: usize,
    dwErrorMode: u32,
    lpPrimary: *DDRAWI_DDRAWSURFACE_INT,
    lpCB: *DDRAWI_DDRAWSURFACE_INT,
    dwPreferredMode: u32,
    hD3DInstance: HINSTANCE,
    pD3DIUnknown: *IUnknown,
    lpDDCB: *DDHAL_CALLBACKS,
    hDDVxd: usize,
    dwAppHackFlags: u32,
    hFocusWnd: usize,
    dwHotTracking: u32,
    dwIMEState: u32,
    hWndPopup: usize,
    hDD: usize,
    hGammaCalibrator: usize,
    lpGammaCalibrator: LPDDGAMMACALIBRATORPROC,
};

pub const DDRAWI_DDVIDEOPORT_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDVIDEOPORT_LCL,
    lpLink: *DDRAWI_DDVIDEOPORT_INT,
    dwIntRefCnt: u32,
    dwFlags: u32,
};

pub const DDRAWI_DDVIDEOPORT_LCL = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    ddvpDesc: DDVIDEOPORTDESC,
    ddvpInfo: DDVIDEOPORTINFO,
    lpSurface: *DDRAWI_DDRAWSURFACE_INT,
    lpVBISurface: *DDRAWI_DDRAWSURFACE_INT,
    lpFlipInts: **DDRAWI_DDRAWSURFACE_INT,
    dwNumAutoflip: u32,
    dwProcessID: u32,
    dwStateFlags: u32,
    dwFlags: u32,
    dwRefCnt: u32,
    fpLastFlip: usize,
    dwReserved1: usize,
    dwReserved2: usize,
    hDDVideoPort: HANDLE,
    dwNumVBIAutoflip: u32,
    lpVBIDesc: *DDVIDEOPORTDESC,
    lpVideoDesc: *DDVIDEOPORTDESC,
    lpVBIInfo: *DDVIDEOPORTINFO,
    lpVideoInfo: *DDVIDEOPORTINFO,
    dwVBIProcessID: u32,
    lpVPNotify: *DDRAWI_DDVIDEOPORT_INT,
};

pub const DDRAWI_DDMOTIONCOMP_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDMOTIONCOMP_LCL,
    lpLink: *DDRAWI_DDMOTIONCOMP_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDMOTIONCOMP_LCL = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    guid: Guid,
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
    dwInternalFlags: u32,
    dwRefCnt: u32,
    dwProcessId: u32,
    hMoComp: HANDLE,
    dwDriverReserved1: u32,
    dwDriverReserved2: u32,
    dwDriverReserved3: u32,
    lpDriverReserved1: *c_void,
    lpDriverReserved2: *c_void,
    lpDriverReserved3: *c_void,
};

pub const DDHALINFO = extern struct {
    dwSize: u32,
    lpDDCallbacks: *DDHAL_DDCALLBACKS,
    lpDDSurfaceCallbacks: *DDHAL_DDSURFACECALLBACKS,
    lpDDPaletteCallbacks: *DDHAL_DDPALETTECALLBACKS,
    vmiData: VIDMEMINFO,
    ddCaps: DDCORECAPS,
    dwMonitorFrequency: u32,
    GetDriverInfo: LPDDHAL_GETDRIVERINFO,
    dwModeIndex: u32,
    lpdwFourCC: *u32,
    dwNumModes: u32,
    lpModeInfo: *DDHALMODEINFO,
    dwFlags: u32,
    lpPDevice: *c_void,
    hInstance: u32,
    lpD3DGlobalDriverData: usize,
    lpD3DHALCallbacks: usize,
    lpDDExeBufCallbacks: *DDHAL_DDEXEBUFCALLBACKS,
};

pub const LPDDHAL_SETINFO = fn(
    lpDDHalInfo: *DDHALINFO,
    reset: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPDDHAL_VIDMEMALLOC = fn(
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    heap: i32,
    dwWidth: u32,
    dwHeight: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPDDHAL_VIDMEMFREE = fn(
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    heap: i32,
    fpMem: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DDHALDDRAWFNS = extern struct {
    dwSize: u32,
    lpSetInfo: LPDDHAL_SETINFO,
    lpVidMemAlloc: LPDDHAL_VIDMEMALLOC,
    lpVidMemFree: LPDDHAL_VIDMEMFREE,
};

pub const DDHAL_BLTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rDest: RECTL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rSrc: RECTL,
    dwFlags: u32,
    dwROPFlags: u32,
    bltFX: DDBLTFX,
    ddRVal: HRESULT,
    Blt: LPDDHALSURFCB_BLT,
    IsClipped: BOOL,
    rOrigDest: RECTL,
    rOrigSrc: RECTL,
    dwRectCnt: u32,
    prDestRects: *RECT,
};

pub const DDHAL_LOCKDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    bHasRect: u32,
    rArea: RECTL,
    lpSurfData: *c_void,
    ddRVal: HRESULT,
    Lock: LPDDHALSURFCB_LOCK,
    dwFlags: u32,
};

pub const DDHAL_UNLOCKDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    Unlock: LPDDHALSURFCB_UNLOCK,
};

pub const DDHAL_UPDATEOVERLAYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rDest: RECTL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rSrc: RECTL,
    dwFlags: u32,
    overlayFX: DDOVERLAYFX,
    ddRVal: HRESULT,
    UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
};

pub const DDHAL_SETOVERLAYPOSITIONDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lXPos: i32,
    lYPos: i32,
    ddRVal: HRESULT,
    SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
};

pub const DDHAL_SETPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    ddRVal: HRESULT,
    SetPalette: LPDDHALSURFCB_SETPALETTE,
    Attach: BOOL,
};

pub const DDHAL_FLIPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpSurfCurr: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTarg: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    Flip: LPDDHALSURFCB_FLIP,
    lpSurfCurrLeft: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTargLeft: *DDRAWI_DDRAWSURFACE_LCL,
};

pub const DDHAL_DESTROYSURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
};

pub const DDHAL_SETCLIPLISTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    SetClipList: LPDDHALSURFCB_SETCLIPLIST,
};

pub const DDHAL_ADDATTACHEDSURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfAttached: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
};

pub const DDHAL_SETCOLORKEYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
};

pub const DDHAL_GETBLTSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
};

pub const DDHAL_GETFLIPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
};

pub const DDHAL_DESTROYPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    ddRVal: HRESULT,
    DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
};

pub const DDHAL_SETENTRIESDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    dwBase: u32,
    dwNumEntries: u32,
    lpEntries: *PALETTEENTRY,
    ddRVal: HRESULT,
    SetEntries: LPDDHALPALCB_SETENTRIES,
};

pub const DDHAL_CREATESURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurfaceDesc: *DDSURFACEDESC,
    lplpSList: **DDRAWI_DDRAWSURFACE_LCL,
    dwSCnt: u32,
    ddRVal: HRESULT,
    CreateSurface: LPDDHAL_CREATESURFACE,
};

pub const DDHAL_CANCREATESURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurfaceDesc: *DDSURFACEDESC,
    bIsDifferentPixelFormat: u32,
    ddRVal: HRESULT,
    CanCreateSurface: LPDDHAL_CANCREATESURFACE,
};

pub const DDHAL_CREATEPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    lpColorTable: *PALETTEENTRY,
    ddRVal: HRESULT,
    CreatePalette: LPDDHAL_CREATEPALETTE,
    is_excl: BOOL,
};

pub const DDHAL_DESTROYDRIVERDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    ddRVal: HRESULT,
    DestroyDriver: LPDDHAL_DESTROYDRIVER,
};

pub const DDHAL_SETMODEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwModeIndex: u32,
    ddRVal: HRESULT,
    SetMode: LPDDHAL_SETMODE,
    inexcl: BOOL,
    useRefreshRate: BOOL,
};

pub const DDHAL_DRVSETCOLORKEYDATA = extern struct {
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: LPDDHAL_SETCOLORKEY,
};

pub const DDHAL_GETSCANLINEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwScanLine: u32,
    ddRVal: HRESULT,
    GetScanLine: LPDDHAL_GETSCANLINE,
};

pub const DDHAL_SETEXCLUSIVEMODEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwEnterExcl: u32,
    dwReserved: u32,
    ddRVal: HRESULT,
    SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
};

pub const DDHAL_FLIPTOGDISURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwToGDI: u32,
    dwReserved: u32,
    ddRVal: HRESULT,
    FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
};

pub const DDHAL_CANCREATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDVideoPortDesc: *DDVIDEOPORTDESC,
    ddRVal: HRESULT,
    CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
};

pub const DDHAL_CREATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDVideoPortDesc: *DDVIDEOPORTDESC,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    ddRVal: HRESULT,
    CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
};

pub const DDHAL_FLIPVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpSurfCurr: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTarg: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    FlipVideoPort: LPDDHALVPORTCB_FLIP,
};

pub const DDHAL_GETVPORTBANDWIDTHDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpddpfFormat: *DDPIXELFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwFlags: u32,
    lpBandwidth: *DDVIDEOPORTBANDWIDTH,
    ddRVal: HRESULT,
    GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
};

pub const DDHAL_GETVPORTINPUTFORMATDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpddpfFormat: *DDPIXELFORMAT,
    dwNumFormats: u32,
    ddRVal: HRESULT,
    GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
};

pub const DDHAL_GETVPORTOUTPUTFORMATDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpddpfInputFormat: *DDPIXELFORMAT,
    lpddpfOutputFormats: *DDPIXELFORMAT,
    dwNumFormats: u32,
    ddRVal: HRESULT,
    GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
};

pub const DDHAL_GETVPORTFIELDDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    bField: BOOL,
    ddRVal: HRESULT,
    GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
};

pub const DDHAL_GETVPORTLINEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwLine: u32,
    ddRVal: HRESULT,
    GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
};

pub const DDHAL_GETVPORTCONNECTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    dwPortId: u32,
    lpConnect: *DDVIDEOPORTCONNECT,
    dwNumEntries: u32,
    ddRVal: HRESULT,
    GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
};

pub const DDHAL_DESTROYVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    ddRVal: HRESULT,
    DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
};

pub const DDHAL_GETVPORTFLIPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    fpSurface: usize,
    ddRVal: HRESULT,
    GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
};

pub const DDHAL_UPDATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lplpDDSurface: **DDRAWI_DDRAWSURFACE_INT,
    lplpDDVBISurface: **DDRAWI_DDRAWSURFACE_INT,
    lpVideoInfo: *DDVIDEOPORTINFO,
    dwFlags: u32,
    dwNumAutoflip: u32,
    dwNumVBIAutoflip: u32,
    ddRVal: HRESULT,
    UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
};

pub const DDHAL_WAITFORVPORTSYNCDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    dwLine: u32,
    dwTimeOut: u32,
    ddRVal: HRESULT,
    WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
};

pub const DDHAL_GETVPORTSIGNALDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwStatus: u32,
    ddRVal: HRESULT,
    GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
};

pub const DDHAL_VPORTCOLORDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpColorData: *DDCOLORCONTROL,
    ddRVal: HRESULT,
    ColorControl: LPDDHALVPORTCB_COLORCONTROL,
};

pub const DDHAL_COLORCONTROLDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpColorData: *DDCOLORCONTROL,
    dwFlags: u32,
    ddRVal: HRESULT,
    ColorControl: LPDDHALCOLORCB_COLORCONTROL,
};

pub const DDHAL_GETDRIVERINFODATA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    guidInfo: Guid,
    dwExpectedSize: u32,
    lpvData: *c_void,
    dwActualSize: u32,
    ddRVal: HRESULT,
    dwContext: usize,
};

pub const DDHAL_GETAVAILDRIVERMEMORYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    DDSCaps: DDSCAPS,
    dwTotal: u32,
    dwFree: u32,
    ddRVal: HRESULT,
    GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    ddsCapsEx: DDSCAPSEX,
};

pub const DDHAL_UPDATENONLOCALHEAPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwHeap: u32,
    fpGARTLin: usize,
    fpGARTDev: usize,
    ulPolicyMaxBytes: usize,
    ddRVal: HRESULT,
    UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
};

pub const DDHAL_GETHEAPALIGNMENTDATA = extern struct {
    dwInstance: usize,
    dwHeap: u32,
    ddRVal: HRESULT,
    GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    Alignment: HEAPALIGNMENT,
};

pub const DDHAL_CREATESURFACEEXDATA = extern struct {
    dwFlags: u32,
    lpDDLcl: *DDRAWI_DIRECTDRAW_LCL,
    lpDDSLcl: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
};

pub const DDHAL_GETDRIVERSTATEDATA = extern struct {
    dwFlags: u32,
    Anonymous: _Anonymous_e__Union,
    lpdwStates: *u32,
    dwLength: u32,
    ddRVal: HRESULT,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDHAL_SYNCSURFACEDATA = extern struct {
    dwSize: u32,
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwSurfaceOffset: u32,
    fpLockPtr: usize,
    lPitch: i32,
    dwOverlayOffset: u32,
    dwOverlaySrcWidth: u32,
    dwOverlaySrcHeight: u32,
    dwOverlayDestWidth: u32,
    dwOverlayDestHeight: u32,
    dwDriverReserved1: usize,
    dwDriverReserved2: usize,
    dwDriverReserved3: usize,
    ddRVal: HRESULT,
};

pub const DDHAL_SYNCVIDEOPORTDATA = extern struct {
    dwSize: u32,
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwOriginOffset: u32,
    dwHeight: u32,
    dwVBIHeight: u32,
    dwDriverReserved1: usize,
    dwDriverReserved2: usize,
    dwDriverReserved3: usize,
    ddRVal: HRESULT,
};

pub const DDHAL_GETMOCOMPGUIDSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    dwNumGuids: u32,
    lpGuids: *Guid,
    ddRVal: HRESULT,
    GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
};

pub const DDHAL_GETMOCOMPFORMATSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwNumFormats: u32,
    lpFormats: *DDPIXELFORMAT,
    ddRVal: HRESULT,
    GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
};

pub const DDHAL_CREATEMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpGuid: *Guid,
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
    lpData: *c_void,
    dwDataSize: u32,
    ddRVal: HRESULT,
    CreateMoComp: LPDDHALMOCOMPCB_CREATE,
};

pub const DDMCCOMPBUFFERINFO = extern struct {
    dwSize: u32,
    dwNumCompBuffers: u32,
    dwWidthToCreate: u32,
    dwHeightToCreate: u32,
    dwBytesToAllocate: u32,
    ddCompCaps: DDSCAPS2,
    ddPixelFormat: DDPIXELFORMAT,
};

pub const DDHAL_GETMOCOMPCOMPBUFFDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwWidth: u32,
    dwHeight: u32,
    ddPixelFormat: DDPIXELFORMAT,
    dwNumTypesCompBuffs: u32,
    lpCompBuffInfo: *DDMCCOMPBUFFERINFO,
    ddRVal: HRESULT,
    GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
};

pub const DDHAL_GETINTERNALMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwWidth: u32,
    dwHeight: u32,
    ddPixelFormat: DDPIXELFORMAT,
    dwScratchMemAlloc: u32,
    ddRVal: HRESULT,
    GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
};

pub const DDHAL_BEGINMOCOMPFRAMEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwInputDataSize: u32,
    lpInputData: *c_void,
    dwOutputDataSize: u32,
    lpOutputData: *c_void,
    ddRVal: HRESULT,
    BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
};

pub const DDHAL_ENDMOCOMPFRAMEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpInputData: *c_void,
    dwInputDataSize: u32,
    ddRVal: HRESULT,
    EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
};

pub const DDMCBUFFERINFO = extern struct {
    dwSize: u32,
    lpCompSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwDataOffset: u32,
    dwDataSize: u32,
    lpPrivate: *c_void,
};

pub const DDHAL_RENDERMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    dwNumBuffers: u32,
    lpBufferInfo: *DDMCBUFFERINFO,
    dwFunction: u32,
    lpInputData: *c_void,
    dwInputDataSize: u32,
    lpOutputData: *c_void,
    dwOutputDataSize: u32,
    ddRVal: HRESULT,
    RenderMoComp: LPDDHALMOCOMPCB_RENDER,
};

pub const DDHAL_QUERYMOCOMPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
};

pub const DDHAL_DESTROYMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    ddRVal: HRESULT,
    DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
};

pub const PFNCHECKCONNECTIONWIZARD = fn(
    param0: u32,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNSETSHELLNEXT = fn(
    param0: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const STRENTRYA = extern struct {
    pszName: PSTR,
    pszValue: PSTR,
};

pub const STRENTRYW = extern struct {
    pszName: PWSTR,
    pszValue: PWSTR,
};

pub const STRTABLEA = extern struct {
    cEntries: u32,
    pse: *STRENTRYA,
};

pub const STRTABLEW = extern struct {
    cEntries: u32,
    pse: *STRENTRYW,
};

pub const REGINSTALLA = fn(
    hm: isize,
    pszSection: [*:0]const u8,
    pstTable: *STRTABLEA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CABINFOA = extern struct {
    pszCab: PSTR,
    pszInf: PSTR,
    pszSection: PSTR,
    szSrcPath: [260]CHAR,
    dwFlags: u32,
};

pub const CABINFOW = extern struct {
    pszCab: PWSTR,
    pszInf: PWSTR,
    pszSection: PWSTR,
    szSrcPath: [260]u16,
    dwFlags: u32,
};

pub const PERUSERSECTIONA = extern struct {
    szGUID: [59]CHAR,
    szDispName: [128]CHAR,
    szLocale: [10]CHAR,
    szStub: [1040]CHAR,
    szVersion: [32]CHAR,
    szCompID: [128]CHAR,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const PERUSERSECTIONW = extern struct {
    szGUID: [59]u16,
    szDispName: [128]u16,
    szLocale: [10]u16,
    szStub: [1040]u16,
    szVersion: [32]u16,
    szCompID: [128]u16,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const IMESTRUCT = extern struct {
    fnc: u32,
    wParam: WPARAM,
    wCount: u32,
    dchSource: u32,
    dchDest: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParam3: LPARAM,
};

pub const UNDETERMINESTRUCT = extern struct {
    dwSize: u32,
    uDefIMESize: u32,
    uDefIMEPos: u32,
    uUndetTextLen: u32,
    uUndetTextPos: u32,
    uUndetAttrPos: u32,
    uCursorPos: u32,
    uDeltaStart: u32,
    uDetermineTextLen: u32,
    uDetermineTextPos: u32,
    uDetermineDelimPos: u32,
    uYomiTextLen: u32,
    uYomiTextPos: u32,
    uYomiDelimPos: u32,
};

pub const STRINGEXSTRUCT = extern struct {
    dwSize: u32,
    uDeterminePos: u32,
    uDetermineDelimPos: u32,
    uYomiPos: u32,
    uYomiDelimPos: u32,
};

pub const DATETIME = extern struct {
    year: u16,
    month: u16,
    day: u16,
    hour: u16,
    min: u16,
    sec: u16,
};

pub const IMEPROA = extern struct {
    hWnd: HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u8,
    szName: [80]u8,
    szOptions: [30]u8,
};

pub const IMEPROW = extern struct {
    hWnd: HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u16,
    szName: [80]u16,
    szOptions: [30]u16,
};

const CLSID_WebBrowser_V1_Value = @import("../zig.zig").Guid.initString("eab22ac3-30c1-11cf-a7eb-0000c05bae0b");
pub const CLSID_WebBrowser_V1 = &CLSID_WebBrowser_V1_Value;

const CLSID_WebBrowser_Value = @import("../zig.zig").Guid.initString("8856f961-340a-11d0-a96b-00c04fd705a2");
pub const CLSID_WebBrowser = &CLSID_WebBrowser_Value;

const CLSID_InternetExplorer_Value = @import("../zig.zig").Guid.initString("0002df01-0000-0000-c000-000000000046");
pub const CLSID_InternetExplorer = &CLSID_InternetExplorer_Value;

const CLSID_InternetExplorerMedium_Value = @import("../zig.zig").Guid.initString("d5e8041d-920f-45e9-b8fb-b1deb82c6e5e");
pub const CLSID_InternetExplorerMedium = &CLSID_InternetExplorerMedium_Value;

const CLSID_ShellBrowserWindow_Value = @import("../zig.zig").Guid.initString("c08afd90-f2a1-11d1-8455-00a0c91f3880");
pub const CLSID_ShellBrowserWindow = &CLSID_ShellBrowserWindow_Value;

const CLSID_ShellWindows_Value = @import("../zig.zig").Guid.initString("9ba05972-f6a8-11cf-a442-00a0c90a8f39");
pub const CLSID_ShellWindows = &CLSID_ShellWindows_Value;

const CLSID_ShellUIHelper_Value = @import("../zig.zig").Guid.initString("64ab4bb7-111e-11d1-8f79-00c04fc2fbe1");
pub const CLSID_ShellUIHelper = &CLSID_ShellUIHelper_Value;

const CLSID_ShellNameSpace_Value = @import("../zig.zig").Guid.initString("55136805-b2de-11d1-b9f2-00a0c98bc547");
pub const CLSID_ShellNameSpace = &CLSID_ShellNameSpace_Value;

const CLSID_CScriptErrorList_Value = @import("../zig.zig").Guid.initString("efd01300-160f-11d2-bb2e-00805ff7efca");
pub const CLSID_CScriptErrorList = &CLSID_CScriptErrorList_Value;

pub const CommandStateChangeConstants = extern enum(i32) {
    UPDATECOMMANDS = -1,
    NAVIGATEFORWARD = 1,
    NAVIGATEBACK = 2,
};
pub const CSC_UPDATECOMMANDS = CommandStateChangeConstants.UPDATECOMMANDS;
pub const CSC_NAVIGATEFORWARD = CommandStateChangeConstants.NAVIGATEFORWARD;
pub const CSC_NAVIGATEBACK = CommandStateChangeConstants.NAVIGATEBACK;

pub const SecureLockIconConstants = extern enum(i32) {
    Unsecure = 0,
    Mixed = 1,
    SecureUnknownBits = 2,
    Secure40Bit = 3,
    Secure56Bit = 4,
    SecureFortezza = 5,
    Secure128Bit = 6,
};
pub const secureLockIconUnsecure = SecureLockIconConstants.Unsecure;
pub const secureLockIconMixed = SecureLockIconConstants.Mixed;
pub const secureLockIconSecureUnknownBits = SecureLockIconConstants.SecureUnknownBits;
pub const secureLockIconSecure40Bit = SecureLockIconConstants.Secure40Bit;
pub const secureLockIconSecure56Bit = SecureLockIconConstants.Secure56Bit;
pub const secureLockIconSecureFortezza = SecureLockIconConstants.SecureFortezza;
pub const secureLockIconSecure128Bit = SecureLockIconConstants.Secure128Bit;

pub const NewProcessCauseConstants = extern enum(i32) {
    t = 1,
};
pub const ProtectedModeRedirect = NewProcessCauseConstants.t;

pub const BrowserNavConstants = extern enum(i32) {
    OpenInNewWindow = 1,
    NoHistory = 2,
    NoReadFromCache = 4,
    NoWriteToCache = 8,
    AllowAutosearch = 16,
    BrowserBar = 32,
    Hyperlink = 64,
    EnforceRestricted = 128,
    NewWindowsManaged = 256,
    UntrustedForDownload = 512,
    TrustedForActiveX = 1024,
    OpenInNewTab = 2048,
    OpenInBackgroundTab = 4096,
    KeepWordWheelText = 8192,
    VirtualTab = 16384,
    BlockRedirectsXDomain = 32768,
    OpenNewForegroundTab = 65536,
    TravelLogScreenshot = 131072,
    DeferUnload = 262144,
    Speculative = 524288,
    SuggestNewWindow = 1048576,
    SuggestNewTab = 2097152,
    Reserved1 = 4194304,
    HomepageNavigate = 8388608,
    Refresh = 16777216,
    HostNavigation = 33554432,
    Reserved2 = 67108864,
    Reserved3 = 134217728,
    Reserved4 = 268435456,
    Reserved5 = 536870912,
    Reserved6 = 1073741824,
    Reserved7 = -2147483648,
};
pub const navOpenInNewWindow = BrowserNavConstants.OpenInNewWindow;
pub const navNoHistory = BrowserNavConstants.NoHistory;
pub const navNoReadFromCache = BrowserNavConstants.NoReadFromCache;
pub const navNoWriteToCache = BrowserNavConstants.NoWriteToCache;
pub const navAllowAutosearch = BrowserNavConstants.AllowAutosearch;
pub const navBrowserBar = BrowserNavConstants.BrowserBar;
pub const navHyperlink = BrowserNavConstants.Hyperlink;
pub const navEnforceRestricted = BrowserNavConstants.EnforceRestricted;
pub const navNewWindowsManaged = BrowserNavConstants.NewWindowsManaged;
pub const navUntrustedForDownload = BrowserNavConstants.UntrustedForDownload;
pub const navTrustedForActiveX = BrowserNavConstants.TrustedForActiveX;
pub const navOpenInNewTab = BrowserNavConstants.OpenInNewTab;
pub const navOpenInBackgroundTab = BrowserNavConstants.OpenInBackgroundTab;
pub const navKeepWordWheelText = BrowserNavConstants.KeepWordWheelText;
pub const navVirtualTab = BrowserNavConstants.VirtualTab;
pub const navBlockRedirectsXDomain = BrowserNavConstants.BlockRedirectsXDomain;
pub const navOpenNewForegroundTab = BrowserNavConstants.OpenNewForegroundTab;
pub const navTravelLogScreenshot = BrowserNavConstants.TravelLogScreenshot;
pub const navDeferUnload = BrowserNavConstants.DeferUnload;
pub const navSpeculative = BrowserNavConstants.Speculative;
pub const navSuggestNewWindow = BrowserNavConstants.SuggestNewWindow;
pub const navSuggestNewTab = BrowserNavConstants.SuggestNewTab;
pub const navReserved1 = BrowserNavConstants.Reserved1;
pub const navHomepageNavigate = BrowserNavConstants.HomepageNavigate;
pub const navRefresh = BrowserNavConstants.Refresh;
pub const navHostNavigation = BrowserNavConstants.HostNavigation;
pub const navReserved2 = BrowserNavConstants.Reserved2;
pub const navReserved3 = BrowserNavConstants.Reserved3;
pub const navReserved4 = BrowserNavConstants.Reserved4;
pub const navReserved5 = BrowserNavConstants.Reserved5;
pub const navReserved6 = BrowserNavConstants.Reserved6;
pub const navReserved7 = BrowserNavConstants.Reserved7;

pub const RefreshConstants = extern enum(i32) {
    NORMAL = 0,
    IFEXPIRED = 1,
    COMPLETELY = 3,
};
pub const REFRESH_NORMAL = RefreshConstants.NORMAL;
pub const REFRESH_IFEXPIRED = RefreshConstants.IFEXPIRED;
pub const REFRESH_COMPLETELY = RefreshConstants.COMPLETELY;

const IID_IWebBrowser_Value = @import("../zig.zig").Guid.initString("eab22ac1-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_IWebBrowser = &IID_IWebBrowser_Value;
pub const IWebBrowser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GoBack: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoForward: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoHome: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoSearch: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IWebBrowser,
            URL: BSTR,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh2: fn(
            self: *const IWebBrowser,
            Level: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopLevelContainer: fn(
            self: *const IWebBrowser,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IWebBrowser,
            Type: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: fn(
            self: *const IWebBrowser,
            Left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: fn(
            self: *const IWebBrowser,
            Top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: fn(
            self: *const IWebBrowser,
            Width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: fn(
            self: *const IWebBrowser,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationName: fn(
            self: *const IWebBrowser,
            LocationName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationURL: fn(
            self: *const IWebBrowser,
            LocationURL: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Busy: fn(
            self: *const IWebBrowser,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoBack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoBack(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoForward(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoForward(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoHome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoHome(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoSearch(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Navigate(self: *const T, URL: BSTR, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Navigate(@ptrCast(*const IWebBrowser, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh2(self: *const T, Level: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh2(@ptrCast(*const IWebBrowser, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Stop(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Application(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Application(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Parent(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Parent(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Container(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Container(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Document(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Document(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_TopLevelContainer(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_TopLevelContainer(@ptrCast(*const IWebBrowser, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Type(self: *const T, Type: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Type(@ptrCast(*const IWebBrowser, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Left(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Left(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Left(self: *const T, Left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Left(@ptrCast(*const IWebBrowser, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Top(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Top(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Top(self: *const T, Top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Top(@ptrCast(*const IWebBrowser, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Width(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Width(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Width(@ptrCast(*const IWebBrowser, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Height(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Height(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Height(self: *const T, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Height(@ptrCast(*const IWebBrowser, self), Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationName(self: *const T, LocationName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationName(@ptrCast(*const IWebBrowser, self), LocationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationURL(self: *const T, LocationURL: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationURL(@ptrCast(*const IWebBrowser, self), LocationURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Busy(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Busy(@ptrCast(*const IWebBrowser, self), pBool);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents_Value = @import("../zig.zig").Guid.initString("eab22ac2-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_DWebBrowserEvents = &IID_DWebBrowserEvents_Value;
pub const DWebBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserApp_Value = @import("../zig.zig").Guid.initString("0002df05-0000-0000-c000-000000000046");
pub const IID_IWebBrowserApp = &IID_IWebBrowserApp_Value;
pub const IWebBrowserApp = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowser.VTable,
        Quit: fn(
            self: *const IWebBrowserApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClientToWindow: fn(
            self: *const IWebBrowserApp,
            pcx: *i32,
            pcy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutProperty: fn(
            self: *const IWebBrowserApp,
            Property: BSTR,
            vtValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IWebBrowserApp,
            Property: BSTR,
            pvtValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IWebBrowserApp,
            Name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: fn(
            self: *const IWebBrowserApp,
            pHWND: *SHANDLE_PTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullName: fn(
            self: *const IWebBrowserApp,
            FullName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IWebBrowserApp,
            Path: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: fn(
            self: *const IWebBrowserApp,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusBar: fn(
            self: *const IWebBrowserApp,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreen: fn(
            self: *const IWebBrowserApp,
            pbFullScreen: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreen: fn(
            self: *const IWebBrowserApp,
            bFullScreen: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_Quit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).Quit(@ptrCast(*const IWebBrowserApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_ClientToWindow(self: *const T, pcx: *i32, pcy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).ClientToWindow(@ptrCast(*const IWebBrowserApp, self), pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_PutProperty(self: *const T, Property: BSTR, vtValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).PutProperty(@ptrCast(*const IWebBrowserApp, self), Property, vtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_GetProperty(self: *const T, Property: BSTR, pvtValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).GetProperty(@ptrCast(*const IWebBrowserApp, self), Property, pvtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Name(self: *const T, Name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Name(@ptrCast(*const IWebBrowserApp, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_HWND(self: *const T, pHWND: *SHANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_HWND(@ptrCast(*const IWebBrowserApp, self), pHWND);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullName(self: *const T, FullName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullName(@ptrCast(*const IWebBrowserApp, self), FullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Path(self: *const T, Path: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Path(@ptrCast(*const IWebBrowserApp, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Visible(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Visible(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_Visible(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_Visible(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusBar(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusBar(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusText(self: *const T, StatusText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusText(self: *const T, StatusText: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_ToolBar(self: *const T, Value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_ToolBar(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_MenuBar(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_MenuBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullScreen(self: *const T, pbFullScreen: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullScreen(@ptrCast(*const IWebBrowserApp, self), pbFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_FullScreen(self: *const T, bFullScreen: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_FullScreen(@ptrCast(*const IWebBrowserApp, self), bFullScreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebBrowser2_Value = @import("../zig.zig").Guid.initString("d30c1661-cdaf-11d0-8a3e-00c04fc9e26e");
pub const IID_IWebBrowser2 = &IID_IWebBrowser2_Value;
pub const IWebBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowserApp.VTable,
        Navigate2: fn(
            self: *const IWebBrowser2,
            URL: *VARIANT,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatusWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            pcmdf: *OLECMDF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            cmdexecopt: OLECMDEXECOPT,
            pvaIn: ?*VARIANT,
            pvaOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserBar: fn(
            self: *const IWebBrowser2,
            pvaClsid: *VARIANT,
            pvarShow: ?*VARIANT,
            pvarSize: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadyState: fn(
            self: *const IWebBrowser2,
            plReadyState: *READYSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Offline: fn(
            self: *const IWebBrowser2,
            pbOffline: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Offline: fn(
            self: *const IWebBrowser2,
            bOffline: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IWebBrowser2,
            pbSilent: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IWebBrowser2,
            bSilent: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TheaterMode: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TheaterMode: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Resizable: fn(
            self: *const IWebBrowser2,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Resizable: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowserApp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_Navigate2(self: *const T, URL: *VARIANT, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).Navigate2(@ptrCast(*const IWebBrowser2, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_QueryStatusWB(self: *const T, cmdID: OLECMDID, pcmdf: *OLECMDF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).QueryStatusWB(@ptrCast(*const IWebBrowser2, self), cmdID, pcmdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ExecWB(self: *const T, cmdID: OLECMDID, cmdexecopt: OLECMDEXECOPT, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ExecWB(@ptrCast(*const IWebBrowser2, self), cmdID, cmdexecopt, pvaIn, pvaOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ShowBrowserBar(self: *const T, pvaClsid: *VARIANT, pvarShow: ?*VARIANT, pvarSize: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ShowBrowserBar(@ptrCast(*const IWebBrowser2, self), pvaClsid, pvarShow, pvarSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_ReadyState(self: *const T, plReadyState: *READYSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_ReadyState(@ptrCast(*const IWebBrowser2, self), plReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Offline(self: *const T, pbOffline: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Offline(@ptrCast(*const IWebBrowser2, self), pbOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Offline(self: *const T, bOffline: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Offline(@ptrCast(*const IWebBrowser2, self), bOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Silent(self: *const T, pbSilent: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Silent(@ptrCast(*const IWebBrowser2, self), pbSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Silent(self: *const T, bSilent: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Silent(@ptrCast(*const IWebBrowser2, self), bSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsBrowser(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsBrowser(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsDropTarget(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsDropTarget(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_TheaterMode(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_TheaterMode(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_TheaterMode(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_TheaterMode(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_AddressBar(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_AddressBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Resizable(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Resizable(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents2_Value = @import("../zig.zig").Guid.initString("34a715a0-6587-11d0-924a-0020afc7ac4d");
pub const IID_DWebBrowserEvents2 = &IID_DWebBrowserEvents2_Value;
pub const DWebBrowserEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellWindowsEvents_Value = @import("../zig.zig").Guid.initString("fe4106e0-399a-11d0-a48c-00a0c90a8f39");
pub const IID_DShellWindowsEvents = &IID_DShellWindowsEvents_Value;
pub const DShellWindowsEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper_Value = @import("../zig.zig").Guid.initString("729fe2f8-1ea8-11d1-8f85-00c04fc2fbe1");
pub const IID_IShellUIHelper = &IID_IShellUIHelper_Value;
pub const IShellUIHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ResetFirstBootMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSafeMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshOfflineDesktop: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFavorite: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            Title: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddChannel: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDesktopComponent: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            Type: BSTR,
            Left: ?*VARIANT,
            Top: ?*VARIANT,
            Width: ?*VARIANT,
            Height: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateAndFind: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            strQuery: BSTR,
            varTargetFrame: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportExportFavorites: fn(
            self: *const IShellUIHelper,
            fImport: i16,
            strImpExpPath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteSaveForm: fn(
            self: *const IShellUIHelper,
            Form: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoScan: fn(
            self: *const IShellUIHelper,
            strSearch: BSTR,
            strFailureUrl: BSTR,
            pvarTargetFrame: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteAttach: fn(
            self: *const IShellUIHelper,
            Reserved: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserUI: fn(
            self: *const IShellUIHelper,
            bstrName: BSTR,
            pvarIn: *VARIANT,
            pvarOut: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetFirstBootMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetFirstBootMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetSafeMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetSafeMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_RefreshOfflineDesktop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).RefreshOfflineDesktop(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddFavorite(self: *const T, URL: BSTR, Title: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddFavorite(@ptrCast(*const IShellUIHelper, self), URL, Title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddChannel(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddChannel(@ptrCast(*const IShellUIHelper, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddDesktopComponent(self: *const T, URL: BSTR, Type: BSTR, Left: ?*VARIANT, Top: ?*VARIANT, Width: ?*VARIANT, Height: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddDesktopComponent(@ptrCast(*const IShellUIHelper, self), URL, Type, Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_IsSubscribed(self: *const T, URL: BSTR, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).IsSubscribed(@ptrCast(*const IShellUIHelper, self), URL, pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_NavigateAndFind(self: *const T, URL: BSTR, strQuery: BSTR, varTargetFrame: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).NavigateAndFind(@ptrCast(*const IShellUIHelper, self), URL, strQuery, varTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ImportExportFavorites(self: *const T, fImport: i16, strImpExpPath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ImportExportFavorites(@ptrCast(*const IShellUIHelper, self), fImport, strImpExpPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteSaveForm(self: *const T, Form: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteSaveForm(@ptrCast(*const IShellUIHelper, self), Form);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoScan(self: *const T, strSearch: BSTR, strFailureUrl: BSTR, pvarTargetFrame: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoScan(@ptrCast(*const IShellUIHelper, self), strSearch, strFailureUrl, pvarTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteAttach(self: *const T, Reserved: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteAttach(@ptrCast(*const IShellUIHelper, self), Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ShowBrowserUI(self: *const T, bstrName: BSTR, pvarIn: *VARIANT, pvarOut: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ShowBrowserUI(@ptrCast(*const IShellUIHelper, self), bstrName, pvarIn, pvarOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper2_Value = @import("../zig.zig").Guid.initString("a7fe6eda-1932-4281-b881-87b31b8bc52c");
pub const IID_IShellUIHelper2 = &IID_IShellUIHelper2_Value;
pub const IShellUIHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper.VTable,
        AddSearchProvider: fn(
            self: *const IShellUIHelper2,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceShown: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipRunOnce: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeSettings: fn(
            self: *const IShellUIHelper2,
            fSQM: i16,
            fPhishing: i16,
            bstrLocale: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SqmEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PhishingEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrandImageUri: fn(
            self: *const IShellUIHelper2,
            pbstrUri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipTabsWelcome: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiagnoseConnection: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeClearType: fn(
            self: *const IShellUIHelper2,
            fSet: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchProviderInstalled: fn(
            self: *const IShellUIHelper2,
            URL: BSTR,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchMigrated: fn(
            self: *const IShellUIHelper2,
            pfMigrated: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultSearchProvider: fn(
            self: *const IShellUIHelper2,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceRequiredSettingsComplete: fn(
            self: *const IShellUIHelper2,
            fComplete: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceHasShown: fn(
            self: *const IShellUIHelper2,
            pfShown: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchGuideUrl: fn(
            self: *const IShellUIHelper2,
            pbstrUrl: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_AddSearchProvider(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).AddSearchProvider(@ptrCast(*const IShellUIHelper2, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceShown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceShown(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipRunOnce(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipRunOnce(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeSettings(self: *const T, fSQM: i16, fPhishing: i16, bstrLocale: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeSettings(@ptrCast(*const IShellUIHelper2, self), fSQM, fPhishing, bstrLocale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SqmEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SqmEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_PhishingEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).PhishingEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_BrandImageUri(self: *const T, pbstrUri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).BrandImageUri(@ptrCast(*const IShellUIHelper2, self), pbstrUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipTabsWelcome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipTabsWelcome(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DiagnoseConnection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DiagnoseConnection(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeClearType(self: *const T, fSet: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeClearType(@ptrCast(*const IShellUIHelper2, self), fSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchProviderInstalled(self: *const T, URL: BSTR, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchProviderInstalled(@ptrCast(*const IShellUIHelper2, self), URL, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchMigrated(self: *const T, pfMigrated: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchMigrated(@ptrCast(*const IShellUIHelper2, self), pfMigrated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DefaultSearchProvider(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DefaultSearchProvider(@ptrCast(*const IShellUIHelper2, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceRequiredSettingsComplete(self: *const T, fComplete: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceRequiredSettingsComplete(@ptrCast(*const IShellUIHelper2, self), fComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceHasShown(self: *const T, pfShown: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceHasShown(@ptrCast(*const IShellUIHelper2, self), pfShown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SearchGuideUrl(self: *const T, pbstrUrl: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SearchGuideUrl(@ptrCast(*const IShellUIHelper2, self), pbstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper3_Value = @import("../zig.zig").Guid.initString("528df2ec-d419-40bc-9b6d-dcdbf9c1b25d");
pub const IID_IShellUIHelper3 = &IID_IShellUIHelper3_Value;
pub const IShellUIHelper3 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper2.VTable,
        AddService: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsServiceInstalled: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
            Verb: BSTR,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPrivateFilteringEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToFavoritesBar: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
            Title: BSTR,
            Type: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildNewTabPage: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecentlyClosedVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActivitiesVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentDiscoveryReset: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSuggestedSitesEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSuggestedSites: fn(
            self: *const IShellUIHelper3,
            fEnable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateToSuggestedSites: fn(
            self: *const IShellUIHelper3,
            bstrRelativeUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowTabsHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowInPrivateHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddService(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddService(@ptrCast(*const IShellUIHelper3, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsServiceInstalled(self: *const T, URL: BSTR, Verb: BSTR, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsServiceInstalled(@ptrCast(*const IShellUIHelper3, self), URL, Verb, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_InPrivateFilteringEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).InPrivateFilteringEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddToFavoritesBar(self: *const T, URL: BSTR, Title: BSTR, Type: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddToFavoritesBar(@ptrCast(*const IShellUIHelper3, self), URL, Title, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_BuildNewTabPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).BuildNewTabPage(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetRecentlyClosedVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetRecentlyClosedVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetActivitiesVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetActivitiesVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ContentDiscoveryReset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ContentDiscoveryReset(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsSuggestedSitesEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsSuggestedSitesEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_EnableSuggestedSites(self: *const T, fEnable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).EnableSuggestedSites(@ptrCast(*const IShellUIHelper3, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_NavigateToSuggestedSites(self: *const T, bstrRelativeUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).NavigateToSuggestedSites(@ptrCast(*const IShellUIHelper3, self), bstrRelativeUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowTabsHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowTabsHelp(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowInPrivateHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowInPrivateHelp(@ptrCast(*const IShellUIHelper3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper4_Value = @import("../zig.zig").Guid.initString("b36e6a53-8073-499e-824c-d776330a333e");
pub const IID_IShellUIHelper4 = &IID_IShellUIHelper4_Value;
pub const IShellUIHelper4 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper3.VTable,
        msIsSiteMode: fn(
            self: *const IShellUIHelper4,
            pfSiteMode: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowThumbBar: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddThumbBarButton: fn(
            self: *const IShellUIHelper4,
            bstrIconURL: BSTR,
            bstrTooltip: BSTR,
            pvarButtonID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeUpdateThumbBarButton: fn(
            self: *const IShellUIHelper4,
            ButtonID: VARIANT,
            fEnabled: i16,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeSetIconOverlay: fn(
            self: *const IShellUIHelper4,
            IconUrl: BSTR,
            pvarDescription: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearIconOverlay: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddSiteMode: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeCreateJumpList: fn(
            self: *const IShellUIHelper4,
            bstrHeader: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddJumpListItem: fn(
            self: *const IShellUIHelper4,
            bstrName: BSTR,
            bstrActionUri: BSTR,
            bstrIconUri: BSTR,
            pvarWindowType: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            bstrIconUrl: BSTR,
            bstrTooltip: BSTR,
            pvarStyleID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            uiStyleID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeActivate: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msIsSiteModeFirstRun: fn(
            self: *const IShellUIHelper4,
            fPreserveState: i16,
            puiFirstRun: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddTrackingProtectionList: fn(
            self: *const IShellUIHelper4,
            URL: BSTR,
            bstrFilterName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msTrackingProtectionEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msActiveXFilteringEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteMode(self: *const T, pfSiteMode: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteMode(@ptrCast(*const IShellUIHelper4, self), pfSiteMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowThumbBar(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowThumbBar(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddThumbBarButton(self: *const T, bstrIconURL: BSTR, bstrTooltip: BSTR, pvarButtonID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddThumbBarButton(@ptrCast(*const IShellUIHelper4, self), bstrIconURL, bstrTooltip, pvarButtonID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeUpdateThumbBarButton(self: *const T, ButtonID: VARIANT, fEnabled: i16, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeUpdateThumbBarButton(@ptrCast(*const IShellUIHelper4, self), ButtonID, fEnabled, fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeSetIconOverlay(self: *const T, IconUrl: BSTR, pvarDescription: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeSetIconOverlay(@ptrCast(*const IShellUIHelper4, self), IconUrl, pvarDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearIconOverlay(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearIconOverlay(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddSiteMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddSiteMode(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeCreateJumpList(self: *const T, bstrHeader: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeCreateJumpList(@ptrCast(*const IShellUIHelper4, self), bstrHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddJumpListItem(self: *const T, bstrName: BSTR, bstrActionUri: BSTR, bstrIconUri: BSTR, pvarWindowType: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddJumpListItem(@ptrCast(*const IShellUIHelper4, self), bstrName, bstrActionUri, bstrIconUri, pvarWindowType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddButtonStyle(self: *const T, uiButtonID: VARIANT, bstrIconUrl: BSTR, bstrTooltip: BSTR, pvarStyleID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, bstrIconUrl, bstrTooltip, pvarStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowButtonStyle(self: *const T, uiButtonID: VARIANT, uiStyleID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, uiStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeActivate(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteModeFirstRun(self: *const T, fPreserveState: i16, puiFirstRun: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteModeFirstRun(@ptrCast(*const IShellUIHelper4, self), fPreserveState, puiFirstRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddTrackingProtectionList(self: *const T, URL: BSTR, bstrFilterName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddTrackingProtectionList(@ptrCast(*const IShellUIHelper4, self), URL, bstrFilterName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msTrackingProtectionEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msTrackingProtectionEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msActiveXFilteringEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msActiveXFilteringEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper5_Value = @import("../zig.zig").Guid.initString("a2a08b09-103d-4d3f-b91c-ea455ca82efa");
pub const IID_IShellUIHelper5 = &IID_IShellUIHelper5_Value;
pub const IShellUIHelper5 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper4.VTable,
        msProvisionNetworks: fn(
            self: *const IShellUIHelper5,
            bstrProvisioningXml: BSTR,
            puiResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msReportSafeUrl: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeRefreshBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msDiagnoseConnectionUILess: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchNetworkClientHelp: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msChangeDefaultBrowser: fn(
            self: *const IShellUIHelper5,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msProvisionNetworks(self: *const T, bstrProvisioningXml: BSTR, puiResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msProvisionNetworks(@ptrCast(*const IShellUIHelper5, self), bstrProvisioningXml, puiResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msReportSafeUrl(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msReportSafeUrl(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeRefreshBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeRefreshBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeClearBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeClearBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msDiagnoseConnectionUILess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msDiagnoseConnectionUILess(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msLaunchNetworkClientHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msLaunchNetworkClientHelp(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msChangeDefaultBrowser(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msChangeDefaultBrowser(@ptrCast(*const IShellUIHelper5, self), fChange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper6_Value = @import("../zig.zig").Guid.initString("987a573e-46ee-4e89-96ab-ddf7f8fdc98c");
pub const IID_IShellUIHelper6 = &IID_IShellUIHelper6_Value;
pub const IShellUIHelper6 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper5.VTable,
        msStopPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdateBatch: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msClearTile: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueue: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msPinnedSiteState: fn(
            self: *const IShellUIHelper6,
            pvarSiteState: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare150x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForWide310x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare310x310: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationXml: BSTR,
            bstrNotificationId: BSTR,
            bstrNotificationTag: BSTR,
            startTime: VARIANT,
            expirationTime: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msRemoveScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationId: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUri: BSTR,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStopPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchInternetOptions: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicTileUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdate(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdateBatch(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdateBatch(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msClearTile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msClearTile(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueue(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueue(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msPinnedSiteState(self: *const T, pvarSiteState: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msPinnedSiteState(@ptrCast(*const IShellUIHelper6, self), pvarSiteState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare150x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare150x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForWide310x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForWide310x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare310x310(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare310x310(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msScheduledTileNotification(self: *const T, bstrNotificationXml: BSTR, bstrNotificationId: BSTR, bstrNotificationTag: BSTR, startTime: VARIANT, expirationTime: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationXml, bstrNotificationId, bstrNotificationTag, startTime, expirationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msRemoveScheduledTileNotification(self: *const T, bstrNotificationId: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msRemoveScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicBadgeUpdate(self: *const T, pollingUri: BSTR, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUri, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicBadgeUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msLaunchInternetOptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msLaunchInternetOptions(@ptrCast(*const IShellUIHelper6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper7_Value = @import("../zig.zig").Guid.initString("60e567c8-9573-4ab2-a264-637c6c161cb1");
pub const IID_IShellUIHelper7 = &IID_IShellUIHelper7_Value;
pub const IShellUIHelper7 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper6.VTable,
        SetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: BSTR,
            vfFlag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: BSTR,
            vfFlag: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: BSTR,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: BSTR,
            pdwValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetAllExperimentalFlagsAndValues: fn(
            self: *const IShellUIHelper7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            flag: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            flag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            exists: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchIE: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            automated: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalFlag(self: *const T, bstrFlagString: BSTR, vfFlag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalFlag(self: *const T, bstrFlagString: BSTR, vfFlag: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalValue(self: *const T, bstrValueString: BSTR, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalValue(self: *const T, bstrValueString: BSTR, pdwValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, pdwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_ResetAllExperimentalFlagsAndValues(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).ResetAllExperimentalFlagsAndValues(@ptrCast(*const IShellUIHelper7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, flag: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, flag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_HasNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, exists: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).HasNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, exists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_LaunchIE(self: *const T, bstrUrl: BSTR, automated: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).LaunchIE(@ptrCast(*const IShellUIHelper7, self), bstrUrl, automated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper8_Value = @import("../zig.zig").Guid.initString("66debcf2-05b0-4f07-b49b-b96241a65db2");
pub const IID_IShellUIHelper8 = &IID_IShellUIHelper8_Value;
pub const IShellUIHelper8 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper7.VTable,
        GetCVListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCVListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesPane: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesSettings: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchInHVSI: fn(
            self: *const IShellUIHelper8,
            bstrUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListLocalData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListLocalData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesPane(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesPane(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesSettings(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_LaunchInHVSI(self: *const T, bstrUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).LaunchInHVSI(@ptrCast(*const IShellUIHelper8, self), bstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper9_Value = @import("../zig.zig").Guid.initString("6cdf73b0-7f2f-451f-bc0f-63e0f3284e54");
pub const IID_IShellUIHelper9 = &IID_IShellUIHelper9_Value;
pub const IShellUIHelper9 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper8.VTable,
        GetOSSku: fn(
            self: *const IShellUIHelper9,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper9_GetOSSku(self: *const T, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper9.VTable, self.vtable).GetOSSku(@ptrCast(*const IShellUIHelper9, self), pdwResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellNameSpaceEvents_Value = @import("../zig.zig").Guid.initString("55136806-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_DShellNameSpaceEvents = &IID_DShellNameSpaceEvents_Value;
pub const DShellNameSpaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellFavoritesNameSpace_Value = @import("../zig.zig").Guid.initString("55136804-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_IShellFavoritesNameSpace = &IID_IShellFavoritesNameSpace_Value;
pub const IShellFavoritesNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        MoveSelectionUp: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionDown: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSort: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewFolder: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Export: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeContextMenuCommand: fn(
            self: *const IShellFavoritesNameSpace,
            strCommand: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionTo: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubscriptionsEnabled: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRoot: fn(
            self: *const IShellFavoritesNameSpace,
            bstrFullPath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionUp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionUp(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionDown(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_ResetSort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).ResetSort(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_NewFolder(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).NewFolder(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Synchronize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Synchronize(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Import(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Import(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Export(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Export(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_InvokeContextMenuCommand(self: *const T, strCommand: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).InvokeContextMenuCommand(@ptrCast(*const IShellFavoritesNameSpace, self), strCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionTo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionTo(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_get_SubscriptionsEnabled(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).get_SubscriptionsEnabled(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_CreateSubscriptionForSelection(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).CreateSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_DeleteSubscriptionForSelection(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).DeleteSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_SetRoot(self: *const T, bstrFullPath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).SetRoot(@ptrCast(*const IShellFavoritesNameSpace, self), bstrFullPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellNameSpace_Value = @import("../zig.zig").Guid.initString("e572d3c9-37be-4ae2-825d-d521763e3108");
pub const IID_IShellNameSpace = &IID_IShellNameSpace_Value;
pub const IShellNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IShellFavoritesNameSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumOptions: fn(
            self: *const IShellNameSpace,
            pgrfEnumFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumOptions: fn(
            self: *const IShellNameSpace,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: fn(
            self: *const IShellNameSpace,
            pvar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Root: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Depth: fn(
            self: *const IShellNameSpace,
            piDepth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Depth: fn(
            self: *const IShellNameSpace,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IShellNameSpace,
            puMode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IShellNameSpace,
            uMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: fn(
            self: *const IShellNameSpace,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountViewTypes: fn(
            self: *const IShellNameSpace,
            piTypes: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewType: fn(
            self: *const IShellNameSpace,
            iType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectedItems: fn(
            self: *const IShellNameSpace,
            ppid: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnselectAll: fn(
            self: *const IShellNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFavoritesNameSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_EnumOptions(self: *const T, pgrfEnumFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_EnumOptions(@ptrCast(*const IShellNameSpace, self), pgrfEnumFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_EnumOptions(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_EnumOptions(@ptrCast(*const IShellNameSpace, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_SelectedItem(self: *const T, pItem: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_SelectedItem(self: *const T, pItem: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Root(self: *const T, pvar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Root(@ptrCast(*const IShellNameSpace, self), pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Root(self: *const T, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Root(@ptrCast(*const IShellNameSpace, self), @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Depth(self: *const T, piDepth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Depth(@ptrCast(*const IShellNameSpace, self), piDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Depth(self: *const T, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Depth(@ptrCast(*const IShellNameSpace, self), iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Mode(self: *const T, puMode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Mode(@ptrCast(*const IShellNameSpace, self), puMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Mode(self: *const T, uMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Mode(@ptrCast(*const IShellNameSpace, self), uMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Flags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Flags(@ptrCast(*const IShellNameSpace, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Flags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Flags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_TVFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_TVFlags(self: *const T, dwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Columns(self: *const T, bstrColumns: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Columns(self: *const T, bstrColumns: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_CountViewTypes(self: *const T, piTypes: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_CountViewTypes(@ptrCast(*const IShellNameSpace, self), piTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SetViewType(self: *const T, iType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SetViewType(@ptrCast(*const IShellNameSpace, self), iType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SelectedItems(self: *const T, ppid: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SelectedItems(@ptrCast(*const IShellNameSpace, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_Expand(self: *const T, @"var": VARIANT, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).Expand(@ptrCast(*const IShellNameSpace, self), @"var", iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_UnselectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).UnselectAll(@ptrCast(*const IShellNameSpace, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptErrorList_Value = @import("../zig.zig").Guid.initString("f3470f24-15fd-11d2-bb2e-00805ff7efca");
pub const IID_IScriptErrorList = &IID_IScriptErrorList_Value;
pub const IScriptErrorList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        advanceError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        retreatError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canAdvanceError: fn(
            self: *const IScriptErrorList,
            pfCanAdvance: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canRetreatError: fn(
            self: *const IScriptErrorList,
            pfCanRetreat: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorLine: fn(
            self: *const IScriptErrorList,
            plLine: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorChar: fn(
            self: *const IScriptErrorList,
            plChar: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorCode: fn(
            self: *const IScriptErrorList,
            plCode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorMsg: fn(
            self: *const IScriptErrorList,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorUrl: fn(
            self: *const IScriptErrorList,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAlwaysShowLockState: fn(
            self: *const IScriptErrorList,
            pfAlwaysShowLocked: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            pfDetailsPaneOpen: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            fDetailsPaneOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            pfPerErrorDisplay: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            fPerErrorDisplay: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_advanceError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).advanceError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_retreatError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).retreatError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canAdvanceError(self: *const T, pfCanAdvance: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canAdvanceError(@ptrCast(*const IScriptErrorList, self), pfCanAdvance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canRetreatError(self: *const T, pfCanRetreat: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canRetreatError(@ptrCast(*const IScriptErrorList, self), pfCanRetreat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorLine(self: *const T, plLine: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorLine(@ptrCast(*const IScriptErrorList, self), plLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorChar(self: *const T, plChar: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorChar(@ptrCast(*const IScriptErrorList, self), plChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorCode(self: *const T, plCode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorCode(@ptrCast(*const IScriptErrorList, self), plCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorMsg(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorMsg(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorUrl(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorUrl(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getAlwaysShowLockState(self: *const T, pfAlwaysShowLocked: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getAlwaysShowLockState(@ptrCast(*const IScriptErrorList, self), pfAlwaysShowLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getDetailsPaneOpen(self: *const T, pfDetailsPaneOpen: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), pfDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setDetailsPaneOpen(self: *const T, fDetailsPaneOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), fDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getPerErrorDisplay(self: *const T, pfPerErrorDisplay: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), pfPerErrorDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setPerErrorDisplay(self: *const T, fPerErrorDisplay: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), fPerErrorDisplay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const JAVA_TRUST = extern struct {
    cbSize: u32,
    flag: u32,
    fAllActiveXPermissions: BOOL,
    fAllPermissions: BOOL,
    dwEncodingType: u32,
    pbJavaPermissions: *u8,
    cbJavaPermissions: u32,
    pbSigner: *u8,
    cbSigner: u32,
    pwszZone: [*:0]const u16,
    guidZone: Guid,
    hVerify: HRESULT,
};

const CLSID_IsolatedAppLauncher_Value = @import("../zig.zig").Guid.initString("bc812430-e75e-4fd1-9641-1f9f1e2d9a1f");
pub const CLSID_IsolatedAppLauncher = &CLSID_IsolatedAppLauncher_Value;

pub const IsolatedAppLauncherTelemetryParameters = extern struct {
    EnableForLaunch: BOOL,
    CorrelationGUID: Guid,
};

const IID_IIsolatedAppLauncher_Value = @import("../zig.zig").Guid.initString("f686878f-7b42-4cc4-96fb-f4f3b6e3d24d");
pub const IID_IIsolatedAppLauncher = &IID_IIsolatedAppLauncher_Value;
pub const IIsolatedAppLauncher = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Launch: fn(
            self: *const IIsolatedAppLauncher,
            appUserModelId: [*:0]const u16,
            arguments: [*:0]const u16,
            telemetryParameters: *const IsolatedAppLauncherTelemetryParameters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsolatedAppLauncher_Launch(self: *const T, appUserModelId: [*:0]const u16, arguments: [*:0]const u16, telemetryParameters: *const IsolatedAppLauncherTelemetryParameters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsolatedAppLauncher.VTable, self.vtable).Launch(@ptrCast(*const IIsolatedAppLauncher, self), appUserModelId, arguments, telemetryParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WSCProductList_Value = @import("../zig.zig").Guid.initString("17072f7b-9abe-4a74-a261-1eb76b55107a");
pub const CLSID_WSCProductList = &CLSID_WSCProductList_Value;

const CLSID_WSCDefaultProduct_Value = @import("../zig.zig").Guid.initString("2981a36e-f22d-11e5-9ce9-5e5517507c66");
pub const CLSID_WSCDefaultProduct = &CLSID_WSCDefaultProduct_Value;

pub const WSC_SECURITY_PRODUCT_SUBSTATUS = extern enum(i32) {
    NOT_SET = 0,
    NO_ACTION = 1,
    ACTION_RECOMMENDED = 2,
    ACTION_NEEDED = 3,
};
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_NOT_SET = WSC_SECURITY_PRODUCT_SUBSTATUS.NOT_SET;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_NO_ACTION = WSC_SECURITY_PRODUCT_SUBSTATUS.NO_ACTION;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_ACTION_RECOMMENDED = WSC_SECURITY_PRODUCT_SUBSTATUS.ACTION_RECOMMENDED;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_ACTION_NEEDED = WSC_SECURITY_PRODUCT_SUBSTATUS.ACTION_NEEDED;

pub const WSC_SECURITY_PRODUCT_STATE = extern enum(i32) {
    ON = 0,
    OFF = 1,
    SNOOZED = 2,
    EXPIRED = 3,
};
pub const WSC_SECURITY_PRODUCT_STATE_ON = WSC_SECURITY_PRODUCT_STATE.ON;
pub const WSC_SECURITY_PRODUCT_STATE_OFF = WSC_SECURITY_PRODUCT_STATE.OFF;
pub const WSC_SECURITY_PRODUCT_STATE_SNOOZED = WSC_SECURITY_PRODUCT_STATE.SNOOZED;
pub const WSC_SECURITY_PRODUCT_STATE_EXPIRED = WSC_SECURITY_PRODUCT_STATE.EXPIRED;

pub const SECURITY_PRODUCT_TYPE = extern enum(i32) {
    ANTIVIRUS = 0,
    FIREWALL = 1,
    ANTISPYWARE = 2,
};
pub const SECURITY_PRODUCT_TYPE_ANTIVIRUS = SECURITY_PRODUCT_TYPE.ANTIVIRUS;
pub const SECURITY_PRODUCT_TYPE_FIREWALL = SECURITY_PRODUCT_TYPE.FIREWALL;
pub const SECURITY_PRODUCT_TYPE_ANTISPYWARE = SECURITY_PRODUCT_TYPE.ANTISPYWARE;

pub const WSC_SECURITY_SIGNATURE_STATUS = extern enum(i32) {
    OUT_OF_DATE = 0,
    UP_TO_DATE = 1,
};
pub const WSC_SECURITY_PRODUCT_OUT_OF_DATE = WSC_SECURITY_SIGNATURE_STATUS.OUT_OF_DATE;
pub const WSC_SECURITY_PRODUCT_UP_TO_DATE = WSC_SECURITY_SIGNATURE_STATUS.UP_TO_DATE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IWscProduct_Value = @import("../zig.zig").Guid.initString("8c38232e-3a45-4a27-92b0-1a16a975f669");
pub const IID_IWscProduct = &IID_IWscProduct_Value;
pub const IWscProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductName: fn(
            self: *const IWscProduct,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductState: fn(
            self: *const IWscProduct,
            pVal: *WSC_SECURITY_PRODUCT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignatureStatus: fn(
            self: *const IWscProduct,
            pVal: *WSC_SECURITY_SIGNATURE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemediationPath: fn(
            self: *const IWscProduct,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductStateTimestamp: fn(
            self: *const IWscProduct,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductGuid: fn(
            self: *const IWscProduct,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductIsDefault: fn(
            self: *const IWscProduct,
            pVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductName(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductName(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductState(self: *const T, pVal: *WSC_SECURITY_PRODUCT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductState(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_SignatureStatus(self: *const T, pVal: *WSC_SECURITY_SIGNATURE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_SignatureStatus(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_RemediationPath(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_RemediationPath(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductStateTimestamp(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductStateTimestamp(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductGuid(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductGuid(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductIsDefault(self: *const T, pVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductIsDefault(@ptrCast(*const IWscProduct, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWscProduct2_Value = @import("../zig.zig").Guid.initString("f896ca54-fe09-4403-86d4-23cb488d81d8");
pub const IID_IWscProduct2 = &IID_IWscProduct2_Value;
pub const IWscProduct2 = extern struct {
    pub const VTable = extern struct {
        base: IWscProduct.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntivirusScanSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntivirusSettingsSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntivirusProtectionUpdateSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallDomainProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallPrivateProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallPublicProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWscProduct.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusScanSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusScanSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusSettingsSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusSettingsSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusProtectionUpdateSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusProtectionUpdateSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallDomainProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallDomainProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallPrivateProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallPrivateProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallPublicProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallPublicProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWscProduct3_Value = @import("../zig.zig").Guid.initString("55536524-d1d1-4726-8c7c-04996a1904e7");
pub const IID_IWscProduct3 = &IID_IWscProduct3_Value;
pub const IWscProduct3 = extern struct {
    pub const VTable = extern struct {
        base: IWscProduct2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntivirusDaysUntilExpired: fn(
            self: *const IWscProduct3,
            pdwDays: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWscProduct2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct3_get_AntivirusDaysUntilExpired(self: *const T, pdwDays: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct3.VTable, self.vtable).get_AntivirusDaysUntilExpired(@ptrCast(*const IWscProduct3, self), pdwDays);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWSCProductList_Value = @import("../zig.zig").Guid.initString("722a338c-6e8e-4e72-ac27-1417fb0c81c2");
pub const IID_IWSCProductList = &IID_IWSCProductList_Value;
pub const IWSCProductList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IWSCProductList,
            provider: WSC_SECURITY_PROVIDER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IWSCProductList,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IWSCProductList,
            index: u32,
            pVal: ?*?*IWscProduct,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_Initialize(self: *const T, provider: WSC_SECURITY_PROVIDER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).Initialize(@ptrCast(*const IWSCProductList, self), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).get_Count(@ptrCast(*const IWSCProductList, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_get_Item(self: *const T, index: u32, pVal: ?*?*IWscProduct) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).get_Item(@ptrCast(*const IWSCProductList, self), index, pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSCDefaultProduct_Value = @import("../zig.zig").Guid.initString("0476d69c-f21a-11e5-9ce9-5e5517507c66");
pub const IID_IWSCDefaultProduct = &IID_IWSCDefaultProduct_Value;
pub const IWSCDefaultProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetDefaultProduct: fn(
            self: *const IWSCDefaultProduct,
            eType: SECURITY_PRODUCT_TYPE,
            pGuid: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCDefaultProduct_SetDefaultProduct(self: *const T, eType: SECURITY_PRODUCT_TYPE, pGuid: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCDefaultProduct.VTable, self.vtable).SetDefaultProduct(@ptrCast(*const IWSCDefaultProduct, self), eType, pGuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WSC_SECURITY_PROVIDER = extern enum(i32) {
    FIREWALL = 1,
    AUTOUPDATE_SETTINGS = 2,
    ANTIVIRUS = 4,
    ANTISPYWARE = 8,
    INTERNET_SETTINGS = 16,
    USER_ACCOUNT_CONTROL = 32,
    SERVICE = 64,
    NONE = 0,
    ALL = 127,
};
pub const WSC_SECURITY_PROVIDER_FIREWALL = WSC_SECURITY_PROVIDER.FIREWALL;
pub const WSC_SECURITY_PROVIDER_AUTOUPDATE_SETTINGS = WSC_SECURITY_PROVIDER.AUTOUPDATE_SETTINGS;
pub const WSC_SECURITY_PROVIDER_ANTIVIRUS = WSC_SECURITY_PROVIDER.ANTIVIRUS;
pub const WSC_SECURITY_PROVIDER_ANTISPYWARE = WSC_SECURITY_PROVIDER.ANTISPYWARE;
pub const WSC_SECURITY_PROVIDER_INTERNET_SETTINGS = WSC_SECURITY_PROVIDER.INTERNET_SETTINGS;
pub const WSC_SECURITY_PROVIDER_USER_ACCOUNT_CONTROL = WSC_SECURITY_PROVIDER.USER_ACCOUNT_CONTROL;
pub const WSC_SECURITY_PROVIDER_SERVICE = WSC_SECURITY_PROVIDER.SERVICE;
pub const WSC_SECURITY_PROVIDER_NONE = WSC_SECURITY_PROVIDER.NONE;
pub const WSC_SECURITY_PROVIDER_ALL = WSC_SECURITY_PROVIDER.ALL;

pub const WSC_SECURITY_PROVIDER_HEALTH = extern enum(i32) {
    GOOD = 0,
    NOTMONITORED = 1,
    POOR = 2,
    SNOOZE = 3,
};
pub const WSC_SECURITY_PROVIDER_HEALTH_GOOD = WSC_SECURITY_PROVIDER_HEALTH.GOOD;
pub const WSC_SECURITY_PROVIDER_HEALTH_NOTMONITORED = WSC_SECURITY_PROVIDER_HEALTH.NOTMONITORED;
pub const WSC_SECURITY_PROVIDER_HEALTH_POOR = WSC_SECURITY_PROVIDER_HEALTH.POOR;
pub const WSC_SECURITY_PROVIDER_HEALTH_SNOOZE = WSC_SECURITY_PROVIDER_HEALTH.SNOOZE;

pub const PFN_IO_COMPLETION = fn(
    pContext: *FIO_CONTEXT,
    lpo: *FH_OVERLAPPED,
    cb: u32,
    dwCompletionStatus: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const FH_OVERLAPPED = extern struct {
    Internal: usize,
    InternalHigh: usize,
    Offset: u32,
    OffsetHigh: u32,
    hEvent: HANDLE,
    pfnCompletion: PFN_IO_COMPLETION,
    Reserved1: usize,
    Reserved2: usize,
    Reserved3: usize,
    Reserved4: usize,
};

pub const FIO_CONTEXT = extern struct {
    m_dwTempHack: u32,
    m_dwSignature: u32,
    m_hFile: HANDLE,
    m_dwLinesOffset: u32,
    m_dwHeaderLength: u32,
};

pub const FCACHE_CREATE_CALLBACK = fn(
    lpstrName: PSTR,
    lpvData: *c_void,
    cbFileSize: *u32,
    cbFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const FCACHE_RICHCREATE_CALLBACK = fn(
    lpstrName: PSTR,
    lpvData: *c_void,
    cbFileSize: *u32,
    cbFileSizeHigh: *u32,
    pfDidWeScanIt: *BOOL,
    pfIsStuffed: *BOOL,
    pfStoredWithDots: *BOOL,
    pfStoredWithTerminatingDot: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const CACHE_KEY_COMPARE = fn(
    cbKey1: u32,
    lpbKey1: *u8,
    cbKey2: u32,
    lpbKey2: *u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CACHE_KEY_HASH = fn(
    lpbKey: *u8,
    cbKey: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CACHE_READ_CALLBACK = fn(
    cb: u32,
    lpb: *u8,
    lpvContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CACHE_DESTROY_CALLBACK = fn(
    cb: u32,
    lpb: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CACHE_ACCESS_CHECK = fn(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    hClientToken: HANDLE,
    dwDesiredAccess: u32,
    GenericMapping: *GENERIC_MAPPING,
    PrivilegeSet: *PRIVILEGE_SET,
    PrivilegeSetLength: *u32,
    GrantedAccess: *u32,
    AccessStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NAME_CACHE_CONTEXT = extern struct {
    m_dwSignature: u32,
};

pub const TDIEntityID = extern struct {
    tei_entity: TDIENTITY_ENTITY_TYPE,
    tei_instance: u32,
};

pub const TDIObjectID = extern struct {
    toi_entity: TDIEntityID,
    toi_class: u32,
    toi_type: u32,
    toi_id: u32,
};

pub const tcp_request_query_information_ex_w2k = extern struct {
    ID: TDIObjectID,
    Context: [16]u8,
};

pub const tcp_request_set_information_ex = extern struct {
    ID: TDIObjectID,
    BufferSize: u32,
    Buffer: [1]u8,
};

pub const TDI_TL_IO_CONTROL_TYPE = extern enum(i32) {
    EndpointIoControlType = 0,
    SetSockOptIoControlType = 1,
    GetSockOptIoControlType = 2,
    SocketIoControlType = 3,
};
pub const EndpointIoControlType = TDI_TL_IO_CONTROL_TYPE.EndpointIoControlType;
pub const SetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.SetSockOptIoControlType;
pub const GetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.GetSockOptIoControlType;
pub const SocketIoControlType = TDI_TL_IO_CONTROL_TYPE.SocketIoControlType;

pub const TDI_TL_IO_CONTROL_ENDPOINT = extern struct {
    Type: TDI_TL_IO_CONTROL_TYPE,
    Level: u32,
    Anonymous: _Anonymous_e__Union,
    InputBuffer: *c_void,
    InputBufferLength: u32,
    OutputBuffer: *c_void,
    OutputBufferLength: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WLDP_HOST = extern enum(i32) {
    RUNDLL32 = 0,
    SVCHOST = 1,
    MAX = 2,
};
pub const WLDP_HOST_RUNDLL32 = WLDP_HOST.RUNDLL32;
pub const WLDP_HOST_SVCHOST = WLDP_HOST.SVCHOST;
pub const WLDP_HOST_MAX = WLDP_HOST.MAX;

pub const WLDP_HOST_ID = extern enum(i32) {
    UNKNOWN = 0,
    GLOBAL = 1,
    VBA = 2,
    WSH = 3,
    POWERSHELL = 4,
    IE = 5,
    MSI = 6,
    ALL = 7,
    MAX = 8,
};
pub const WLDP_HOST_ID_UNKNOWN = WLDP_HOST_ID.UNKNOWN;
pub const WLDP_HOST_ID_GLOBAL = WLDP_HOST_ID.GLOBAL;
pub const WLDP_HOST_ID_VBA = WLDP_HOST_ID.VBA;
pub const WLDP_HOST_ID_WSH = WLDP_HOST_ID.WSH;
pub const WLDP_HOST_ID_POWERSHELL = WLDP_HOST_ID.POWERSHELL;
pub const WLDP_HOST_ID_IE = WLDP_HOST_ID.IE;
pub const WLDP_HOST_ID_MSI = WLDP_HOST_ID.MSI;
pub const WLDP_HOST_ID_ALL = WLDP_HOST_ID.ALL;
pub const WLDP_HOST_ID_MAX = WLDP_HOST_ID.MAX;

pub const DECISION_LOCATION = extern enum(i32) {
    REFRESH_GLOBAL_DATA = 0,
    PARAMETER_VALIDATION = 1,
    AUDIT = 2,
    FAILED_CONVERT_GUID = 3,
    ENTERPRISE_DEFINED_CLASS_ID = 4,
    GLOBAL_BUILT_IN_LIST = 5,
    PROVIDER_BUILT_IN_LIST = 6,
    ENFORCE_STATE_LIST = 7,
    NOT_FOUND = 8,
    UNKNOWN = 9,
};
pub const DECISION_LOCATION_REFRESH_GLOBAL_DATA = DECISION_LOCATION.REFRESH_GLOBAL_DATA;
pub const DECISION_LOCATION_PARAMETER_VALIDATION = DECISION_LOCATION.PARAMETER_VALIDATION;
pub const DECISION_LOCATION_AUDIT = DECISION_LOCATION.AUDIT;
pub const DECISION_LOCATION_FAILED_CONVERT_GUID = DECISION_LOCATION.FAILED_CONVERT_GUID;
pub const DECISION_LOCATION_ENTERPRISE_DEFINED_CLASS_ID = DECISION_LOCATION.ENTERPRISE_DEFINED_CLASS_ID;
pub const DECISION_LOCATION_GLOBAL_BUILT_IN_LIST = DECISION_LOCATION.GLOBAL_BUILT_IN_LIST;
pub const DECISION_LOCATION_PROVIDER_BUILT_IN_LIST = DECISION_LOCATION.PROVIDER_BUILT_IN_LIST;
pub const DECISION_LOCATION_ENFORCE_STATE_LIST = DECISION_LOCATION.ENFORCE_STATE_LIST;
pub const DECISION_LOCATION_NOT_FOUND = DECISION_LOCATION.NOT_FOUND;
pub const DECISION_LOCATION_UNKNOWN = DECISION_LOCATION.UNKNOWN;

pub const WLDP_KEY = extern enum(i32) {
    UNKNOWN = 0,
    OVERRIDE = 1,
    ALL_KEYS = 2,
};
pub const KEY_UNKNOWN = WLDP_KEY.UNKNOWN;
pub const KEY_OVERRIDE = WLDP_KEY.OVERRIDE;
pub const KEY_ALL_KEYS = WLDP_KEY.ALL_KEYS;

pub const VALUENAME = extern enum(i32) {
    UNKNOWN = 0,
    ENTERPRISE_DEFINED_CLASS_ID = 1,
    BUILT_IN_LIST = 2,
};
pub const VALUENAME_UNKNOWN = VALUENAME.UNKNOWN;
pub const VALUENAME_ENTERPRISE_DEFINED_CLASS_ID = VALUENAME.ENTERPRISE_DEFINED_CLASS_ID;
pub const VALUENAME_BUILT_IN_LIST = VALUENAME.BUILT_IN_LIST;

pub const WLDP_WINDOWS_LOCKDOWN_MODE = extern enum(i32) {
    UNLOCKED = 0,
    TRIAL = 1,
    LOCKED = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_MODE_UNLOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.UNLOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_TRIAL = WLDP_WINDOWS_LOCKDOWN_MODE.TRIAL;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_LOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.LOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_MAX = WLDP_WINDOWS_LOCKDOWN_MODE.MAX;

pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION = extern enum(i32) {
    NONE = 0,
    NOUNLOCK = 1,
    NOUNLOCK_PERMANENT = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NONE = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NONE;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK_PERMANENT = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK_PERMANENT;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_MAX = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.MAX;

pub const WLDP_HOST_INFORMATION = extern struct {
    dwRevision: u32,
    dwHostId: WLDP_HOST_ID,
    szSource: [*:0]const u16,
    hSource: HANDLE,
};

pub const PWLDP_SETDYNAMICCODETRUST_API = fn(
    hFileHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_ISDYNAMICCODEPOLICYENABLED_API = fn(
    pbEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYDYNAMICODETRUST_API = fn(
    fileHandle: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    baseImage: ?*c_void,
    imageSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYWINDOWSLOCKDOWNMODE_API = fn(
    lockdownMode: *WLDP_WINDOWS_LOCKDOWN_MODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API = fn(
    LockdownRestriction: *WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API = fn(
    LockdownRestriction: WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_WLDPISAPPAPPROVEDBYPOLICY_API = fn(
    PackageFamilyName: [*:0]const u16,
    PackageVersion: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const XmlNodeType = extern enum(i32) {
    XmlNodeType_None = 0,
    XmlNodeType_Element = 1,
    XmlNodeType_Attribute = 2,
    XmlNodeType_Text = 3,
    XmlNodeType_CDATA = 4,
    XmlNodeType_ProcessingInstruction = 7,
    XmlNodeType_Comment = 8,
    XmlNodeType_DocumentType = 10,
    XmlNodeType_Whitespace = 13,
    XmlNodeType_EndElement = 15,
    XmlNodeType_XmlDeclaration = 17,
    _XmlNodeType_Last = 17,
};
pub const XmlNodeType_None = XmlNodeType.XmlNodeType_None;
pub const XmlNodeType_Element = XmlNodeType.XmlNodeType_Element;
pub const XmlNodeType_Attribute = XmlNodeType.XmlNodeType_Attribute;
pub const XmlNodeType_Text = XmlNodeType.XmlNodeType_Text;
pub const XmlNodeType_CDATA = XmlNodeType.XmlNodeType_CDATA;
pub const XmlNodeType_ProcessingInstruction = XmlNodeType.XmlNodeType_ProcessingInstruction;
pub const XmlNodeType_Comment = XmlNodeType.XmlNodeType_Comment;
pub const XmlNodeType_DocumentType = XmlNodeType.XmlNodeType_DocumentType;
pub const XmlNodeType_Whitespace = XmlNodeType.XmlNodeType_Whitespace;
pub const XmlNodeType_EndElement = XmlNodeType.XmlNodeType_EndElement;
pub const XmlNodeType_XmlDeclaration = XmlNodeType.XmlNodeType_XmlDeclaration;
pub const _XmlNodeType_Last = XmlNodeType._XmlNodeType_Last;

pub const XmlConformanceLevel = extern enum(i32) {
    XmlConformanceLevel_Auto = 0,
    XmlConformanceLevel_Fragment = 1,
    XmlConformanceLevel_Document = 2,
    _XmlConformanceLevel_Last = 2,
};
pub const XmlConformanceLevel_Auto = XmlConformanceLevel.XmlConformanceLevel_Auto;
pub const XmlConformanceLevel_Fragment = XmlConformanceLevel.XmlConformanceLevel_Fragment;
pub const XmlConformanceLevel_Document = XmlConformanceLevel.XmlConformanceLevel_Document;
pub const _XmlConformanceLevel_Last = XmlConformanceLevel._XmlConformanceLevel_Last;

pub const DtdProcessing = extern enum(i32) {
    DtdProcessing_Prohibit = 0,
    DtdProcessing_Parse = 1,
    _DtdProcessing_Last = 1,
};
pub const DtdProcessing_Prohibit = DtdProcessing.DtdProcessing_Prohibit;
pub const DtdProcessing_Parse = DtdProcessing.DtdProcessing_Parse;
pub const _DtdProcessing_Last = DtdProcessing._DtdProcessing_Last;

pub const XmlReadState = extern enum(i32) {
    Initial = 0,
    Interactive = 1,
    Error = 2,
    EndOfFile = 3,
    Closed = 4,
};
pub const XmlReadState_Initial = XmlReadState.Initial;
pub const XmlReadState_Interactive = XmlReadState.Interactive;
pub const XmlReadState_Error = XmlReadState.Error;
pub const XmlReadState_EndOfFile = XmlReadState.EndOfFile;
pub const XmlReadState_Closed = XmlReadState.Closed;

pub const XmlReaderProperty = extern enum(i32) {
    XmlReaderProperty_MultiLanguage = 0,
    XmlReaderProperty_ConformanceLevel = 1,
    XmlReaderProperty_RandomAccess = 2,
    XmlReaderProperty_XmlResolver = 3,
    XmlReaderProperty_DtdProcessing = 4,
    XmlReaderProperty_ReadState = 5,
    XmlReaderProperty_MaxElementDepth = 6,
    XmlReaderProperty_MaxEntityExpansion = 7,
    _XmlReaderProperty_Last = 7,
};
pub const XmlReaderProperty_MultiLanguage = XmlReaderProperty.XmlReaderProperty_MultiLanguage;
pub const XmlReaderProperty_ConformanceLevel = XmlReaderProperty.XmlReaderProperty_ConformanceLevel;
pub const XmlReaderProperty_RandomAccess = XmlReaderProperty.XmlReaderProperty_RandomAccess;
pub const XmlReaderProperty_XmlResolver = XmlReaderProperty.XmlReaderProperty_XmlResolver;
pub const XmlReaderProperty_DtdProcessing = XmlReaderProperty.XmlReaderProperty_DtdProcessing;
pub const XmlReaderProperty_ReadState = XmlReaderProperty.XmlReaderProperty_ReadState;
pub const XmlReaderProperty_MaxElementDepth = XmlReaderProperty.XmlReaderProperty_MaxElementDepth;
pub const XmlReaderProperty_MaxEntityExpansion = XmlReaderProperty.XmlReaderProperty_MaxEntityExpansion;
pub const _XmlReaderProperty_Last = XmlReaderProperty._XmlReaderProperty_Last;

pub const XmlError = extern enum(i32) {
    MX_E_MX = -1072894464,
    MX_E_INPUTEND = -1072894463,
    MX_E_ENCODING = -1072894462,
    MX_E_ENCODINGSWITCH = -1072894461,
    MX_E_ENCODINGSIGNATURE = -1072894460,
    WC_E_WC = -1072894432,
    WC_E_WHITESPACE = -1072894431,
    WC_E_SEMICOLON = -1072894430,
    WC_E_GREATERTHAN = -1072894429,
    WC_E_QUOTE = -1072894428,
    WC_E_EQUAL = -1072894427,
    WC_E_LESSTHAN = -1072894426,
    WC_E_HEXDIGIT = -1072894425,
    WC_E_DIGIT = -1072894424,
    WC_E_LEFTBRACKET = -1072894423,
    WC_E_LEFTPAREN = -1072894422,
    WC_E_XMLCHARACTER = -1072894421,
    WC_E_NAMECHARACTER = -1072894420,
    WC_E_SYNTAX = -1072894419,
    WC_E_CDSECT = -1072894418,
    WC_E_COMMENT = -1072894417,
    WC_E_CONDSECT = -1072894416,
    WC_E_DECLATTLIST = -1072894415,
    WC_E_DECLDOCTYPE = -1072894414,
    WC_E_DECLELEMENT = -1072894413,
    WC_E_DECLENTITY = -1072894412,
    WC_E_DECLNOTATION = -1072894411,
    WC_E_NDATA = -1072894410,
    WC_E_PUBLIC = -1072894409,
    WC_E_SYSTEM = -1072894408,
    WC_E_NAME = -1072894407,
    WC_E_ROOTELEMENT = -1072894406,
    WC_E_ELEMENTMATCH = -1072894405,
    WC_E_UNIQUEATTRIBUTE = -1072894404,
    WC_E_TEXTXMLDECL = -1072894403,
    WC_E_LEADINGXML = -1072894402,
    WC_E_TEXTDECL = -1072894401,
    WC_E_XMLDECL = -1072894400,
    WC_E_ENCNAME = -1072894399,
    WC_E_PUBLICID = -1072894398,
    WC_E_PESINTERNALSUBSET = -1072894397,
    WC_E_PESBETWEENDECLS = -1072894396,
    WC_E_NORECURSION = -1072894395,
    WC_E_ENTITYCONTENT = -1072894394,
    WC_E_UNDECLAREDENTITY = -1072894393,
    WC_E_PARSEDENTITY = -1072894392,
    WC_E_NOEXTERNALENTITYREF = -1072894391,
    WC_E_PI = -1072894390,
    WC_E_SYSTEMID = -1072894389,
    WC_E_QUESTIONMARK = -1072894388,
    WC_E_CDSECTEND = -1072894387,
    WC_E_MOREDATA = -1072894386,
    WC_E_DTDPROHIBITED = -1072894385,
    WC_E_INVALIDXMLSPACE = -1072894384,
    NC_E_NC = -1072894368,
    NC_E_QNAMECHARACTER = -1072894367,
    NC_E_QNAMECOLON = -1072894366,
    NC_E_NAMECOLON = -1072894365,
    NC_E_DECLAREDPREFIX = -1072894364,
    NC_E_UNDECLAREDPREFIX = -1072894363,
    NC_E_EMPTYURI = -1072894362,
    NC_E_XMLPREFIXRESERVED = -1072894361,
    NC_E_XMLNSPREFIXRESERVED = -1072894360,
    NC_E_XMLURIRESERVED = -1072894359,
    NC_E_XMLNSURIRESERVED = -1072894358,
    SC_E_SC = -1072894336,
    SC_E_MAXELEMENTDEPTH = -1072894335,
    SC_E_MAXENTITYEXPANSION = -1072894334,
    WR_E_WR = -1072894208,
    WR_E_NONWHITESPACE = -1072894207,
    WR_E_NSPREFIXDECLARED = -1072894206,
    WR_E_NSPREFIXWITHEMPTYNSURI = -1072894205,
    WR_E_DUPLICATEATTRIBUTE = -1072894204,
    WR_E_XMLNSPREFIXDECLARATION = -1072894203,
    WR_E_XMLPREFIXDECLARATION = -1072894202,
    WR_E_XMLURIDECLARATION = -1072894201,
    WR_E_XMLNSURIDECLARATION = -1072894200,
    WR_E_NAMESPACEUNDECLARED = -1072894199,
    WR_E_INVALIDXMLSPACE = -1072894198,
    WR_E_INVALIDACTION = -1072894197,
    WR_E_INVALIDSURROGATEPAIR = -1072894196,
    XML_E_INVALID_DECIMAL = -1072898019,
    XML_E_INVALID_HEXIDECIMAL = -1072898018,
    XML_E_INVALID_UNICODE = -1072898017,
    XML_E_INVALIDENCODING = -1072897938,
};
pub const MX_E_MX = XmlError.MX_E_MX;
pub const MX_E_INPUTEND = XmlError.MX_E_INPUTEND;
pub const MX_E_ENCODING = XmlError.MX_E_ENCODING;
pub const MX_E_ENCODINGSWITCH = XmlError.MX_E_ENCODINGSWITCH;
pub const MX_E_ENCODINGSIGNATURE = XmlError.MX_E_ENCODINGSIGNATURE;
pub const WC_E_WC = XmlError.WC_E_WC;
pub const WC_E_WHITESPACE = XmlError.WC_E_WHITESPACE;
pub const WC_E_SEMICOLON = XmlError.WC_E_SEMICOLON;
pub const WC_E_GREATERTHAN = XmlError.WC_E_GREATERTHAN;
pub const WC_E_QUOTE = XmlError.WC_E_QUOTE;
pub const WC_E_EQUAL = XmlError.WC_E_EQUAL;
pub const WC_E_LESSTHAN = XmlError.WC_E_LESSTHAN;
pub const WC_E_HEXDIGIT = XmlError.WC_E_HEXDIGIT;
pub const WC_E_DIGIT = XmlError.WC_E_DIGIT;
pub const WC_E_LEFTBRACKET = XmlError.WC_E_LEFTBRACKET;
pub const WC_E_LEFTPAREN = XmlError.WC_E_LEFTPAREN;
pub const WC_E_XMLCHARACTER = XmlError.WC_E_XMLCHARACTER;
pub const WC_E_NAMECHARACTER = XmlError.WC_E_NAMECHARACTER;
pub const WC_E_SYNTAX = XmlError.WC_E_SYNTAX;
pub const WC_E_CDSECT = XmlError.WC_E_CDSECT;
pub const WC_E_COMMENT = XmlError.WC_E_COMMENT;
pub const WC_E_CONDSECT = XmlError.WC_E_CONDSECT;
pub const WC_E_DECLATTLIST = XmlError.WC_E_DECLATTLIST;
pub const WC_E_DECLDOCTYPE = XmlError.WC_E_DECLDOCTYPE;
pub const WC_E_DECLELEMENT = XmlError.WC_E_DECLELEMENT;
pub const WC_E_DECLENTITY = XmlError.WC_E_DECLENTITY;
pub const WC_E_DECLNOTATION = XmlError.WC_E_DECLNOTATION;
pub const WC_E_NDATA = XmlError.WC_E_NDATA;
pub const WC_E_PUBLIC = XmlError.WC_E_PUBLIC;
pub const WC_E_SYSTEM = XmlError.WC_E_SYSTEM;
pub const WC_E_NAME = XmlError.WC_E_NAME;
pub const WC_E_ROOTELEMENT = XmlError.WC_E_ROOTELEMENT;
pub const WC_E_ELEMENTMATCH = XmlError.WC_E_ELEMENTMATCH;
pub const WC_E_UNIQUEATTRIBUTE = XmlError.WC_E_UNIQUEATTRIBUTE;
pub const WC_E_TEXTXMLDECL = XmlError.WC_E_TEXTXMLDECL;
pub const WC_E_LEADINGXML = XmlError.WC_E_LEADINGXML;
pub const WC_E_TEXTDECL = XmlError.WC_E_TEXTDECL;
pub const WC_E_XMLDECL = XmlError.WC_E_XMLDECL;
pub const WC_E_ENCNAME = XmlError.WC_E_ENCNAME;
pub const WC_E_PUBLICID = XmlError.WC_E_PUBLICID;
pub const WC_E_PESINTERNALSUBSET = XmlError.WC_E_PESINTERNALSUBSET;
pub const WC_E_PESBETWEENDECLS = XmlError.WC_E_PESBETWEENDECLS;
pub const WC_E_NORECURSION = XmlError.WC_E_NORECURSION;
pub const WC_E_ENTITYCONTENT = XmlError.WC_E_ENTITYCONTENT;
pub const WC_E_UNDECLAREDENTITY = XmlError.WC_E_UNDECLAREDENTITY;
pub const WC_E_PARSEDENTITY = XmlError.WC_E_PARSEDENTITY;
pub const WC_E_NOEXTERNALENTITYREF = XmlError.WC_E_NOEXTERNALENTITYREF;
pub const WC_E_PI = XmlError.WC_E_PI;
pub const WC_E_SYSTEMID = XmlError.WC_E_SYSTEMID;
pub const WC_E_QUESTIONMARK = XmlError.WC_E_QUESTIONMARK;
pub const WC_E_CDSECTEND = XmlError.WC_E_CDSECTEND;
pub const WC_E_MOREDATA = XmlError.WC_E_MOREDATA;
pub const WC_E_DTDPROHIBITED = XmlError.WC_E_DTDPROHIBITED;
pub const WC_E_INVALIDXMLSPACE = XmlError.WC_E_INVALIDXMLSPACE;
pub const NC_E_NC = XmlError.NC_E_NC;
pub const NC_E_QNAMECHARACTER = XmlError.NC_E_QNAMECHARACTER;
pub const NC_E_QNAMECOLON = XmlError.NC_E_QNAMECOLON;
pub const NC_E_NAMECOLON = XmlError.NC_E_NAMECOLON;
pub const NC_E_DECLAREDPREFIX = XmlError.NC_E_DECLAREDPREFIX;
pub const NC_E_UNDECLAREDPREFIX = XmlError.NC_E_UNDECLAREDPREFIX;
pub const NC_E_EMPTYURI = XmlError.NC_E_EMPTYURI;
pub const NC_E_XMLPREFIXRESERVED = XmlError.NC_E_XMLPREFIXRESERVED;
pub const NC_E_XMLNSPREFIXRESERVED = XmlError.NC_E_XMLNSPREFIXRESERVED;
pub const NC_E_XMLURIRESERVED = XmlError.NC_E_XMLURIRESERVED;
pub const NC_E_XMLNSURIRESERVED = XmlError.NC_E_XMLNSURIRESERVED;
pub const SC_E_SC = XmlError.SC_E_SC;
pub const SC_E_MAXELEMENTDEPTH = XmlError.SC_E_MAXELEMENTDEPTH;
pub const SC_E_MAXENTITYEXPANSION = XmlError.SC_E_MAXENTITYEXPANSION;
pub const WR_E_WR = XmlError.WR_E_WR;
pub const WR_E_NONWHITESPACE = XmlError.WR_E_NONWHITESPACE;
pub const WR_E_NSPREFIXDECLARED = XmlError.WR_E_NSPREFIXDECLARED;
pub const WR_E_NSPREFIXWITHEMPTYNSURI = XmlError.WR_E_NSPREFIXWITHEMPTYNSURI;
pub const WR_E_DUPLICATEATTRIBUTE = XmlError.WR_E_DUPLICATEATTRIBUTE;
pub const WR_E_XMLNSPREFIXDECLARATION = XmlError.WR_E_XMLNSPREFIXDECLARATION;
pub const WR_E_XMLPREFIXDECLARATION = XmlError.WR_E_XMLPREFIXDECLARATION;
pub const WR_E_XMLURIDECLARATION = XmlError.WR_E_XMLURIDECLARATION;
pub const WR_E_XMLNSURIDECLARATION = XmlError.WR_E_XMLNSURIDECLARATION;
pub const WR_E_NAMESPACEUNDECLARED = XmlError.WR_E_NAMESPACEUNDECLARED;
pub const WR_E_INVALIDXMLSPACE = XmlError.WR_E_INVALIDXMLSPACE;
pub const WR_E_INVALIDACTION = XmlError.WR_E_INVALIDACTION;
pub const WR_E_INVALIDSURROGATEPAIR = XmlError.WR_E_INVALIDSURROGATEPAIR;
pub const XML_E_INVALID_DECIMAL = XmlError.XML_E_INVALID_DECIMAL;
pub const XML_E_INVALID_HEXIDECIMAL = XmlError.XML_E_INVALID_HEXIDECIMAL;
pub const XML_E_INVALID_UNICODE = XmlError.XML_E_INVALID_UNICODE;
pub const XML_E_INVALIDENCODING = XmlError.XML_E_INVALIDENCODING;

pub const XmlStandalone = extern enum(i32) {
    XmlStandalone_Omit = 0,
    XmlStandalone_Yes = 1,
    XmlStandalone_No = 2,
    _XmlStandalone_Last = 2,
};
pub const XmlStandalone_Omit = XmlStandalone.XmlStandalone_Omit;
pub const XmlStandalone_Yes = XmlStandalone.XmlStandalone_Yes;
pub const XmlStandalone_No = XmlStandalone.XmlStandalone_No;
pub const _XmlStandalone_Last = XmlStandalone._XmlStandalone_Last;

pub const XmlWriterProperty = extern enum(i32) {
    XmlWriterProperty_MultiLanguage = 0,
    XmlWriterProperty_Indent = 1,
    XmlWriterProperty_ByteOrderMark = 2,
    XmlWriterProperty_OmitXmlDeclaration = 3,
    XmlWriterProperty_ConformanceLevel = 4,
    XmlWriterProperty_CompactEmptyElement = 5,
    _XmlWriterProperty_Last = 5,
};
pub const XmlWriterProperty_MultiLanguage = XmlWriterProperty.XmlWriterProperty_MultiLanguage;
pub const XmlWriterProperty_Indent = XmlWriterProperty.XmlWriterProperty_Indent;
pub const XmlWriterProperty_ByteOrderMark = XmlWriterProperty.XmlWriterProperty_ByteOrderMark;
pub const XmlWriterProperty_OmitXmlDeclaration = XmlWriterProperty.XmlWriterProperty_OmitXmlDeclaration;
pub const XmlWriterProperty_ConformanceLevel = XmlWriterProperty.XmlWriterProperty_ConformanceLevel;
pub const XmlWriterProperty_CompactEmptyElement = XmlWriterProperty.XmlWriterProperty_CompactEmptyElement;
pub const _XmlWriterProperty_Last = XmlWriterProperty._XmlWriterProperty_Last;

const IID_IXmlReader_Value = @import("../zig.zig").Guid.initString("7279fc81-709d-4095-b63d-69fe4b0d9030");
pub const IID_IXmlReader = &IID_IXmlReader_Value;
pub const IXmlReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInput: fn(
            self: *const IXmlReader,
            pInput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlReader,
            nProperty: u32,
            ppValue: *isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlReader,
            nProperty: u32,
            pValue: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IXmlReader,
            pNodeType: ?*XmlNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeType: fn(
            self: *const IXmlReader,
            pNodeType: *XmlNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToFirstAttribute: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToNextAttribute: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToAttributeByName: fn(
            self: *const IXmlReader,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToElement: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualifiedName: fn(
            self: *const IXmlReader,
            ppwszQualifiedName: ?*?PWSTR,
            pcwchQualifiedName: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamespaceUri: fn(
            self: *const IXmlReader,
            ppwszNamespaceUri: ?*?PWSTR,
            pcwchNamespaceUri: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalName: fn(
            self: *const IXmlReader,
            ppwszLocalName: ?*?PWSTR,
            pcwchLocalName: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrefix: fn(
            self: *const IXmlReader,
            ppwszPrefix: ?*?PWSTR,
            pcwchPrefix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IXmlReader,
            ppwszValue: ?*?PWSTR,
            pcwchValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadValueChunk: fn(
            self: *const IXmlReader,
            pwchBuffer: [*:0]u16,
            cwchChunkSize: u32,
            pcwchRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseUri: fn(
            self: *const IXmlReader,
            ppwszBaseUri: ?*?PWSTR,
            pcwchBaseUri: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDefault: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        IsEmptyElement: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetLineNumber: fn(
            self: *const IXmlReader,
            pnLineNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinePosition: fn(
            self: *const IXmlReader,
            pnLinePosition: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeCount: fn(
            self: *const IXmlReader,
            pnAttributeCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDepth: fn(
            self: *const IXmlReader,
            pnDepth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEOF: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_SetInput(self: *const T, pInput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).SetInput(@ptrCast(*const IXmlReader, self), pInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetProperty(self: *const T, nProperty: u32, ppValue: *isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlReader, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_SetProperty(self: *const T, nProperty: u32, pValue: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlReader, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_Read(self: *const T, pNodeType: ?*XmlNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).Read(@ptrCast(*const IXmlReader, self), pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetNodeType(self: *const T, pNodeType: *XmlNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetNodeType(@ptrCast(*const IXmlReader, self), pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToFirstAttribute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToFirstAttribute(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToNextAttribute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToNextAttribute(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToAttributeByName(self: *const T, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToAttributeByName(@ptrCast(*const IXmlReader, self), pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToElement(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetQualifiedName(self: *const T, ppwszQualifiedName: ?*?PWSTR, pcwchQualifiedName: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetQualifiedName(@ptrCast(*const IXmlReader, self), ppwszQualifiedName, pcwchQualifiedName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetNamespaceUri(self: *const T, ppwszNamespaceUri: ?*?PWSTR, pcwchNamespaceUri: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetNamespaceUri(@ptrCast(*const IXmlReader, self), ppwszNamespaceUri, pcwchNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLocalName(self: *const T, ppwszLocalName: ?*?PWSTR, pcwchLocalName: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLocalName(@ptrCast(*const IXmlReader, self), ppwszLocalName, pcwchLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetPrefix(self: *const T, ppwszPrefix: ?*?PWSTR, pcwchPrefix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetPrefix(@ptrCast(*const IXmlReader, self), ppwszPrefix, pcwchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetValue(self: *const T, ppwszValue: ?*?PWSTR, pcwchValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetValue(@ptrCast(*const IXmlReader, self), ppwszValue, pcwchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_ReadValueChunk(self: *const T, pwchBuffer: [*:0]u16, cwchChunkSize: u32, pcwchRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).ReadValueChunk(@ptrCast(*const IXmlReader, self), pwchBuffer, cwchChunkSize, pcwchRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetBaseUri(self: *const T, ppwszBaseUri: ?*?PWSTR, pcwchBaseUri: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetBaseUri(@ptrCast(*const IXmlReader, self), ppwszBaseUri, pcwchBaseUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsDefault(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsDefault(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsEmptyElement(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsEmptyElement(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLineNumber(self: *const T, pnLineNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLineNumber(@ptrCast(*const IXmlReader, self), pnLineNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLinePosition(self: *const T, pnLinePosition: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLinePosition(@ptrCast(*const IXmlReader, self), pnLinePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetAttributeCount(self: *const T, pnAttributeCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetAttributeCount(@ptrCast(*const IXmlReader, self), pnAttributeCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetDepth(self: *const T, pnDepth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetDepth(@ptrCast(*const IXmlReader, self), pnDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsEOF(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsEOF(@ptrCast(*const IXmlReader, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlResolver_Value = @import("../zig.zig").Guid.initString("7279fc82-709d-4095-b63d-69fe4b0d9030");
pub const IID_IXmlResolver = &IID_IXmlResolver_Value;
pub const IXmlResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResolveUri: fn(
            self: *const IXmlResolver,
            pwszBaseUri: ?[*:0]const u16,
            pwszPublicIdentifier: ?[*:0]const u16,
            pwszSystemIdentifier: ?[*:0]const u16,
            ppResolvedInput: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlResolver_ResolveUri(self: *const T, pwszBaseUri: ?[*:0]const u16, pwszPublicIdentifier: ?[*:0]const u16, pwszSystemIdentifier: ?[*:0]const u16, ppResolvedInput: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlResolver.VTable, self.vtable).ResolveUri(@ptrCast(*const IXmlResolver, self), pwszBaseUri, pwszPublicIdentifier, pwszSystemIdentifier, ppResolvedInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlWriter_Value = @import("../zig.zig").Guid.initString("7279fc88-709d-4095-b63d-69fe4b0d9030");
pub const IID_IXmlWriter = &IID_IXmlWriter_Value;
pub const IXmlWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutput: fn(
            self: *const IXmlWriter,
            pOutput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlWriter,
            nProperty: u32,
            ppValue: *isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlWriter,
            nProperty: u32,
            pValue: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributes: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributeString: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: ?[*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCData: fn(
            self: *const IXmlWriter,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCharEntity: fn(
            self: *const IXmlWriter,
            wch: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteChars: fn(
            self: *const IXmlWriter,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteComment: fn(
            self: *const IXmlWriter,
            pwszComment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDocType: fn(
            self: *const IXmlWriter,
            pwszName: ?[*:0]const u16,
            pwszPublicId: ?[*:0]const u16,
            pwszSystemId: ?[*:0]const u16,
            pwszSubset: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteElementString: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndDocument: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndElement: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEntityRef: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFullEndElement: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteName: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNmToken: fn(
            self: *const IXmlWriter,
            pwszNmToken: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNode: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNodeShallow: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProcessingInstruction: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteQualifiedName: fn(
            self: *const IXmlWriter,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRaw: fn(
            self: *const IXmlWriter,
            pwszData: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRawChars: fn(
            self: *const IXmlWriter,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartDocument: fn(
            self: *const IXmlWriter,
            standalone: XmlStandalone,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartElement: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteString: fn(
            self: *const IXmlWriter,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSurrogateCharEntity: fn(
            self: *const IXmlWriter,
            wchLow: u16,
            wchHigh: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWhitespace: fn(
            self: *const IXmlWriter,
            pwszWhitespace: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_SetOutput(self: *const T, pOutput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).SetOutput(@ptrCast(*const IXmlWriter, self), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_GetProperty(self: *const T, nProperty: u32, ppValue: *isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlWriter, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_SetProperty(self: *const T, nProperty: u32, pValue: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlWriter, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteAttributes(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteAttributes(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteAttributeString(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: ?[*:0]const u16, pwszNamespaceUri: ?[*:0]const u16, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteAttributeString(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteCData(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteCData(@ptrCast(*const IXmlWriter, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteCharEntity(self: *const T, wch: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteCharEntity(@ptrCast(*const IXmlWriter, self), wch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteChars(@ptrCast(*const IXmlWriter, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteComment(self: *const T, pwszComment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteComment(@ptrCast(*const IXmlWriter, self), pwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteDocType(self: *const T, pwszName: ?[*:0]const u16, pwszPublicId: ?[*:0]const u16, pwszSystemId: ?[*:0]const u16, pwszSubset: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteDocType(@ptrCast(*const IXmlWriter, self), pwszName, pwszPublicId, pwszSystemId, pwszSubset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteElementString(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteElementString(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEndDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEndDocument(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEndElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEndElement(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEntityRef(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEntityRef(@ptrCast(*const IXmlWriter, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteFullEndElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteFullEndElement(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteName(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteName(@ptrCast(*const IXmlWriter, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNmToken(self: *const T, pwszNmToken: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNmToken(@ptrCast(*const IXmlWriter, self), pwszNmToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNode(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNode(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNodeShallow(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNodeShallow(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteProcessingInstruction(self: *const T, pwszName: [*:0]const u16, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteProcessingInstruction(@ptrCast(*const IXmlWriter, self), pwszName, pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteQualifiedName(self: *const T, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteQualifiedName(@ptrCast(*const IXmlWriter, self), pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteRaw(self: *const T, pwszData: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteRaw(@ptrCast(*const IXmlWriter, self), pwszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteRawChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteRawChars(@ptrCast(*const IXmlWriter, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteStartDocument(self: *const T, standalone: XmlStandalone) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteStartDocument(@ptrCast(*const IXmlWriter, self), standalone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteStartElement(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteStartElement(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteString(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteString(@ptrCast(*const IXmlWriter, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteSurrogateCharEntity(self: *const T, wchLow: u16, wchHigh: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteSurrogateCharEntity(@ptrCast(*const IXmlWriter, self), wchLow, wchHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteWhitespace(self: *const T, pwszWhitespace: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteWhitespace(@ptrCast(*const IXmlWriter, self), pwszWhitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).Flush(@ptrCast(*const IXmlWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlWriterLite_Value = @import("../zig.zig").Guid.initString("862494c6-1310-4aad-b3cd-2dbeebf670d3");
pub const IID_IXmlWriterLite = &IID_IXmlWriterLite_Value;
pub const IXmlWriterLite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutput: fn(
            self: *const IXmlWriterLite,
            pOutput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlWriterLite,
            nProperty: u32,
            ppValue: *isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlWriterLite,
            nProperty: u32,
            pValue: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributes: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributeString: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
            pwszValue: ?[*:0]const u16,
            cwszValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCData: fn(
            self: *const IXmlWriterLite,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCharEntity: fn(
            self: *const IXmlWriterLite,
            wch: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteChars: fn(
            self: *const IXmlWriterLite,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteComment: fn(
            self: *const IXmlWriterLite,
            pwszComment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDocType: fn(
            self: *const IXmlWriterLite,
            pwszName: ?[*:0]const u16,
            pwszPublicId: ?[*:0]const u16,
            pwszSystemId: ?[*:0]const u16,
            pwszSubset: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteElementString: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndDocument: fn(
            self: *const IXmlWriterLite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEntityRef: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFullEndElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteName: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNmToken: fn(
            self: *const IXmlWriterLite,
            pwszNmToken: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNode: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNodeShallow: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProcessingInstruction: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRaw: fn(
            self: *const IXmlWriterLite,
            pwszData: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRawChars: fn(
            self: *const IXmlWriterLite,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartDocument: fn(
            self: *const IXmlWriterLite,
            standalone: XmlStandalone,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteString: fn(
            self: *const IXmlWriterLite,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSurrogateCharEntity: fn(
            self: *const IXmlWriterLite,
            wchLow: u16,
            wchHigh: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWhitespace: fn(
            self: *const IXmlWriterLite,
            pwszWhitespace: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IXmlWriterLite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_SetOutput(self: *const T, pOutput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).SetOutput(@ptrCast(*const IXmlWriterLite, self), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_GetProperty(self: *const T, nProperty: u32, ppValue: *isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlWriterLite, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_SetProperty(self: *const T, nProperty: u32, pValue: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlWriterLite, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteAttributes(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteAttributes(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteAttributeString(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32, pwszValue: ?[*:0]const u16, cwszValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteAttributeString(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName, pwszValue, cwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteCData(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteCData(@ptrCast(*const IXmlWriterLite, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteCharEntity(self: *const T, wch: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteCharEntity(@ptrCast(*const IXmlWriterLite, self), wch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteChars(@ptrCast(*const IXmlWriterLite, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteComment(self: *const T, pwszComment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteComment(@ptrCast(*const IXmlWriterLite, self), pwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteDocType(self: *const T, pwszName: ?[*:0]const u16, pwszPublicId: ?[*:0]const u16, pwszSystemId: ?[*:0]const u16, pwszSubset: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteDocType(@ptrCast(*const IXmlWriterLite, self), pwszName, pwszPublicId, pwszSystemId, pwszSubset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteElementString(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteElementString(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEndDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEndDocument(@ptrCast(*const IXmlWriterLite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEndElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEndElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEntityRef(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEntityRef(@ptrCast(*const IXmlWriterLite, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteFullEndElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteFullEndElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteName(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteName(@ptrCast(*const IXmlWriterLite, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNmToken(self: *const T, pwszNmToken: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNmToken(@ptrCast(*const IXmlWriterLite, self), pwszNmToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNode(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNode(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNodeShallow(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNodeShallow(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteProcessingInstruction(self: *const T, pwszName: [*:0]const u16, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteProcessingInstruction(@ptrCast(*const IXmlWriterLite, self), pwszName, pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteRaw(self: *const T, pwszData: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteRaw(@ptrCast(*const IXmlWriterLite, self), pwszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteRawChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteRawChars(@ptrCast(*const IXmlWriterLite, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteStartDocument(self: *const T, standalone: XmlStandalone) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteStartDocument(@ptrCast(*const IXmlWriterLite, self), standalone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteStartElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteStartElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteString(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteString(@ptrCast(*const IXmlWriterLite, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteSurrogateCharEntity(self: *const T, wchLow: u16, wchHigh: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteSurrogateCharEntity(@ptrCast(*const IXmlWriterLite, self), wchLow, wchHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteWhitespace(self: *const T, pwszWhitespace: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteWhitespace(@ptrCast(*const IXmlWriterLite, self), pwszWhitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).Flush(@ptrCast(*const IXmlWriterLite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DEVPROP_OPERATOR = extern enum(u32) {
    MODIFIER_NOT = 65536,
    MODIFIER_IGNORE_CASE = 131072,
    NONE = 0,
    EXISTS = 1,
    NOT_EXISTS = 65537,
    EQUALS = 2,
    NOT_EQUALS = 65538,
    GREATER_THAN = 3,
    LESS_THAN = 4,
    GREATER_THAN_EQUALS = 5,
    LESS_THAN_EQUALS = 6,
    EQUALS_IGNORE_CASE = 131074,
    NOT_EQUALS_IGNORE_CASE = 196610,
    BITWISE_AND = 7,
    BITWISE_OR = 8,
    BEGINS_WITH = 9,
    ENDS_WITH = 10,
    CONTAINS = 11,
    BEGINS_WITH_IGNORE_CASE = 131081,
    ENDS_WITH_IGNORE_CASE = 131082,
    CONTAINS_IGNORE_CASE = 131083,
    LIST_CONTAINS = 4096,
    LIST_ELEMENT_BEGINS_WITH = 8192,
    LIST_ELEMENT_ENDS_WITH = 12288,
    LIST_ELEMENT_CONTAINS = 16384,
    LIST_CONTAINS_IGNORE_CASE = 135168,
    LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = 139264,
    LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = 143360,
    LIST_ELEMENT_CONTAINS_IGNORE_CASE = 147456,
    AND_OPEN = 1048576,
    AND_CLOSE = 2097152,
    OR_OPEN = 3145728,
    OR_CLOSE = 4194304,
    NOT_OPEN = 5242880,
    NOT_CLOSE = 6291456,
    ARRAY_CONTAINS = 268435456,
    MASK_EVAL = 4095,
    MASK_LIST = 61440,
    MASK_MODIFIER = 983040,
    MASK_NOT_LOGICAL = 4027580415,
    MASK_LOGICAL = 267386880,
    MASK_ARRAY = 4026531840,
    _,
};
pub const DEVPROP_OPERATOR_MODIFIER_NOT = DEVPROP_OPERATOR.MODIFIER_NOT;
pub const DEVPROP_OPERATOR_MODIFIER_IGNORE_CASE = DEVPROP_OPERATOR.MODIFIER_IGNORE_CASE;
pub const DEVPROP_OPERATOR_NONE = DEVPROP_OPERATOR.NONE;
pub const DEVPROP_OPERATOR_EXISTS = DEVPROP_OPERATOR.EXISTS;
pub const DEVPROP_OPERATOR_NOT_EXISTS = DEVPROP_OPERATOR.NOT_EXISTS;
pub const DEVPROP_OPERATOR_EQUALS = DEVPROP_OPERATOR.EQUALS;
pub const DEVPROP_OPERATOR_NOT_EQUALS = DEVPROP_OPERATOR.NOT_EQUALS;
pub const DEVPROP_OPERATOR_GREATER_THAN = DEVPROP_OPERATOR.GREATER_THAN;
pub const DEVPROP_OPERATOR_LESS_THAN = DEVPROP_OPERATOR.LESS_THAN;
pub const DEVPROP_OPERATOR_GREATER_THAN_EQUALS = DEVPROP_OPERATOR.GREATER_THAN_EQUALS;
pub const DEVPROP_OPERATOR_LESS_THAN_EQUALS = DEVPROP_OPERATOR.LESS_THAN_EQUALS;
pub const DEVPROP_OPERATOR_EQUALS_IGNORE_CASE = DEVPROP_OPERATOR.EQUALS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_NOT_EQUALS_IGNORE_CASE = DEVPROP_OPERATOR.NOT_EQUALS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_BITWISE_AND = DEVPROP_OPERATOR.BITWISE_AND;
pub const DEVPROP_OPERATOR_BITWISE_OR = DEVPROP_OPERATOR.BITWISE_OR;
pub const DEVPROP_OPERATOR_BEGINS_WITH = DEVPROP_OPERATOR.BEGINS_WITH;
pub const DEVPROP_OPERATOR_ENDS_WITH = DEVPROP_OPERATOR.ENDS_WITH;
pub const DEVPROP_OPERATOR_CONTAINS = DEVPROP_OPERATOR.CONTAINS;
pub const DEVPROP_OPERATOR_BEGINS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.BEGINS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_ENDS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.ENDS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_CONTAINS = DEVPROP_OPERATOR.LIST_CONTAINS;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH = DEVPROP_OPERATOR.LIST_ELEMENT_BEGINS_WITH;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH = DEVPROP_OPERATOR.LIST_ELEMENT_ENDS_WITH;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS = DEVPROP_OPERATOR.LIST_ELEMENT_CONTAINS;
pub const DEVPROP_OPERATOR_LIST_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.LIST_CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_ENDS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_AND_OPEN = DEVPROP_OPERATOR.AND_OPEN;
pub const DEVPROP_OPERATOR_AND_CLOSE = DEVPROP_OPERATOR.AND_CLOSE;
pub const DEVPROP_OPERATOR_OR_OPEN = DEVPROP_OPERATOR.OR_OPEN;
pub const DEVPROP_OPERATOR_OR_CLOSE = DEVPROP_OPERATOR.OR_CLOSE;
pub const DEVPROP_OPERATOR_NOT_OPEN = DEVPROP_OPERATOR.NOT_OPEN;
pub const DEVPROP_OPERATOR_NOT_CLOSE = DEVPROP_OPERATOR.NOT_CLOSE;
pub const DEVPROP_OPERATOR_ARRAY_CONTAINS = DEVPROP_OPERATOR.ARRAY_CONTAINS;
pub const DEVPROP_OPERATOR_MASK_EVAL = DEVPROP_OPERATOR.MASK_EVAL;
pub const DEVPROP_OPERATOR_MASK_LIST = DEVPROP_OPERATOR.MASK_LIST;
pub const DEVPROP_OPERATOR_MASK_MODIFIER = DEVPROP_OPERATOR.MASK_MODIFIER;
pub const DEVPROP_OPERATOR_MASK_NOT_LOGICAL = DEVPROP_OPERATOR.MASK_NOT_LOGICAL;
pub const DEVPROP_OPERATOR_MASK_LOGICAL = DEVPROP_OPERATOR.MASK_LOGICAL;
pub const DEVPROP_OPERATOR_MASK_ARRAY = DEVPROP_OPERATOR.MASK_ARRAY;

pub const DEVPROP_FILTER_EXPRESSION = extern struct {
    Operator: DEVPROP_OPERATOR,
    Property: DEVPROPERTY,
};

pub const DEV_OBJECT_TYPE = extern enum(i32) {
    Unknown = 0,
    DeviceInterface = 1,
    DeviceContainer = 2,
    Device = 3,
    DeviceInterfaceClass = 4,
    AEP = 5,
    AEPContainer = 6,
    DeviceInstallerClass = 7,
    DeviceInterfaceDisplay = 8,
    DeviceContainerDisplay = 9,
    AEPService = 10,
    DevicePanel = 11,
};
pub const DevObjectTypeUnknown = DEV_OBJECT_TYPE.Unknown;
pub const DevObjectTypeDeviceInterface = DEV_OBJECT_TYPE.DeviceInterface;
pub const DevObjectTypeDeviceContainer = DEV_OBJECT_TYPE.DeviceContainer;
pub const DevObjectTypeDevice = DEV_OBJECT_TYPE.Device;
pub const DevObjectTypeDeviceInterfaceClass = DEV_OBJECT_TYPE.DeviceInterfaceClass;
pub const DevObjectTypeAEP = DEV_OBJECT_TYPE.AEP;
pub const DevObjectTypeAEPContainer = DEV_OBJECT_TYPE.AEPContainer;
pub const DevObjectTypeDeviceInstallerClass = DEV_OBJECT_TYPE.DeviceInstallerClass;
pub const DevObjectTypeDeviceInterfaceDisplay = DEV_OBJECT_TYPE.DeviceInterfaceDisplay;
pub const DevObjectTypeDeviceContainerDisplay = DEV_OBJECT_TYPE.DeviceContainerDisplay;
pub const DevObjectTypeAEPService = DEV_OBJECT_TYPE.AEPService;
pub const DevObjectTypeDevicePanel = DEV_OBJECT_TYPE.DevicePanel;

pub const DEV_QUERY_FLAGS = extern enum(i32) {
    None = 0,
    UpdateResults = 1,
    AllProperties = 2,
    Localize = 4,
    AsyncClose = 8,
};
pub const DevQueryFlagNone = DEV_QUERY_FLAGS.None;
pub const DevQueryFlagUpdateResults = DEV_QUERY_FLAGS.UpdateResults;
pub const DevQueryFlagAllProperties = DEV_QUERY_FLAGS.AllProperties;
pub const DevQueryFlagLocalize = DEV_QUERY_FLAGS.Localize;
pub const DevQueryFlagAsyncClose = DEV_QUERY_FLAGS.AsyncClose;

pub const DEV_QUERY_STATE = extern enum(i32) {
    Initialized = 0,
    EnumCompleted = 1,
    Aborted = 2,
    Closed = 3,
};
pub const DevQueryStateInitialized = DEV_QUERY_STATE.Initialized;
pub const DevQueryStateEnumCompleted = DEV_QUERY_STATE.EnumCompleted;
pub const DevQueryStateAborted = DEV_QUERY_STATE.Aborted;
pub const DevQueryStateClosed = DEV_QUERY_STATE.Closed;

pub const DEV_QUERY_RESULT_ACTION = extern enum(i32) {
    StateChange = 0,
    Add = 1,
    Update = 2,
    Remove = 3,
};
pub const DevQueryResultStateChange = DEV_QUERY_RESULT_ACTION.StateChange;
pub const DevQueryResultAdd = DEV_QUERY_RESULT_ACTION.Add;
pub const DevQueryResultUpdate = DEV_QUERY_RESULT_ACTION.Update;
pub const DevQueryResultRemove = DEV_QUERY_RESULT_ACTION.Remove;

pub const DEV_OBJECT = extern struct {
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    cPropertyCount: u32,
    pProperties: *const DEVPROPERTY,
};

pub const DEV_QUERY_RESULT_ACTION_DATA = extern struct {
    Action: DEV_QUERY_RESULT_ACTION,
    Data: _DEV_QUERY_RESULT_UPDATE_PAYLOAD,
    const _DEV_QUERY_RESULT_UPDATE_PAYLOAD = u32; // TODO: generate this nested type!
};

pub const DEV_QUERY_PARAMETER = extern struct {
    Key: DEVPROPKEY,
    Type: u32,
    BufferSize: u32,
    Buffer: *c_void,
};

pub const HDEVQUERY__ = extern struct {
    unused: i32,
};

pub const PDEV_QUERY_RESULT_CALLBACK = fn(
    hDevQuery: *HDEVQUERY__,
    pContext: ?*c_void,
    pActionData: *const DEV_QUERY_RESULT_ACTION_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const GLOBAL_FILTER = extern enum(i32) {
    FRAGMENTS = 2,
    STRONGHOST = 8,
    FRAGCACHE = 9,
};
pub const GF_FRAGMENTS = GLOBAL_FILTER.FRAGMENTS;
pub const GF_STRONGHOST = GLOBAL_FILTER.STRONGHOST;
pub const GF_FRAGCACHE = GLOBAL_FILTER.FRAGCACHE;

pub const PFFORWARD_ACTION = extern enum(i32) {
    FORWARD = 0,
    DROP = 1,
};
pub const PF_ACTION_FORWARD = PFFORWARD_ACTION.FORWARD;
pub const PF_ACTION_DROP = PFFORWARD_ACTION.DROP;

pub const PFADDRESSTYPE = extern enum(i32) {
    @"4" = 0,
    @"6" = 1,
};
pub const PF_IPV4 = PFADDRESSTYPE.@"4";
pub const PF_IPV6 = PFADDRESSTYPE.@"6";

pub const PF_FILTER_DESCRIPTOR = extern struct {
    dwFilterFlags: u32,
    dwRule: u32,
    pfatType: PFADDRESSTYPE,
    SrcAddr: *u8,
    SrcMask: *u8,
    DstAddr: *u8,
    DstMask: *u8,
    dwProtocol: u32,
    fLateBound: u32,
    wSrcPort: u16,
    wDstPort: u16,
    wSrcPortHighRange: u16,
    wDstPortHighRange: u16,
};

pub const PF_FILTER_STATS = extern struct {
    dwNumPacketsFiltered: u32,
    info: PF_FILTER_DESCRIPTOR,
};

pub const PF_INTERFACE_STATS = extern struct {
    pvDriverContext: *c_void,
    dwFlags: u32,
    dwInDrops: u32,
    dwOutDrops: u32,
    eaInAction: PFFORWARD_ACTION,
    eaOutAction: PFFORWARD_ACTION,
    dwNumInFilters: u32,
    dwNumOutFilters: u32,
    dwFrag: u32,
    dwSpoof: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    liSYN: LARGE_INTEGER,
    liTotalLogged: LARGE_INTEGER,
    dwLostLogEntries: u32,
    FilterInfo: [1]PF_FILTER_STATS,
};

pub const PF_LATEBIND_INFO = extern struct {
    SrcAddr: *u8,
    DstAddr: *u8,
    Mask: *u8,
};

pub const PFFRAMETYPE = extern enum(i32) {
    FILTER = 1,
    FRAG = 2,
    SPOOF = 3,
};
pub const PFFT_FILTER = PFFRAMETYPE.FILTER;
pub const PFFT_FRAG = PFFRAMETYPE.FRAG;
pub const PFFT_SPOOF = PFFRAMETYPE.SPOOF;

pub const PFLOGFRAME = extern struct {
    Timestamp: LARGE_INTEGER,
    pfeTypeOfFrame: PFFRAMETYPE,
    dwTotalSizeUsed: u32,
    dwFilterRule: u32,
    wSizeOfAdditionalData: u16,
    wSizeOfIpHeader: u16,
    dwInterfaceName: u32,
    dwIPIndex: u32,
    bPacketData: [1]u8,
};

pub const NETLOGON_INFO_1 = extern struct {
    netlog1_flags: u32,
    netlog1_pdc_connection_status: u32,
};

pub const NETLOGON_INFO_2 = extern struct {
    netlog2_flags: u32,
    netlog2_pdc_connection_status: u32,
    netlog2_trusted_dc_name: PWSTR,
    netlog2_tc_connection_status: u32,
};

pub const NETLOGON_INFO_3 = extern struct {
    netlog3_flags: u32,
    netlog3_logon_attempts: u32,
    netlog3_reserved1: u32,
    netlog3_reserved2: u32,
    netlog3_reserved3: u32,
    netlog3_reserved4: u32,
    netlog3_reserved5: u32,
};

pub const NETLOGON_INFO_4 = extern struct {
    netlog4_trusted_dc_name: PWSTR,
    netlog4_trusted_domain_name: PWSTR,
};

pub const EXTENDED_NAME_FORMAT = extern enum(i32) {
    Unknown = 0,
    FullyQualifiedDN = 1,
    SamCompatible = 2,
    Display = 3,
    UniqueId = 6,
    Canonical = 7,
    UserPrincipal = 8,
    CanonicalEx = 9,
    ServicePrincipal = 10,
    DnsDomain = 12,
    GivenName = 13,
    Surname = 14,
};
pub const NameUnknown = EXTENDED_NAME_FORMAT.Unknown;
pub const NameFullyQualifiedDN = EXTENDED_NAME_FORMAT.FullyQualifiedDN;
pub const NameSamCompatible = EXTENDED_NAME_FORMAT.SamCompatible;
pub const NameDisplay = EXTENDED_NAME_FORMAT.Display;
pub const NameUniqueId = EXTENDED_NAME_FORMAT.UniqueId;
pub const NameCanonical = EXTENDED_NAME_FORMAT.Canonical;
pub const NameUserPrincipal = EXTENDED_NAME_FORMAT.UserPrincipal;
pub const NameCanonicalEx = EXTENDED_NAME_FORMAT.CanonicalEx;
pub const NameServicePrincipal = EXTENDED_NAME_FORMAT.ServicePrincipal;
pub const NameDnsDomain = EXTENDED_NAME_FORMAT.DnsDomain;
pub const NameGivenName = EXTENDED_NAME_FORMAT.GivenName;
pub const NameSurname = EXTENDED_NAME_FORMAT.Surname;


//--------------------------------------------------------------------------------
// Section: Functions (483)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_lstrcmpW(
    String1: *u16,
    String2: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_lstrcmpiW(
    String1: *u16,
    String2: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_lstrlenW(
    String: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_wcschr(
    String: *u16,
    Character: u16,
) callconv(@import("std").os.windows.WINAPI) *u16;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_wcscpy(
    Destination: *u16,
    Source: *u16,
) callconv(@import("std").os.windows.WINAPI) *u16;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_wcsicmp(
    String1: *u16,
    String2: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_wcslen(
    String: *u16,
) callconv(@import("std").os.windows.WINAPI) usize;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn uaw_wcsrchr(
    String: *u16,
    Character: u16,
) callconv(@import("std").os.windows.WINAPI) *u16;

}, else => struct { } };

pub extern "KERNEL32" fn RtlRaiseException(
    ExceptionRecord: *EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn DisableProcessWindowsGhosting(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrSimpleStructMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexStructMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrConformantArrayMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexArrayMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrSimpleStructUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexStructUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexArrayUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrUserMarshalUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrSimpleStructBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexStructBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCRT4" fn NdrConformantArrayBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "RPCRT4" fn NdrComplexArrayBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-apiquery-l2-1-0" fn IsApiSetImplemented(
    Contract: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetEnvironmentStringsW(
    NewEnvironment: [*]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetStdHandle(
    nStdHandle: STD_HANDLE_TYPE,
) callconv(@import("std").os.windows.WINAPI) NonClosableHandle;

pub extern "KERNEL32" fn SetStdHandle(
    nStdHandle: STD_HANDLE_TYPE,
    hHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetStdHandleEx(
    nStdHandle: STD_HANDLE_TYPE,
    hHandle: HANDLE,
    phPrevValue: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn ExpandEnvironmentStringsA(
    lpSrc: [*:0]const u8,
    lpDst: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn ExpandEnvironmentStringsW(
    lpSrc: [*:0]const u16,
    lpDst: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetCurrentDirectoryA(
    lpPathName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCurrentDirectoryW(
    lpPathName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetCurrentDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CloseHandle(
    hObject: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn DuplicateHandle(
    hSourceProcessHandle: HANDLE,
    hSourceHandle: HANDLE,
    hTargetProcessHandle: HANDLE,
    lpTargetHandle: *HANDLE,
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwOptions: DUPLICATE_HANDLE_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-handle-l1-1-0" fn CompareObjectHandles(
    hFirstObjectHandle: HANDLE,
    hSecondObjectHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetHandleInformation(
    hObject: HANDLE,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetHandleInformation(
    hObject: HANDLE,
    dwMask: u32,
    dwFlags: HANDLE_FLAG_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn QueryPerformanceCounter(
    lpPerformanceCount: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn QueryPerformanceFrequency(
    lpFrequency: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessDynamicEHContinuationTargets(
    Process: HANDLE,
    NumberOfTargets: u16,
    Targets: [*]PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn IsProcessorFeaturePresent(
    ProcessorFeature: PROCESSOR_FEATURE_ID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemTimes(
    lpIdleTime: ?*FILETIME,
    lpKernelTime: ?*FILETIME,
    lpUserTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemCpuSetInformation(
    // TODO: what to do with BytesParamIndex 1?
    Information: ?*SYSTEM_CPU_SET_INFORMATION,
    BufferLength: u32,
    ReturnedLength: *u32,
    Process: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessDefaultCpuSets(
    Process: HANDLE,
    CpuSetIds: ?[*]u32,
    CpuSetIdCount: u32,
    RequiredIdCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessDefaultCpuSets(
    Process: HANDLE,
    CpuSetIds: ?[*]const u32,
    CpuSetIdCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadSelectedCpuSets(
    Thread: HANDLE,
    CpuSetIds: ?[*]u32,
    CpuSetIdCount: u32,
    RequiredIdCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadSelectedCpuSets(
    Thread: HANDLE,
    CpuSetIds: [*]const u32,
    CpuSetIdCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemInfo(
    lpSystemInfo: *SYSTEM_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemTime(
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemTimeAsFileTime(
    lpSystemTimeAsFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetLocalTime(
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn IsUserCetAvailableInEnvironment(
    UserCetEnvironment: USER_CET_ENVIRONMENT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemLeapSecondInformation(
    Enabled: *BOOL,
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetLocalTime(
    lpSystemTime: *const SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetTickCount(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetTickCount64(
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemTimeAdjustment(
    lpTimeAdjustment: *u32,
    lpTimeIncrement: *u32,
    lpTimeAdjustmentDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-sysinfo-l1-2-4" fn GetSystemTimeAdjustmentPrecise(
    lpTimeAdjustment: *u64,
    lpTimeIncrement: *u64,
    lpTimeAdjustmentDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetWindowsDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetWindowsDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemWindowsDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetSystemWindowsDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetComputerNameExA(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetComputerNameExW(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetComputerNameExW(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetSystemTime(
    lpSystemTime: *const SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetVersionExA(
    lpVersionInformation: *OSVERSIONINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetVersionExW(
    lpVersionInformation: *OSVERSIONINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetNativeSystemInfo(
    lpSystemInfo: *SYSTEM_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetSystemTimePreciseAsFileTime(
    lpSystemTimeAsFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProductInfo(
    dwOSMajorVersion: u32,
    dwOSMinorVersion: u32,
    dwSpMajorVersion: u32,
    dwSpMinorVersion: u32,
    pdwReturnedProductType: *OS_PRODUCT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn VerSetConditionMask(
    ConditionMask: u64,
    TypeMask: VER_FLAGS,
    Condition: u8,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "api-ms-win-core-sysinfo-l1-2-0" fn GetOsSafeBootMode(
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn EnumSystemFirmwareTables(
    FirmwareTableProviderSignature: u32,
    // TODO: what to do with BytesParamIndex 2?
    pFirmwareTableEnumBuffer: ?*c_void,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemFirmwareTable(
    FirmwareTableProviderSignature: u32,
    FirmwareTableID: u32,
    // TODO: what to do with BytesParamIndex 3?
    pFirmwareTableBuffer: ?*c_void,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn DnsHostnameToComputerNameExW(
    Hostname: [*:0]const u16,
    ComputerName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetComputerNameEx2W(
    NameType: COMPUTER_NAME_FORMAT,
    Flags: u32,
    lpBuffer: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetSystemTimeAdjustment(
    dwTimeAdjustment: u32,
    bTimeAdjustmentDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-sysinfo-l1-2-4" fn SetSystemTimeAdjustmentPrecise(
    dwTimeAdjustment: u64,
    bTimeAdjustmentDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-sysinfo-l1-2-3" fn GetOsManufacturingMode(
    pbEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-sysinfo-l1-2-3" fn GetIntegratedDisplaySize(
    sizeInInches: *f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetComputerNameA(
    lpComputerName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetComputerNameW(
    lpComputerName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetComputerNameExA(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTimePrecise(
    lpInterruptTimePrecise: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryUnbiasedInterruptTimePrecise(
    lpUnbiasedInterruptTimePrecise: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTime(
    lpInterruptTime: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn QueryUnbiasedInterruptTime(
    UnbiasedTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn QueryAuxiliaryCounterFrequency(
    lpAuxiliaryCounterFrequency: *u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertAuxiliaryCounterToPerformanceCounter(
    ullAuxiliaryCounterValue: u64,
    lpPerformanceCounterValue: *u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertPerformanceCounterToAuxiliaryCounter(
    ullPerformanceCounterValue: u64,
    lpAuxiliaryCounterValue: *u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GlobalCompact(
    dwMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "KERNEL32" fn GlobalFix(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GlobalUnfix(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GlobalWire(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn GlobalUnWire(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalShrink(
    hMem: isize,
    cbNewSize: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "KERNEL32" fn LocalCompact(
    uMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "KERNEL32" fn SetEnvironmentStringsA(
    NewEnvironment: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetHandleCount(
    uNumber: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn RequestDeviceWakeup(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CancelDeviceWakeupRequest(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetMessageWaitingIndicator(
    hMsgIndicator: HANDLE,
    ulMsgCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MulDiv(
    nNumber: i32,
    nNumerator: i32,
    nDenominator: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemRegistryQuota(
    pdwQuotaAllowed: ?*u32,
    pdwQuotaUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn FileTimeToDosDateTime(
    lpFileTime: *const FILETIME,
    lpFatDate: *u16,
    lpFatTime: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn DosDateTimeToFileTime(
    wFatDate: u16,
    wFatTime: u16,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn _lopen(
    lpPathName: [*:0]const u8,
    iReadWrite: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lcreat(
    lpPathName: [*:0]const u8,
    iAttribute: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lread(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn _lwrite(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: [*]const u8,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn _hread(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _hwrite(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: [*]const u8,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lclose(
    hFile: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _llseek(
    hFile: i32,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn OpenMutexA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenSemaphoreA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenWaitableTimerA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerExA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetStartupInfoA(
    lpStartupInfo: *STARTUPINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableExA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableExW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*c_void,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*c_void,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*c_void,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableExA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*c_void,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableExW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*c_void,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetFirmwareType(
    FirmwareType: *FIRMWARE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn IsNativeVhdBoot(
    NativeVhdBoot: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileIntA(
    lpAppName: [*:0]const u8,
    lpKeyName: [*:0]const u8,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileIntW(
    lpAppName: [*:0]const u16,
    lpKeyName: [*:0]const u16,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WriteProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WriteProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileSectionA(
    lpAppName: [*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetProfileSectionW(
    lpAppName: [*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WriteProfileSectionA(
    lpAppName: [*:0]const u8,
    lpString: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WriteProfileSectionW(
    lpAppName: [*:0]const u16,
    lpString: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileIntA(
    lpAppName: [*:0]const u8,
    lpKeyName: [*:0]const u8,
    nDefault: i32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileIntW(
    lpAppName: [*:0]const u16,
    lpKeyName: [*:0]const u16,
    nDefault: i32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileSectionA(
    lpAppName: [*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileSectionW(
    lpAppName: [*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileSectionNamesA(
    lpszReturnBuffer: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileSectionNamesW(
    lpszReturnBuffer: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileStructA(
    lpszSection: [*:0]const u8,
    lpszKey: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*c_void,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetPrivateProfileStructW(
    lpszSection: [*:0]const u16,
    lpszKey: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*c_void,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileStructA(
    lpszSection: [*:0]const u8,
    lpszKey: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*c_void,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WritePrivateProfileStructW(
    lpszSection: [*:0]const u16,
    lpszKey: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*c_void,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadHugeReadPtr(
    lp: ?*const c_void,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadHugeWritePtr(
    lp: ?*c_void,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetComputerNameA(
    lpBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetComputerNameW(
    lpBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn DnsHostnameToComputerNameA(
    Hostname: [*:0]const u8,
    ComputerName: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn DnsHostnameToComputerNameW(
    Hostname: [*:0]const u16,
    ComputerName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetUserNameA(
    lpBuffer: ?[*:0]u8,
    pcbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetUserNameW(
    lpBuffer: ?[*:0]u16,
    pcbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn IsTokenUntrusted(
    TokenHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetTimerQueueTimer(
    TimerQueue: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Parameter: ?*c_void,
    DueTime: u32,
    Period: u32,
    PreferIo: BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CancelTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetCurrentHwProfileA(
    lpHwProfileInfo: *HW_PROFILE_INFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetCurrentHwProfileW(
    lpHwProfileInfo: *HW_PROFILE_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn VerifyVersionInfoA(
    lpVersionInformation: *OSVERSIONINFOEXA,
    dwTypeMask: VER_FLAGS,
    dwlConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn VerifyVersionInfoW(
    lpVersionInformation: *OSVERSIONINFOEXW,
    dwTypeMask: VER_FLAGS,
    dwlConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SystemTimeToTzSpecificLocalTime(
    lpTimeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    lpUniversalTime: *const SYSTEMTIME,
    lpLocalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TzSpecificLocalTimeToSystemTime(
    lpTimeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FileTimeToSystemTime(
    lpFileTime: *const FILETIME,
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SystemTimeToFileTime(
    lpSystemTime: *const SYSTEMTIME,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetTimeZoneInformation(
    lpTimeZoneInformation: *TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetTimeZoneInformation(
    lpTimeZoneInformation: *const TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetDynamicTimeZoneInformation(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDynamicTimeZoneInformation(
    pTimeZoneInformation: *DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetTimeZoneInformationForYear(
    wYear: u16,
    pdtzi: ?*DYNAMIC_TIME_ZONE_INFORMATION,
    ptzi: *TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn EnumDynamicTimeZoneInformation(
    dwIndex: u32,
    lpTimeZoneInformation: *DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn GetDynamicTimeZoneInformationEffectiveYears(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
    FirstYear: *u32,
    LastYear: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SystemTimeToTzSpecificLocalTimeEx(
    lpTimeZoneInformation: ?*const DYNAMIC_TIME_ZONE_INFORMATION,
    lpUniversalTime: *const SYSTEMTIME,
    lpLocalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn TzSpecificLocalTimeToSystemTimeEx(
    lpTimeZoneInformation: ?*const DYNAMIC_TIME_ZONE_INFORMATION,
    lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalFileTimeToLocalSystemTime(
    timeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    localFileTime: *const FILETIME,
    localSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalSystemTimeToLocalFileTime(
    timeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    localSystemTime: *const SYSTEMTIME,
    localFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateJobSet(
    NumJob: u32,
    UserJobSet: [*]JOB_SET_ARRAY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReplacePartitionUnit(
    TargetPartition: PWSTR,
    SparePartition: PWSTR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeContext2(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    ContextFlags: u32,
    Context: **CONTEXT,
    ContextLength: *u32,
    XStateCompactionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-backgroundtask-l1-1-0" fn RaiseCustomSystemEventTrigger(
    CustomSystemEventTriggerConfig: *CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCloseKey(
    hKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOverridePredefKey(
    hKey: HKEY,
    hNewHKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenUserClassesRoot(
    hToken: HANDLE,
    dwOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenCurrentUser(
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDisablePredefinedCache(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDisablePredefinedCacheEx(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegConnectRegistryA(
    lpMachineName: ?[*:0]const u8,
    hKey: HKEY,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegConnectRegistryW(
    lpMachineName: ?[*:0]const u16,
    hKey: HKEY,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExA(
    lpMachineName: ?[*:0]const u8,
    hKey: HKEY,
    Flags: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExW(
    lpMachineName: ?[*:0]const u16,
    hKey: HKEY,
    Flags: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyExA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyExW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCreateKeyTransactedA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCreateKeyTransactedW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteKeyA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteKeyW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyExA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyExW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyTransactedA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    samDesired: u32,
    Reserved: u32,
    hTransaction: HANDLE,
    pExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyTransactedW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    samDesired: u32,
    Reserved: u32,
    hTransaction: HANDLE,
    pExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDisableReflectionKey(
    hBase: HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegEnableReflectionKey(
    hBase: HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegQueryReflectionKey(
    hBase: HKEY,
    bIsReflectionDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteValueA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteValueW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyA(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyW(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyExA(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    lpcchName: *u32,
    lpReserved: *u32,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyExW(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    lpcchName: *u32,
    lpReserved: *u32,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumValueA(
    hKey: HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u8,
    lpcchValueName: *u32,
    lpReserved: *u32,
    lpType: ?*u32,
    // TODO: what to do with BytesParamIndex 7?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumValueW(
    hKey: HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u16,
    lpcchValueName: *u32,
    lpReserved: *u32,
    lpType: ?*u32,
    // TODO: what to do with BytesParamIndex 7?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegFlushKey(
    hKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegLoadKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpFile: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegLoadKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpFile: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegNotifyChangeKeyValue(
    hKey: HKEY,
    bWatchSubtree: BOOL,
    dwNotifyFilter: REG_NOTIFY_FILTER,
    hEvent: HANDLE,
    fAsynchronous: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyExA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyExW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegOpenKeyTransactedA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: *HKEY,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegOpenKeyTransactedW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: *HKEY,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryInfoKeyA(
    hKey: HKEY,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpReserved: *u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryInfoKeyW(
    hKey: HKEY,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpReserved: *u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpData: ?PSTR,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpData: ?PWSTR,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryMultipleValuesA(
    hKey: HKEY,
    val_list: [*]VALENTA,
    num_vals: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpValueBuf: ?PSTR,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryMultipleValuesW(
    hKey: HKEY,
    val_list: [*]VALENTW,
    num_vals: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpValueBuf: ?PWSTR,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueExA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
    lpReserved: *u32,
    lpType: ?*REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueExW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
    lpReserved: *u32,
    lpType: ?*REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegReplaceKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpNewFile: [*:0]const u8,
    lpOldFile: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegReplaceKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpNewFile: [*:0]const u16,
    lpOldFile: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegRestoreKeyA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    dwFlags: REG_RESTORE_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegRestoreKeyW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    dwFlags: REG_RESTORE_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegRenameKey(
    hKey: HKEY,
    lpSubKeyName: ?[*:0]const u16,
    lpNewKeyName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSaveKeyA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSaveKeyW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    lpData: ?[*:0]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    lpData: ?[*:0]const u16,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueExA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
    Reserved: u32,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueExW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
    Reserved: u32,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegUnLoadKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegUnLoadKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegSetKeyValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const c_void,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegSetKeyValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const c_void,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteTreeA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteTreeW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCopyTreeA(
    hKeySrc: HKEY,
    lpSubKey: ?[*:0]const u8,
    hKeyDest: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegGetValueA(
    hkey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValue: ?[*:0]const u8,
    dwFlags: RRF_RT,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*c_void,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegGetValueW(
    hkey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValue: ?[*:0]const u16,
    dwFlags: RRF_RT,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*c_void,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCopyTreeW(
    hKeySrc: HKEY,
    lpSubKey: ?[*:0]const u16,
    hKeyDest: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadMUIStringA(
    hKey: HKEY,
    pszValue: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pszOutBuf: ?PSTR,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadMUIStringW(
    hKey: HKEY,
    pszValue: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pszOutBuf: ?PWSTR,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadAppKeyA(
    lpFile: [*:0]const u8,
    phkResult: *HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadAppKeyW(
    lpFile: [*:0]const u16,
    phkResult: *HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn CheckForHiberboot(
    pHiberboot: *u8,
    bClearFlag: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSaveKeyExA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: REG_SAVE_FORMAT,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSaveKeyExW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: REG_SAVE_FORMAT,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtClose(
    Handle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtCreateFile(
    FileHandle: *HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: *OBJECT_ATTRIBUTES,
    IoStatusBlock: *IO_STATUS_BLOCK,
    AllocationSize: *LARGE_INTEGER,
    FileAttributes: u32,
    ShareAccess: FILE_SHARE_MODE,
    CreateDisposition: NT_CREATE_FILE_DISPOSITION,
    CreateOptions: u32,
    EaBuffer: *c_void,
    EaLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtOpenFile(
    FileHandle: *HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: *OBJECT_ATTRIBUTES,
    IoStatusBlock: *IO_STATUS_BLOCK,
    ShareAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtRenameKey(
    KeyHandle: HANDLE,
    NewName: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtNotifyChangeMultipleKeys(
    MasterKeyHandle: HANDLE,
    Count: u32,
    SubordinateObjects: ?[*]OBJECT_ATTRIBUTES,
    Event: HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    CompletionFilter: u32,
    WatchTree: u8,
    // TODO: what to do with BytesParamIndex 10?
    Buffer: ?*c_void,
    BufferSize: u32,
    Asynchronous: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryMultipleValueKey(
    KeyHandle: HANDLE,
    ValueEntries: [*]KEY_VALUE_ENTRY,
    EntryCount: u32,
    // TODO: what to do with BytesParamIndex 4?
    ValueBuffer: *c_void,
    BufferLength: *u32,
    RequiredBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtSetInformationKey(
    KeyHandle: HANDLE,
    KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    KeySetInformation: *c_void,
    KeySetInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtDeviceIoControlFile(
    FileHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: PIO_APC_ROUTINE,
    ApcContext: *c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    IoControlCode: u32,
    InputBuffer: *c_void,
    InputBufferLength: u32,
    OutputBuffer: *c_void,
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtWaitForSingleObject(
    Handle: HANDLE,
    Alertable: u8,
    Timeout: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlIsNameLegalDOS8Dot3(
    Name: *UNICODE_STRING,
    OemName: *STRING,
    NameContainsSpaces: *u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn NtQueryObject(
    Handle: HANDLE,
    ObjectInformationClass: OBJECT_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ObjectInformation: ?*c_void,
    ObjectInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemInformation(
    SystemInformationClass: SYSTEM_INFORMATION_CLASS,
    SystemInformation: *c_void,
    SystemInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemTime(
    SystemTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlLocalTimeToSystemTime(
    LocalTime: *LARGE_INTEGER,
    SystemTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlTimeToSecondsSince1970(
    Time: *LARGE_INTEGER,
    ElapsedSeconds: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeAnsiString(
    AnsiString: *STRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeUnicodeString(
    UnicodeString: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeOemString(
    OemString: *STRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitString(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitStringEx(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlInitAnsiString(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitAnsiStringEx(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlInitUnicodeString(
    DestinationString: *UNICODE_STRING,
    SourceString: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlAnsiStringToUnicodeString(
    DestinationString: *UNICODE_STRING,
    SourceString: *STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeStringToAnsiString(
    DestinationString: *STRING,
    SourceString: *UNICODE_STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeStringToOemString(
    DestinationString: *STRING,
    SourceString: *UNICODE_STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeToMultiByteSize(
    BytesInMultiByteString: *u32,
    // TODO: what to do with BytesParamIndex 2?
    UnicodeString: [*]u16,
    BytesInUnicodeString: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlCharToInteger(
    String: *i8,
    Base: u32,
    Value: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUniform(
    Seed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "verifier" fn VerifierEnumerateResource(
    Process: HANDLE,
    Flags: VERIFIER_ENUM_RESOURCE_FLAGS,
    ResourceType: eAvrfResourceTypes,
    ResourceCallback: AVRF_RESOURCE_ENUMERATE_CALLBACK,
    EnumerationContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "Cabinet" fn FCICreate(
    perf: *ERF,
    pfnfcifp: PFNFCIFILEPLACED,
    pfna: PFNFCIALLOC,
    pfnf: PFNFCIFREE,
    pfnopen: PFNFCIOPEN,
    pfnread: PFNFCIREAD,
    pfnwrite: PFNFCIWRITE,
    pfnclose: PFNFCICLOSE,
    pfnseek: PFNFCISEEK,
    pfndelete: PFNFCIDELETE,
    pfnfcigtf: PFNFCIGETTEMPFILE,
    pccab: *CCAB,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "Cabinet" fn FCIAddFile(
    hfci: *c_void,
    pszSourceFile: PSTR,
    pszFileName: PSTR,
    fExecute: BOOL,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
    pfnfcigoi: PFNFCIGETOPENINFO,
    typeCompress: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIFlushCabinet(
    hfci: *c_void,
    fGetNextCab: BOOL,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIFlushFolder(
    hfci: *c_void,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIDestroy(
    hfci: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "Cabinet" fn FDICreate(
    pfnalloc: PFNALLOC,
    pfnfree: PFNFREE,
    pfnopen: PFNOPEN,
    pfnread: PFNREAD,
    pfnwrite: PFNWRITE,
    pfnclose: PFNCLOSE,
    pfnseek: PFNSEEK,
    cpuType: FDICREATE_CPU_TYPE,
    perf: *ERF,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "Cabinet" fn FDIIsCabinet(
    hfdi: *c_void,
    hf: isize,
    pfdici: ?*FDICABINETINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "Cabinet" fn FDICopy(
    hfdi: *c_void,
    pszCabinet: PSTR,
    pszCabPath: PSTR,
    flags: i32,
    pfnfdin: PFNFDINOTIFY,
    pfnfdid: PFNFDIDECRYPT,
    pvUser: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "Cabinet" fn FDIDestroy(
    hfdi: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FDITruncateCabinet(
    hfdi: *c_void,
    pszCabinetName: PSTR,
    iFolderToDelete: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn GetFeatureEnabledState(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
) callconv(@import("std").os.windows.WINAPI) FEATURE_ENABLED_STATE;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureUsage(
    featureId: u32,
    kind: u32,
    addend: u32,
    originName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureError(
    featureId: u32,
    @"error": *const FEATURE_ERROR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn SubscribeFeatureStateChangeNotification(
    subscription: *FEATURE_STATE_CHANGE_SUBSCRIPTION,
    callback: PFEATURE_STATE_CHANGE_CALLBACK,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn UnsubscribeFeatureStateChangeNotification(
    subscription: FEATURE_STATE_CHANGE_SUBSCRIPTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-1" fn GetFeatureVariant(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
    payloadId: *u32,
    hasNotification: *BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceOpenPipe(
    StartServiceIfStopped: BOOL,
    Pipe: *FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceClosePipe(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStartBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
    LowPriorityIo: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceStopBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
    StopTracking: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceReloadConfiguration(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceBlockBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "fhsvcctl" fn FhServiceUnblockBackup(
    Pipe: FH_SERVICE_PIPE_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCIOpenProvider(
) callconv(@import("std").os.windows.WINAPI) HDC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCICloseProvider(
    hdc: HDC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCICreatePrimary(
    hdc: HDC,
    lplpSurface: **DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCICreateOffscreen(
    hdc: HDC,
    dwCompression: u32,
    dwRedMask: u32,
    dwGreenMask: u32,
    dwBlueMask: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lplpSurface: **DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCICreateOverlay(
    hdc: HDC,
    lpOffscreenSurf: *c_void,
    lplpSurface: **DCIOVERLAY,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCIEnum(
    hdc: HDC,
    lprDst: *RECT,
    lprSrc: *RECT,
    lpFnCallback: *c_void,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetSrcDestClip(
    pdci: *DCIOFFSCREEN,
    srcrc: *RECT,
    destrc: *RECT,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn WinWatchOpen(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HWINWATCH;

pub extern "DCIMAN32" fn WinWatchClose(
    hWW: HWINWATCH,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn WinWatchGetClipList(
    hWW: HWINWATCH,
    prc: *RECT,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn WinWatchDidStatusChange(
    hWW: HWINWATCH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "DCIMAN32" fn GetWindowRegionData(
    hwnd: HWND,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn GetDCRegionData(
    hdc: HDC,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn WinWatchNotify(
    hWW: HWINWATCH,
    NotifyCallback: WINWATCHNOTIFYPROC,
    NotifyParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCIEndAccess(
    pdci: *DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCIBeginAccess(
    pdci: *DCISURFACEINFO,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "DCIMAN32" fn DCIDestroy(
    pdci: *DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn DCIDraw(
    pdci: *DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetClipList(
    pdci: *DCIOFFSCREEN,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetDestination(
    pdci: *DCIOFFSCREEN,
    dst: *RECT,
    src: *RECT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-dx-d3dkmt-l1-1-0" fn GdiEntry13(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVPACK" fn RunSetupCommandA(
    hWnd: HWND,
    szCmdName: [*:0]const u8,
    szInfSection: [*:0]const u8,
    szDir: [*:0]const u8,
    lpszTitle: [*:0]const u8,
    phEXE: *HANDLE,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RunSetupCommandW(
    hWnd: HWND,
    szCmdName: [*:0]const u16,
    szInfSection: [*:0]const u16,
    szDir: [*:0]const u16,
    lpszTitle: [*:0]const u16,
    phEXE: *HANDLE,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn NeedRebootInit(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVPACK" fn NeedReboot(
    dwRebootCheck: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVPACK" fn RebootCheckOnInstallA(
    hwnd: HWND,
    pszINF: [*:0]const u8,
    pszSec: [*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RebootCheckOnInstallW(
    hwnd: HWND,
    pszINF: [*:0]const u16,
    pszSec: [*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringA(
    pszInfFilename: [*:0]const u8,
    pszInstallSection: [*:0]const u8,
    pszTranslateSection: [*:0]const u8,
    pszTranslateKey: [*:0]const u8,
    pszBuffer: ?[*:0]u8,
    cchBuffer: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringW(
    pszInfFilename: [*:0]const u16,
    pszInstallSection: [*:0]const u16,
    pszTranslateSection: [*:0]const u16,
    pszTranslateKey: [*:0]const u16,
    pszBuffer: ?[*:0]u16,
    cchBuffer: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ADVPACK" fn RegInstallA(
    hmod: isize,
    pszSection: [*:0]const u8,
    pstTable: *const STRTABLEA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ADVPACK" fn RegInstallW(
    hmod: isize,
    pszSection: [*:0]const u16,
    pstTable: *const STRTABLEW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn LaunchINFSectionExW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExecuteCabA(
    hwnd: HWND,
    pCab: *CABINFOA,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExecuteCabW(
    hwnd: HWND,
    pCab: *CABINFOW,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AdvInstallFileA(
    hwnd: HWND,
    lpszSourceDir: [*:0]const u8,
    lpszSourceFile: [*:0]const u8,
    lpszDestDir: [*:0]const u8,
    lpszDestFile: [*:0]const u8,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AdvInstallFileW(
    hwnd: HWND,
    lpszSourceDir: [*:0]const u16,
    lpszSourceFile: [*:0]const u16,
    lpszDestDir: [*:0]const u16,
    lpszDestFile: [*:0]const u16,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreA(
    hWnd: HWND,
    pszTitleString: [*:0]const u8,
    hkBckupKey: HKEY,
    pcszRootKey: [*:0]const u8,
    pcszSubKey: [*:0]const u8,
    pcszValueName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreW(
    hWnd: HWND,
    pszTitleString: [*:0]const u16,
    hkBckupKey: HKEY,
    pcszRootKey: [*:0]const u16,
    pcszSubKey: [*:0]const u16,
    pcszValueName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreOnINFA(
    hWnd: HWND,
    pszTitle: [*:0]const u8,
    pszINF: [*:0]const u8,
    pszSection: [*:0]const u8,
    hHKLMBackKey: HKEY,
    hHKCUBackKey: HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreOnINFW(
    hWnd: HWND,
    pszTitle: [*:0]const u16,
    pszINF: [*:0]const u16,
    pszSection: [*:0]const u16,
    hHKLMBackKey: HKEY,
    hHKCUBackKey: HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegRestoreAllA(
    hWnd: HWND,
    pszTitleString: ?[*:0]const u8,
    hkBckupKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegRestoreAllW(
    hWnd: HWND,
    pszTitleString: ?[*:0]const u16,
    hkBckupKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreW(
    hDlg: HWND,
    lpFileList: ?PWSTR,
    lpDir: [*:0]const u16,
    lpBaseName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreOnINFA(
    hWnd: HWND,
    pszTitle: [*:0]const u8,
    pszINF: [*:0]const u8,
    pszSection: [*:0]const u8,
    pszBackupDir: [*:0]const u8,
    pszBaseBackupFile: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreOnINFW(
    hWnd: HWND,
    pszTitle: [*:0]const u16,
    pszINF: [*:0]const u16,
    pszSection: [*:0]const u16,
    pszBackupDir: [*:0]const u16,
    pszBaseBackupFile: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AddDelBackupEntryA(
    lpcszFileList: ?[*:0]const u8,
    lpcszBackupDir: ?[*:0]const u8,
    lpcszBaseName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AddDelBackupEntryW(
    lpcszFileList: ?[*:0]const u16,
    lpcszBackupDir: ?[*:0]const u16,
    lpcszBaseName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveMarkNotExistA(
    lpFileList: ?[*:0]const u8,
    lpDir: ?[*:0]const u8,
    lpBaseName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveMarkNotExistW(
    lpFileList: ?[*:0]const u16,
    lpDir: ?[*:0]const u16,
    lpBaseName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileA(
    lpszFilename: [*:0]const u8,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileW(
    lpszFilename: [*:0]const u16,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileExA(
    lpszFilename: [*:0]const u8,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileExW(
    lpszFilename: [*:0]const u16,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn IsNTAdmin(
    dwReserved: u32,
    lpdwReserved: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVPACK" fn DelNodeA(
    pszFileOrDirName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn DelNodeW(
    pszFileOrDirName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn DelNodeRunDLL32W(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn OpenINFEngineA(
    pszInfFilename: [*:0]const u8,
    pszInstallSection: [*:0]const u8,
    dwFlags: u32,
    phInf: **c_void,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn OpenINFEngineW(
    pszInfFilename: [*:0]const u16,
    pszInstallSection: [*:0]const u16,
    dwFlags: u32,
    phInf: **c_void,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringExA(
    hInf: *c_void,
    pszInfFilename: [*:0]const u8,
    pszTranslateSection: [*:0]const u8,
    pszTranslateKey: [*:0]const u8,
    pszBuffer: [*:0]u8,
    dwBufferSize: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringExW(
    hInf: *c_void,
    pszInfFilename: [*:0]const u16,
    pszTranslateSection: [*:0]const u16,
    pszTranslateKey: [*:0]const u16,
    pszBuffer: [*:0]u16,
    dwBufferSize: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn CloseINFEngine(
    hInf: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExtractFilesA(
    pszCabName: [*:0]const u8,
    pszExpandDir: [*:0]const u8,
    dwFlags: u32,
    pszFileList: [*:0]const u8,
    lpReserved: *c_void,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExtractFilesW(
    pszCabName: [*:0]const u16,
    pszExpandDir: [*:0]const u16,
    dwFlags: u32,
    pszFileList: [*:0]const u16,
    lpReserved: *c_void,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn LaunchINFSectionW(
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    pszParams: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ADVPACK" fn UserInstStubWrapperA(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserInstStubWrapperW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserUnInstStubWrapperA(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserUnInstStubWrapperW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn SetPerUserSecValuesA(
    pPerUser: *PERUSERSECTIONA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn SetPerUserSecValuesW(
    pPerUser: *PERUSERSECTIONW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USER32" fn SendIMEMessageExA(
    param0: HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USER32" fn SendIMEMessageExW(
    param0: HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "USER32" fn IMPGetIMEA(
    param0: HWND,
    param1: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPGetIMEW(
    param0: HWND,
    param1: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPQueryIMEA(
    param0: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPQueryIMEW(
    param0: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPSetIMEA(
    param0: HWND,
    param1: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPSetIMEW(
    param0: HWND,
    param1: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn WINNLSGetIMEHotkey(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USER32" fn WINNLSEnableIME(
    param0: HWND,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn WINNLSGetEnableStatus(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-security-isolatedcontainer-l1-1-1" fn IsProcessInWDAGContainer(
    Reserved: *c_void,
    isProcessInWDAGContainer: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-security-isolatedcontainer-l1-1-0" fn IsProcessInIsolatedContainer(
    isProcessInIsolatedContainer: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WSCAPI" fn WscRegisterForChanges(
    Reserved: *c_void,
    phCallbackRegistration: *HANDLE,
    lpCallbackAddress: LPTHREAD_START_ROUTINE,
    pContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WSCAPI" fn WscUnRegisterChanges(
    hRegistrationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscRegisterForUserNotifications(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WSCAPI" fn WscGetSecurityProviderHealth(
    Providers: u32,
    pHealth: *WSC_SECURITY_PROVIDER_HEALTH,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscQueryAntiMalwareUri(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscGetAntiMalwareUri(
    ppszUri: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "APPHELP" fn ApphelpCheckShellObject(
    ObjectCLSID: *const Guid,
    bShimIfNecessary: BOOL,
    pullFlags: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Wldp" fn WldpGetLockdownPolicy(
    hostInformation: ?*WLDP_HOST_INFORMATION,
    lockdownState: *u32,
    lockdownFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpIsClassInApprovedList(
    classID: *const Guid,
    hostInformation: *WLDP_HOST_INFORMATION,
    isApproved: *BOOL,
    optionalFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpSetDynamicCodeTrust(
    fileHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpIsDynamicCodePolicyEnabled(
    isEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpQueryDynamicCodeTrust(
    fileHandle: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    baseImage: ?*c_void,
    imageSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CeipIsOptedIn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "XmlLite" fn CreateXmlReader(
    riid: *const Guid,
    ppvObject: **c_void,
    pMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlReaderInputWithEncodingCodePage(
    pInputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    nEncodingCodePage: u32,
    fEncodingHint: BOOL,
    pwszBaseUri: ?[*:0]const u16,
    ppInput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlReaderInputWithEncodingName(
    pInputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    pwszEncodingName: [*:0]const u16,
    fEncodingHint: BOOL,
    pwszBaseUri: ?[*:0]const u16,
    ppInput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriter(
    riid: *const Guid,
    ppvObject: **c_void,
    pMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriterOutputWithEncodingCodePage(
    pOutputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    nEncodingCodePage: u32,
    ppOutput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriterOutputWithEncodingName(
    pOutputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    pwszEncodingName: [*:0]const u16,
    ppOutput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQuery(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryEx(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQueryFromId(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryFromIdEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQueryFromIds(
    ObjectType: DEV_OBJECT_TYPE,
    pszzObjectIds: [*]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryFromIdsEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszzObjectIds: [*]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCloseObjectQuery(
    hDevQuery: *HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevGetObjects(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pcObjectCount: *u32,
    ppObjects: ?*const ?*const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevGetObjectsEx(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pcObjectCount: *u32,
    ppObjects: ?*const ?*const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFreeObjects(
    cObjectCount: u32,
    pObjects: [*]const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevGetObjectProperties(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: [*]const DEVPROPCOMPKEY,
    pcPropertyCount: *u32,
    ppProperties: *const *const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevGetObjectPropertiesEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: [*]const DEVPROPCOMPKEY,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pcPropertyCount: *u32,
    ppProperties: *const *const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFreeObjectProperties(
    cPropertyCount: u32,
    pProperties: [*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFindProperty(
    pKey: *const DEVPROPKEY,
    Store: DEVPROPSTORE,
    pszLocaleName: [*:0]const u16,
    cProperties: u32,
    pProperties: ?[*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) *DEVPROPERTY;

pub extern "IPHLPAPI" fn PfCreateInterface(
    dwName: u32,
    inAction: PFFORWARD_ACTION,
    outAction: PFFORWARD_ACTION,
    bUseLog: BOOL,
    bMustBeUnique: BOOL,
    ppInterface: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfDeleteInterface(
    pInterface: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfAddFiltersToInterface(
    ih: *c_void,
    cInFilters: u32,
    pfiltIn: *PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: *PF_FILTER_DESCRIPTOR,
    pfHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveFiltersFromInterface(
    ih: *c_void,
    cInFilters: u32,
    pfiltIn: *PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: *PF_FILTER_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveFilterHandles(
    pInterface: *c_void,
    cFilters: u32,
    pvHandles: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfUnBindInterface(
    pInterface: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfBindInterfaceToIndex(
    pInterface: *c_void,
    dwIndex: u32,
    pfatLinkType: PFADDRESSTYPE,
    LinkIPAddress: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfBindInterfaceToIPAddress(
    pInterface: *c_void,
    pfatType: PFADDRESSTYPE,
    IPAddress: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRebindFilters(
    pInterface: *c_void,
    pLateBindInfo: *PF_LATEBIND_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfAddGlobalFilterToInterface(
    pInterface: *c_void,
    gfFilter: GLOBAL_FILTER,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveGlobalFilterFromInterface(
    pInterface: *c_void,
    gfFilter: GLOBAL_FILTER,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfMakeLog(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfSetLogBuffer(
    pbBuffer: *u8,
    dwSize: u32,
    dwThreshold: u32,
    dwEntries: u32,
    pdwLoggedEntries: *u32,
    pdwLostEntries: *u32,
    pdwSizeUsed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfDeleteLog(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfGetInterfaceStatistics(
    pInterface: *c_void,
    ppfStats: *PF_INTERFACE_STATS,
    pdwBufferSize: *u32,
    fResetCounters: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfTestPacket(
    pInInterface: *c_void,
    pOutInterface: *c_void,
    cBytes: u32,
    pbPacket: *u8,
    ppAction: *PFFORWARD_ACTION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-state-helpers-l1-1-0" fn GetRegistryValueWithFallbackW(
    hkeyPrimary: HKEY,
    pwszPrimarySubKey: ?[*:0]const u16,
    hkeyFallback: HKEY,
    pwszFallbackSubKey: ?[*:0]const u16,
    pwszValue: [*:0]const u16,
    dwFlags: u32,
    pdwType: ?*u32,
    pvData: ?*c_void,
    cbDataIn: u32,
    pcbDataOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "NETAPI32" fn I_NetLogonControl2(
    ServerName: ?[*:0]const u16,
    FunctionCode: u32,
    QueryLevel: u32,
    Data: *u8,
    Buffer: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn CoInstall(
    pbc: *IBindCtx,
    dwFlags: u32,
    pClassSpec: *uCLSSPEC,
    pQuery: *QUERYCONTEXT,
    pszCodeBase: PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CompareFileTime(
    lpFileTime1: *const FILETIME,
    lpFileTime2: *const FILETIME,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FileTimeToLocalFileTime(
    lpFileTime: *const FILETIME,
    lpLocalFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileTime(
    hFile: HANDLE,
    lpCreationTime: ?*FILETIME,
    lpLastAccessTime: ?*FILETIME,
    lpLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalFileTimeToFileTime(
    lpLocalFileTime: *const FILETIME,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileTime(
    hFile: HANDLE,
    lpCreationTime: ?*const FILETIME,
    lpLastAccessTime: ?*const FILETIME,
    lpLastWriteTime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetSystemWow64DirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetSystemWow64DirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.10586'
pub extern "api-ms-win-core-wow64-l1-1-1" fn GetSystemWow64Directory2A(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
    ImageFileMachineType: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.10586'
pub extern "api-ms-win-core-wow64-l1-1-1" fn GetSystemWow64Directory2W(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
    ImageFileMachineType: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn IsWow64GuestMachineSupported(
    WowGuestMachine: u16,
    MachineIsSupported: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "loadperf" fn InstallPerfDllW(
    szComputerName: ?[*:0]const u16,
    lpIniFile: [*:0]const u16,
    dwFlags: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "loadperf" fn InstallPerfDllA(
    szComputerName: ?[*:0]const u8,
    lpIniFile: [*:0]const u8,
    dwFlags: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SspiCli" fn GetUserNameExA(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SspiCli" fn GetUserNameExW(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SECUR32" fn GetComputerObjectNameA(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SECUR32" fn GetComputerObjectNameW(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SECUR32" fn TranslateNameA(
    lpAccountName: [*:0]const u8,
    AccountNameFormat: EXTENDED_NAME_FORMAT,
    DesiredNameFormat: EXTENDED_NAME_FORMAT,
    lpTranslatedName: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SECUR32" fn TranslateNameW(
    lpAccountName: [*:0]const u16,
    AccountNameFormat: EXTENDED_NAME_FORMAT,
    DesiredNameFormat: EXTENDED_NAME_FORMAT,
    lpTranslatedName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (109)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OSVERSIONINFO = OSVERSIONINFOA;
        pub const OSVERSIONINFOEX = OSVERSIONINFOEXA;
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = PGET_SYSTEM_WOW64_DIRECTORY_A;
        pub const HW_PROFILE_INFO = HW_PROFILE_INFOA;
        pub const pvalue = pvalueA;
        pub const VALENT = VALENTA;
        pub const STRENTRY = STRENTRYA;
        pub const STRTABLE = STRTABLEA;
        pub const CABINFO = CABINFOA;
        pub const PERUSERSECTION = PERUSERSECTIONA;
        pub const IMEPRO = IMEPROA;
        pub const SetEnvironmentStrings = SetEnvironmentStringsA;
        pub const ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
        pub const SetCurrentDirectory = SetCurrentDirectoryA;
        pub const GetCurrentDirectory = GetCurrentDirectoryA;
        pub const GetSystemDirectory = GetSystemDirectoryA;
        pub const GetWindowsDirectory = GetWindowsDirectoryA;
        pub const GetSystemWindowsDirectory = GetSystemWindowsDirectoryA;
        pub const GetComputerNameEx = GetComputerNameExA;
        pub const SetComputerNameEx = SetComputerNameExA;
        pub const GetVersionEx = GetVersionExA;
        pub const SetComputerName = SetComputerNameA;
        pub const GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableA;
        pub const GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExA;
        pub const SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableA;
        pub const SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExA;
        pub const GetProfileInt = GetProfileIntA;
        pub const GetProfileString = GetProfileStringA;
        pub const WriteProfileString = WriteProfileStringA;
        pub const GetProfileSection = GetProfileSectionA;
        pub const WriteProfileSection = WriteProfileSectionA;
        pub const GetPrivateProfileInt = GetPrivateProfileIntA;
        pub const GetPrivateProfileString = GetPrivateProfileStringA;
        pub const WritePrivateProfileString = WritePrivateProfileStringA;
        pub const GetPrivateProfileSection = GetPrivateProfileSectionA;
        pub const WritePrivateProfileSection = WritePrivateProfileSectionA;
        pub const GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
        pub const GetPrivateProfileStruct = GetPrivateProfileStructA;
        pub const WritePrivateProfileStruct = WritePrivateProfileStructA;
        pub const GetComputerName = GetComputerNameA;
        pub const DnsHostnameToComputerName = DnsHostnameToComputerNameA;
        pub const GetUserName = GetUserNameA;
        pub const GetCurrentHwProfile = GetCurrentHwProfileA;
        pub const VerifyVersionInfo = VerifyVersionInfoA;
        pub const RegConnectRegistry = RegConnectRegistryA;
        pub const RegConnectRegistryEx = RegConnectRegistryExA;
        pub const RegCreateKey = RegCreateKeyA;
        pub const RegCreateKeyEx = RegCreateKeyExA;
        pub const RegCreateKeyTransacted = RegCreateKeyTransactedA;
        pub const RegDeleteKey = RegDeleteKeyA;
        pub const RegDeleteKeyEx = RegDeleteKeyExA;
        pub const RegDeleteKeyTransacted = RegDeleteKeyTransactedA;
        pub const RegDeleteValue = RegDeleteValueA;
        pub const RegEnumKey = RegEnumKeyA;
        pub const RegEnumKeyEx = RegEnumKeyExA;
        pub const RegEnumValue = RegEnumValueA;
        pub const RegLoadKey = RegLoadKeyA;
        pub const RegOpenKey = RegOpenKeyA;
        pub const RegOpenKeyEx = RegOpenKeyExA;
        pub const RegOpenKeyTransacted = RegOpenKeyTransactedA;
        pub const RegQueryInfoKey = RegQueryInfoKeyA;
        pub const RegQueryValue = RegQueryValueA;
        pub const RegQueryMultipleValues = RegQueryMultipleValuesA;
        pub const RegQueryValueEx = RegQueryValueExA;
        pub const RegReplaceKey = RegReplaceKeyA;
        pub const RegRestoreKey = RegRestoreKeyA;
        pub const RegSaveKey = RegSaveKeyA;
        pub const RegSetValue = RegSetValueA;
        pub const RegSetValueEx = RegSetValueExA;
        pub const RegUnLoadKey = RegUnLoadKeyA;
        pub const RegDeleteKeyValue = RegDeleteKeyValueA;
        pub const RegSetKeyValue = RegSetKeyValueA;
        pub const RegDeleteTree = RegDeleteTreeA;
        pub const RegCopyTree = RegCopyTreeA;
        pub const RegGetValue = RegGetValueA;
        pub const RegLoadMUIString = RegLoadMUIStringA;
        pub const RegLoadAppKey = RegLoadAppKeyA;
        pub const RegSaveKeyEx = RegSaveKeyExA;
        pub const RunSetupCommand = RunSetupCommandA;
        pub const RebootCheckOnInstall = RebootCheckOnInstallA;
        pub const TranslateInfString = TranslateInfStringA;
        pub const RegInstall = RegInstallA;
        pub const ExecuteCab = ExecuteCabA;
        pub const AdvInstallFile = AdvInstallFileA;
        pub const RegSaveRestore = RegSaveRestoreA;
        pub const RegSaveRestoreOnINF = RegSaveRestoreOnINFA;
        pub const RegRestoreAll = RegRestoreAllA;
        pub const FileSaveRestoreOnINF = FileSaveRestoreOnINFA;
        pub const AddDelBackupEntry = AddDelBackupEntryA;
        pub const FileSaveMarkNotExist = FileSaveMarkNotExistA;
        pub const GetVersionFromFile = GetVersionFromFileA;
        pub const GetVersionFromFileEx = GetVersionFromFileExA;
        pub const DelNode = DelNodeA;
        pub const OpenINFEngine = OpenINFEngineA;
        pub const TranslateInfStringEx = TranslateInfStringExA;
        pub const ExtractFiles = ExtractFilesA;
        pub const UserInstStubWrapper = UserInstStubWrapperA;
        pub const UserUnInstStubWrapper = UserUnInstStubWrapperA;
        pub const SetPerUserSecValues = SetPerUserSecValuesA;
        pub const SendIMEMessageEx = SendIMEMessageExA;
        pub const IMPGetIME = IMPGetIMEA;
        pub const IMPQueryIME = IMPQueryIMEA;
        pub const IMPSetIME = IMPSetIMEA;
        pub const GetSystemWow64Directory = GetSystemWow64DirectoryA;
        pub const GetSystemWow64Directory2 = GetSystemWow64Directory2A;
        pub const InstallPerfDll = InstallPerfDllA;
        pub const GetUserNameEx = GetUserNameExA;
        pub const GetComputerObjectName = GetComputerObjectNameA;
        pub const TranslateName = TranslateNameA;
    },
    .wide => struct {
        pub const OSVERSIONINFO = OSVERSIONINFOW;
        pub const OSVERSIONINFOEX = OSVERSIONINFOEXW;
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = PGET_SYSTEM_WOW64_DIRECTORY_W;
        pub const HW_PROFILE_INFO = HW_PROFILE_INFOW;
        pub const pvalue = pvalueW;
        pub const VALENT = VALENTW;
        pub const STRENTRY = STRENTRYW;
        pub const STRTABLE = STRTABLEW;
        pub const CABINFO = CABINFOW;
        pub const PERUSERSECTION = PERUSERSECTIONW;
        pub const IMEPRO = IMEPROW;
        pub const SetEnvironmentStrings = SetEnvironmentStringsW;
        pub const ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
        pub const SetCurrentDirectory = SetCurrentDirectoryW;
        pub const GetCurrentDirectory = GetCurrentDirectoryW;
        pub const GetSystemDirectory = GetSystemDirectoryW;
        pub const GetWindowsDirectory = GetWindowsDirectoryW;
        pub const GetSystemWindowsDirectory = GetSystemWindowsDirectoryW;
        pub const GetComputerNameEx = GetComputerNameExW;
        pub const SetComputerNameEx = SetComputerNameExW;
        pub const GetVersionEx = GetVersionExW;
        pub const SetComputerName = SetComputerNameW;
        pub const GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableW;
        pub const GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExW;
        pub const SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableW;
        pub const SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExW;
        pub const GetProfileInt = GetProfileIntW;
        pub const GetProfileString = GetProfileStringW;
        pub const WriteProfileString = WriteProfileStringW;
        pub const GetProfileSection = GetProfileSectionW;
        pub const WriteProfileSection = WriteProfileSectionW;
        pub const GetPrivateProfileInt = GetPrivateProfileIntW;
        pub const GetPrivateProfileString = GetPrivateProfileStringW;
        pub const WritePrivateProfileString = WritePrivateProfileStringW;
        pub const GetPrivateProfileSection = GetPrivateProfileSectionW;
        pub const WritePrivateProfileSection = WritePrivateProfileSectionW;
        pub const GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
        pub const GetPrivateProfileStruct = GetPrivateProfileStructW;
        pub const WritePrivateProfileStruct = WritePrivateProfileStructW;
        pub const GetComputerName = GetComputerNameW;
        pub const DnsHostnameToComputerName = DnsHostnameToComputerNameW;
        pub const GetUserName = GetUserNameW;
        pub const GetCurrentHwProfile = GetCurrentHwProfileW;
        pub const VerifyVersionInfo = VerifyVersionInfoW;
        pub const RegConnectRegistry = RegConnectRegistryW;
        pub const RegConnectRegistryEx = RegConnectRegistryExW;
        pub const RegCreateKey = RegCreateKeyW;
        pub const RegCreateKeyEx = RegCreateKeyExW;
        pub const RegCreateKeyTransacted = RegCreateKeyTransactedW;
        pub const RegDeleteKey = RegDeleteKeyW;
        pub const RegDeleteKeyEx = RegDeleteKeyExW;
        pub const RegDeleteKeyTransacted = RegDeleteKeyTransactedW;
        pub const RegDeleteValue = RegDeleteValueW;
        pub const RegEnumKey = RegEnumKeyW;
        pub const RegEnumKeyEx = RegEnumKeyExW;
        pub const RegEnumValue = RegEnumValueW;
        pub const RegLoadKey = RegLoadKeyW;
        pub const RegOpenKey = RegOpenKeyW;
        pub const RegOpenKeyEx = RegOpenKeyExW;
        pub const RegOpenKeyTransacted = RegOpenKeyTransactedW;
        pub const RegQueryInfoKey = RegQueryInfoKeyW;
        pub const RegQueryValue = RegQueryValueW;
        pub const RegQueryMultipleValues = RegQueryMultipleValuesW;
        pub const RegQueryValueEx = RegQueryValueExW;
        pub const RegReplaceKey = RegReplaceKeyW;
        pub const RegRestoreKey = RegRestoreKeyW;
        pub const RegSaveKey = RegSaveKeyW;
        pub const RegSetValue = RegSetValueW;
        pub const RegSetValueEx = RegSetValueExW;
        pub const RegUnLoadKey = RegUnLoadKeyW;
        pub const RegDeleteKeyValue = RegDeleteKeyValueW;
        pub const RegSetKeyValue = RegSetKeyValueW;
        pub const RegDeleteTree = RegDeleteTreeW;
        pub const RegCopyTree = RegCopyTreeW;
        pub const RegGetValue = RegGetValueW;
        pub const RegLoadMUIString = RegLoadMUIStringW;
        pub const RegLoadAppKey = RegLoadAppKeyW;
        pub const RegSaveKeyEx = RegSaveKeyExW;
        pub const RunSetupCommand = RunSetupCommandW;
        pub const RebootCheckOnInstall = RebootCheckOnInstallW;
        pub const TranslateInfString = TranslateInfStringW;
        pub const RegInstall = RegInstallW;
        pub const ExecuteCab = ExecuteCabW;
        pub const AdvInstallFile = AdvInstallFileW;
        pub const RegSaveRestore = RegSaveRestoreW;
        pub const RegSaveRestoreOnINF = RegSaveRestoreOnINFW;
        pub const RegRestoreAll = RegRestoreAllW;
        pub const FileSaveRestoreOnINF = FileSaveRestoreOnINFW;
        pub const AddDelBackupEntry = AddDelBackupEntryW;
        pub const FileSaveMarkNotExist = FileSaveMarkNotExistW;
        pub const GetVersionFromFile = GetVersionFromFileW;
        pub const GetVersionFromFileEx = GetVersionFromFileExW;
        pub const DelNode = DelNodeW;
        pub const OpenINFEngine = OpenINFEngineW;
        pub const TranslateInfStringEx = TranslateInfStringExW;
        pub const ExtractFiles = ExtractFilesW;
        pub const UserInstStubWrapper = UserInstStubWrapperW;
        pub const UserUnInstStubWrapper = UserUnInstStubWrapperW;
        pub const SetPerUserSecValues = SetPerUserSecValuesW;
        pub const SendIMEMessageEx = SendIMEMessageExW;
        pub const IMPGetIME = IMPGetIMEW;
        pub const IMPQueryIME = IMPQueryIMEW;
        pub const IMPSetIME = IMPSetIMEW;
        pub const GetSystemWow64Directory = GetSystemWow64DirectoryW;
        pub const GetSystemWow64Directory2 = GetSystemWow64Directory2W;
        pub const InstallPerfDll = InstallPerfDllW;
        pub const GetUserNameEx = GetUserNameExW;
        pub const GetComputerObjectName = GetComputerObjectNameW;
        pub const TranslateName = TranslateNameW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OSVERSIONINFO = *opaque{};
        pub const OSVERSIONINFOEX = *opaque{};
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = *opaque{};
        pub const HW_PROFILE_INFO = *opaque{};
        pub const pvalue = *opaque{};
        pub const VALENT = *opaque{};
        pub const STRENTRY = *opaque{};
        pub const STRTABLE = *opaque{};
        pub const CABINFO = *opaque{};
        pub const PERUSERSECTION = *opaque{};
        pub const IMEPRO = *opaque{};
        pub const SetEnvironmentStrings = *opaque{};
        pub const ExpandEnvironmentStrings = *opaque{};
        pub const SetCurrentDirectory = *opaque{};
        pub const GetCurrentDirectory = *opaque{};
        pub const GetSystemDirectory = *opaque{};
        pub const GetWindowsDirectory = *opaque{};
        pub const GetSystemWindowsDirectory = *opaque{};
        pub const GetComputerNameEx = *opaque{};
        pub const SetComputerNameEx = *opaque{};
        pub const GetVersionEx = *opaque{};
        pub const SetComputerName = *opaque{};
        pub const GetFirmwareEnvironmentVariable = *opaque{};
        pub const GetFirmwareEnvironmentVariableEx = *opaque{};
        pub const SetFirmwareEnvironmentVariable = *opaque{};
        pub const SetFirmwareEnvironmentVariableEx = *opaque{};
        pub const GetProfileInt = *opaque{};
        pub const GetProfileString = *opaque{};
        pub const WriteProfileString = *opaque{};
        pub const GetProfileSection = *opaque{};
        pub const WriteProfileSection = *opaque{};
        pub const GetPrivateProfileInt = *opaque{};
        pub const GetPrivateProfileString = *opaque{};
        pub const WritePrivateProfileString = *opaque{};
        pub const GetPrivateProfileSection = *opaque{};
        pub const WritePrivateProfileSection = *opaque{};
        pub const GetPrivateProfileSectionNames = *opaque{};
        pub const GetPrivateProfileStruct = *opaque{};
        pub const WritePrivateProfileStruct = *opaque{};
        pub const GetComputerName = *opaque{};
        pub const DnsHostnameToComputerName = *opaque{};
        pub const GetUserName = *opaque{};
        pub const GetCurrentHwProfile = *opaque{};
        pub const VerifyVersionInfo = *opaque{};
        pub const RegConnectRegistry = *opaque{};
        pub const RegConnectRegistryEx = *opaque{};
        pub const RegCreateKey = *opaque{};
        pub const RegCreateKeyEx = *opaque{};
        pub const RegCreateKeyTransacted = *opaque{};
        pub const RegDeleteKey = *opaque{};
        pub const RegDeleteKeyEx = *opaque{};
        pub const RegDeleteKeyTransacted = *opaque{};
        pub const RegDeleteValue = *opaque{};
        pub const RegEnumKey = *opaque{};
        pub const RegEnumKeyEx = *opaque{};
        pub const RegEnumValue = *opaque{};
        pub const RegLoadKey = *opaque{};
        pub const RegOpenKey = *opaque{};
        pub const RegOpenKeyEx = *opaque{};
        pub const RegOpenKeyTransacted = *opaque{};
        pub const RegQueryInfoKey = *opaque{};
        pub const RegQueryValue = *opaque{};
        pub const RegQueryMultipleValues = *opaque{};
        pub const RegQueryValueEx = *opaque{};
        pub const RegReplaceKey = *opaque{};
        pub const RegRestoreKey = *opaque{};
        pub const RegSaveKey = *opaque{};
        pub const RegSetValue = *opaque{};
        pub const RegSetValueEx = *opaque{};
        pub const RegUnLoadKey = *opaque{};
        pub const RegDeleteKeyValue = *opaque{};
        pub const RegSetKeyValue = *opaque{};
        pub const RegDeleteTree = *opaque{};
        pub const RegCopyTree = *opaque{};
        pub const RegGetValue = *opaque{};
        pub const RegLoadMUIString = *opaque{};
        pub const RegLoadAppKey = *opaque{};
        pub const RegSaveKeyEx = *opaque{};
        pub const RunSetupCommand = *opaque{};
        pub const RebootCheckOnInstall = *opaque{};
        pub const TranslateInfString = *opaque{};
        pub const RegInstall = *opaque{};
        pub const ExecuteCab = *opaque{};
        pub const AdvInstallFile = *opaque{};
        pub const RegSaveRestore = *opaque{};
        pub const RegSaveRestoreOnINF = *opaque{};
        pub const RegRestoreAll = *opaque{};
        pub const FileSaveRestoreOnINF = *opaque{};
        pub const AddDelBackupEntry = *opaque{};
        pub const FileSaveMarkNotExist = *opaque{};
        pub const GetVersionFromFile = *opaque{};
        pub const GetVersionFromFileEx = *opaque{};
        pub const DelNode = *opaque{};
        pub const OpenINFEngine = *opaque{};
        pub const TranslateInfStringEx = *opaque{};
        pub const ExtractFiles = *opaque{};
        pub const UserInstStubWrapper = *opaque{};
        pub const UserUnInstStubWrapper = *opaque{};
        pub const SetPerUserSecValues = *opaque{};
        pub const SendIMEMessageEx = *opaque{};
        pub const IMPGetIME = *opaque{};
        pub const IMPQueryIME = *opaque{};
        pub const IMPSetIME = *opaque{};
        pub const GetSystemWow64Directory = *opaque{};
        pub const GetSystemWow64Directory2 = *opaque{};
        pub const InstallPerfDll = *opaque{};
        pub const GetUserNameEx = *opaque{};
        pub const GetComputerObjectName = *opaque{};
        pub const TranslateName = *opaque{};
    } else struct {
        pub const OSVERSIONINFO = @compileError("'OSVERSIONINFO' requires that UNICODE be set to true or false in the root module");
        pub const OSVERSIONINFOEX = @compileError("'OSVERSIONINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = @compileError("'PGET_SYSTEM_WOW64_DIRECTORY_' requires that UNICODE be set to true or false in the root module");
        pub const HW_PROFILE_INFO = @compileError("'HW_PROFILE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const pvalue = @compileError("'pvalue' requires that UNICODE be set to true or false in the root module");
        pub const VALENT = @compileError("'VALENT' requires that UNICODE be set to true or false in the root module");
        pub const STRENTRY = @compileError("'STRENTRY' requires that UNICODE be set to true or false in the root module");
        pub const STRTABLE = @compileError("'STRTABLE' requires that UNICODE be set to true or false in the root module");
        pub const CABINFO = @compileError("'CABINFO' requires that UNICODE be set to true or false in the root module");
        pub const PERUSERSECTION = @compileError("'PERUSERSECTION' requires that UNICODE be set to true or false in the root module");
        pub const IMEPRO = @compileError("'IMEPRO' requires that UNICODE be set to true or false in the root module");
        pub const SetEnvironmentStrings = @compileError("'SetEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const ExpandEnvironmentStrings = @compileError("'ExpandEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const SetCurrentDirectory = @compileError("'SetCurrentDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrentDirectory = @compileError("'GetCurrentDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemDirectory = @compileError("'GetSystemDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetWindowsDirectory = @compileError("'GetWindowsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWindowsDirectory = @compileError("'GetSystemWindowsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerNameEx = @compileError("'GetComputerNameEx' requires that UNICODE be set to true or false in the root module");
        pub const SetComputerNameEx = @compileError("'SetComputerNameEx' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionEx = @compileError("'GetVersionEx' requires that UNICODE be set to true or false in the root module");
        pub const SetComputerName = @compileError("'SetComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariable = @compileError("'GetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariableEx = @compileError("'GetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariable = @compileError("'SetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariableEx = @compileError("'SetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileInt = @compileError("'GetProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileString = @compileError("'GetProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileString = @compileError("'WriteProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileSection = @compileError("'GetProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileSection = @compileError("'WriteProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileInt = @compileError("'GetPrivateProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileString = @compileError("'GetPrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileString = @compileError("'WritePrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSection = @compileError("'GetPrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileSection = @compileError("'WritePrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSectionNames = @compileError("'GetPrivateProfileSectionNames' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileStruct = @compileError("'GetPrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileStruct = @compileError("'WritePrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerName = @compileError("'GetComputerName' requires that UNICODE be set to true or false in the root module");
        pub const DnsHostnameToComputerName = @compileError("'DnsHostnameToComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetUserName = @compileError("'GetUserName' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrentHwProfile = @compileError("'GetCurrentHwProfile' requires that UNICODE be set to true or false in the root module");
        pub const VerifyVersionInfo = @compileError("'VerifyVersionInfo' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistry = @compileError("'RegConnectRegistry' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistryEx = @compileError("'RegConnectRegistryEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKey = @compileError("'RegCreateKey' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyEx = @compileError("'RegCreateKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyTransacted = @compileError("'RegCreateKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKey = @compileError("'RegDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyEx = @compileError("'RegDeleteKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyTransacted = @compileError("'RegDeleteKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteValue = @compileError("'RegDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKey = @compileError("'RegEnumKey' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKeyEx = @compileError("'RegEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumValue = @compileError("'RegEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadKey = @compileError("'RegLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKey = @compileError("'RegOpenKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyEx = @compileError("'RegOpenKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyTransacted = @compileError("'RegOpenKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryInfoKey = @compileError("'RegQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValue = @compileError("'RegQueryValue' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryMultipleValues = @compileError("'RegQueryMultipleValues' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValueEx = @compileError("'RegQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegReplaceKey = @compileError("'RegReplaceKey' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreKey = @compileError("'RegRestoreKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKey = @compileError("'RegSaveKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValue = @compileError("'RegSetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValueEx = @compileError("'RegSetValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegUnLoadKey = @compileError("'RegUnLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyValue = @compileError("'RegDeleteKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetKeyValue = @compileError("'RegSetKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteTree = @compileError("'RegDeleteTree' requires that UNICODE be set to true or false in the root module");
        pub const RegCopyTree = @compileError("'RegCopyTree' requires that UNICODE be set to true or false in the root module");
        pub const RegGetValue = @compileError("'RegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadMUIString = @compileError("'RegLoadMUIString' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadAppKey = @compileError("'RegLoadAppKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKeyEx = @compileError("'RegSaveKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RunSetupCommand = @compileError("'RunSetupCommand' requires that UNICODE be set to true or false in the root module");
        pub const RebootCheckOnInstall = @compileError("'RebootCheckOnInstall' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfString = @compileError("'TranslateInfString' requires that UNICODE be set to true or false in the root module");
        pub const RegInstall = @compileError("'RegInstall' requires that UNICODE be set to true or false in the root module");
        pub const ExecuteCab = @compileError("'ExecuteCab' requires that UNICODE be set to true or false in the root module");
        pub const AdvInstallFile = @compileError("'AdvInstallFile' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestore = @compileError("'RegSaveRestore' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestoreOnINF = @compileError("'RegSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreAll = @compileError("'RegRestoreAll' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveRestoreOnINF = @compileError("'FileSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const AddDelBackupEntry = @compileError("'AddDelBackupEntry' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveMarkNotExist = @compileError("'FileSaveMarkNotExist' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFile = @compileError("'GetVersionFromFile' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFileEx = @compileError("'GetVersionFromFileEx' requires that UNICODE be set to true or false in the root module");
        pub const DelNode = @compileError("'DelNode' requires that UNICODE be set to true or false in the root module");
        pub const OpenINFEngine = @compileError("'OpenINFEngine' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfStringEx = @compileError("'TranslateInfStringEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractFiles = @compileError("'ExtractFiles' requires that UNICODE be set to true or false in the root module");
        pub const UserInstStubWrapper = @compileError("'UserInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const UserUnInstStubWrapper = @compileError("'UserUnInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const SetPerUserSecValues = @compileError("'SetPerUserSecValues' requires that UNICODE be set to true or false in the root module");
        pub const SendIMEMessageEx = @compileError("'SendIMEMessageEx' requires that UNICODE be set to true or false in the root module");
        pub const IMPGetIME = @compileError("'IMPGetIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPQueryIME = @compileError("'IMPQueryIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPSetIME = @compileError("'IMPSetIME' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWow64Directory = @compileError("'GetSystemWow64Directory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWow64Directory2 = @compileError("'GetSystemWow64Directory2' requires that UNICODE be set to true or false in the root module");
        pub const InstallPerfDll = @compileError("'InstallPerfDll' requires that UNICODE be set to true or false in the root module");
        pub const GetUserNameEx = @compileError("'GetUserNameEx' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerObjectName = @compileError("'GetComputerObjectName' requires that UNICODE be set to true or false in the root module");
        pub const TranslateName = @compileError("'TranslateName' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (79)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const DDOVERLAYFX = @import("direct_draw.zig").DDOVERLAYFX;
const DDSCAPSEX = @import("direct_draw.zig").DDSCAPSEX;
const OLECMDF = @import("com.zig").OLECMDF;
const OLECMDEXECOPT = @import("com.zig").OLECMDEXECOPT;
const DEVPROPERTY = @import("system_services.zig").DEVPROPERTY;
const MIDL_STUB_MESSAGE = @import("rpc.zig").MIDL_STUB_MESSAGE;
const NTSTATUS = @import("system_services.zig").NTSTATUS;
const CONTEXT = @import("debug.zig").CONTEXT;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const LRESULT = @import("system_services.zig").LRESULT;
const DDVIDEOPORTDESC = @import("display_devices.zig").DDVIDEOPORTDESC;
const DDCOLORCONTROL = @import("direct_draw.zig").DDCOLORCONTROL;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const DDCOLORKEY = @import("direct_show.zig").DDCOLORKEY;
const UNICODE_STRING = @import("security.zig").UNICODE_STRING;
const DDVIDEOPORTCONNECT = @import("core_audio.zig").DDVIDEOPORTCONNECT;
const SECURITY_DESCRIPTOR = @import("security.zig").SECURITY_DESCRIPTOR;
const PWSTR = @import("system_services.zig").PWSTR;
const LSTATUS = @import("system_services.zig").LSTATUS;
const IBindCtx = @import("com.zig").IBindCtx;
const DDCORECAPS = @import("display_devices.zig").DDCORECAPS;
const DDVIDEOPORTINFO = @import("display_devices.zig").DDVIDEOPORTINFO;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const LPTHREAD_START_ROUTINE = @import("system_services.zig").LPTHREAD_START_ROUTINE;
const DDSCAPS2 = @import("direct_draw.zig").DDSCAPS2;
const DEVPROPCOMPKEY = @import("system_services.zig").DEVPROPCOMPKEY;
const DEVPROPSTORE = @import("system_services.zig").DEVPROPSTORE;
const NonClosableHandle = @import("system_services.zig").NonClosableHandle;
const SYSTEM_CPU_SET_INFORMATION = @import("system_services.zig").SYSTEM_CPU_SET_INFORMATION;
const OLECMDID = @import("com.zig").OLECMDID;
const HANDLE = @import("system_services.zig").HANDLE;
const PALETTEENTRY = @import("gdi.zig").PALETTEENTRY;
const DEBUG_EVENT = @import("debug.zig").DEBUG_EVENT;
const RGNDATA = @import("gdi.zig").RGNDATA;
const EXCEPTION_RECORD = @import("debug.zig").EXCEPTION_RECORD;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const DDVIDEOPORTCAPS = @import("display_devices.zig").DDVIDEOPORTCAPS;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const WAITORTIMERCALLBACK = @import("system_services.zig").WAITORTIMERCALLBACK;
const CHAR = @import("system_services.zig").CHAR;
const DDHAL_DESTROYDDLOCALDATA = @import("display_devices.zig").DDHAL_DESTROYDDLOCALDATA;
const DEVPROPKEY = @import("system_services.zig").DEVPROPKEY;
const HRESULT = @import("com.zig").HRESULT;
const HDC = @import("gdi.zig").HDC;
const STARTUPINFOA = @import("system_services.zig").STARTUPINFOA;
const LDT_ENTRY = @import("debug.zig").LDT_ENTRY;
const BOOL = @import("system_services.zig").BOOL;
const PRIVILEGE_SET = @import("security.zig").PRIVILEGE_SET;
const DDSURFACEDESC = @import("direct_draw.zig").DDSURFACEDESC;
const FILE_SHARE_MODE = @import("file_system.zig").FILE_SHARE_MODE;
const JOB_SET_ARRAY = @import("system_services.zig").JOB_SET_ARRAY;
const IMalloc = @import("com.zig").IMalloc;
const SHANDLE_PTR = @import("system_services.zig").SHANDLE_PTR;
const QUERYCONTEXT = @import("com.zig").QUERYCONTEXT;
const SAFEARRAY = @import("automation.zig").SAFEARRAY;
const DDSURFACEDESC2 = @import("direct_draw.zig").DDSURFACEDESC2;
const IUnknown = @import("com.zig").IUnknown;
const DDGAMMARAMP = @import("direct_draw.zig").DDGAMMARAMP;
const READYSTATE = @import("direct_show.zig").READYSTATE;
const GENERIC_MAPPING = @import("security.zig").GENERIC_MAPPING;
const HWND = @import("windows_and_messaging.zig").HWND;
const DDVIDEOPORTBANDWIDTH = @import("display_devices.zig").DDVIDEOPORTBANDWIDTH;
const HEAPALIGNMENT = @import("display_devices.zig").HEAPALIGNMENT;
const PEB = @import("system_services.zig").PEB;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const VARIANT = @import("automation.zig").VARIANT;
const PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = @import("system_services.zig").PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
const DDPIXELFORMAT = @import("direct_draw.zig").DDPIXELFORMAT;
const DDBLTFX = @import("direct_draw.zig").DDBLTFX;
const uCLSSPEC = @import("system_services.zig").uCLSSPEC;
const RECTL = @import("display_devices.zig").RECTL;
const DDSCAPS = @import("direct_draw.zig").DDSCAPS;
const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = @import("system_services.zig").CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
const DDKERNELCAPS = @import("display_devices.zig").DDKERNELCAPS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "VDMGETTHREADSELECTORENTRYPROC")) { _ = VDMGETTHREADSELECTORENTRYPROC; }
    if (@hasDecl(@This(), "VDMGETCONTEXTPROC")) { _ = VDMGETCONTEXTPROC; }
    if (@hasDecl(@This(), "VDMSETCONTEXTPROC")) { _ = VDMSETCONTEXTPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERCALLBACKPROC")) { _ = PSYMBOLSERVERCALLBACKPROC; }
    if (@hasDecl(@This(), "VDMGETTHREADSELECTORENTRYPROC")) { _ = VDMGETTHREADSELECTORENTRYPROC; }
    if (@hasDecl(@This(), "VDMGETCONTEXTPROC")) { _ = VDMGETCONTEXTPROC; }
    if (@hasDecl(@This(), "VDMSETCONTEXTPROC")) { _ = VDMSETCONTEXTPROC; }
    if (@hasDecl(@This(), "LPFIBER_START_ROUTINE")) { _ = LPFIBER_START_ROUTINE; }
    if (@hasDecl(@This(), "PFIBER_CALLOUT_ROUTINE")) { _ = PFIBER_CALLOUT_ROUTINE; }
    if (@hasDecl(@This(), "PGET_SYSTEM_WOW64_DIRECTORY_A")) { _ = PGET_SYSTEM_WOW64_DIRECTORY_A; }
    if (@hasDecl(@This(), "PGET_SYSTEM_WOW64_DIRECTORY_W")) { _ = PGET_SYSTEM_WOW64_DIRECTORY_W; }
    if (@hasDecl(@This(), "PQUERYACTCTXW_FUNC")) { _ = PQUERYACTCTXW_FUNC; }
    if (@hasDecl(@This(), "APPLICATION_RECOVERY_CALLBACK")) { _ = APPLICATION_RECOVERY_CALLBACK; }
    if (@hasDecl(@This(), "PQUERYHANDLER")) { _ = PQUERYHANDLER; }
    if (@hasDecl(@This(), "PPS_POST_PROCESS_INIT_ROUTINE")) { _ = PPS_POST_PROCESS_INIT_ROUTINE; }
    if (@hasDecl(@This(), "PIO_APC_ROUTINE")) { _ = PIO_APC_ROUTINE; }
    if (@hasDecl(@This(), "PWINSTATIONQUERYINFORMATIONW")) { _ = PWINSTATIONQUERYINFORMATIONW; }
    if (@hasDecl(@This(), "AVRF_RESOURCE_ENUMERATE_CALLBACK")) { _ = AVRF_RESOURCE_ENUMERATE_CALLBACK; }
    if (@hasDecl(@This(), "AVRF_HEAPALLOCATION_ENUMERATE_CALLBACK")) { _ = AVRF_HEAPALLOCATION_ENUMERATE_CALLBACK; }
    if (@hasDecl(@This(), "AVRF_HANDLEOPERATION_ENUMERATE_CALLBACK")) { _ = AVRF_HANDLEOPERATION_ENUMERATE_CALLBACK; }
    if (@hasDecl(@This(), "PFNFCIALLOC")) { _ = PFNFCIALLOC; }
    if (@hasDecl(@This(), "PFNFCIFREE")) { _ = PFNFCIFREE; }
    if (@hasDecl(@This(), "PFNFCIOPEN")) { _ = PFNFCIOPEN; }
    if (@hasDecl(@This(), "PFNFCIREAD")) { _ = PFNFCIREAD; }
    if (@hasDecl(@This(), "PFNFCIWRITE")) { _ = PFNFCIWRITE; }
    if (@hasDecl(@This(), "PFNFCICLOSE")) { _ = PFNFCICLOSE; }
    if (@hasDecl(@This(), "PFNFCISEEK")) { _ = PFNFCISEEK; }
    if (@hasDecl(@This(), "PFNFCIDELETE")) { _ = PFNFCIDELETE; }
    if (@hasDecl(@This(), "PFNFCIGETNEXTCABINET")) { _ = PFNFCIGETNEXTCABINET; }
    if (@hasDecl(@This(), "PFNFCIFILEPLACED")) { _ = PFNFCIFILEPLACED; }
    if (@hasDecl(@This(), "PFNFCIGETOPENINFO")) { _ = PFNFCIGETOPENINFO; }
    if (@hasDecl(@This(), "PFNFCISTATUS")) { _ = PFNFCISTATUS; }
    if (@hasDecl(@This(), "PFNFCIGETTEMPFILE")) { _ = PFNFCIGETTEMPFILE; }
    if (@hasDecl(@This(), "PFNALLOC")) { _ = PFNALLOC; }
    if (@hasDecl(@This(), "PFNFREE")) { _ = PFNFREE; }
    if (@hasDecl(@This(), "PFNOPEN")) { _ = PFNOPEN; }
    if (@hasDecl(@This(), "PFNREAD")) { _ = PFNREAD; }
    if (@hasDecl(@This(), "PFNWRITE")) { _ = PFNWRITE; }
    if (@hasDecl(@This(), "PFNCLOSE")) { _ = PFNCLOSE; }
    if (@hasDecl(@This(), "PFNSEEK")) { _ = PFNSEEK; }
    if (@hasDecl(@This(), "PFNFDIDECRYPT")) { _ = PFNFDIDECRYPT; }
    if (@hasDecl(@This(), "PFNFDINOTIFY")) { _ = PFNFDINOTIFY; }
    if (@hasDecl(@This(), "DEBUGEVENTPROC")) { _ = DEBUGEVENTPROC; }
    if (@hasDecl(@This(), "PROCESSENUMPROC")) { _ = PROCESSENUMPROC; }
    if (@hasDecl(@This(), "TASKENUMPROC")) { _ = TASKENUMPROC; }
    if (@hasDecl(@This(), "TASKENUMPROCEX")) { _ = TASKENUMPROCEX; }
    if (@hasDecl(@This(), "VDMPROCESSEXCEPTIONPROC")) { _ = VDMPROCESSEXCEPTIONPROC; }
    if (@hasDecl(@This(), "VDMGETPOINTERPROC")) { _ = VDMGETPOINTERPROC; }
    if (@hasDecl(@This(), "VDMKILLWOWPROC")) { _ = VDMKILLWOWPROC; }
    if (@hasDecl(@This(), "VDMDETECTWOWPROC")) { _ = VDMDETECTWOWPROC; }
    if (@hasDecl(@This(), "VDMBREAKTHREADPROC")) { _ = VDMBREAKTHREADPROC; }
    if (@hasDecl(@This(), "VDMGETSELECTORMODULEPROC")) { _ = VDMGETSELECTORMODULEPROC; }
    if (@hasDecl(@This(), "VDMGETMODULESELECTORPROC")) { _ = VDMGETMODULESELECTORPROC; }
    if (@hasDecl(@This(), "VDMMODULEFIRSTPROC")) { _ = VDMMODULEFIRSTPROC; }
    if (@hasDecl(@This(), "VDMMODULENEXTPROC")) { _ = VDMMODULENEXTPROC; }
    if (@hasDecl(@This(), "VDMGLOBALFIRSTPROC")) { _ = VDMGLOBALFIRSTPROC; }
    if (@hasDecl(@This(), "VDMGLOBALNEXTPROC")) { _ = VDMGLOBALNEXTPROC; }
    if (@hasDecl(@This(), "VDMENUMPROCESSWOWPROC")) { _ = VDMENUMPROCESSWOWPROC; }
    if (@hasDecl(@This(), "VDMENUMTASKWOWPROC")) { _ = VDMENUMTASKWOWPROC; }
    if (@hasDecl(@This(), "VDMENUMTASKWOWEXPROC")) { _ = VDMENUMTASKWOWEXPROC; }
    if (@hasDecl(@This(), "VDMTERMINATETASKINWOWPROC")) { _ = VDMTERMINATETASKINWOWPROC; }
    if (@hasDecl(@This(), "VDMSTARTTASKINWOWPROC")) { _ = VDMSTARTTASKINWOWPROC; }
    if (@hasDecl(@This(), "VDMGETDBGFLAGSPROC")) { _ = VDMGETDBGFLAGSPROC; }
    if (@hasDecl(@This(), "VDMSETDBGFLAGSPROC")) { _ = VDMSETDBGFLAGSPROC; }
    if (@hasDecl(@This(), "VDMISMODULELOADEDPROC")) { _ = VDMISMODULELOADEDPROC; }
    if (@hasDecl(@This(), "VDMGETSEGMENTINFOPROC")) { _ = VDMGETSEGMENTINFOPROC; }
    if (@hasDecl(@This(), "VDMGETSYMBOLPROC")) { _ = VDMGETSYMBOLPROC; }
    if (@hasDecl(@This(), "VDMGETADDREXPRESSIONPROC")) { _ = VDMGETADDREXPRESSIONPROC; }
    if (@hasDecl(@This(), "PFEATURE_STATE_CHANGE_CALLBACK")) { _ = PFEATURE_STATE_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "ENUM_CALLBACK")) { _ = ENUM_CALLBACK; }
    if (@hasDecl(@This(), "WINWATCHNOTIFYPROC")) { _ = WINWATCHNOTIFYPROC; }
    if (@hasDecl(@This(), "LPDD32BITDRIVERINIT")) { _ = LPDD32BITDRIVERINIT; }
    if (@hasDecl(@This(), "LPDDHEL_INIT")) { _ = LPDDHEL_INIT; }
    if (@hasDecl(@This(), "LPDDHAL_SETCOLORKEY")) { _ = LPDDHAL_SETCOLORKEY; }
    if (@hasDecl(@This(), "LPDDHAL_CANCREATESURFACE")) { _ = LPDDHAL_CANCREATESURFACE; }
    if (@hasDecl(@This(), "LPDDHAL_CREATESURFACE")) { _ = LPDDHAL_CREATESURFACE; }
    if (@hasDecl(@This(), "LPDDHAL_DESTROYDRIVER")) { _ = LPDDHAL_DESTROYDRIVER; }
    if (@hasDecl(@This(), "LPDDHAL_SETMODE")) { _ = LPDDHAL_SETMODE; }
    if (@hasDecl(@This(), "LPDDHAL_CREATEPALETTE")) { _ = LPDDHAL_CREATEPALETTE; }
    if (@hasDecl(@This(), "LPDDHAL_GETSCANLINE")) { _ = LPDDHAL_GETSCANLINE; }
    if (@hasDecl(@This(), "LPDDHAL_SETEXCLUSIVEMODE")) { _ = LPDDHAL_SETEXCLUSIVEMODE; }
    if (@hasDecl(@This(), "LPDDHAL_FLIPTOGDISURFACE")) { _ = LPDDHAL_FLIPTOGDISURFACE; }
    if (@hasDecl(@This(), "LPDDHAL_GETDRIVERINFO")) { _ = LPDDHAL_GETDRIVERINFO; }
    if (@hasDecl(@This(), "LPDDHALPALCB_DESTROYPALETTE")) { _ = LPDDHALPALCB_DESTROYPALETTE; }
    if (@hasDecl(@This(), "LPDDHALPALCB_SETENTRIES")) { _ = LPDDHALPALCB_SETENTRIES; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_LOCK")) { _ = LPDDHALSURFCB_LOCK; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_UNLOCK")) { _ = LPDDHALSURFCB_UNLOCK; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_BLT")) { _ = LPDDHALSURFCB_BLT; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_UPDATEOVERLAY")) { _ = LPDDHALSURFCB_UPDATEOVERLAY; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_SETOVERLAYPOSITION")) { _ = LPDDHALSURFCB_SETOVERLAYPOSITION; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_SETPALETTE")) { _ = LPDDHALSURFCB_SETPALETTE; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_FLIP")) { _ = LPDDHALSURFCB_FLIP; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_DESTROYSURFACE")) { _ = LPDDHALSURFCB_DESTROYSURFACE; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_SETCLIPLIST")) { _ = LPDDHALSURFCB_SETCLIPLIST; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_ADDATTACHEDSURFACE")) { _ = LPDDHALSURFCB_ADDATTACHEDSURFACE; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_SETCOLORKEY")) { _ = LPDDHALSURFCB_SETCOLORKEY; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_GETBLTSTATUS")) { _ = LPDDHALSURFCB_GETBLTSTATUS; }
    if (@hasDecl(@This(), "LPDDHALSURFCB_GETFLIPSTATUS")) { _ = LPDDHALSURFCB_GETFLIPSTATUS; }
    if (@hasDecl(@This(), "LPDDHAL_GETAVAILDRIVERMEMORY")) { _ = LPDDHAL_GETAVAILDRIVERMEMORY; }
    if (@hasDecl(@This(), "LPDDHAL_UPDATENONLOCALHEAP")) { _ = LPDDHAL_UPDATENONLOCALHEAP; }
    if (@hasDecl(@This(), "LPDDHAL_GETHEAPALIGNMENT")) { _ = LPDDHAL_GETHEAPALIGNMENT; }
    if (@hasDecl(@This(), "LPDDHAL_CREATESURFACEEX")) { _ = LPDDHAL_CREATESURFACEEX; }
    if (@hasDecl(@This(), "LPDDHAL_GETDRIVERSTATE")) { _ = LPDDHAL_GETDRIVERSTATE; }
    if (@hasDecl(@This(), "LPDDHAL_DESTROYDDLOCAL")) { _ = LPDDHAL_DESTROYDDLOCAL; }
    if (@hasDecl(@This(), "LPDDHALEXEBUFCB_CANCREATEEXEBUF")) { _ = LPDDHALEXEBUFCB_CANCREATEEXEBUF; }
    if (@hasDecl(@This(), "LPDDHALEXEBUFCB_CREATEEXEBUF")) { _ = LPDDHALEXEBUFCB_CREATEEXEBUF; }
    if (@hasDecl(@This(), "LPDDHALEXEBUFCB_DESTROYEXEBUF")) { _ = LPDDHALEXEBUFCB_DESTROYEXEBUF; }
    if (@hasDecl(@This(), "LPDDHALEXEBUFCB_LOCKEXEBUF")) { _ = LPDDHALEXEBUFCB_LOCKEXEBUF; }
    if (@hasDecl(@This(), "LPDDHALEXEBUFCB_UNLOCKEXEBUF")) { _ = LPDDHALEXEBUFCB_UNLOCKEXEBUF; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_CANCREATEVIDEOPORT")) { _ = LPDDHALVPORTCB_CANCREATEVIDEOPORT; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_CREATEVIDEOPORT")) { _ = LPDDHALVPORTCB_CREATEVIDEOPORT; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_FLIP")) { _ = LPDDHALVPORTCB_FLIP; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETBANDWIDTH")) { _ = LPDDHALVPORTCB_GETBANDWIDTH; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETINPUTFORMATS")) { _ = LPDDHALVPORTCB_GETINPUTFORMATS; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETOUTPUTFORMATS")) { _ = LPDDHALVPORTCB_GETOUTPUTFORMATS; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETFIELD")) { _ = LPDDHALVPORTCB_GETFIELD; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETLINE")) { _ = LPDDHALVPORTCB_GETLINE; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETVPORTCONNECT")) { _ = LPDDHALVPORTCB_GETVPORTCONNECT; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_DESTROYVPORT")) { _ = LPDDHALVPORTCB_DESTROYVPORT; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETFLIPSTATUS")) { _ = LPDDHALVPORTCB_GETFLIPSTATUS; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_UPDATE")) { _ = LPDDHALVPORTCB_UPDATE; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_WAITFORSYNC")) { _ = LPDDHALVPORTCB_WAITFORSYNC; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_GETSIGNALSTATUS")) { _ = LPDDHALVPORTCB_GETSIGNALSTATUS; }
    if (@hasDecl(@This(), "LPDDHALVPORTCB_COLORCONTROL")) { _ = LPDDHALVPORTCB_COLORCONTROL; }
    if (@hasDecl(@This(), "LPDDHALCOLORCB_COLORCONTROL")) { _ = LPDDHALCOLORCB_COLORCONTROL; }
    if (@hasDecl(@This(), "LPDDHALKERNELCB_SYNCSURFACE")) { _ = LPDDHALKERNELCB_SYNCSURFACE; }
    if (@hasDecl(@This(), "LPDDHALKERNELCB_SYNCVIDEOPORT")) { _ = LPDDHALKERNELCB_SYNCVIDEOPORT; }
    if (@hasDecl(@This(), "LPDDGAMMACALIBRATORPROC")) { _ = LPDDGAMMACALIBRATORPROC; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_GETGUIDS")) { _ = LPDDHALMOCOMPCB_GETGUIDS; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_GETFORMATS")) { _ = LPDDHALMOCOMPCB_GETFORMATS; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_CREATE")) { _ = LPDDHALMOCOMPCB_CREATE; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_GETCOMPBUFFINFO")) { _ = LPDDHALMOCOMPCB_GETCOMPBUFFINFO; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_GETINTERNALINFO")) { _ = LPDDHALMOCOMPCB_GETINTERNALINFO; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_BEGINFRAME")) { _ = LPDDHALMOCOMPCB_BEGINFRAME; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_ENDFRAME")) { _ = LPDDHALMOCOMPCB_ENDFRAME; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_RENDER")) { _ = LPDDHALMOCOMPCB_RENDER; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_QUERYSTATUS")) { _ = LPDDHALMOCOMPCB_QUERYSTATUS; }
    if (@hasDecl(@This(), "LPDDHALMOCOMPCB_DESTROY")) { _ = LPDDHALMOCOMPCB_DESTROY; }
    if (@hasDecl(@This(), "LPDDHAL_SETINFO")) { _ = LPDDHAL_SETINFO; }
    if (@hasDecl(@This(), "LPDDHAL_VIDMEMALLOC")) { _ = LPDDHAL_VIDMEMALLOC; }
    if (@hasDecl(@This(), "LPDDHAL_VIDMEMFREE")) { _ = LPDDHAL_VIDMEMFREE; }
    if (@hasDecl(@This(), "PFNCHECKCONNECTIONWIZARD")) { _ = PFNCHECKCONNECTIONWIZARD; }
    if (@hasDecl(@This(), "PFNSETSHELLNEXT")) { _ = PFNSETSHELLNEXT; }
    if (@hasDecl(@This(), "REGINSTALLA")) { _ = REGINSTALLA; }
    if (@hasDecl(@This(), "PFN_IO_COMPLETION")) { _ = PFN_IO_COMPLETION; }
    if (@hasDecl(@This(), "FCACHE_CREATE_CALLBACK")) { _ = FCACHE_CREATE_CALLBACK; }
    if (@hasDecl(@This(), "FCACHE_RICHCREATE_CALLBACK")) { _ = FCACHE_RICHCREATE_CALLBACK; }
    if (@hasDecl(@This(), "CACHE_KEY_COMPARE")) { _ = CACHE_KEY_COMPARE; }
    if (@hasDecl(@This(), "CACHE_KEY_HASH")) { _ = CACHE_KEY_HASH; }
    if (@hasDecl(@This(), "CACHE_READ_CALLBACK")) { _ = CACHE_READ_CALLBACK; }
    if (@hasDecl(@This(), "CACHE_DESTROY_CALLBACK")) { _ = CACHE_DESTROY_CALLBACK; }
    if (@hasDecl(@This(), "CACHE_ACCESS_CHECK")) { _ = CACHE_ACCESS_CHECK; }
    if (@hasDecl(@This(), "PWLDP_SETDYNAMICCODETRUST_API")) { _ = PWLDP_SETDYNAMICCODETRUST_API; }
    if (@hasDecl(@This(), "PWLDP_ISDYNAMICCODEPOLICYENABLED_API")) { _ = PWLDP_ISDYNAMICCODEPOLICYENABLED_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYDYNAMICODETRUST_API")) { _ = PWLDP_QUERYDYNAMICODETRUST_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYWINDOWSLOCKDOWNMODE_API")) { _ = PWLDP_QUERYWINDOWSLOCKDOWNMODE_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API")) { _ = PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API; }
    if (@hasDecl(@This(), "PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API")) { _ = PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API; }
    if (@hasDecl(@This(), "PWLDP_WLDPISAPPAPPROVEDBYPOLICY_API")) { _ = PWLDP_WLDPISAPPAPPROVEDBYPOLICY_API; }
    if (@hasDecl(@This(), "PDEV_QUERY_RESULT_CALLBACK")) { _ = PDEV_QUERY_RESULT_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
