//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3416)
//--------------------------------------------------------------------------------
pub const WM_CAP_START = @as(u32, 1024);
pub const MODM_USER = @as(u32, 16384);
pub const MIDM_USER = @as(u32, 16384);
pub const MODM_MAPPER = @as(u32, 8192);
pub const MIDM_MAPPER = @as(u32, 8192);
pub const MODM_INIT = @as(u32, 100);
pub const MIDM_INIT = @as(u32, 100);
pub const MODM_INIT_EX = @as(u32, 104);
pub const MIDM_INIT_EX = @as(u32, 104);
pub const DRV_MCI_FIRST = @as(u32, 2048);
pub const ACMDM_BASE = @as(u32, 24576);
pub const ICM_RESERVED = @as(u32, 20480);
pub const MIXERCONTROL_CONTROLTYPE_CUSTOM = @as(u32, 0);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = @as(u32, 268500992);
pub const MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = @as(u32, 268566528);
pub const MIXERCONTROL_CONTROLTYPE_PEAKMETER = @as(u32, 268566529);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = @as(u32, 268632064);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEAN = @as(u32, 536936448);
pub const MIXERCONTROL_CONTROLTYPE_ONOFF = @as(u32, 536936449);
pub const MIXERCONTROL_CONTROLTYPE_MUTE = @as(u32, 536936450);
pub const MIXERCONTROL_CONTROLTYPE_MONO = @as(u32, 536936451);
pub const MIXERCONTROL_CONTROLTYPE_LOUDNESS = @as(u32, 536936452);
pub const MIXERCONTROL_CONTROLTYPE_STEREOENH = @as(u32, 536936453);
pub const MIXERCONTROL_CONTROLTYPE_BASS_BOOST = @as(u32, 536945271);
pub const MIXERCONTROL_CONTROLTYPE_BUTTON = @as(u32, 553713664);
pub const MIXERCONTROL_CONTROLTYPE_DECIBELS = @as(u32, 805568512);
pub const MIXERCONTROL_CONTROLTYPE_SIGNED = @as(u32, 805437440);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNED = @as(u32, 805502976);
pub const MIXERCONTROL_CONTROLTYPE_PERCENT = @as(u32, 805634048);
pub const MIXERCONTROL_CONTROLTYPE_SLIDER = @as(u32, 1073872896);
pub const MIXERCONTROL_CONTROLTYPE_PAN = @as(u32, 1073872897);
pub const MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = @as(u32, 1073872898);
pub const MIXERCONTROL_CONTROLTYPE_FADER = @as(u32, 1342373888);
pub const MIXERCONTROL_CONTROLTYPE_VOLUME = @as(u32, 1342373889);
pub const MIXERCONTROL_CONTROLTYPE_BASS = @as(u32, 1342373890);
pub const MIXERCONTROL_CONTROLTYPE_TREBLE = @as(u32, 1342373891);
pub const MIXERCONTROL_CONTROLTYPE_EQUALIZER = @as(u32, 1342373892);
pub const MIXERCONTROL_CONTROLTYPE_SINGLESELECT = @as(u32, 1879113728);
pub const MIXERCONTROL_CONTROLTYPE_MUX = @as(u32, 1879113729);
pub const MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = @as(u32, 1895890944);
pub const MIXERCONTROL_CONTROLTYPE_MIXER = @as(u32, 1895890945);
pub const MIXERCONTROL_CONTROLTYPE_MICROTIME = @as(u32, 1610809344);
pub const MIXERCONTROL_CONTROLTYPE_MILLITIME = @as(u32, 1627586560);
pub const MCI_TEST = @as(i32, 32);
pub const MCI_CAPTURE = @as(u32, 2160);
pub const MCI_MONITOR = @as(u32, 2161);
pub const MCI_RESERVE = @as(u32, 2162);
pub const MCI_SETAUDIO = @as(u32, 2163);
pub const MCI_SIGNAL = @as(u32, 2165);
pub const MCI_SETVIDEO = @as(u32, 2166);
pub const MCI_QUALITY = @as(u32, 2167);
pub const MCI_LIST = @as(u32, 2168);
pub const MCI_UNDO = @as(u32, 2169);
pub const MCI_CONFIGURE = @as(u32, 2170);
pub const MCI_RESTORE = @as(u32, 2171);
pub const MCI_ON = @as(u32, 1);
pub const MCI_OFF = @as(u32, 0);
pub const MCI_DGV_FILE_MODE_SAVING = @as(u32, 1);
pub const MCI_DGV_FILE_MODE_LOADING = @as(u32, 2);
pub const MCI_DGV_FILE_MODE_EDITING = @as(u32, 3);
pub const MCI_DGV_FILE_MODE_IDLE = @as(u32, 4);
pub const MCI_ON_S = @as(i32, 32768);
pub const MCI_OFF_S = @as(i32, 32769);
pub const MCI_DGV_FILE_S = @as(i32, 32770);
pub const MCI_DGV_INPUT_S = @as(i32, 32771);
pub const MCI_DGV_FILE_MODE_SAVING_S = @as(i32, 32772);
pub const MCI_DGV_FILE_MODE_LOADING_S = @as(i32, 32773);
pub const MCI_DGV_FILE_MODE_EDITING_S = @as(i32, 32774);
pub const MCI_DGV_FILE_MODE_IDLE_S = @as(i32, 32775);
pub const MCI_DGV_SETVIDEO_SRC_NTSC_S = @as(i32, 32784);
pub const MCI_DGV_SETVIDEO_SRC_RGB_S = @as(i32, 32785);
pub const MCI_DGV_SETVIDEO_SRC_SVIDEO_S = @as(i32, 32786);
pub const MCI_DGV_SETVIDEO_SRC_PAL_S = @as(i32, 32787);
pub const MCI_DGV_SETVIDEO_SRC_SECAM_S = @as(i32, 32788);
pub const MCI_DGV_SETVIDEO_SRC_GENERIC_S = @as(i32, 32789);
pub const MCI_DGV_SETAUDIO_SRC_LEFT_S = @as(i32, 32800);
pub const MCI_DGV_SETAUDIO_SRC_RIGHT_S = @as(i32, 32801);
pub const MCI_DGV_SETAUDIO_SRC_AVERAGE_S = @as(i32, 32802);
pub const MCI_DGV_SETAUDIO_SRC_STEREO_S = @as(i32, 32803);
pub const MM_MCISIGNAL = @as(u32, 971);
pub const MCIERR_DGV_DEVICE_LIMIT = @as(u32, 512);
pub const MCIERR_DGV_IOERR = @as(u32, 513);
pub const MCIERR_DGV_WORKSPACE_EMPTY = @as(u32, 514);
pub const MCIERR_DGV_DISK_FULL = @as(u32, 515);
pub const MCIERR_DGV_DEVICE_MEMORY_FULL = @as(u32, 516);
pub const MCIERR_DGV_BAD_CLIPBOARD_RANGE = @as(u32, 517);
pub const MCI_DGV_METHOD_PRE = @as(i32, 40960);
pub const MCI_DGV_METHOD_POST = @as(i32, 40961);
pub const MCI_DGV_METHOD_DIRECT = @as(i32, 40962);
pub const MCI_DGV_FF_AVSS = @as(i32, 16384);
pub const MCI_DGV_FF_AVI = @as(i32, 16385);
pub const MCI_DGV_FF_DIB = @as(i32, 16386);
pub const MCI_DGV_FF_RDIB = @as(i32, 16387);
pub const MCI_DGV_FF_JPEG = @as(i32, 16388);
pub const MCI_DGV_FF_RJPEG = @as(i32, 16389);
pub const MCI_DGV_FF_JFIF = @as(i32, 16390);
pub const MCI_DGV_FF_MPEG = @as(i32, 16391);
pub const MCI_DGV_GETDEVCAPS_CAN_LOCK = @as(i32, 16384);
pub const MCI_DGV_GETDEVCAPS_CAN_STRETCH = @as(i32, 16385);
pub const MCI_DGV_GETDEVCAPS_CAN_FREEZE = @as(i32, 16386);
pub const MCI_DGV_GETDEVCAPS_MAX_WINDOWS = @as(i32, 16387);
pub const MCI_DGV_GETDEVCAPS_CAN_REVERSE = @as(i32, 16388);
pub const MCI_DGV_GETDEVCAPS_HAS_STILL = @as(i32, 16389);
pub const MCI_DGV_GETDEVCAPS_PALETTES = @as(i32, 16390);
pub const MCI_DGV_GETDEVCAPS_CAN_STR_IN = @as(i32, 16392);
pub const MCI_DGV_GETDEVCAPS_CAN_TEST = @as(i32, 16393);
pub const MCI_DGV_GETDEVCAPS_MAXIMUM_RATE = @as(i32, 16394);
pub const MCI_DGV_GETDEVCAPS_MINIMUM_RATE = @as(i32, 16395);
pub const MCI_DGV_CAPTURE_AS = @as(i32, 65536);
pub const MCI_DGV_CAPTURE_AT = @as(i32, 131072);
pub const MCI_DGV_COPY_AT = @as(i32, 65536);
pub const MCI_DGV_COPY_AUDIO_STREAM = @as(i32, 131072);
pub const MCI_DGV_COPY_VIDEO_STREAM = @as(i32, 262144);
pub const MCI_DGV_CUE_INPUT = @as(i32, 65536);
pub const MCI_DGV_CUE_OUTPUT = @as(i32, 131072);
pub const MCI_DGV_CUE_NOSHOW = @as(i32, 262144);
pub const MCI_DGV_CUT_AT = @as(i32, 65536);
pub const MCI_DGV_CUT_AUDIO_STREAM = @as(i32, 131072);
pub const MCI_DGV_CUT_VIDEO_STREAM = @as(i32, 262144);
pub const MCI_DGV_DELETE_AT = @as(i32, 65536);
pub const MCI_DGV_DELETE_AUDIO_STREAM = @as(i32, 131072);
pub const MCI_DGV_DELETE_VIDEO_STREAM = @as(i32, 262144);
pub const MCI_DGV_FREEZE_AT = @as(i32, 65536);
pub const MCI_DGV_FREEZE_OUTSIDE = @as(i32, 131072);
pub const MCI_DGV_INFO_TEXT = @as(i32, 65536);
pub const MCI_DGV_INFO_ITEM = @as(i32, 131072);
pub const MCI_INFO_VERSION = @as(i32, 1024);
pub const MCI_DGV_INFO_USAGE = @as(i32, 16384);
pub const MCI_DGV_INFO_AUDIO_QUALITY = @as(i32, 16385);
pub const MCI_DGV_INFO_STILL_QUALITY = @as(i32, 16386);
pub const MCI_DGV_INFO_VIDEO_QUALITY = @as(i32, 16387);
pub const MCI_DGV_INFO_AUDIO_ALG = @as(i32, 16388);
pub const MCI_DGV_INFO_STILL_ALG = @as(i32, 16389);
pub const MCI_DGV_INFO_VIDEO_ALG = @as(i32, 16390);
pub const MCI_DGV_LIST_ITEM = @as(i32, 65536);
pub const MCI_DGV_LIST_COUNT = @as(i32, 131072);
pub const MCI_DGV_LIST_NUMBER = @as(i32, 262144);
pub const MCI_DGV_LIST_ALG = @as(i32, 524288);
pub const MCI_DGV_LIST_AUDIO_ALG = @as(i32, 16384);
pub const MCI_DGV_LIST_AUDIO_QUALITY = @as(i32, 16385);
pub const MCI_DGV_LIST_AUDIO_STREAM = @as(i32, 16386);
pub const MCI_DGV_LIST_STILL_ALG = @as(i32, 16387);
pub const MCI_DGV_LIST_STILL_QUALITY = @as(i32, 16388);
pub const MCI_DGV_LIST_VIDEO_ALG = @as(i32, 16389);
pub const MCI_DGV_LIST_VIDEO_QUALITY = @as(i32, 16390);
pub const MCI_DGV_LIST_VIDEO_STREAM = @as(i32, 16391);
pub const MCI_DGV_LIST_VIDEO_SOURCE = @as(i32, 16392);
pub const MCI_DGV_MONITOR_METHOD = @as(i32, 65536);
pub const MCI_DGV_MONITOR_SOURCE = @as(i32, 131072);
pub const MCI_DGV_MONITOR_INPUT = @as(i32, 16384);
pub const MCI_DGV_MONITOR_FILE = @as(i32, 16385);
pub const MCI_DGV_OPEN_WS = @as(i32, 65536);
pub const MCI_DGV_OPEN_PARENT = @as(i32, 131072);
pub const MCI_DGV_OPEN_NOSTATIC = @as(i32, 262144);
pub const MCI_DGV_OPEN_16BIT = @as(i32, 524288);
pub const MCI_DGV_OPEN_32BIT = @as(i32, 1048576);
pub const MCI_DGV_PASTE_AT = @as(i32, 65536);
pub const MCI_DGV_PASTE_AUDIO_STREAM = @as(i32, 131072);
pub const MCI_DGV_PASTE_VIDEO_STREAM = @as(i32, 262144);
pub const MCI_DGV_PASTE_INSERT = @as(i32, 524288);
pub const MCI_DGV_PASTE_OVERWRITE = @as(i32, 1048576);
pub const MCI_DGV_PLAY_REPEAT = @as(i32, 65536);
pub const MCI_DGV_PLAY_REVERSE = @as(i32, 131072);
pub const MCI_DGV_RECT = @as(i32, 65536);
pub const MCI_DGV_PUT_SOURCE = @as(i32, 131072);
pub const MCI_DGV_PUT_DESTINATION = @as(i32, 262144);
pub const MCI_DGV_PUT_FRAME = @as(i32, 524288);
pub const MCI_DGV_PUT_VIDEO = @as(i32, 1048576);
pub const MCI_DGV_PUT_WINDOW = @as(i32, 2097152);
pub const MCI_DGV_PUT_CLIENT = @as(i32, 4194304);
pub const MCI_QUALITY_ITEM = @as(i32, 65536);
pub const MCI_QUALITY_NAME = @as(i32, 131072);
pub const MCI_QUALITY_ALG = @as(i32, 262144);
pub const MCI_QUALITY_DIALOG = @as(i32, 524288);
pub const MCI_QUALITY_HANDLE = @as(i32, 1048576);
pub const MCI_QUALITY_ITEM_AUDIO = @as(i32, 16384);
pub const MCI_QUALITY_ITEM_STILL = @as(i32, 16385);
pub const MCI_QUALITY_ITEM_VIDEO = @as(i32, 16386);
pub const MCI_DGV_REALIZE_NORM = @as(i32, 65536);
pub const MCI_DGV_REALIZE_BKGD = @as(i32, 131072);
pub const MCI_DGV_RECORD_HOLD = @as(i32, 131072);
pub const MCI_DGV_RECORD_AUDIO_STREAM = @as(i32, 262144);
pub const MCI_DGV_RECORD_VIDEO_STREAM = @as(i32, 524288);
pub const MCI_DGV_RESERVE_IN = @as(i32, 65536);
pub const MCI_DGV_RESERVE_SIZE = @as(i32, 131072);
pub const MCI_DGV_RESTORE_FROM = @as(i32, 65536);
pub const MCI_DGV_RESTORE_AT = @as(i32, 131072);
pub const MCI_DGV_SAVE_ABORT = @as(i32, 131072);
pub const MCI_DGV_SAVE_KEEPRESERVE = @as(i32, 262144);
pub const MCI_DGV_SET_SEEK_EXACTLY = @as(i32, 65536);
pub const MCI_DGV_SET_SPEED = @as(i32, 131072);
pub const MCI_DGV_SET_STILL = @as(i32, 262144);
pub const MCI_DGV_SET_FILEFORMAT = @as(i32, 524288);
pub const MCI_DGV_SETAUDIO_OVER = @as(i32, 65536);
pub const MCI_DGV_SETAUDIO_CLOCKTIME = @as(i32, 131072);
pub const MCI_DGV_SETAUDIO_ALG = @as(i32, 262144);
pub const MCI_DGV_SETAUDIO_QUALITY = @as(i32, 524288);
pub const MCI_DGV_SETAUDIO_RECORD = @as(i32, 1048576);
pub const MCI_DGV_SETAUDIO_LEFT = @as(i32, 2097152);
pub const MCI_DGV_SETAUDIO_RIGHT = @as(i32, 4194304);
pub const MCI_DGV_SETAUDIO_ITEM = @as(i32, 8388608);
pub const MCI_DGV_SETAUDIO_VALUE = @as(i32, 16777216);
pub const MCI_DGV_SETAUDIO_INPUT = @as(i32, 33554432);
pub const MCI_DGV_SETAUDIO_OUTPUT = @as(i32, 67108864);
pub const MCI_DGV_SETAUDIO_TREBLE = @as(i32, 16384);
pub const MCI_DGV_SETAUDIO_BASS = @as(i32, 16385);
pub const MCI_DGV_SETAUDIO_VOLUME = @as(i32, 16386);
pub const MCI_DGV_SETAUDIO_STREAM = @as(i32, 16387);
pub const MCI_DGV_SETAUDIO_SOURCE = @as(i32, 16388);
pub const MCI_DGV_SETAUDIO_SAMPLESPERSEC = @as(i32, 16389);
pub const MCI_DGV_SETAUDIO_AVGBYTESPERSEC = @as(i32, 16390);
pub const MCI_DGV_SETAUDIO_BLOCKALIGN = @as(i32, 16391);
pub const MCI_DGV_SETAUDIO_BITSPERSAMPLE = @as(i32, 16392);
pub const MCI_DGV_SETAUDIO_SOURCE_STEREO = @as(i32, 0);
pub const MCI_DGV_SETAUDIO_SOURCE_LEFT = @as(i32, 1);
pub const MCI_DGV_SETAUDIO_SOURCE_RIGHT = @as(i32, 2);
pub const MCI_DGV_SETAUDIO_SOURCE_AVERAGE = @as(i32, 16384);
pub const MCI_DGV_SETVIDEO_QUALITY = @as(i32, 65536);
pub const MCI_DGV_SETVIDEO_ALG = @as(i32, 131072);
pub const MCI_DGV_SETVIDEO_CLOCKTIME = @as(i32, 262144);
pub const MCI_DGV_SETVIDEO_SRC_NUMBER = @as(i32, 524288);
pub const MCI_DGV_SETVIDEO_ITEM = @as(i32, 1048576);
pub const MCI_DGV_SETVIDEO_OVER = @as(i32, 2097152);
pub const MCI_DGV_SETVIDEO_RECORD = @as(i32, 4194304);
pub const MCI_DGV_SETVIDEO_STILL = @as(i32, 8388608);
pub const MCI_DGV_SETVIDEO_VALUE = @as(i32, 16777216);
pub const MCI_DGV_SETVIDEO_INPUT = @as(i32, 33554432);
pub const MCI_DGV_SETVIDEO_OUTPUT = @as(i32, 67108864);
pub const MCI_DGV_SETVIDEO_SRC_NTSC = @as(i32, 16384);
pub const MCI_DGV_SETVIDEO_SRC_RGB = @as(i32, 16385);
pub const MCI_DGV_SETVIDEO_SRC_SVIDEO = @as(i32, 16386);
pub const MCI_DGV_SETVIDEO_SRC_PAL = @as(i32, 16387);
pub const MCI_DGV_SETVIDEO_SRC_SECAM = @as(i32, 16388);
pub const MCI_DGV_SETVIDEO_SRC_GENERIC = @as(i32, 16389);
pub const MCI_DGV_SETVIDEO_BRIGHTNESS = @as(i32, 16384);
pub const MCI_DGV_SETVIDEO_COLOR = @as(i32, 16385);
pub const MCI_DGV_SETVIDEO_CONTRAST = @as(i32, 16386);
pub const MCI_DGV_SETVIDEO_TINT = @as(i32, 16387);
pub const MCI_DGV_SETVIDEO_SHARPNESS = @as(i32, 16388);
pub const MCI_DGV_SETVIDEO_GAMMA = @as(i32, 16389);
pub const MCI_DGV_SETVIDEO_STREAM = @as(i32, 16390);
pub const MCI_DGV_SETVIDEO_PALHANDLE = @as(i32, 16391);
pub const MCI_DGV_SETVIDEO_FRAME_RATE = @as(i32, 16392);
pub const MCI_DGV_SETVIDEO_SOURCE = @as(i32, 16393);
pub const MCI_DGV_SETVIDEO_KEY_INDEX = @as(i32, 16394);
pub const MCI_DGV_SETVIDEO_KEY_COLOR = @as(i32, 16395);
pub const MCI_DGV_SETVIDEO_BITSPERPEL = @as(i32, 16396);
pub const MCI_DGV_SIGNAL_AT = @as(i32, 65536);
pub const MCI_DGV_SIGNAL_EVERY = @as(i32, 131072);
pub const MCI_DGV_SIGNAL_USERVAL = @as(i32, 262144);
pub const MCI_DGV_SIGNAL_CANCEL = @as(i32, 524288);
pub const MCI_DGV_SIGNAL_POSITION = @as(i32, 1048576);
pub const MCI_DGV_STATUS_NOMINAL = @as(i32, 131072);
pub const MCI_DGV_STATUS_REFERENCE = @as(i32, 262144);
pub const MCI_DGV_STATUS_LEFT = @as(i32, 524288);
pub const MCI_DGV_STATUS_RIGHT = @as(i32, 1048576);
pub const MCI_DGV_STATUS_DISKSPACE = @as(i32, 2097152);
pub const MCI_DGV_STATUS_INPUT = @as(i32, 4194304);
pub const MCI_DGV_STATUS_OUTPUT = @as(i32, 8388608);
pub const MCI_DGV_STATUS_RECORD = @as(i32, 16777216);
pub const MCI_DGV_STATUS_AUDIO_INPUT = @as(i32, 16384);
pub const MCI_DGV_STATUS_HWND = @as(i32, 16385);
pub const MCI_DGV_STATUS_SPEED = @as(i32, 16387);
pub const MCI_DGV_STATUS_HPAL = @as(i32, 16388);
pub const MCI_DGV_STATUS_BRIGHTNESS = @as(i32, 16389);
pub const MCI_DGV_STATUS_COLOR = @as(i32, 16390);
pub const MCI_DGV_STATUS_CONTRAST = @as(i32, 16391);
pub const MCI_DGV_STATUS_FILEFORMAT = @as(i32, 16392);
pub const MCI_DGV_STATUS_AUDIO_SOURCE = @as(i32, 16393);
pub const MCI_DGV_STATUS_GAMMA = @as(i32, 16394);
pub const MCI_DGV_STATUS_MONITOR = @as(i32, 16395);
pub const MCI_DGV_STATUS_MONITOR_METHOD = @as(i32, 16396);
pub const MCI_DGV_STATUS_FRAME_RATE = @as(i32, 16398);
pub const MCI_DGV_STATUS_BASS = @as(i32, 16399);
pub const MCI_DGV_STATUS_SIZE = @as(i32, 16400);
pub const MCI_DGV_STATUS_SEEK_EXACTLY = @as(i32, 16401);
pub const MCI_DGV_STATUS_SHARPNESS = @as(i32, 16402);
pub const MCI_DGV_STATUS_SMPTE = @as(i32, 16403);
pub const MCI_DGV_STATUS_AUDIO = @as(i32, 16404);
pub const MCI_DGV_STATUS_TINT = @as(i32, 16405);
pub const MCI_DGV_STATUS_TREBLE = @as(i32, 16406);
pub const MCI_DGV_STATUS_UNSAVED = @as(i32, 16407);
pub const MCI_DGV_STATUS_VIDEO = @as(i32, 16408);
pub const MCI_DGV_STATUS_VOLUME = @as(i32, 16409);
pub const MCI_DGV_STATUS_AUDIO_RECORD = @as(i32, 16410);
pub const MCI_DGV_STATUS_VIDEO_SOURCE = @as(i32, 16411);
pub const MCI_DGV_STATUS_VIDEO_RECORD = @as(i32, 16412);
pub const MCI_DGV_STATUS_STILL_FILEFORMAT = @as(i32, 16413);
pub const MCI_DGV_STATUS_VIDEO_SRC_NUM = @as(i32, 16414);
pub const MCI_DGV_STATUS_FILE_MODE = @as(i32, 16415);
pub const MCI_DGV_STATUS_FILE_COMPLETION = @as(i32, 16416);
pub const MCI_DGV_STATUS_WINDOW_VISIBLE = @as(i32, 16417);
pub const MCI_DGV_STATUS_WINDOW_MINIMIZED = @as(i32, 16418);
pub const MCI_DGV_STATUS_WINDOW_MAXIMIZED = @as(i32, 16419);
pub const MCI_DGV_STATUS_KEY_INDEX = @as(i32, 16420);
pub const MCI_DGV_STATUS_KEY_COLOR = @as(i32, 16421);
pub const MCI_DGV_STATUS_PAUSE_MODE = @as(i32, 16422);
pub const MCI_DGV_STATUS_SAMPLESPERSEC = @as(i32, 16423);
pub const MCI_DGV_STATUS_AVGBYTESPERSEC = @as(i32, 16424);
pub const MCI_DGV_STATUS_BLOCKALIGN = @as(i32, 16425);
pub const MCI_DGV_STATUS_BITSPERSAMPLE = @as(i32, 16426);
pub const MCI_DGV_STATUS_BITSPERPEL = @as(i32, 16427);
pub const MCI_DGV_STATUS_FORWARD = @as(i32, 16428);
pub const MCI_DGV_STATUS_AUDIO_STREAM = @as(i32, 16429);
pub const MCI_DGV_STATUS_VIDEO_STREAM = @as(i32, 16430);
pub const MCI_DGV_STEP_REVERSE = @as(i32, 65536);
pub const MCI_DGV_STEP_FRAMES = @as(i32, 131072);
pub const MCI_DGV_STOP_HOLD = @as(i32, 65536);
pub const MCI_DGV_UPDATE_HDC = @as(i32, 131072);
pub const MCI_DGV_UPDATE_PAINT = @as(i32, 262144);
pub const MCI_DGV_WHERE_SOURCE = @as(i32, 131072);
pub const MCI_DGV_WHERE_DESTINATION = @as(i32, 262144);
pub const MCI_DGV_WHERE_FRAME = @as(i32, 524288);
pub const MCI_DGV_WHERE_VIDEO = @as(i32, 1048576);
pub const MCI_DGV_WHERE_WINDOW = @as(i32, 2097152);
pub const MCI_DGV_WHERE_MAX = @as(i32, 4194304);
pub const MCI_DGV_WINDOW_HWND = @as(i32, 65536);
pub const MCI_DGV_WINDOW_STATE = @as(i32, 262144);
pub const MCI_DGV_WINDOW_TEXT = @as(i32, 524288);
pub const MCI_DGV_WINDOW_DEFAULT = @as(i32, 0);
pub const MM_MICROSOFT = @as(u32, 1);
pub const MM_CREATIVE = @as(u32, 2);
pub const MM_MEDIAVISION = @as(u32, 3);
pub const MM_FUJITSU = @as(u32, 4);
pub const MM_PRAGMATRAX = @as(u32, 5);
pub const MM_CYRIX = @as(u32, 6);
pub const MM_PHILIPS_SPEECH_PROCESSING = @as(u32, 7);
pub const MM_NETXL = @as(u32, 8);
pub const MM_ZYXEL = @as(u32, 9);
pub const MM_BECUBED = @as(u32, 10);
pub const MM_AARDVARK = @as(u32, 11);
pub const MM_BINTEC = @as(u32, 12);
pub const MM_HEWLETT_PACKARD = @as(u32, 13);
pub const MM_ACULAB = @as(u32, 14);
pub const MM_FAITH = @as(u32, 15);
pub const MM_MITEL = @as(u32, 16);
pub const MM_QUANTUM3D = @as(u32, 17);
pub const MM_SNI = @as(u32, 18);
pub const MM_EMU = @as(u32, 19);
pub const MM_ARTISOFT = @as(u32, 20);
pub const MM_TURTLE_BEACH = @as(u32, 21);
pub const MM_IBM = @as(u32, 22);
pub const MM_VOCALTEC = @as(u32, 23);
pub const MM_ROLAND = @as(u32, 24);
pub const MM_DSP_SOLUTIONS = @as(u32, 25);
pub const MM_NEC = @as(u32, 26);
pub const MM_ATI = @as(u32, 27);
pub const MM_WANGLABS = @as(u32, 28);
pub const MM_TANDY = @as(u32, 29);
pub const MM_VOYETRA = @as(u32, 30);
pub const MM_ANTEX = @as(u32, 31);
pub const MM_ICL_PS = @as(u32, 32);
pub const MM_INTEL = @as(u32, 33);
pub const MM_GRAVIS = @as(u32, 34);
pub const MM_VAL = @as(u32, 35);
pub const MM_INTERACTIVE = @as(u32, 36);
pub const MM_YAMAHA = @as(u32, 37);
pub const MM_EVEREX = @as(u32, 38);
pub const MM_ECHO = @as(u32, 39);
pub const MM_SIERRA = @as(u32, 40);
pub const MM_CAT = @as(u32, 41);
pub const MM_APPS = @as(u32, 42);
pub const MM_DSP_GROUP = @as(u32, 43);
pub const MM_MELABS = @as(u32, 44);
pub const MM_COMPUTER_FRIENDS = @as(u32, 45);
pub const MM_ESS = @as(u32, 46);
pub const MM_AUDIOFILE = @as(u32, 47);
pub const MM_MOTOROLA = @as(u32, 48);
pub const MM_CANOPUS = @as(u32, 49);
pub const MM_EPSON = @as(u32, 50);
pub const MM_TRUEVISION = @as(u32, 51);
pub const MM_AZTECH = @as(u32, 52);
pub const MM_VIDEOLOGIC = @as(u32, 53);
pub const MM_SCALACS = @as(u32, 54);
pub const MM_KORG = @as(u32, 55);
pub const MM_APT = @as(u32, 56);
pub const MM_ICS = @as(u32, 57);
pub const MM_ITERATEDSYS = @as(u32, 58);
pub const MM_METHEUS = @as(u32, 59);
pub const MM_LOGITECH = @as(u32, 60);
pub const MM_WINNOV = @as(u32, 61);
pub const MM_NCR = @as(u32, 62);
pub const MM_EXAN = @as(u32, 63);
pub const MM_AST = @as(u32, 64);
pub const MM_WILLOWPOND = @as(u32, 65);
pub const MM_SONICFOUNDRY = @as(u32, 66);
pub const MM_VITEC = @as(u32, 67);
pub const MM_MOSCOM = @as(u32, 68);
pub const MM_SILICONSOFT = @as(u32, 69);
pub const MM_TERRATEC = @as(u32, 70);
pub const MM_MEDIASONIC = @as(u32, 71);
pub const MM_SANYO = @as(u32, 72);
pub const MM_SUPERMAC = @as(u32, 73);
pub const MM_AUDIOPT = @as(u32, 74);
pub const MM_NOGATECH = @as(u32, 75);
pub const MM_SPEECHCOMP = @as(u32, 76);
pub const MM_AHEAD = @as(u32, 77);
pub const MM_DOLBY = @as(u32, 78);
pub const MM_OKI = @as(u32, 79);
pub const MM_AURAVISION = @as(u32, 80);
pub const MM_OLIVETTI = @as(u32, 81);
pub const MM_IOMAGIC = @as(u32, 82);
pub const MM_MATSUSHITA = @as(u32, 83);
pub const MM_CONTROLRES = @as(u32, 84);
pub const MM_XEBEC = @as(u32, 85);
pub const MM_NEWMEDIA = @as(u32, 86);
pub const MM_NMS = @as(u32, 87);
pub const MM_LYRRUS = @as(u32, 88);
pub const MM_COMPUSIC = @as(u32, 89);
pub const MM_OPTI = @as(u32, 90);
pub const MM_ADLACC = @as(u32, 91);
pub const MM_COMPAQ = @as(u32, 92);
pub const MM_DIALOGIC = @as(u32, 93);
pub const MM_INSOFT = @as(u32, 94);
pub const MM_MPTUS = @as(u32, 95);
pub const MM_WEITEK = @as(u32, 96);
pub const MM_LERNOUT_AND_HAUSPIE = @as(u32, 97);
pub const MM_QCIAR = @as(u32, 98);
pub const MM_APPLE = @as(u32, 99);
pub const MM_DIGITAL = @as(u32, 100);
pub const MM_MOTU = @as(u32, 101);
pub const MM_WORKBIT = @as(u32, 102);
pub const MM_OSITECH = @as(u32, 103);
pub const MM_MIRO = @as(u32, 104);
pub const MM_CIRRUSLOGIC = @as(u32, 105);
pub const MM_ISOLUTION = @as(u32, 106);
pub const MM_HORIZONS = @as(u32, 107);
pub const MM_CONCEPTS = @as(u32, 108);
pub const MM_VTG = @as(u32, 109);
pub const MM_RADIUS = @as(u32, 110);
pub const MM_ROCKWELL = @as(u32, 111);
pub const MM_XYZ = @as(u32, 112);
pub const MM_OPCODE = @as(u32, 113);
pub const MM_VOXWARE = @as(u32, 114);
pub const MM_NORTHERN_TELECOM = @as(u32, 115);
pub const MM_APICOM = @as(u32, 116);
pub const MM_GRANDE = @as(u32, 117);
pub const MM_ADDX = @as(u32, 118);
pub const MM_WILDCAT = @as(u32, 119);
pub const MM_RHETOREX = @as(u32, 120);
pub const MM_BROOKTREE = @as(u32, 121);
pub const MM_ENSONIQ = @as(u32, 125);
pub const MM_FAST = @as(u32, 126);
pub const MM_NVIDIA = @as(u32, 127);
pub const MM_OKSORI = @as(u32, 128);
pub const MM_DIACOUSTICS = @as(u32, 129);
pub const MM_GULBRANSEN = @as(u32, 130);
pub const MM_KAY_ELEMETRICS = @as(u32, 131);
pub const MM_CRYSTAL = @as(u32, 132);
pub const MM_SPLASH_STUDIOS = @as(u32, 133);
pub const MM_QUARTERDECK = @as(u32, 134);
pub const MM_TDK = @as(u32, 135);
pub const MM_DIGITAL_AUDIO_LABS = @as(u32, 136);
pub const MM_SEERSYS = @as(u32, 137);
pub const MM_PICTURETEL = @as(u32, 138);
pub const MM_ATT_MICROELECTRONICS = @as(u32, 139);
pub const MM_OSPREY = @as(u32, 140);
pub const MM_MEDIATRIX = @as(u32, 141);
pub const MM_SOUNDESIGNS = @as(u32, 142);
pub const MM_ALDIGITAL = @as(u32, 143);
pub const MM_SPECTRUM_SIGNAL_PROCESSING = @as(u32, 144);
pub const MM_ECS = @as(u32, 145);
pub const MM_AMD = @as(u32, 146);
pub const MM_COREDYNAMICS = @as(u32, 147);
pub const MM_CANAM = @as(u32, 148);
pub const MM_SOFTSOUND = @as(u32, 149);
pub const MM_NORRIS = @as(u32, 150);
pub const MM_DDD = @as(u32, 151);
pub const MM_EUPHONICS = @as(u32, 152);
pub const MM_PRECEPT = @as(u32, 153);
pub const MM_CRYSTAL_NET = @as(u32, 154);
pub const MM_CHROMATIC = @as(u32, 155);
pub const MM_VOICEINFO = @as(u32, 156);
pub const MM_VIENNASYS = @as(u32, 157);
pub const MM_CONNECTIX = @as(u32, 158);
pub const MM_GADGETLABS = @as(u32, 159);
pub const MM_FRONTIER = @as(u32, 160);
pub const MM_VIONA = @as(u32, 161);
pub const MM_CASIO = @as(u32, 162);
pub const MM_DIAMONDMM = @as(u32, 163);
pub const MM_S3 = @as(u32, 164);
pub const MM_DVISION = @as(u32, 165);
pub const MM_NETSCAPE = @as(u32, 166);
pub const MM_SOUNDSPACE = @as(u32, 167);
pub const MM_VANKOEVERING = @as(u32, 168);
pub const MM_QTEAM = @as(u32, 169);
pub const MM_ZEFIRO = @as(u32, 170);
pub const MM_STUDER = @as(u32, 171);
pub const MM_FRAUNHOFER_IIS = @as(u32, 172);
pub const MM_QUICKNET = @as(u32, 173);
pub const MM_ALARIS = @as(u32, 174);
pub const MM_SICRESOURCE = @as(u32, 175);
pub const MM_NEOMAGIC = @as(u32, 176);
pub const MM_MERGING_TECHNOLOGIES = @as(u32, 177);
pub const MM_XIRLINK = @as(u32, 178);
pub const MM_COLORGRAPH = @as(u32, 179);
pub const MM_OTI = @as(u32, 180);
pub const MM_AUREAL = @as(u32, 181);
pub const MM_VIVO = @as(u32, 182);
pub const MM_SHARP = @as(u32, 183);
pub const MM_LUCENT = @as(u32, 184);
pub const MM_ATT = @as(u32, 185);
pub const MM_SUNCOM = @as(u32, 186);
pub const MM_SORVIS = @as(u32, 187);
pub const MM_INVISION = @as(u32, 188);
pub const MM_BERKOM = @as(u32, 189);
pub const MM_MARIAN = @as(u32, 190);
pub const MM_DPSINC = @as(u32, 191);
pub const MM_BCB = @as(u32, 192);
pub const MM_MOTIONPIXELS = @as(u32, 193);
pub const MM_QDESIGN = @as(u32, 194);
pub const MM_NMP = @as(u32, 195);
pub const MM_DATAFUSION = @as(u32, 196);
pub const MM_DUCK = @as(u32, 197);
pub const MM_FTR = @as(u32, 198);
pub const MM_BERCOS = @as(u32, 199);
pub const MM_ONLIVE = @as(u32, 200);
pub const MM_SIEMENS_SBC = @as(u32, 201);
pub const MM_TERALOGIC = @as(u32, 202);
pub const MM_PHONET = @as(u32, 203);
pub const MM_WINBOND = @as(u32, 204);
pub const MM_VIRTUALMUSIC = @as(u32, 205);
pub const MM_ENET = @as(u32, 206);
pub const MM_GUILLEMOT = @as(u32, 207);
pub const MM_EMAGIC = @as(u32, 208);
pub const MM_MWM = @as(u32, 209);
pub const MM_PACIFICRESEARCH = @as(u32, 210);
pub const MM_SIPROLAB = @as(u32, 211);
pub const MM_LYNX = @as(u32, 212);
pub const MM_SPECTRUM_PRODUCTIONS = @as(u32, 213);
pub const MM_DICTAPHONE = @as(u32, 214);
pub const MM_QUALCOMM = @as(u32, 215);
pub const MM_RZS = @as(u32, 216);
pub const MM_AUDIOSCIENCE = @as(u32, 217);
pub const MM_PINNACLE = @as(u32, 218);
pub const MM_EES = @as(u32, 219);
pub const MM_HAFTMANN = @as(u32, 220);
pub const MM_LUCID = @as(u32, 221);
pub const MM_HEADSPACE = @as(u32, 222);
pub const MM_UNISYS = @as(u32, 223);
pub const MM_LUMINOSITI = @as(u32, 224);
pub const MM_ACTIVEVOICE = @as(u32, 225);
pub const MM_DTS = @as(u32, 226);
pub const MM_DIGIGRAM = @as(u32, 227);
pub const MM_SOFTLAB_NSK = @as(u32, 228);
pub const MM_FORTEMEDIA = @as(u32, 229);
pub const MM_SONORUS = @as(u32, 230);
pub const MM_ARRAY = @as(u32, 231);
pub const MM_DATARAN = @as(u32, 232);
pub const MM_I_LINK = @as(u32, 233);
pub const MM_SELSIUS_SYSTEMS = @as(u32, 234);
pub const MM_ADMOS = @as(u32, 235);
pub const MM_LEXICON = @as(u32, 236);
pub const MM_SGI = @as(u32, 237);
pub const MM_IPI = @as(u32, 238);
pub const MM_ICE = @as(u32, 239);
pub const MM_VQST = @as(u32, 240);
pub const MM_ETEK = @as(u32, 241);
pub const MM_CS = @as(u32, 242);
pub const MM_ALESIS = @as(u32, 243);
pub const MM_INTERNET = @as(u32, 244);
pub const MM_SONY = @as(u32, 245);
pub const MM_HYPERACTIVE = @as(u32, 246);
pub const MM_UHER_INFORMATIC = @as(u32, 247);
pub const MM_SYDEC_NV = @as(u32, 248);
pub const MM_FLEXION = @as(u32, 249);
pub const MM_VIA = @as(u32, 250);
pub const MM_MICRONAS = @as(u32, 251);
pub const MM_ANALOGDEVICES = @as(u32, 252);
pub const MM_HP = @as(u32, 253);
pub const MM_MATROX_DIV = @as(u32, 254);
pub const MM_QUICKAUDIO = @as(u32, 255);
pub const MM_YOUCOM = @as(u32, 256);
pub const MM_RICHMOND = @as(u32, 257);
pub const MM_IODD = @as(u32, 258);
pub const MM_ICCC = @as(u32, 259);
pub const MM_3COM = @as(u32, 260);
pub const MM_MALDEN = @as(u32, 261);
pub const MM_3DFX = @as(u32, 262);
pub const MM_MINDMAKER = @as(u32, 263);
pub const MM_TELEKOL = @as(u32, 264);
pub const MM_ST_MICROELECTRONICS = @as(u32, 265);
pub const MM_ALGOVISION = @as(u32, 266);
pub const MM_UNMAPPED = @as(u32, 65535);
pub const MM_MIDI_MAPPER = @as(u32, 1);
pub const MM_WAVE_MAPPER = @as(u32, 2);
pub const MM_SNDBLST_MIDIOUT = @as(u32, 3);
pub const MM_SNDBLST_MIDIIN = @as(u32, 4);
pub const MM_SNDBLST_SYNTH = @as(u32, 5);
pub const MM_SNDBLST_WAVEOUT = @as(u32, 6);
pub const MM_SNDBLST_WAVEIN = @as(u32, 7);
pub const MM_ADLIB = @as(u32, 9);
pub const MM_MPU401_MIDIOUT = @as(u32, 10);
pub const MM_MPU401_MIDIIN = @as(u32, 11);
pub const MM_PC_JOYSTICK = @as(u32, 12);
pub const MM_PCSPEAKER_WAVEOUT = @as(u32, 13);
pub const MM_MSFT_WSS_WAVEIN = @as(u32, 14);
pub const MM_MSFT_WSS_WAVEOUT = @as(u32, 15);
pub const MM_MSFT_WSS_FMSYNTH_STEREO = @as(u32, 16);
pub const MM_MSFT_WSS_MIXER = @as(u32, 17);
pub const MM_MSFT_WSS_OEM_WAVEIN = @as(u32, 18);
pub const MM_MSFT_WSS_OEM_WAVEOUT = @as(u32, 19);
pub const MM_MSFT_WSS_OEM_FMSYNTH_STEREO = @as(u32, 20);
pub const MM_MSFT_WSS_AUX = @as(u32, 21);
pub const MM_MSFT_WSS_OEM_AUX = @as(u32, 22);
pub const MM_MSFT_GENERIC_WAVEIN = @as(u32, 23);
pub const MM_MSFT_GENERIC_WAVEOUT = @as(u32, 24);
pub const MM_MSFT_GENERIC_MIDIIN = @as(u32, 25);
pub const MM_MSFT_GENERIC_MIDIOUT = @as(u32, 26);
pub const MM_MSFT_GENERIC_MIDISYNTH = @as(u32, 27);
pub const MM_MSFT_GENERIC_AUX_LINE = @as(u32, 28);
pub const MM_MSFT_GENERIC_AUX_MIC = @as(u32, 29);
pub const MM_MSFT_GENERIC_AUX_CD = @as(u32, 30);
pub const MM_MSFT_WSS_OEM_MIXER = @as(u32, 31);
pub const MM_MSFT_MSACM = @as(u32, 32);
pub const MM_MSFT_ACM_MSADPCM = @as(u32, 33);
pub const MM_MSFT_ACM_IMAADPCM = @as(u32, 34);
pub const MM_MSFT_ACM_MSFILTER = @as(u32, 35);
pub const MM_MSFT_ACM_GSM610 = @as(u32, 36);
pub const MM_MSFT_ACM_G711 = @as(u32, 37);
pub const MM_MSFT_ACM_PCM = @as(u32, 38);
pub const MM_WSS_SB16_WAVEIN = @as(u32, 39);
pub const MM_WSS_SB16_WAVEOUT = @as(u32, 40);
pub const MM_WSS_SB16_MIDIIN = @as(u32, 41);
pub const MM_WSS_SB16_MIDIOUT = @as(u32, 42);
pub const MM_WSS_SB16_SYNTH = @as(u32, 43);
pub const MM_WSS_SB16_AUX_LINE = @as(u32, 44);
pub const MM_WSS_SB16_AUX_CD = @as(u32, 45);
pub const MM_WSS_SB16_MIXER = @as(u32, 46);
pub const MM_WSS_SBPRO_WAVEIN = @as(u32, 47);
pub const MM_WSS_SBPRO_WAVEOUT = @as(u32, 48);
pub const MM_WSS_SBPRO_MIDIIN = @as(u32, 49);
pub const MM_WSS_SBPRO_MIDIOUT = @as(u32, 50);
pub const MM_WSS_SBPRO_SYNTH = @as(u32, 51);
pub const MM_WSS_SBPRO_AUX_LINE = @as(u32, 52);
pub const MM_WSS_SBPRO_AUX_CD = @as(u32, 53);
pub const MM_WSS_SBPRO_MIXER = @as(u32, 54);
pub const MM_MSFT_WSS_NT_WAVEIN = @as(u32, 55);
pub const MM_MSFT_WSS_NT_WAVEOUT = @as(u32, 56);
pub const MM_MSFT_WSS_NT_FMSYNTH_STEREO = @as(u32, 57);
pub const MM_MSFT_WSS_NT_MIXER = @as(u32, 58);
pub const MM_MSFT_WSS_NT_AUX = @as(u32, 59);
pub const MM_MSFT_SB16_WAVEIN = @as(u32, 60);
pub const MM_MSFT_SB16_WAVEOUT = @as(u32, 61);
pub const MM_MSFT_SB16_MIDIIN = @as(u32, 62);
pub const MM_MSFT_SB16_MIDIOUT = @as(u32, 63);
pub const MM_MSFT_SB16_SYNTH = @as(u32, 64);
pub const MM_MSFT_SB16_AUX_LINE = @as(u32, 65);
pub const MM_MSFT_SB16_AUX_CD = @as(u32, 66);
pub const MM_MSFT_SB16_MIXER = @as(u32, 67);
pub const MM_MSFT_SBPRO_WAVEIN = @as(u32, 68);
pub const MM_MSFT_SBPRO_WAVEOUT = @as(u32, 69);
pub const MM_MSFT_SBPRO_MIDIIN = @as(u32, 70);
pub const MM_MSFT_SBPRO_MIDIOUT = @as(u32, 71);
pub const MM_MSFT_SBPRO_SYNTH = @as(u32, 72);
pub const MM_MSFT_SBPRO_AUX_LINE = @as(u32, 73);
pub const MM_MSFT_SBPRO_AUX_CD = @as(u32, 74);
pub const MM_MSFT_SBPRO_MIXER = @as(u32, 75);
pub const MM_MSFT_MSOPL_SYNTH = @as(u32, 76);
pub const MM_MSFT_VMDMS_LINE_WAVEIN = @as(u32, 80);
pub const MM_MSFT_VMDMS_LINE_WAVEOUT = @as(u32, 81);
pub const MM_MSFT_VMDMS_HANDSET_WAVEIN = @as(u32, 82);
pub const MM_MSFT_VMDMS_HANDSET_WAVEOUT = @as(u32, 83);
pub const MM_MSFT_VMDMW_LINE_WAVEIN = @as(u32, 84);
pub const MM_MSFT_VMDMW_LINE_WAVEOUT = @as(u32, 85);
pub const MM_MSFT_VMDMW_HANDSET_WAVEIN = @as(u32, 86);
pub const MM_MSFT_VMDMW_HANDSET_WAVEOUT = @as(u32, 87);
pub const MM_MSFT_VMDMW_MIXER = @as(u32, 88);
pub const MM_MSFT_VMDM_GAME_WAVEOUT = @as(u32, 89);
pub const MM_MSFT_VMDM_GAME_WAVEIN = @as(u32, 90);
pub const MM_MSFT_ACM_MSNAUDIO = @as(u32, 91);
pub const MM_MSFT_ACM_MSG723 = @as(u32, 92);
pub const MM_MSFT_ACM_MSRT24 = @as(u32, 93);
pub const MM_MSFT_WDMAUDIO_WAVEOUT = @as(u32, 100);
pub const MM_MSFT_WDMAUDIO_WAVEIN = @as(u32, 101);
pub const MM_MSFT_WDMAUDIO_MIDIOUT = @as(u32, 102);
pub const MM_MSFT_WDMAUDIO_MIDIIN = @as(u32, 103);
pub const MM_MSFT_WDMAUDIO_MIXER = @as(u32, 104);
pub const MM_MSFT_WDMAUDIO_AUX = @as(u32, 105);
pub const MM_CREATIVE_SB15_WAVEIN = @as(u32, 1);
pub const MM_CREATIVE_SB20_WAVEIN = @as(u32, 2);
pub const MM_CREATIVE_SBPRO_WAVEIN = @as(u32, 3);
pub const MM_CREATIVE_SBP16_WAVEIN = @as(u32, 4);
pub const MM_CREATIVE_PHNBLST_WAVEIN = @as(u32, 5);
pub const MM_CREATIVE_SB15_WAVEOUT = @as(u32, 101);
pub const MM_CREATIVE_SB20_WAVEOUT = @as(u32, 102);
pub const MM_CREATIVE_SBPRO_WAVEOUT = @as(u32, 103);
pub const MM_CREATIVE_SBP16_WAVEOUT = @as(u32, 104);
pub const MM_CREATIVE_PHNBLST_WAVEOUT = @as(u32, 105);
pub const MM_CREATIVE_MIDIOUT = @as(u32, 201);
pub const MM_CREATIVE_MIDIIN = @as(u32, 202);
pub const MM_CREATIVE_FMSYNTH_MONO = @as(u32, 301);
pub const MM_CREATIVE_FMSYNTH_STEREO = @as(u32, 302);
pub const MM_CREATIVE_MIDI_AWE32 = @as(u32, 303);
pub const MM_CREATIVE_AUX_CD = @as(u32, 401);
pub const MM_CREATIVE_AUX_LINE = @as(u32, 402);
pub const MM_CREATIVE_AUX_MIC = @as(u32, 403);
pub const MM_CREATIVE_AUX_MASTER = @as(u32, 404);
pub const MM_CREATIVE_AUX_PCSPK = @as(u32, 405);
pub const MM_CREATIVE_AUX_WAVE = @as(u32, 406);
pub const MM_CREATIVE_AUX_MIDI = @as(u32, 407);
pub const MM_CREATIVE_SBPRO_MIXER = @as(u32, 408);
pub const MM_CREATIVE_SB16_MIXER = @as(u32, 409);
pub const MM_MEDIAVISION_PROAUDIO = @as(u32, 16);
pub const MM_PROAUD_MIDIOUT = @as(u32, 17);
pub const MM_PROAUD_MIDIIN = @as(u32, 18);
pub const MM_PROAUD_SYNTH = @as(u32, 19);
pub const MM_PROAUD_WAVEOUT = @as(u32, 20);
pub const MM_PROAUD_WAVEIN = @as(u32, 21);
pub const MM_PROAUD_MIXER = @as(u32, 22);
pub const MM_PROAUD_AUX = @as(u32, 23);
pub const MM_MEDIAVISION_THUNDER = @as(u32, 32);
pub const MM_THUNDER_SYNTH = @as(u32, 35);
pub const MM_THUNDER_WAVEOUT = @as(u32, 36);
pub const MM_THUNDER_WAVEIN = @as(u32, 37);
pub const MM_THUNDER_AUX = @as(u32, 39);
pub const MM_MEDIAVISION_TPORT = @as(u32, 64);
pub const MM_TPORT_WAVEOUT = @as(u32, 65);
pub const MM_TPORT_WAVEIN = @as(u32, 66);
pub const MM_TPORT_SYNTH = @as(u32, 67);
pub const MM_MEDIAVISION_PROAUDIO_PLUS = @as(u32, 80);
pub const MM_PROAUD_PLUS_MIDIOUT = @as(u32, 81);
pub const MM_PROAUD_PLUS_MIDIIN = @as(u32, 82);
pub const MM_PROAUD_PLUS_SYNTH = @as(u32, 83);
pub const MM_PROAUD_PLUS_WAVEOUT = @as(u32, 84);
pub const MM_PROAUD_PLUS_WAVEIN = @as(u32, 85);
pub const MM_PROAUD_PLUS_MIXER = @as(u32, 86);
pub const MM_PROAUD_PLUS_AUX = @as(u32, 87);
pub const MM_MEDIAVISION_PROAUDIO_16 = @as(u32, 96);
pub const MM_PROAUD_16_MIDIOUT = @as(u32, 97);
pub const MM_PROAUD_16_MIDIIN = @as(u32, 98);
pub const MM_PROAUD_16_SYNTH = @as(u32, 99);
pub const MM_PROAUD_16_WAVEOUT = @as(u32, 100);
pub const MM_PROAUD_16_WAVEIN = @as(u32, 101);
pub const MM_PROAUD_16_MIXER = @as(u32, 102);
pub const MM_PROAUD_16_AUX = @as(u32, 103);
pub const MM_MEDIAVISION_PROSTUDIO_16 = @as(u32, 96);
pub const MM_STUDIO_16_MIDIOUT = @as(u32, 97);
pub const MM_STUDIO_16_MIDIIN = @as(u32, 98);
pub const MM_STUDIO_16_SYNTH = @as(u32, 99);
pub const MM_STUDIO_16_WAVEOUT = @as(u32, 100);
pub const MM_STUDIO_16_WAVEIN = @as(u32, 101);
pub const MM_STUDIO_16_MIXER = @as(u32, 102);
pub const MM_STUDIO_16_AUX = @as(u32, 103);
pub const MM_MEDIAVISION_CDPC = @as(u32, 112);
pub const MM_CDPC_MIDIOUT = @as(u32, 113);
pub const MM_CDPC_MIDIIN = @as(u32, 114);
pub const MM_CDPC_SYNTH = @as(u32, 115);
pub const MM_CDPC_WAVEOUT = @as(u32, 116);
pub const MM_CDPC_WAVEIN = @as(u32, 117);
pub const MM_CDPC_MIXER = @as(u32, 118);
pub const MM_CDPC_AUX = @as(u32, 119);
pub const MM_MEDIAVISION_OPUS1208 = @as(u32, 128);
pub const MM_OPUS401_MIDIOUT = @as(u32, 129);
pub const MM_OPUS401_MIDIIN = @as(u32, 130);
pub const MM_OPUS1208_SYNTH = @as(u32, 131);
pub const MM_OPUS1208_WAVEOUT = @as(u32, 132);
pub const MM_OPUS1208_WAVEIN = @as(u32, 133);
pub const MM_OPUS1208_MIXER = @as(u32, 134);
pub const MM_OPUS1208_AUX = @as(u32, 135);
pub const MM_MEDIAVISION_OPUS1216 = @as(u32, 144);
pub const MM_OPUS1216_MIDIOUT = @as(u32, 145);
pub const MM_OPUS1216_MIDIIN = @as(u32, 146);
pub const MM_OPUS1216_SYNTH = @as(u32, 147);
pub const MM_OPUS1216_WAVEOUT = @as(u32, 148);
pub const MM_OPUS1216_WAVEIN = @as(u32, 149);
pub const MM_OPUS1216_MIXER = @as(u32, 150);
pub const MM_OPUS1216_AUX = @as(u32, 151);
pub const MM_CYRIX_XASYNTH = @as(u32, 1);
pub const MM_CYRIX_XAMIDIIN = @as(u32, 2);
pub const MM_CYRIX_XAMIDIOUT = @as(u32, 3);
pub const MM_CYRIX_XAWAVEIN = @as(u32, 4);
pub const MM_CYRIX_XAWAVEOUT = @as(u32, 5);
pub const MM_CYRIX_XAAUX = @as(u32, 6);
pub const MM_CYRIX_XAMIXER = @as(u32, 7);
pub const MM_PHILIPS_ACM_LPCBB = @as(u32, 1);
pub const MM_NETXL_XLVIDEO = @as(u32, 1);
pub const MM_ZYXEL_ACM_ADPCM = @as(u32, 1);
pub const MM_AARDVARK_STUDIO12_WAVEOUT = @as(u32, 1);
pub const MM_AARDVARK_STUDIO12_WAVEIN = @as(u32, 2);
pub const MM_AARDVARK_STUDIO88_WAVEOUT = @as(u32, 3);
pub const MM_AARDVARK_STUDIO88_WAVEIN = @as(u32, 4);
pub const MM_BINTEC_TAPI_WAVE = @as(u32, 1);
pub const MM_HEWLETT_PACKARD_CU_CODEC = @as(u32, 1);
pub const MM_MITEL_TALKTO_LINE_WAVEOUT = @as(u32, 100);
pub const MM_MITEL_TALKTO_LINE_WAVEIN = @as(u32, 101);
pub const MM_MITEL_TALKTO_HANDSET_WAVEOUT = @as(u32, 102);
pub const MM_MITEL_TALKTO_HANDSET_WAVEIN = @as(u32, 103);
pub const MM_MITEL_TALKTO_BRIDGED_WAVEOUT = @as(u32, 104);
pub const MM_MITEL_TALKTO_BRIDGED_WAVEIN = @as(u32, 105);
pub const MM_MITEL_MPA_HANDSET_WAVEOUT = @as(u32, 200);
pub const MM_MITEL_MPA_HANDSET_WAVEIN = @as(u32, 201);
pub const MM_MITEL_MPA_HANDSFREE_WAVEOUT = @as(u32, 202);
pub const MM_MITEL_MPA_HANDSFREE_WAVEIN = @as(u32, 203);
pub const MM_MITEL_MPA_LINE1_WAVEOUT = @as(u32, 204);
pub const MM_MITEL_MPA_LINE1_WAVEIN = @as(u32, 205);
pub const MM_MITEL_MPA_LINE2_WAVEOUT = @as(u32, 206);
pub const MM_MITEL_MPA_LINE2_WAVEIN = @as(u32, 207);
pub const MM_MITEL_MEDIAPATH_WAVEOUT = @as(u32, 300);
pub const MM_MITEL_MEDIAPATH_WAVEIN = @as(u32, 301);
pub const MM_SNI_ACM_G721 = @as(u32, 1);
pub const MM_EMU_APSSYNTH = @as(u32, 1);
pub const MM_EMU_APSMIDIIN = @as(u32, 2);
pub const MM_EMU_APSMIDIOUT = @as(u32, 3);
pub const MM_EMU_APSWAVEIN = @as(u32, 4);
pub const MM_EMU_APSWAVEOUT = @as(u32, 5);
pub const MM_ARTISOFT_SBWAVEIN = @as(u32, 1);
pub const MM_ARTISOFT_SBWAVEOUT = @as(u32, 2);
pub const MM_TBS_TROPEZ_WAVEIN = @as(u32, 37);
pub const MM_TBS_TROPEZ_WAVEOUT = @as(u32, 38);
pub const MM_TBS_TROPEZ_AUX1 = @as(u32, 39);
pub const MM_TBS_TROPEZ_AUX2 = @as(u32, 40);
pub const MM_TBS_TROPEZ_LINE = @as(u32, 41);
pub const MM_MMOTION_WAVEAUX = @as(u32, 1);
pub const MM_MMOTION_WAVEOUT = @as(u32, 2);
pub const MM_MMOTION_WAVEIN = @as(u32, 3);
pub const MM_IBM_PCMCIA_WAVEIN = @as(u32, 11);
pub const MM_IBM_PCMCIA_WAVEOUT = @as(u32, 12);
pub const MM_IBM_PCMCIA_SYNTH = @as(u32, 13);
pub const MM_IBM_PCMCIA_MIDIIN = @as(u32, 14);
pub const MM_IBM_PCMCIA_MIDIOUT = @as(u32, 15);
pub const MM_IBM_PCMCIA_AUX = @as(u32, 16);
pub const MM_IBM_THINKPAD200 = @as(u32, 17);
pub const MM_IBM_MWAVE_WAVEIN = @as(u32, 18);
pub const MM_IBM_MWAVE_WAVEOUT = @as(u32, 19);
pub const MM_IBM_MWAVE_MIXER = @as(u32, 20);
pub const MM_IBM_MWAVE_MIDIIN = @as(u32, 21);
pub const MM_IBM_MWAVE_MIDIOUT = @as(u32, 22);
pub const MM_IBM_MWAVE_AUX = @as(u32, 23);
pub const MM_IBM_WC_MIDIOUT = @as(u32, 30);
pub const MM_IBM_WC_WAVEOUT = @as(u32, 31);
pub const MM_IBM_WC_MIXEROUT = @as(u32, 33);
pub const MM_VOCALTEC_WAVEOUT = @as(u32, 1);
pub const MM_VOCALTEC_WAVEIN = @as(u32, 2);
pub const MM_ROLAND_RAP10_MIDIOUT = @as(u32, 10);
pub const MM_ROLAND_RAP10_MIDIIN = @as(u32, 11);
pub const MM_ROLAND_RAP10_SYNTH = @as(u32, 12);
pub const MM_ROLAND_RAP10_WAVEOUT = @as(u32, 13);
pub const MM_ROLAND_RAP10_WAVEIN = @as(u32, 14);
pub const MM_ROLAND_MPU401_MIDIOUT = @as(u32, 15);
pub const MM_ROLAND_MPU401_MIDIIN = @as(u32, 16);
pub const MM_ROLAND_SMPU_MIDIOUTA = @as(u32, 17);
pub const MM_ROLAND_SMPU_MIDIOUTB = @as(u32, 18);
pub const MM_ROLAND_SMPU_MIDIINA = @as(u32, 19);
pub const MM_ROLAND_SMPU_MIDIINB = @as(u32, 20);
pub const MM_ROLAND_SC7_MIDIOUT = @as(u32, 21);
pub const MM_ROLAND_SC7_MIDIIN = @as(u32, 22);
pub const MM_ROLAND_SERIAL_MIDIOUT = @as(u32, 23);
pub const MM_ROLAND_SERIAL_MIDIIN = @as(u32, 24);
pub const MM_ROLAND_SCP_MIDIOUT = @as(u32, 38);
pub const MM_ROLAND_SCP_MIDIIN = @as(u32, 39);
pub const MM_ROLAND_SCP_WAVEOUT = @as(u32, 40);
pub const MM_ROLAND_SCP_WAVEIN = @as(u32, 41);
pub const MM_ROLAND_SCP_MIXER = @as(u32, 42);
pub const MM_ROLAND_SCP_AUX = @as(u32, 48);
pub const MM_DSP_SOLUTIONS_WAVEOUT = @as(u32, 1);
pub const MM_DSP_SOLUTIONS_WAVEIN = @as(u32, 2);
pub const MM_DSP_SOLUTIONS_SYNTH = @as(u32, 3);
pub const MM_DSP_SOLUTIONS_AUX = @as(u32, 4);
pub const MM_NEC_73_86_SYNTH = @as(u32, 5);
pub const MM_NEC_73_86_WAVEOUT = @as(u32, 6);
pub const MM_NEC_73_86_WAVEIN = @as(u32, 7);
pub const MM_NEC_26_SYNTH = @as(u32, 9);
pub const MM_NEC_MPU401_MIDIOUT = @as(u32, 10);
pub const MM_NEC_MPU401_MIDIIN = @as(u32, 11);
pub const MM_NEC_JOYSTICK = @as(u32, 12);
pub const MM_WANGLABS_WAVEIN1 = @as(u32, 1);
pub const MM_WANGLABS_WAVEOUT1 = @as(u32, 2);
pub const MM_TANDY_VISWAVEIN = @as(u32, 1);
pub const MM_TANDY_VISWAVEOUT = @as(u32, 2);
pub const MM_TANDY_VISBIOSSYNTH = @as(u32, 3);
pub const MM_TANDY_SENS_MMAWAVEIN = @as(u32, 4);
pub const MM_TANDY_SENS_MMAWAVEOUT = @as(u32, 5);
pub const MM_TANDY_SENS_MMAMIDIIN = @as(u32, 6);
pub const MM_TANDY_SENS_MMAMIDIOUT = @as(u32, 7);
pub const MM_TANDY_SENS_VISWAVEOUT = @as(u32, 8);
pub const MM_TANDY_PSSJWAVEIN = @as(u32, 9);
pub const MM_TANDY_PSSJWAVEOUT = @as(u32, 10);
pub const MM_ANTEX_SX12_WAVEIN = @as(u32, 1);
pub const MM_ANTEX_SX12_WAVEOUT = @as(u32, 2);
pub const MM_ANTEX_SX15_WAVEIN = @as(u32, 3);
pub const MM_ANTEX_SX15_WAVEOUT = @as(u32, 4);
pub const MM_ANTEX_VP625_WAVEIN = @as(u32, 5);
pub const MM_ANTEX_VP625_WAVEOUT = @as(u32, 6);
pub const MM_ANTEX_AUDIOPORT22_WAVEIN = @as(u32, 7);
pub const MM_ANTEX_AUDIOPORT22_WAVEOUT = @as(u32, 8);
pub const MM_ANTEX_AUDIOPORT22_FEEDTHRU = @as(u32, 9);
pub const MM_INTELOPD_WAVEIN = @as(u32, 1);
pub const MM_INTELOPD_WAVEOUT = @as(u32, 101);
pub const MM_INTELOPD_AUX = @as(u32, 401);
pub const MM_INTEL_NSPMODEMLINEIN = @as(u32, 501);
pub const MM_INTEL_NSPMODEMLINEOUT = @as(u32, 502);
pub const MM_VAL_MICROKEY_AP_WAVEIN = @as(u32, 1);
pub const MM_VAL_MICROKEY_AP_WAVEOUT = @as(u32, 2);
pub const MM_INTERACTIVE_WAVEIN = @as(u32, 69);
pub const MM_INTERACTIVE_WAVEOUT = @as(u32, 69);
pub const MM_YAMAHA_GSS_SYNTH = @as(u32, 1);
pub const MM_YAMAHA_GSS_WAVEOUT = @as(u32, 2);
pub const MM_YAMAHA_GSS_WAVEIN = @as(u32, 3);
pub const MM_YAMAHA_GSS_MIDIOUT = @as(u32, 4);
pub const MM_YAMAHA_GSS_MIDIIN = @as(u32, 5);
pub const MM_YAMAHA_GSS_AUX = @as(u32, 6);
pub const MM_YAMAHA_SERIAL_MIDIOUT = @as(u32, 7);
pub const MM_YAMAHA_SERIAL_MIDIIN = @as(u32, 8);
pub const MM_YAMAHA_OPL3SA_WAVEOUT = @as(u32, 16);
pub const MM_YAMAHA_OPL3SA_WAVEIN = @as(u32, 17);
pub const MM_YAMAHA_OPL3SA_FMSYNTH = @as(u32, 18);
pub const MM_YAMAHA_OPL3SA_YSYNTH = @as(u32, 19);
pub const MM_YAMAHA_OPL3SA_MIDIOUT = @as(u32, 20);
pub const MM_YAMAHA_OPL3SA_MIDIIN = @as(u32, 21);
pub const MM_YAMAHA_OPL3SA_MIXER = @as(u32, 23);
pub const MM_YAMAHA_OPL3SA_JOYSTICK = @as(u32, 24);
pub const MM_YAMAHA_YMF724LEG_MIDIOUT = @as(u32, 25);
pub const MM_YAMAHA_YMF724LEG_MIDIIN = @as(u32, 26);
pub const MM_YAMAHA_YMF724_WAVEOUT = @as(u32, 27);
pub const MM_YAMAHA_YMF724_WAVEIN = @as(u32, 28);
pub const MM_YAMAHA_YMF724_MIDIOUT = @as(u32, 29);
pub const MM_YAMAHA_YMF724_AUX = @as(u32, 30);
pub const MM_YAMAHA_YMF724_MIXER = @as(u32, 31);
pub const MM_YAMAHA_YMF724LEG_FMSYNTH = @as(u32, 32);
pub const MM_YAMAHA_YMF724LEG_MIXER = @as(u32, 33);
pub const MM_YAMAHA_SXG_MIDIOUT = @as(u32, 34);
pub const MM_YAMAHA_SXG_WAVEOUT = @as(u32, 35);
pub const MM_YAMAHA_SXG_MIXER = @as(u32, 36);
pub const MM_YAMAHA_ACXG_WAVEIN = @as(u32, 37);
pub const MM_YAMAHA_ACXG_WAVEOUT = @as(u32, 38);
pub const MM_YAMAHA_ACXG_MIDIOUT = @as(u32, 39);
pub const MM_YAMAHA_ACXG_MIXER = @as(u32, 40);
pub const MM_YAMAHA_ACXG_AUX = @as(u32, 41);
pub const MM_EVEREX_CARRIER = @as(u32, 1);
pub const MM_ECHO_SYNTH = @as(u32, 1);
pub const MM_ECHO_WAVEOUT = @as(u32, 2);
pub const MM_ECHO_WAVEIN = @as(u32, 3);
pub const MM_ECHO_MIDIOUT = @as(u32, 4);
pub const MM_ECHO_MIDIIN = @as(u32, 5);
pub const MM_ECHO_AUX = @as(u32, 6);
pub const MM_SIERRA_ARIA_MIDIOUT = @as(u32, 20);
pub const MM_SIERRA_ARIA_MIDIIN = @as(u32, 21);
pub const MM_SIERRA_ARIA_SYNTH = @as(u32, 22);
pub const MM_SIERRA_ARIA_WAVEOUT = @as(u32, 23);
pub const MM_SIERRA_ARIA_WAVEIN = @as(u32, 24);
pub const MM_SIERRA_ARIA_AUX = @as(u32, 25);
pub const MM_SIERRA_ARIA_AUX2 = @as(u32, 32);
pub const MM_SIERRA_QUARTET_WAVEIN = @as(u32, 80);
pub const MM_SIERRA_QUARTET_WAVEOUT = @as(u32, 81);
pub const MM_SIERRA_QUARTET_MIDIIN = @as(u32, 82);
pub const MM_SIERRA_QUARTET_MIDIOUT = @as(u32, 83);
pub const MM_SIERRA_QUARTET_SYNTH = @as(u32, 84);
pub const MM_SIERRA_QUARTET_AUX_CD = @as(u32, 85);
pub const MM_SIERRA_QUARTET_AUX_LINE = @as(u32, 86);
pub const MM_SIERRA_QUARTET_AUX_MODEM = @as(u32, 87);
pub const MM_SIERRA_QUARTET_MIXER = @as(u32, 88);
pub const MM_CAT_WAVEOUT = @as(u32, 1);
pub const MM_DSP_GROUP_TRUESPEECH = @as(u32, 1);
pub const MM_MELABS_MIDI2GO = @as(u32, 1);
pub const MM_ESS_AMWAVEOUT = @as(u32, 1);
pub const MM_ESS_AMWAVEIN = @as(u32, 2);
pub const MM_ESS_AMAUX = @as(u32, 3);
pub const MM_ESS_AMSYNTH = @as(u32, 4);
pub const MM_ESS_AMMIDIOUT = @as(u32, 5);
pub const MM_ESS_AMMIDIIN = @as(u32, 6);
pub const MM_ESS_MIXER = @as(u32, 7);
pub const MM_ESS_AUX_CD = @as(u32, 8);
pub const MM_ESS_MPU401_MIDIOUT = @as(u32, 9);
pub const MM_ESS_MPU401_MIDIIN = @as(u32, 10);
pub const MM_ESS_ES488_WAVEOUT = @as(u32, 16);
pub const MM_ESS_ES488_WAVEIN = @as(u32, 17);
pub const MM_ESS_ES488_MIXER = @as(u32, 18);
pub const MM_ESS_ES688_WAVEOUT = @as(u32, 19);
pub const MM_ESS_ES688_WAVEIN = @as(u32, 20);
pub const MM_ESS_ES688_MIXER = @as(u32, 21);
pub const MM_ESS_ES1488_WAVEOUT = @as(u32, 22);
pub const MM_ESS_ES1488_WAVEIN = @as(u32, 23);
pub const MM_ESS_ES1488_MIXER = @as(u32, 24);
pub const MM_ESS_ES1688_WAVEOUT = @as(u32, 25);
pub const MM_ESS_ES1688_WAVEIN = @as(u32, 26);
pub const MM_ESS_ES1688_MIXER = @as(u32, 27);
pub const MM_ESS_ES1788_WAVEOUT = @as(u32, 28);
pub const MM_ESS_ES1788_WAVEIN = @as(u32, 29);
pub const MM_ESS_ES1788_MIXER = @as(u32, 30);
pub const MM_ESS_ES1888_WAVEOUT = @as(u32, 31);
pub const MM_ESS_ES1888_WAVEIN = @as(u32, 32);
pub const MM_ESS_ES1888_MIXER = @as(u32, 33);
pub const MM_ESS_ES1868_WAVEOUT = @as(u32, 34);
pub const MM_ESS_ES1868_WAVEIN = @as(u32, 35);
pub const MM_ESS_ES1868_MIXER = @as(u32, 36);
pub const MM_ESS_ES1878_WAVEOUT = @as(u32, 37);
pub const MM_ESS_ES1878_WAVEIN = @as(u32, 38);
pub const MM_ESS_ES1878_MIXER = @as(u32, 39);
pub const MM_CANOPUS_ACM_DVREX = @as(u32, 1);
pub const MM_EPS_FMSND = @as(u32, 1);
pub const MM_TRUEVISION_WAVEIN1 = @as(u32, 1);
pub const MM_TRUEVISION_WAVEOUT1 = @as(u32, 2);
pub const MM_AZTECH_MIDIOUT = @as(u32, 3);
pub const MM_AZTECH_MIDIIN = @as(u32, 4);
pub const MM_AZTECH_WAVEIN = @as(u32, 17);
pub const MM_AZTECH_WAVEOUT = @as(u32, 18);
pub const MM_AZTECH_FMSYNTH = @as(u32, 20);
pub const MM_AZTECH_MIXER = @as(u32, 21);
pub const MM_AZTECH_PRO16_WAVEIN = @as(u32, 33);
pub const MM_AZTECH_PRO16_WAVEOUT = @as(u32, 34);
pub const MM_AZTECH_PRO16_FMSYNTH = @as(u32, 38);
pub const MM_AZTECH_DSP16_WAVEIN = @as(u32, 65);
pub const MM_AZTECH_DSP16_WAVEOUT = @as(u32, 66);
pub const MM_AZTECH_DSP16_FMSYNTH = @as(u32, 68);
pub const MM_AZTECH_DSP16_WAVESYNTH = @as(u32, 70);
pub const MM_AZTECH_NOVA16_WAVEIN = @as(u32, 71);
pub const MM_AZTECH_NOVA16_WAVEOUT = @as(u32, 72);
pub const MM_AZTECH_NOVA16_MIXER = @as(u32, 73);
pub const MM_AZTECH_WASH16_WAVEIN = @as(u32, 74);
pub const MM_AZTECH_WASH16_WAVEOUT = @as(u32, 75);
pub const MM_AZTECH_WASH16_MIXER = @as(u32, 76);
pub const MM_AZTECH_AUX_CD = @as(u32, 401);
pub const MM_AZTECH_AUX_LINE = @as(u32, 402);
pub const MM_AZTECH_AUX_MIC = @as(u32, 403);
pub const MM_AZTECH_AUX = @as(u32, 404);
pub const MM_VIDEOLOGIC_MSWAVEIN = @as(u32, 1);
pub const MM_VIDEOLOGIC_MSWAVEOUT = @as(u32, 2);
pub const MM_KORG_PCIF_MIDIOUT = @as(u32, 1);
pub const MM_KORG_PCIF_MIDIIN = @as(u32, 2);
pub const MM_KORG_1212IO_MSWAVEIN = @as(u32, 3);
pub const MM_KORG_1212IO_MSWAVEOUT = @as(u32, 4);
pub const MM_APT_ACE100CD = @as(u32, 1);
pub const MM_ICS_WAVEDECK_WAVEOUT = @as(u32, 1);
pub const MM_ICS_WAVEDECK_WAVEIN = @as(u32, 2);
pub const MM_ICS_WAVEDECK_MIXER = @as(u32, 3);
pub const MM_ICS_WAVEDECK_AUX = @as(u32, 4);
pub const MM_ICS_WAVEDECK_SYNTH = @as(u32, 5);
pub const MM_ICS_WAVEDEC_SB_WAVEOUT = @as(u32, 6);
pub const MM_ICS_WAVEDEC_SB_WAVEIN = @as(u32, 7);
pub const MM_ICS_WAVEDEC_SB_FM_MIDIOUT = @as(u32, 8);
pub const MM_ICS_WAVEDEC_SB_MPU401_MIDIOUT = @as(u32, 9);
pub const MM_ICS_WAVEDEC_SB_MPU401_MIDIIN = @as(u32, 10);
pub const MM_ICS_WAVEDEC_SB_MIXER = @as(u32, 11);
pub const MM_ICS_WAVEDEC_SB_AUX = @as(u32, 12);
pub const MM_ICS_2115_LITE_MIDIOUT = @as(u32, 13);
pub const MM_ICS_2120_LITE_MIDIOUT = @as(u32, 14);
pub const MM_ITERATEDSYS_FUFCODEC = @as(u32, 1);
pub const MM_METHEUS_ZIPPER = @as(u32, 1);
pub const MM_WINNOV_CAVIAR_WAVEIN = @as(u32, 1);
pub const MM_WINNOV_CAVIAR_WAVEOUT = @as(u32, 2);
pub const MM_WINNOV_CAVIAR_VIDC = @as(u32, 3);
pub const MM_WINNOV_CAVIAR_CHAMPAGNE = @as(u32, 4);
pub const MM_WINNOV_CAVIAR_YUV8 = @as(u32, 5);
pub const MM_NCR_BA_WAVEIN = @as(u32, 1);
pub const MM_NCR_BA_WAVEOUT = @as(u32, 2);
pub const MM_NCR_BA_SYNTH = @as(u32, 3);
pub const MM_NCR_BA_AUX = @as(u32, 4);
pub const MM_NCR_BA_MIXER = @as(u32, 5);
pub const MM_AST_MODEMWAVE_WAVEIN = @as(u32, 13);
pub const MM_AST_MODEMWAVE_WAVEOUT = @as(u32, 14);
pub const MM_WILLOWPOND_FMSYNTH_STEREO = @as(u32, 20);
pub const MM_WILLOWPOND_MPU401 = @as(u32, 21);
pub const MM_WILLOWPOND_SNDPORT_WAVEIN = @as(u32, 100);
pub const MM_WILLOWPOND_SNDPORT_WAVEOUT = @as(u32, 101);
pub const MM_WILLOWPOND_SNDPORT_MIXER = @as(u32, 102);
pub const MM_WILLOWPOND_SNDPORT_AUX = @as(u32, 103);
pub const MM_WILLOWPOND_PH_WAVEIN = @as(u32, 104);
pub const MM_WILLOWPOND_PH_WAVEOUT = @as(u32, 105);
pub const MM_WILLOWPOND_PH_MIXER = @as(u32, 106);
pub const MM_WILLOWPOND_PH_AUX = @as(u32, 107);
pub const MM_WILLOPOND_SNDCOMM_WAVEIN = @as(u32, 108);
pub const MM_WILLOWPOND_SNDCOMM_WAVEOUT = @as(u32, 109);
pub const MM_WILLOWPOND_SNDCOMM_MIXER = @as(u32, 110);
pub const MM_WILLOWPOND_SNDCOMM_AUX = @as(u32, 111);
pub const MM_WILLOWPOND_GENERIC_WAVEIN = @as(u32, 112);
pub const MM_WILLOWPOND_GENERIC_WAVEOUT = @as(u32, 113);
pub const MM_WILLOWPOND_GENERIC_MIXER = @as(u32, 114);
pub const MM_WILLOWPOND_GENERIC_AUX = @as(u32, 115);
pub const MM_VITEC_VMAKER = @as(u32, 1);
pub const MM_VITEC_VMPRO = @as(u32, 2);
pub const MM_MOSCOM_VPC2400_IN = @as(u32, 1);
pub const MM_MOSCOM_VPC2400_OUT = @as(u32, 2);
pub const MM_SILICONSOFT_SC1_WAVEIN = @as(u32, 1);
pub const MM_SILICONSOFT_SC1_WAVEOUT = @as(u32, 2);
pub const MM_SILICONSOFT_SC2_WAVEIN = @as(u32, 3);
pub const MM_SILICONSOFT_SC2_WAVEOUT = @as(u32, 4);
pub const MM_SILICONSOFT_SOUNDJR2_WAVEOUT = @as(u32, 5);
pub const MM_SILICONSOFT_SOUNDJR2PR_WAVEIN = @as(u32, 6);
pub const MM_SILICONSOFT_SOUNDJR2PR_WAVEOUT = @as(u32, 7);
pub const MM_SILICONSOFT_SOUNDJR3_WAVEOUT = @as(u32, 8);
pub const MM_TTEWS_WAVEIN = @as(u32, 1);
pub const MM_TTEWS_WAVEOUT = @as(u32, 2);
pub const MM_TTEWS_MIDIIN = @as(u32, 3);
pub const MM_TTEWS_MIDIOUT = @as(u32, 4);
pub const MM_TTEWS_MIDISYNTH = @as(u32, 5);
pub const MM_TTEWS_MIDIMONITOR = @as(u32, 6);
pub const MM_TTEWS_VMIDIIN = @as(u32, 7);
pub const MM_TTEWS_VMIDIOUT = @as(u32, 8);
pub const MM_TTEWS_AUX = @as(u32, 9);
pub const MM_TTEWS_MIXER = @as(u32, 10);
pub const MM_MEDIASONIC_ACM_G723 = @as(u32, 1);
pub const MM_MEDIASONIC_ICOM = @as(u32, 2);
pub const MM_ICOM_WAVEIN = @as(u32, 3);
pub const MM_ICOM_WAVEOUT = @as(u32, 4);
pub const MM_ICOM_MIXER = @as(u32, 5);
pub const MM_ICOM_AUX = @as(u32, 6);
pub const MM_ICOM_LINE = @as(u32, 7);
pub const MM_SANYO_ACM_LD_ADPCM = @as(u32, 1);
pub const MM_AHEAD_MULTISOUND = @as(u32, 1);
pub const MM_AHEAD_SOUNDBLASTER = @as(u32, 2);
pub const MM_AHEAD_PROAUDIO = @as(u32, 3);
pub const MM_AHEAD_GENERIC = @as(u32, 4);
pub const MM_OLIVETTI_WAVEIN = @as(u32, 1);
pub const MM_OLIVETTI_WAVEOUT = @as(u32, 2);
pub const MM_OLIVETTI_MIXER = @as(u32, 3);
pub const MM_OLIVETTI_AUX = @as(u32, 4);
pub const MM_OLIVETTI_MIDIIN = @as(u32, 5);
pub const MM_OLIVETTI_MIDIOUT = @as(u32, 6);
pub const MM_OLIVETTI_SYNTH = @as(u32, 7);
pub const MM_OLIVETTI_JOYSTICK = @as(u32, 8);
pub const MM_OLIVETTI_ACM_GSM = @as(u32, 9);
pub const MM_OLIVETTI_ACM_ADPCM = @as(u32, 10);
pub const MM_OLIVETTI_ACM_CELP = @as(u32, 11);
pub const MM_OLIVETTI_ACM_SBC = @as(u32, 12);
pub const MM_OLIVETTI_ACM_OPR = @as(u32, 13);
pub const MM_IOMAGIC_TEMPO_WAVEOUT = @as(u32, 1);
pub const MM_IOMAGIC_TEMPO_WAVEIN = @as(u32, 2);
pub const MM_IOMAGIC_TEMPO_SYNTH = @as(u32, 3);
pub const MM_IOMAGIC_TEMPO_MIDIOUT = @as(u32, 4);
pub const MM_IOMAGIC_TEMPO_MXDOUT = @as(u32, 5);
pub const MM_IOMAGIC_TEMPO_AUXOUT = @as(u32, 6);
pub const MM_MATSUSHITA_WAVEIN = @as(u32, 1);
pub const MM_MATSUSHITA_WAVEOUT = @as(u32, 2);
pub const MM_MATSUSHITA_FMSYNTH_STEREO = @as(u32, 3);
pub const MM_MATSUSHITA_MIXER = @as(u32, 4);
pub const MM_MATSUSHITA_AUX = @as(u32, 5);
pub const MM_NEWMEDIA_WAVJAMMER = @as(u32, 1);
pub const MM_LYRRUS_BRIDGE_GUITAR = @as(u32, 1);
pub const MM_OPTI_M16_FMSYNTH_STEREO = @as(u32, 1);
pub const MM_OPTI_M16_MIDIIN = @as(u32, 2);
pub const MM_OPTI_M16_MIDIOUT = @as(u32, 3);
pub const MM_OPTI_M16_WAVEIN = @as(u32, 4);
pub const MM_OPTI_M16_WAVEOUT = @as(u32, 5);
pub const MM_OPTI_M16_MIXER = @as(u32, 6);
pub const MM_OPTI_M16_AUX = @as(u32, 7);
pub const MM_OPTI_P16_FMSYNTH_STEREO = @as(u32, 16);
pub const MM_OPTI_P16_MIDIIN = @as(u32, 17);
pub const MM_OPTI_P16_MIDIOUT = @as(u32, 18);
pub const MM_OPTI_P16_WAVEIN = @as(u32, 19);
pub const MM_OPTI_P16_WAVEOUT = @as(u32, 20);
pub const MM_OPTI_P16_MIXER = @as(u32, 21);
pub const MM_OPTI_P16_AUX = @as(u32, 22);
pub const MM_OPTI_M32_WAVEIN = @as(u32, 32);
pub const MM_OPTI_M32_WAVEOUT = @as(u32, 33);
pub const MM_OPTI_M32_MIDIIN = @as(u32, 34);
pub const MM_OPTI_M32_MIDIOUT = @as(u32, 35);
pub const MM_OPTI_M32_SYNTH_STEREO = @as(u32, 36);
pub const MM_OPTI_M32_MIXER = @as(u32, 37);
pub const MM_OPTI_M32_AUX = @as(u32, 38);
pub const MM_COMPAQ_BB_WAVEIN = @as(u32, 1);
pub const MM_COMPAQ_BB_WAVEOUT = @as(u32, 2);
pub const MM_COMPAQ_BB_WAVEAUX = @as(u32, 3);
pub const MM_MPTUS_SPWAVEOUT = @as(u32, 1);
pub const MM_LERNOUT_ANDHAUSPIE_LHCODECACM = @as(u32, 1);
pub const MM_DIGITAL_AV320_WAVEIN = @as(u32, 1);
pub const MM_DIGITAL_AV320_WAVEOUT = @as(u32, 2);
pub const MM_DIGITAL_ACM_G723 = @as(u32, 3);
pub const MM_DIGITAL_ICM_H263 = @as(u32, 4);
pub const MM_DIGITAL_ICM_H261 = @as(u32, 5);
pub const MM_MOTU_MTP_MIDIOUT_ALL = @as(u32, 100);
pub const MM_MOTU_MTP_MIDIIN_1 = @as(u32, 101);
pub const MM_MOTU_MTP_MIDIOUT_1 = @as(u32, 101);
pub const MM_MOTU_MTP_MIDIIN_2 = @as(u32, 102);
pub const MM_MOTU_MTP_MIDIOUT_2 = @as(u32, 102);
pub const MM_MOTU_MTP_MIDIIN_3 = @as(u32, 103);
pub const MM_MOTU_MTP_MIDIOUT_3 = @as(u32, 103);
pub const MM_MOTU_MTP_MIDIIN_4 = @as(u32, 104);
pub const MM_MOTU_MTP_MIDIOUT_4 = @as(u32, 104);
pub const MM_MOTU_MTP_MIDIIN_5 = @as(u32, 105);
pub const MM_MOTU_MTP_MIDIOUT_5 = @as(u32, 105);
pub const MM_MOTU_MTP_MIDIIN_6 = @as(u32, 106);
pub const MM_MOTU_MTP_MIDIOUT_6 = @as(u32, 106);
pub const MM_MOTU_MTP_MIDIIN_7 = @as(u32, 107);
pub const MM_MOTU_MTP_MIDIOUT_7 = @as(u32, 107);
pub const MM_MOTU_MTP_MIDIIN_8 = @as(u32, 108);
pub const MM_MOTU_MTP_MIDIOUT_8 = @as(u32, 108);
pub const MM_MOTU_MTPII_MIDIOUT_ALL = @as(u32, 200);
pub const MM_MOTU_MTPII_MIDIIN_SYNC = @as(u32, 200);
pub const MM_MOTU_MTPII_MIDIIN_1 = @as(u32, 201);
pub const MM_MOTU_MTPII_MIDIOUT_1 = @as(u32, 201);
pub const MM_MOTU_MTPII_MIDIIN_2 = @as(u32, 202);
pub const MM_MOTU_MTPII_MIDIOUT_2 = @as(u32, 202);
pub const MM_MOTU_MTPII_MIDIIN_3 = @as(u32, 203);
pub const MM_MOTU_MTPII_MIDIOUT_3 = @as(u32, 203);
pub const MM_MOTU_MTPII_MIDIIN_4 = @as(u32, 204);
pub const MM_MOTU_MTPII_MIDIOUT_4 = @as(u32, 204);
pub const MM_MOTU_MTPII_MIDIIN_5 = @as(u32, 205);
pub const MM_MOTU_MTPII_MIDIOUT_5 = @as(u32, 205);
pub const MM_MOTU_MTPII_MIDIIN_6 = @as(u32, 206);
pub const MM_MOTU_MTPII_MIDIOUT_6 = @as(u32, 206);
pub const MM_MOTU_MTPII_MIDIIN_7 = @as(u32, 207);
pub const MM_MOTU_MTPII_MIDIOUT_7 = @as(u32, 207);
pub const MM_MOTU_MTPII_MIDIIN_8 = @as(u32, 208);
pub const MM_MOTU_MTPII_MIDIOUT_8 = @as(u32, 208);
pub const MM_MOTU_MTPII_NET_MIDIIN_1 = @as(u32, 209);
pub const MM_MOTU_MTPII_NET_MIDIOUT_1 = @as(u32, 209);
pub const MM_MOTU_MTPII_NET_MIDIIN_2 = @as(u32, 210);
pub const MM_MOTU_MTPII_NET_MIDIOUT_2 = @as(u32, 210);
pub const MM_MOTU_MTPII_NET_MIDIIN_3 = @as(u32, 211);
pub const MM_MOTU_MTPII_NET_MIDIOUT_3 = @as(u32, 211);
pub const MM_MOTU_MTPII_NET_MIDIIN_4 = @as(u32, 212);
pub const MM_MOTU_MTPII_NET_MIDIOUT_4 = @as(u32, 212);
pub const MM_MOTU_MTPII_NET_MIDIIN_5 = @as(u32, 213);
pub const MM_MOTU_MTPII_NET_MIDIOUT_5 = @as(u32, 213);
pub const MM_MOTU_MTPII_NET_MIDIIN_6 = @as(u32, 214);
pub const MM_MOTU_MTPII_NET_MIDIOUT_6 = @as(u32, 214);
pub const MM_MOTU_MTPII_NET_MIDIIN_7 = @as(u32, 215);
pub const MM_MOTU_MTPII_NET_MIDIOUT_7 = @as(u32, 215);
pub const MM_MOTU_MTPII_NET_MIDIIN_8 = @as(u32, 216);
pub const MM_MOTU_MTPII_NET_MIDIOUT_8 = @as(u32, 216);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_ALL = @as(u32, 300);
pub const MM_MOTU_MXP_MIDIIN_SYNC = @as(u32, 300);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_1 = @as(u32, 301);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_1 = @as(u32, 301);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_2 = @as(u32, 302);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_2 = @as(u32, 302);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_3 = @as(u32, 303);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_3 = @as(u32, 303);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_4 = @as(u32, 304);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_4 = @as(u32, 304);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_5 = @as(u32, 305);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_5 = @as(u32, 305);
pub const MM_MOTU_MXP_MIDIIN_MIDIIN_6 = @as(u32, 306);
pub const MM_MOTU_MXP_MIDIIN_MIDIOUT_6 = @as(u32, 306);
pub const MM_MOTU_MXPMPU_MIDIOUT_ALL = @as(u32, 400);
pub const MM_MOTU_MXPMPU_MIDIIN_SYNC = @as(u32, 400);
pub const MM_MOTU_MXPMPU_MIDIIN_1 = @as(u32, 401);
pub const MM_MOTU_MXPMPU_MIDIOUT_1 = @as(u32, 401);
pub const MM_MOTU_MXPMPU_MIDIIN_2 = @as(u32, 402);
pub const MM_MOTU_MXPMPU_MIDIOUT_2 = @as(u32, 402);
pub const MM_MOTU_MXPMPU_MIDIIN_3 = @as(u32, 403);
pub const MM_MOTU_MXPMPU_MIDIOUT_3 = @as(u32, 403);
pub const MM_MOTU_MXPMPU_MIDIIN_4 = @as(u32, 404);
pub const MM_MOTU_MXPMPU_MIDIOUT_4 = @as(u32, 404);
pub const MM_MOTU_MXPMPU_MIDIIN_5 = @as(u32, 405);
pub const MM_MOTU_MXPMPU_MIDIOUT_5 = @as(u32, 405);
pub const MM_MOTU_MXPMPU_MIDIIN_6 = @as(u32, 406);
pub const MM_MOTU_MXPMPU_MIDIOUT_6 = @as(u32, 406);
pub const MM_MOTU_MXN_MIDIOUT_ALL = @as(u32, 500);
pub const MM_MOTU_MXN_MIDIIN_SYNC = @as(u32, 500);
pub const MM_MOTU_MXN_MIDIIN_1 = @as(u32, 501);
pub const MM_MOTU_MXN_MIDIOUT_1 = @as(u32, 501);
pub const MM_MOTU_MXN_MIDIIN_2 = @as(u32, 502);
pub const MM_MOTU_MXN_MIDIOUT_2 = @as(u32, 502);
pub const MM_MOTU_MXN_MIDIIN_3 = @as(u32, 503);
pub const MM_MOTU_MXN_MIDIOUT_3 = @as(u32, 503);
pub const MM_MOTU_MXN_MIDIIN_4 = @as(u32, 504);
pub const MM_MOTU_MXN_MIDIOUT_4 = @as(u32, 504);
pub const MM_MOTU_FLYER_MIDI_IN_SYNC = @as(u32, 600);
pub const MM_MOTU_FLYER_MIDI_IN_A = @as(u32, 601);
pub const MM_MOTU_FLYER_MIDI_OUT_A = @as(u32, 601);
pub const MM_MOTU_FLYER_MIDI_IN_B = @as(u32, 602);
pub const MM_MOTU_FLYER_MIDI_OUT_B = @as(u32, 602);
pub const MM_MOTU_PKX_MIDI_IN_SYNC = @as(u32, 700);
pub const MM_MOTU_PKX_MIDI_IN_A = @as(u32, 701);
pub const MM_MOTU_PKX_MIDI_OUT_A = @as(u32, 701);
pub const MM_MOTU_PKX_MIDI_IN_B = @as(u32, 702);
pub const MM_MOTU_PKX_MIDI_OUT_B = @as(u32, 702);
pub const MM_MOTU_DTX_MIDI_IN_SYNC = @as(u32, 800);
pub const MM_MOTU_DTX_MIDI_IN_A = @as(u32, 801);
pub const MM_MOTU_DTX_MIDI_OUT_A = @as(u32, 801);
pub const MM_MOTU_DTX_MIDI_IN_B = @as(u32, 802);
pub const MM_MOTU_DTX_MIDI_OUT_B = @as(u32, 802);
pub const MM_MOTU_MTPAV_MIDIOUT_ALL = @as(u32, 900);
pub const MM_MOTU_MTPAV_MIDIIN_SYNC = @as(u32, 900);
pub const MM_MOTU_MTPAV_MIDIIN_1 = @as(u32, 901);
pub const MM_MOTU_MTPAV_MIDIOUT_1 = @as(u32, 901);
pub const MM_MOTU_MTPAV_MIDIIN_2 = @as(u32, 902);
pub const MM_MOTU_MTPAV_MIDIOUT_2 = @as(u32, 902);
pub const MM_MOTU_MTPAV_MIDIIN_3 = @as(u32, 903);
pub const MM_MOTU_MTPAV_MIDIOUT_3 = @as(u32, 903);
pub const MM_MOTU_MTPAV_MIDIIN_4 = @as(u32, 904);
pub const MM_MOTU_MTPAV_MIDIOUT_4 = @as(u32, 904);
pub const MM_MOTU_MTPAV_MIDIIN_5 = @as(u32, 905);
pub const MM_MOTU_MTPAV_MIDIOUT_5 = @as(u32, 905);
pub const MM_MOTU_MTPAV_MIDIIN_6 = @as(u32, 906);
pub const MM_MOTU_MTPAV_MIDIOUT_6 = @as(u32, 906);
pub const MM_MOTU_MTPAV_MIDIIN_7 = @as(u32, 907);
pub const MM_MOTU_MTPAV_MIDIOUT_7 = @as(u32, 907);
pub const MM_MOTU_MTPAV_MIDIIN_8 = @as(u32, 908);
pub const MM_MOTU_MTPAV_MIDIOUT_8 = @as(u32, 908);
pub const MM_MOTU_MTPAV_NET_MIDIIN_1 = @as(u32, 909);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_1 = @as(u32, 909);
pub const MM_MOTU_MTPAV_NET_MIDIIN_2 = @as(u32, 910);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_2 = @as(u32, 910);
pub const MM_MOTU_MTPAV_NET_MIDIIN_3 = @as(u32, 911);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_3 = @as(u32, 911);
pub const MM_MOTU_MTPAV_NET_MIDIIN_4 = @as(u32, 912);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_4 = @as(u32, 912);
pub const MM_MOTU_MTPAV_NET_MIDIIN_5 = @as(u32, 913);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_5 = @as(u32, 913);
pub const MM_MOTU_MTPAV_NET_MIDIIN_6 = @as(u32, 914);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_6 = @as(u32, 914);
pub const MM_MOTU_MTPAV_NET_MIDIIN_7 = @as(u32, 915);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_7 = @as(u32, 915);
pub const MM_MOTU_MTPAV_NET_MIDIIN_8 = @as(u32, 916);
pub const MM_MOTU_MTPAV_NET_MIDIOUT_8 = @as(u32, 916);
pub const MM_MOTU_MTPAV_MIDIIN_ADAT = @as(u32, 917);
pub const MM_MOTU_MTPAV_MIDIOUT_ADAT = @as(u32, 917);
pub const MM_MOTU_MXPXT_MIDIIN_SYNC = @as(u32, 1000);
pub const MM_MOTU_MXPXT_MIDIOUT_ALL = @as(u32, 1000);
pub const MM_MOTU_MXPXT_MIDIIN_1 = @as(u32, 1001);
pub const MM_MOTU_MXPXT_MIDIOUT_1 = @as(u32, 1001);
pub const MM_MOTU_MXPXT_MIDIOUT_2 = @as(u32, 1002);
pub const MM_MOTU_MXPXT_MIDIIN_2 = @as(u32, 1002);
pub const MM_MOTU_MXPXT_MIDIIN_3 = @as(u32, 1003);
pub const MM_MOTU_MXPXT_MIDIOUT_3 = @as(u32, 1003);
pub const MM_MOTU_MXPXT_MIDIIN_4 = @as(u32, 1004);
pub const MM_MOTU_MXPXT_MIDIOUT_4 = @as(u32, 1004);
pub const MM_MOTU_MXPXT_MIDIIN_5 = @as(u32, 1005);
pub const MM_MOTU_MXPXT_MIDIOUT_5 = @as(u32, 1005);
pub const MM_MOTU_MXPXT_MIDIOUT_6 = @as(u32, 1006);
pub const MM_MOTU_MXPXT_MIDIIN_6 = @as(u32, 1006);
pub const MM_MOTU_MXPXT_MIDIOUT_7 = @as(u32, 1007);
pub const MM_MOTU_MXPXT_MIDIIN_7 = @as(u32, 1007);
pub const MM_MOTU_MXPXT_MIDIOUT_8 = @as(u32, 1008);
pub const MM_MOTU_MXPXT_MIDIIN_8 = @as(u32, 1008);
pub const MM_WORKBIT_MIXER = @as(u32, 1);
pub const MM_WORKBIT_WAVEOUT = @as(u32, 2);
pub const MM_WORKBIT_WAVEIN = @as(u32, 3);
pub const MM_WORKBIT_MIDIIN = @as(u32, 4);
pub const MM_WORKBIT_MIDIOUT = @as(u32, 5);
pub const MM_WORKBIT_FMSYNTH = @as(u32, 6);
pub const MM_WORKBIT_AUX = @as(u32, 7);
pub const MM_WORKBIT_JOYSTICK = @as(u32, 8);
pub const MM_OSITECH_TRUMPCARD = @as(u32, 1);
pub const MM_MIRO_MOVIEPRO = @as(u32, 1);
pub const MM_MIRO_VIDEOD1 = @as(u32, 2);
pub const MM_MIRO_VIDEODC1TV = @as(u32, 3);
pub const MM_MIRO_VIDEOTD = @as(u32, 4);
pub const MM_MIRO_DC30_WAVEOUT = @as(u32, 5);
pub const MM_MIRO_DC30_WAVEIN = @as(u32, 6);
pub const MM_MIRO_DC30_MIX = @as(u32, 7);
pub const MM_ISOLUTION_PASCAL = @as(u32, 1);
pub const MM_VOICEMIXER = @as(u32, 1);
pub const ROCKWELL_WA1_WAVEIN = @as(u32, 100);
pub const ROCKWELL_WA1_WAVEOUT = @as(u32, 101);
pub const ROCKWELL_WA1_SYNTH = @as(u32, 102);
pub const ROCKWELL_WA1_MIXER = @as(u32, 103);
pub const ROCKWELL_WA1_MPU401_IN = @as(u32, 104);
pub const ROCKWELL_WA1_MPU401_OUT = @as(u32, 105);
pub const ROCKWELL_WA2_WAVEIN = @as(u32, 200);
pub const ROCKWELL_WA2_WAVEOUT = @as(u32, 201);
pub const ROCKWELL_WA2_SYNTH = @as(u32, 202);
pub const ROCKWELL_WA2_MIXER = @as(u32, 203);
pub const ROCKWELL_WA2_MPU401_IN = @as(u32, 204);
pub const ROCKWELL_WA2_MPU401_OUT = @as(u32, 205);
pub const MM_VOXWARE_CODEC = @as(u32, 1);
pub const MM_NORTEL_MPXAC_WAVEIN = @as(u32, 1);
pub const MM_NORTEL_MPXAC_WAVEOUT = @as(u32, 2);
pub const MM_ADDX_PCTV_DIGITALMIX = @as(u32, 1);
pub const MM_ADDX_PCTV_WAVEIN = @as(u32, 2);
pub const MM_ADDX_PCTV_WAVEOUT = @as(u32, 3);
pub const MM_ADDX_PCTV_MIXER = @as(u32, 4);
pub const MM_ADDX_PCTV_AUX_CD = @as(u32, 5);
pub const MM_ADDX_PCTV_AUX_LINE = @as(u32, 6);
pub const MM_WILDCAT_AUTOSCOREMIDIIN = @as(u32, 1);
pub const MM_RHETOREX_WAVEIN = @as(u32, 1);
pub const MM_RHETOREX_WAVEOUT = @as(u32, 2);
pub const MM_BTV_WAVEIN = @as(u32, 1);
pub const MM_BTV_WAVEOUT = @as(u32, 2);
pub const MM_BTV_MIDIIN = @as(u32, 3);
pub const MM_BTV_MIDIOUT = @as(u32, 4);
pub const MM_BTV_MIDISYNTH = @as(u32, 5);
pub const MM_BTV_AUX_LINE = @as(u32, 6);
pub const MM_BTV_AUX_MIC = @as(u32, 7);
pub const MM_BTV_AUX_CD = @as(u32, 8);
pub const MM_BTV_DIGITALIN = @as(u32, 9);
pub const MM_BTV_DIGITALOUT = @as(u32, 10);
pub const MM_BTV_MIDIWAVESTREAM = @as(u32, 11);
pub const MM_BTV_MIXER = @as(u32, 12);
pub const MM_ENSONIQ_SOUNDSCAPE = @as(u32, 16);
pub const MM_SOUNDSCAPE_WAVEOUT = @as(u32, 17);
pub const MM_SOUNDSCAPE_WAVEOUT_AUX = @as(u32, 18);
pub const MM_SOUNDSCAPE_WAVEIN = @as(u32, 19);
pub const MM_SOUNDSCAPE_MIDIOUT = @as(u32, 20);
pub const MM_SOUNDSCAPE_MIDIIN = @as(u32, 21);
pub const MM_SOUNDSCAPE_SYNTH = @as(u32, 22);
pub const MM_SOUNDSCAPE_MIXER = @as(u32, 23);
pub const MM_SOUNDSCAPE_AUX = @as(u32, 24);
pub const MM_NVIDIA_WAVEOUT = @as(u32, 1);
pub const MM_NVIDIA_WAVEIN = @as(u32, 2);
pub const MM_NVIDIA_MIDIOUT = @as(u32, 3);
pub const MM_NVIDIA_MIDIIN = @as(u32, 4);
pub const MM_NVIDIA_GAMEPORT = @as(u32, 5);
pub const MM_NVIDIA_MIXER = @as(u32, 6);
pub const MM_NVIDIA_AUX = @as(u32, 7);
pub const MM_OKSORI_BASE = @as(u32, 0);
pub const MM_OKSORI_OSR8_WAVEOUT = @as(u32, 1);
pub const MM_OKSORI_OSR8_WAVEIN = @as(u32, 2);
pub const MM_OKSORI_OSR16_WAVEOUT = @as(u32, 3);
pub const MM_OKSORI_OSR16_WAVEIN = @as(u32, 4);
pub const MM_OKSORI_FM_OPL4 = @as(u32, 5);
pub const MM_OKSORI_MIX_MASTER = @as(u32, 6);
pub const MM_OKSORI_MIX_WAVE = @as(u32, 7);
pub const MM_OKSORI_MIX_FM = @as(u32, 8);
pub const MM_OKSORI_MIX_LINE = @as(u32, 9);
pub const MM_OKSORI_MIX_CD = @as(u32, 10);
pub const MM_OKSORI_MIX_MIC = @as(u32, 11);
pub const MM_OKSORI_MIX_ECHO = @as(u32, 12);
pub const MM_OKSORI_MIX_AUX1 = @as(u32, 13);
pub const MM_OKSORI_MIX_LINE1 = @as(u32, 14);
pub const MM_OKSORI_EXT_MIC1 = @as(u32, 15);
pub const MM_OKSORI_EXT_MIC2 = @as(u32, 16);
pub const MM_OKSORI_MIDIOUT = @as(u32, 17);
pub const MM_OKSORI_MIDIIN = @as(u32, 18);
pub const MM_OKSORI_MPEG_CDVISION = @as(u32, 19);
pub const MM_DIACOUSTICS_DRUM_ACTION = @as(u32, 1);
pub const MM_KAY_ELEMETRICS_CSL = @as(u32, 17152);
pub const MM_KAY_ELEMETRICS_CSL_DAT = @as(u32, 17160);
pub const MM_KAY_ELEMETRICS_CSL_4CHANNEL = @as(u32, 17161);
pub const MM_CRYSTAL_CS4232_WAVEIN = @as(u32, 1);
pub const MM_CRYSTAL_CS4232_WAVEOUT = @as(u32, 2);
pub const MM_CRYSTAL_CS4232_WAVEMIXER = @as(u32, 3);
pub const MM_CRYSTAL_CS4232_WAVEAUX_AUX1 = @as(u32, 4);
pub const MM_CRYSTAL_CS4232_WAVEAUX_AUX2 = @as(u32, 5);
pub const MM_CRYSTAL_CS4232_WAVEAUX_LINE = @as(u32, 6);
pub const MM_CRYSTAL_CS4232_WAVEAUX_MONO = @as(u32, 7);
pub const MM_CRYSTAL_CS4232_WAVEAUX_MASTER = @as(u32, 8);
pub const MM_CRYSTAL_CS4232_MIDIIN = @as(u32, 9);
pub const MM_CRYSTAL_CS4232_MIDIOUT = @as(u32, 10);
pub const MM_CRYSTAL_CS4232_INPUTGAIN_AUX1 = @as(u32, 13);
pub const MM_CRYSTAL_CS4232_INPUTGAIN_LOOP = @as(u32, 14);
pub const MM_CRYSTAL_SOUND_FUSION_WAVEIN = @as(u32, 21);
pub const MM_CRYSTAL_SOUND_FUSION_WAVEOUT = @as(u32, 22);
pub const MM_CRYSTAL_SOUND_FUSION_MIXER = @as(u32, 23);
pub const MM_CRYSTAL_SOUND_FUSION_MIDIIN = @as(u32, 24);
pub const MM_CRYSTAL_SOUND_FUSION_MIDIOUT = @as(u32, 25);
pub const MM_CRYSTAL_SOUND_FUSION_JOYSTICK = @as(u32, 26);
pub const MM_QUARTERDECK_LHWAVEIN = @as(u32, 0);
pub const MM_QUARTERDECK_LHWAVEOUT = @as(u32, 1);
pub const MM_TDK_MW_MIDI_SYNTH = @as(u32, 1);
pub const MM_TDK_MW_MIDI_IN = @as(u32, 2);
pub const MM_TDK_MW_MIDI_OUT = @as(u32, 3);
pub const MM_TDK_MW_WAVE_IN = @as(u32, 4);
pub const MM_TDK_MW_WAVE_OUT = @as(u32, 5);
pub const MM_TDK_MW_AUX = @as(u32, 6);
pub const MM_TDK_MW_MIXER = @as(u32, 10);
pub const MM_TDK_MW_AUX_MASTER = @as(u32, 100);
pub const MM_TDK_MW_AUX_BASS = @as(u32, 101);
pub const MM_TDK_MW_AUX_TREBLE = @as(u32, 102);
pub const MM_TDK_MW_AUX_MIDI_VOL = @as(u32, 103);
pub const MM_TDK_MW_AUX_WAVE_VOL = @as(u32, 104);
pub const MM_TDK_MW_AUX_WAVE_RVB = @as(u32, 105);
pub const MM_TDK_MW_AUX_WAVE_CHR = @as(u32, 106);
pub const MM_TDK_MW_AUX_VOL = @as(u32, 107);
pub const MM_TDK_MW_AUX_RVB = @as(u32, 108);
pub const MM_TDK_MW_AUX_CHR = @as(u32, 109);
pub const MM_DIGITAL_AUDIO_LABS_TC = @as(u32, 1);
pub const MM_DIGITAL_AUDIO_LABS_DOC = @as(u32, 2);
pub const MM_DIGITAL_AUDIO_LABS_V8 = @as(u32, 16);
pub const MM_DIGITAL_AUDIO_LABS_CPRO = @as(u32, 17);
pub const MM_DIGITAL_AUDIO_LABS_VP = @as(u32, 18);
pub const MM_DIGITAL_AUDIO_LABS_CDLX = @as(u32, 19);
pub const MM_DIGITAL_AUDIO_LABS_CTDIF = @as(u32, 20);
pub const MM_SEERSYS_SEERSYNTH = @as(u32, 1);
pub const MM_SEERSYS_SEERWAVE = @as(u32, 2);
pub const MM_SEERSYS_SEERMIX = @as(u32, 3);
pub const MM_SEERSYS_WAVESYNTH = @as(u32, 4);
pub const MM_SEERSYS_WAVESYNTH_WG = @as(u32, 5);
pub const MM_SEERSYS_REALITY = @as(u32, 6);
pub const MM_OSPREY_1000WAVEIN = @as(u32, 1);
pub const MM_OSPREY_1000WAVEOUT = @as(u32, 2);
pub const MM_SOUNDESIGNS_WAVEIN = @as(u32, 1);
pub const MM_SOUNDESIGNS_WAVEOUT = @as(u32, 2);
pub const MM_SSP_SNDFESWAVEIN = @as(u32, 1);
pub const MM_SSP_SNDFESWAVEOUT = @as(u32, 2);
pub const MM_SSP_SNDFESMIDIIN = @as(u32, 3);
pub const MM_SSP_SNDFESMIDIOUT = @as(u32, 4);
pub const MM_SSP_SNDFESSYNTH = @as(u32, 5);
pub const MM_SSP_SNDFESMIX = @as(u32, 6);
pub const MM_SSP_SNDFESAUX = @as(u32, 7);
pub const MM_ECS_AADF_MIDI_IN = @as(u32, 10);
pub const MM_ECS_AADF_MIDI_OUT = @as(u32, 11);
pub const MM_ECS_AADF_WAVE2MIDI_IN = @as(u32, 12);
pub const MM_AMD_INTERWAVE_WAVEIN = @as(u32, 1);
pub const MM_AMD_INTERWAVE_WAVEOUT = @as(u32, 2);
pub const MM_AMD_INTERWAVE_SYNTH = @as(u32, 3);
pub const MM_AMD_INTERWAVE_MIXER1 = @as(u32, 4);
pub const MM_AMD_INTERWAVE_MIXER2 = @as(u32, 5);
pub const MM_AMD_INTERWAVE_JOYSTICK = @as(u32, 6);
pub const MM_AMD_INTERWAVE_EX_CD = @as(u32, 7);
pub const MM_AMD_INTERWAVE_MIDIIN = @as(u32, 8);
pub const MM_AMD_INTERWAVE_MIDIOUT = @as(u32, 9);
pub const MM_AMD_INTERWAVE_AUX1 = @as(u32, 10);
pub const MM_AMD_INTERWAVE_AUX2 = @as(u32, 11);
pub const MM_AMD_INTERWAVE_AUX_MIC = @as(u32, 12);
pub const MM_AMD_INTERWAVE_AUX_CD = @as(u32, 13);
pub const MM_AMD_INTERWAVE_MONO_IN = @as(u32, 14);
pub const MM_AMD_INTERWAVE_MONO_OUT = @as(u32, 15);
pub const MM_AMD_INTERWAVE_EX_TELEPHONY = @as(u32, 16);
pub const MM_AMD_INTERWAVE_WAVEOUT_BASE = @as(u32, 17);
pub const MM_AMD_INTERWAVE_WAVEOUT_TREBLE = @as(u32, 18);
pub const MM_AMD_INTERWAVE_STEREO_ENHANCED = @as(u32, 19);
pub const MM_COREDYNAMICS_DYNAMIXHR = @as(u32, 1);
pub const MM_COREDYNAMICS_DYNASONIX_SYNTH = @as(u32, 2);
pub const MM_COREDYNAMICS_DYNASONIX_MIDI_IN = @as(u32, 3);
pub const MM_COREDYNAMICS_DYNASONIX_MIDI_OUT = @as(u32, 4);
pub const MM_COREDYNAMICS_DYNASONIX_WAVE_IN = @as(u32, 5);
pub const MM_COREDYNAMICS_DYNASONIX_WAVE_OUT = @as(u32, 6);
pub const MM_COREDYNAMICS_DYNASONIX_AUDIO_IN = @as(u32, 7);
pub const MM_COREDYNAMICS_DYNASONIX_AUDIO_OUT = @as(u32, 8);
pub const MM_COREDYNAMICS_DYNAGRAFX_VGA = @as(u32, 9);
pub const MM_COREDYNAMICS_DYNAGRAFX_WAVE_IN = @as(u32, 10);
pub const MM_COREDYNAMICS_DYNAGRAFX_WAVE_OUT = @as(u32, 11);
pub const MM_CANAM_CBXWAVEOUT = @as(u32, 1);
pub const MM_CANAM_CBXWAVEIN = @as(u32, 2);
pub const MM_SOFTSOUND_CODEC = @as(u32, 1);
pub const MM_NORRIS_VOICELINK = @as(u32, 1);
pub const MM_DDD_MIDILINK_MIDIIN = @as(u32, 1);
pub const MM_DDD_MIDILINK_MIDIOUT = @as(u32, 2);
pub const MM_EUPHONICS_AUX_CD = @as(u32, 1);
pub const MM_EUPHONICS_AUX_LINE = @as(u32, 2);
pub const MM_EUPHONICS_AUX_MASTER = @as(u32, 3);
pub const MM_EUPHONICS_AUX_MIC = @as(u32, 4);
pub const MM_EUPHONICS_AUX_MIDI = @as(u32, 5);
pub const MM_EUPHONICS_AUX_WAVE = @as(u32, 6);
pub const MM_EUPHONICS_FMSYNTH_MONO = @as(u32, 7);
pub const MM_EUPHONICS_FMSYNTH_STEREO = @as(u32, 8);
pub const MM_EUPHONICS_MIDIIN = @as(u32, 9);
pub const MM_EUPHONICS_MIDIOUT = @as(u32, 10);
pub const MM_EUPHONICS_MIXER = @as(u32, 11);
pub const MM_EUPHONICS_WAVEIN = @as(u32, 12);
pub const MM_EUPHONICS_WAVEOUT = @as(u32, 13);
pub const MM_EUPHONICS_EUSYNTH = @as(u32, 14);
pub const CRYSTAL_NET_SFM_CODEC = @as(u32, 1);
pub const MM_CHROMATIC_M1 = @as(u32, 1);
pub const MM_CHROMATIC_M1_WAVEIN = @as(u32, 2);
pub const MM_CHROMATIC_M1_WAVEOUT = @as(u32, 3);
pub const MM_CHROMATIC_M1_FMSYNTH = @as(u32, 4);
pub const MM_CHROMATIC_M1_MIXER = @as(u32, 5);
pub const MM_CHROMATIC_M1_AUX = @as(u32, 6);
pub const MM_CHROMATIC_M1_AUX_CD = @as(u32, 7);
pub const MM_CHROMATIC_M1_MIDIIN = @as(u32, 8);
pub const MM_CHROMATIC_M1_MIDIOUT = @as(u32, 9);
pub const MM_CHROMATIC_M1_WTSYNTH = @as(u32, 16);
pub const MM_CHROMATIC_M1_MPEGWAVEIN = @as(u32, 17);
pub const MM_CHROMATIC_M1_MPEGWAVEOUT = @as(u32, 18);
pub const MM_CHROMATIC_M2 = @as(u32, 19);
pub const MM_CHROMATIC_M2_WAVEIN = @as(u32, 20);
pub const MM_CHROMATIC_M2_WAVEOUT = @as(u32, 21);
pub const MM_CHROMATIC_M2_FMSYNTH = @as(u32, 22);
pub const MM_CHROMATIC_M2_MIXER = @as(u32, 23);
pub const MM_CHROMATIC_M2_AUX = @as(u32, 24);
pub const MM_CHROMATIC_M2_AUX_CD = @as(u32, 25);
pub const MM_CHROMATIC_M2_MIDIIN = @as(u32, 32);
pub const MM_CHROMATIC_M2_MIDIOUT = @as(u32, 33);
pub const MM_CHROMATIC_M2_WTSYNTH = @as(u32, 34);
pub const MM_CHROMATIC_M2_MPEGWAVEIN = @as(u32, 35);
pub const MM_CHROMATIC_M2_MPEGWAVEOUT = @as(u32, 36);
pub const MM_VIENNASYS_TSP_WAVE_DRIVER = @as(u32, 1);
pub const MM_CONNECTIX_VIDEC_CODEC = @as(u32, 1);
pub const MM_GADGETLABS_WAVE44_WAVEIN = @as(u32, 1);
pub const MM_GADGETLABS_WAVE44_WAVEOUT = @as(u32, 2);
pub const MM_GADGETLABS_WAVE42_WAVEIN = @as(u32, 3);
pub const MM_GADGETLABS_WAVE42_WAVEOUT = @as(u32, 4);
pub const MM_GADGETLABS_WAVE4_MIDIIN = @as(u32, 5);
pub const MM_GADGETLABS_WAVE4_MIDIOUT = @as(u32, 6);
pub const MM_FRONTIER_WAVECENTER_MIDIIN = @as(u32, 1);
pub const MM_FRONTIER_WAVECENTER_MIDIOUT = @as(u32, 2);
pub const MM_FRONTIER_WAVECENTER_WAVEIN = @as(u32, 3);
pub const MM_FRONTIER_WAVECENTER_WAVEOUT = @as(u32, 4);
pub const MM_VIONA_QVINPCI_MIXER = @as(u32, 1);
pub const MM_VIONA_QVINPCI_WAVEIN = @as(u32, 2);
pub const MM_VIONAQVINPCI_WAVEOUT = @as(u32, 3);
pub const MM_VIONA_BUSTER_MIXER = @as(u32, 4);
pub const MM_VIONA_CINEMASTER_MIXER = @as(u32, 5);
pub const MM_VIONA_CONCERTO_MIXER = @as(u32, 6);
pub const MM_CASIO_WP150_MIDIOUT = @as(u32, 1);
pub const MM_CASIO_WP150_MIDIIN = @as(u32, 2);
pub const MM_CASIO_LSG_MIDIOUT = @as(u32, 3);
pub const MM_DIMD_PLATFORM = @as(u32, 0);
pub const MM_DIMD_DIRSOUND = @as(u32, 1);
pub const MM_DIMD_VIRTMPU = @as(u32, 2);
pub const MM_DIMD_VIRTSB = @as(u32, 3);
pub const MM_DIMD_VIRTJOY = @as(u32, 4);
pub const MM_DIMD_WAVEIN = @as(u32, 5);
pub const MM_DIMD_WAVEOUT = @as(u32, 6);
pub const MM_DIMD_MIDIIN = @as(u32, 7);
pub const MM_DIMD_MIDIOUT = @as(u32, 8);
pub const MM_DIMD_AUX_LINE = @as(u32, 9);
pub const MM_DIMD_MIXER = @as(u32, 10);
pub const MM_DIMD_WSS_WAVEIN = @as(u32, 14);
pub const MM_DIMD_WSS_WAVEOUT = @as(u32, 15);
pub const MM_DIMD_WSS_MIXER = @as(u32, 17);
pub const MM_DIMD_WSS_AUX = @as(u32, 21);
pub const MM_DIMD_WSS_SYNTH = @as(u32, 76);
pub const MM_S3_WAVEOUT = @as(u32, 1);
pub const MM_S3_WAVEIN = @as(u32, 2);
pub const MM_S3_MIDIOUT = @as(u32, 3);
pub const MM_S3_MIDIIN = @as(u32, 4);
pub const MM_S3_FMSYNTH = @as(u32, 5);
pub const MM_S3_MIXER = @as(u32, 6);
pub const MM_S3_AUX = @as(u32, 7);
pub const MM_VKC_MPU401_MIDIIN = @as(u32, 256);
pub const MM_VKC_SERIAL_MIDIIN = @as(u32, 257);
pub const MM_VKC_MPU401_MIDIOUT = @as(u32, 512);
pub const MM_VKC_SERIAL_MIDIOUT = @as(u32, 513);
pub const MM_ZEFIRO_ZA2 = @as(u32, 2);
pub const MM_FHGIIS_MPEGLAYER3_DECODE = @as(u32, 9);
pub const MM_FHGIIS_MPEGLAYER3 = @as(u32, 10);
pub const MM_FHGIIS_MPEGLAYER3_LITE = @as(u32, 10);
pub const MM_FHGIIS_MPEGLAYER3_BASIC = @as(u32, 11);
pub const MM_FHGIIS_MPEGLAYER3_ADVANCED = @as(u32, 12);
pub const MM_FHGIIS_MPEGLAYER3_PROFESSIONAL = @as(u32, 13);
pub const MM_FHGIIS_MPEGLAYER3_ADVANCEDPLUS = @as(u32, 14);
pub const MM_QUICKNET_PJWAVEIN = @as(u32, 1);
pub const MM_QUICKNET_PJWAVEOUT = @as(u32, 2);
pub const MM_SICRESOURCE_SSO3D = @as(u32, 2);
pub const MM_SICRESOURCE_SSOW3DI = @as(u32, 3);
pub const MM_NEOMAGIC_SYNTH = @as(u32, 1);
pub const MM_NEOMAGIC_WAVEOUT = @as(u32, 2);
pub const MM_NEOMAGIC_WAVEIN = @as(u32, 3);
pub const MM_NEOMAGIC_MIDIOUT = @as(u32, 4);
pub const MM_NEOMAGIC_MIDIIN = @as(u32, 5);
pub const MM_NEOMAGIC_AUX = @as(u32, 6);
pub const MM_NEOMAGIC_MW3DX_WAVEOUT = @as(u32, 10);
pub const MM_NEOMAGIC_MW3DX_WAVEIN = @as(u32, 11);
pub const MM_NEOMAGIC_MW3DX_MIDIOUT = @as(u32, 12);
pub const MM_NEOMAGIC_MW3DX_MIDIIN = @as(u32, 13);
pub const MM_NEOMAGIC_MW3DX_FMSYNTH = @as(u32, 14);
pub const MM_NEOMAGIC_MW3DX_GMSYNTH = @as(u32, 15);
pub const MM_NEOMAGIC_MW3DX_MIXER = @as(u32, 16);
pub const MM_NEOMAGIC_MW3DX_AUX = @as(u32, 17);
pub const MM_NEOMAGIC_MWAVE_WAVEOUT = @as(u32, 20);
pub const MM_NEOMAGIC_MWAVE_WAVEIN = @as(u32, 21);
pub const MM_NEOMAGIC_MWAVE_MIDIOUT = @as(u32, 22);
pub const MM_NEOMAGIC_MWAVE_MIDIIN = @as(u32, 23);
pub const MM_NEOMAGIC_MWAVE_MIXER = @as(u32, 24);
pub const MM_NEOMAGIC_MWAVE_AUX = @as(u32, 25);
pub const MM_MERGING_MPEGL3 = @as(u32, 1);
pub const MM_XIRLINK_VISIONLINK = @as(u32, 1);
pub const MM_OTI_611WAVEIN = @as(u32, 5);
pub const MM_OTI_611WAVEOUT = @as(u32, 6);
pub const MM_OTI_611MIXER = @as(u32, 7);
pub const MM_OTI_611MIDIN = @as(u32, 18);
pub const MM_OTI_611MIDIOUT = @as(u32, 19);
pub const MM_AUREAL_AU8820 = @as(u32, 16);
pub const MM_AU8820_SYNTH = @as(u32, 17);
pub const MM_AU8820_WAVEOUT = @as(u32, 18);
pub const MM_AU8820_WAVEIN = @as(u32, 19);
pub const MM_AU8820_MIXER = @as(u32, 20);
pub const MM_AU8820_AUX = @as(u32, 21);
pub const MM_AU8820_MIDIOUT = @as(u32, 22);
pub const MM_AU8820_MIDIIN = @as(u32, 23);
pub const MM_AUREAL_AU8830 = @as(u32, 32);
pub const MM_AU8830_SYNTH = @as(u32, 33);
pub const MM_AU8830_WAVEOUT = @as(u32, 34);
pub const MM_AU8830_WAVEIN = @as(u32, 35);
pub const MM_AU8830_MIXER = @as(u32, 36);
pub const MM_AU8830_AUX = @as(u32, 37);
pub const MM_AU8830_MIDIOUT = @as(u32, 38);
pub const MM_AU8830_MIDIIN = @as(u32, 39);
pub const MM_VIVO_AUDIO_CODEC = @as(u32, 1);
pub const MM_SHARP_MDC_MIDI_SYNTH = @as(u32, 1);
pub const MM_SHARP_MDC_MIDI_IN = @as(u32, 2);
pub const MM_SHARP_MDC_MIDI_OUT = @as(u32, 3);
pub const MM_SHARP_MDC_WAVE_IN = @as(u32, 4);
pub const MM_SHARP_MDC_WAVE_OUT = @as(u32, 5);
pub const MM_SHARP_MDC_AUX = @as(u32, 6);
pub const MM_SHARP_MDC_MIXER = @as(u32, 10);
pub const MM_SHARP_MDC_AUX_MASTER = @as(u32, 100);
pub const MM_SHARP_MDC_AUX_BASS = @as(u32, 101);
pub const MM_SHARP_MDC_AUX_TREBLE = @as(u32, 102);
pub const MM_SHARP_MDC_AUX_MIDI_VOL = @as(u32, 103);
pub const MM_SHARP_MDC_AUX_WAVE_VOL = @as(u32, 104);
pub const MM_SHARP_MDC_AUX_WAVE_RVB = @as(u32, 105);
pub const MM_SHARP_MDC_AUX_WAVE_CHR = @as(u32, 106);
pub const MM_SHARP_MDC_AUX_VOL = @as(u32, 107);
pub const MM_SHARP_MDC_AUX_RVB = @as(u32, 108);
pub const MM_SHARP_MDC_AUX_CHR = @as(u32, 109);
pub const MM_LUCENT_ACM_G723 = @as(u32, 0);
pub const MM_ATT_G729A = @as(u32, 1);
pub const MM_MARIAN_ARC44WAVEIN = @as(u32, 1);
pub const MM_MARIAN_ARC44WAVEOUT = @as(u32, 2);
pub const MM_MARIAN_PRODIF24WAVEIN = @as(u32, 3);
pub const MM_MARIAN_PRODIF24WAVEOUT = @as(u32, 4);
pub const MM_MARIAN_ARC88WAVEIN = @as(u32, 5);
pub const MM_MARIAN_ARC88WAVEOUT = @as(u32, 6);
pub const MM_BCB_NETBOARD_10 = @as(u32, 1);
pub const MM_BCB_TT75_10 = @as(u32, 2);
pub const MM_MOTIONPIXELS_MVI2 = @as(u32, 1);
pub const MM_QDESIGN_ACM_MPEG = @as(u32, 1);
pub const MM_QDESIGN_ACM_QDESIGN_MUSIC = @as(u32, 2);
pub const MM_NMP_CCP_WAVEIN = @as(u32, 1);
pub const MM_NMP_CCP_WAVEOUT = @as(u32, 2);
pub const MM_NMP_ACM_AMR = @as(u32, 10);
pub const MM_DF_ACM_G726 = @as(u32, 1);
pub const MM_DF_ACM_GSM610 = @as(u32, 2);
pub const MM_BERCOS_WAVEIN = @as(u32, 1);
pub const MM_BERCOS_MIXER = @as(u32, 2);
pub const MM_BERCOS_WAVEOUT = @as(u32, 3);
pub const MM_ONLIVE_MPCODEC = @as(u32, 1);
pub const MM_PHONET_PP_WAVEOUT = @as(u32, 1);
pub const MM_PHONET_PP_WAVEIN = @as(u32, 2);
pub const MM_PHONET_PP_MIXER = @as(u32, 3);
pub const MM_FTR_ENCODER_WAVEIN = @as(u32, 1);
pub const MM_FTR_ACM = @as(u32, 2);
pub const MM_ENET_T2000_LINEIN = @as(u32, 1);
pub const MM_ENET_T2000_LINEOUT = @as(u32, 2);
pub const MM_ENET_T2000_HANDSETIN = @as(u32, 3);
pub const MM_ENET_T2000_HANDSETOUT = @as(u32, 4);
pub const MM_EMAGIC_UNITOR8 = @as(u32, 1);
pub const MM_SIPROLAB_ACELPNET = @as(u32, 1);
pub const MM_DICTAPHONE_G726 = @as(u32, 1);
pub const MM_RZS_ACM_TUBGSM = @as(u32, 1);
pub const MM_EES_PCMIDI14 = @as(u32, 1);
pub const MM_EES_PCMIDI14_IN = @as(u32, 2);
pub const MM_EES_PCMIDI14_OUT1 = @as(u32, 3);
pub const MM_EES_PCMIDI14_OUT2 = @as(u32, 4);
pub const MM_EES_PCMIDI14_OUT3 = @as(u32, 5);
pub const MM_EES_PCMIDI14_OUT4 = @as(u32, 6);
pub const MM_HAFTMANN_LPTDAC2 = @as(u32, 1);
pub const MM_LUCID_PCI24WAVEIN = @as(u32, 1);
pub const MM_LUCID_PCI24WAVEOUT = @as(u32, 2);
pub const MM_HEADSPACE_HAESYNTH = @as(u32, 1);
pub const MM_HEADSPACE_HAEWAVEOUT = @as(u32, 2);
pub const MM_HEADSPACE_HAEWAVEIN = @as(u32, 3);
pub const MM_HEADSPACE_HAEMIXER = @as(u32, 4);
pub const MM_UNISYS_ACM_NAP = @as(u32, 1);
pub const MM_LUMINOSITI_SCWAVEIN = @as(u32, 1);
pub const MM_LUMINOSITI_SCWAVEOUT = @as(u32, 2);
pub const MM_LUMINOSITI_SCWAVEMIX = @as(u32, 3);
pub const MM_ACTIVEVOICE_ACM_VOXADPCM = @as(u32, 1);
pub const MM_DTS_DS = @as(u32, 1);
pub const MM_SOFTLAB_NSK_FRW_WAVEIN = @as(u32, 1);
pub const MM_SOFTLAB_NSK_FRW_WAVEOUT = @as(u32, 2);
pub const MM_SOFTLAB_NSK_FRW_MIXER = @as(u32, 3);
pub const MM_SOFTLAB_NSK_FRW_AUX = @as(u32, 4);
pub const MM_FORTEMEDIA_WAVEIN = @as(u32, 1);
pub const MM_FORTEMEDIA_WAVEOUT = @as(u32, 2);
pub const MM_FORTEMEDIA_FMSYNC = @as(u32, 3);
pub const MM_FORTEMEDIA_MIXER = @as(u32, 4);
pub const MM_FORTEMEDIA_AUX = @as(u32, 5);
pub const MM_SONORUS_STUDIO = @as(u32, 1);
pub const MM_I_LINK_VOICE_CODER = @as(u32, 1);
pub const MM_SELSIUS_SYSTEMS_RTPWAVEOUT = @as(u32, 1);
pub const MM_SELSIUS_SYSTEMS_RTPWAVEIN = @as(u32, 2);
pub const MM_ADMOS_FM_SYNTH = @as(u32, 1);
pub const MM_ADMOS_QS3AMIDIOUT = @as(u32, 2);
pub const MM_ADMOS_QS3AMIDIIN = @as(u32, 3);
pub const MM_ADMOS_QS3AWAVEOUT = @as(u32, 4);
pub const MM_ADMOS_QS3AWAVEIN = @as(u32, 5);
pub const MM_LEXICON_STUDIO_WAVE_OUT = @as(u32, 1);
pub const MM_LEXICON_STUDIO_WAVE_IN = @as(u32, 2);
pub const MM_SGI_320_WAVEIN = @as(u32, 1);
pub const MM_SGI_320_WAVEOUT = @as(u32, 2);
pub const MM_SGI_320_MIXER = @as(u32, 3);
pub const MM_SGI_540_WAVEIN = @as(u32, 4);
pub const MM_SGI_540_WAVEOUT = @as(u32, 5);
pub const MM_SGI_540_MIXER = @as(u32, 6);
pub const MM_SGI_RAD_ADATMONO1_WAVEIN = @as(u32, 7);
pub const MM_SGI_RAD_ADATMONO2_WAVEIN = @as(u32, 8);
pub const MM_SGI_RAD_ADATMONO3_WAVEIN = @as(u32, 9);
pub const MM_SGI_RAD_ADATMONO4_WAVEIN = @as(u32, 10);
pub const MM_SGI_RAD_ADATMONO5_WAVEIN = @as(u32, 11);
pub const MM_SGI_RAD_ADATMONO6_WAVEIN = @as(u32, 12);
pub const MM_SGI_RAD_ADATMONO7_WAVEIN = @as(u32, 13);
pub const MM_SGI_RAD_ADATMONO8_WAVEIN = @as(u32, 14);
pub const MM_SGI_RAD_ADATSTEREO12_WAVEIN = @as(u32, 15);
pub const MM_SGI_RAD_ADATSTEREO34_WAVEIN = @as(u32, 16);
pub const MM_SGI_RAD_ADATSTEREO56_WAVEIN = @as(u32, 17);
pub const MM_SGI_RAD_ADATSTEREO78_WAVEIN = @as(u32, 18);
pub const MM_SGI_RAD_ADAT8CHAN_WAVEIN = @as(u32, 19);
pub const MM_SGI_RAD_ADATMONO1_WAVEOUT = @as(u32, 20);
pub const MM_SGI_RAD_ADATMONO2_WAVEOUT = @as(u32, 21);
pub const MM_SGI_RAD_ADATMONO3_WAVEOUT = @as(u32, 22);
pub const MM_SGI_RAD_ADATMONO4_WAVEOUT = @as(u32, 23);
pub const MM_SGI_RAD_ADATMONO5_WAVEOUT = @as(u32, 24);
pub const MM_SGI_RAD_ADATMONO6_WAVEOUT = @as(u32, 25);
pub const MM_SGI_RAD_ADATMONO7_WAVEOUT = @as(u32, 26);
pub const MM_SGI_RAD_ADATMONO8_WAVEOUT = @as(u32, 27);
pub const MM_SGI_RAD_ADATSTEREO12_WAVEOUT = @as(u32, 28);
pub const MM_SGI_RAD_ADATSTEREO32_WAVEOUT = @as(u32, 29);
pub const MM_SGI_RAD_ADATSTEREO56_WAVEOUT = @as(u32, 30);
pub const MM_SGI_RAD_ADATSTEREO78_WAVEOUT = @as(u32, 31);
pub const MM_SGI_RAD_ADAT8CHAN_WAVEOUT = @as(u32, 32);
pub const MM_SGI_RAD_AESMONO1_WAVEIN = @as(u32, 33);
pub const MM_SGI_RAD_AESMONO2_WAVEIN = @as(u32, 34);
pub const MM_SGI_RAD_AESSTEREO_WAVEIN = @as(u32, 35);
pub const MM_SGI_RAD_AESMONO1_WAVEOUT = @as(u32, 36);
pub const MM_SGI_RAD_AESMONO2_WAVEOUT = @as(u32, 37);
pub const MM_SGI_RAD_AESSTEREO_WAVEOUT = @as(u32, 38);
pub const MM_IPI_ACM_HSX = @as(u32, 1);
pub const MM_IPI_ACM_RPELP = @as(u32, 2);
pub const MM_IPI_WF_ASSS = @as(u32, 3);
pub const MM_IPI_AT_WAVEOUT = @as(u32, 4);
pub const MM_IPI_AT_WAVEIN = @as(u32, 5);
pub const MM_IPI_AT_MIXER = @as(u32, 6);
pub const MM_ICE_WAVEOUT = @as(u32, 1);
pub const MM_ICE_WAVEIN = @as(u32, 2);
pub const MM_ICE_MTWAVEOUT = @as(u32, 3);
pub const MM_ICE_MTWAVEIN = @as(u32, 4);
pub const MM_ICE_MIDIOUT1 = @as(u32, 5);
pub const MM_ICE_MIDIIN1 = @as(u32, 6);
pub const MM_ICE_MIDIOUT2 = @as(u32, 7);
pub const MM_ICE_MIDIIN2 = @as(u32, 8);
pub const MM_ICE_SYNTH = @as(u32, 9);
pub const MM_ICE_MIXER = @as(u32, 10);
pub const MM_ICE_AUX = @as(u32, 11);
pub const MM_VQST_VQC1 = @as(u32, 1);
pub const MM_VQST_VQC2 = @as(u32, 2);
pub const MM_ETEK_KWIKMIDI_MIDIIN = @as(u32, 1);
pub const MM_ETEK_KWIKMIDI_MIDIOUT = @as(u32, 2);
pub const MM_INTERNET_SSW_MIDIOUT = @as(u32, 10);
pub const MM_INTERNET_SSW_MIDIIN = @as(u32, 11);
pub const MM_INTERNET_SSW_WAVEOUT = @as(u32, 12);
pub const MM_INTERNET_SSW_WAVEIN = @as(u32, 13);
pub const MM_SONY_ACM_SCX = @as(u32, 1);
pub const MM_UH_ACM_ADPCM = @as(u32, 1);
pub const MM_SYDEC_NV_WAVEIN = @as(u32, 1);
pub const MM_SYDEC_NV_WAVEOUT = @as(u32, 2);
pub const MM_FLEXION_X300_WAVEIN = @as(u32, 1);
pub const MM_FLEXION_X300_WAVEOUT = @as(u32, 2);
pub const MM_VIA_WAVEOUT = @as(u32, 1);
pub const MM_VIA_WAVEIN = @as(u32, 2);
pub const MM_VIA_MIXER = @as(u32, 3);
pub const MM_VIA_AUX = @as(u32, 4);
pub const MM_VIA_MPU401_MIDIOUT = @as(u32, 5);
pub const MM_VIA_MPU401_MIDIIN = @as(u32, 6);
pub const MM_VIA_SWFM_SYNTH = @as(u32, 7);
pub const MM_VIA_WDM_WAVEOUT = @as(u32, 8);
pub const MM_VIA_WDM_WAVEIN = @as(u32, 9);
pub const MM_VIA_WDM_MIXER = @as(u32, 10);
pub const MM_VIA_WDM_MPU401_MIDIOUT = @as(u32, 11);
pub const MM_VIA_WDM_MPU401_MIDIIN = @as(u32, 12);
pub const MM_MICRONAS_SC4 = @as(u32, 1);
pub const MM_MICRONAS_CLP833 = @as(u32, 2);
pub const MM_HP_WAVEOUT = @as(u32, 1);
pub const MM_HP_WAVEIN = @as(u32, 2);
pub const MM_QUICKAUDIO_MINIMIDI = @as(u32, 1);
pub const MM_QUICKAUDIO_MAXIMIDI = @as(u32, 2);
pub const MM_ICCC_UNA3_WAVEIN = @as(u32, 1);
pub const MM_ICCC_UNA3_WAVEOUT = @as(u32, 2);
pub const MM_ICCC_UNA3_AUX = @as(u32, 3);
pub const MM_ICCC_UNA3_MIXER = @as(u32, 4);
pub const MM_3COM_CB_MIXER = @as(u32, 1);
pub const MM_3COM_CB_WAVEIN = @as(u32, 2);
pub const MM_3COM_CB_WAVEOUT = @as(u32, 3);
pub const MM_MINDMAKER_GC_WAVEIN = @as(u32, 1);
pub const MM_MINDMAKER_GC_WAVEOUT = @as(u32, 2);
pub const MM_MINDMAKER_GC_MIXER = @as(u32, 3);
pub const MM_TELEKOL_WAVEOUT = @as(u32, 1);
pub const MM_TELEKOL_WAVEIN = @as(u32, 2);
pub const MM_ALGOVISION_VB80WAVEOUT = @as(u32, 1);
pub const MM_ALGOVISION_VB80WAVEIN = @as(u32, 2);
pub const MM_ALGOVISION_VB80MIXER = @as(u32, 3);
pub const MM_ALGOVISION_VB80AUX = @as(u32, 4);
pub const MM_ALGOVISION_VB80AUX2 = @as(u32, 5);
pub const WAVE_FORMAT_UNKNOWN = @as(u32, 0);
pub const WAVE_FORMAT_ADPCM = @as(u32, 2);
pub const WAVE_FORMAT_IEEE_FLOAT = @as(u32, 3);
pub const WAVE_FORMAT_VSELP = @as(u32, 4);
pub const WAVE_FORMAT_IBM_CVSD = @as(u32, 5);
pub const WAVE_FORMAT_ALAW = @as(u32, 6);
pub const WAVE_FORMAT_MULAW = @as(u32, 7);
pub const WAVE_FORMAT_DTS = @as(u32, 8);
pub const WAVE_FORMAT_DRM = @as(u32, 9);
pub const WAVE_FORMAT_WMAVOICE9 = @as(u32, 10);
pub const WAVE_FORMAT_WMAVOICE10 = @as(u32, 11);
pub const WAVE_FORMAT_OKI_ADPCM = @as(u32, 16);
pub const WAVE_FORMAT_DVI_ADPCM = @as(u32, 17);
pub const WAVE_FORMAT_MEDIASPACE_ADPCM = @as(u32, 18);
pub const WAVE_FORMAT_SIERRA_ADPCM = @as(u32, 19);
pub const WAVE_FORMAT_G723_ADPCM = @as(u32, 20);
pub const WAVE_FORMAT_DIGISTD = @as(u32, 21);
pub const WAVE_FORMAT_DIGIFIX = @as(u32, 22);
pub const WAVE_FORMAT_DIALOGIC_OKI_ADPCM = @as(u32, 23);
pub const WAVE_FORMAT_MEDIAVISION_ADPCM = @as(u32, 24);
pub const WAVE_FORMAT_CU_CODEC = @as(u32, 25);
pub const WAVE_FORMAT_HP_DYN_VOICE = @as(u32, 26);
pub const WAVE_FORMAT_YAMAHA_ADPCM = @as(u32, 32);
pub const WAVE_FORMAT_SONARC = @as(u32, 33);
pub const WAVE_FORMAT_DSPGROUP_TRUESPEECH = @as(u32, 34);
pub const WAVE_FORMAT_ECHOSC1 = @as(u32, 35);
pub const WAVE_FORMAT_AUDIOFILE_AF36 = @as(u32, 36);
pub const WAVE_FORMAT_APTX = @as(u32, 37);
pub const WAVE_FORMAT_AUDIOFILE_AF10 = @as(u32, 38);
pub const WAVE_FORMAT_PROSODY_1612 = @as(u32, 39);
pub const WAVE_FORMAT_LRC = @as(u32, 40);
pub const WAVE_FORMAT_DOLBY_AC2 = @as(u32, 48);
pub const WAVE_FORMAT_GSM610 = @as(u32, 49);
pub const WAVE_FORMAT_MSNAUDIO = @as(u32, 50);
pub const WAVE_FORMAT_ANTEX_ADPCME = @as(u32, 51);
pub const WAVE_FORMAT_CONTROL_RES_VQLPC = @as(u32, 52);
pub const WAVE_FORMAT_DIGIREAL = @as(u32, 53);
pub const WAVE_FORMAT_DIGIADPCM = @as(u32, 54);
pub const WAVE_FORMAT_CONTROL_RES_CR10 = @as(u32, 55);
pub const WAVE_FORMAT_NMS_VBXADPCM = @as(u32, 56);
pub const WAVE_FORMAT_CS_IMAADPCM = @as(u32, 57);
pub const WAVE_FORMAT_ECHOSC3 = @as(u32, 58);
pub const WAVE_FORMAT_ROCKWELL_ADPCM = @as(u32, 59);
pub const WAVE_FORMAT_ROCKWELL_DIGITALK = @as(u32, 60);
pub const WAVE_FORMAT_XEBEC = @as(u32, 61);
pub const WAVE_FORMAT_G721_ADPCM = @as(u32, 64);
pub const WAVE_FORMAT_G728_CELP = @as(u32, 65);
pub const WAVE_FORMAT_MSG723 = @as(u32, 66);
pub const WAVE_FORMAT_INTEL_G723_1 = @as(u32, 67);
pub const WAVE_FORMAT_INTEL_G729 = @as(u32, 68);
pub const WAVE_FORMAT_SHARP_G726 = @as(u32, 69);
pub const WAVE_FORMAT_MPEG = @as(u32, 80);
pub const WAVE_FORMAT_RT24 = @as(u32, 82);
pub const WAVE_FORMAT_PAC = @as(u32, 83);
pub const WAVE_FORMAT_MPEGLAYER3 = @as(u32, 85);
pub const WAVE_FORMAT_LUCENT_G723 = @as(u32, 89);
pub const WAVE_FORMAT_CIRRUS = @as(u32, 96);
pub const WAVE_FORMAT_ESPCM = @as(u32, 97);
pub const WAVE_FORMAT_VOXWARE = @as(u32, 98);
pub const WAVE_FORMAT_CANOPUS_ATRAC = @as(u32, 99);
pub const WAVE_FORMAT_G726_ADPCM = @as(u32, 100);
pub const WAVE_FORMAT_G722_ADPCM = @as(u32, 101);
pub const WAVE_FORMAT_DSAT = @as(u32, 102);
pub const WAVE_FORMAT_DSAT_DISPLAY = @as(u32, 103);
pub const WAVE_FORMAT_VOXWARE_BYTE_ALIGNED = @as(u32, 105);
pub const WAVE_FORMAT_VOXWARE_AC8 = @as(u32, 112);
pub const WAVE_FORMAT_VOXWARE_AC10 = @as(u32, 113);
pub const WAVE_FORMAT_VOXWARE_AC16 = @as(u32, 114);
pub const WAVE_FORMAT_VOXWARE_AC20 = @as(u32, 115);
pub const WAVE_FORMAT_VOXWARE_RT24 = @as(u32, 116);
pub const WAVE_FORMAT_VOXWARE_RT29 = @as(u32, 117);
pub const WAVE_FORMAT_VOXWARE_RT29HW = @as(u32, 118);
pub const WAVE_FORMAT_VOXWARE_VR12 = @as(u32, 119);
pub const WAVE_FORMAT_VOXWARE_VR18 = @as(u32, 120);
pub const WAVE_FORMAT_VOXWARE_TQ40 = @as(u32, 121);
pub const WAVE_FORMAT_VOXWARE_SC3 = @as(u32, 122);
pub const WAVE_FORMAT_VOXWARE_SC3_1 = @as(u32, 123);
pub const WAVE_FORMAT_SOFTSOUND = @as(u32, 128);
pub const WAVE_FORMAT_VOXWARE_TQ60 = @as(u32, 129);
pub const WAVE_FORMAT_MSRT24 = @as(u32, 130);
pub const WAVE_FORMAT_G729A = @as(u32, 131);
pub const WAVE_FORMAT_MVI_MVI2 = @as(u32, 132);
pub const WAVE_FORMAT_DF_G726 = @as(u32, 133);
pub const WAVE_FORMAT_DF_GSM610 = @as(u32, 134);
pub const WAVE_FORMAT_ISIAUDIO = @as(u32, 136);
pub const WAVE_FORMAT_ONLIVE = @as(u32, 137);
pub const WAVE_FORMAT_MULTITUDE_FT_SX20 = @as(u32, 138);
pub const WAVE_FORMAT_INFOCOM_ITS_G721_ADPCM = @as(u32, 139);
pub const WAVE_FORMAT_CONVEDIA_G729 = @as(u32, 140);
pub const WAVE_FORMAT_CONGRUENCY = @as(u32, 141);
pub const WAVE_FORMAT_SBC24 = @as(u32, 145);
pub const WAVE_FORMAT_DOLBY_AC3_SPDIF = @as(u32, 146);
pub const WAVE_FORMAT_MEDIASONIC_G723 = @as(u32, 147);
pub const WAVE_FORMAT_PROSODY_8KBPS = @as(u32, 148);
pub const WAVE_FORMAT_ZYXEL_ADPCM = @as(u32, 151);
pub const WAVE_FORMAT_PHILIPS_LPCBB = @as(u32, 152);
pub const WAVE_FORMAT_PACKED = @as(u32, 153);
pub const WAVE_FORMAT_MALDEN_PHONYTALK = @as(u32, 160);
pub const WAVE_FORMAT_RACAL_RECORDER_GSM = @as(u32, 161);
pub const WAVE_FORMAT_RACAL_RECORDER_G720_A = @as(u32, 162);
pub const WAVE_FORMAT_RACAL_RECORDER_G723_1 = @as(u32, 163);
pub const WAVE_FORMAT_RACAL_RECORDER_TETRA_ACELP = @as(u32, 164);
pub const WAVE_FORMAT_NEC_AAC = @as(u32, 176);
pub const WAVE_FORMAT_RAW_AAC1 = @as(u32, 255);
pub const WAVE_FORMAT_RHETOREX_ADPCM = @as(u32, 256);
pub const WAVE_FORMAT_IRAT = @as(u32, 257);
pub const WAVE_FORMAT_VIVO_G723 = @as(u32, 273);
pub const WAVE_FORMAT_VIVO_SIREN = @as(u32, 274);
pub const WAVE_FORMAT_PHILIPS_CELP = @as(u32, 288);
pub const WAVE_FORMAT_PHILIPS_GRUNDIG = @as(u32, 289);
pub const WAVE_FORMAT_DIGITAL_G723 = @as(u32, 291);
pub const WAVE_FORMAT_SANYO_LD_ADPCM = @as(u32, 293);
pub const WAVE_FORMAT_SIPROLAB_ACEPLNET = @as(u32, 304);
pub const WAVE_FORMAT_SIPROLAB_ACELP4800 = @as(u32, 305);
pub const WAVE_FORMAT_SIPROLAB_ACELP8V3 = @as(u32, 306);
pub const WAVE_FORMAT_SIPROLAB_G729 = @as(u32, 307);
pub const WAVE_FORMAT_SIPROLAB_G729A = @as(u32, 308);
pub const WAVE_FORMAT_SIPROLAB_KELVIN = @as(u32, 309);
pub const WAVE_FORMAT_VOICEAGE_AMR = @as(u32, 310);
pub const WAVE_FORMAT_G726ADPCM = @as(u32, 320);
pub const WAVE_FORMAT_DICTAPHONE_CELP68 = @as(u32, 321);
pub const WAVE_FORMAT_DICTAPHONE_CELP54 = @as(u32, 322);
pub const WAVE_FORMAT_QUALCOMM_PUREVOICE = @as(u32, 336);
pub const WAVE_FORMAT_QUALCOMM_HALFRATE = @as(u32, 337);
pub const WAVE_FORMAT_TUBGSM = @as(u32, 341);
pub const WAVE_FORMAT_MSAUDIO1 = @as(u32, 352);
pub const WAVE_FORMAT_WMAUDIO2 = @as(u32, 353);
pub const WAVE_FORMAT_WMAUDIO3 = @as(u32, 354);
pub const WAVE_FORMAT_WMAUDIO_LOSSLESS = @as(u32, 355);
pub const WAVE_FORMAT_WMASPDIF = @as(u32, 356);
pub const WAVE_FORMAT_UNISYS_NAP_ADPCM = @as(u32, 368);
pub const WAVE_FORMAT_UNISYS_NAP_ULAW = @as(u32, 369);
pub const WAVE_FORMAT_UNISYS_NAP_ALAW = @as(u32, 370);
pub const WAVE_FORMAT_UNISYS_NAP_16K = @as(u32, 371);
pub const WAVE_FORMAT_SYCOM_ACM_SYC008 = @as(u32, 372);
pub const WAVE_FORMAT_SYCOM_ACM_SYC701_G726L = @as(u32, 373);
pub const WAVE_FORMAT_SYCOM_ACM_SYC701_CELP54 = @as(u32, 374);
pub const WAVE_FORMAT_SYCOM_ACM_SYC701_CELP68 = @as(u32, 375);
pub const WAVE_FORMAT_KNOWLEDGE_ADVENTURE_ADPCM = @as(u32, 376);
pub const WAVE_FORMAT_FRAUNHOFER_IIS_MPEG2_AAC = @as(u32, 384);
pub const WAVE_FORMAT_DTS_DS = @as(u32, 400);
pub const WAVE_FORMAT_CREATIVE_ADPCM = @as(u32, 512);
pub const WAVE_FORMAT_CREATIVE_FASTSPEECH8 = @as(u32, 514);
pub const WAVE_FORMAT_CREATIVE_FASTSPEECH10 = @as(u32, 515);
pub const WAVE_FORMAT_UHER_ADPCM = @as(u32, 528);
pub const WAVE_FORMAT_ULEAD_DV_AUDIO = @as(u32, 533);
pub const WAVE_FORMAT_ULEAD_DV_AUDIO_1 = @as(u32, 534);
pub const WAVE_FORMAT_QUARTERDECK = @as(u32, 544);
pub const WAVE_FORMAT_ILINK_VC = @as(u32, 560);
pub const WAVE_FORMAT_RAW_SPORT = @as(u32, 576);
pub const WAVE_FORMAT_ESST_AC3 = @as(u32, 577);
pub const WAVE_FORMAT_GENERIC_PASSTHRU = @as(u32, 585);
pub const WAVE_FORMAT_IPI_HSX = @as(u32, 592);
pub const WAVE_FORMAT_IPI_RPELP = @as(u32, 593);
pub const WAVE_FORMAT_CS2 = @as(u32, 608);
pub const WAVE_FORMAT_SONY_SCX = @as(u32, 624);
pub const WAVE_FORMAT_SONY_SCY = @as(u32, 625);
pub const WAVE_FORMAT_SONY_ATRAC3 = @as(u32, 626);
pub const WAVE_FORMAT_SONY_SPC = @as(u32, 627);
pub const WAVE_FORMAT_TELUM_AUDIO = @as(u32, 640);
pub const WAVE_FORMAT_TELUM_IA_AUDIO = @as(u32, 641);
pub const WAVE_FORMAT_NORCOM_VOICE_SYSTEMS_ADPCM = @as(u32, 645);
pub const WAVE_FORMAT_FM_TOWNS_SND = @as(u32, 768);
pub const WAVE_FORMAT_MICRONAS = @as(u32, 848);
pub const WAVE_FORMAT_MICRONAS_CELP833 = @as(u32, 849);
pub const WAVE_FORMAT_BTV_DIGITAL = @as(u32, 1024);
pub const WAVE_FORMAT_INTEL_MUSIC_CODER = @as(u32, 1025);
pub const WAVE_FORMAT_INDEO_AUDIO = @as(u32, 1026);
pub const WAVE_FORMAT_QDESIGN_MUSIC = @as(u32, 1104);
pub const WAVE_FORMAT_ON2_VP7_AUDIO = @as(u32, 1280);
pub const WAVE_FORMAT_ON2_VP6_AUDIO = @as(u32, 1281);
pub const WAVE_FORMAT_VME_VMPCM = @as(u32, 1664);
pub const WAVE_FORMAT_TPC = @as(u32, 1665);
pub const WAVE_FORMAT_LIGHTWAVE_LOSSLESS = @as(u32, 2222);
pub const WAVE_FORMAT_OLIGSM = @as(u32, 4096);
pub const WAVE_FORMAT_OLIADPCM = @as(u32, 4097);
pub const WAVE_FORMAT_OLICELP = @as(u32, 4098);
pub const WAVE_FORMAT_OLISBC = @as(u32, 4099);
pub const WAVE_FORMAT_OLIOPR = @as(u32, 4100);
pub const WAVE_FORMAT_LH_CODEC = @as(u32, 4352);
pub const WAVE_FORMAT_LH_CODEC_CELP = @as(u32, 4353);
pub const WAVE_FORMAT_LH_CODEC_SBC8 = @as(u32, 4354);
pub const WAVE_FORMAT_LH_CODEC_SBC12 = @as(u32, 4355);
pub const WAVE_FORMAT_LH_CODEC_SBC16 = @as(u32, 4356);
pub const WAVE_FORMAT_NORRIS = @as(u32, 5120);
pub const WAVE_FORMAT_ISIAUDIO_2 = @as(u32, 5121);
pub const WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS = @as(u32, 5376);
pub const WAVE_FORMAT_MPEG_ADTS_AAC = @as(u32, 5632);
pub const WAVE_FORMAT_MPEG_RAW_AAC = @as(u32, 5633);
pub const WAVE_FORMAT_MPEG_LOAS = @as(u32, 5634);
pub const WAVE_FORMAT_NOKIA_MPEG_ADTS_AAC = @as(u32, 5640);
pub const WAVE_FORMAT_NOKIA_MPEG_RAW_AAC = @as(u32, 5641);
pub const WAVE_FORMAT_VODAFONE_MPEG_ADTS_AAC = @as(u32, 5642);
pub const WAVE_FORMAT_VODAFONE_MPEG_RAW_AAC = @as(u32, 5643);
pub const WAVE_FORMAT_MPEG_HEAAC = @as(u32, 5648);
pub const WAVE_FORMAT_VOXWARE_RT24_SPEECH = @as(u32, 6172);
pub const WAVE_FORMAT_SONICFOUNDRY_LOSSLESS = @as(u32, 6513);
pub const WAVE_FORMAT_INNINGS_TELECOM_ADPCM = @as(u32, 6521);
pub const WAVE_FORMAT_LUCENT_SX8300P = @as(u32, 7175);
pub const WAVE_FORMAT_LUCENT_SX5363S = @as(u32, 7180);
pub const WAVE_FORMAT_CUSEEME = @as(u32, 7939);
pub const WAVE_FORMAT_NTCSOFT_ALF2CM_ACM = @as(u32, 8132);
pub const WAVE_FORMAT_DVM = @as(u32, 8192);
pub const WAVE_FORMAT_DTS2 = @as(u32, 8193);
pub const WAVE_FORMAT_MAKEAVIS = @as(u32, 13075);
pub const WAVE_FORMAT_DIVIO_MPEG4_AAC = @as(u32, 16707);
pub const WAVE_FORMAT_NOKIA_ADAPTIVE_MULTIRATE = @as(u32, 16897);
pub const WAVE_FORMAT_DIVIO_G726 = @as(u32, 16963);
pub const WAVE_FORMAT_LEAD_SPEECH = @as(u32, 17228);
pub const WAVE_FORMAT_LEAD_VORBIS = @as(u32, 22092);
pub const WAVE_FORMAT_WAVPACK_AUDIO = @as(u32, 22358);
pub const WAVE_FORMAT_ALAC = @as(u32, 27745);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_1 = @as(u32, 26447);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_2 = @as(u32, 26448);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_3 = @as(u32, 26449);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_1_PLUS = @as(u32, 26479);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_2_PLUS = @as(u32, 26480);
pub const WAVE_FORMAT_OGG_VORBIS_MODE_3_PLUS = @as(u32, 26481);
pub const WAVE_FORMAT_3COM_NBX = @as(u32, 28672);
pub const WAVE_FORMAT_OPUS = @as(u32, 28751);
pub const WAVE_FORMAT_FAAD_AAC = @as(u32, 28781);
pub const WAVE_FORMAT_AMR_NB = @as(u32, 29537);
pub const WAVE_FORMAT_AMR_WB = @as(u32, 29538);
pub const WAVE_FORMAT_AMR_WP = @as(u32, 29539);
pub const WAVE_FORMAT_GSM_AMR_CBR = @as(u32, 31265);
pub const WAVE_FORMAT_GSM_AMR_VBR_SID = @as(u32, 31266);
pub const WAVE_FORMAT_COMVERSE_INFOSYS_G723_1 = @as(u32, 41216);
pub const WAVE_FORMAT_COMVERSE_INFOSYS_AVQSBC = @as(u32, 41217);
pub const WAVE_FORMAT_COMVERSE_INFOSYS_SBC = @as(u32, 41218);
pub const WAVE_FORMAT_SYMBOL_G729_A = @as(u32, 41219);
pub const WAVE_FORMAT_VOICEAGE_AMR_WB = @as(u32, 41220);
pub const WAVE_FORMAT_INGENIENT_G726 = @as(u32, 41221);
pub const WAVE_FORMAT_MPEG4_AAC = @as(u32, 41222);
pub const WAVE_FORMAT_ENCORE_G726 = @as(u32, 41223);
pub const WAVE_FORMAT_ZOLL_ASAO = @as(u32, 41224);
pub const WAVE_FORMAT_SPEEX_VOICE = @as(u32, 41225);
pub const WAVE_FORMAT_VIANIX_MASC = @as(u32, 41226);
pub const WAVE_FORMAT_WM9_SPECTRUM_ANALYZER = @as(u32, 41227);
pub const WAVE_FORMAT_WMF_SPECTRUM_ANAYZER = @as(u32, 41228);
pub const WAVE_FORMAT_GSM_610 = @as(u32, 41229);
pub const WAVE_FORMAT_GSM_620 = @as(u32, 41230);
pub const WAVE_FORMAT_GSM_660 = @as(u32, 41231);
pub const WAVE_FORMAT_GSM_690 = @as(u32, 41232);
pub const WAVE_FORMAT_GSM_ADAPTIVE_MULTIRATE_WB = @as(u32, 41233);
pub const WAVE_FORMAT_POLYCOM_G722 = @as(u32, 41234);
pub const WAVE_FORMAT_POLYCOM_G728 = @as(u32, 41235);
pub const WAVE_FORMAT_POLYCOM_G729_A = @as(u32, 41236);
pub const WAVE_FORMAT_POLYCOM_SIREN = @as(u32, 41237);
pub const WAVE_FORMAT_GLOBAL_IP_ILBC = @as(u32, 41238);
pub const WAVE_FORMAT_RADIOTIME_TIME_SHIFT_RADIO = @as(u32, 41239);
pub const WAVE_FORMAT_NICE_ACA = @as(u32, 41240);
pub const WAVE_FORMAT_NICE_ADPCM = @as(u32, 41241);
pub const WAVE_FORMAT_VOCORD_G721 = @as(u32, 41242);
pub const WAVE_FORMAT_VOCORD_G726 = @as(u32, 41243);
pub const WAVE_FORMAT_VOCORD_G722_1 = @as(u32, 41244);
pub const WAVE_FORMAT_VOCORD_G728 = @as(u32, 41245);
pub const WAVE_FORMAT_VOCORD_G729 = @as(u32, 41246);
pub const WAVE_FORMAT_VOCORD_G729_A = @as(u32, 41247);
pub const WAVE_FORMAT_VOCORD_G723_1 = @as(u32, 41248);
pub const WAVE_FORMAT_VOCORD_LBC = @as(u32, 41249);
pub const WAVE_FORMAT_NICE_G728 = @as(u32, 41250);
pub const WAVE_FORMAT_FRACE_TELECOM_G729 = @as(u32, 41251);
pub const WAVE_FORMAT_CODIAN = @as(u32, 41252);
pub const WAVE_FORMAT_FLAC = @as(u32, 61868);
pub const WAVE_FORMAT_DEVELOPMENT = @as(u32, 65535);
pub const WAVE_FORMAT_PCM = @as(u32, 1);
pub const ACM_MPEG_LAYER1 = @as(u32, 1);
pub const ACM_MPEG_LAYER2 = @as(u32, 2);
pub const ACM_MPEG_LAYER3 = @as(u32, 4);
pub const ACM_MPEG_STEREO = @as(u32, 1);
pub const ACM_MPEG_JOINTSTEREO = @as(u32, 2);
pub const ACM_MPEG_DUALCHANNEL = @as(u32, 4);
pub const ACM_MPEG_SINGLECHANNEL = @as(u32, 8);
pub const ACM_MPEG_PRIVATEBIT = @as(u32, 1);
pub const ACM_MPEG_COPYRIGHT = @as(u32, 2);
pub const ACM_MPEG_ORIGINALHOME = @as(u32, 4);
pub const ACM_MPEG_PROTECTIONBIT = @as(u32, 8);
pub const ACM_MPEG_ID_MPEG1 = @as(u32, 16);
pub const MPEGLAYER3_WFX_EXTRA_BYTES = @as(u32, 12);
pub const MPEGLAYER3_ID_UNKNOWN = @as(u32, 0);
pub const MPEGLAYER3_ID_MPEG = @as(u32, 1);
pub const MPEGLAYER3_ID_CONSTANTFRAMESIZE = @as(u32, 2);
pub const MM_MSFT_ACM_WMAUDIO = @as(u32, 39);
pub const WMAUDIO_BITS_PER_SAMPLE = @as(u32, 16);
pub const WMAUDIO_MAX_CHANNELS = @as(u32, 2);
pub const MM_MSFT_ACM_MSAUDIO1 = @as(u32, 39);
pub const MM_MSFT_ACM_WMAUDIO2 = @as(u32, 101);
pub const WAVE_FILTER_UNKNOWN = @as(u32, 0);
pub const WAVE_FILTER_DEVELOPMENT = @as(u32, 65535);
pub const WAVE_FILTER_VOLUME = @as(u32, 1);
pub const WAVE_FILTER_ECHO = @as(u32, 2);
pub const JPEG_PROCESS_BASELINE = @as(u32, 0);
pub const AVIIF_CONTROLFRAME = @as(i32, 512);
pub const JIFMK_SOF0 = @as(u32, 65472);
pub const JIFMK_SOF1 = @as(u32, 65473);
pub const JIFMK_SOF2 = @as(u32, 65474);
pub const JIFMK_SOF3 = @as(u32, 65475);
pub const JIFMK_SOF5 = @as(u32, 65477);
pub const JIFMK_SOF6 = @as(u32, 65478);
pub const JIFMK_SOF7 = @as(u32, 65479);
pub const JIFMK_JPG = @as(u32, 65480);
pub const JIFMK_SOF9 = @as(u32, 65481);
pub const JIFMK_SOF10 = @as(u32, 65482);
pub const JIFMK_SOF11 = @as(u32, 65483);
pub const JIFMK_SOF13 = @as(u32, 65485);
pub const JIFMK_SOF14 = @as(u32, 65486);
pub const JIFMK_SOF15 = @as(u32, 65487);
pub const JIFMK_DHT = @as(u32, 65476);
pub const JIFMK_DAC = @as(u32, 65484);
pub const JIFMK_RST0 = @as(u32, 65488);
pub const JIFMK_RST1 = @as(u32, 65489);
pub const JIFMK_RST2 = @as(u32, 65490);
pub const JIFMK_RST3 = @as(u32, 65491);
pub const JIFMK_RST4 = @as(u32, 65492);
pub const JIFMK_RST5 = @as(u32, 65493);
pub const JIFMK_RST6 = @as(u32, 65494);
pub const JIFMK_RST7 = @as(u32, 65495);
pub const JIFMK_SOI = @as(u32, 65496);
pub const JIFMK_EOI = @as(u32, 65497);
pub const JIFMK_SOS = @as(u32, 65498);
pub const JIFMK_DQT = @as(u32, 65499);
pub const JIFMK_DNL = @as(u32, 65500);
pub const JIFMK_DRI = @as(u32, 65501);
pub const JIFMK_DHP = @as(u32, 65502);
pub const JIFMK_EXP = @as(u32, 65503);
pub const JIFMK_APP0 = @as(u32, 65504);
pub const JIFMK_APP1 = @as(u32, 65505);
pub const JIFMK_APP2 = @as(u32, 65506);
pub const JIFMK_APP3 = @as(u32, 65507);
pub const JIFMK_APP4 = @as(u32, 65508);
pub const JIFMK_APP5 = @as(u32, 65509);
pub const JIFMK_APP6 = @as(u32, 65510);
pub const JIFMK_APP7 = @as(u32, 65511);
pub const JIFMK_JPG0 = @as(u32, 65520);
pub const JIFMK_JPG1 = @as(u32, 65521);
pub const JIFMK_JPG2 = @as(u32, 65522);
pub const JIFMK_JPG3 = @as(u32, 65523);
pub const JIFMK_JPG4 = @as(u32, 65524);
pub const JIFMK_JPG5 = @as(u32, 65525);
pub const JIFMK_JPG6 = @as(u32, 65526);
pub const JIFMK_JPG7 = @as(u32, 65527);
pub const JIFMK_JPG8 = @as(u32, 65528);
pub const JIFMK_JPG9 = @as(u32, 65529);
pub const JIFMK_JPG10 = @as(u32, 65530);
pub const JIFMK_JPG11 = @as(u32, 65531);
pub const JIFMK_JPG12 = @as(u32, 65532);
pub const JIFMK_JPG13 = @as(u32, 65533);
pub const JIFMK_COM = @as(u32, 65534);
pub const JIFMK_TEM = @as(u32, 65281);
pub const JIFMK_RES = @as(u32, 65282);
pub const JIFMK_00 = @as(u32, 65280);
pub const JIFMK_FF = @as(u32, 65535);
pub const JPEG_Y = @as(u32, 1);
pub const JPEG_YCbCr = @as(u32, 2);
pub const JPEG_RGB = @as(u32, 3);
pub const MIXERCONTROL_CONTROLTYPE_SRS_MTS = @as(u32, 536936454);
pub const MIXERCONTROL_CONTROLTYPE_SRS_ONOFF = @as(u32, 536936455);
pub const MIXERCONTROL_CONTROLTYPE_SRS_SYNTHSELECT = @as(u32, 536936456);
pub const SND_SYNC = @as(u32, 0);
pub const SND_ASYNC = @as(u32, 1);
pub const SND_NODEFAULT = @as(u32, 2);
pub const SND_MEMORY = @as(u32, 4);
pub const SND_LOOP = @as(u32, 8);
pub const SND_NOSTOP = @as(u32, 16);
pub const SND_NOWAIT = @as(i32, 8192);
pub const SND_ALIAS = @as(i32, 65536);
pub const SND_ALIAS_ID = @as(i32, 1114112);
pub const SND_FILENAME = @as(i32, 131072);
pub const SND_RESOURCE = @as(i32, 262148);
pub const SND_PURGE = @as(u32, 64);
pub const SND_APPLICATION = @as(u32, 128);
pub const SND_SENTRY = @as(i32, 524288);
pub const SND_RING = @as(i32, 1048576);
pub const SND_SYSTEM = @as(i32, 2097152);
pub const SND_ALIAS_START = @as(u32, 0);
pub const MAXPNAMELEN = @as(u32, 32);
pub const MAXERRORLENGTH = @as(u32, 256);
pub const TIME_MS = @as(u32, 1);
pub const TIME_SAMPLES = @as(u32, 2);
pub const TIME_BYTES = @as(u32, 4);
pub const TIME_SMPTE = @as(u32, 8);
pub const TIME_MIDI = @as(u32, 16);
pub const TIME_TICKS = @as(u32, 32);
pub const MM_JOY1MOVE = @as(u32, 928);
pub const MM_JOY2MOVE = @as(u32, 929);
pub const MM_JOY1ZMOVE = @as(u32, 930);
pub const MM_JOY2ZMOVE = @as(u32, 931);
pub const MM_JOY1BUTTONDOWN = @as(u32, 949);
pub const MM_JOY2BUTTONDOWN = @as(u32, 950);
pub const MM_JOY1BUTTONUP = @as(u32, 951);
pub const MM_JOY2BUTTONUP = @as(u32, 952);
pub const MM_MCINOTIFY = @as(u32, 953);
pub const MM_WOM_OPEN = @as(u32, 955);
pub const MM_WOM_CLOSE = @as(u32, 956);
pub const MM_WOM_DONE = @as(u32, 957);
pub const MM_WIM_OPEN = @as(u32, 958);
pub const MM_WIM_CLOSE = @as(u32, 959);
pub const MM_WIM_DATA = @as(u32, 960);
pub const MM_MIM_OPEN = @as(u32, 961);
pub const MM_MIM_CLOSE = @as(u32, 962);
pub const MM_MIM_DATA = @as(u32, 963);
pub const MM_MIM_LONGDATA = @as(u32, 964);
pub const MM_MIM_ERROR = @as(u32, 965);
pub const MM_MIM_LONGERROR = @as(u32, 966);
pub const MM_MOM_OPEN = @as(u32, 967);
pub const MM_MOM_CLOSE = @as(u32, 968);
pub const MM_MOM_DONE = @as(u32, 969);
pub const MM_STREAM_OPEN = @as(u32, 980);
pub const MM_STREAM_CLOSE = @as(u32, 981);
pub const MM_STREAM_DONE = @as(u32, 982);
pub const MM_STREAM_ERROR = @as(u32, 983);
pub const MM_MOM_POSITIONCB = @as(u32, 970);
pub const MM_MIM_MOREDATA = @as(u32, 972);
pub const MM_MIXM_LINE_CHANGE = @as(u32, 976);
pub const MM_MIXM_CONTROL_CHANGE = @as(u32, 977);
pub const MMSYSERR_BASE = @as(u32, 0);
pub const WAVERR_BASE = @as(u32, 32);
pub const MIDIERR_BASE = @as(u32, 64);
pub const TIMERR_BASE = @as(u32, 96);
pub const JOYERR_BASE = @as(u32, 160);
pub const MCIERR_BASE = @as(u32, 256);
pub const MIXERR_BASE = @as(u32, 1024);
pub const MCI_STRING_OFFSET = @as(u32, 512);
pub const MCI_VD_OFFSET = @as(u32, 1024);
pub const MCI_CD_OFFSET = @as(u32, 1088);
pub const MCI_WAVE_OFFSET = @as(u32, 1152);
pub const MCI_SEQ_OFFSET = @as(u32, 1216);
pub const MMSYSERR_NOERROR = @as(u32, 0);
pub const MMSYSERR_ERROR = @as(u32, 1);
pub const MMSYSERR_BADDEVICEID = @as(u32, 2);
pub const MMSYSERR_NOTENABLED = @as(u32, 3);
pub const MMSYSERR_ALLOCATED = @as(u32, 4);
pub const MMSYSERR_INVALHANDLE = @as(u32, 5);
pub const MMSYSERR_NODRIVER = @as(u32, 6);
pub const MMSYSERR_NOMEM = @as(u32, 7);
pub const MMSYSERR_NOTSUPPORTED = @as(u32, 8);
pub const MMSYSERR_BADERRNUM = @as(u32, 9);
pub const MMSYSERR_INVALFLAG = @as(u32, 10);
pub const MMSYSERR_INVALPARAM = @as(u32, 11);
pub const MMSYSERR_HANDLEBUSY = @as(u32, 12);
pub const MMSYSERR_INVALIDALIAS = @as(u32, 13);
pub const MMSYSERR_BADDB = @as(u32, 14);
pub const MMSYSERR_KEYNOTFOUND = @as(u32, 15);
pub const MMSYSERR_READERROR = @as(u32, 16);
pub const MMSYSERR_WRITEERROR = @as(u32, 17);
pub const MMSYSERR_DELETEERROR = @as(u32, 18);
pub const MMSYSERR_VALNOTFOUND = @as(u32, 19);
pub const MMSYSERR_NODRIVERCB = @as(u32, 20);
pub const MMSYSERR_MOREDATA = @as(u32, 21);
pub const MMSYSERR_LASTERROR = @as(u32, 21);
pub const VP_COMMAND_GET = @as(u32, 1);
pub const VP_COMMAND_SET = @as(u32, 2);
pub const VP_FLAGS_TV_MODE = @as(u32, 1);
pub const VP_FLAGS_TV_STANDARD = @as(u32, 2);
pub const VP_FLAGS_FLICKER = @as(u32, 4);
pub const VP_FLAGS_OVERSCAN = @as(u32, 8);
pub const VP_FLAGS_MAX_UNSCALED = @as(u32, 16);
pub const VP_FLAGS_POSITION = @as(u32, 32);
pub const VP_FLAGS_BRIGHTNESS = @as(u32, 64);
pub const VP_FLAGS_CONTRAST = @as(u32, 128);
pub const VP_FLAGS_COPYPROTECT = @as(u32, 256);
pub const VP_MODE_WIN_GRAPHICS = @as(u32, 1);
pub const VP_MODE_TV_PLAYBACK = @as(u32, 2);
pub const VP_TV_STANDARD_NTSC_M = @as(u32, 1);
pub const VP_TV_STANDARD_NTSC_M_J = @as(u32, 2);
pub const VP_TV_STANDARD_PAL_B = @as(u32, 4);
pub const VP_TV_STANDARD_PAL_D = @as(u32, 8);
pub const VP_TV_STANDARD_PAL_H = @as(u32, 16);
pub const VP_TV_STANDARD_PAL_I = @as(u32, 32);
pub const VP_TV_STANDARD_PAL_M = @as(u32, 64);
pub const VP_TV_STANDARD_PAL_N = @as(u32, 128);
pub const VP_TV_STANDARD_SECAM_B = @as(u32, 256);
pub const VP_TV_STANDARD_SECAM_D = @as(u32, 512);
pub const VP_TV_STANDARD_SECAM_G = @as(u32, 1024);
pub const VP_TV_STANDARD_SECAM_H = @as(u32, 2048);
pub const VP_TV_STANDARD_SECAM_K = @as(u32, 4096);
pub const VP_TV_STANDARD_SECAM_K1 = @as(u32, 8192);
pub const VP_TV_STANDARD_SECAM_L = @as(u32, 16384);
pub const VP_TV_STANDARD_WIN_VGA = @as(u32, 32768);
pub const VP_TV_STANDARD_NTSC_433 = @as(u32, 65536);
pub const VP_TV_STANDARD_PAL_G = @as(u32, 131072);
pub const VP_TV_STANDARD_PAL_60 = @as(u32, 262144);
pub const VP_TV_STANDARD_SECAM_L1 = @as(u32, 524288);
pub const VP_CP_TYPE_APS_TRIGGER = @as(u32, 1);
pub const VP_CP_TYPE_MACROVISION = @as(u32, 2);
pub const VP_CP_CMD_ACTIVATE = @as(u32, 1);
pub const VP_CP_CMD_DEACTIVATE = @as(u32, 2);
pub const VP_CP_CMD_CHANGE = @as(u32, 4);
pub const DRV_MAPPER_PREFERRED_INPUT_GET = @as(u32, 16384);
pub const DRV_MAPPER_PREFERRED_OUTPUT_GET = @as(u32, 16386);
pub const DRVM_MAPPER = @as(u32, 8192);
pub const DRVM_MAPPER_STATUS = @as(u32, 8192);
pub const WIDM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEIN_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEIN_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEIN_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const WODM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEOUT_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEOUT_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEOUT_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const ACMERR_BASE = @as(u32, 512);
pub const ACMERR_NOTPOSSIBLE = @as(u32, 512);
pub const ACMERR_BUSY = @as(u32, 513);
pub const ACMERR_UNPREPARED = @as(u32, 514);
pub const ACMERR_CANCELED = @as(u32, 515);
pub const ACM_METRIC_COUNT_DRIVERS = @as(u32, 1);
pub const ACM_METRIC_COUNT_CODECS = @as(u32, 2);
pub const ACM_METRIC_COUNT_CONVERTERS = @as(u32, 3);
pub const ACM_METRIC_COUNT_FILTERS = @as(u32, 4);
pub const ACM_METRIC_COUNT_DISABLED = @as(u32, 5);
pub const ACM_METRIC_COUNT_HARDWARE = @as(u32, 6);
pub const ACM_METRIC_COUNT_LOCAL_DRIVERS = @as(u32, 20);
pub const ACM_METRIC_COUNT_LOCAL_CODECS = @as(u32, 21);
pub const ACM_METRIC_COUNT_LOCAL_CONVERTERS = @as(u32, 22);
pub const ACM_METRIC_COUNT_LOCAL_FILTERS = @as(u32, 23);
pub const ACM_METRIC_COUNT_LOCAL_DISABLED = @as(u32, 24);
pub const ACM_METRIC_HARDWARE_WAVE_INPUT = @as(u32, 30);
pub const ACM_METRIC_HARDWARE_WAVE_OUTPUT = @as(u32, 31);
pub const ACM_METRIC_MAX_SIZE_FORMAT = @as(u32, 50);
pub const ACM_METRIC_MAX_SIZE_FILTER = @as(u32, 51);
pub const ACM_METRIC_DRIVER_SUPPORT = @as(u32, 100);
pub const ACM_METRIC_DRIVER_PRIORITY = @as(u32, 101);
pub const ACM_DRIVERENUMF_NOLOCAL = @as(i32, 1073741824);
pub const ACM_DRIVERENUMF_DISABLED = @as(i32, -2147483648);
pub const ACM_DRIVERADDF_NAME = @as(i32, 1);
pub const ACM_DRIVERADDF_FUNCTION = @as(i32, 3);
pub const ACM_DRIVERADDF_NOTIFYHWND = @as(i32, 4);
pub const ACM_DRIVERADDF_TYPEMASK = @as(i32, 7);
pub const ACM_DRIVERADDF_LOCAL = @as(i32, 0);
pub const ACM_DRIVERADDF_GLOBAL = @as(i32, 8);
pub const ACMDM_USER = @as(u32, 16384);
pub const ACMDM_RESERVED_LOW = @as(u32, 24576);
pub const ACMDM_RESERVED_HIGH = @as(u32, 28671);
pub const ACMDM_DRIVER_ABOUT = @as(u32, 24587);
pub const ACM_DRIVERPRIORITYF_ENABLE = @as(i32, 1);
pub const ACM_DRIVERPRIORITYF_DISABLE = @as(i32, 2);
pub const ACM_DRIVERPRIORITYF_ABLEMASK = @as(i32, 3);
pub const ACM_DRIVERPRIORITYF_BEGIN = @as(i32, 65536);
pub const ACM_DRIVERPRIORITYF_END = @as(i32, 131072);
pub const ACM_DRIVERPRIORITYF_DEFERMASK = @as(i32, 196608);
pub const ACMDRIVERDETAILS_SHORTNAME_CHARS = @as(u32, 32);
pub const ACMDRIVERDETAILS_LONGNAME_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_COPYRIGHT_CHARS = @as(u32, 80);
pub const ACMDRIVERDETAILS_LICENSING_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_FEATURES_CHARS = @as(u32, 512);
pub const ACMDRIVERDETAILS_SUPPORTF_CODEC = @as(i32, 1);
pub const ACMDRIVERDETAILS_SUPPORTF_CONVERTER = @as(i32, 2);
pub const ACMDRIVERDETAILS_SUPPORTF_FILTER = @as(i32, 4);
pub const ACMDRIVERDETAILS_SUPPORTF_HARDWARE = @as(i32, 8);
pub const ACMDRIVERDETAILS_SUPPORTF_ASYNC = @as(i32, 16);
pub const ACMDRIVERDETAILS_SUPPORTF_LOCAL = @as(i32, 1073741824);
pub const ACMDRIVERDETAILS_SUPPORTF_DISABLED = @as(i32, -2147483648);
pub const ACMFORMATTAGDETAILS_FORMATTAG_CHARS = @as(u32, 48);
pub const ACM_FORMATTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATTAGDETAILSF_FORMATTAG = @as(i32, 1);
pub const ACM_FORMATTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FORMATTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFORMATDETAILS_FORMAT_CHARS = @as(u32, 128);
pub const ACM_FORMATDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATDETAILSF_FORMAT = @as(i32, 1);
pub const ACM_FORMATDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FORMATENUMF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATENUMF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATENUMF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATENUMF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATENUMF_CONVERT = @as(i32, 1048576);
pub const ACM_FORMATENUMF_SUGGEST = @as(i32, 2097152);
pub const ACM_FORMATENUMF_HARDWARE = @as(i32, 4194304);
pub const ACM_FORMATENUMF_INPUT = @as(i32, 8388608);
pub const ACM_FORMATENUMF_OUTPUT = @as(i32, 16777216);
pub const ACM_FORMATSUGGESTF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATSUGGESTF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATSUGGESTF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATSUGGESTF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATSUGGESTF_TYPEMASK = @as(i32, 16711680);
pub const MM_ACM_FORMATCHOOSE = @as(u32, 32768);
pub const FORMATCHOOSE_MESSAGE = @as(u32, 0);
pub const FORMATCHOOSE_FORMATTAG_VERIFY = @as(u32, 0);
pub const FORMATCHOOSE_FORMAT_VERIFY = @as(u32, 1);
pub const FORMATCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFORMATCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFORMATCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT = @as(i32, 64);
pub const ACMFORMATCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMFILTERTAGDETAILS_FILTERTAG_CHARS = @as(u32, 48);
pub const ACM_FILTERTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERTAGDETAILSF_FILTERTAG = @as(i32, 1);
pub const ACM_FILTERTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FILTERTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFILTERDETAILS_FILTER_CHARS = @as(u32, 128);
pub const ACM_FILTERDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERDETAILSF_FILTER = @as(i32, 1);
pub const ACM_FILTERDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FILTERENUMF_DWFILTERTAG = @as(i32, 65536);
pub const MM_ACM_FILTERCHOOSE = @as(u32, 32768);
pub const FILTERCHOOSE_MESSAGE = @as(u32, 0);
pub const FILTERCHOOSE_FILTERTAG_VERIFY = @as(u32, 0);
pub const FILTERCHOOSE_FILTER_VERIFY = @as(u32, 1);
pub const FILTERCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFILTERCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFILTERCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT = @as(i32, 64);
pub const ACMFILTERCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMSTREAMHEADER_STATUSF_DONE = @as(i32, 65536);
pub const ACMSTREAMHEADER_STATUSF_PREPARED = @as(i32, 131072);
pub const ACMSTREAMHEADER_STATUSF_INQUEUE = @as(i32, 1048576);
pub const ACM_STREAMOPENF_QUERY = @as(u32, 1);
pub const ACM_STREAMOPENF_ASYNC = @as(u32, 2);
pub const ACM_STREAMOPENF_NONREALTIME = @as(u32, 4);
pub const ACM_STREAMSIZEF_SOURCE = @as(i32, 0);
pub const ACM_STREAMSIZEF_DESTINATION = @as(i32, 1);
pub const ACM_STREAMSIZEF_QUERYMASK = @as(i32, 15);
pub const ACM_STREAMCONVERTF_BLOCKALIGN = @as(u32, 4);
pub const ACM_STREAMCONVERTF_START = @as(u32, 16);
pub const ACM_STREAMCONVERTF_END = @as(u32, 32);
pub const WAVERR_BADFORMAT = @as(u32, 32);
pub const WAVERR_STILLPLAYING = @as(u32, 33);
pub const WAVERR_UNPREPARED = @as(u32, 34);
pub const WAVERR_SYNC = @as(u32, 35);
pub const WAVERR_LASTERROR = @as(u32, 35);
pub const WHDR_DONE = @as(u32, 1);
pub const WHDR_PREPARED = @as(u32, 2);
pub const WHDR_BEGINLOOP = @as(u32, 4);
pub const WHDR_ENDLOOP = @as(u32, 8);
pub const WHDR_INQUEUE = @as(u32, 16);
pub const WAVECAPS_PITCH = @as(u32, 1);
pub const WAVECAPS_PLAYBACKRATE = @as(u32, 2);
pub const WAVECAPS_VOLUME = @as(u32, 4);
pub const WAVECAPS_LRVOLUME = @as(u32, 8);
pub const WAVECAPS_SYNC = @as(u32, 16);
pub const WAVECAPS_SAMPLEACCURATE = @as(u32, 32);
pub const WAVE_INVALIDFORMAT = @as(u32, 0);
pub const WAVE_FORMAT_1M08 = @as(u32, 1);
pub const WAVE_FORMAT_1S08 = @as(u32, 2);
pub const WAVE_FORMAT_1M16 = @as(u32, 4);
pub const WAVE_FORMAT_1S16 = @as(u32, 8);
pub const WAVE_FORMAT_2M08 = @as(u32, 16);
pub const WAVE_FORMAT_2S08 = @as(u32, 32);
pub const WAVE_FORMAT_2M16 = @as(u32, 64);
pub const WAVE_FORMAT_2S16 = @as(u32, 128);
pub const WAVE_FORMAT_4M08 = @as(u32, 256);
pub const WAVE_FORMAT_4S08 = @as(u32, 512);
pub const WAVE_FORMAT_4M16 = @as(u32, 1024);
pub const WAVE_FORMAT_4S16 = @as(u32, 2048);
pub const WAVE_FORMAT_44M08 = @as(u32, 256);
pub const WAVE_FORMAT_44S08 = @as(u32, 512);
pub const WAVE_FORMAT_44M16 = @as(u32, 1024);
pub const WAVE_FORMAT_44S16 = @as(u32, 2048);
pub const WAVE_FORMAT_48M08 = @as(u32, 4096);
pub const WAVE_FORMAT_48S08 = @as(u32, 8192);
pub const WAVE_FORMAT_48M16 = @as(u32, 16384);
pub const WAVE_FORMAT_48S16 = @as(u32, 32768);
pub const WAVE_FORMAT_96M08 = @as(u32, 65536);
pub const WAVE_FORMAT_96S08 = @as(u32, 131072);
pub const WAVE_FORMAT_96M16 = @as(u32, 262144);
pub const WAVE_FORMAT_96S16 = @as(u32, 524288);
pub const MIDIERR_UNPREPARED = @as(u32, 64);
pub const MIDIERR_STILLPLAYING = @as(u32, 65);
pub const MIDIERR_NOMAP = @as(u32, 66);
pub const MIDIERR_NOTREADY = @as(u32, 67);
pub const MIDIERR_NODEVICE = @as(u32, 68);
pub const MIDIERR_INVALIDSETUP = @as(u32, 69);
pub const MIDIERR_BADOPENMODE = @as(u32, 70);
pub const MIDIERR_DONT_CONTINUE = @as(u32, 71);
pub const MIDIERR_LASTERROR = @as(u32, 71);
pub const MIDIPATCHSIZE = @as(u32, 128);
pub const MIDI_CACHE_ALL = @as(u32, 1);
pub const MIDI_CACHE_BESTFIT = @as(u32, 2);
pub const MIDI_CACHE_QUERY = @as(u32, 3);
pub const MIDI_UNCACHE = @as(u32, 4);
pub const MOD_MIDIPORT = @as(u32, 1);
pub const MOD_SYNTH = @as(u32, 2);
pub const MOD_SQSYNTH = @as(u32, 3);
pub const MOD_FMSYNTH = @as(u32, 4);
pub const MOD_MAPPER = @as(u32, 5);
pub const MOD_WAVETABLE = @as(u32, 6);
pub const MOD_SWSYNTH = @as(u32, 7);
pub const MIDICAPS_VOLUME = @as(u32, 1);
pub const MIDICAPS_LRVOLUME = @as(u32, 2);
pub const MIDICAPS_CACHE = @as(u32, 4);
pub const MIDICAPS_STREAM = @as(u32, 8);
pub const MHDR_DONE = @as(u32, 1);
pub const MHDR_PREPARED = @as(u32, 2);
pub const MHDR_INQUEUE = @as(u32, 4);
pub const MHDR_ISSTRM = @as(u32, 8);
pub const MEVT_F_SHORT = @as(i32, 0);
pub const MEVT_F_LONG = @as(i32, -2147483648);
pub const MEVT_F_CALLBACK = @as(i32, 1073741824);
pub const MIDISTRM_ERROR = @as(i32, -2);
pub const MIDIPROP_SET = @as(i32, -2147483648);
pub const MIDIPROP_GET = @as(i32, 1073741824);
pub const MIDIPROP_TIMEDIV = @as(i32, 1);
pub const MIDIPROP_TEMPO = @as(i32, 2);
pub const AUXCAPS_CDAUDIO = @as(u32, 1);
pub const AUXCAPS_AUXIN = @as(u32, 2);
pub const AUXCAPS_VOLUME = @as(u32, 1);
pub const AUXCAPS_LRVOLUME = @as(u32, 2);
pub const MIXER_SHORT_NAME_CHARS = @as(u32, 16);
pub const MIXER_LONG_NAME_CHARS = @as(u32, 64);
pub const MIXERR_INVALLINE = @as(u32, 1024);
pub const MIXERR_INVALCONTROL = @as(u32, 1025);
pub const MIXERR_INVALVALUE = @as(u32, 1026);
pub const MIXERR_LASTERROR = @as(u32, 1026);
pub const MIXER_OBJECTF_HANDLE = @as(i32, -2147483648);
pub const MIXER_OBJECTF_MIXER = @as(i32, 0);
pub const MIXER_OBJECTF_WAVEOUT = @as(i32, 268435456);
pub const MIXER_OBJECTF_WAVEIN = @as(i32, 536870912);
pub const MIXER_OBJECTF_MIDIOUT = @as(i32, 805306368);
pub const MIXER_OBJECTF_MIDIIN = @as(i32, 1073741824);
pub const MIXER_OBJECTF_AUX = @as(i32, 1342177280);
pub const MIXERLINE_LINEF_ACTIVE = @as(i32, 1);
pub const MIXERLINE_LINEF_DISCONNECTED = @as(i32, 32768);
pub const MIXERLINE_LINEF_SOURCE = @as(i32, -2147483648);
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST = @as(i32, 0);
pub const MIXERLINE_COMPONENTTYPE_DST_LAST = @as(u32, 8);
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST = @as(i32, 4096);
pub const MIXERLINE_COMPONENTTYPE_SRC_LAST = @as(u32, 4106);
pub const MIXERLINE_TARGETTYPE_UNDEFINED = @as(u32, 0);
pub const MIXERLINE_TARGETTYPE_WAVEOUT = @as(u32, 1);
pub const MIXERLINE_TARGETTYPE_WAVEIN = @as(u32, 2);
pub const MIXERLINE_TARGETTYPE_MIDIOUT = @as(u32, 3);
pub const MIXERLINE_TARGETTYPE_MIDIIN = @as(u32, 4);
pub const MIXERLINE_TARGETTYPE_AUX = @as(u32, 5);
pub const MIXER_GETLINEINFOF_DESTINATION = @as(i32, 0);
pub const MIXER_GETLINEINFOF_SOURCE = @as(i32, 1);
pub const MIXER_GETLINEINFOF_LINEID = @as(i32, 2);
pub const MIXER_GETLINEINFOF_COMPONENTTYPE = @as(i32, 3);
pub const MIXER_GETLINEINFOF_TARGETTYPE = @as(i32, 4);
pub const MIXER_GETLINEINFOF_QUERYMASK = @as(i32, 15);
pub const MIXERCONTROL_CONTROLF_UNIFORM = @as(i32, 1);
pub const MIXERCONTROL_CONTROLF_MULTIPLE = @as(i32, 2);
pub const MIXERCONTROL_CONTROLF_DISABLED = @as(i32, -2147483648);
pub const MIXERCONTROL_CT_CLASS_MASK = @as(i32, -268435456);
pub const MIXERCONTROL_CT_CLASS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_CLASS_METER = @as(i32, 268435456);
pub const MIXERCONTROL_CT_CLASS_SWITCH = @as(i32, 536870912);
pub const MIXERCONTROL_CT_CLASS_NUMBER = @as(i32, 805306368);
pub const MIXERCONTROL_CT_CLASS_SLIDER = @as(i32, 1073741824);
pub const MIXERCONTROL_CT_CLASS_FADER = @as(i32, 1342177280);
pub const MIXERCONTROL_CT_CLASS_TIME = @as(i32, 1610612736);
pub const MIXERCONTROL_CT_CLASS_LIST = @as(i32, 1879048192);
pub const MIXERCONTROL_CT_SUBCLASS_MASK = @as(i32, 251658240);
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_METER_POLLED = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_LIST_SINGLE = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE = @as(i32, 16777216);
pub const MIXERCONTROL_CT_UNITS_MASK = @as(i32, 16711680);
pub const MIXERCONTROL_CT_UNITS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_UNITS_BOOLEAN = @as(i32, 65536);
pub const MIXERCONTROL_CT_UNITS_SIGNED = @as(i32, 131072);
pub const MIXERCONTROL_CT_UNITS_UNSIGNED = @as(i32, 196608);
pub const MIXERCONTROL_CT_UNITS_DECIBELS = @as(i32, 262144);
pub const MIXERCONTROL_CT_UNITS_PERCENT = @as(i32, 327680);
pub const MIXER_GETLINECONTROLSF_ALL = @as(i32, 0);
pub const MIXER_GETLINECONTROLSF_ONEBYID = @as(i32, 1);
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE = @as(i32, 2);
pub const MIXER_GETLINECONTROLSF_QUERYMASK = @as(i32, 15);
pub const MIXER_GETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT = @as(i32, 1);
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const MIXER_SETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_SETCONTROLDETAILSF_CUSTOM = @as(i32, 1);
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const ICVERSION = @as(u32, 260);
pub const BI_1632 = @as(u32, 842217009);
pub const ICERR_OK = @as(i32, 0);
pub const ICERR_DONTDRAW = @as(i32, 1);
pub const ICERR_NEWPALETTE = @as(i32, 2);
pub const ICERR_GOTOKEYFRAME = @as(i32, 3);
pub const ICERR_STOPDRAWING = @as(i32, 4);
pub const ICERR_UNSUPPORTED = @as(i32, -1);
pub const ICERR_BADFORMAT = @as(i32, -2);
pub const ICERR_MEMORY = @as(i32, -3);
pub const ICERR_INTERNAL = @as(i32, -4);
pub const ICERR_BADFLAGS = @as(i32, -5);
pub const ICERR_BADPARAM = @as(i32, -6);
pub const ICERR_BADSIZE = @as(i32, -7);
pub const ICERR_BADHANDLE = @as(i32, -8);
pub const ICERR_CANTUPDATE = @as(i32, -9);
pub const ICERR_ABORT = @as(i32, -10);
pub const ICERR_ERROR = @as(i32, -100);
pub const ICERR_BADBITDEPTH = @as(i32, -200);
pub const ICERR_BADIMAGESIZE = @as(i32, -201);
pub const ICERR_CUSTOM = @as(i32, -400);
pub const ICMODE_COMPRESS = @as(u32, 1);
pub const ICMODE_DECOMPRESS = @as(u32, 2);
pub const ICMODE_FASTDECOMPRESS = @as(u32, 3);
pub const ICMODE_QUERY = @as(u32, 4);
pub const ICMODE_FASTCOMPRESS = @as(u32, 5);
pub const ICMODE_DRAW = @as(u32, 8);
pub const ICMODE_INTERNALF_FUNCTION32 = @as(u32, 32768);
pub const ICMODE_INTERNALF_MASK = @as(u32, 32768);
pub const AVIIF_TWOCC = @as(i32, 2);
pub const ICQUALITY_LOW = @as(u32, 0);
pub const ICQUALITY_HIGH = @as(u32, 10000);
pub const ICQUALITY_DEFAULT = @as(i32, -1);
pub const ICM_USER = @as(u32, 16384);
pub const ICM_RESERVED_LOW = @as(u32, 20480);
pub const ICM_RESERVED_HIGH = @as(u32, 24576);
pub const ICM_GETSTATE = @as(u32, 20480);
pub const ICM_SETSTATE = @as(u32, 20481);
pub const ICM_GETINFO = @as(u32, 20482);
pub const ICM_CONFIGURE = @as(u32, 20490);
pub const ICM_ABOUT = @as(u32, 20491);
pub const ICM_GETERRORTEXT = @as(u32, 20492);
pub const ICM_GETFORMATNAME = @as(u32, 20500);
pub const ICM_ENUMFORMATS = @as(u32, 20501);
pub const ICM_GETDEFAULTQUALITY = @as(u32, 20510);
pub const ICM_GETQUALITY = @as(u32, 20511);
pub const ICM_SETQUALITY = @as(u32, 20512);
pub const ICM_SET = @as(u32, 20520);
pub const ICM_GET = @as(u32, 20521);
pub const ICM_COMPRESS_GET_FORMAT = @as(u32, 16388);
pub const ICM_COMPRESS_GET_SIZE = @as(u32, 16389);
pub const ICM_COMPRESS_QUERY = @as(u32, 16390);
pub const ICM_COMPRESS_BEGIN = @as(u32, 16391);
pub const ICM_COMPRESS = @as(u32, 16392);
pub const ICM_COMPRESS_END = @as(u32, 16393);
pub const ICM_DECOMPRESS_GET_FORMAT = @as(u32, 16394);
pub const ICM_DECOMPRESS_QUERY = @as(u32, 16395);
pub const ICM_DECOMPRESS_BEGIN = @as(u32, 16396);
pub const ICM_DECOMPRESS = @as(u32, 16397);
pub const ICM_DECOMPRESS_END = @as(u32, 16398);
pub const ICM_DECOMPRESS_SET_PALETTE = @as(u32, 16413);
pub const ICM_DECOMPRESS_GET_PALETTE = @as(u32, 16414);
pub const ICM_DRAW_QUERY = @as(u32, 16415);
pub const ICM_DRAW_BEGIN = @as(u32, 16399);
pub const ICM_DRAW_GET_PALETTE = @as(u32, 16400);
pub const ICM_DRAW_UPDATE = @as(u32, 16401);
pub const ICM_DRAW_START = @as(u32, 16402);
pub const ICM_DRAW_STOP = @as(u32, 16403);
pub const ICM_DRAW_BITS = @as(u32, 16404);
pub const ICM_DRAW_END = @as(u32, 16405);
pub const ICM_DRAW_GETTIME = @as(u32, 16416);
pub const ICM_DRAW = @as(u32, 16417);
pub const ICM_DRAW_WINDOW = @as(u32, 16418);
pub const ICM_DRAW_SETTIME = @as(u32, 16419);
pub const ICM_DRAW_REALIZE = @as(u32, 16420);
pub const ICM_DRAW_FLUSH = @as(u32, 16421);
pub const ICM_DRAW_RENDERBUFFER = @as(u32, 16422);
pub const ICM_DRAW_START_PLAY = @as(u32, 16423);
pub const ICM_DRAW_STOP_PLAY = @as(u32, 16424);
pub const ICM_DRAW_SUGGESTFORMAT = @as(u32, 16434);
pub const ICM_DRAW_CHANGEPALETTE = @as(u32, 16435);
pub const ICM_DRAW_IDLE = @as(u32, 16436);
pub const ICM_GETBUFFERSWANTED = @as(u32, 16425);
pub const ICM_GETDEFAULTKEYFRAMERATE = @as(u32, 16426);
pub const ICM_DECOMPRESSEX_BEGIN = @as(u32, 16444);
pub const ICM_DECOMPRESSEX_QUERY = @as(u32, 16445);
pub const ICM_DECOMPRESSEX = @as(u32, 16446);
pub const ICM_DECOMPRESSEX_END = @as(u32, 16447);
pub const ICM_COMPRESS_FRAMES_INFO = @as(u32, 16454);
pub const ICM_COMPRESS_FRAMES = @as(u32, 16455);
pub const ICM_SET_STATUS_PROC = @as(u32, 16456);
pub const VIDCF_QUALITY = @as(u32, 1);
pub const VIDCF_CRUNCH = @as(u32, 2);
pub const VIDCF_TEMPORAL = @as(u32, 4);
pub const VIDCF_COMPRESSFRAMES = @as(u32, 8);
pub const VIDCF_DRAW = @as(u32, 16);
pub const VIDCF_FASTTEMPORALC = @as(u32, 32);
pub const VIDCF_FASTTEMPORALD = @as(u32, 128);
pub const ICCOMPRESS_KEYFRAME = @as(i32, 1);
pub const ICCOMPRESSFRAMES_PADDING = @as(u32, 1);
pub const ICDECOMPRESS_HURRYUP = @as(i32, -2147483648);
pub const ICDECOMPRESS_UPDATE = @as(i32, 1073741824);
pub const ICDECOMPRESS_PREROLL = @as(i32, 536870912);
pub const ICDECOMPRESS_NULLFRAME = @as(i32, 268435456);
pub const ICDECOMPRESS_NOTKEYFRAME = @as(i32, 134217728);
pub const ICDRAW_QUERY = @as(i32, 1);
pub const ICDRAW_FULLSCREEN = @as(i32, 2);
pub const ICDRAW_HDC = @as(i32, 4);
pub const ICDRAW_ANIMATE = @as(i32, 8);
pub const ICDRAW_CONTINUE = @as(i32, 16);
pub const ICDRAW_MEMORYDC = @as(i32, 32);
pub const ICDRAW_UPDATING = @as(i32, 64);
pub const ICDRAW_RENDER = @as(i32, 128);
pub const ICDRAW_BUFFER = @as(i32, 256);
pub const ICDRAW_HURRYUP = @as(i32, -2147483648);
pub const ICDRAW_UPDATE = @as(i32, 1073741824);
pub const ICDRAW_PREROLL = @as(i32, 536870912);
pub const ICDRAW_NULLFRAME = @as(i32, 268435456);
pub const ICDRAW_NOTKEYFRAME = @as(i32, 134217728);
pub const ICINSTALL_UNICODE = @as(u32, 32768);
pub const ICINSTALL_FUNCTION = @as(u32, 1);
pub const ICINSTALL_DRIVER = @as(u32, 2);
pub const ICINSTALL_HDRV = @as(u32, 4);
pub const ICINSTALL_DRIVERW = @as(u32, 32770);
pub const ICMF_CONFIGURE_QUERY = @as(u32, 1);
pub const ICMF_ABOUT_QUERY = @as(u32, 1);
pub const ICMF_COMPVARS_VALID = @as(u32, 1);
pub const ICMF_CHOOSE_KEYFRAME = @as(u32, 1);
pub const ICMF_CHOOSE_DATARATE = @as(u32, 2);
pub const ICMF_CHOOSE_PREVIEW = @as(u32, 4);
pub const ICMF_CHOOSE_ALLCOMPRESSORS = @as(u32, 8);
pub const DDF_0001 = @as(u32, 1);
pub const DDF_UPDATE = @as(u32, 2);
pub const DDF_SAME_HDC = @as(u32, 4);
pub const DDF_SAME_DRAW = @as(u32, 8);
pub const DDF_DONTDRAW = @as(u32, 16);
pub const DDF_ANIMATE = @as(u32, 32);
pub const DDF_BUFFER = @as(u32, 64);
pub const DDF_JUSTDRAWIT = @as(u32, 128);
pub const DDF_FULLSCREEN = @as(u32, 256);
pub const DDF_BACKGROUNDPAL = @as(u32, 512);
pub const DDF_NOTKEYFRAME = @as(u32, 1024);
pub const DDF_HURRYUP = @as(u32, 2048);
pub const DDF_HALFTONE = @as(u32, 4096);
pub const DDF_2000 = @as(u32, 8192);
pub const PD_CAN_DRAW_DIB = @as(u32, 1);
pub const PD_CAN_STRETCHDIB = @as(u32, 2);
pub const PD_STRETCHDIB_1_1_OK = @as(u32, 4);
pub const PD_STRETCHDIB_1_2_OK = @as(u32, 8);
pub const PD_STRETCHDIB_1_N_OK = @as(u32, 16);
pub const AVIGETFRAMEF_BESTDISPLAYFMT = @as(u32, 1);
pub const AVISTREAMINFO_DISABLED = @as(u32, 1);
pub const AVISTREAMINFO_FORMATCHANGES = @as(u32, 65536);
pub const AVIFILEINFO_HASINDEX = @as(u32, 16);
pub const AVIFILEINFO_MUSTUSEINDEX = @as(u32, 32);
pub const AVIFILEINFO_ISINTERLEAVED = @as(u32, 256);
pub const AVIFILEINFO_WASCAPTUREFILE = @as(u32, 65536);
pub const AVIFILEINFO_COPYRIGHTED = @as(u32, 131072);
pub const AVIFILECAPS_CANREAD = @as(u32, 1);
pub const AVIFILECAPS_CANWRITE = @as(u32, 2);
pub const AVIFILECAPS_ALLKEYFRAMES = @as(u32, 16);
pub const AVIFILECAPS_NOCOMPRESSION = @as(u32, 32);
pub const AVICOMPRESSF_INTERLEAVE = @as(u32, 1);
pub const AVICOMPRESSF_DATARATE = @as(u32, 2);
pub const AVICOMPRESSF_KEYFRAMES = @as(u32, 4);
pub const AVICOMPRESSF_VALID = @as(u32, 8);
pub const AVIFILEHANDLER_CANREAD = @as(u32, 1);
pub const AVIFILEHANDLER_CANWRITE = @as(u32, 2);
pub const AVIFILEHANDLER_CANACCEPTNONRGB = @as(u32, 4);
pub const AVISTREAMREAD_CONVENIENT = @as(i32, -1);
pub const FIND_DIR = @as(i32, 15);
pub const FIND_NEXT = @as(i32, 1);
pub const FIND_PREV = @as(i32, 4);
pub const FIND_FROM_START = @as(i32, 8);
pub const FIND_TYPE = @as(i32, 240);
pub const FIND_KEY = @as(i32, 16);
pub const FIND_ANY = @as(i32, 32);
pub const FIND_FORMAT = @as(i32, 64);
pub const FIND_RET = @as(i32, 61440);
pub const FIND_POS = @as(i32, 0);
pub const FIND_LENGTH = @as(i32, 4096);
pub const FIND_OFFSET = @as(i32, 8192);
pub const FIND_SIZE = @as(i32, 12288);
pub const FIND_INDEX = @as(i32, 16384);
pub const AVIERR_OK = @as(i32, 0);
pub const MCIWNDOPENF_NEW = @as(u32, 1);
pub const MCIWNDF_NOAUTOSIZEWINDOW = @as(u32, 1);
pub const MCIWNDF_NOPLAYBAR = @as(u32, 2);
pub const MCIWNDF_NOAUTOSIZEMOVIE = @as(u32, 4);
pub const MCIWNDF_NOMENU = @as(u32, 8);
pub const MCIWNDF_SHOWNAME = @as(u32, 16);
pub const MCIWNDF_SHOWPOS = @as(u32, 32);
pub const MCIWNDF_SHOWMODE = @as(u32, 64);
pub const MCIWNDF_SHOWALL = @as(u32, 112);
pub const MCIWNDF_NOTIFYMODE = @as(u32, 256);
pub const MCIWNDF_NOTIFYPOS = @as(u32, 512);
pub const MCIWNDF_NOTIFYSIZE = @as(u32, 1024);
pub const MCIWNDF_NOTIFYERROR = @as(u32, 4096);
pub const MCIWNDF_NOTIFYALL = @as(u32, 7936);
pub const MCIWNDF_NOTIFYANSI = @as(u32, 128);
pub const MCIWNDF_NOTIFYMEDIAA = @as(u32, 2176);
pub const MCIWNDF_NOTIFYMEDIAW = @as(u32, 2048);
pub const MCIWNDF_RECORD = @as(u32, 8192);
pub const MCIWNDF_NOERRORDLG = @as(u32, 16384);
pub const MCIWNDF_NOOPEN = @as(u32, 32768);
pub const MCIWNDM_GETDEVICEID = @as(u32, 1124);
pub const MCIWNDM_GETSTART = @as(u32, 1127);
pub const MCIWNDM_GETLENGTH = @as(u32, 1128);
pub const MCIWNDM_GETEND = @as(u32, 1129);
pub const MCIWNDM_EJECT = @as(u32, 1131);
pub const MCIWNDM_SETZOOM = @as(u32, 1132);
pub const MCIWNDM_GETZOOM = @as(u32, 1133);
pub const MCIWNDM_SETVOLUME = @as(u32, 1134);
pub const MCIWNDM_GETVOLUME = @as(u32, 1135);
pub const MCIWNDM_SETSPEED = @as(u32, 1136);
pub const MCIWNDM_GETSPEED = @as(u32, 1137);
pub const MCIWNDM_SETREPEAT = @as(u32, 1138);
pub const MCIWNDM_GETREPEAT = @as(u32, 1139);
pub const MCIWNDM_REALIZE = @as(u32, 1142);
pub const MCIWNDM_VALIDATEMEDIA = @as(u32, 1145);
pub const MCIWNDM_PLAYFROM = @as(u32, 1146);
pub const MCIWNDM_PLAYTO = @as(u32, 1147);
pub const MCIWNDM_GETPALETTE = @as(u32, 1150);
pub const MCIWNDM_SETPALETTE = @as(u32, 1151);
pub const MCIWNDM_SETTIMERS = @as(u32, 1153);
pub const MCIWNDM_SETACTIVETIMER = @as(u32, 1154);
pub const MCIWNDM_SETINACTIVETIMER = @as(u32, 1155);
pub const MCIWNDM_GETACTIVETIMER = @as(u32, 1156);
pub const MCIWNDM_GETINACTIVETIMER = @as(u32, 1157);
pub const MCIWNDM_CHANGESTYLES = @as(u32, 1159);
pub const MCIWNDM_GETSTYLES = @as(u32, 1160);
pub const MCIWNDM_GETALIAS = @as(u32, 1161);
pub const MCIWNDM_PLAYREVERSE = @as(u32, 1163);
pub const MCIWNDM_GET_SOURCE = @as(u32, 1164);
pub const MCIWNDM_PUT_SOURCE = @as(u32, 1165);
pub const MCIWNDM_GET_DEST = @as(u32, 1166);
pub const MCIWNDM_PUT_DEST = @as(u32, 1167);
pub const MCIWNDM_CAN_PLAY = @as(u32, 1168);
pub const MCIWNDM_CAN_WINDOW = @as(u32, 1169);
pub const MCIWNDM_CAN_RECORD = @as(u32, 1170);
pub const MCIWNDM_CAN_SAVE = @as(u32, 1171);
pub const MCIWNDM_CAN_EJECT = @as(u32, 1172);
pub const MCIWNDM_CAN_CONFIG = @as(u32, 1173);
pub const MCIWNDM_PALETTEKICK = @as(u32, 1174);
pub const MCIWNDM_OPENINTERFACE = @as(u32, 1175);
pub const MCIWNDM_SETOWNER = @as(u32, 1176);
pub const MCIWNDM_SENDSTRINGA = @as(u32, 1125);
pub const MCIWNDM_GETPOSITIONA = @as(u32, 1126);
pub const MCIWNDM_GETMODEA = @as(u32, 1130);
pub const MCIWNDM_SETTIMEFORMATA = @as(u32, 1143);
pub const MCIWNDM_GETTIMEFORMATA = @as(u32, 1144);
pub const MCIWNDM_GETFILENAMEA = @as(u32, 1148);
pub const MCIWNDM_GETDEVICEA = @as(u32, 1149);
pub const MCIWNDM_GETERRORA = @as(u32, 1152);
pub const MCIWNDM_NEWA = @as(u32, 1158);
pub const MCIWNDM_RETURNSTRINGA = @as(u32, 1162);
pub const MCIWNDM_OPENA = @as(u32, 1177);
pub const MCIWNDM_SENDSTRINGW = @as(u32, 1225);
pub const MCIWNDM_GETPOSITIONW = @as(u32, 1226);
pub const MCIWNDM_GETMODEW = @as(u32, 1230);
pub const MCIWNDM_SETTIMEFORMATW = @as(u32, 1243);
pub const MCIWNDM_GETTIMEFORMATW = @as(u32, 1244);
pub const MCIWNDM_GETFILENAMEW = @as(u32, 1248);
pub const MCIWNDM_GETDEVICEW = @as(u32, 1249);
pub const MCIWNDM_GETERRORW = @as(u32, 1252);
pub const MCIWNDM_NEWW = @as(u32, 1258);
pub const MCIWNDM_RETURNSTRINGW = @as(u32, 1262);
pub const MCIWNDM_OPENW = @as(u32, 1276);
pub const MCIWNDM_NOTIFYMODE = @as(u32, 1224);
pub const MCIWNDM_NOTIFYPOS = @as(u32, 1225);
pub const MCIWNDM_NOTIFYSIZE = @as(u32, 1226);
pub const MCIWNDM_NOTIFYMEDIA = @as(u32, 1227);
pub const MCIWNDM_NOTIFYERROR = @as(u32, 1229);
pub const MCIWND_START = @as(i32, -1);
pub const MCIWND_END = @as(i32, -2);
pub const DV_ERR_OK = @as(u32, 0);
pub const DV_ERR_BASE = @as(u32, 1);
pub const DV_ERR_BADFORMAT = @as(u32, 2);
pub const DV_ERR_STILLPLAYING = @as(u32, 3);
pub const DV_ERR_UNPREPARED = @as(u32, 4);
pub const DV_ERR_SYNC = @as(u32, 5);
pub const DV_ERR_TOOMANYCHANNELS = @as(u32, 6);
pub const DV_ERR_NOTDETECTED = @as(u32, 7);
pub const DV_ERR_BADINSTALL = @as(u32, 8);
pub const DV_ERR_CREATEPALETTE = @as(u32, 9);
pub const DV_ERR_SIZEFIELD = @as(u32, 10);
pub const DV_ERR_PARAM1 = @as(u32, 11);
pub const DV_ERR_PARAM2 = @as(u32, 12);
pub const DV_ERR_CONFIG1 = @as(u32, 13);
pub const DV_ERR_CONFIG2 = @as(u32, 14);
pub const DV_ERR_FLAGS = @as(u32, 15);
pub const DV_ERR_13 = @as(u32, 16);
pub const DV_ERR_NOTSUPPORTED = @as(u32, 17);
pub const DV_ERR_NOMEM = @as(u32, 18);
pub const DV_ERR_ALLOCATED = @as(u32, 19);
pub const DV_ERR_BADDEVICEID = @as(u32, 20);
pub const DV_ERR_INVALHANDLE = @as(u32, 21);
pub const DV_ERR_BADERRNUM = @as(u32, 22);
pub const DV_ERR_NO_BUFFERS = @as(u32, 23);
pub const DV_ERR_MEM_CONFLICT = @as(u32, 24);
pub const DV_ERR_IO_CONFLICT = @as(u32, 25);
pub const DV_ERR_DMA_CONFLICT = @as(u32, 26);
pub const DV_ERR_INT_CONFLICT = @as(u32, 27);
pub const DV_ERR_PROTECT_ONLY = @as(u32, 28);
pub const DV_ERR_LASTERROR = @as(u32, 28);
pub const DV_ERR_USER_MSG = @as(u32, 1001);
pub const MM_DRVM_OPEN = @as(u32, 976);
pub const MM_DRVM_CLOSE = @as(u32, 977);
pub const MM_DRVM_DATA = @as(u32, 978);
pub const MM_DRVM_ERROR = @as(u32, 979);
pub const VHDR_DONE = @as(u32, 1);
pub const VHDR_PREPARED = @as(u32, 2);
pub const VHDR_INQUEUE = @as(u32, 4);
pub const VHDR_KEYFRAME = @as(u32, 8);
pub const VHDR_VALID = @as(u32, 15);
pub const VCAPS_OVERLAY = @as(u32, 1);
pub const VCAPS_SRC_CAN_CLIP = @as(u32, 2);
pub const VCAPS_DST_CAN_CLIP = @as(u32, 4);
pub const VCAPS_CAN_SCALE = @as(u32, 8);
pub const VIDEO_EXTERNALIN = @as(u32, 1);
pub const VIDEO_EXTERNALOUT = @as(u32, 2);
pub const VIDEO_IN = @as(u32, 4);
pub const VIDEO_OUT = @as(u32, 8);
pub const VIDEO_DLG_QUERY = @as(u32, 16);
pub const VIDEO_CONFIGURE_QUERY = @as(u32, 32768);
pub const VIDEO_CONFIGURE_SET = @as(u32, 4096);
pub const VIDEO_CONFIGURE_GET = @as(u32, 8192);
pub const VIDEO_CONFIGURE_QUERYSIZE = @as(u32, 1);
pub const VIDEO_CONFIGURE_CURRENT = @as(u32, 16);
pub const VIDEO_CONFIGURE_NOMINAL = @as(u32, 32);
pub const VIDEO_CONFIGURE_MIN = @as(u32, 64);
pub const VIDEO_CONFIGURE_MAX = @as(u32, 128);
pub const DVM_USER = @as(u32, 16384);
pub const DVM_CONFIGURE_START = @as(u32, 4096);
pub const DVM_CONFIGURE_END = @as(u32, 8191);
pub const DVM_PALETTE = @as(u32, 4097);
pub const DVM_FORMAT = @as(u32, 4098);
pub const DVM_PALETTERGB555 = @as(u32, 4099);
pub const DVM_SRC_RECT = @as(u32, 4100);
pub const DVM_DST_RECT = @as(u32, 4101);
pub const WM_CAP_UNICODE_START = @as(u32, 1124);
pub const WM_CAP_GET_CAPSTREAMPTR = @as(u32, 1025);
pub const WM_CAP_SET_CALLBACK_ERRORW = @as(u32, 1126);
pub const WM_CAP_SET_CALLBACK_STATUSW = @as(u32, 1127);
pub const WM_CAP_SET_CALLBACK_ERRORA = @as(u32, 1026);
pub const WM_CAP_SET_CALLBACK_STATUSA = @as(u32, 1027);
pub const WM_CAP_SET_CALLBACK_YIELD = @as(u32, 1028);
pub const WM_CAP_SET_CALLBACK_FRAME = @as(u32, 1029);
pub const WM_CAP_SET_CALLBACK_VIDEOSTREAM = @as(u32, 1030);
pub const WM_CAP_SET_CALLBACK_WAVESTREAM = @as(u32, 1031);
pub const WM_CAP_GET_USER_DATA = @as(u32, 1032);
pub const WM_CAP_SET_USER_DATA = @as(u32, 1033);
pub const WM_CAP_DRIVER_CONNECT = @as(u32, 1034);
pub const WM_CAP_DRIVER_DISCONNECT = @as(u32, 1035);
pub const WM_CAP_DRIVER_GET_NAMEA = @as(u32, 1036);
pub const WM_CAP_DRIVER_GET_VERSIONA = @as(u32, 1037);
pub const WM_CAP_DRIVER_GET_NAMEW = @as(u32, 1136);
pub const WM_CAP_DRIVER_GET_VERSIONW = @as(u32, 1137);
pub const WM_CAP_DRIVER_GET_CAPS = @as(u32, 1038);
pub const WM_CAP_FILE_SET_CAPTURE_FILEA = @as(u32, 1044);
pub const WM_CAP_FILE_GET_CAPTURE_FILEA = @as(u32, 1045);
pub const WM_CAP_FILE_SAVEASA = @as(u32, 1047);
pub const WM_CAP_FILE_SAVEDIBA = @as(u32, 1049);
pub const WM_CAP_FILE_SET_CAPTURE_FILEW = @as(u32, 1144);
pub const WM_CAP_FILE_GET_CAPTURE_FILEW = @as(u32, 1145);
pub const WM_CAP_FILE_SAVEASW = @as(u32, 1147);
pub const WM_CAP_FILE_SAVEDIBW = @as(u32, 1149);
pub const WM_CAP_FILE_ALLOCATE = @as(u32, 1046);
pub const WM_CAP_FILE_SET_INFOCHUNK = @as(u32, 1048);
pub const WM_CAP_EDIT_COPY = @as(u32, 1054);
pub const WM_CAP_SET_AUDIOFORMAT = @as(u32, 1059);
pub const WM_CAP_GET_AUDIOFORMAT = @as(u32, 1060);
pub const WM_CAP_DLG_VIDEOFORMAT = @as(u32, 1065);
pub const WM_CAP_DLG_VIDEOSOURCE = @as(u32, 1066);
pub const WM_CAP_DLG_VIDEODISPLAY = @as(u32, 1067);
pub const WM_CAP_GET_VIDEOFORMAT = @as(u32, 1068);
pub const WM_CAP_SET_VIDEOFORMAT = @as(u32, 1069);
pub const WM_CAP_DLG_VIDEOCOMPRESSION = @as(u32, 1070);
pub const WM_CAP_SET_PREVIEW = @as(u32, 1074);
pub const WM_CAP_SET_OVERLAY = @as(u32, 1075);
pub const WM_CAP_SET_PREVIEWRATE = @as(u32, 1076);
pub const WM_CAP_SET_SCALE = @as(u32, 1077);
pub const WM_CAP_GET_STATUS = @as(u32, 1078);
pub const WM_CAP_SET_SCROLL = @as(u32, 1079);
pub const WM_CAP_GRAB_FRAME = @as(u32, 1084);
pub const WM_CAP_GRAB_FRAME_NOSTOP = @as(u32, 1085);
pub const WM_CAP_SEQUENCE = @as(u32, 1086);
pub const WM_CAP_SEQUENCE_NOFILE = @as(u32, 1087);
pub const WM_CAP_SET_SEQUENCE_SETUP = @as(u32, 1088);
pub const WM_CAP_GET_SEQUENCE_SETUP = @as(u32, 1089);
pub const WM_CAP_SET_MCI_DEVICEA = @as(u32, 1090);
pub const WM_CAP_GET_MCI_DEVICEA = @as(u32, 1091);
pub const WM_CAP_SET_MCI_DEVICEW = @as(u32, 1190);
pub const WM_CAP_GET_MCI_DEVICEW = @as(u32, 1191);
pub const WM_CAP_STOP = @as(u32, 1092);
pub const WM_CAP_ABORT = @as(u32, 1093);
pub const WM_CAP_SINGLE_FRAME_OPEN = @as(u32, 1094);
pub const WM_CAP_SINGLE_FRAME_CLOSE = @as(u32, 1095);
pub const WM_CAP_SINGLE_FRAME = @as(u32, 1096);
pub const WM_CAP_PAL_OPENA = @as(u32, 1104);
pub const WM_CAP_PAL_SAVEA = @as(u32, 1105);
pub const WM_CAP_PAL_OPENW = @as(u32, 1204);
pub const WM_CAP_PAL_SAVEW = @as(u32, 1205);
pub const WM_CAP_PAL_PASTE = @as(u32, 1106);
pub const WM_CAP_PAL_AUTOCREATE = @as(u32, 1107);
pub const WM_CAP_PAL_MANUALCREATE = @as(u32, 1108);
pub const WM_CAP_SET_CALLBACK_CAPCONTROL = @as(u32, 1109);
pub const AVSTREAMMASTER_AUDIO = @as(u32, 0);
pub const AVSTREAMMASTER_NONE = @as(u32, 1);
pub const CONTROLCALLBACK_PREROLL = @as(u32, 1);
pub const CONTROLCALLBACK_CAPTURING = @as(u32, 2);
pub const IDS_CAP_BEGIN = @as(u32, 300);
pub const IDS_CAP_END = @as(u32, 301);
pub const IDS_CAP_INFO = @as(u32, 401);
pub const IDS_CAP_OUTOFMEM = @as(u32, 402);
pub const IDS_CAP_FILEEXISTS = @as(u32, 403);
pub const IDS_CAP_ERRORPALOPEN = @as(u32, 404);
pub const IDS_CAP_ERRORPALSAVE = @as(u32, 405);
pub const IDS_CAP_ERRORDIBSAVE = @as(u32, 406);
pub const IDS_CAP_DEFAVIEXT = @as(u32, 407);
pub const IDS_CAP_DEFPALEXT = @as(u32, 408);
pub const IDS_CAP_CANTOPEN = @as(u32, 409);
pub const IDS_CAP_SEQ_MSGSTART = @as(u32, 410);
pub const IDS_CAP_SEQ_MSGSTOP = @as(u32, 411);
pub const IDS_CAP_VIDEDITERR = @as(u32, 412);
pub const IDS_CAP_READONLYFILE = @as(u32, 413);
pub const IDS_CAP_WRITEERROR = @as(u32, 414);
pub const IDS_CAP_NODISKSPACE = @as(u32, 415);
pub const IDS_CAP_SETFILESIZE = @as(u32, 416);
pub const IDS_CAP_SAVEASPERCENT = @as(u32, 417);
pub const IDS_CAP_DRIVER_ERROR = @as(u32, 418);
pub const IDS_CAP_WAVE_OPEN_ERROR = @as(u32, 419);
pub const IDS_CAP_WAVE_ALLOC_ERROR = @as(u32, 420);
pub const IDS_CAP_WAVE_PREPARE_ERROR = @as(u32, 421);
pub const IDS_CAP_WAVE_ADD_ERROR = @as(u32, 422);
pub const IDS_CAP_WAVE_SIZE_ERROR = @as(u32, 423);
pub const IDS_CAP_VIDEO_OPEN_ERROR = @as(u32, 424);
pub const IDS_CAP_VIDEO_ALLOC_ERROR = @as(u32, 425);
pub const IDS_CAP_VIDEO_PREPARE_ERROR = @as(u32, 426);
pub const IDS_CAP_VIDEO_ADD_ERROR = @as(u32, 427);
pub const IDS_CAP_VIDEO_SIZE_ERROR = @as(u32, 428);
pub const IDS_CAP_FILE_OPEN_ERROR = @as(u32, 429);
pub const IDS_CAP_FILE_WRITE_ERROR = @as(u32, 430);
pub const IDS_CAP_RECORDING_ERROR = @as(u32, 431);
pub const IDS_CAP_RECORDING_ERROR2 = @as(u32, 432);
pub const IDS_CAP_AVI_INIT_ERROR = @as(u32, 433);
pub const IDS_CAP_NO_FRAME_CAP_ERROR = @as(u32, 434);
pub const IDS_CAP_NO_PALETTE_WARN = @as(u32, 435);
pub const IDS_CAP_MCI_CONTROL_ERROR = @as(u32, 436);
pub const IDS_CAP_MCI_CANT_STEP_ERROR = @as(u32, 437);
pub const IDS_CAP_NO_AUDIO_CAP_ERROR = @as(u32, 438);
pub const IDS_CAP_AVI_DRAWDIB_ERROR = @as(u32, 439);
pub const IDS_CAP_COMPRESSOR_ERROR = @as(u32, 440);
pub const IDS_CAP_AUDIO_DROP_ERROR = @as(u32, 441);
pub const IDS_CAP_AUDIO_DROP_COMPERROR = @as(u32, 442);
pub const IDS_CAP_STAT_LIVE_MODE = @as(u32, 500);
pub const IDS_CAP_STAT_OVERLAY_MODE = @as(u32, 501);
pub const IDS_CAP_STAT_CAP_INIT = @as(u32, 502);
pub const IDS_CAP_STAT_CAP_FINI = @as(u32, 503);
pub const IDS_CAP_STAT_PALETTE_BUILD = @as(u32, 504);
pub const IDS_CAP_STAT_OPTPAL_BUILD = @as(u32, 505);
pub const IDS_CAP_STAT_I_FRAMES = @as(u32, 506);
pub const IDS_CAP_STAT_L_FRAMES = @as(u32, 507);
pub const IDS_CAP_STAT_CAP_L_FRAMES = @as(u32, 508);
pub const IDS_CAP_STAT_CAP_AUDIO = @as(u32, 509);
pub const IDS_CAP_STAT_VIDEOCURRENT = @as(u32, 510);
pub const IDS_CAP_STAT_VIDEOAUDIO = @as(u32, 511);
pub const IDS_CAP_STAT_VIDEOONLY = @as(u32, 512);
pub const IDS_CAP_STAT_FRAMESDROPPED = @as(u32, 513);
pub const JOYERR_NOERROR = @as(u32, 0);
pub const JOYERR_PARMS = @as(u32, 165);
pub const JOYERR_NOCANDO = @as(u32, 166);
pub const JOYERR_UNPLUGGED = @as(u32, 167);
pub const JOY_BUTTON1 = @as(u32, 1);
pub const JOY_BUTTON2 = @as(u32, 2);
pub const JOY_BUTTON3 = @as(u32, 4);
pub const JOY_BUTTON4 = @as(u32, 8);
pub const JOY_BUTTON1CHG = @as(u32, 256);
pub const JOY_BUTTON2CHG = @as(u32, 512);
pub const JOY_BUTTON3CHG = @as(u32, 1024);
pub const JOY_BUTTON4CHG = @as(u32, 2048);
pub const JOY_BUTTON5 = @as(i32, 16);
pub const JOY_BUTTON6 = @as(i32, 32);
pub const JOY_BUTTON7 = @as(i32, 64);
pub const JOY_BUTTON8 = @as(i32, 128);
pub const JOY_BUTTON9 = @as(i32, 256);
pub const JOY_BUTTON10 = @as(i32, 512);
pub const JOY_BUTTON11 = @as(i32, 1024);
pub const JOY_BUTTON12 = @as(i32, 2048);
pub const JOY_BUTTON13 = @as(i32, 4096);
pub const JOY_BUTTON14 = @as(i32, 8192);
pub const JOY_BUTTON15 = @as(i32, 16384);
pub const JOY_BUTTON16 = @as(i32, 32768);
pub const JOY_BUTTON17 = @as(i32, 65536);
pub const JOY_BUTTON18 = @as(i32, 131072);
pub const JOY_BUTTON19 = @as(i32, 262144);
pub const JOY_BUTTON20 = @as(i32, 524288);
pub const JOY_BUTTON21 = @as(i32, 1048576);
pub const JOY_BUTTON22 = @as(i32, 2097152);
pub const JOY_BUTTON23 = @as(i32, 4194304);
pub const JOY_BUTTON24 = @as(i32, 8388608);
pub const JOY_BUTTON25 = @as(i32, 16777216);
pub const JOY_BUTTON26 = @as(i32, 33554432);
pub const JOY_BUTTON27 = @as(i32, 67108864);
pub const JOY_BUTTON28 = @as(i32, 134217728);
pub const JOY_BUTTON29 = @as(i32, 268435456);
pub const JOY_BUTTON30 = @as(i32, 536870912);
pub const JOY_BUTTON31 = @as(i32, 1073741824);
pub const JOY_BUTTON32 = @as(i32, -2147483648);
pub const JOY_POVFORWARD = @as(u32, 0);
pub const JOY_POVRIGHT = @as(u32, 9000);
pub const JOY_POVBACKWARD = @as(u32, 18000);
pub const JOY_POVLEFT = @as(u32, 27000);
pub const JOY_RETURNX = @as(i32, 1);
pub const JOY_RETURNY = @as(i32, 2);
pub const JOY_RETURNZ = @as(i32, 4);
pub const JOY_RETURNR = @as(i32, 8);
pub const JOY_RETURNU = @as(i32, 16);
pub const JOY_RETURNV = @as(i32, 32);
pub const JOY_RETURNPOV = @as(i32, 64);
pub const JOY_RETURNBUTTONS = @as(i32, 128);
pub const JOY_RETURNRAWDATA = @as(i32, 256);
pub const JOY_RETURNPOVCTS = @as(i32, 512);
pub const JOY_RETURNCENTERED = @as(i32, 1024);
pub const JOY_USEDEADZONE = @as(i32, 2048);
pub const JOY_CAL_READALWAYS = @as(i32, 65536);
pub const JOY_CAL_READXYONLY = @as(i32, 131072);
pub const JOY_CAL_READ3 = @as(i32, 262144);
pub const JOY_CAL_READ4 = @as(i32, 524288);
pub const JOY_CAL_READXONLY = @as(i32, 1048576);
pub const JOY_CAL_READYONLY = @as(i32, 2097152);
pub const JOY_CAL_READ5 = @as(i32, 4194304);
pub const JOY_CAL_READ6 = @as(i32, 8388608);
pub const JOY_CAL_READZONLY = @as(i32, 16777216);
pub const JOY_CAL_READRONLY = @as(i32, 33554432);
pub const JOY_CAL_READUONLY = @as(i32, 67108864);
pub const JOY_CAL_READVONLY = @as(i32, 134217728);
pub const JOYSTICKID1 = @as(u32, 0);
pub const JOYSTICKID2 = @as(u32, 1);
pub const JOYCAPS_HASZ = @as(u32, 1);
pub const JOYCAPS_HASR = @as(u32, 2);
pub const JOYCAPS_HASU = @as(u32, 4);
pub const JOYCAPS_HASV = @as(u32, 8);
pub const JOYCAPS_HASPOV = @as(u32, 16);
pub const JOYCAPS_POV4DIR = @as(u32, 32);
pub const JOYCAPS_POVCTS = @as(u32, 64);
pub const DRV_LOAD = @as(u32, 1);
pub const DRV_ENABLE = @as(u32, 2);
pub const DRV_OPEN = @as(u32, 3);
pub const DRV_CLOSE = @as(u32, 4);
pub const DRV_DISABLE = @as(u32, 5);
pub const DRV_FREE = @as(u32, 6);
pub const DRV_CONFIGURE = @as(u32, 7);
pub const DRV_QUERYCONFIGURE = @as(u32, 8);
pub const DRV_INSTALL = @as(u32, 9);
pub const DRV_REMOVE = @as(u32, 10);
pub const DRV_RESERVED = @as(u32, 2048);
pub const DRV_USER = @as(u32, 16384);
pub const DCB_NOSWITCH = @as(u32, 8);
pub const DCB_TYPEMASK = @as(u32, 7);
pub const DCB_NULL = @as(u32, 0);
pub const DCB_WINDOW = @as(u32, 1);
pub const DCB_TASK = @as(u32, 2);
pub const DCB_FUNCTION = @as(u32, 3);
pub const DCB_EVENT = @as(u32, 5);
pub const DRVM_INIT = @as(u32, 100);
pub const DRVM_EXIT = @as(u32, 101);
pub const DRVM_DISABLE = @as(u32, 102);
pub const DRVM_ENABLE = @as(u32, 103);
pub const DRVM_INIT_EX = @as(u32, 104);
pub const DRVM_USER = @as(u32, 16384);
pub const DRVM_MAPPER_RECONFIGURE = @as(u32, 8193);
pub const DRVM_MAPPER_PREFERRED_GET = @as(u32, 8213);
pub const DRVM_MAPPER_CONSOLEVOICECOM_GET = @as(u32, 8215);
pub const DRV_QUERYDEVNODE = @as(u32, 2050);
pub const DRV_QUERYMAPPABLE = @as(u32, 2053);
pub const DRV_QUERYMODULE = @as(u32, 2057);
pub const DRV_PNPINSTALL = @as(u32, 2059);
pub const DRV_QUERYDEVICEINTERFACE = @as(u32, 2060);
pub const DRV_QUERYDEVICEINTERFACESIZE = @as(u32, 2061);
pub const DRV_QUERYSTRINGID = @as(u32, 2062);
pub const DRV_QUERYSTRINGIDSIZE = @as(u32, 2063);
pub const DRV_QUERYIDFROMSTRINGID = @as(u32, 2064);
pub const DRV_QUERYFUNCTIONINSTANCEID = @as(u32, 2065);
pub const DRV_QUERYFUNCTIONINSTANCEIDSIZE = @as(u32, 2066);
pub const DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY = @as(u32, 1);
pub const DRVM_IOCTL = @as(u32, 256);
pub const DRVM_ADD_THRU = @as(u32, 257);
pub const DRVM_REMOVE_THRU = @as(u32, 258);
pub const DRVM_IOCTL_LAST = @as(u32, 261);
pub const DRVM_IOCTL_CMD_USER = @as(i32, 0);
pub const DRVM_IOCTL_CMD_SYSTEM = @as(i32, -2147483648);
pub const VADMAD_Device_ID = @as(u32, 1092);
pub const WODM_GETNUMDEVS = @as(u32, 3);
pub const WODM_GETDEVCAPS = @as(u32, 4);
pub const WODM_OPEN = @as(u32, 5);
pub const WODM_CLOSE = @as(u32, 6);
pub const WODM_PREPARE = @as(u32, 7);
pub const WODM_UNPREPARE = @as(u32, 8);
pub const WODM_WRITE = @as(u32, 9);
pub const WODM_PAUSE = @as(u32, 10);
pub const WODM_RESTART = @as(u32, 11);
pub const WODM_RESET = @as(u32, 12);
pub const WODM_GETPOS = @as(u32, 13);
pub const WODM_GETPITCH = @as(u32, 14);
pub const WODM_SETPITCH = @as(u32, 15);
pub const WODM_GETVOLUME = @as(u32, 16);
pub const WODM_SETVOLUME = @as(u32, 17);
pub const WODM_GETPLAYBACKRATE = @as(u32, 18);
pub const WODM_SETPLAYBACKRATE = @as(u32, 19);
pub const WODM_BREAKLOOP = @as(u32, 20);
pub const WODM_PREFERRED = @as(u32, 21);
pub const WODM_BUSY = @as(u32, 21);
pub const WIDM_GETNUMDEVS = @as(u32, 50);
pub const WIDM_GETDEVCAPS = @as(u32, 51);
pub const WIDM_OPEN = @as(u32, 52);
pub const WIDM_CLOSE = @as(u32, 53);
pub const WIDM_PREPARE = @as(u32, 54);
pub const WIDM_UNPREPARE = @as(u32, 55);
pub const WIDM_ADDBUFFER = @as(u32, 56);
pub const WIDM_START = @as(u32, 57);
pub const WIDM_STOP = @as(u32, 58);
pub const WIDM_RESET = @as(u32, 59);
pub const WIDM_GETPOS = @as(u32, 60);
pub const WIDM_PREFERRED = @as(u32, 61);
pub const MIDI_IO_PACKED = @as(i32, 0);
pub const MIDI_IO_COOKED = @as(i32, 2);
pub const MODM_GETNUMDEVS = @as(u32, 1);
pub const MODM_GETDEVCAPS = @as(u32, 2);
pub const MODM_OPEN = @as(u32, 3);
pub const MODM_CLOSE = @as(u32, 4);
pub const MODM_PREPARE = @as(u32, 5);
pub const MODM_UNPREPARE = @as(u32, 6);
pub const MODM_DATA = @as(u32, 7);
pub const MODM_LONGDATA = @as(u32, 8);
pub const MODM_RESET = @as(u32, 9);
pub const MODM_GETVOLUME = @as(u32, 10);
pub const MODM_SETVOLUME = @as(u32, 11);
pub const MODM_CACHEPATCHES = @as(u32, 12);
pub const MODM_CACHEDRUMPATCHES = @as(u32, 13);
pub const MODM_STRMDATA = @as(u32, 14);
pub const MODM_GETPOS = @as(u32, 17);
pub const MODM_PAUSE = @as(u32, 18);
pub const MODM_RESTART = @as(u32, 19);
pub const MODM_STOP = @as(u32, 20);
pub const MODM_PROPERTIES = @as(u32, 21);
pub const MODM_PREFERRED = @as(u32, 22);
pub const MODM_RECONFIGURE = @as(u32, 18280);
pub const MIDM_GETNUMDEVS = @as(u32, 53);
pub const MIDM_GETDEVCAPS = @as(u32, 54);
pub const MIDM_OPEN = @as(u32, 55);
pub const MIDM_CLOSE = @as(u32, 56);
pub const MIDM_PREPARE = @as(u32, 57);
pub const MIDM_UNPREPARE = @as(u32, 58);
pub const MIDM_ADDBUFFER = @as(u32, 59);
pub const MIDM_START = @as(u32, 60);
pub const MIDM_STOP = @as(u32, 61);
pub const MIDM_RESET = @as(u32, 62);
pub const AUXDM_GETNUMDEVS = @as(u32, 3);
pub const AUXDM_GETDEVCAPS = @as(u32, 4);
pub const AUXDM_GETVOLUME = @as(u32, 5);
pub const AUXDM_SETVOLUME = @as(u32, 6);
pub const MXDM_BASE = @as(u32, 1);
pub const MXDM_GETNUMDEVS = @as(u32, 1);
pub const MXDM_GETDEVCAPS = @as(u32, 2);
pub const MXDM_OPEN = @as(u32, 3);
pub const MXDM_CLOSE = @as(u32, 4);
pub const MXDM_GETLINEINFO = @as(u32, 5);
pub const MXDM_GETLINECONTROLS = @as(u32, 6);
pub const MXDM_GETCONTROLDETAILS = @as(u32, 7);
pub const MXDM_SETCONTROLDETAILS = @as(u32, 8);
pub const TDD_KILLTIMEREVENT = @as(u32, 2048);
pub const TDD_SETTIMEREVENT = @as(u32, 2052);
pub const TDD_GETSYSTEMTIME = @as(u32, 2056);
pub const TDD_GETDEVCAPS = @as(u32, 2060);
pub const TDD_BEGINMINPERIOD = @as(u32, 2064);
pub const TDD_ENDMINPERIOD = @as(u32, 2068);
pub const JDD_GETNUMDEVS = @as(u32, 2049);
pub const JDD_GETDEVCAPS = @as(u32, 2050);
pub const JDD_GETPOS = @as(u32, 2305);
pub const JDD_SETCALIBRATION = @as(u32, 2306);
pub const JDD_CONFIGCHANGED = @as(u32, 2307);
pub const JDD_GETPOSEX = @as(u32, 2308);
pub const MCI_OPEN_DRIVER = @as(u32, 2049);
pub const MCI_CLOSE_DRIVER = @as(u32, 2050);
pub const MCI_FALSE = @as(u32, 531);
pub const MCI_TRUE = @as(u32, 532);
pub const MCI_FORMAT_MILLISECONDS_S = @as(u32, 533);
pub const MCI_FORMAT_HMS_S = @as(u32, 534);
pub const MCI_FORMAT_MSF_S = @as(u32, 535);
pub const MCI_FORMAT_FRAMES_S = @as(u32, 536);
pub const MCI_FORMAT_SMPTE_24_S = @as(u32, 537);
pub const MCI_FORMAT_SMPTE_25_S = @as(u32, 538);
pub const MCI_FORMAT_SMPTE_30_S = @as(u32, 539);
pub const MCI_FORMAT_SMPTE_30DROP_S = @as(u32, 540);
pub const MCI_FORMAT_BYTES_S = @as(u32, 541);
pub const MCI_FORMAT_SAMPLES_S = @as(u32, 542);
pub const MCI_FORMAT_TMSF_S = @as(u32, 543);
pub const MCI_VD_FORMAT_TRACK_S = @as(u32, 1029);
pub const WAVE_FORMAT_PCM_S = @as(u32, 1152);
pub const WAVE_MAPPER_S = @as(u32, 1153);
pub const MCI_SEQ_MAPPER_S = @as(u32, 1221);
pub const MCI_SEQ_FILE_S = @as(u32, 1222);
pub const MCI_SEQ_MIDI_S = @as(u32, 1223);
pub const MCI_SEQ_SMPTE_S = @as(u32, 1224);
pub const MCI_SEQ_FORMAT_SONGPTR_S = @as(u32, 1225);
pub const MCI_SEQ_NONE_S = @as(u32, 1226);
pub const MIDIMAPPER_S = @as(u32, 1227);
pub const MCI_MAX_DEVICE_TYPE_LENGTH = @as(u32, 80);
pub const MCI_RESOURCE_RETURNED = @as(u32, 65536);
pub const MCI_COLONIZED3_RETURN = @as(u32, 131072);
pub const MCI_COLONIZED4_RETURN = @as(u32, 262144);
pub const MCI_INTEGER_RETURNED = @as(u32, 524288);
pub const MCI_RESOURCE_DRIVER = @as(u32, 1048576);
pub const MCI_COMMAND_HEAD = @as(u32, 0);
pub const MCI_STRING = @as(u32, 1);
pub const MCI_INTEGER = @as(u32, 2);
pub const MCI_END_COMMAND = @as(u32, 3);
pub const MCI_RETURN = @as(u32, 4);
pub const MCI_FLAG = @as(u32, 5);
pub const MCI_END_COMMAND_LIST = @as(u32, 6);
pub const MCI_RECT = @as(u32, 7);
pub const MCI_CONSTANT = @as(u32, 8);
pub const MCI_END_CONSTANT = @as(u32, 9);
pub const MCI_HWND = @as(u32, 10);
pub const MCI_HPAL = @as(u32, 11);
pub const MCI_HDC = @as(u32, 12);
pub const MCI_INTEGER64 = @as(u32, 13);
pub const TASKERR_NOTASKSUPPORT = @as(u32, 1);
pub const TASKERR_OUTOFMEMORY = @as(u32, 2);
pub const DRV_EXITSESSION = @as(u32, 11);
pub const DRV_POWER = @as(u32, 15);
pub const DRVCNF_CANCEL = @as(u32, 0);
pub const DRVCNF_OK = @as(u32, 1);
pub const DRVCNF_RESTART = @as(u32, 2);
pub const DRV_MCI_LAST = @as(u32, 6143);
pub const MMIOERR_BASE = @as(u32, 256);
pub const MMIOERR_FILENOTFOUND = @as(u32, 257);
pub const MMIOERR_OUTOFMEMORY = @as(u32, 258);
pub const MMIOERR_CANNOTOPEN = @as(u32, 259);
pub const MMIOERR_CANNOTCLOSE = @as(u32, 260);
pub const MMIOERR_CANNOTREAD = @as(u32, 261);
pub const MMIOERR_CANNOTWRITE = @as(u32, 262);
pub const MMIOERR_CANNOTSEEK = @as(u32, 263);
pub const MMIOERR_CANNOTEXPAND = @as(u32, 264);
pub const MMIOERR_CHUNKNOTFOUND = @as(u32, 265);
pub const MMIOERR_UNBUFFERED = @as(u32, 266);
pub const MMIOERR_PATHNOTFOUND = @as(u32, 267);
pub const MMIOERR_ACCESSDENIED = @as(u32, 268);
pub const MMIOERR_SHARINGVIOLATION = @as(u32, 269);
pub const MMIOERR_NETWORKERROR = @as(u32, 270);
pub const MMIOERR_TOOMANYOPENFILES = @as(u32, 271);
pub const MMIOERR_INVALIDFILE = @as(u32, 272);
pub const MMIO_RWMODE = @as(u32, 3);
pub const MMIO_SHAREMODE = @as(u32, 112);
pub const MMIO_CREATE = @as(u32, 4096);
pub const MMIO_PARSE = @as(u32, 256);
pub const MMIO_DELETE = @as(u32, 512);
pub const MMIO_EXIST = @as(u32, 16384);
pub const MMIO_ALLOCBUF = @as(u32, 65536);
pub const MMIO_GETTEMP = @as(u32, 131072);
pub const MMIO_DIRTY = @as(u32, 268435456);
pub const MMIO_READ = @as(u32, 0);
pub const MMIO_WRITE = @as(u32, 1);
pub const MMIO_READWRITE = @as(u32, 2);
pub const MMIO_COMPAT = @as(u32, 0);
pub const MMIO_EXCLUSIVE = @as(u32, 16);
pub const MMIO_DENYWRITE = @as(u32, 32);
pub const MMIO_DENYREAD = @as(u32, 48);
pub const MMIO_DENYNONE = @as(u32, 64);
pub const MMIO_FHOPEN = @as(u32, 16);
pub const MMIO_EMPTYBUF = @as(u32, 16);
pub const MMIO_TOUPPER = @as(u32, 16);
pub const MMIO_INSTALLPROC = @as(u32, 65536);
pub const MMIO_GLOBALPROC = @as(u32, 268435456);
pub const MMIO_REMOVEPROC = @as(u32, 131072);
pub const MMIO_UNICODEPROC = @as(u32, 16777216);
pub const MMIO_FINDPROC = @as(u32, 262144);
pub const MMIO_FINDCHUNK = @as(u32, 16);
pub const MMIO_FINDRIFF = @as(u32, 32);
pub const MMIO_FINDLIST = @as(u32, 64);
pub const MMIO_CREATERIFF = @as(u32, 32);
pub const MMIO_CREATELIST = @as(u32, 64);
pub const MMIOM_SEEK = @as(u32, 2);
pub const MMIOM_OPEN = @as(u32, 3);
pub const MMIOM_CLOSE = @as(u32, 4);
pub const MMIOM_WRITEFLUSH = @as(u32, 5);
pub const MMIOM_RENAME = @as(u32, 6);
pub const MMIOM_USER = @as(u32, 32768);
pub const SEEK_SET = @as(u32, 0);
pub const SEEK_CUR = @as(u32, 1);
pub const SEEK_END = @as(u32, 2);
pub const MMIO_DEFAULTBUFFER = @as(u32, 8192);
pub const TIMERR_NOERROR = @as(u32, 0);
pub const TIMERR_NOCANDO = @as(u32, 97);
pub const TIMERR_STRUCT = @as(u32, 129);

//--------------------------------------------------------------------------------
// Section: Types (252)
//--------------------------------------------------------------------------------
pub const LPWAVECALLBACK = fn(
    hdrvr: HDRVR,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPMIDICALLBACK = fn(
    hdrvr: HDRVR,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ACMSTREAMHEADER = extern struct {
    cbStruct: u32,
    fdwStatus: u32,
    dwUser: usize,
    pbSrc: *u8,
    cbSrcLength: u32,
    cbSrcLengthUsed: u32,
    dwSrcUser: usize,
    pbDst: *u8,
    cbDstLength: u32,
    cbDstLengthUsed: u32,
    dwDstUser: usize,
    dwReservedDriver: [15]u32,
};

}, else => struct { } };

pub const HMIDI = ?*opaque{};

pub const HMIDIIN = ?*opaque{};

pub const HMIDIOUT = ?*opaque{};

pub const HMIDISTRM = ?*opaque{};

pub const HMIXER = ?*opaque{};

pub const HMIXEROBJ = ?*opaque{};

pub const HWAVE = ?*opaque{};

pub const HWAVEOUT = ?*opaque{};

pub const HWAVEIN = ?*opaque{};

pub const HMMIO = ?*opaque{};

pub const HDRVR = ?*opaque{};

pub const HACMDRIVERID = ?*opaque{};

pub const HACMDRIVER = ?*opaque{};

pub const HACMSTREAM = ?*opaque{};

pub const HACMOBJ = ?*opaque{};

pub const HIC = ?*opaque{};

pub const HVIDEO = ?*opaque{};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ACMSTREAMHEADER = extern struct {
    cbStruct: u32,
    fdwStatus: u32,
    dwUser: usize,
    pbSrc: *u8,
    cbSrcLength: u32,
    cbSrcLengthUsed: u32,
    dwSrcUser: usize,
    pbDst: *u8,
    cbDstLength: u32,
    cbDstLengthUsed: u32,
    dwDstUser: usize,
    dwReservedDriver: [10]u32,
};

}, else => struct { } };

pub const WAVEFORMAT = extern struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
};

pub const PCMWAVEFORMAT = extern struct {
    wf: WAVEFORMAT,
    wBitsPerSample: u16,
};

pub const WAVEFORMATEX = extern struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
    wBitsPerSample: u16,
    cbSize: u16,
};

const CLSID_KSDATAFORMAT_SUBTYPE_PCM_Value = @import("../zig.zig").Guid.initString("00000001-0000-0010-8000-00aa00389b71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_PCM = &CLSID_KSDATAFORMAT_SUBTYPE_PCM_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT_Value = @import("../zig.zig").Guid.initString("00000003-0000-0010-8000-00aa00389b71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = &CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX_Value = @import("../zig.zig").Guid.initString("00000000-0000-0010-8000-00aa00389b71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX = &CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX_Value;

pub const WAVEFORMATEXTENSIBLE = extern struct {
    Format: WAVEFORMATEX,
    Samples: _Samples_e__Union,
    dwChannelMask: u32,
    SubFormat: Guid,
    const _Samples_e__Union = u32; // TODO: generate this nested type!
};

pub const ADPCMCOEFSET = extern struct {
    iCoef1: i16,
    iCoef2: i16,
};

pub const ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
    wNumCoef: u16,
    aCoef: ADPCMCOEFSET,
};

pub const DRMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wReserved: u16,
    ulContentId: u32,
    wfxSecure: WAVEFORMATEX,
};

pub const DVIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const IMAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const MEDIASPACEADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const SIERRAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const G723_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    cbExtraSize: u16,
    nAuxBlockSize: u16,
};

pub const DIGISTDWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DIGIFIXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DIALOGICOKIADPCMWAVEFORMAT = extern struct {
    ewf: WAVEFORMATEX,
};

pub const YAMAHA_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const SONARCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wCompType: u16,
};

pub const TRUESPEECHWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
    nSamplesPerBlock: u16,
    abReserved: [28]u8,
};

pub const ECHOSC1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const AUDIOFILE_AF36WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const APTXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const AUDIOFILE_AF10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DOLBYAC2WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    nAuxBitsCode: u16,
};

pub const GSM610WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const ADPCMEWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const CONTRESVQLPCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const DIGIREALWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const DIGIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const CONTRESCR10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const NMS_VBXADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const G721_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    nAuxBlockSize: u16,
};

pub const MSAUDIO1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
    wEncodeOptions: u16,
};

pub const WMAUDIO2WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    dwSamplesPerBlock: u32,
    wEncodeOptions: u16,
    dwSuperBlockAlign: u32,
};

pub const WMAUDIO3WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wValidBitsPerSample: u16,
    dwChannelMask: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    wEncodeOptions: u16,
    wReserved3: u16,
};

pub const CREATIVEADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const CREATIVEFASTSPEECH8WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const CREATIVEFASTSPEECH10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const FMTOWNS_SND_WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const OLIGSMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLICELPWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLISBCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLIOPRWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const CSIMAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const WAVEFILTER = extern struct {
    cbStruct: u32,
    dwFilterTag: u32,
    fdwFilter: u32,
    dwReserved: [5]u32,
};

pub const VOLUMEWAVEFILTER = extern struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
};

pub const ECHOWAVEFILTER = extern struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
    dwDelay: u32,
};

pub const s_RIFFWAVE_inst = extern struct {
    bUnshiftedNote: u8,
    chFineTune: CHAR,
    chGain: CHAR,
    bLowNote: u8,
    bHighNote: u8,
    bLowVelocity: u8,
    bHighVelocity: u8,
};

pub const EXBMINFOHEADER = extern struct {
    bmi: BITMAPINFOHEADER,
    biExtDataOffset: u32,
};

pub const JPEGINFOHEADER = extern struct {
    JPEGSize: u32,
    JPEGProcess: u32,
    JPEGColorSpaceID: u32,
    JPEGBitsPerSample: u32,
    JPEGHSubSampling: u32,
    JPEGVSubSampling: u32,
};

pub const MMTIME = extern struct {
    wType: u32,
    u: _u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const LPDRVCALLBACK = fn(
    hdrvr: HDRVR,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DRVCONFIGINFOEX = extern struct {
    dwDCISize: u32,
    lpszDCISectionName: [*:0]const u16,
    lpszDCIAliasName: [*:0]const u16,
    dnDevNode: u32,
};

pub const DRVCONFIGINFO = extern struct {
    dwDCISize: u32,
    lpszDCISectionName: [*:0]const u16,
    lpszDCIAliasName: [*:0]const u16,
};

pub const DRIVERPROC = fn(
    param0: usize,
    param1: HDRVR,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const DRIVERMSGPROC = fn(
    param0: u32,
    param1: u32,
    param2: usize,
    param3: usize,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPMMIOPROC = fn(
    lpmmioinfo: PSTR,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const MMIOINFO = extern struct {
    dwFlags: u32,
    fccIOProc: u32,
    pIOProc: LPMMIOPROC,
    wErrorRet: u32,
    htask: HTASK,
    cchBuffer: i32,
    pchBuffer: *i8,
    pchNext: *i8,
    pchEndRead: *i8,
    pchEndWrite: *i8,
    lBufOffset: i32,
    lDiskOffset: i32,
    adwInfo: [3]u32,
    dwReserved1: u32,
    dwReserved2: u32,
    hmmio: HMMIO,
};

pub const MMCKINFO = extern struct {
    ckid: u32,
    cksize: u32,
    fccType: u32,
    dwDataOffset: u32,
    dwFlags: u32,
};

pub const WAVEHDR = extern struct {
    lpData: PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: usize,
    dwFlags: u32,
    dwLoops: u32,
    lpNext: *WAVEHDR,
    reserved: usize,
};

pub const WAVEOUTCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEOUTCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIOUTCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIOUTCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwSupport: u32,
};

pub const MIDIINCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
};

pub const MIDIINCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIHDR = extern struct {
    lpData: PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: usize,
    dwFlags: u32,
    lpNext: *MIDIHDR,
    reserved: usize,
    dwOffset: u32,
    dwReserved: [8]usize,
};

pub const MIDIEVENT = extern struct {
    dwDeltaTime: u32,
    dwStreamID: u32,
    dwEvent: u32,
    dwParms: [1]u32,
};

pub const MIDISTRMBUFFVER = extern struct {
    dwVersion: u32,
    dwMid: u32,
    dwOEMVersion: u32,
};

pub const MIDIPROPTIMEDIV = extern struct {
    cbStruct: u32,
    dwTimeDiv: u32,
};

pub const MIDIPROPTEMPO = extern struct {
    cbStruct: u32,
    dwTempo: u32,
};

pub const AUXCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const AUXCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERLINEA = extern struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: usize,
    dwComponentType: MIXERLINE_COMPONENTTYPE,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Target: _Target_e__Struct,
    const _Target_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIXERLINEW = extern struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: usize,
    dwComponentType: MIXERLINE_COMPONENTTYPE,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Target: _Target_e__Struct,
    const _Target_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLA = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Bounds: _Bounds_e__Union,
    Metrics: _Metrics_e__Union,
    const _Bounds_e__Union = u32; // TODO: generate this nested type!
    const _Metrics_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLW = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Bounds: _Bounds_e__Union,
    Metrics: _Metrics_e__Union,
    const _Metrics_e__Union = u32; // TODO: generate this nested type!
    const _Bounds_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERLINECONTROLSA = extern struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: _Anonymous_e__Union,
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: *MIXERCONTROLA,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERLINECONTROLSW = extern struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: _Anonymous_e__Union,
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: *MIXERCONTROLW,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLDETAILS = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    cChannels: u32,
    Anonymous: _Anonymous_e__Union,
    cbDetails: u32,
    paDetails: *c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLDETAILS_LISTTEXTA = extern struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]CHAR,
};

pub const MIXERCONTROLDETAILS_LISTTEXTW = extern struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]u16,
};

pub const MIXERCONTROLDETAILS_BOOLEAN = extern struct {
    fValue: i32,
};

pub const MIXERCONTROLDETAILS_SIGNED = extern struct {
    lValue: i32,
};

pub const MIXERCONTROLDETAILS_UNSIGNED = extern struct {
    dwValue: u32,
};

pub const TIMECAPS = extern struct {
    wPeriodMin: u32,
    wPeriodMax: u32,
};

pub const JOYCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]CHAR,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]CHAR,
    szOEMVxD: [260]CHAR,
};

pub const JOYCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]u16,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]u16,
    szOEMVxD: [260]u16,
};

pub const JOYCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]CHAR,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]CHAR,
    szOEMVxD: [260]CHAR,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const JOYCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]u16,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]u16,
    szOEMVxD: [260]u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const JOYINFO = extern struct {
    wXpos: u32,
    wYpos: u32,
    wZpos: u32,
    wButtons: u32,
};

pub const JOYINFOEX = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwXpos: u32,
    dwYpos: u32,
    dwZpos: u32,
    dwRpos: u32,
    dwUpos: u32,
    dwVpos: u32,
    dwButtons: u32,
    dwButtonNumber: u32,
    dwPOV: u32,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const MCI_DGV_RECT_PARMS = extern struct {
    dwCallback: usize,
    rc: RECT,
};

pub const MCI_DGV_CAPTURE_PARMSA = extern struct {
    dwCallback: usize,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_CAPTURE_PARMSW = extern struct {
    dwCallback: usize,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_COPY_PARMS = extern struct {
    dwCallback: usize,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_CUE_PARMS = extern struct {
    dwCallback: usize,
    dwTo: u32,
};

pub const MCI_DGV_CUT_PARMS = extern struct {
    dwCallback: usize,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_DELETE_PARMS = extern struct {
    dwCallback: usize,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_INFO_PARMSA = extern struct {
    dwCallback: usize,
    lpstrReturn: PSTR,
    dwRetSize: u32,
    dwItem: u32,
};

pub const MCI_DGV_INFO_PARMSW = extern struct {
    dwCallback: usize,
    lpstrReturn: PWSTR,
    dwRetSize: u32,
    dwItem: u32,
};

pub const MCI_DGV_LIST_PARMSA = extern struct {
    dwCallback: usize,
    lpstrReturn: PSTR,
    dwLength: u32,
    dwNumber: u32,
    dwItem: u32,
    lpstrAlgorithm: PSTR,
};

pub const MCI_DGV_LIST_PARMSW = extern struct {
    dwCallback: usize,
    lpstrReturn: PWSTR,
    dwLength: u32,
    dwNumber: u32,
    dwItem: u32,
    lpstrAlgorithm: PWSTR,
};

pub const MCI_DGV_MONITOR_PARMS = extern struct {
    dwCallback: usize,
    dwSource: u32,
    dwMethod: u32,
};

pub const MCI_DGV_OPEN_PARMSA = extern struct {
    dwCallback: usize,
    wDeviceID: u32,
    lpstrDeviceType: PSTR,
    lpstrElementName: PSTR,
    lpstrAlias: PSTR,
    dwStyle: u32,
    hWndParent: HWND,
};

pub const MCI_DGV_OPEN_PARMSW = extern struct {
    dwCallback: usize,
    wDeviceID: u32,
    lpstrDeviceType: PWSTR,
    lpstrElementName: PWSTR,
    lpstrAlias: PWSTR,
    dwStyle: u32,
    hWndParent: HWND,
};

pub const MCI_DGV_PASTE_PARMS = extern struct {
    dwCallback: usize,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_QUALITY_PARMSA = extern struct {
    dwCallback: usize,
    dwItem: u32,
    lpstrName: PSTR,
    lpstrAlgorithm: u32,
    dwHandle: u32,
};

pub const MCI_DGV_QUALITY_PARMSW = extern struct {
    dwCallback: usize,
    dwItem: u32,
    lpstrName: PWSTR,
    lpstrAlgorithm: u32,
    dwHandle: u32,
};

pub const MCI_DGV_RECORD_PARMS = extern struct {
    dwCallback: usize,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_RESERVE_PARMSA = extern struct {
    dwCallback: usize,
    lpstrPath: PSTR,
    dwSize: u32,
};

pub const MCI_DGV_RESERVE_PARMSW = extern struct {
    dwCallback: usize,
    lpstrPath: PWSTR,
    dwSize: u32,
};

pub const MCI_DGV_RESTORE_PARMSA = extern struct {
    dwCallback: usize,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_RESTORE_PARMSW = extern struct {
    dwCallback: usize,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_SAVE_PARMSA = extern struct {
    dwCallback: usize,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_SAVE_PARMSW = extern struct {
    dwCallback: usize,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_SET_PARMS = extern struct {
    dwCallback: usize,
    dwTimeFormat: u32,
    dwAudio: u32,
    dwFileFormat: u32,
    dwSpeed: u32,
};

pub const MCI_DGV_SETAUDIO_PARMSA = extern struct {
    dwCallback: usize,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PSTR,
    lpstrQuality: PSTR,
};

pub const MCI_DGV_SETAUDIO_PARMSW = extern struct {
    dwCallback: usize,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PWSTR,
    lpstrQuality: PWSTR,
};

pub const MCI_DGV_SIGNAL_PARMS = extern struct {
    dwCallback: usize,
    dwPosition: u32,
    dwPeriod: u32,
    dwUserParm: u32,
};

pub const MCI_DGV_SETVIDEO_PARMSA = extern struct {
    dwCallback: usize,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PSTR,
    lpstrQuality: PSTR,
    dwSourceNumber: u32,
};

pub const MCI_DGV_SETVIDEO_PARMSW = extern struct {
    dwCallback: usize,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PWSTR,
    lpstrQuality: PWSTR,
    dwSourceNumber: u32,
};

pub const MCI_DGV_STATUS_PARMSA = extern struct {
    dwCallback: usize,
    dwReturn: usize,
    dwItem: u32,
    dwTrack: u32,
    lpstrDrive: PSTR,
    dwReference: u32,
};

pub const MCI_DGV_STATUS_PARMSW = extern struct {
    dwCallback: usize,
    dwReturn: usize,
    dwItem: u32,
    dwTrack: u32,
    lpstrDrive: PWSTR,
    dwReference: u32,
};

pub const MCI_DGV_STEP_PARMS = extern struct {
    dwCallback: usize,
    dwFrames: u32,
};

pub const MCI_DGV_UPDATE_PARMS = extern struct {
    dwCallback: usize,
    rc: RECT,
    hDC: HDC,
};

pub const MCI_DGV_WINDOW_PARMSA = extern struct {
    dwCallback: usize,
    hWnd: HWND,
    nCmdShow: u32,
    lpstrText: PSTR,
};

pub const MCI_DGV_WINDOW_PARMSW = extern struct {
    dwCallback: usize,
    hWnd: HWND,
    nCmdShow: u32,
    lpstrText: PWSTR,
};

pub const ACMDRIVERENUMCB = fn(
    hadid: HACMDRIVERID,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPACMDRIVERPROC = fn(
    param0: usize,
    param1: HACMDRIVERID,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const ACMDRIVERDETAILSA = extern struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: HICON,
    szShortName: [32]CHAR,
    szLongName: [128]CHAR,
    szCopyright: [80]CHAR,
    szLicensing: [128]CHAR,
    szFeatures: [512]CHAR,
};

pub const ACMDRIVERDETAILSW = extern struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: HICON,
    szShortName: [32]u16,
    szLongName: [128]u16,
    szCopyright: [80]u16,
    szLicensing: [128]u16,
    szFeatures: [512]u16,
};

pub const ACMFORMATTAGDETAILSA = extern struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]CHAR,
};

pub const ACMFORMATTAGDETAILSW = extern struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]u16,
};

pub const ACMFORMATTAGENUMCBA = fn(
    hadid: HACMDRIVERID,
    paftd: *ACMFORMATTAGDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATTAGENUMCBW = fn(
    hadid: HACMDRIVERID,
    paftd: *ACMFORMATTAGDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATDETAILSA = extern struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]CHAR,
};

pub const tACMFORMATDETAILSW = extern struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]u16,
};

pub const ACMFORMATENUMCBA = fn(
    hadid: HACMDRIVERID,
    pafd: *ACMFORMATDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATENUMCBW = fn(
    hadid: HACMDRIVERID,
    pafd: *tACMFORMATDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATCHOOSEHOOKPROCA = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEHOOKPROCW = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEA = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: [*:0]const u8,
    szFormatTag: [48]CHAR,
    szFormat: [128]CHAR,
    pszName: PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: *WAVEFORMATEX,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ACMFORMATCHOOSEHOOKPROCA,
};

pub const ACMFORMATCHOOSEW = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: [*:0]const u16,
    szFormatTag: [48]u16,
    szFormat: [128]u16,
    pszName: PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: *WAVEFORMATEX,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ACMFORMATCHOOSEHOOKPROCW,
};

pub const ACMFILTERTAGDETAILSA = extern struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]CHAR,
};

pub const ACMFILTERTAGDETAILSW = extern struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]u16,
};

pub const ACMFILTERTAGENUMCBA = fn(
    hadid: HACMDRIVERID,
    paftd: *ACMFILTERTAGDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERTAGENUMCBW = fn(
    hadid: HACMDRIVERID,
    paftd: *ACMFILTERTAGDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERDETAILSA = extern struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]CHAR,
};

pub const ACMFILTERDETAILSW = extern struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]u16,
};

pub const ACMFILTERENUMCBA = fn(
    hadid: HACMDRIVERID,
    pafd: *ACMFILTERDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERENUMCBW = fn(
    hadid: HACMDRIVERID,
    pafd: *ACMFILTERDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERCHOOSEHOOKPROCA = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEHOOKPROCW = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEA = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    pszTitle: [*:0]const u8,
    szFilterTag: [48]CHAR,
    szFilter: [128]CHAR,
    pszName: PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: *WAVEFILTER,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ACMFILTERCHOOSEHOOKPROCA,
};

pub const ACMFILTERCHOOSEW = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    pszTitle: [*:0]const u16,
    szFilterTag: [48]u16,
    szFilter: [128]u16,
    pszName: PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: *WAVEFILTER,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ACMFILTERCHOOSEHOOKPROCW,
};

pub const ICOPEN = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwVersion: u32,
    dwFlags: u32,
    dwError: LRESULT,
    pV1Reserved: *c_void,
    pV2Reserved: *c_void,
    dnDevNode: u32,
};

pub const ICINFO = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwVersion: u32,
    dwVersionICM: u32,
    szName: [16]u16,
    szDescription: [128]u16,
    szDriver: [128]u16,
};

pub const ICCOMPRESS = extern struct {
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lpOutput: *c_void,
    lpbiInput: *BITMAPINFOHEADER,
    lpInput: *c_void,
    lpckid: *u32,
    lpdwFlags: *u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: *BITMAPINFOHEADER,
    lpPrev: *c_void,
};

pub const ICCOMPRESSFRAMES = extern struct {
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lOutput: LPARAM,
    lpbiInput: *BITMAPINFOHEADER,
    lInput: LPARAM,
    lStartFrame: i32,
    lFrameCount: i32,
    lQuality: i32,
    lDataRate: i32,
    lKeyRate: i32,
    dwRate: u32,
    dwScale: u32,
    dwOverheadPerFrame: u32,
    dwReserved2: u32,
    GetData: isize,
    PutData: isize,
};

pub const ICSETSTATUSPROC = extern struct {
    dwFlags: u32,
    lParam: LPARAM,
    Status: isize,
};

pub const ICDECOMPRESS = extern struct {
    dwFlags: u32,
    lpbiInput: *BITMAPINFOHEADER,
    lpInput: *c_void,
    lpbiOutput: *BITMAPINFOHEADER,
    lpOutput: *c_void,
    ckid: u32,
};

pub const ICDECOMPRESSEX = extern struct {
    dwFlags: u32,
    lpbiSrc: *BITMAPINFOHEADER,
    lpSrc: *c_void,
    lpbiDst: *BITMAPINFOHEADER,
    lpDst: *c_void,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
};

pub const ICDRAWBEGIN = extern struct {
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
};

pub const ICDRAW = extern struct {
    dwFlags: u32,
    lpFormat: *c_void,
    lpData: *c_void,
    cbData: u32,
    lTime: i32,
};

pub const ICDRAWSUGGEST = extern struct {
    lpbiIn: *BITMAPINFOHEADER,
    lpbiSuggest: *BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    dxDst: i32,
    dyDst: i32,
    hicDecompressor: HIC,
};

pub const ICPALETTE = extern struct {
    dwFlags: u32,
    iStart: i32,
    iLen: i32,
    lppe: *PALETTEENTRY,
};

pub const COMPVARS = extern struct {
    cbSize: i32,
    dwFlags: u32,
    hic: HIC,
    fccType: u32,
    fccHandler: u32,
    lpbiIn: *BITMAPINFO,
    lpbiOut: *BITMAPINFO,
    lpBitsOut: *c_void,
    lpBitsPrev: *c_void,
    lFrame: i32,
    lKey: i32,
    lDataRate: i32,
    lQ: i32,
    lKeyCount: i32,
    lpState: *c_void,
    cbState: i32,
};

pub const DRAWDIBTIME = extern struct {
    timeCount: i32,
    timeDraw: i32,
    timeDecompress: i32,
    timeDither: i32,
    timeStretch: i32,
    timeBlt: i32,
    timeSetDIBits: i32,
};

pub const AVISTREAMINFOW = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: [64]u16,
};

pub const AVISTREAMINFOA = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: [64]CHAR,
};

pub const AVIFILEINFOW = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: [64]u16,
};

pub const AVIFILEINFOA = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: [64]CHAR,
};

pub const AVISAVECALLBACK = fn(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const AVICOMPRESSOPTIONS = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwKeyFrameEvery: u32,
    dwQuality: u32,
    dwBytesPerSecond: u32,
    dwFlags: u32,
    lpFormat: *c_void,
    cbFormat: u32,
    lpParms: *c_void,
    cbParms: u32,
    dwInterleaveEvery: u32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAVIStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IAVIStream,
            lParam1: LPARAM,
            lParam2: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Info: fn(
            self: *const IAVIStream,
            // TODO: what to do with BytesParamIndex 1?
            psi: *AVISTREAMINFOW,
            lSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSample: fn(
            self: *const IAVIStream,
            lPos: i32,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        ReadFormat: fn(
            self: *const IAVIStream,
            lPos: i32,
            // TODO: what to do with BytesParamIndex 2?
            lpFormat: ?*c_void,
            lpcbFormat: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IAVIStream,
            lPos: i32,
            // TODO: what to do with BytesParamIndex 2?
            lpFormat: *c_void,
            cbFormat: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: ?*c_void,
            cbBuffer: i32,
            plBytes: ?*i32,
            plSamples: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: *c_void,
            cbBuffer: i32,
            dwFlags: u32,
            plSampWritten: ?*i32,
            plBytesWritten: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadData: fn(
            self: *const IAVIStream,
            fcc: u32,
            // TODO: what to do with BytesParamIndex 2?
            lp: ?*c_void,
            lpcb: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteData: fn(
            self: *const IAVIStream,
            fcc: u32,
            // TODO: what to do with BytesParamIndex 2?
            lp: *c_void,
            cb: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: fn(
            self: *const IAVIStream,
            // TODO: what to do with BytesParamIndex 1?
            lpInfo: *AVISTREAMINFOW,
            cbInfo: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Create(self: *const T, lParam1: LPARAM, lParam2: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Create(@ptrCast(*const IAVIStream, self), lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Info(self: *const T, psi: *AVISTREAMINFOW, lSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Info(@ptrCast(*const IAVIStream, self), psi, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_FindSample(self: *const T, lPos: i32, lFlags: i32) callconv(.Inline) i32 {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).FindSample(@ptrCast(*const IAVIStream, self), lPos, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_ReadFormat(self: *const T, lPos: i32, lpFormat: ?*c_void, lpcbFormat: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).ReadFormat(@ptrCast(*const IAVIStream, self), lPos, lpFormat, lpcbFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_SetFormat(self: *const T, lPos: i32, lpFormat: *c_void, cbFormat: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).SetFormat(@ptrCast(*const IAVIStream, self), lPos, lpFormat, cbFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Read(self: *const T, lStart: i32, lSamples: i32, lpBuffer: ?*c_void, cbBuffer: i32, plBytes: ?*i32, plSamples: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Read(@ptrCast(*const IAVIStream, self), lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Write(self: *const T, lStart: i32, lSamples: i32, lpBuffer: *c_void, cbBuffer: i32, dwFlags: u32, plSampWritten: ?*i32, plBytesWritten: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Write(@ptrCast(*const IAVIStream, self), lStart, lSamples, lpBuffer, cbBuffer, dwFlags, plSampWritten, plBytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Delete(self: *const T, lStart: i32, lSamples: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Delete(@ptrCast(*const IAVIStream, self), lStart, lSamples);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_ReadData(self: *const T, fcc: u32, lp: ?*c_void, lpcb: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).ReadData(@ptrCast(*const IAVIStream, self), fcc, lp, lpcb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_WriteData(self: *const T, fcc: u32, lp: *c_void, cb: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).WriteData(@ptrCast(*const IAVIStream, self), fcc, lp, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_SetInfo(self: *const T, lpInfo: *AVISTREAMINFOW, cbInfo: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).SetInfo(@ptrCast(*const IAVIStream, self), lpInfo, cbInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAVIStreaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: fn(
            self: *const IAVIStreaming,
            lStart: i32,
            lEnd: i32,
            lRate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IAVIStreaming,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStreaming_Begin(self: *const T, lStart: i32, lEnd: i32, lRate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStreaming.VTable, self.vtable).Begin(@ptrCast(*const IAVIStreaming, self), lStart, lEnd, lRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStreaming_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStreaming.VTable, self.vtable).End(@ptrCast(*const IAVIStreaming, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAVIEditStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cut: fn(
            self: *const IAVIEditStream,
            plStart: *i32,
            plLength: *i32,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IAVIEditStream,
            plStart: *i32,
            plLength: *i32,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const IAVIEditStream,
            plPos: *i32,
            plLength: *i32,
            pstream: *IAVIStream,
            lStart: i32,
            lEnd: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IAVIEditStream,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: fn(
            self: *const IAVIEditStream,
            // TODO: what to do with BytesParamIndex 1?
            lpInfo: *AVISTREAMINFOW,
            cbInfo: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Cut(self: *const T, plStart: *i32, plLength: *i32, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Cut(@ptrCast(*const IAVIEditStream, self), plStart, plLength, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Copy(self: *const T, plStart: *i32, plLength: *i32, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Copy(@ptrCast(*const IAVIEditStream, self), plStart, plLength, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Paste(self: *const T, plPos: *i32, plLength: *i32, pstream: *IAVIStream, lStart: i32, lEnd: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Paste(@ptrCast(*const IAVIEditStream, self), plPos, plLength, pstream, lStart, lEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Clone(self: *const T, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Clone(@ptrCast(*const IAVIEditStream, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_SetInfo(self: *const T, lpInfo: *AVISTREAMINFOW, cbInfo: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).SetInfo(@ptrCast(*const IAVIEditStream, self), lpInfo, cbInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAVIPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersistFile.VTable,
        Reserved1: fn(
            self: *const IAVIPersistFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistFile.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIPersistFile_Reserved1(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIPersistFile.VTable, self.vtable).Reserved1(@ptrCast(*const IAVIPersistFile, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAVIFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Info: fn(
            self: *const IAVIFile,
            // TODO: what to do with BytesParamIndex 1?
            pfi: *AVIFILEINFOW,
            lSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAVIFile,
            ppStream: **IAVIStream,
            fccType: u32,
            lParam: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStream: fn(
            self: *const IAVIFile,
            ppStream: **IAVIStream,
            psi: *AVISTREAMINFOW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteData: fn(
            self: *const IAVIFile,
            ckid: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpData: *c_void,
            cbData: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadData: fn(
            self: *const IAVIFile,
            ckid: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpData: *c_void,
            lpcbData: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndRecord: fn(
            self: *const IAVIFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteStream: fn(
            self: *const IAVIFile,
            fccType: u32,
            lParam: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_Info(self: *const T, pfi: *AVIFILEINFOW, lSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).Info(@ptrCast(*const IAVIFile, self), pfi, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_GetStream(self: *const T, ppStream: **IAVIStream, fccType: u32, lParam: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).GetStream(@ptrCast(*const IAVIFile, self), ppStream, fccType, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_CreateStream(self: *const T, ppStream: **IAVIStream, psi: *AVISTREAMINFOW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).CreateStream(@ptrCast(*const IAVIFile, self), ppStream, psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_WriteData(self: *const T, ckid: u32, lpData: *c_void, cbData: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).WriteData(@ptrCast(*const IAVIFile, self), ckid, lpData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_ReadData(self: *const T, ckid: u32, lpData: *c_void, lpcbData: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).ReadData(@ptrCast(*const IAVIFile, self), ckid, lpData, lpcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_EndRecord(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).EndRecord(@ptrCast(*const IAVIFile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_DeleteStream(self: *const T, fccType: u32, lParam: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).DeleteStream(@ptrCast(*const IAVIFile, self), fccType, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IGetFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrame: fn(
            self: *const IGetFrame,
            lPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        Begin: fn(
            self: *const IGetFrame,
            lStart: i32,
            lEnd: i32,
            lRate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IGetFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IGetFrame,
            lpbi: *BITMAPINFOHEADER,
            lpBits: ?*c_void,
            x: i32,
            y: i32,
            dx: i32,
            dy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_GetFrame(self: *const T, lPos: i32) callconv(.Inline) *c_void {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).GetFrame(@ptrCast(*const IGetFrame, self), lPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_Begin(self: *const T, lStart: i32, lEnd: i32, lRate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).Begin(@ptrCast(*const IGetFrame, self), lStart, lEnd, lRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).End(@ptrCast(*const IGetFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_SetFormat(self: *const T, lpbi: *BITMAPINFOHEADER, lpBits: ?*c_void, x: i32, y: i32, dx: i32, dy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).SetFormat(@ptrCast(*const IGetFrame, self), lpbi, lpBits, x, y, dx, dy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VIDEOHDR = extern struct {
    lpData: *u8,
    dwBufferLength: u32,
    dwBytesUsed: u32,
    dwTimeCaptured: u32,
    dwUser: usize,
    dwFlags: u32,
    dwReserved: [4]usize,
};

pub const channel_caps_tag = extern struct {
    dwFlags: u32,
    dwSrcRectXMod: u32,
    dwSrcRectYMod: u32,
    dwSrcRectWidthMod: u32,
    dwSrcRectHeightMod: u32,
    dwDstRectXMod: u32,
    dwDstRectYMod: u32,
    dwDstRectWidthMod: u32,
    dwDstRectHeightMod: u32,
};

pub const CAPDRIVERCAPS = extern struct {
    wDeviceIndex: u32,
    fHasOverlay: BOOL,
    fHasDlgVideoSource: BOOL,
    fHasDlgVideoFormat: BOOL,
    fHasDlgVideoDisplay: BOOL,
    fCaptureInitialized: BOOL,
    fDriverSuppliesPalettes: BOOL,
    hVideoIn: HANDLE,
    hVideoOut: HANDLE,
    hVideoExtIn: HANDLE,
    hVideoExtOut: HANDLE,
};

pub const CAPSTATUS = extern struct {
    uiImageWidth: u32,
    uiImageHeight: u32,
    fLiveWindow: BOOL,
    fOverlayWindow: BOOL,
    fScale: BOOL,
    ptScroll: POINT,
    fUsingDefaultPalette: BOOL,
    fAudioHardware: BOOL,
    fCapFileExists: BOOL,
    dwCurrentVideoFrame: u32,
    dwCurrentVideoFramesDropped: u32,
    dwCurrentWaveSamples: u32,
    dwCurrentTimeElapsedMS: u32,
    hPalCurrent: HPALETTE,
    fCapturingNow: BOOL,
    dwReturn: u32,
    wNumVideoAllocated: u32,
    wNumAudioAllocated: u32,
};

pub const CAPTUREPARMS = extern struct {
    dwRequestMicroSecPerFrame: u32,
    fMakeUserHitOKToCapture: BOOL,
    wPercentDropForError: u32,
    fYield: BOOL,
    dwIndexSize: u32,
    wChunkGranularity: u32,
    fUsingDOSMemory: BOOL,
    wNumVideoRequested: u32,
    fCaptureAudio: BOOL,
    wNumAudioRequested: u32,
    vKeyAbort: u32,
    fAbortLeftMouse: BOOL,
    fAbortRightMouse: BOOL,
    fLimitEnabled: BOOL,
    wTimeLimit: u32,
    fMCIControl: BOOL,
    fStepMCIDevice: BOOL,
    dwMCIStartTime: u32,
    dwMCIStopTime: u32,
    fStepCaptureAt2x: BOOL,
    wStepCaptureAverageFrames: u32,
    dwAudioBufferSize: u32,
    fDisableWriteCache: BOOL,
    AVStreamMaster: u32,
};

pub const CAPINFOCHUNK = extern struct {
    fccInfoID: u32,
    lpData: *c_void,
    cbData: i32,
};

pub const CAPYIELDCALLBACK = fn(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPSTATUSCALLBACKW = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPERRORCALLBACKW = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPSTATUSCALLBACKA = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPERRORCALLBACKA = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPVIDEOCALLBACK = fn(
    hWnd: HWND,
    lpVHdr: *VIDEOHDR,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPWAVECALLBACK = fn(
    hWnd: HWND,
    lpWHdr: *WAVEHDR,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPCONTROLCALLBACK = fn(
    hWnd: HWND,
    nState: i32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const DRVM_IOCTL_DATA = extern struct {
    dwSize: u32,
    dwCmd: u32,
};

pub const WAVEOPENDESC = extern struct {
    hWave: HWAVE,
    lpFormat: *WAVEFORMAT,
    dwCallback: usize,
    dwInstance: usize,
    uMappedDeviceID: u32,
    dnDevNode: usize,
};

pub const midiopenstrmid_tag = extern struct {
    dwStreamID: u32,
    uDeviceID: u32,
};

pub const tMIXEROPENDESC = extern struct {
    hmx: HMIXER,
    pReserved0: *c_void,
    dwCallback: usize,
    dwInstance: usize,
    dnDevNode: usize,
};

pub const TIMEREVENT = extern struct {
    wDelay: u16,
    wResolution: u16,
    lpFunction: LPTIMECALLBACK,
    dwUser: u32,
    wFlags: u16,
    wReserved1: u16,
};

pub const joypos_tag = extern struct {
    dwX: u32,
    dwY: u32,
    dwZ: u32,
    dwR: u32,
    dwU: u32,
    dwV: u32,
};

pub const joyrange_tag = extern struct {
    jpMin: joypos_tag,
    jpMax: joypos_tag,
    jpCenter: joypos_tag,
};

pub const joyreguservalues_tag = extern struct {
    dwTimeOut: u32,
    jrvRanges: joyrange_tag,
    jpDeadZone: joypos_tag,
};

pub const joyreghwsettings_tag = extern struct {
    dwFlags: u32,
    dwNumButtons: u32,
};

pub const joyreghwconfig_tag = extern struct {
    hws: joyreghwsettings_tag,
    dwUsageSettings: u32,
    hwv: JOYREGHWVALUES,
    dwType: u32,
    dwReserved: u32,
};

pub const joycalibrate_tag = extern struct {
    wXbase: u16,
    wXdelta: u16,
    wYbase: u16,
    wYdelta: u16,
    wZbase: u16,
    wZdelta: u16,
};

pub const LPJOYDEVMSGPROC = fn(
    param0: u32,
    param1: u32,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MCI_OPEN_DRIVER_PARMS = extern struct {
    wDeviceID: u32,
    lpstrParams: [*:0]const u16,
    wCustomCommandTable: u32,
    wType: u32,
};

pub const LPTASKCALLBACK = fn(
    dwInst: usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MIDI_OPEN_TYPE = extern enum(u32) {
    CALLBACK_TYPEMASK = 458752,
    CALLBACK_NULL = 0,
    CALLBACK_WINDOW = 65536,
    CALLBACK_TASK = 131072,
    CALLBACK_FUNCTION = 196608,
    CALLBACK_THREAD = 131072,
    CALLBACK_EVENT = 327680,
    MIDI_IO_STATUS = 32,
    _,
};
// TODO: enum 'MIDI_OPEN_TYPE' has known issues with its value aliases

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const WAVE_OPEN_TYPE = extern enum(u32) {
    CALLBACK_TYPEMASK = 458752,
    CALLBACK_NULL = 0,
    CALLBACK_WINDOW = 65536,
    CALLBACK_TASK = 131072,
    CALLBACK_FUNCTION = 196608,
    CALLBACK_THREAD = 131072,
    CALLBACK_EVENT = 327680,
    WAVE_FORMAT_QUERY = 1,
    WAVE_ALLOWSYNC = 2,
    WAVE_MAPPED = 4,
    WAVE_FORMAT_DIRECT = 8,
    WAVE_FORMAT_DIRECT_QUERY = 9,
    WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 16,
    _,
};
pub const CALLBACK_TYPEMASK = WAVE_OPEN_TYPE.CALLBACK_TYPEMASK;
pub const CALLBACK_NULL = WAVE_OPEN_TYPE.CALLBACK_NULL;
pub const CALLBACK_WINDOW = WAVE_OPEN_TYPE.CALLBACK_WINDOW;
pub const CALLBACK_TASK = WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_FUNCTION = WAVE_OPEN_TYPE.CALLBACK_FUNCTION;
pub const CALLBACK_THREAD = WAVE_OPEN_TYPE.CALLBACK_THREAD;
pub const CALLBACK_EVENT = WAVE_OPEN_TYPE.CALLBACK_EVENT;
pub const WAVE_FORMAT_QUERY = WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY;
pub const WAVE_ALLOWSYNC = WAVE_OPEN_TYPE.WAVE_ALLOWSYNC;
pub const WAVE_MAPPED = WAVE_OPEN_TYPE.WAVE_MAPPED;
pub const WAVE_FORMAT_DIRECT = WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT;
pub const WAVE_FORMAT_DIRECT_QUERY = WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE;

pub const MIXERLINE_COMPONENTTYPE = extern enum(u32) {
    DST_DIGITAL = 1,
    DST_HEADPHONES = 5,
    DST_LINE = 2,
    DST_MONITOR = 3,
    DST_SPEAKERS = 4,
    DST_TELEPHONE = 6,
    DST_UNDEFINED = 0,
    DST_VOICEIN = 8,
    DST_WAVEIN = 7,
    SRC_ANALOG = 4106,
    SRC_AUXILIARY = 4105,
    SRC_COMPACTDISC = 4101,
    SRC_DIGITAL = 4097,
    SRC_LINE = 4098,
    SRC_MICROPHONE = 4099,
    SRC_PCSPEAKER = 4103,
    SRC_SYNTHESIZER = 4100,
    SRC_TELEPHONE = 4102,
    SRC_UNDEFINED = 4096,
    SRC_WAVEOUT = 4104,
};
pub const MIXERLINE_COMPONENTTYPE_DST_DIGITAL = MIXERLINE_COMPONENTTYPE.DST_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = MIXERLINE_COMPONENTTYPE.DST_HEADPHONES;
pub const MIXERLINE_COMPONENTTYPE_DST_LINE = MIXERLINE_COMPONENTTYPE.DST_LINE;
pub const MIXERLINE_COMPONENTTYPE_DST_MONITOR = MIXERLINE_COMPONENTTYPE.DST_MONITOR;
pub const MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = MIXERLINE_COMPONENTTYPE.DST_SPEAKERS;
pub const MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = MIXERLINE_COMPONENTTYPE.DST_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = MIXERLINE_COMPONENTTYPE.DST_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_DST_VOICEIN = MIXERLINE_COMPONENTTYPE.DST_VOICEIN;
pub const MIXERLINE_COMPONENTTYPE_DST_WAVEIN = MIXERLINE_COMPONENTTYPE.DST_WAVEIN;
pub const MIXERLINE_COMPONENTTYPE_SRC_ANALOG = MIXERLINE_COMPONENTTYPE.SRC_ANALOG;
pub const MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = MIXERLINE_COMPONENTTYPE.SRC_AUXILIARY;
pub const MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = MIXERLINE_COMPONENTTYPE.SRC_COMPACTDISC;
pub const MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = MIXERLINE_COMPONENTTYPE.SRC_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_SRC_LINE = MIXERLINE_COMPONENTTYPE.SRC_LINE;
pub const MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = MIXERLINE_COMPONENTTYPE.SRC_MICROPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = MIXERLINE_COMPONENTTYPE.SRC_PCSPEAKER;
pub const MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = MIXERLINE_COMPONENTTYPE.SRC_SYNTHESIZER;
pub const MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = MIXERLINE_COMPONENTTYPE.SRC_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = MIXERLINE_COMPONENTTYPE.SRC_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = MIXERLINE_COMPONENTTYPE.SRC_WAVEOUT;


//--------------------------------------------------------------------------------
// Section: Functions (305)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyConfigChanged(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn CloseDriver(
    hDriver: HDRVR,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn OpenDriver(
    szDriverName: [*:0]const u16,
    szSectionName: [*:0]const u16,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HDRVR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn SendDriverMessage(
    hDriver: HDRVR,
    message: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn DrvGetModuleHandle(
    hDriver: HDRVR,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn GetDriverModuleHandle(
    hDriver: HDRVR,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn DefDriverProc(
    dwDriverIdentifier: usize,
    hdrvr: HDRVR,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn DriverCallback(
    dwCallback: usize,
    dwFlags: u32,
    hDevice: HDRVR,
    dwMsg: u32,
    dwUser: usize,
    dwParam1: usize,
    dwParam2: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-mm-misc-l1-1-1" fn sndOpenSound(
    EventName: [*:0]const u16,
    AppName: [*:0]const u16,
    Flags: i32,
    FileHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINMM" fn mmDrvInstall(
    hDriver: HDRVR,
    wszDrvEntry: [*:0]const u16,
    drvMessage: DRIVERMSGPROC,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioStringToFOURCCA(
    sz: [*:0]const u8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioStringToFOURCCW(
    sz: [*:0]const u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioInstallIOProcA(
    fccIOProc: u32,
    pIOProc: ?LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioInstallIOProcW(
    fccIOProc: u32,
    pIOProc: ?LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioOpenA(
    pszFileName: ?*[128]u8,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) HMMIO;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioOpenW(
    pszFileName: ?*[128]u16,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) HMMIO;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioRenameA(
    pszFileName: [*:0]const u8,
    pszNewFileName: [*:0]const u8,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioRenameW(
    pszFileName: [*:0]const u16,
    pszNewFileName: [*:0]const u16,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioClose(
    hmmio: HMMIO,
    fuClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioRead(
    hmmio: HMMIO,
    // TODO: what to do with BytesParamIndex 2?
    pch: *i8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioWrite(
    hmmio: HMMIO,
    // TODO: what to do with BytesParamIndex 2?
    pch: [*:0]const u8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioSeek(
    hmmio: HMMIO,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioGetInfo(
    hmmio: HMMIO,
    pmmioinfo: *MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioSetInfo(
    hmmio: HMMIO,
    pmmioinfo: *MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioSetBuffer(
    hmmio: HMMIO,
    pchBuffer: ?[*:0]u8,
    cchBuffer: i32,
    fuBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioFlush(
    hmmio: HMMIO,
    fuFlush: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioAdvance(
    hmmio: HMMIO,
    pmmioinfo: ?*MMIOINFO,
    fuAdvance: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioSendMessage(
    hmmio: HMMIO,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioDescend(
    hmmio: HMMIO,
    pmmcki: *MMCKINFO,
    pmmckiParent: ?*const MMCKINFO,
    fuDescend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioAscend(
    hmmio: HMMIO,
    pmmcki: *MMCKINFO,
    fuAscend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mmioCreateChunk(
    hmmio: HMMIO,
    pmmcki: *MMCKINFO,
    fuCreate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn sndPlaySoundA(
    pszSound: ?[*:0]const u8,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn sndPlaySoundW(
    pszSound: ?[*:0]const u16,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundA(
    pszSound: ?[*:0]const u8,
    hmod: isize,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundW(
    pszSound: ?[*:0]const u16,
    hmod: isize,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsA(
    uDeviceID: usize,
    pwoc: *WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsW(
    uDeviceID: usize,
    pwoc: *WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetVolume(
    hwo: HWAVEOUT,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetVolume(
    hwo: HWAVEOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutOpen(
    phwo: ?*HWAVEOUT,
    uDeviceID: u32,
    pwfx: *WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutClose(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutPrepareHeader(
    hwo: HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutUnprepareHeader(
    hwo: HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutWrite(
    hwo: HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutPause(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutRestart(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutReset(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutBreakLoop(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPosition(
    hwo: HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: *MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPitch(
    hwo: HWAVEOUT,
    pdwPitch: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetPitch(
    hwo: HWAVEOUT,
    dwPitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPlaybackRate(
    hwo: HWAVEOUT,
    pdwRate: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetPlaybackRate(
    hwo: HWAVEOUT,
    dwRate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetID(
    hwo: HWAVEOUT,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutMessage(
    hwo: HWAVEOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: *WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: *WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInOpen(
    phwi: ?*HWAVEIN,
    uDeviceID: u32,
    pwfx: *WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInClose(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInPrepareHeader(
    hwi: HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInUnprepareHeader(
    hwi: HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInAddBuffer(
    hwi: HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: *WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInStart(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInStop(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInReset(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetPosition(
    hwi: HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: *MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetID(
    hwi: HWAVEIN,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInMessage(
    hwi: HWAVEIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamOpen(
    phms: *HMIDISTRM,
    puDeviceID: [*]u32,
    cMidi: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamClose(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamProperty(
    hms: HMIDISTRM,
    lppropdata: *u8,
    dwProperty: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamPosition(
    hms: HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    lpmmt: *MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamOut(
    hms: HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamPause(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamRestart(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamStop(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiConnect(
    hmi: HMIDI,
    hmo: HMIDIOUT,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiDisconnect(
    hmi: HMIDI,
    hmo: HMIDIOUT,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: *MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: *MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetVolume(
    hmo: HMIDIOUT,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutSetVolume(
    hmo: HMIDIOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutOpen(
    phmo: *HMIDIOUT,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutClose(
    hmo: HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutPrepareHeader(
    hmo: HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutUnprepareHeader(
    hmo: HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutShortMsg(
    hmo: HMIDIOUT,
    dwMsg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutLongMsg(
    hmo: HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutReset(
    hmo: HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutCachePatches(
    hmo: HMIDIOUT,
    uBank: u32,
    pwpa: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutCacheDrumPatches(
    hmo: HMIDIOUT,
    uPatch: u32,
    pwkya: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetID(
    hmo: HMIDIOUT,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutMessage(
    hmo: HMIDIOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: *MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: *MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInOpen(
    phmi: *HMIDIIN,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInClose(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInPrepareHeader(
    hmi: HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInUnprepareHeader(
    hmi: HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInAddBuffer(
    hmi: HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: *MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInStart(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInStop(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInReset(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetID(
    hmi: HMIDIIN,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInMessage(
    hmi: HMIDIIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: *AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: *AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxSetVolume(
    uDeviceID: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetVolume(
    uDeviceID: u32,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxOutMessage(
    uDeviceID: u32,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetDevCapsA(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: *MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetDevCapsW(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: *MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerOpen(
    phmx: ?*isize,
    uMxId: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerClose(
    hmx: HMIXER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerMessage(
    hmx: HMIXER,
    uMsg: u32,
    dwParam1: usize,
    dwParam2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineInfoA(
    hmxobj: HMIXEROBJ,
    pmxl: *MIXERLINEA,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineInfoW(
    hmxobj: HMIXEROBJ,
    pmxl: *MIXERLINEW,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetID(
    hmxobj: HMIXEROBJ,
    puMxId: *u32,
    fdwId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineControlsA(
    hmxobj: HMIXEROBJ,
    pmxlc: *MIXERLINECONTROLSA,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineControlsW(
    hmxobj: HMIXEROBJ,
    pmxlc: *MIXERLINECONTROLSW,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetControlDetailsA(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetControlDetailsW(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerSetControlDetails(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn timeGetSystemTime(
    // TODO: what to do with BytesParamIndex 1?
    pmmt: *MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn timeGetTime(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn timeGetDevCaps(
    // TODO: what to do with BytesParamIndex 1?
    ptc: *TIMECAPS,
    cbtc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn timeBeginPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn timeEndPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyGetPosEx(
    uJoyID: u32,
    pji: *JOYINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetDevCapsA(
    uJoyID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pjc: *JOYCAPSA,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyGetDevCapsW(
    uJoyID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pjc: *JOYCAPSW,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyGetPos(
    uJoyID: u32,
    pji: *JOYINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyGetThreshold(
    uJoyID: u32,
    puThreshold: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joyReleaseCapture(
    uJoyID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joySetCapture(
    hwnd: HWND,
    uJoyID: u32,
    uPeriod: u32,
    fChanged: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn joySetThreshold(
    uJoyID: u32,
    uThreshold: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmGetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmMetrics(
    hao: HACMOBJ,
    uMetric: u32,
    pMetric: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverEnum(
    fnCallback: ACMDRIVERENUMCB,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverID(
    hao: HACMOBJ,
    phadid: *isize,
    fdwDriverID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverAddA(
    phadid: *isize,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverAddW(
    phadid: *isize,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverRemove(
    hadid: HACMDRIVERID,
    fdwRemove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverOpen(
    phad: *isize,
    hadid: HACMDRIVERID,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverClose(
    had: HACMDRIVER,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverMessage(
    had: HACMDRIVER,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverPriority(
    hadid: HACMDRIVERID,
    dwPriority: u32,
    fdwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverDetailsA(
    hadid: HACMDRIVERID,
    padd: *ACMDRIVERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverDetailsW(
    hadid: HACMDRIVERID,
    padd: *ACMDRIVERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagDetailsA(
    had: HACMDRIVER,
    paftd: *ACMFORMATTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagDetailsW(
    had: HACMDRIVER,
    paftd: *ACMFORMATTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagEnumA(
    had: HACMDRIVER,
    paftd: *ACMFORMATTAGDETAILSA,
    fnCallback: ACMFORMATTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagEnumW(
    had: HACMDRIVER,
    paftd: *ACMFORMATTAGDETAILSW,
    fnCallback: ACMFORMATTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatDetailsA(
    had: HACMDRIVER,
    pafd: *ACMFORMATDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatDetailsW(
    had: HACMDRIVER,
    pafd: *tACMFORMATDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatEnumA(
    had: HACMDRIVER,
    pafd: *ACMFORMATDETAILSA,
    fnCallback: ACMFORMATENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatEnumW(
    had: HACMDRIVER,
    pafd: *tACMFORMATDETAILSW,
    fnCallback: ACMFORMATENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatSuggest(
    had: HACMDRIVER,
    pwfxSrc: *WAVEFORMATEX,
    pwfxDst: *WAVEFORMATEX,
    cbwfxDst: u32,
    fdwSuggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatChooseA(
    pafmtc: *ACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatChooseW(
    pafmtc: *ACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagDetailsA(
    had: HACMDRIVER,
    paftd: *ACMFILTERTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagDetailsW(
    had: HACMDRIVER,
    paftd: *ACMFILTERTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagEnumA(
    had: HACMDRIVER,
    paftd: *ACMFILTERTAGDETAILSA,
    fnCallback: ACMFILTERTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagEnumW(
    had: HACMDRIVER,
    paftd: *ACMFILTERTAGDETAILSW,
    fnCallback: ACMFILTERTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterDetailsA(
    had: HACMDRIVER,
    pafd: *ACMFILTERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterDetailsW(
    had: HACMDRIVER,
    pafd: *ACMFILTERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterEnumA(
    had: HACMDRIVER,
    pafd: *ACMFILTERDETAILSA,
    fnCallback: ACMFILTERENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterEnumW(
    had: HACMDRIVER,
    pafd: *ACMFILTERDETAILSW,
    fnCallback: ACMFILTERENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterChooseA(
    pafltrc: *ACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterChooseW(
    pafltrc: *ACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamOpen(
    phas: *isize,
    had: HACMDRIVER,
    pwfxSrc: *WAVEFORMATEX,
    pwfxDst: *WAVEFORMATEX,
    pwfltr: *WAVEFILTER,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamClose(
    has: HACMSTREAM,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamSize(
    has: HACMSTREAM,
    cbInput: u32,
    pdwOutputBytes: *u32,
    fdwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamReset(
    has: HACMSTREAM,
    fdwReset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamMessage(
    has: HACMSTREAM,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamConvert(
    has: HACMSTREAM,
    pash: *ACMSTREAMHEADER,
    fdwConvert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamPrepareHeader(
    has: HACMSTREAM,
    pash: *ACMSTREAMHEADER,
    fdwPrepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamUnprepareHeader(
    has: HACMSTREAM,
    pash: *ACMSTREAMHEADER,
    fdwUnprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn VideoForWindowsVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICInfo(
    fccType: u32,
    fccHandler: u32,
    lpicinfo: *ICINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICInstall(
    fccType: u32,
    fccHandler: u32,
    lParam: LPARAM,
    szDesc: PSTR,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICRemove(
    fccType: u32,
    fccHandler: u32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICGetInfo(
    hic: HIC,
    // TODO: what to do with BytesParamIndex 2?
    picinfo: *ICINFO,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICOpen(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
) callconv(@import("std").os.windows.WINAPI) HIC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICOpenFunction(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
    lpfnHandler: FARPROC,
) callconv(@import("std").os.windows.WINAPI) HIC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICClose(
    hic: HIC,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICSendMessage(
    hic: HIC,
    msg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICCompress(
    hic: HIC,
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lpData: *c_void,
    lpbiInput: *BITMAPINFOHEADER,
    lpBits: *c_void,
    lpckid: ?*u32,
    lpdwFlags: ?*u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: ?*BITMAPINFOHEADER,
    lpPrev: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICDecompress(
    hic: HIC,
    dwFlags: u32,
    lpbiFormat: *BITMAPINFOHEADER,
    lpData: *c_void,
    lpbi: *BITMAPINFOHEADER,
    lpBits: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICDrawBegin(
    hic: HIC,
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICDraw(
    hic: HIC,
    dwFlags: u32,
    lpFormat: *c_void,
    // TODO: what to do with BytesParamIndex 4?
    lpData: ?*c_void,
    cbData: u32,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICLocate(
    fccType: u32,
    fccHandler: u32,
    lpbiIn: *BITMAPINFOHEADER,
    lpbiOut: ?*BITMAPINFOHEADER,
    wFlags: u16,
) callconv(@import("std").os.windows.WINAPI) HIC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICGetDisplayFormat(
    hic: HIC,
    lpbiIn: *BITMAPINFOHEADER,
    lpbiOut: *BITMAPINFOHEADER,
    BitDepth: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) HIC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICImageCompress(
    hic: HIC,
    uiFlags: u32,
    lpbiIn: *BITMAPINFO,
    lpBits: *c_void,
    lpbiOut: ?*BITMAPINFO,
    lQuality: i32,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICImageDecompress(
    hic: HIC,
    uiFlags: u32,
    lpbiIn: *BITMAPINFO,
    lpBits: *c_void,
    lpbiOut: ?*BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICCompressorChoose(
    hwnd: HWND,
    uiFlags: u32,
    pvIn: ?*c_void,
    lpData: ?*c_void,
    pc: *COMPVARS,
    lpszTitle: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICSeqCompressFrameStart(
    pc: *COMPVARS,
    lpbiIn: *BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICSeqCompressFrameEnd(
    pc: *COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICSeqCompressFrame(
    pc: *COMPVARS,
    uiFlags: u32,
    lpBits: *c_void,
    pfKey: *BOOL,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn ICCompressorFree(
    pc: *COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibOpen(
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibClose(
    hdd: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibGetBuffer(
    hdd: isize,
    lpbi: *BITMAPINFOHEADER,
    dwSize: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibGetPalette(
    hdd: isize,
) callconv(@import("std").os.windows.WINAPI) HPALETTE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibSetPalette(
    hdd: isize,
    hpal: HPALETTE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibChangePalette(
    hdd: isize,
    iStart: i32,
    iLen: i32,
    lppe: [*]PALETTEENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibRealize(
    hdd: isize,
    hdc: HDC,
    fBackground: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibStart(
    hdd: isize,
    rate: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibStop(
    hdd: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibBegin(
    hdd: isize,
    hdc: HDC,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibDraw(
    hdd: isize,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    lpBits: ?*c_void,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibEnd(
    hdd: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibTime(
    hdd: isize,
    lpddtime: *DRAWDIBTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn DrawDibProfileDisplay(
    lpbi: *BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileInit(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileExit(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileAddRef(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileRelease(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileOpenA(
    ppfile: **IAVIFile,
    szFile: [*:0]const u8,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileOpenW(
    ppfile: **IAVIFile,
    szFile: [*:0]const u16,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileInfoW(
    pfile: *IAVIFile,
    // TODO: what to do with BytesParamIndex 2?
    pfi: *AVIFILEINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileInfoA(
    pfile: *IAVIFile,
    // TODO: what to do with BytesParamIndex 2?
    pfi: *AVIFILEINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileGetStream(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    fccType: u32,
    lParam: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileCreateStreamW(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    psi: *AVISTREAMINFOW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileCreateStreamA(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    psi: *AVISTREAMINFOA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileWriteData(
    pfile: *IAVIFile,
    ckid: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpData: *c_void,
    cbData: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileReadData(
    pfile: *IAVIFile,
    ckid: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpData: *c_void,
    lpcbData: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIFileEndRecord(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamAddRef(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamRelease(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamInfoW(
    pavi: *IAVIStream,
    // TODO: what to do with BytesParamIndex 2?
    psi: *AVISTREAMINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamInfoA(
    pavi: *IAVIStream,
    // TODO: what to do with BytesParamIndex 2?
    psi: *AVISTREAMINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamFindSample(
    pavi: *IAVIStream,
    lPos: i32,
    lFlags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamReadFormat(
    pavi: *IAVIStream,
    lPos: i32,
    // TODO: what to do with BytesParamIndex 3?
    lpFormat: ?*c_void,
    lpcbFormat: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamSetFormat(
    pavi: *IAVIStream,
    lPos: i32,
    // TODO: what to do with BytesParamIndex 3?
    lpFormat: *c_void,
    cbFormat: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamReadData(
    pavi: *IAVIStream,
    fcc: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp: ?*c_void,
    lpcb: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamWriteData(
    pavi: *IAVIStream,
    fcc: u32,
    // TODO: what to do with BytesParamIndex 3?
    lp: *c_void,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamRead(
    pavi: *IAVIStream,
    lStart: i32,
    lSamples: i32,
    // TODO: what to do with BytesParamIndex 4?
    lpBuffer: ?*c_void,
    cbBuffer: i32,
    plBytes: ?*i32,
    plSamples: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamWrite(
    pavi: *IAVIStream,
    lStart: i32,
    lSamples: i32,
    // TODO: what to do with BytesParamIndex 4?
    lpBuffer: *c_void,
    cbBuffer: i32,
    dwFlags: u32,
    plSampWritten: ?*i32,
    plBytesWritten: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamStart(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamLength(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamTimeToSample(
    pavi: *IAVIStream,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamSampleToTime(
    pavi: *IAVIStream,
    lSample: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamBeginStreaming(
    pavi: *IAVIStream,
    lStart: i32,
    lEnd: i32,
    lRate: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamEndStreaming(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamGetFrameOpen(
    pavi: *IAVIStream,
    lpbiWanted: ?*BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) *IGetFrame;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamGetFrame(
    pg: *IGetFrame,
    lPos: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamGetFrameClose(
    pg: *IGetFrame,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamOpenFromFileA(
    ppavi: **IAVIStream,
    szFile: [*:0]const u8,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamOpenFromFileW(
    ppavi: **IAVIStream,
    szFile: [*:0]const u16,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIStreamCreate(
    ppavi: **IAVIStream,
    lParam1: i32,
    lParam2: i32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIMakeCompressedStream(
    ppsCompressed: **IAVIStream,
    ppsSource: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveA(
    szFile: [*:0]const u8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveVA(
    szFile: [*:0]const u8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveW(
    szFile: [*:0]const u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveVW(
    szFile: [*:0]const u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveOptions(
    hwnd: HWND,
    uiFlags: u32,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVISaveOptionsFree(
    nStreams: i32,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIBuildFilterW(
    lpszFilter: [*:0]u16,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIBuildFilterA(
    lpszFilter: [*:0]u8,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIMakeFileFromStreams(
    ppfile: **IAVIFile,
    nStreams: i32,
    papStreams: [*]*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIMakeStreamFromClipboard(
    cfFormat: u32,
    hGlobal: HANDLE,
    ppstream: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIPutFileOnClipboard(
    pf: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIGetFromClipboard(
    lppf: **IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn AVIClearClipboard(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn CreateEditableStream(
    ppsEditable: **IAVIStream,
    psSource: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamCut(
    pavi: *IAVIStream,
    plStart: *i32,
    plLength: *i32,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamCopy(
    pavi: *IAVIStream,
    plStart: *i32,
    plLength: *i32,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamPaste(
    pavi: *IAVIStream,
    plPos: *i32,
    plLength: *i32,
    pstream: *IAVIStream,
    lStart: i32,
    lEnd: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamClone(
    pavi: *IAVIStream,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamSetNameA(
    pavi: *IAVIStream,
    lpszName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamSetNameW(
    pavi: *IAVIStream,
    lpszName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamSetInfoW(
    pavi: *IAVIStream,
    // TODO: what to do with BytesParamIndex 2?
    lpInfo: *AVISTREAMINFOW,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVIFIL32" fn EditStreamSetInfoA(
    pavi: *IAVIStream,
    // TODO: what to do with BytesParamIndex 2?
    lpInfo: *AVISTREAMINFOA,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn MCIWndCreateA(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn MCIWndCreateW(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn MCIWndRegisterClass(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVICAP32" fn capCreateCaptureWindowA(
    lpszWindowName: [*:0]const u8,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVICAP32" fn capGetDriverDescriptionA(
    wDriverIndex: u32,
    lpszName: [*:0]u8,
    cbName: i32,
    lpszVer: [*:0]u8,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVICAP32" fn capCreateCaptureWindowW(
    lpszWindowName: [*:0]const u16,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows5.0'
pub extern "AVICAP32" fn capGetDriverDescriptionW(
    wDriverIndex: u32,
    lpszName: [*:0]u16,
    cbName: i32,
    lpszVer: [*:0]u16,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn GetOpenFileNamePreviewA(
    lpofn: *OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn GetSaveFileNamePreviewA(
    lpofn: *OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn GetOpenFileNamePreviewW(
    lpofn: *OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSVFW32" fn GetSaveFileNamePreviewW(
    lpofn: *OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn mmTaskCreate(
    lpfn: LPTASKCALLBACK,
    lph: *HANDLE,
    dwInst: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmTaskBlock(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINMM" fn mmTaskSignal(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn mmTaskYield(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINMM" fn mmGetCurrentTask(
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (93)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2A;
        pub const WAVEINCAPS = WAVEINCAPSA;
        pub const WAVEINCAPS2 = WAVEINCAPS2A;
        pub const MIDIOUTCAPS = MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2A;
        pub const MIDIINCAPS = MIDIINCAPSA;
        pub const MIDIINCAPS2 = MIDIINCAPS2A;
        pub const AUXCAPS = AUXCAPSA;
        pub const AUXCAPS2 = AUXCAPS2A;
        pub const MIXERCAPS = MIXERCAPSA;
        pub const MIXERCAPS2 = MIXERCAPS2A;
        pub const MIXERLINE = MIXERLINEA;
        pub const MIXERCONTROL = MIXERCONTROLA;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTA;
        pub const JOYCAPS = JOYCAPSA;
        pub const JOYCAPS2 = JOYCAPS2A;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSA;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSA;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSA;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSA;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSA;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSA;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSA;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSA;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSA;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSA;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSA;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSA;
        pub const ACMDRIVERDETAILS = ACMDRIVERDETAILSA;
        pub const ACMFORMATTAGDETAILS = ACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBA;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCA;
        pub const ACMFORMATCHOOSE = ACMFORMATCHOOSEA;
        pub const ACMFILTERTAGDETAILS = ACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBA;
        pub const ACMFILTERDETAILS = ACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCA;
        pub const ACMFILTERCHOOSE = ACMFILTERCHOOSEA;
        pub const AVISTREAMINFO = AVISTREAMINFOA;
        pub const AVIFILEINFO = AVIFILEINFOA;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKA;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKA;
        pub const mmioStringToFOURCC = mmioStringToFOURCCA;
        pub const mmioInstallIOProc = mmioInstallIOProcA;
        pub const mmioOpen = mmioOpenA;
        pub const mmioRename = mmioRenameA;
        pub const sndPlaySound = sndPlaySoundA;
        pub const PlaySound = PlaySoundA;
        pub const waveOutGetDevCaps = waveOutGetDevCapsA;
        pub const waveOutGetErrorText = waveOutGetErrorTextA;
        pub const waveInGetDevCaps = waveInGetDevCapsA;
        pub const waveInGetErrorText = waveInGetErrorTextA;
        pub const midiOutGetDevCaps = midiOutGetDevCapsA;
        pub const midiOutGetErrorText = midiOutGetErrorTextA;
        pub const midiInGetDevCaps = midiInGetDevCapsA;
        pub const midiInGetErrorText = midiInGetErrorTextA;
        pub const auxGetDevCaps = auxGetDevCapsA;
        pub const mixerGetDevCaps = mixerGetDevCapsA;
        pub const mixerGetLineInfo = mixerGetLineInfoA;
        pub const mixerGetLineControls = mixerGetLineControlsA;
        pub const mixerGetControlDetails = mixerGetControlDetailsA;
        pub const joyGetDevCaps = joyGetDevCapsA;
        pub const acmDriverAdd = acmDriverAddA;
        pub const acmDriverDetails = acmDriverDetailsA;
        pub const acmFormatTagDetails = acmFormatTagDetailsA;
        pub const acmFormatTagEnum = acmFormatTagEnumA;
        pub const acmFormatDetails = acmFormatDetailsA;
        pub const acmFormatEnum = acmFormatEnumA;
        pub const acmFormatChoose = acmFormatChooseA;
        pub const acmFilterTagDetails = acmFilterTagDetailsA;
        pub const acmFilterTagEnum = acmFilterTagEnumA;
        pub const acmFilterDetails = acmFilterDetailsA;
        pub const acmFilterEnum = acmFilterEnumA;
        pub const acmFilterChoose = acmFilterChooseA;
        pub const AVIFileOpen = AVIFileOpenA;
        pub const AVIFileInfo = AVIFileInfoA;
        pub const AVIFileCreateStream = AVIFileCreateStreamA;
        pub const AVIStreamInfo = AVIStreamInfoA;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileA;
        pub const AVISave = AVISaveA;
        pub const AVISaveV = AVISaveVA;
        pub const AVIBuildFilter = AVIBuildFilterA;
        pub const EditStreamSetName = EditStreamSetNameA;
        pub const EditStreamSetInfo = EditStreamSetInfoA;
        pub const MCIWndCreate = MCIWndCreateA;
        pub const capCreateCaptureWindow = capCreateCaptureWindowA;
        pub const capGetDriverDescription = capGetDriverDescriptionA;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewA;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2W;
        pub const WAVEINCAPS = WAVEINCAPSW;
        pub const WAVEINCAPS2 = WAVEINCAPS2W;
        pub const MIDIOUTCAPS = MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2W;
        pub const MIDIINCAPS = MIDIINCAPSW;
        pub const MIDIINCAPS2 = MIDIINCAPS2W;
        pub const AUXCAPS = AUXCAPSW;
        pub const AUXCAPS2 = AUXCAPS2W;
        pub const MIXERCAPS = MIXERCAPSW;
        pub const MIXERCAPS2 = MIXERCAPS2W;
        pub const MIXERLINE = MIXERLINEW;
        pub const MIXERCONTROL = MIXERCONTROLW;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTW;
        pub const JOYCAPS = JOYCAPSW;
        pub const JOYCAPS2 = JOYCAPS2W;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSW;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSW;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSW;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSW;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSW;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSW;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSW;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSW;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSW;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSW;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSW;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSW;
        pub const ACMDRIVERDETAILS = ACMDRIVERDETAILSW;
        pub const ACMFORMATTAGDETAILS = ACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBW;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCW;
        pub const ACMFORMATCHOOSE = ACMFORMATCHOOSEW;
        pub const ACMFILTERTAGDETAILS = ACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBW;
        pub const ACMFILTERDETAILS = ACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCW;
        pub const ACMFILTERCHOOSE = ACMFILTERCHOOSEW;
        pub const AVISTREAMINFO = AVISTREAMINFOW;
        pub const AVIFILEINFO = AVIFILEINFOW;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKW;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKW;
        pub const mmioStringToFOURCC = mmioStringToFOURCCW;
        pub const mmioInstallIOProc = mmioInstallIOProcW;
        pub const mmioOpen = mmioOpenW;
        pub const mmioRename = mmioRenameW;
        pub const sndPlaySound = sndPlaySoundW;
        pub const PlaySound = PlaySoundW;
        pub const waveOutGetDevCaps = waveOutGetDevCapsW;
        pub const waveOutGetErrorText = waveOutGetErrorTextW;
        pub const waveInGetDevCaps = waveInGetDevCapsW;
        pub const waveInGetErrorText = waveInGetErrorTextW;
        pub const midiOutGetDevCaps = midiOutGetDevCapsW;
        pub const midiOutGetErrorText = midiOutGetErrorTextW;
        pub const midiInGetDevCaps = midiInGetDevCapsW;
        pub const midiInGetErrorText = midiInGetErrorTextW;
        pub const auxGetDevCaps = auxGetDevCapsW;
        pub const mixerGetDevCaps = mixerGetDevCapsW;
        pub const mixerGetLineInfo = mixerGetLineInfoW;
        pub const mixerGetLineControls = mixerGetLineControlsW;
        pub const mixerGetControlDetails = mixerGetControlDetailsW;
        pub const joyGetDevCaps = joyGetDevCapsW;
        pub const acmDriverAdd = acmDriverAddW;
        pub const acmDriverDetails = acmDriverDetailsW;
        pub const acmFormatTagDetails = acmFormatTagDetailsW;
        pub const acmFormatTagEnum = acmFormatTagEnumW;
        pub const acmFormatDetails = acmFormatDetailsW;
        pub const acmFormatEnum = acmFormatEnumW;
        pub const acmFormatChoose = acmFormatChooseW;
        pub const acmFilterTagDetails = acmFilterTagDetailsW;
        pub const acmFilterTagEnum = acmFilterTagEnumW;
        pub const acmFilterDetails = acmFilterDetailsW;
        pub const acmFilterEnum = acmFilterEnumW;
        pub const acmFilterChoose = acmFilterChooseW;
        pub const AVIFileOpen = AVIFileOpenW;
        pub const AVIFileInfo = AVIFileInfoW;
        pub const AVIFileCreateStream = AVIFileCreateStreamW;
        pub const AVIStreamInfo = AVIStreamInfoW;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileW;
        pub const AVISave = AVISaveW;
        pub const AVISaveV = AVISaveVW;
        pub const AVIBuildFilter = AVIBuildFilterW;
        pub const EditStreamSetName = EditStreamSetNameW;
        pub const EditStreamSetInfo = EditStreamSetInfoW;
        pub const MCIWndCreate = MCIWndCreateW;
        pub const capCreateCaptureWindow = capCreateCaptureWindowW;
        pub const capGetDriverDescription = capGetDriverDescriptionW;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewW;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque{};
        pub const WAVEOUTCAPS2 = *opaque{};
        pub const WAVEINCAPS = *opaque{};
        pub const WAVEINCAPS2 = *opaque{};
        pub const MIDIOUTCAPS = *opaque{};
        pub const MIDIOUTCAPS2 = *opaque{};
        pub const MIDIINCAPS = *opaque{};
        pub const MIDIINCAPS2 = *opaque{};
        pub const AUXCAPS = *opaque{};
        pub const AUXCAPS2 = *opaque{};
        pub const MIXERCAPS = *opaque{};
        pub const MIXERCAPS2 = *opaque{};
        pub const MIXERLINE = *opaque{};
        pub const MIXERCONTROL = *opaque{};
        pub const MIXERLINECONTROLS = *opaque{};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque{};
        pub const JOYCAPS = *opaque{};
        pub const JOYCAPS2 = *opaque{};
        pub const MCI_DGV_CAPTURE_PARMS = *opaque{};
        pub const MCI_DGV_INFO_PARMS = *opaque{};
        pub const MCI_DGV_LIST_PARMS = *opaque{};
        pub const MCI_DGV_OPEN_PARMS = *opaque{};
        pub const MCI_DGV_QUALITY_PARMS = *opaque{};
        pub const MCI_DGV_RESERVE_PARMS = *opaque{};
        pub const MCI_DGV_RESTORE_PARMS = *opaque{};
        pub const MCI_DGV_SAVE_PARMS = *opaque{};
        pub const MCI_DGV_SETAUDIO_PARMS = *opaque{};
        pub const MCI_DGV_SETVIDEO_PARMS = *opaque{};
        pub const MCI_DGV_STATUS_PARMS = *opaque{};
        pub const MCI_DGV_WINDOW_PARMS = *opaque{};
        pub const ACMDRIVERDETAILS = *opaque{};
        pub const ACMFORMATTAGDETAILS = *opaque{};
        pub const ACMFORMATTAGENUMCB = *opaque{};
        pub const ACMFORMATENUMCB = *opaque{};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque{};
        pub const ACMFORMATCHOOSE = *opaque{};
        pub const ACMFILTERTAGDETAILS = *opaque{};
        pub const ACMFILTERTAGENUMCB = *opaque{};
        pub const ACMFILTERDETAILS = *opaque{};
        pub const ACMFILTERENUMCB = *opaque{};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque{};
        pub const ACMFILTERCHOOSE = *opaque{};
        pub const AVISTREAMINFO = *opaque{};
        pub const AVIFILEINFO = *opaque{};
        pub const CAPSTATUSCALLBACK = *opaque{};
        pub const CAPERRORCALLBACK = *opaque{};
        pub const mmioStringToFOURCC = *opaque{};
        pub const mmioInstallIOProc = *opaque{};
        pub const mmioOpen = *opaque{};
        pub const mmioRename = *opaque{};
        pub const sndPlaySound = *opaque{};
        pub const PlaySound = *opaque{};
        pub const waveOutGetDevCaps = *opaque{};
        pub const waveOutGetErrorText = *opaque{};
        pub const waveInGetDevCaps = *opaque{};
        pub const waveInGetErrorText = *opaque{};
        pub const midiOutGetDevCaps = *opaque{};
        pub const midiOutGetErrorText = *opaque{};
        pub const midiInGetDevCaps = *opaque{};
        pub const midiInGetErrorText = *opaque{};
        pub const auxGetDevCaps = *opaque{};
        pub const mixerGetDevCaps = *opaque{};
        pub const mixerGetLineInfo = *opaque{};
        pub const mixerGetLineControls = *opaque{};
        pub const mixerGetControlDetails = *opaque{};
        pub const joyGetDevCaps = *opaque{};
        pub const acmDriverAdd = *opaque{};
        pub const acmDriverDetails = *opaque{};
        pub const acmFormatTagDetails = *opaque{};
        pub const acmFormatTagEnum = *opaque{};
        pub const acmFormatDetails = *opaque{};
        pub const acmFormatEnum = *opaque{};
        pub const acmFormatChoose = *opaque{};
        pub const acmFilterTagDetails = *opaque{};
        pub const acmFilterTagEnum = *opaque{};
        pub const acmFilterDetails = *opaque{};
        pub const acmFilterEnum = *opaque{};
        pub const acmFilterChoose = *opaque{};
        pub const AVIFileOpen = *opaque{};
        pub const AVIFileInfo = *opaque{};
        pub const AVIFileCreateStream = *opaque{};
        pub const AVIStreamInfo = *opaque{};
        pub const AVIStreamOpenFromFile = *opaque{};
        pub const AVISave = *opaque{};
        pub const AVISaveV = *opaque{};
        pub const AVIBuildFilter = *opaque{};
        pub const EditStreamSetName = *opaque{};
        pub const EditStreamSetInfo = *opaque{};
        pub const MCIWndCreate = *opaque{};
        pub const capCreateCaptureWindow = *opaque{};
        pub const capGetDriverDescription = *opaque{};
        pub const GetOpenFileNamePreview = *opaque{};
        pub const GetSaveFileNamePreview = *opaque{};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS = @compileError("'JOYCAPS' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS2 = @compileError("'JOYCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_CAPTURE_PARMS = @compileError("'MCI_DGV_CAPTURE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_INFO_PARMS = @compileError("'MCI_DGV_INFO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_LIST_PARMS = @compileError("'MCI_DGV_LIST_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_OPEN_PARMS = @compileError("'MCI_DGV_OPEN_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_QUALITY_PARMS = @compileError("'MCI_DGV_QUALITY_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESERVE_PARMS = @compileError("'MCI_DGV_RESERVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESTORE_PARMS = @compileError("'MCI_DGV_RESTORE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SAVE_PARMS = @compileError("'MCI_DGV_SAVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETAUDIO_PARMS = @compileError("'MCI_DGV_SETAUDIO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETVIDEO_PARMS = @compileError("'MCI_DGV_SETVIDEO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_STATUS_PARMS = @compileError("'MCI_DGV_STATUS_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_WINDOW_PARMS = @compileError("'MCI_DGV_WINDOW_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const ACMDRIVERDETAILS = @compileError("'ACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGDETAILS = @compileError("'ACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSE = @compileError("'ACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGDETAILS = @compileError("'ACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERDETAILS = @compileError("'ACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSE = @compileError("'ACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const AVISTREAMINFO = @compileError("'AVISTREAMINFO' requires that UNICODE be set to true or false in the root module");
        pub const AVIFILEINFO = @compileError("'AVIFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const CAPSTATUSCALLBACK = @compileError("'CAPSTATUSCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const CAPERRORCALLBACK = @compileError("'CAPERRORCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const mmioStringToFOURCC = @compileError("'mmioStringToFOURCC' requires that UNICODE be set to true or false in the root module");
        pub const mmioInstallIOProc = @compileError("'mmioInstallIOProc' requires that UNICODE be set to true or false in the root module");
        pub const mmioOpen = @compileError("'mmioOpen' requires that UNICODE be set to true or false in the root module");
        pub const mmioRename = @compileError("'mmioRename' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const joyGetDevCaps = @compileError("'joyGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileOpen = @compileError("'AVIFileOpen' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileInfo = @compileError("'AVIFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileCreateStream = @compileError("'AVIFileCreateStream' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamInfo = @compileError("'AVIStreamInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamOpenFromFile = @compileError("'AVIStreamOpenFromFile' requires that UNICODE be set to true or false in the root module");
        pub const AVISave = @compileError("'AVISave' requires that UNICODE be set to true or false in the root module");
        pub const AVISaveV = @compileError("'AVISaveV' requires that UNICODE be set to true or false in the root module");
        pub const AVIBuildFilter = @compileError("'AVIBuildFilter' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetName = @compileError("'EditStreamSetName' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetInfo = @compileError("'EditStreamSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MCIWndCreate = @compileError("'MCIWndCreate' requires that UNICODE be set to true or false in the root module");
        pub const capCreateCaptureWindow = @compileError("'capCreateCaptureWindow' requires that UNICODE be set to true or false in the root module");
        pub const capGetDriverDescription = @compileError("'capGetDriverDescription' requires that UNICODE be set to true or false in the root module");
        pub const GetOpenFileNamePreview = @compileError("'GetOpenFileNamePreview' requires that UNICODE be set to true or false in the root module");
        pub const GetSaveFileNamePreview = @compileError("'GetSaveFileNamePreview' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (28)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const HDC = @import("gdi.zig").HDC;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const JOYREGHWVALUES = @import("hid.zig").JOYREGHWVALUES;
const CHAR = @import("system_services.zig").CHAR;
const OPENFILENAMEA = @import("windows_and_messaging.zig").OPENFILENAMEA;
const HRESULT = @import("com.zig").HRESULT;
const BITMAPINFOHEADER = @import("gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("system_services.zig").BOOL;
const LRESULT = @import("system_services.zig").LRESULT;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const HPALETTE = @import("gdi.zig").HPALETTE;
const HTASK = @import("core_audio.zig").HTASK;
const FARPROC = @import("system_services.zig").FARPROC;
const OPENFILENAMEW = @import("windows_and_messaging.zig").OPENFILENAMEW;
const HICON = @import("menus_and_resources.zig").HICON;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const LPTIMECALLBACK = @import("system_services.zig").LPTIMECALLBACK;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const HWND = @import("windows_and_messaging.zig").HWND;
const BITMAPINFO = @import("gdi.zig").BITMAPINFO;
const IPersistFile = @import("com.zig").IPersistFile;
const PALETTEENTRY = @import("gdi.zig").PALETTEENTRY;
const HANDLE = @import("system_services.zig").HANDLE;
const POINT = @import("display_devices.zig").POINT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPWAVECALLBACK")) { _ = LPWAVECALLBACK; }
    if (@hasDecl(@This(), "LPMIDICALLBACK")) { _ = LPMIDICALLBACK; }
    if (@hasDecl(@This(), "LPDRVCALLBACK")) { _ = LPDRVCALLBACK; }
    if (@hasDecl(@This(), "DRIVERPROC")) { _ = DRIVERPROC; }
    if (@hasDecl(@This(), "DRIVERMSGPROC")) { _ = DRIVERMSGPROC; }
    if (@hasDecl(@This(), "LPMMIOPROC")) { _ = LPMMIOPROC; }
    if (@hasDecl(@This(), "ACMDRIVERENUMCB")) { _ = ACMDRIVERENUMCB; }
    if (@hasDecl(@This(), "LPACMDRIVERPROC")) { _ = LPACMDRIVERPROC; }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBA")) { _ = ACMFORMATTAGENUMCBA; }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBW")) { _ = ACMFORMATTAGENUMCBW; }
    if (@hasDecl(@This(), "ACMFORMATENUMCBA")) { _ = ACMFORMATENUMCBA; }
    if (@hasDecl(@This(), "ACMFORMATENUMCBW")) { _ = ACMFORMATENUMCBW; }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCA")) { _ = ACMFORMATCHOOSEHOOKPROCA; }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCW")) { _ = ACMFORMATCHOOSEHOOKPROCW; }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBA")) { _ = ACMFILTERTAGENUMCBA; }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBW")) { _ = ACMFILTERTAGENUMCBW; }
    if (@hasDecl(@This(), "ACMFILTERENUMCBA")) { _ = ACMFILTERENUMCBA; }
    if (@hasDecl(@This(), "ACMFILTERENUMCBW")) { _ = ACMFILTERENUMCBW; }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCA")) { _ = ACMFILTERCHOOSEHOOKPROCA; }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCW")) { _ = ACMFILTERCHOOSEHOOKPROCW; }
    if (@hasDecl(@This(), "AVISAVECALLBACK")) { _ = AVISAVECALLBACK; }
    if (@hasDecl(@This(), "CAPYIELDCALLBACK")) { _ = CAPYIELDCALLBACK; }
    if (@hasDecl(@This(), "CAPSTATUSCALLBACKW")) { _ = CAPSTATUSCALLBACKW; }
    if (@hasDecl(@This(), "CAPERRORCALLBACKW")) { _ = CAPERRORCALLBACKW; }
    if (@hasDecl(@This(), "CAPSTATUSCALLBACKA")) { _ = CAPSTATUSCALLBACKA; }
    if (@hasDecl(@This(), "CAPERRORCALLBACKA")) { _ = CAPERRORCALLBACKA; }
    if (@hasDecl(@This(), "CAPVIDEOCALLBACK")) { _ = CAPVIDEOCALLBACK; }
    if (@hasDecl(@This(), "CAPWAVECALLBACK")) { _ = CAPWAVECALLBACK; }
    if (@hasDecl(@This(), "CAPCONTROLCALLBACK")) { _ = CAPCONTROLCALLBACK; }
    if (@hasDecl(@This(), "LPJOYDEVMSGPROC")) { _ = LPJOYDEVMSGPROC; }
    if (@hasDecl(@This(), "LPTASKCALLBACK")) { _ = LPTASKCALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
