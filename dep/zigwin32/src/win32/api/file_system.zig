//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (195)
//--------------------------------------------------------------------------------
pub const IOCTL_VOLUME_BC_VERSION = @as(u32, 1);
pub const CSV_BLOCK_CACHE_CALLBACK_VERSION = @as(u32, 1);
pub const CSV_BLOCK_AND_FILE_CACHE_CALLBACK_VERSION = @as(u32, 2);
pub const CLFS_MGMT_POLICY_VERSION = @as(u32, 1);
pub const LOG_POLICY_OVERWRITE = @as(u32, 1);
pub const LOG_POLICY_PERSIST = @as(u32, 2);
pub const CLFS_MGMT_CLIENT_REGISTRATION_VERSION = @as(u32, 1);
pub const NTMSMLI_MAXTYPE = @as(u32, 64);
pub const NTMSMLI_MAXIDSIZE = @as(u32, 256);
pub const NTMSMLI_MAXAPPDESCR = @as(u32, 256);
pub const NTMS_OBJECTNAME_LENGTH = @as(u32, 64);
pub const NTMS_DESCRIPTION_LENGTH = @as(u32, 127);
pub const NTMS_DEVICENAME_LENGTH = @as(u32, 64);
pub const NTMS_SERIALNUMBER_LENGTH = @as(u32, 32);
pub const NTMS_REVISION_LENGTH = @as(u32, 32);
pub const NTMS_BARCODE_LENGTH = @as(u32, 64);
pub const NTMS_SEQUENCE_LENGTH = @as(u32, 32);
pub const NTMS_VENDORNAME_LENGTH = @as(u32, 128);
pub const NTMS_PRODUCTNAME_LENGTH = @as(u32, 128);
pub const NTMS_USERNAME_LENGTH = @as(u32, 64);
pub const NTMS_APPLICATIONNAME_LENGTH = @as(u32, 64);
pub const NTMS_COMPUTERNAME_LENGTH = @as(u32, 64);
pub const NTMS_I1_MESSAGE_LENGTH = @as(u32, 127);
pub const NTMS_MESSAGE_LENGTH = @as(u32, 256);
pub const NTMS_POOLHIERARCHY_LENGTH = @as(u32, 512);
pub const NTMS_OMIDLABELID_LENGTH = @as(u32, 255);
pub const NTMS_OMIDLABELTYPE_LENGTH = @as(u32, 64);
pub const NTMS_OMIDLABELINFO_LENGTH = @as(u32, 256);
pub const NTMS_MAXATTR_LENGTH = @as(u32, 65536);
pub const NTMS_MAXATTR_NAMELEN = @as(u32, 32);
pub const CLFS_FLAG_REENTRANT_FILE_SYSTEM = @as(u32, 8);
pub const CLFS_FLAG_NON_REENTRANT_FILTER = @as(u32, 16);
pub const CLFS_FLAG_REENTRANT_FILTER = @as(u32, 32);
pub const CLFS_FLAG_IGNORE_SHARE_ACCESS = @as(u32, 64);
pub const CLFS_FLAG_READ_IN_PROGRESS = @as(u32, 128);
pub const CLFS_FLAG_MINIFILTER_LEVEL = @as(u32, 256);
pub const CLFS_FLAG_HIDDEN_SYSTEM_LOG = @as(u32, 512);
pub const CLFS_MARSHALLING_FLAG_NONE = @as(u32, 0);
pub const CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT = @as(u32, 1);
pub const CLSID_DiskQuotaControl = Guid.initString("7988b571-ec89-11cf-9c00-00aa00a14f56");
pub const DISKQUOTA_STATE_DISABLED = @as(u32, 0);
pub const DISKQUOTA_STATE_TRACK = @as(u32, 1);
pub const DISKQUOTA_STATE_ENFORCE = @as(u32, 2);
pub const DISKQUOTA_STATE_MASK = @as(u32, 3);
pub const DISKQUOTA_FILESTATE_INCOMPLETE = @as(u32, 256);
pub const DISKQUOTA_FILESTATE_REBUILDING = @as(u32, 512);
pub const DISKQUOTA_FILESTATE_MASK = @as(u32, 768);
pub const DISKQUOTA_LOGFLAG_USER_THRESHOLD = @as(u32, 1);
pub const DISKQUOTA_LOGFLAG_USER_LIMIT = @as(u32, 2);
pub const DISKQUOTA_USER_ACCOUNT_RESOLVED = @as(u32, 0);
pub const DISKQUOTA_USER_ACCOUNT_UNAVAILABLE = @as(u32, 1);
pub const DISKQUOTA_USER_ACCOUNT_DELETED = @as(u32, 2);
pub const DISKQUOTA_USER_ACCOUNT_INVALID = @as(u32, 3);
pub const DISKQUOTA_USER_ACCOUNT_UNKNOWN = @as(u32, 4);
pub const DISKQUOTA_USER_ACCOUNT_UNRESOLVED = @as(u32, 5);
pub const WINEFS_SETUSERKEY_SET_CAPABILITIES = @as(u32, 1);
pub const EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR = @as(u32, 5);
pub const EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR = @as(u32, 6);
pub const EFS_SUBVER_UNKNOWN = @as(u32, 0);
pub const EFS_EFS_SUBVER_EFS_CERT = @as(u32, 1);
pub const EFS_PFILE_SUBVER_RMS = @as(u32, 2);
pub const EFS_PFILE_SUBVER_APPX = @as(u32, 3);
pub const MAX_SID_SIZE = @as(u32, 256);
pub const EFS_METADATA_ADD_USER = @as(u32, 1);
pub const EFS_METADATA_REMOVE_USER = @as(u32, 2);
pub const EFS_METADATA_REPLACE_USER = @as(u32, 4);
pub const EFS_METADATA_GENERAL_OP = @as(u32, 8);
pub const LZERROR_BADINHANDLE = @as(i32, -1);
pub const LZERROR_BADOUTHANDLE = @as(i32, -2);
pub const LZERROR_READ = @as(i32, -3);
pub const LZERROR_WRITE = @as(i32, -4);
pub const LZERROR_GLOBALLOC = @as(i32, -5);
pub const LZERROR_GLOBLOCK = @as(i32, -6);
pub const LZERROR_BADVALUE = @as(i32, -7);
pub const LZERROR_UNKNOWNALG = @as(i32, -8);
pub const WIM_ENTRY_FLAG_NOT_ACTIVE = @as(u32, 1);
pub const WIM_ENTRY_FLAG_SUSPENDED = @as(u32, 2);
pub const TXF_LOG_RECORD_GENERIC_TYPE_COMMIT = @as(u32, 1);
pub const TXF_LOG_RECORD_GENERIC_TYPE_ABORT = @as(u32, 2);
pub const TXF_LOG_RECORD_GENERIC_TYPE_PREPARE = @as(u32, 4);
pub const TXF_LOG_RECORD_GENERIC_TYPE_DATA = @as(u32, 8);
pub const SHARE_NETNAME_PARMNUM = @as(u32, 1);
pub const SHARE_TYPE_PARMNUM = @as(u32, 3);
pub const SHARE_REMARK_PARMNUM = @as(u32, 4);
pub const SHARE_PERMISSIONS_PARMNUM = @as(u32, 5);
pub const SHARE_MAX_USES_PARMNUM = @as(u32, 6);
pub const SHARE_CURRENT_USES_PARMNUM = @as(u32, 7);
pub const SHARE_PATH_PARMNUM = @as(u32, 8);
pub const SHARE_PASSWD_PARMNUM = @as(u32, 9);
pub const SHARE_FILE_SD_PARMNUM = @as(u32, 501);
pub const SHARE_SERVER_PARMNUM = @as(u32, 503);
pub const SHI1_NUM_ELEMENTS = @as(u32, 4);
pub const SHI2_NUM_ELEMENTS = @as(u32, 10);
pub const STYPE_RESERVED1 = @as(u32, 16777216);
pub const STYPE_RESERVED2 = @as(u32, 33554432);
pub const STYPE_RESERVED3 = @as(u32, 67108864);
pub const STYPE_RESERVED4 = @as(u32, 134217728);
pub const STYPE_RESERVED5 = @as(u32, 1048576);
pub const STYPE_RESERVED_ALL = @as(u32, 1073741568);
pub const SHI1005_FLAGS_DFS = @as(u32, 1);
pub const SHI1005_FLAGS_DFS_ROOT = @as(u32, 2);
pub const CSC_MASK_EXT = @as(u32, 8240);
pub const CSC_MASK = @as(u32, 48);
pub const CSC_CACHE_MANUAL_REINT = @as(u32, 0);
pub const CSC_CACHE_AUTO_REINT = @as(u32, 16);
pub const CSC_CACHE_VDO = @as(u32, 32);
pub const CSC_CACHE_NONE = @as(u32, 48);
pub const SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS = @as(u32, 256);
pub const SHI1005_FLAGS_FORCE_SHARED_DELETE = @as(u32, 512);
pub const SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING = @as(u32, 1024);
pub const SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM = @as(u32, 2048);
pub const SHI1005_FLAGS_FORCE_LEVELII_OPLOCK = @as(u32, 4096);
pub const SHI1005_FLAGS_ENABLE_HASH = @as(u32, 8192);
pub const SHI1005_FLAGS_ENABLE_CA = @as(u32, 16384);
pub const SHI1005_FLAGS_ENCRYPT_DATA = @as(u32, 32768);
pub const SHI1005_FLAGS_RESERVED = @as(u32, 65536);
pub const SHI1005_FLAGS_DISABLE_CLIENT_BUFFERING = @as(u32, 131072);
pub const SHI1005_FLAGS_IDENTITY_REMOTING = @as(u32, 262144);
pub const SHI1005_FLAGS_CLUSTER_MANAGED = @as(u32, 524288);
pub const SESI1_NUM_ELEMENTS = @as(u32, 8);
pub const SESI2_NUM_ELEMENTS = @as(u32, 9);
pub const STATSOPT_CLR = @as(u32, 1);
pub const TRANSACTION_MANAGER_VOLATILE = @as(u32, 1);
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT = @as(u32, 0);
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME = @as(u32, 2);
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES = @as(u32, 4);
pub const TRANSACTION_MANAGER_COMMIT_LOWEST = @as(u32, 8);
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY = @as(u32, 16);
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS = @as(u32, 32);
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION = @as(u32, 63);
pub const TRANSACTION_DO_NOT_PROMOTE = @as(u32, 1);
pub const TRANSACTION_MAXIMUM_OPTION = @as(u32, 1);
pub const RESOURCE_MANAGER_VOLATILE = @as(u32, 1);
pub const RESOURCE_MANAGER_COMMUNICATION = @as(u32, 2);
pub const RESOURCE_MANAGER_MAXIMUM_OPTION = @as(u32, 3);
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY = @as(u32, 1);
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO = @as(u32, 2);
pub const CRM_PROTOCOL_MAXIMUM_OPTION = @as(u32, 3);
pub const ENLISTMENT_SUPERIOR = @as(u32, 1);
pub const ENLISTMENT_MAXIMUM_OPTION = @as(u32, 1);
pub const TRANSACTION_NOTIFY_MASK = @as(u32, 1073741823);
pub const TRANSACTION_NOTIFY_PREPREPARE = @as(u32, 1);
pub const TRANSACTION_NOTIFY_PREPARE = @as(u32, 2);
pub const TRANSACTION_NOTIFY_COMMIT = @as(u32, 4);
pub const TRANSACTION_NOTIFY_ROLLBACK = @as(u32, 8);
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE = @as(u32, 16);
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE = @as(u32, 32);
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE = @as(u32, 64);
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE = @as(u32, 128);
pub const TRANSACTION_NOTIFY_RECOVER = @as(u32, 256);
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT = @as(u32, 512);
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT = @as(u32, 1024);
pub const TRANSACTION_NOTIFY_RECOVER_QUERY = @as(u32, 2048);
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE = @as(u32, 4096);
pub const TRANSACTION_NOTIFY_LAST_RECOVER = @as(u32, 8192);
pub const TRANSACTION_NOTIFY_INDOUBT = @as(u32, 16384);
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL = @as(u32, 32768);
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH = @as(u32, 65536);
pub const TRANSACTION_NOTIFY_MARSHAL = @as(u32, 131072);
pub const TRANSACTION_NOTIFY_ENLIST_MASK = @as(u32, 262144);
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED = @as(u32, 16777216);
pub const TRANSACTION_NOTIFY_TM_ONLINE = @as(u32, 33554432);
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST = @as(u32, 67108864);
pub const TRANSACTION_NOTIFY_PROMOTE = @as(u32, 134217728);
pub const TRANSACTION_NOTIFY_PROMOTE_NEW = @as(u32, 268435456);
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME = @as(u32, 536870912);
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE = @as(u32, 1073741824);
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED = @as(u32, 1);
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR = @as(u32, 1);
pub const KTM_MARSHAL_BLOB_VERSION_MINOR = @as(u32, 1);
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH = @as(u32, 64);
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH = @as(u32, 64);
pub const ClfsNullRecord = @as(u8, 0);
pub const ClfsDataRecord = @as(u8, 1);
pub const ClfsRestartRecord = @as(u8, 2);
pub const ClfsClientRecord = @as(u8, 3);
pub const ClsContainerInitializing = @as(u32, 1);
pub const ClsContainerInactive = @as(u32, 2);
pub const ClsContainerActive = @as(u32, 4);
pub const ClsContainerActivePendingDelete = @as(u32, 8);
pub const ClsContainerPendingArchive = @as(u32, 16);
pub const ClsContainerPendingArchiveAndDelete = @as(u32, 32);
pub const ClfsContainerInitializing = @as(u32, 1);
pub const ClfsContainerInactive = @as(u32, 2);
pub const ClfsContainerActive = @as(u32, 4);
pub const ClfsContainerActivePendingDelete = @as(u32, 8);
pub const ClfsContainerPendingArchive = @as(u32, 16);
pub const ClfsContainerPendingArchiveAndDelete = @as(u32, 32);
pub const CLFS_MAX_CONTAINER_INFO = @as(u32, 256);
pub const CLFS_SCAN_INIT = @as(u8, 1);
pub const CLFS_SCAN_FORWARD = @as(u8, 2);
pub const CLFS_SCAN_BACKWARD = @as(u8, 4);
pub const CLFS_SCAN_CLOSE = @as(u8, 8);
pub const CLFS_SCAN_INITIALIZED = @as(u8, 16);
pub const CLFS_SCAN_BUFFERED = @as(u8, 32);

//--------------------------------------------------------------------------------
// Section: Types (456)
//--------------------------------------------------------------------------------
// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FIND_FIRST_EX_FLAGS = extern enum(u32) {
    CASE_SENSITIVE = 1,
    LARGE_FETCH = 2,
    ON_DISK_ENTRIES_ONLY = 4,
    _,
};
pub const FIND_FIRST_EX_CASE_SENSITIVE = FIND_FIRST_EX_FLAGS.CASE_SENSITIVE;
pub const FIND_FIRST_EX_LARGE_FETCH = FIND_FIRST_EX_FLAGS.LARGE_FETCH;
pub const FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY = FIND_FIRST_EX_FLAGS.ON_DISK_ENTRIES_ONLY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DEFINE_DOS_DEVICE_FLAGS = extern enum(u32) {
    RAW_TARGET_PATH = 1,
    REMOVE_DEFINITION = 2,
    EXACT_MATCH_ON_REMOVE = 4,
    NO_BROADCAST_SYSTEM = 8,
    LUID_BROADCAST_DRIVE = 16,
    _,
};
pub const DDD_RAW_TARGET_PATH = DEFINE_DOS_DEVICE_FLAGS.RAW_TARGET_PATH;
pub const DDD_REMOVE_DEFINITION = DEFINE_DOS_DEVICE_FLAGS.REMOVE_DEFINITION;
pub const DDD_EXACT_MATCH_ON_REMOVE = DEFINE_DOS_DEVICE_FLAGS.EXACT_MATCH_ON_REMOVE;
pub const DDD_NO_BROADCAST_SYSTEM = DEFINE_DOS_DEVICE_FLAGS.NO_BROADCAST_SYSTEM;
pub const DDD_LUID_BROADCAST_DRIVE = DEFINE_DOS_DEVICE_FLAGS.LUID_BROADCAST_DRIVE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_FLAGS_AND_ATTRIBUTES = extern enum(u32) {
    FILE_ATTRIBUTE_READONLY = 1,
    FILE_ATTRIBUTE_HIDDEN = 2,
    FILE_ATTRIBUTE_SYSTEM = 4,
    FILE_ATTRIBUTE_DIRECTORY = 16,
    FILE_ATTRIBUTE_ARCHIVE = 32,
    FILE_ATTRIBUTE_DEVICE = 64,
    FILE_ATTRIBUTE_NORMAL = 128,
    FILE_ATTRIBUTE_TEMPORARY = 256,
    FILE_ATTRIBUTE_SPARSE_FILE = 512,
    FILE_ATTRIBUTE_REPARSE_POINT = 1024,
    FILE_ATTRIBUTE_COMPRESSED = 2048,
    FILE_ATTRIBUTE_OFFLINE = 4096,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192,
    FILE_ATTRIBUTE_ENCRYPTED = 16384,
    FILE_ATTRIBUTE_INTEGRITY_STREAM = 32768,
    FILE_ATTRIBUTE_VIRTUAL = 65536,
    FILE_ATTRIBUTE_NO_SCRUB_DATA = 131072,
    FILE_ATTRIBUTE_EA = 262144,
    FILE_ATTRIBUTE_PINNED = 524288,
    FILE_ATTRIBUTE_UNPINNED = 1048576,
    FILE_ATTRIBUTE_RECALL_ON_OPEN = 262144,
    FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 4194304,
    FILE_FLAG_WRITE_THROUGH = 2147483648,
    FILE_FLAG_OVERLAPPED = 1073741824,
    FILE_FLAG_NO_BUFFERING = 536870912,
    FILE_FLAG_RANDOM_ACCESS = 268435456,
    FILE_FLAG_SEQUENTIAL_SCAN = 134217728,
    FILE_FLAG_DELETE_ON_CLOSE = 67108864,
    FILE_FLAG_BACKUP_SEMANTICS = 33554432,
    FILE_FLAG_POSIX_SEMANTICS = 16777216,
    FILE_FLAG_SESSION_AWARE = 8388608,
    FILE_FLAG_OPEN_REPARSE_POINT = 2097152,
    FILE_FLAG_OPEN_NO_RECALL = 1048576,
    FILE_FLAG_FIRST_PIPE_INSTANCE = 524288,
    SECURITY_ANONYMOUS = 0,
    SECURITY_IDENTIFICATION = 65536,
    SECURITY_IMPERSONATION = 131072,
    SECURITY_DELEGATION = 196608,
    SECURITY_CONTEXT_TRACKING = 262144,
    SECURITY_EFFECTIVE_ONLY = 524288,
    SECURITY_SQOS_PRESENT = 1048576,
    SECURITY_VALID_SQOS_FLAGS = 2031616,
    _,
};
pub const FILE_ATTRIBUTE_READONLY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_READONLY;
pub const FILE_ATTRIBUTE_HIDDEN = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_HIDDEN;
pub const FILE_ATTRIBUTE_SYSTEM = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SYSTEM;
pub const FILE_ATTRIBUTE_DIRECTORY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DIRECTORY;
pub const FILE_ATTRIBUTE_ARCHIVE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ARCHIVE;
pub const FILE_ATTRIBUTE_DEVICE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_DEVICE;
pub const FILE_ATTRIBUTE_NORMAL = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NORMAL;
pub const FILE_ATTRIBUTE_TEMPORARY = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_TEMPORARY;
pub const FILE_ATTRIBUTE_SPARSE_FILE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_SPARSE_FILE;
pub const FILE_ATTRIBUTE_REPARSE_POINT = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_REPARSE_POINT;
pub const FILE_ATTRIBUTE_COMPRESSED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_COMPRESSED;
pub const FILE_ATTRIBUTE_OFFLINE = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_OFFLINE;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
pub const FILE_ATTRIBUTE_ENCRYPTED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_ENCRYPTED;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_INTEGRITY_STREAM;
pub const FILE_ATTRIBUTE_VIRTUAL = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_VIRTUAL;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_NO_SCRUB_DATA;
pub const FILE_ATTRIBUTE_EA = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_EA;
pub const FILE_ATTRIBUTE_PINNED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_PINNED;
pub const FILE_ATTRIBUTE_UNPINNED = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_UNPINNED;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_RECALL_ON_OPEN;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = FILE_FLAGS_AND_ATTRIBUTES.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
pub const FILE_FLAG_WRITE_THROUGH = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_WRITE_THROUGH;
pub const FILE_FLAG_OVERLAPPED = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OVERLAPPED;
pub const FILE_FLAG_NO_BUFFERING = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_NO_BUFFERING;
pub const FILE_FLAG_RANDOM_ACCESS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_RANDOM_ACCESS;
pub const FILE_FLAG_SEQUENTIAL_SCAN = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SEQUENTIAL_SCAN;
pub const FILE_FLAG_DELETE_ON_CLOSE = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_DELETE_ON_CLOSE;
pub const FILE_FLAG_BACKUP_SEMANTICS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_BACKUP_SEMANTICS;
pub const FILE_FLAG_POSIX_SEMANTICS = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_POSIX_SEMANTICS;
pub const FILE_FLAG_SESSION_AWARE = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_SESSION_AWARE;
pub const FILE_FLAG_OPEN_REPARSE_POINT = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OPEN_REPARSE_POINT;
pub const FILE_FLAG_OPEN_NO_RECALL = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_OPEN_NO_RECALL;
pub const FILE_FLAG_FIRST_PIPE_INSTANCE = FILE_FLAGS_AND_ATTRIBUTES.FILE_FLAG_FIRST_PIPE_INSTANCE;
pub const SECURITY_ANONYMOUS = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_ANONYMOUS;
pub const SECURITY_IDENTIFICATION = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_IDENTIFICATION;
pub const SECURITY_IMPERSONATION = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_IMPERSONATION;
pub const SECURITY_DELEGATION = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_DELEGATION;
pub const SECURITY_CONTEXT_TRACKING = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_CONTEXT_TRACKING;
pub const SECURITY_EFFECTIVE_ONLY = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_EFFECTIVE_ONLY;
pub const SECURITY_SQOS_PRESENT = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_SQOS_PRESENT;
pub const SECURITY_VALID_SQOS_FLAGS = FILE_FLAGS_AND_ATTRIBUTES.SECURITY_VALID_SQOS_FLAGS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_ACCESS_FLAGS = extern enum(u32) {
    FILE_READ_DATA = 1,
    FILE_LIST_DIRECTORY = 1,
    FILE_WRITE_DATA = 2,
    FILE_ADD_FILE = 2,
    FILE_APPEND_DATA = 4,
    FILE_ADD_SUBDIRECTORY = 4,
    FILE_CREATE_PIPE_INSTANCE = 4,
    FILE_READ_EA = 8,
    FILE_WRITE_EA = 16,
    FILE_EXECUTE = 32,
    FILE_TRAVERSE = 32,
    FILE_DELETE_CHILD = 64,
    FILE_READ_ATTRIBUTES = 128,
    FILE_WRITE_ATTRIBUTES = 256,
    READ_CONTROL = 131072,
    SYNCHRONIZE = 1048576,
    STANDARD_RIGHTS_REQUIRED = 983040,
    STANDARD_RIGHTS_READ = 131072,
    STANDARD_RIGHTS_WRITE = 131072,
    STANDARD_RIGHTS_EXECUTE = 131072,
    STANDARD_RIGHTS_ALL = 2031616,
    SPECIFIC_RIGHTS_ALL = 65535,
    FILE_ALL_ACCESS = 2032127,
    FILE_GENERIC_READ = 1179785,
    FILE_GENERIC_WRITE = 1179926,
    FILE_GENERIC_EXECUTE = 1179808,
    _,
};
pub const FILE_READ_DATA = FILE_ACCESS_FLAGS.FILE_READ_DATA;
pub const FILE_LIST_DIRECTORY = FILE_ACCESS_FLAGS.FILE_LIST_DIRECTORY;
pub const FILE_WRITE_DATA = FILE_ACCESS_FLAGS.FILE_WRITE_DATA;
pub const FILE_ADD_FILE = FILE_ACCESS_FLAGS.FILE_ADD_FILE;
pub const FILE_APPEND_DATA = FILE_ACCESS_FLAGS.FILE_APPEND_DATA;
pub const FILE_ADD_SUBDIRECTORY = FILE_ACCESS_FLAGS.FILE_ADD_SUBDIRECTORY;
pub const FILE_CREATE_PIPE_INSTANCE = FILE_ACCESS_FLAGS.FILE_CREATE_PIPE_INSTANCE;
pub const FILE_READ_EA = FILE_ACCESS_FLAGS.FILE_READ_EA;
pub const FILE_WRITE_EA = FILE_ACCESS_FLAGS.FILE_WRITE_EA;
pub const FILE_EXECUTE = FILE_ACCESS_FLAGS.FILE_EXECUTE;
pub const FILE_TRAVERSE = FILE_ACCESS_FLAGS.FILE_TRAVERSE;
pub const FILE_DELETE_CHILD = FILE_ACCESS_FLAGS.FILE_DELETE_CHILD;
pub const FILE_READ_ATTRIBUTES = FILE_ACCESS_FLAGS.FILE_READ_ATTRIBUTES;
pub const FILE_WRITE_ATTRIBUTES = FILE_ACCESS_FLAGS.FILE_WRITE_ATTRIBUTES;
pub const READ_CONTROL = FILE_ACCESS_FLAGS.READ_CONTROL;
pub const SYNCHRONIZE = FILE_ACCESS_FLAGS.SYNCHRONIZE;
pub const STANDARD_RIGHTS_REQUIRED = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_REQUIRED;
pub const STANDARD_RIGHTS_READ = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_READ;
pub const STANDARD_RIGHTS_WRITE = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_WRITE;
pub const STANDARD_RIGHTS_EXECUTE = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_EXECUTE;
pub const STANDARD_RIGHTS_ALL = FILE_ACCESS_FLAGS.STANDARD_RIGHTS_ALL;
pub const SPECIFIC_RIGHTS_ALL = FILE_ACCESS_FLAGS.SPECIFIC_RIGHTS_ALL;
pub const FILE_ALL_ACCESS = FILE_ACCESS_FLAGS.FILE_ALL_ACCESS;
pub const FILE_GENERIC_READ = FILE_ACCESS_FLAGS.FILE_GENERIC_READ;
pub const FILE_GENERIC_WRITE = FILE_ACCESS_FLAGS.FILE_GENERIC_WRITE;
pub const FILE_GENERIC_EXECUTE = FILE_ACCESS_FLAGS.FILE_GENERIC_EXECUTE;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const MARK_HANDLE_INFO32 = extern struct {
    Anonymous: _Anonymous_e__Union,
    VolumeHandle: u32,
    HandleInfo: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub const FILE_ID_128 = extern struct {
    Identifier: [16]u8,
};

pub const FILE_NOTIFY_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: FILE_ACTION,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_NOTIFY_EXTENDED_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Action: FILE_ACTION,
    CreationTime: LARGE_INTEGER,
    LastModificationTime: LARGE_INTEGER,
    LastChangeTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    AllocatedLength: LARGE_INTEGER,
    FileSize: LARGE_INTEGER,
    FileAttributes: u32,
    ReparsePointTag: u32,
    FileId: LARGE_INTEGER,
    ParentFileId: LARGE_INTEGER,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const REPARSE_GUID_DATA_BUFFER = extern struct {
    ReparseTag: u32,
    ReparseDataLength: u16,
    Reserved: u16,
    ReparseGuid: Guid,
    GenericReparseBuffer: _GenericReparseBuffer_e__Struct,
    const _GenericReparseBuffer_e__Struct = u32; // TODO: generate this nested type!
};

pub const TRANSACTION_OUTCOME = extern enum(i32) {
    Undetermined = 1,
    Committed = 2,
    Aborted = 3,
};
pub const TransactionOutcomeUndetermined = TRANSACTION_OUTCOME.Undetermined;
pub const TransactionOutcomeCommitted = TRANSACTION_OUTCOME.Committed;
pub const TransactionOutcomeAborted = TRANSACTION_OUTCOME.Aborted;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
pub const FindFileHandle = isize;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
pub const FindFileNameHandle = isize;

// TODO: this type has a FreeFunc 'FindClose', what can Zig do with this information?
pub const FindStreamHandle = isize;

// TODO: this type has a FreeFunc 'FindCloseChangeNotification', what can Zig do with this information?
pub const FindChangeNotificationHandle = isize;

// TODO: this type has a FreeFunc 'FindVolumeClose', what can Zig do with this information?
pub const FindVolumeHandle = isize;

// TODO: this type has a FreeFunc 'FindVolumeMountPointClose', what can Zig do with this information?
pub const FindVolumeMointPointHandle = isize;

pub const OVERLAPPED_ENTRY = extern struct {
    lpCompletionKey: usize,
    lpOverlapped: *OVERLAPPED,
    Internal: usize,
    dwNumberOfBytesTransferred: u32,
};

pub const WIN32_FIND_DATAA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: [260]CHAR,
    cAlternateFileName: [14]CHAR,
};

pub const WIN32_FIND_DATAW = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    dwReserved0: u32,
    dwReserved1: u32,
    cFileName: [260]u16,
    cAlternateFileName: [14]u16,
};

pub const FINDEX_INFO_LEVELS = extern enum(i32) {
    Standard = 0,
    Basic = 1,
    MaxInfoLevel = 2,
};
pub const FindExInfoStandard = FINDEX_INFO_LEVELS.Standard;
pub const FindExInfoBasic = FINDEX_INFO_LEVELS.Basic;
pub const FindExInfoMaxInfoLevel = FINDEX_INFO_LEVELS.MaxInfoLevel;

pub const FINDEX_SEARCH_OPS = extern enum(i32) {
    NameMatch = 0,
    LimitToDirectories = 1,
    LimitToDevices = 2,
    MaxSearchOp = 3,
};
pub const FindExSearchNameMatch = FINDEX_SEARCH_OPS.NameMatch;
pub const FindExSearchLimitToDirectories = FINDEX_SEARCH_OPS.LimitToDirectories;
pub const FindExSearchLimitToDevices = FINDEX_SEARCH_OPS.LimitToDevices;
pub const FindExSearchMaxSearchOp = FINDEX_SEARCH_OPS.MaxSearchOp;

pub const READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = extern enum(i32) {
    Information = 1,
    ExtendedInformation = 2,
};
pub const ReadDirectoryNotifyInformation = READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.Information;
pub const ReadDirectoryNotifyExtendedInformation = READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ExtendedInformation;

pub const GET_FILEEX_INFO_LEVELS = extern enum(i32) {
    InfoStandard = 0,
    MaxInfoLevel = 1,
};
pub const GetFileExInfoStandard = GET_FILEEX_INFO_LEVELS.InfoStandard;
pub const GetFileExMaxInfoLevel = GET_FILEEX_INFO_LEVELS.MaxInfoLevel;

pub const FILE_INFO_BY_HANDLE_CLASS = extern enum(i32) {
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
    FileStorageInfo = 16,
    FileAlignmentInfo = 17,
    FileIdInfo = 18,
    FileIdExtdDirectoryInfo = 19,
    FileIdExtdDirectoryRestartInfo = 20,
    FileDispositionInfoEx = 21,
    FileRenameInfoEx = 22,
    FileCaseSensitiveInfo = 23,
    FileNormalizedNameInfo = 24,
    MaximumFileInfoByHandleClass = 25,
};
pub const FileBasicInfo = FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo;
pub const FileStandardInfo = FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo;
pub const FileNameInfo = FILE_INFO_BY_HANDLE_CLASS.FileNameInfo;
pub const FileRenameInfo = FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo;
pub const FileDispositionInfo = FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo;
pub const FileAllocationInfo = FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo;
pub const FileEndOfFileInfo = FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo;
pub const FileStreamInfo = FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo;
pub const FileCompressionInfo = FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo;
pub const FileAttributeTagInfo = FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo;
pub const FileIdBothDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo;
pub const FileIdBothDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo;
pub const FileIoPriorityHintInfo = FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo;
pub const FileRemoteProtocolInfo = FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo;
pub const FileFullDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo;
pub const FileFullDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo;
pub const FileStorageInfo = FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo;
pub const FileAlignmentInfo = FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo;
pub const FileIdInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdInfo;
pub const FileIdExtdDirectoryInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo;
pub const FileIdExtdDirectoryRestartInfo = FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo;
pub const FileDispositionInfoEx = FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx;
pub const FileRenameInfoEx = FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx;
pub const FileCaseSensitiveInfo = FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo;
pub const FileNormalizedNameInfo = FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo;
pub const MaximumFileInfoByHandleClass = FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass;

pub const LPOVERLAPPED_COMPLETION_ROUTINE = fn(
    dwErrorCode: u32,
    dwNumberOfBytesTransfered: u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) void;

pub const STORAGE_QUERY_TYPE = extern enum(i32) {
    StandardQuery = 0,
    ExistsQuery = 1,
    MaskQuery = 2,
    QueryMaxDefined = 3,
};
pub const PropertyStandardQuery = STORAGE_QUERY_TYPE.StandardQuery;
pub const PropertyExistsQuery = STORAGE_QUERY_TYPE.ExistsQuery;
pub const PropertyMaskQuery = STORAGE_QUERY_TYPE.MaskQuery;
pub const PropertyQueryMaxDefined = STORAGE_QUERY_TYPE.QueryMaxDefined;

pub const STORAGE_PROPERTY_ID = extern enum(i32) {
    DeviceProperty = 0,
    AdapterProperty = 1,
    DeviceIdProperty = 2,
    DeviceUniqueIdProperty = 3,
    DeviceWriteCacheProperty = 4,
    MiniportProperty = 5,
    AccessAlignmentProperty = 6,
    DeviceSeekPenaltyProperty = 7,
    DeviceTrimProperty = 8,
    DeviceWriteAggregationProperty = 9,
    DeviceDeviceTelemetryProperty = 10,
    DeviceLBProvisioningProperty = 11,
    DevicePowerProperty = 12,
    DeviceCopyOffloadProperty = 13,
    DeviceResiliencyProperty = 14,
    DeviceMediumProductType = 15,
    AdapterRpmbProperty = 16,
    AdapterCryptoProperty = 17,
    DeviceIoCapabilityProperty = 48,
    AdapterProtocolSpecificProperty = 49,
    DeviceProtocolSpecificProperty = 50,
    AdapterTemperatureProperty = 51,
    DeviceTemperatureProperty = 52,
    AdapterPhysicalTopologyProperty = 53,
    DevicePhysicalTopologyProperty = 54,
    DeviceAttributesProperty = 55,
    DeviceManagementStatus = 56,
    AdapterSerialNumberProperty = 57,
    DeviceLocationProperty = 58,
    DeviceNumaProperty = 59,
    DeviceZonedDeviceProperty = 60,
    DeviceUnsafeShutdownCount = 61,
    DeviceEnduranceProperty = 62,
};
pub const StorageDeviceProperty = STORAGE_PROPERTY_ID.DeviceProperty;
pub const StorageAdapterProperty = STORAGE_PROPERTY_ID.AdapterProperty;
pub const StorageDeviceIdProperty = STORAGE_PROPERTY_ID.DeviceIdProperty;
pub const StorageDeviceUniqueIdProperty = STORAGE_PROPERTY_ID.DeviceUniqueIdProperty;
pub const StorageDeviceWriteCacheProperty = STORAGE_PROPERTY_ID.DeviceWriteCacheProperty;
pub const StorageMiniportProperty = STORAGE_PROPERTY_ID.MiniportProperty;
pub const StorageAccessAlignmentProperty = STORAGE_PROPERTY_ID.AccessAlignmentProperty;
pub const StorageDeviceSeekPenaltyProperty = STORAGE_PROPERTY_ID.DeviceSeekPenaltyProperty;
pub const StorageDeviceTrimProperty = STORAGE_PROPERTY_ID.DeviceTrimProperty;
pub const StorageDeviceWriteAggregationProperty = STORAGE_PROPERTY_ID.DeviceWriteAggregationProperty;
pub const StorageDeviceDeviceTelemetryProperty = STORAGE_PROPERTY_ID.DeviceDeviceTelemetryProperty;
pub const StorageDeviceLBProvisioningProperty = STORAGE_PROPERTY_ID.DeviceLBProvisioningProperty;
pub const StorageDevicePowerProperty = STORAGE_PROPERTY_ID.DevicePowerProperty;
pub const StorageDeviceCopyOffloadProperty = STORAGE_PROPERTY_ID.DeviceCopyOffloadProperty;
pub const StorageDeviceResiliencyProperty = STORAGE_PROPERTY_ID.DeviceResiliencyProperty;
pub const StorageDeviceMediumProductType = STORAGE_PROPERTY_ID.DeviceMediumProductType;
pub const StorageAdapterRpmbProperty = STORAGE_PROPERTY_ID.AdapterRpmbProperty;
pub const StorageAdapterCryptoProperty = STORAGE_PROPERTY_ID.AdapterCryptoProperty;
pub const StorageDeviceIoCapabilityProperty = STORAGE_PROPERTY_ID.DeviceIoCapabilityProperty;
pub const StorageAdapterProtocolSpecificProperty = STORAGE_PROPERTY_ID.AdapterProtocolSpecificProperty;
pub const StorageDeviceProtocolSpecificProperty = STORAGE_PROPERTY_ID.DeviceProtocolSpecificProperty;
pub const StorageAdapterTemperatureProperty = STORAGE_PROPERTY_ID.AdapterTemperatureProperty;
pub const StorageDeviceTemperatureProperty = STORAGE_PROPERTY_ID.DeviceTemperatureProperty;
pub const StorageAdapterPhysicalTopologyProperty = STORAGE_PROPERTY_ID.AdapterPhysicalTopologyProperty;
pub const StorageDevicePhysicalTopologyProperty = STORAGE_PROPERTY_ID.DevicePhysicalTopologyProperty;
pub const StorageDeviceAttributesProperty = STORAGE_PROPERTY_ID.DeviceAttributesProperty;
pub const StorageDeviceManagementStatus = STORAGE_PROPERTY_ID.DeviceManagementStatus;
pub const StorageAdapterSerialNumberProperty = STORAGE_PROPERTY_ID.AdapterSerialNumberProperty;
pub const StorageDeviceLocationProperty = STORAGE_PROPERTY_ID.DeviceLocationProperty;
pub const StorageDeviceNumaProperty = STORAGE_PROPERTY_ID.DeviceNumaProperty;
pub const StorageDeviceZonedDeviceProperty = STORAGE_PROPERTY_ID.DeviceZonedDeviceProperty;
pub const StorageDeviceUnsafeShutdownCount = STORAGE_PROPERTY_ID.DeviceUnsafeShutdownCount;
pub const StorageDeviceEnduranceProperty = STORAGE_PROPERTY_ID.DeviceEnduranceProperty;

pub const STORAGE_PROPERTY_QUERY = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    QueryType: STORAGE_QUERY_TYPE,
    AdditionalParameters: [1]u8,
};

pub const STORAGE_DESCRIPTOR_HEADER = extern struct {
    Version: u32,
    Size: u32,
};

pub const STORAGE_DEVICE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceType: u8,
    DeviceTypeModifier: u8,
    RemovableMedia: u8,
    CommandQueueing: u8,
    VendorIdOffset: u32,
    ProductIdOffset: u32,
    ProductRevisionOffset: u32,
    SerialNumberOffset: u32,
    BusType: STORAGE_BUS_TYPE,
    RawPropertiesLength: u32,
    RawDeviceProperties: [1]u8,
};

pub const STORAGE_ADAPTER_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MaximumTransferLength: u32,
    MaximumPhysicalPages: u32,
    AlignmentMask: u32,
    AdapterUsesPio: u8,
    AdapterScansDown: u8,
    CommandQueueing: u8,
    AcceleratedTransfer: u8,
    BusType: u8,
    BusMajorVersion: u16,
    BusMinorVersion: u16,
    SrbType: u8,
    AddressType: u8,
};

pub const STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    BytesPerCacheLine: u32,
    BytesOffsetForCacheAlignment: u32,
    BytesPerLogicalSector: u32,
    BytesPerPhysicalSector: u32,
    BytesOffsetForSectorAlignment: u32,
};

pub const STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MediumProductType: u32,
};

pub const STORAGE_PORT_CODE_SET = extern enum(i32) {
    Reserved = 0,
    Storport = 1,
    SCSIport = 2,
    Spaceport = 3,
    ATAport = 4,
    USBport = 5,
    SBP2port = 6,
    SDport = 7,
};
pub const StoragePortCodeSetReserved = STORAGE_PORT_CODE_SET.Reserved;
pub const StoragePortCodeSetStorport = STORAGE_PORT_CODE_SET.Storport;
pub const StoragePortCodeSetSCSIport = STORAGE_PORT_CODE_SET.SCSIport;
pub const StoragePortCodeSetSpaceport = STORAGE_PORT_CODE_SET.Spaceport;
pub const StoragePortCodeSetATAport = STORAGE_PORT_CODE_SET.ATAport;
pub const StoragePortCodeSetUSBport = STORAGE_PORT_CODE_SET.USBport;
pub const StoragePortCodeSetSBP2port = STORAGE_PORT_CODE_SET.SBP2port;
pub const StoragePortCodeSetSDport = STORAGE_PORT_CODE_SET.SDport;

pub const STORAGE_MINIPORT_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Portdriver: STORAGE_PORT_CODE_SET,
    LUNResetSupported: u8,
    TargetResetSupported: u8,
    IoTimeoutValue: u16,
    ExtraIoInfoSupported: u8,
    Reserved0: [3]u8,
    Reserved1: u32,
};

pub const STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumberOfIdentifiers: u32,
    Identifiers: [1]u8,
};

pub const DEVICE_SEEK_PENALTY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    IncursSeekPenalty: u8,
};

pub const DEVICE_WRITE_AGGREGATION_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    BenefitsFromWriteAggregation: u8,
};

pub const DEVICE_TRIM_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    TrimEnabled: u8,
};

pub const DEVICE_LB_PROVISIONING_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u8,
    Reserved1: [7]u8,
    OptimalUnmapGranularity: u64,
    UnmapGranularityAlignment: u64,
    MaxUnmapLbaCount: u32,
    MaxUnmapBlockDescriptorCount: u32,
};

pub const DEVICE_POWER_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceAttentionSupported: u8,
    AsynchronousNotificationSupported: u8,
    IdlePowerManagementEnabled: u8,
    D3ColdEnabled: u8,
    D3ColdSupported: u8,
    NoVerifyDuringIdlePower: u8,
    Reserved: [2]u8,
    IdleTimeoutInMS: u32,
};

pub const DEVICE_COPY_OFFLOAD_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    MaximumTokenLifetime: u32,
    DefaultTokenLifetime: u32,
    MaximumTransferSize: u64,
    OptimalTransferCount: u64,
    MaximumDataDescriptors: u32,
    MaximumTransferLengthPerDescriptor: u32,
    OptimalTransferLengthPerDescriptor: u32,
    OptimalTransferLengthGranularity: u16,
    Reserved: [2]u8,
};

pub const STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NameOffset: u32,
    NumberOfLogicalCopies: u32,
    NumberOfPhysicalCopies: u32,
    PhysicalDiskRedundancy: u32,
    NumberOfColumns: u32,
    Interleave: u32,
};

pub const STORAGE_PROTOCOL_TYPE = extern enum(i32) {
    Unknown = 0,
    Scsi = 1,
    Ata = 2,
    Nvme = 3,
    Sd = 4,
    Ufs = 5,
    Proprietary = 126,
    MaxReserved = 127,
};
pub const ProtocolTypeUnknown = STORAGE_PROTOCOL_TYPE.Unknown;
pub const ProtocolTypeScsi = STORAGE_PROTOCOL_TYPE.Scsi;
pub const ProtocolTypeAta = STORAGE_PROTOCOL_TYPE.Ata;
pub const ProtocolTypeNvme = STORAGE_PROTOCOL_TYPE.Nvme;
pub const ProtocolTypeSd = STORAGE_PROTOCOL_TYPE.Sd;
pub const ProtocolTypeUfs = STORAGE_PROTOCOL_TYPE.Ufs;
pub const ProtocolTypeProprietary = STORAGE_PROTOCOL_TYPE.Proprietary;
pub const ProtocolTypeMaxReserved = STORAGE_PROTOCOL_TYPE.MaxReserved;

pub const STORAGE_PROTOCOL_NVME_DATA_TYPE = extern enum(i32) {
    Unknown = 0,
    Identify = 1,
    LogPage = 2,
    Feature = 3,
};
pub const NVMeDataTypeUnknown = STORAGE_PROTOCOL_NVME_DATA_TYPE.Unknown;
pub const NVMeDataTypeIdentify = STORAGE_PROTOCOL_NVME_DATA_TYPE.Identify;
pub const NVMeDataTypeLogPage = STORAGE_PROTOCOL_NVME_DATA_TYPE.LogPage;
pub const NVMeDataTypeFeature = STORAGE_PROTOCOL_NVME_DATA_TYPE.Feature;

pub const STORAGE_PROTOCOL_ATA_DATA_TYPE = extern enum(i32) {
    Unknown = 0,
    Identify = 1,
    LogPage = 2,
};
pub const AtaDataTypeUnknown = STORAGE_PROTOCOL_ATA_DATA_TYPE.Unknown;
pub const AtaDataTypeIdentify = STORAGE_PROTOCOL_ATA_DATA_TYPE.Identify;
pub const AtaDataTypeLogPage = STORAGE_PROTOCOL_ATA_DATA_TYPE.LogPage;

pub const STORAGE_PROTOCOL_SPECIFIC_DATA = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: u32,
    ProtocolDataRequestValue: u32,
    ProtocolDataRequestSubValue: u32,
    ProtocolDataOffset: u32,
    ProtocolDataLength: u32,
    FixedProtocolReturnData: u32,
    ProtocolDataRequestSubValue2: u32,
    ProtocolDataRequestSubValue3: u32,
    Reserved: u32,
};

pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
};

pub const STORAGE_TEMPERATURE_INFO = extern struct {
    Index: u16,
    Temperature: i16,
    OverThreshold: i16,
    UnderThreshold: i16,
    OverThresholdChangable: u8,
    UnderThresholdChangable: u8,
    EventGenerated: u8,
    Reserved0: u8,
    Reserved1: u32,
};

pub const STORAGE_TEMPERATURE_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    CriticalTemperature: i16,
    WarningTemperature: i16,
    InfoCount: u16,
    Reserved0: [2]u8,
    Reserved1: [2]u32,
    TemperatureInfo: [1]STORAGE_TEMPERATURE_INFO,
};

pub const STORAGE_TEMPERATURE_THRESHOLD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u16,
    Index: u16,
    Threshold: i16,
    OverThreshold: u8,
    Reserved: u8,
};

pub const STORAGE_DEVICE_FORM_FACTOR = extern enum(i32) {
    Unknown = 0,
    @"3_5" = 1,
    @"2_5" = 2,
    @"1_8" = 3,
    @"1_8Less" = 4,
    Embedded = 5,
    MemoryCard = 6,
    mSata = 7,
    M_2 = 8,
    PCIeBoard = 9,
    Dimm = 10,
};
pub const FormFactorUnknown = STORAGE_DEVICE_FORM_FACTOR.Unknown;
pub const FormFactor3_5 = STORAGE_DEVICE_FORM_FACTOR.@"3_5";
pub const FormFactor2_5 = STORAGE_DEVICE_FORM_FACTOR.@"2_5";
pub const FormFactor1_8 = STORAGE_DEVICE_FORM_FACTOR.@"1_8";
pub const FormFactor1_8Less = STORAGE_DEVICE_FORM_FACTOR.@"1_8Less";
pub const FormFactorEmbedded = STORAGE_DEVICE_FORM_FACTOR.Embedded;
pub const FormFactorMemoryCard = STORAGE_DEVICE_FORM_FACTOR.MemoryCard;
pub const FormFactormSata = STORAGE_DEVICE_FORM_FACTOR.mSata;
pub const FormFactorM_2 = STORAGE_DEVICE_FORM_FACTOR.M_2;
pub const FormFactorPCIeBoard = STORAGE_DEVICE_FORM_FACTOR.PCIeBoard;
pub const FormFactorDimm = STORAGE_DEVICE_FORM_FACTOR.Dimm;

pub const STORAGE_COMPONENT_HEALTH_STATUS = extern enum(i32) {
    Unknown = 0,
    Normal = 1,
    Throttled = 2,
    Warning = 3,
    Disabled = 4,
    Failed = 5,
};
pub const HealthStatusUnknown = STORAGE_COMPONENT_HEALTH_STATUS.Unknown;
pub const HealthStatusNormal = STORAGE_COMPONENT_HEALTH_STATUS.Normal;
pub const HealthStatusThrottled = STORAGE_COMPONENT_HEALTH_STATUS.Throttled;
pub const HealthStatusWarning = STORAGE_COMPONENT_HEALTH_STATUS.Warning;
pub const HealthStatusDisabled = STORAGE_COMPONENT_HEALTH_STATUS.Disabled;
pub const HealthStatusFailed = STORAGE_COMPONENT_HEALTH_STATUS.Failed;

pub const STORAGE_SPEC_VERSION = extern union {
    Anonymous: _Anonymous_e__Struct,
    AsUlong: u32,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const STORAGE_PHYSICAL_DEVICE_DATA = extern struct {
    DeviceId: u32,
    Role: u32,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    FormFactor: STORAGE_DEVICE_FORM_FACTOR,
    Vendor: [8]u8,
    Model: [40]u8,
    FirmwareRevision: [16]u8,
    Capacity: u64,
    PhysicalLocation: [32]u8,
    Reserved: [2]u32,
};

pub const STORAGE_PHYSICAL_ADAPTER_DATA = extern struct {
    AdapterId: u32,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    Vendor: [8]u8,
    Model: [40]u8,
    FirmwareRevision: [16]u8,
    PhysicalLocation: [32]u8,
    ExpanderConnected: u8,
    Reserved0: [3]u8,
    Reserved1: [3]u32,
};

pub const STORAGE_PHYSICAL_NODE_DATA = extern struct {
    NodeId: u32,
    AdapterCount: u32,
    AdapterDataLength: u32,
    AdapterDataOffset: u32,
    DeviceCount: u32,
    DeviceDataLength: u32,
    DeviceDataOffset: u32,
    Reserved: [3]u32,
};

pub const STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NodeCount: u32,
    Reserved: u32,
    Node: [1]STORAGE_PHYSICAL_NODE_DATA,
};

pub const STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    LunMaxIoCount: u32,
    AdapterMaxIoCount: u32,
};

pub const STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Attributes: u64,
};

pub const STORAGE_ADAPTER_SERIAL_NUMBER = extern struct {
    Version: u32,
    Size: u32,
    SerialNumber: [128]u16,
};

pub const WRITE_CACHE_TYPE = extern enum(i32) {
    Unknown = 0,
    None = 1,
    WriteBack = 2,
    WriteThrough = 3,
};
pub const WriteCacheTypeUnknown = WRITE_CACHE_TYPE.Unknown;
pub const WriteCacheTypeNone = WRITE_CACHE_TYPE.None;
pub const WriteCacheTypeWriteBack = WRITE_CACHE_TYPE.WriteBack;
pub const WriteCacheTypeWriteThrough = WRITE_CACHE_TYPE.WriteThrough;

pub const WRITE_CACHE_ENABLE = extern enum(i32) {
    EnableUnknown = 0,
    Disabled = 1,
    Enabled = 2,
};
pub const WriteCacheEnableUnknown = WRITE_CACHE_ENABLE.EnableUnknown;
pub const WriteCacheDisabled = WRITE_CACHE_ENABLE.Disabled;
pub const WriteCacheEnabled = WRITE_CACHE_ENABLE.Enabled;

pub const WRITE_CACHE_CHANGE = extern enum(i32) {
    ChangeUnknown = 0,
    NotChangeable = 1,
    Changeable = 2,
};
pub const WriteCacheChangeUnknown = WRITE_CACHE_CHANGE.ChangeUnknown;
pub const WriteCacheNotChangeable = WRITE_CACHE_CHANGE.NotChangeable;
pub const WriteCacheChangeable = WRITE_CACHE_CHANGE.Changeable;

pub const WRITE_THROUGH = extern enum(i32) {
    Unknown = 0,
    NotSupported = 1,
    Supported = 2,
};
pub const WriteThroughUnknown = WRITE_THROUGH.Unknown;
pub const WriteThroughNotSupported = WRITE_THROUGH.NotSupported;
pub const WriteThroughSupported = WRITE_THROUGH.Supported;

pub const STORAGE_WRITE_CACHE_PROPERTY = extern struct {
    Version: u32,
    Size: u32,
    WriteCacheType: WRITE_CACHE_TYPE,
    WriteCacheEnabled: WRITE_CACHE_ENABLE,
    WriteCacheChangeable: WRITE_CACHE_CHANGE,
    WriteThroughSupported: WRITE_THROUGH,
    FlushCacheSupported: u8,
    UserDefinedPowerProtection: u8,
    NVCacheEnabled: u8,
};

pub const STORAGE_DEVICE_POWER_CAP_UNITS = extern enum(i32) {
    Percent = 0,
    Milliwatts = 1,
};
pub const StorageDevicePowerCapUnitsPercent = STORAGE_DEVICE_POWER_CAP_UNITS.Percent;
pub const StorageDevicePowerCapUnitsMilliwatts = STORAGE_DEVICE_POWER_CAP_UNITS.Milliwatts;

pub const STORAGE_DEVICE_POWER_CAP = extern struct {
    Version: u32,
    Size: u32,
    Units: STORAGE_DEVICE_POWER_CAP_UNITS,
    MaxPower: u64,
};

pub const STORAGE_HW_FIRMWARE_DOWNLOAD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: [3]u8,
    Offset: u64,
    BufferSize: u64,
    ImageBuffer: [1]u8,
};

pub const STORAGE_HW_FIRMWARE_ACTIVATE = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved0: [3]u8,
};

pub const STORAGE_PROTOCOL_COMMAND = extern struct {
    Version: u32,
    Length: u32,
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    Flags: u32,
    ReturnStatus: u32,
    ErrorCode: u32,
    CommandLength: u32,
    ErrorInfoLength: u32,
    DataToDeviceTransferLength: u32,
    DataFromDeviceTransferLength: u32,
    TimeOutValue: u32,
    ErrorInfoOffset: u32,
    DataToDeviceBufferOffset: u32,
    DataFromDeviceBufferOffset: u32,
    CommandSpecific: u32,
    Reserved0: u32,
    FixedProtocolReturnData: u32,
    Reserved1: [3]u32,
    Command: [1]u8,
};

pub const MEDIA_TYPE = extern enum(i32) {
    Unknown = 0,
    F5_1Pt2_512 = 1,
    F3_1Pt44_512 = 2,
    F3_2Pt88_512 = 3,
    F3_20Pt8_512 = 4,
    F3_720_512 = 5,
    F5_360_512 = 6,
    F5_320_512 = 7,
    F5_320_1024 = 8,
    F5_180_512 = 9,
    F5_160_512 = 10,
    RemovableMedia = 11,
    FixedMedia = 12,
    F3_120M_512 = 13,
    F3_640_512 = 14,
    F5_640_512 = 15,
    F5_720_512 = 16,
    F3_1Pt2_512 = 17,
    F3_1Pt23_1024 = 18,
    F5_1Pt23_1024 = 19,
    F3_128Mb_512 = 20,
    F3_230Mb_512 = 21,
    F8_256_128 = 22,
    F3_200Mb_512 = 23,
    F3_240M_512 = 24,
    F3_32M_512 = 25,
};
pub const Unknown = MEDIA_TYPE.Unknown;
pub const F5_1Pt2_512 = MEDIA_TYPE.F5_1Pt2_512;
pub const F3_1Pt44_512 = MEDIA_TYPE.F3_1Pt44_512;
pub const F3_2Pt88_512 = MEDIA_TYPE.F3_2Pt88_512;
pub const F3_20Pt8_512 = MEDIA_TYPE.F3_20Pt8_512;
pub const F3_720_512 = MEDIA_TYPE.F3_720_512;
pub const F5_360_512 = MEDIA_TYPE.F5_360_512;
pub const F5_320_512 = MEDIA_TYPE.F5_320_512;
pub const F5_320_1024 = MEDIA_TYPE.F5_320_1024;
pub const F5_180_512 = MEDIA_TYPE.F5_180_512;
pub const F5_160_512 = MEDIA_TYPE.F5_160_512;
pub const RemovableMedia = MEDIA_TYPE.RemovableMedia;
pub const FixedMedia = MEDIA_TYPE.FixedMedia;
pub const F3_120M_512 = MEDIA_TYPE.F3_120M_512;
pub const F3_640_512 = MEDIA_TYPE.F3_640_512;
pub const F5_640_512 = MEDIA_TYPE.F5_640_512;
pub const F5_720_512 = MEDIA_TYPE.F5_720_512;
pub const F3_1Pt2_512 = MEDIA_TYPE.F3_1Pt2_512;
pub const F3_1Pt23_1024 = MEDIA_TYPE.F3_1Pt23_1024;
pub const F5_1Pt23_1024 = MEDIA_TYPE.F5_1Pt23_1024;
pub const F3_128Mb_512 = MEDIA_TYPE.F3_128Mb_512;
pub const F3_230Mb_512 = MEDIA_TYPE.F3_230Mb_512;
pub const F8_256_128 = MEDIA_TYPE.F8_256_128;
pub const F3_200Mb_512 = MEDIA_TYPE.F3_200Mb_512;
pub const F3_240M_512 = MEDIA_TYPE.F3_240M_512;
pub const F3_32M_512 = MEDIA_TYPE.F3_32M_512;

pub const FORMAT_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: u32,
    EndCylinderNumber: u32,
    StartHeadNumber: u32,
    EndHeadNumber: u32,
};

pub const FORMAT_EX_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: u32,
    EndCylinderNumber: u32,
    StartHeadNumber: u32,
    EndHeadNumber: u32,
    FormatGapLength: u16,
    SectorsPerTrack: u16,
    SectorNumber: [1]u16,
};

pub const DISK_GEOMETRY = extern struct {
    Cylinders: LARGE_INTEGER,
    MediaType: MEDIA_TYPE,
    TracksPerCylinder: u32,
    SectorsPerTrack: u32,
    BytesPerSector: u32,
};

pub const PARTITION_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    HiddenSectors: u32,
    PartitionNumber: u32,
    PartitionType: u8,
    BootIndicator: u8,
    RecognizedPartition: u8,
    RewritePartition: u8,
};

pub const SET_PARTITION_INFORMATION = extern struct {
    PartitionType: u8,
};

pub const DRIVE_LAYOUT_INFORMATION = extern struct {
    PartitionCount: u32,
    Signature: u32,
    PartitionEntry: [1]PARTITION_INFORMATION,
};

pub const VERIFY_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    Length: u32,
};

pub const REASSIGN_BLOCKS = extern struct {
    Reserved: u16,
    Count: u16,
    BlockNumber: [1]u32,
};

pub const REASSIGN_BLOCKS_EX = extern struct {
    Reserved: u16,
    Count: u16,
    BlockNumber: [1]LARGE_INTEGER,
};

pub const PARTITION_STYLE = extern enum(i32) {
    MBR = 0,
    GPT = 1,
    RAW = 2,
};
pub const PARTITION_STYLE_MBR = PARTITION_STYLE.MBR;
pub const PARTITION_STYLE_GPT = PARTITION_STYLE.GPT;
pub const PARTITION_STYLE_RAW = PARTITION_STYLE.RAW;

pub const PARTITION_INFORMATION_GPT = extern struct {
    PartitionType: Guid,
    PartitionId: Guid,
    Attributes: GPT_ATTRIBUTES,
    Name: [36]u16,
};

pub const PARTITION_INFORMATION_MBR = extern struct {
    PartitionType: u8,
    BootIndicator: u8,
    RecognizedPartition: u8,
    HiddenSectors: u32,
    PartitionId: Guid,
};

pub const CREATE_DISK_GPT = extern struct {
    DiskId: Guid,
    MaxPartitionCount: u32,
};

pub const CREATE_DISK_MBR = extern struct {
    Signature: u32,
};

pub const CREATE_DISK = extern struct {
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const GET_LENGTH_INFORMATION = extern struct {
    Length: LARGE_INTEGER,
};

pub const PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    PartitionNumber: u32,
    RewritePartition: u8,
    IsServicePartition: u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DRIVE_LAYOUT_INFORMATION_GPT = extern struct {
    DiskId: Guid,
    StartingUsableOffset: LARGE_INTEGER,
    UsableLength: LARGE_INTEGER,
    MaxPartitionCount: u32,
};

pub const DRIVE_LAYOUT_INFORMATION_MBR = extern struct {
    Signature: u32,
    CheckSum: u32,
};

pub const DRIVE_LAYOUT_INFORMATION_EX = extern struct {
    PartitionStyle: u32,
    PartitionCount: u32,
    Anonymous: _Anonymous_e__Union,
    PartitionEntry: [1]PARTITION_INFORMATION_EX,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DISK_INT13_INFO = extern struct {
    DriveSelect: u16,
    MaxCylinders: u32,
    SectorsPerTrack: u16,
    MaxHeads: u16,
    NumberDrives: u16,
};

pub const DISK_EX_INT13_INFO = extern struct {
    ExBufferSize: u16,
    ExFlags: u16,
    ExCylinders: u32,
    ExHeads: u32,
    ExSectorsPerTrack: u32,
    ExSectorsPerDrive: u64,
    ExSectorSize: u16,
    ExReserved: u16,
};

pub const DISK_DETECTION_INFO = extern struct {
    SizeOfDetectInfo: u32,
    DetectionType: DETECTION_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DISK_PARTITION_INFO = extern struct {
    SizeOfPartitionInfo: u32,
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DISK_GEOMETRY_EX = extern struct {
    Geometry: DISK_GEOMETRY,
    DiskSize: LARGE_INTEGER,
    Data: [1]u8,
};

pub const DISK_CACHE_INFORMATION = extern struct {
    ParametersSavable: u8,
    ReadCacheEnabled: u8,
    WriteCacheEnabled: u8,
    ReadRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    WriteRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    DisablePrefetchTransferLength: u16,
    PrefetchScalar: u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DISK_GROW_PARTITION = extern struct {
    PartitionNumber: u32,
    BytesToGrow: LARGE_INTEGER,
};

pub const DISK_PERFORMANCE = extern struct {
    BytesRead: LARGE_INTEGER,
    BytesWritten: LARGE_INTEGER,
    ReadTime: LARGE_INTEGER,
    WriteTime: LARGE_INTEGER,
    IdleTime: LARGE_INTEGER,
    ReadCount: u32,
    WriteCount: u32,
    QueueDepth: u32,
    SplitCount: u32,
    QueryTime: LARGE_INTEGER,
    StorageDeviceNumber: u32,
    StorageManagerName: [8]u16,
};

pub const GET_DISK_ATTRIBUTES = extern struct {
    Version: u32,
    Reserved1: u32,
    Attributes: u64,
};

pub const SET_DISK_ATTRIBUTES = extern struct {
    Version: u32,
    Persist: u8,
    Reserved1: [3]u8,
    Attributes: u64,
    AttributesMask: u64,
    Reserved2: [4]u32,
};

pub const NTFS_VOLUME_DATA_BUFFER = extern struct {
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: u32,
    BytesPerCluster: u32,
    BytesPerFileRecordSegment: u32,
    ClustersPerFileRecordSegment: u32,
    MftValidDataLength: LARGE_INTEGER,
    MftStartLcn: LARGE_INTEGER,
    Mft2StartLcn: LARGE_INTEGER,
    MftZoneStart: LARGE_INTEGER,
    MftZoneEnd: LARGE_INTEGER,
};

pub const NTFS_EXTENDED_VOLUME_DATA = extern struct {
    ByteCount: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    BytesPerPhysicalSector: u32,
    LfsMajorVersion: u16,
    LfsMinorVersion: u16,
    MaxDeviceTrimExtentCount: u32,
    MaxDeviceTrimByteCount: u32,
    MaxVolumeTrimExtentCount: u32,
    MaxVolumeTrimByteCount: u32,
};

pub const STARTING_LCN_INPUT_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
};

pub const VOLUME_BITMAP_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
    BitmapSize: LARGE_INTEGER,
    Buffer: [1]u8,
};

pub const STARTING_VCN_INPUT_BUFFER = extern struct {
    StartingVcn: LARGE_INTEGER,
};

pub const RETRIEVAL_POINTERS_BUFFER = extern struct {
    ExtentCount: u32,
    StartingVcn: LARGE_INTEGER,
    Extents: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const NTFS_FILE_RECORD_INPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
};

pub const NTFS_FILE_RECORD_OUTPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
    FileRecordLength: u32,
    FileRecordBuffer: [1]u8,
};

pub const MOVE_FILE_DATA = extern struct {
    FileHandle: HANDLE,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: u32,
};

pub const FIND_BY_SID_DATA = extern struct {
    Restart: u32,
    Sid: SID,
};

pub const FIND_BY_SID_OUTPUT = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const MFT_ENUM_DATA_V0 = extern struct {
    StartFileReferenceNumber: u64,
    LowUsn: i64,
    HighUsn: i64,
};

pub const MFT_ENUM_DATA_V1 = extern struct {
    StartFileReferenceNumber: u64,
    LowUsn: i64,
    HighUsn: i64,
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};

pub const CREATE_USN_JOURNAL_DATA = extern struct {
    MaximumSize: u64,
    AllocationDelta: u64,
};

pub const READ_FILE_USN_DATA = extern struct {
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};

pub const READ_USN_JOURNAL_DATA_V0 = extern struct {
    StartUsn: i64,
    ReasonMask: u32,
    ReturnOnlyOnClose: u32,
    Timeout: u64,
    BytesToWaitFor: u64,
    UsnJournalID: u64,
};

pub const READ_USN_JOURNAL_DATA_V1 = extern struct {
    StartUsn: i64,
    ReasonMask: u32,
    ReturnOnlyOnClose: u32,
    Timeout: u64,
    BytesToWaitFor: u64,
    UsnJournalID: u64,
    MinMajorVersion: u16,
    MaxMajorVersion: u16,
};

pub const USN_TRACK_MODIFIED_RANGES = extern struct {
    Flags: u32,
    Unused: u32,
    ChunkSize: u64,
    FileSizeThreshold: i64,
};

pub const USN_RANGE_TRACK_OUTPUT = extern struct {
    Usn: i64,
};

pub const USN_RECORD_V2 = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    FileReferenceNumber: u64,
    ParentFileReferenceNumber: u64,
    Usn: i64,
    TimeStamp: LARGE_INTEGER,
    Reason: u32,
    SourceInfo: u32,
    SecurityId: u32,
    FileAttributes: u32,
    FileNameLength: u16,
    FileNameOffset: u16,
    FileName: [1]u16,
};

pub const USN_RECORD_V3 = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: i64,
    TimeStamp: LARGE_INTEGER,
    Reason: u32,
    SourceInfo: u32,
    SecurityId: u32,
    FileAttributes: u32,
    FileNameLength: u16,
    FileNameOffset: u16,
    FileName: [1]u16,
};

pub const USN_RECORD_COMMON_HEADER = extern struct {
    RecordLength: u32,
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const USN_RECORD_EXTENT = extern struct {
    Offset: i64,
    Length: i64,
};

pub const USN_RECORD_V4 = extern struct {
    Header: USN_RECORD_COMMON_HEADER,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: i64,
    Reason: u32,
    SourceInfo: USN_SOURCE_INFO_ID,
    RemainingExtents: u32,
    NumberOfExtents: u16,
    ExtentSize: u16,
    Extents: [1]USN_RECORD_EXTENT,
};

pub const USN_JOURNAL_DATA_V0 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
};

pub const USN_JOURNAL_DATA_V1 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
    MinSupportedMajorVersion: u16,
    MaxSupportedMajorVersion: u16,
};

pub const USN_JOURNAL_DATA_V2 = extern struct {
    UsnJournalID: u64,
    FirstUsn: i64,
    NextUsn: i64,
    LowestValidUsn: i64,
    MaxUsn: i64,
    MaximumSize: u64,
    AllocationDelta: u64,
    MinSupportedMajorVersion: u16,
    MaxSupportedMajorVersion: u16,
    Flags: u32,
    RangeTrackChunkSize: u64,
    RangeTrackFileSizeThreshold: i64,
};

pub const DELETE_USN_JOURNAL_DATA = extern struct {
    UsnJournalID: u64,
    DeleteFlags: USN_DELETE_FLAGS,
};

pub const MARK_HANDLE_INFO = extern struct {
    Anonymous: _Anonymous_e__Union,
    VolumeHandle: HANDLE,
    HandleInfo: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const FILESYSTEM_STATISTICS = extern struct {
    FileSystemType: FILESYSTEM_STATISTICS_TYPE,
    Version: u16,
    SizeOfCompleteStructure: u32,
    UserFileReads: u32,
    UserFileReadBytes: u32,
    UserDiskReads: u32,
    UserFileWrites: u32,
    UserFileWriteBytes: u32,
    UserDiskWrites: u32,
    MetaDataReads: u32,
    MetaDataReadBytes: u32,
    MetaDataDiskReads: u32,
    MetaDataWrites: u32,
    MetaDataWriteBytes: u32,
    MetaDataDiskWrites: u32,
};

pub const FAT_STATISTICS = extern struct {
    CreateHits: u32,
    SuccessfulCreates: u32,
    FailedCreates: u32,
    NonCachedReads: u32,
    NonCachedReadBytes: u32,
    NonCachedWrites: u32,
    NonCachedWriteBytes: u32,
    NonCachedDiskReads: u32,
    NonCachedDiskWrites: u32,
};

pub const EXFAT_STATISTICS = extern struct {
    CreateHits: u32,
    SuccessfulCreates: u32,
    FailedCreates: u32,
    NonCachedReads: u32,
    NonCachedReadBytes: u32,
    NonCachedWrites: u32,
    NonCachedWriteBytes: u32,
    NonCachedDiskReads: u32,
    NonCachedDiskWrites: u32,
};

pub const NTFS_STATISTICS = extern struct {
    LogFileFullExceptions: u32,
    OtherExceptions: u32,
    MftReads: u32,
    MftReadBytes: u32,
    MftWrites: u32,
    MftWriteBytes: u32,
    MftWritesUserLevel: _MftWritesUserLevel_e__Struct,
    MftWritesFlushForLogFileFull: u16,
    MftWritesLazyWriter: u16,
    MftWritesUserRequest: u16,
    Mft2Writes: u32,
    Mft2WriteBytes: u32,
    Mft2WritesUserLevel: _Mft2WritesUserLevel_e__Struct,
    Mft2WritesFlushForLogFileFull: u16,
    Mft2WritesLazyWriter: u16,
    Mft2WritesUserRequest: u16,
    RootIndexReads: u32,
    RootIndexReadBytes: u32,
    RootIndexWrites: u32,
    RootIndexWriteBytes: u32,
    BitmapReads: u32,
    BitmapReadBytes: u32,
    BitmapWrites: u32,
    BitmapWriteBytes: u32,
    BitmapWritesFlushForLogFileFull: u16,
    BitmapWritesLazyWriter: u16,
    BitmapWritesUserRequest: u16,
    BitmapWritesUserLevel: _BitmapWritesUserLevel_e__Struct,
    MftBitmapReads: u32,
    MftBitmapReadBytes: u32,
    MftBitmapWrites: u32,
    MftBitmapWriteBytes: u32,
    MftBitmapWritesFlushForLogFileFull: u16,
    MftBitmapWritesLazyWriter: u16,
    MftBitmapWritesUserRequest: u16,
    MftBitmapWritesUserLevel: _MftBitmapWritesUserLevel_e__Struct,
    UserIndexReads: u32,
    UserIndexReadBytes: u32,
    UserIndexWrites: u32,
    UserIndexWriteBytes: u32,
    LogFileReads: u32,
    LogFileReadBytes: u32,
    LogFileWrites: u32,
    LogFileWriteBytes: u32,
    Allocate: _Allocate_e__Struct,
    DiskResourcesExhausted: u32,
    const _Allocate_e__Struct = u32; // TODO: generate this nested type!
    const _BitmapWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _MftWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _Mft2WritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _MftBitmapWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
};

pub const FILESYSTEM_STATISTICS_EX = extern struct {
    FileSystemType: FILESYSTEM_STATISTICS_TYPE,
    Version: u16,
    SizeOfCompleteStructure: u32,
    UserFileReads: u64,
    UserFileReadBytes: u64,
    UserDiskReads: u64,
    UserFileWrites: u64,
    UserFileWriteBytes: u64,
    UserDiskWrites: u64,
    MetaDataReads: u64,
    MetaDataReadBytes: u64,
    MetaDataDiskReads: u64,
    MetaDataWrites: u64,
    MetaDataWriteBytes: u64,
    MetaDataDiskWrites: u64,
};

pub const NTFS_STATISTICS_EX = extern struct {
    LogFileFullExceptions: u32,
    OtherExceptions: u32,
    MftReads: u64,
    MftReadBytes: u64,
    MftWrites: u64,
    MftWriteBytes: u64,
    MftWritesUserLevel: _MftWritesUserLevel_e__Struct,
    MftWritesFlushForLogFileFull: u32,
    MftWritesLazyWriter: u32,
    MftWritesUserRequest: u32,
    Mft2Writes: u64,
    Mft2WriteBytes: u64,
    Mft2WritesUserLevel: _Mft2WritesUserLevel_e__Struct,
    Mft2WritesFlushForLogFileFull: u32,
    Mft2WritesLazyWriter: u32,
    Mft2WritesUserRequest: u32,
    RootIndexReads: u64,
    RootIndexReadBytes: u64,
    RootIndexWrites: u64,
    RootIndexWriteBytes: u64,
    BitmapReads: u64,
    BitmapReadBytes: u64,
    BitmapWrites: u64,
    BitmapWriteBytes: u64,
    BitmapWritesFlushForLogFileFull: u32,
    BitmapWritesLazyWriter: u32,
    BitmapWritesUserRequest: u32,
    BitmapWritesUserLevel: _BitmapWritesUserLevel_e__Struct,
    MftBitmapReads: u64,
    MftBitmapReadBytes: u64,
    MftBitmapWrites: u64,
    MftBitmapWriteBytes: u64,
    MftBitmapWritesFlushForLogFileFull: u32,
    MftBitmapWritesLazyWriter: u32,
    MftBitmapWritesUserRequest: u32,
    MftBitmapWritesUserLevel: _MftBitmapWritesUserLevel_e__Struct,
    UserIndexReads: u64,
    UserIndexReadBytes: u64,
    UserIndexWrites: u64,
    UserIndexWriteBytes: u64,
    LogFileReads: u64,
    LogFileReadBytes: u64,
    LogFileWrites: u64,
    LogFileWriteBytes: u64,
    Allocate: _Allocate_e__Struct,
    DiskResourcesExhausted: u32,
    VolumeTrimCount: u64,
    VolumeTrimTime: u64,
    VolumeTrimByteCount: u64,
    FileLevelTrimCount: u64,
    FileLevelTrimTime: u64,
    FileLevelTrimByteCount: u64,
    VolumeTrimSkippedCount: u64,
    VolumeTrimSkippedByteCount: u64,
    NtfsFillStatInfoFromMftRecordCalledCount: u64,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: u64,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: u64,
    const _MftBitmapWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _Mft2WritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _Allocate_e__Struct = u32; // TODO: generate this nested type!
    const _MftWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
    const _BitmapWritesUserLevel_e__Struct = u32; // TODO: generate this nested type!
};

pub const FILE_OBJECTID_BUFFER = extern struct {
    ObjectId: [16]u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const FILE_SET_SPARSE_BUFFER = extern struct {
    SetSparse: u8,
};

pub const FILE_ZERO_DATA_INFORMATION = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
};

pub const FILE_ALLOCATED_RANGE_BUFFER = extern struct {
    FileOffset: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};

pub const PLEX_READ_DATA_REQUEST = extern struct {
    ByteOffset: LARGE_INTEGER,
    ByteLength: u32,
    PlexNumber: u32,
};

pub const FILE_MAKE_COMPATIBLE_BUFFER = extern struct {
    CloseDisc: u8,
};

pub const FILE_SET_DEFECT_MGMT_BUFFER = extern struct {
    Disable: u8,
};

pub const FILE_QUERY_SPARING_BUFFER = extern struct {
    SparingUnitBytes: u32,
    SoftwareSparing: u8,
    TotalSpareBlocks: u32,
    FreeSpareBlocks: u32,
};

pub const FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = extern struct {
    DirectoryCount: LARGE_INTEGER,
    FileCount: LARGE_INTEGER,
    FsFormatMajVersion: u16,
    FsFormatMinVersion: u16,
    FsFormatName: [12]u16,
    FormatTime: LARGE_INTEGER,
    LastUpdateTime: LARGE_INTEGER,
    CopyrightInfo: [34]u16,
    AbstractInfo: [34]u16,
    FormattingImplementationInfo: [34]u16,
    LastModifyingImplementationInfo: [34]u16,
};

pub const SHRINK_VOLUME_INFORMATION = extern struct {
    ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    Flags: u64,
    NewNumberOfSectors: i64,
};

pub const TXFS_MODIFY_RM = extern struct {
    Flags: TXFS_RMF_LAGS,
    LogContainerCountMax: u32,
    LogContainerCountMin: u32,
    LogContainerCount: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    Reserved: u64,
    LoggingMode: u16,
};

pub const TXFS_QUERY_RM_INFORMATION = extern struct {
    BytesRequired: u32,
    TailLsn: u64,
    CurrentLsn: u64,
    ArchiveTailLsn: u64,
    LogContainerSize: u64,
    HighestVirtualClock: LARGE_INTEGER,
    LogContainerCount: u32,
    LogContainerCountMax: u32,
    LogContainerCountMin: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    Flags: TXFS_RMF_LAGS,
    LoggingMode: u16,
    Reserved: u16,
    RmState: u32,
    LogCapacity: u64,
    LogFree: u64,
    TopsSize: u64,
    TopsUsed: u64,
    TransactionCount: u64,
    OnePCCount: u64,
    TwoPCCount: u64,
    NumberLogFileFull: u64,
    OldestTransactionAge: u64,
    RMName: Guid,
    TmLogPathOffset: u32,
};

pub const TXFS_GET_METADATA_INFO_OUT = extern struct {
    TxfFileId: _TxfFileId_e__Struct,
    LockingTransaction: Guid,
    LastLsn: u64,
    TransactionState: u32,
    const _TxfFileId_e__Struct = u32; // TODO: generate this nested type!
};

pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = extern struct {
    Offset: u64,
    NameFlags: u32,
    FileId: i64,
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: i64,
    FileName: [1]u16,
};

pub const TXFS_LIST_TRANSACTION_LOCKED_FILES = extern struct {
    KtmTransaction: Guid,
    NumberOfFiles: u64,
    BufferSizeRequired: u64,
    Offset: u64,
};

pub const TXFS_LIST_TRANSACTIONS_ENTRY = extern struct {
    TransactionId: Guid,
    TransactionState: u32,
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: i64,
};

pub const TXFS_LIST_TRANSACTIONS = extern struct {
    NumberOfTransactions: u64,
    BufferSizeRequired: u64,
};

pub const TXFS_READ_BACKUP_INFORMATION_OUT = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TXFS_WRITE_BACKUP_INFORMATION = extern struct {
    Buffer: [1]u8,
};

pub const TXFS_GET_TRANSACTED_VERSION = extern struct {
    ThisBaseVersion: u32,
    LatestVersion: u32,
    ThisMiniVersion: u16,
    FirstMiniVersion: u16,
    LatestMiniVersion: u16,
};

pub const TXFS_SAVEPOINT_INFORMATION = extern struct {
    KtmTransaction: HANDLE,
    ActionCode: u32,
    SavepointId: u32,
};

pub const TXFS_CREATE_MINIVERSION_INFO = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    BaseVersion: u32,
    MiniVersion: u16,
};

pub const TXFS_TRANSACTION_ACTIVE_INFO = extern struct {
    TransactionsActiveAtSnapshot: u8,
};

pub const BOOT_AREA_INFO = extern struct {
    BootSectorCount: u32,
    BootSectors: [2]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const RETRIEVAL_POINTER_BASE = extern struct {
    FileAreaOffset: LARGE_INTEGER,
};

pub const FILE_SYSTEM_RECOGNITION_INFORMATION = extern struct {
    FileSystem: [9]CHAR,
};

pub const REQUEST_OPLOCK_INPUT_BUFFER = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    RequestedOplockLevel: u32,
    Flags: u32,
};

pub const REQUEST_OPLOCK_OUTPUT_BUFFER = extern struct {
    StructureVersion: u16,
    StructureLength: u16,
    OriginalOplockLevel: u32,
    NewOplockLevel: u32,
    Flags: u32,
    AccessMode: u32,
    ShareMode: u16,
};

pub const LOOKUP_STREAM_FROM_CLUSTER_INPUT = extern struct {
    Flags: u32,
    NumberOfClusters: u32,
    Cluster: [1]LARGE_INTEGER,
};

pub const LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = extern struct {
    Offset: u32,
    NumberOfMatches: u32,
    BufferSizeRequired: u32,
};

pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY = extern struct {
    OffsetToNext: u32,
    Flags: u32,
    Reserved: LARGE_INTEGER,
    Cluster: LARGE_INTEGER,
    FileName: [1]u16,
};

pub const CSV_NAMESPACE_INFO = extern struct {
    Version: u32,
    DeviceNumber: u32,
    StartingOffset: LARGE_INTEGER,
    SectorSize: u32,
};

pub const CSV_CONTROL_OP = extern enum(i32) {
    StartRedirectFile = 2,
    StopRedirectFile = 3,
    QueryRedirectState = 4,
    QueryFileRevision = 6,
    QueryMdsPath = 8,
    QueryFileRevisionFileId128 = 9,
    QueryVolumeRedirectState = 10,
    EnableUSNRangeModificationTracking = 13,
    MarkHandleLocalVolumeMount = 14,
    UnmarkHandleLocalVolumeMount = 15,
    GetCsvFsMdsPathV2 = 18,
    DisableCaching = 19,
    EnableCaching = 20,
    StartForceDFO = 21,
    StopForceDFO = 22,
};
pub const CsvControlStartRedirectFile = CSV_CONTROL_OP.StartRedirectFile;
pub const CsvControlStopRedirectFile = CSV_CONTROL_OP.StopRedirectFile;
pub const CsvControlQueryRedirectState = CSV_CONTROL_OP.QueryRedirectState;
pub const CsvControlQueryFileRevision = CSV_CONTROL_OP.QueryFileRevision;
pub const CsvControlQueryMdsPath = CSV_CONTROL_OP.QueryMdsPath;
pub const CsvControlQueryFileRevisionFileId128 = CSV_CONTROL_OP.QueryFileRevisionFileId128;
pub const CsvControlQueryVolumeRedirectState = CSV_CONTROL_OP.QueryVolumeRedirectState;
pub const CsvControlEnableUSNRangeModificationTracking = CSV_CONTROL_OP.EnableUSNRangeModificationTracking;
pub const CsvControlMarkHandleLocalVolumeMount = CSV_CONTROL_OP.MarkHandleLocalVolumeMount;
pub const CsvControlUnmarkHandleLocalVolumeMount = CSV_CONTROL_OP.UnmarkHandleLocalVolumeMount;
pub const CsvControlGetCsvFsMdsPathV2 = CSV_CONTROL_OP.GetCsvFsMdsPathV2;
pub const CsvControlDisableCaching = CSV_CONTROL_OP.DisableCaching;
pub const CsvControlEnableCaching = CSV_CONTROL_OP.EnableCaching;
pub const CsvControlStartForceDFO = CSV_CONTROL_OP.StartForceDFO;
pub const CsvControlStopForceDFO = CSV_CONTROL_OP.StopForceDFO;

pub const CSV_CONTROL_PARAM = extern struct {
    Operation: CSV_CONTROL_OP,
    Unused: i64,
};

pub const CSV_QUERY_REDIRECT_STATE = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    FileRedirected: u8,
};

pub const CSV_QUERY_FILE_REVISION = extern struct {
    FileId: i64,
    FileRevision: [3]i64,
};

pub const CSV_QUERY_MDS_PATH = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    PathLength: u32,
    Path: [1]u16,
};

pub const CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = extern struct {
    VetoedFromAltitudeIntegral: u64,
    VetoedFromAltitudeDecimal: u64,
    Reason: [256]u16,
};

pub const CSV_IS_OWNED_BY_CSVFS = extern struct {
    OwnedByCSVFS: u8,
};

pub const FILE_LEVEL_TRIM_RANGE = extern struct {
    Offset: u64,
    Length: u64,
};

pub const FILE_LEVEL_TRIM = extern struct {
    Key: u32,
    NumRanges: u32,
    Ranges: [1]FILE_LEVEL_TRIM_RANGE,
};

pub const FILE_LEVEL_TRIM_OUTPUT = extern struct {
    NumRangesProcessed: u32,
};

pub const FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: u16,
    Reserved: u16,
    Flags: u32,
    ChecksumChunkSizeInBytes: u32,
    ClusterSizeInBytes: u32,
};

pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: u16,
    Reserved: u16,
    Flags: u32,
};

pub const REPAIR_COPIES_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    FileOffset: LARGE_INTEGER,
    Length: u32,
    SourceCopy: u32,
    NumberOfRepairCopies: u32,
    RepairCopies: [1]u32,
};

pub const REPAIR_COPIES_OUTPUT = extern struct {
    Size: u32,
    Status: u32,
    ResumeFileOffset: LARGE_INTEGER,
};

pub const FILE_STORAGE_TIER_MEDIA_TYPE = extern enum(i32) {
    Unspecified = 0,
    Disk = 1,
    Ssd = 2,
    Scm = 4,
    Max = 5,
};
pub const FileStorageTierMediaTypeUnspecified = FILE_STORAGE_TIER_MEDIA_TYPE.Unspecified;
pub const FileStorageTierMediaTypeDisk = FILE_STORAGE_TIER_MEDIA_TYPE.Disk;
pub const FileStorageTierMediaTypeSsd = FILE_STORAGE_TIER_MEDIA_TYPE.Ssd;
pub const FileStorageTierMediaTypeScm = FILE_STORAGE_TIER_MEDIA_TYPE.Scm;
pub const FileStorageTierMediaTypeMax = FILE_STORAGE_TIER_MEDIA_TYPE.Max;

pub const FILE_STORAGE_TIER = extern struct {
    Id: Guid,
    Name: [256]u16,
    Description: [256]u16,
    Flags: FILE_STORAGE_TIER_FLAGS,
    ProvisionedCapacity: u64,
    MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    Class: FILE_STORAGE_TIER_CLASS,
};

pub const FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: FILE_STORAGE_TIER_FLAGS,
    TotalNumberOfTiers: u32,
    NumberOfTiersReturned: u32,
    Tiers: [1]FILE_STORAGE_TIER,
};

pub const FSCTL_QUERY_REGION_INFO_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NumberOfTierIds: u32,
    TierIds: [1]Guid,
};

pub const FILE_STORAGE_TIER_REGION = extern struct {
    TierId: Guid,
    Offset: u64,
    Length: u64,
};

pub const FSCTL_QUERY_REGION_INFO_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
    Alignment: u64,
    TotalNumberOfRegions: u32,
    NumberOfRegionsReturned: u32,
    Regions: [1]FILE_STORAGE_TIER_REGION,
};

pub const DUPLICATE_EXTENTS_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
};

pub const DISK_EXTENT = extern struct {
    DiskNumber: u32,
    StartingOffset: LARGE_INTEGER,
    ExtentLength: LARGE_INTEGER,
};

pub const VOLUME_DISK_EXTENTS = extern struct {
    NumberOfDiskExtents: u32,
    Extents: [1]DISK_EXTENT,
};

pub const VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: u64,
};

pub const OFSTRUCT = extern struct {
    cBytes: u8,
    fFixedDisk: u8,
    nErrCode: u16,
    Reserved1: u16,
    Reserved2: u16,
    szPathName: [128]CHAR,
};

pub const PFE_EXPORT_FUNC = fn(
    // TODO: what to do with BytesParamIndex 2?
    pbData: *u8,
    pvCallbackContext: ?*c_void,
    ulLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFE_IMPORT_FUNC = fn(
    // TODO: what to do with BytesParamIndex 2?
    pbData: *u8,
    pvCallbackContext: ?*c_void,
    ulLength: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPPROGRESS_ROUTINE = fn(
    TotalFileSize: LARGE_INTEGER,
    TotalBytesTransferred: LARGE_INTEGER,
    StreamSize: LARGE_INTEGER,
    StreamBytesTransferred: LARGE_INTEGER,
    dwStreamNumber: u32,
    dwCallbackReason: LPPROGRESS_ROUTINE_CALLBACK_REASON,
    hSourceFile: HANDLE,
    hDestinationFile: HANDLE,
    lpData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const COPYFILE2_MESSAGE_TYPE = extern enum(i32) {
    NONE = 0,
    CHUNK_STARTED = 1,
    CHUNK_FINISHED = 2,
    STREAM_STARTED = 3,
    STREAM_FINISHED = 4,
    POLL_CONTINUE = 5,
    ERROR = 6,
    MAX = 7,
};
pub const COPYFILE2_CALLBACK_NONE = COPYFILE2_MESSAGE_TYPE.NONE;
pub const COPYFILE2_CALLBACK_CHUNK_STARTED = COPYFILE2_MESSAGE_TYPE.CHUNK_STARTED;
pub const COPYFILE2_CALLBACK_CHUNK_FINISHED = COPYFILE2_MESSAGE_TYPE.CHUNK_FINISHED;
pub const COPYFILE2_CALLBACK_STREAM_STARTED = COPYFILE2_MESSAGE_TYPE.STREAM_STARTED;
pub const COPYFILE2_CALLBACK_STREAM_FINISHED = COPYFILE2_MESSAGE_TYPE.STREAM_FINISHED;
pub const COPYFILE2_CALLBACK_POLL_CONTINUE = COPYFILE2_MESSAGE_TYPE.POLL_CONTINUE;
pub const COPYFILE2_CALLBACK_ERROR = COPYFILE2_MESSAGE_TYPE.ERROR;
pub const COPYFILE2_CALLBACK_MAX = COPYFILE2_MESSAGE_TYPE.MAX;

pub const COPYFILE2_MESSAGE_ACTION = extern enum(i32) {
    CONTINUE = 0,
    CANCEL = 1,
    STOP = 2,
    QUIET = 3,
    PAUSE = 4,
};
pub const COPYFILE2_PROGRESS_CONTINUE = COPYFILE2_MESSAGE_ACTION.CONTINUE;
pub const COPYFILE2_PROGRESS_CANCEL = COPYFILE2_MESSAGE_ACTION.CANCEL;
pub const COPYFILE2_PROGRESS_STOP = COPYFILE2_MESSAGE_ACTION.STOP;
pub const COPYFILE2_PROGRESS_QUIET = COPYFILE2_MESSAGE_ACTION.QUIET;
pub const COPYFILE2_PROGRESS_PAUSE = COPYFILE2_MESSAGE_ACTION.PAUSE;

pub const COPYFILE2_COPY_PHASE = extern enum(i32) {
    NONE = 0,
    PREPARE_SOURCE = 1,
    PREPARE_DEST = 2,
    READ_SOURCE = 3,
    WRITE_DESTINATION = 4,
    SERVER_COPY = 5,
    NAMEGRAFT_COPY = 6,
    MAX = 7,
};
pub const COPYFILE2_PHASE_NONE = COPYFILE2_COPY_PHASE.NONE;
pub const COPYFILE2_PHASE_PREPARE_SOURCE = COPYFILE2_COPY_PHASE.PREPARE_SOURCE;
pub const COPYFILE2_PHASE_PREPARE_DEST = COPYFILE2_COPY_PHASE.PREPARE_DEST;
pub const COPYFILE2_PHASE_READ_SOURCE = COPYFILE2_COPY_PHASE.READ_SOURCE;
pub const COPYFILE2_PHASE_WRITE_DESTINATION = COPYFILE2_COPY_PHASE.WRITE_DESTINATION;
pub const COPYFILE2_PHASE_SERVER_COPY = COPYFILE2_COPY_PHASE.SERVER_COPY;
pub const COPYFILE2_PHASE_NAMEGRAFT_COPY = COPYFILE2_COPY_PHASE.NAMEGRAFT_COPY;
pub const COPYFILE2_PHASE_MAX = COPYFILE2_COPY_PHASE.MAX;

pub const COPYFILE2_MESSAGE = extern struct {
    Type: COPYFILE2_MESSAGE_TYPE,
    dwPadding: u32,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const PCOPYFILE2_PROGRESS_ROUTINE = fn(
    pMessage: *const COPYFILE2_MESSAGE,
    pvCallbackContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) COPYFILE2_MESSAGE_ACTION;

pub const COPYFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwCopyFlags: u32,
    pfCancel: *BOOL,
    pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
    pvCallbackContext: *c_void,
};

pub const FILE_BASIC_INFO = extern struct {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    FileAttributes: u32,
};

pub const FILE_STANDARD_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: u32,
    DeletePending: u8,
    Directory: u8,
};

pub const FILE_NAME_INFO = extern struct {
    FileNameLength: u32,
    FileName: [1]u16,
};

pub const FILE_RENAME_INFO = extern struct {
    Anonymous: _Anonymous_e__Union,
    RootDirectory: HANDLE,
    FileNameLength: u32,
    FileName: [1]u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const FILE_ALLOCATION_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
};

pub const FILE_END_OF_FILE_INFO = extern struct {
    EndOfFile: LARGE_INTEGER,
};

pub const FILE_STREAM_INFO = extern struct {
    NextEntryOffset: u32,
    StreamNameLength: u32,
    StreamSize: LARGE_INTEGER,
    StreamAllocationSize: LARGE_INTEGER,
    StreamName: [1]u16,
};

pub const FILE_COMPRESSION_INFO = extern struct {
    CompressedFileSize: LARGE_INTEGER,
    CompressionFormat: u16,
    CompressionUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    Reserved: [3]u8,
};

pub const FILE_ATTRIBUTE_TAG_INFO = extern struct {
    FileAttributes: u32,
    ReparseTag: u32,
};

pub const FILE_DISPOSITION_INFO = extern struct {
    DeleteFileA: u8,
};

pub const FILE_ID_BOTH_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ShortNameLength: i8,
    ShortName: [12]u16,
    FileId: LARGE_INTEGER,
    FileName: [1]u16,
};

pub const FILE_FULL_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    FileName: [1]u16,
};

pub const PRIORITY_HINT = extern enum(i32) {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow = 1,
    IoPriorityHintNormal = 2,
    MaximumIoPriorityHintType = 3,
};
pub const IoPriorityHintVeryLow = PRIORITY_HINT.IoPriorityHintVeryLow;
pub const IoPriorityHintLow = PRIORITY_HINT.IoPriorityHintLow;
pub const IoPriorityHintNormal = PRIORITY_HINT.IoPriorityHintNormal;
pub const MaximumIoPriorityHintType = PRIORITY_HINT.MaximumIoPriorityHintType;

pub const FILE_IO_PRIORITY_HINT_INFO = extern struct {
    PriorityHint: PRIORITY_HINT,
};

pub const FILE_ALIGNMENT_INFO = extern struct {
    AlignmentRequirement: u32,
};

pub const FILE_STORAGE_INFO = extern struct {
    LogicalBytesPerSector: u32,
    PhysicalBytesPerSectorForAtomicity: u32,
    PhysicalBytesPerSectorForPerformance: u32,
    FileSystemEffectivePhysicalBytesPerSectorForAtomicity: u32,
    Flags: u32,
    ByteOffsetForSectorAlignment: u32,
    ByteOffsetForPartitionAlignment: u32,
};

pub const FILE_ID_INFO = extern struct {
    VolumeSerialNumber: u64,
    FileId: FILE_ID_128,
};

pub const FILE_ID_EXTD_DIR_INFO = extern struct {
    NextEntryOffset: u32,
    FileIndex: u32,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: u32,
    FileNameLength: u32,
    EaSize: u32,
    ReparsePointTag: u32,
    FileId: FILE_ID_128,
    FileName: [1]u16,
};

pub const FILE_REMOTE_PROTOCOL_INFO = extern struct {
    StructureVersion: u16,
    StructureSize: u16,
    Protocol: u32,
    ProtocolMajorVersion: u16,
    ProtocolMinorVersion: u16,
    ProtocolRevision: u16,
    Reserved: u16,
    Flags: u32,
    GenericReserved: _GenericReserved_e__Struct,
    ProtocolSpecific: _ProtocolSpecific_e__Union,
    const _ProtocolSpecific_e__Union = u32; // TODO: generate this nested type!
    const _GenericReserved_e__Struct = u32; // TODO: generate this nested type!
};

pub const FILE_ID_TYPE = extern enum(i32) {
    FileIdType = 0,
    ObjectIdType = 1,
    ExtendedFileIdType = 2,
    MaximumFileIdType = 3,
};
pub const FileIdType = FILE_ID_TYPE.FileIdType;
pub const ObjectIdType = FILE_ID_TYPE.ObjectIdType;
pub const ExtendedFileIdType = FILE_ID_TYPE.ExtendedFileIdType;
pub const MaximumFileIdType = FILE_ID_TYPE.MaximumFileIdType;

pub const FILE_ID_DESCRIPTOR = extern struct {
    dwSize: u32,
    Type: FILE_ID_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GPT_ATTRIBUTES = extern enum(u64) {
    ATTRIBUTE_PLATFORM_REQUIRED = 1,
    BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 9223372036854775808,
    BASIC_DATA_ATTRIBUTE_HIDDEN = 4611686018427387904,
    BASIC_DATA_ATTRIBUTE_SHADOW_COPY = 2305843009213693952,
    BASIC_DATA_ATTRIBUTE_READ_ONLY = 1152921504606846976,
    _,
};
pub const GPT_ATTRIBUTE_PLATFORM_REQUIRED = GPT_ATTRIBUTES.ATTRIBUTE_PLATFORM_REQUIRED;
pub const GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = GPT_ATTRIBUTES.BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER;
pub const GPT_BASIC_DATA_ATTRIBUTE_HIDDEN = GPT_ATTRIBUTES.BASIC_DATA_ATTRIBUTE_HIDDEN;
pub const GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY = GPT_ATTRIBUTES.BASIC_DATA_ATTRIBUTE_SHADOW_COPY;
pub const GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY = GPT_ATTRIBUTES.BASIC_DATA_ATTRIBUTE_READ_ONLY;

pub const FILE_CREATION_DISPOSITION = extern enum(u32) {
    CREATE_NEW = 1,
    CREATE_ALWAYS = 2,
    OPEN_EXISTING = 3,
    OPEN_ALWAYS = 4,
    TRUNCATE_EXISTING = 5,
};
pub const CREATE_NEW = FILE_CREATION_DISPOSITION.CREATE_NEW;
pub const CREATE_ALWAYS = FILE_CREATION_DISPOSITION.CREATE_ALWAYS;
pub const OPEN_EXISTING = FILE_CREATION_DISPOSITION.OPEN_EXISTING;
pub const OPEN_ALWAYS = FILE_CREATION_DISPOSITION.OPEN_ALWAYS;
pub const TRUNCATE_EXISTING = FILE_CREATION_DISPOSITION.TRUNCATE_EXISTING;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_SHARE_MODE = extern enum(u32) {
    NONE = 0,
    DELETE = 4,
    READ = 1,
    WRITE = 2,
    _,
};
pub const FILE_SHARE_NONE = FILE_SHARE_MODE.NONE;
pub const FILE_SHARE_DELETE = FILE_SHARE_MODE.DELETE;
pub const FILE_SHARE_READ = FILE_SHARE_MODE.READ;
pub const FILE_SHARE_WRITE = FILE_SHARE_MODE.WRITE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SHARE_TYPE = extern enum(u32) {
    DISKTREE = 0,
    PRINTQ = 1,
    DEVICE = 2,
    IPC = 3,
    SPECIAL = 2147483648,
    TEMPORARY = 1073741824,
    MASK = 255,
    _,
};
pub const STYPE_DISKTREE = SHARE_TYPE.DISKTREE;
pub const STYPE_PRINTQ = SHARE_TYPE.PRINTQ;
pub const STYPE_DEVICE = SHARE_TYPE.DEVICE;
pub const STYPE_IPC = SHARE_TYPE.IPC;
pub const STYPE_SPECIAL = SHARE_TYPE.SPECIAL;
pub const STYPE_TEMPORARY = SHARE_TYPE.TEMPORARY;
pub const STYPE_MASK = SHARE_TYPE.MASK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CLFS_FLAG = extern enum(u32) {
    FORCE_APPEND = 1,
    FORCE_FLUSH = 2,
    NO_FLAGS = 0,
    USE_RESERVATION = 4,
    _,
};
pub const CLFS_FLAG_FORCE_APPEND = CLFS_FLAG.FORCE_APPEND;
pub const CLFS_FLAG_FORCE_FLUSH = CLFS_FLAG.FORCE_FLUSH;
pub const CLFS_FLAG_NO_FLAGS = CLFS_FLAG.NO_FLAGS;
pub const CLFS_FLAG_USE_RESERVATION = CLFS_FLAG.USE_RESERVATION;

pub const SET_FILE_POINTER_MOVE_METHOD = extern enum(u32) {
    BEGIN = 0,
    CURRENT = 1,
    END = 2,
};
pub const FILE_BEGIN = SET_FILE_POINTER_MOVE_METHOD.BEGIN;
pub const FILE_CURRENT = SET_FILE_POINTER_MOVE_METHOD.CURRENT;
pub const FILE_END = SET_FILE_POINTER_MOVE_METHOD.END;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MOVE_FILE_FLAGS = extern enum(u32) {
    COPY_ALLOWED = 2,
    CREATE_HARDLINK = 16,
    DELAY_UNTIL_REBOOT = 4,
    REPLACE_EXISTING = 1,
    WRITE_THROUGH = 8,
    FAIL_IF_NOT_TRACKABLE = 32,
    _,
};
pub const MOVEFILE_COPY_ALLOWED = MOVE_FILE_FLAGS.COPY_ALLOWED;
pub const MOVEFILE_CREATE_HARDLINK = MOVE_FILE_FLAGS.CREATE_HARDLINK;
pub const MOVEFILE_DELAY_UNTIL_REBOOT = MOVE_FILE_FLAGS.DELAY_UNTIL_REBOOT;
pub const MOVEFILE_REPLACE_EXISTING = MOVE_FILE_FLAGS.REPLACE_EXISTING;
pub const MOVEFILE_WRITE_THROUGH = MOVE_FILE_FLAGS.WRITE_THROUGH;
pub const MOVEFILE_FAIL_IF_NOT_TRACKABLE = MOVE_FILE_FLAGS.FAIL_IF_NOT_TRACKABLE;

pub const FILE_NAME = extern enum(u32) {
    NORMALIZED = 0,
    OPENED = 8,
};
pub const FILE_NAME_NORMALIZED = FILE_NAME.NORMALIZED;
pub const FILE_NAME_OPENED = FILE_NAME.OPENED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LZOPENFILE_STYLE = extern enum(u32) {
    CANCEL = 2048,
    CREATE = 4096,
    DELETE = 512,
    EXIST = 16384,
    PARSE = 256,
    PROMPT = 8192,
    READ = 0,
    READWRITE = 2,
    REOPEN = 32768,
    SHARE_DENY_NONE = 64,
    SHARE_DENY_READ = 48,
    SHARE_DENY_WRITE = 32,
    SHARE_EXCLUSIVE = 16,
    WRITE = 1,
    SHARE_COMPAT = 0,
    VERIFY = 1024,
    _,
};
pub const OF_CANCEL = LZOPENFILE_STYLE.CANCEL;
pub const OF_CREATE = LZOPENFILE_STYLE.CREATE;
pub const OF_DELETE = LZOPENFILE_STYLE.DELETE;
pub const OF_EXIST = LZOPENFILE_STYLE.EXIST;
pub const OF_PARSE = LZOPENFILE_STYLE.PARSE;
pub const OF_PROMPT = LZOPENFILE_STYLE.PROMPT;
pub const OF_READ = LZOPENFILE_STYLE.READ;
pub const OF_READWRITE = LZOPENFILE_STYLE.READWRITE;
pub const OF_REOPEN = LZOPENFILE_STYLE.REOPEN;
pub const OF_SHARE_DENY_NONE = LZOPENFILE_STYLE.SHARE_DENY_NONE;
pub const OF_SHARE_DENY_READ = LZOPENFILE_STYLE.SHARE_DENY_READ;
pub const OF_SHARE_DENY_WRITE = LZOPENFILE_STYLE.SHARE_DENY_WRITE;
pub const OF_SHARE_EXCLUSIVE = LZOPENFILE_STYLE.SHARE_EXCLUSIVE;
pub const OF_WRITE = LZOPENFILE_STYLE.WRITE;
pub const OF_SHARE_COMPAT = LZOPENFILE_STYLE.SHARE_COMPAT;
pub const OF_VERIFY = LZOPENFILE_STYLE.VERIFY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_NOTIFY_CHANGE = extern enum(u32) {
    FILE_NAME = 1,
    DIR_NAME = 2,
    ATTRIBUTES = 4,
    SIZE = 8,
    LAST_WRITE = 16,
    LAST_ACCESS = 32,
    CREATION = 64,
    SECURITY = 256,
    _,
};
pub const FILE_NOTIFY_CHANGE_FILE_NAME = FILE_NOTIFY_CHANGE.FILE_NAME;
pub const FILE_NOTIFY_CHANGE_DIR_NAME = FILE_NOTIFY_CHANGE.DIR_NAME;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES = FILE_NOTIFY_CHANGE.ATTRIBUTES;
pub const FILE_NOTIFY_CHANGE_SIZE = FILE_NOTIFY_CHANGE.SIZE;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE = FILE_NOTIFY_CHANGE.LAST_WRITE;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS = FILE_NOTIFY_CHANGE.LAST_ACCESS;
pub const FILE_NOTIFY_CHANGE_CREATION = FILE_NOTIFY_CHANGE.CREATION;
pub const FILE_NOTIFY_CHANGE_SECURITY = FILE_NOTIFY_CHANGE.SECURITY;

pub const TXFS_MINIVERSION = extern enum(u32) {
    COMMITTED_VIEW = 0,
    DIRTY_VIEW = 65535,
    DEFAULT_VIEW = 65534,
};
pub const TXFS_MINIVERSION_COMMITTED_VIEW = TXFS_MINIVERSION.COMMITTED_VIEW;
pub const TXFS_MINIVERSION_DIRTY_VIEW = TXFS_MINIVERSION.DIRTY_VIEW;
pub const TXFS_MINIVERSION_DEFAULT_VIEW = TXFS_MINIVERSION.DEFAULT_VIEW;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const REPLACE_FILE_FLAGS = extern enum(u32) {
    WRITE_THROUGH = 1,
    IGNORE_MERGE_ERRORS = 2,
    IGNORE_ACL_ERRORS = 4,
    _,
};
pub const REPLACEFILE_WRITE_THROUGH = REPLACE_FILE_FLAGS.WRITE_THROUGH;
pub const REPLACEFILE_IGNORE_MERGE_ERRORS = REPLACE_FILE_FLAGS.IGNORE_MERGE_ERRORS;
pub const REPLACEFILE_IGNORE_ACL_ERRORS = REPLACE_FILE_FLAGS.IGNORE_ACL_ERRORS;

pub const DISKQUOTA_USERNAME_RESOLVE = extern enum(u32) {
    ASYNC = 2,
    NONE = 0,
    SYNC = 1,
};
pub const DISKQUOTA_USERNAME_RESOLVE_ASYNC = DISKQUOTA_USERNAME_RESOLVE.ASYNC;
pub const DISKQUOTA_USERNAME_RESOLVE_NONE = DISKQUOTA_USERNAME_RESOLVE.NONE;
pub const DISKQUOTA_USERNAME_RESOLVE_SYNC = DISKQUOTA_USERNAME_RESOLVE.SYNC;

pub const NTMS_OMID_TYPE = extern enum(u32) {
    FILESYSTEM_INFO = 2,
    RAW_LABEL = 1,
};
pub const NTMS_OMID_TYPE_FILESYSTEM_INFO = NTMS_OMID_TYPE.FILESYSTEM_INFO;
pub const NTMS_OMID_TYPE_RAW_LABEL = NTMS_OMID_TYPE.RAW_LABEL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LOCK_FILE_FLAGS = extern enum(u32) {
    EXCLUSIVE_LOCK = 2,
    FAIL_IMMEDIATELY = 1,
    _,
};
pub const LOCKFILE_EXCLUSIVE_LOCK = LOCK_FILE_FLAGS.EXCLUSIVE_LOCK;
pub const LOCKFILE_FAIL_IMMEDIATELY = LOCK_FILE_FLAGS.FAIL_IMMEDIATELY;

pub const LPPROGRESS_ROUTINE_CALLBACK_REASON = extern enum(u32) {
    CHUNK_FINISHED = 0,
    STREAM_SWITCH = 1,
};
pub const CALLBACK_CHUNK_FINISHED = LPPROGRESS_ROUTINE_CALLBACK_REASON.CHUNK_FINISHED;
pub const CALLBACK_STREAM_SWITCH = LPPROGRESS_ROUTINE_CALLBACK_REASON.STREAM_SWITCH;

pub const FILE_ACTION = extern enum(u32) {
    ADDED = 1,
    REMOVED = 2,
    MODIFIED = 3,
    RENAMED_OLD_NAME = 4,
    RENAMED_NEW_NAME = 5,
};
pub const FILE_ACTION_ADDED = FILE_ACTION.ADDED;
pub const FILE_ACTION_REMOVED = FILE_ACTION.REMOVED;
pub const FILE_ACTION_MODIFIED = FILE_ACTION.MODIFIED;
pub const FILE_ACTION_RENAMED_OLD_NAME = FILE_ACTION.RENAMED_OLD_NAME;
pub const FILE_ACTION_RENAMED_NEW_NAME = FILE_ACTION.RENAMED_NEW_NAME;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const USN_DELETE_FLAGS = extern enum(u32) {
    DELETE = 1,
    NOTIFY = 2,
    _,
};
pub const USN_DELETE_FLAG_DELETE = USN_DELETE_FLAGS.DELETE;
pub const USN_DELETE_FLAG_NOTIFY = USN_DELETE_FLAGS.NOTIFY;

pub const SHARE_INFO_PERMISSIONS = extern enum(u32) {
    READ = 1,
    WRITE = 2,
    CREATE = 4,
    EXEC = 8,
    DELETE = 16,
    ATRIB = 32,
    PERM = 64,
    ALL = 32768,
};
pub const ACCESS_READ = SHARE_INFO_PERMISSIONS.READ;
pub const ACCESS_WRITE = SHARE_INFO_PERMISSIONS.WRITE;
pub const ACCESS_CREATE = SHARE_INFO_PERMISSIONS.CREATE;
pub const ACCESS_EXEC = SHARE_INFO_PERMISSIONS.EXEC;
pub const ACCESS_DELETE = SHARE_INFO_PERMISSIONS.DELETE;
pub const ACCESS_ATRIB = SHARE_INFO_PERMISSIONS.ATRIB;
pub const ACCESS_PERM = SHARE_INFO_PERMISSIONS.PERM;
pub const ACCESS_ALL = SHARE_INFO_PERMISSIONS.ALL;

pub const FILE_DEVICE_TYPE = extern enum(u32) {
    CD_ROM = 2,
    DISK = 7,
    TAPE = 31,
    DVD = 51,
};
pub const FILE_DEVICE_CD_ROM = FILE_DEVICE_TYPE.CD_ROM;
pub const FILE_DEVICE_DISK = FILE_DEVICE_TYPE.DISK;
pub const FILE_DEVICE_TAPE = FILE_DEVICE_TYPE.TAPE;
pub const FILE_DEVICE_DVD = FILE_DEVICE_TYPE.DVD;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TXFS_RMF_LAGS = extern enum(u32) {
    LOGGING_MODE = 1,
    RENAME_RM = 2,
    LOG_CONTAINER_COUNT_MAX = 4,
    LOG_CONTAINER_COUNT_MIN = 8,
    LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 16,
    LOG_GROWTH_INCREMENT_PERCENT = 32,
    LOG_AUTO_SHRINK_PERCENTAGE = 64,
    LOG_NO_CONTAINER_COUNT_MAX = 128,
    LOG_NO_CONTAINER_COUNT_MIN = 256,
    GROW_LOG = 1024,
    SHRINK_LOG = 2048,
    ENFORCE_MINIMUM_SIZE = 4096,
    PRESERVE_CHANGES = 8192,
    RESET_RM_AT_NEXT_START = 16384,
    DO_NOT_RESET_RM_AT_NEXT_START = 32768,
    PREFER_CONSISTENCY = 65536,
    PREFER_AVAILABILITY = 131072,
    _,
};
pub const TXFS_RM_FLAG_LOGGING_MODE = TXFS_RMF_LAGS.LOGGING_MODE;
pub const TXFS_RM_FLAG_RENAME_RM = TXFS_RMF_LAGS.RENAME_RM;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX = TXFS_RMF_LAGS.LOG_CONTAINER_COUNT_MAX;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN = TXFS_RMF_LAGS.LOG_CONTAINER_COUNT_MIN;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = TXFS_RMF_LAGS.LOG_GROWTH_INCREMENT_NUM_CONTAINERS;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = TXFS_RMF_LAGS.LOG_GROWTH_INCREMENT_PERCENT;
pub const TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = TXFS_RMF_LAGS.LOG_AUTO_SHRINK_PERCENTAGE;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = TXFS_RMF_LAGS.LOG_NO_CONTAINER_COUNT_MAX;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = TXFS_RMF_LAGS.LOG_NO_CONTAINER_COUNT_MIN;
pub const TXFS_RM_FLAG_GROW_LOG = TXFS_RMF_LAGS.GROW_LOG;
pub const TXFS_RM_FLAG_SHRINK_LOG = TXFS_RMF_LAGS.SHRINK_LOG;
pub const TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE = TXFS_RMF_LAGS.ENFORCE_MINIMUM_SIZE;
pub const TXFS_RM_FLAG_PRESERVE_CHANGES = TXFS_RMF_LAGS.PRESERVE_CHANGES;
pub const TXFS_RM_FLAG_RESET_RM_AT_NEXT_START = TXFS_RMF_LAGS.RESET_RM_AT_NEXT_START;
pub const TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START = TXFS_RMF_LAGS.DO_NOT_RESET_RM_AT_NEXT_START;
pub const TXFS_RM_FLAG_PREFER_CONSISTENCY = TXFS_RMF_LAGS.PREFER_CONSISTENCY;
pub const TXFS_RM_FLAG_PREFER_AVAILABILITY = TXFS_RMF_LAGS.PREFER_AVAILABILITY;

pub const FILESYSTEM_STATISTICS_TYPE = extern enum(u32) {
    EXFAT = 3,
    FAT = 2,
    NTFS = 1,
};
pub const FILESYSTEM_STATISTICS_TYPE_EXFAT = FILESYSTEM_STATISTICS_TYPE.EXFAT;
pub const FILESYSTEM_STATISTICS_TYPE_FAT = FILESYSTEM_STATISTICS_TYPE.FAT;
pub const FILESYSTEM_STATISTICS_TYPE_NTFS = FILESYSTEM_STATISTICS_TYPE.NTFS;

pub const USN_SOURCE_INFO_ID = extern enum(u32) {
    AUXILIARY_DATA = 2,
    DATA_MANAGEMENT = 1,
    REPLICATION_MANAGEMENT = 4,
    CLIENT_REPLICATION_MANAGEMENT = 8,
};
pub const USN_SOURCE_AUXILIARY_DATA = USN_SOURCE_INFO_ID.AUXILIARY_DATA;
pub const USN_SOURCE_DATA_MANAGEMENT = USN_SOURCE_INFO_ID.DATA_MANAGEMENT;
pub const USN_SOURCE_REPLICATION_MANAGEMENT = USN_SOURCE_INFO_ID.REPLICATION_MANAGEMENT;
pub const USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT = USN_SOURCE_INFO_ID.CLIENT_REPLICATION_MANAGEMENT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_STORAGE_TIER_FLAGS = extern enum(u32) {
    Y = 131072,
    _,
};
pub const FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY = FILE_STORAGE_TIER_FLAGS.Y;

pub const SESSION_INFO_USER_FLAGS = extern enum(u32) {
    GUEST = 1,
    NOENCRYPTION = 2,
};
pub const SESS_GUEST = SESSION_INFO_USER_FLAGS.GUEST;
pub const SESS_NOENCRYPTION = SESSION_INFO_USER_FLAGS.NOENCRYPTION;

pub const TXF_LOG_RECORD_TYPE = extern enum(u32) {
    AFFECTED_FILE = 4,
    TRUNCATE = 2,
    WRITE = 1,
};
pub const TXF_LOG_RECORD_TYPE_AFFECTED_FILE = TXF_LOG_RECORD_TYPE.AFFECTED_FILE;
pub const TXF_LOG_RECORD_TYPE_TRUNCATE = TXF_LOG_RECORD_TYPE.TRUNCATE;
pub const TXF_LOG_RECORD_TYPE_WRITE = TXF_LOG_RECORD_TYPE.WRITE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_INFO_FLAGS_PERMISSIONS = extern enum(u32) {
    READ = 1,
    WRITE = 2,
    CREATE = 4,
    _,
};
pub const PERM_FILE_READ = FILE_INFO_FLAGS_PERMISSIONS.READ;
pub const PERM_FILE_WRITE = FILE_INFO_FLAGS_PERMISSIONS.WRITE;
pub const PERM_FILE_CREATE = FILE_INFO_FLAGS_PERMISSIONS.CREATE;

pub const TRANSACTION_NOTIFICATION = extern struct {
    TransactionKey: *c_void,
    TransactionNotification: u32,
    TmVirtualClock: LARGE_INTEGER,
    ArgumentLength: u32,
};

pub const TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = extern struct {
    EnlistmentId: Guid,
    UOW: Guid,
};

pub const TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = extern struct {
    TmIdentity: Guid,
    Flags: u32,
};

pub const TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = extern struct {
    SavepointId: u32,
};

pub const TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = extern struct {
    PropagationCookie: u32,
    UOW: Guid,
    TmIdentity: Guid,
    BufferLength: u32,
};

pub const TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = extern struct {
    MarshalCookie: u32,
    UOW: Guid,
};

pub const KCRM_MARSHAL_HEADER = extern struct {
    VersionMajor: u32,
    VersionMinor: u32,
    NumProtocols: u32,
    Unused: u32,
};

pub const KCRM_TRANSACTION_BLOB = extern struct {
    UOW: Guid,
    TmIdentity: Guid,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: [64]u16,
};

pub const KCRM_PROTOCOL_BLOB = extern struct {
    ProtocolId: Guid,
    StaticInfoLength: u32,
    TransactionIdInfoLength: u32,
    Unused1: u32,
    Unused2: u32,
};

pub const DISK_SPACE_INFORMATION = extern struct {
    ActualTotalAllocationUnits: u64,
    ActualAvailableAllocationUnits: u64,
    ActualPoolUnavailableAllocationUnits: u64,
    CallerTotalAllocationUnits: u64,
    CallerAvailableAllocationUnits: u64,
    CallerPoolUnavailableAllocationUnits: u64,
    UsedAllocationUnits: u64,
    TotalReservedAllocationUnits: u64,
    VolumeStorageReserveAllocationUnits: u64,
    AvailableCommittedAllocationUnits: u64,
    PoolAvailableAllocationUnits: u64,
    SectorsPerAllocationUnit: u32,
    BytesPerSector: u32,
};

pub const WIN32_FILE_ATTRIBUTE_DATA = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
};

pub const BY_HANDLE_FILE_INFORMATION = extern struct {
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    dwVolumeSerialNumber: u32,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    nNumberOfLinks: u32,
    nFileIndexHigh: u32,
    nFileIndexLow: u32,
};

pub const CREATEFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: u32,
    dwFileAttributes: u32,
    dwFileFlags: u32,
    dwSecurityQosFlags: u32,
    lpSecurityAttributes: *SECURITY_ATTRIBUTES,
    hTemplateFile: HANDLE,
};

pub const STREAM_INFO_LEVELS = extern enum(i32) {
    Standard = 0,
    MaxInfoLevel = 1,
};
pub const FindStreamInfoStandard = STREAM_INFO_LEVELS.Standard;
pub const FindStreamInfoMaxInfoLevel = STREAM_INFO_LEVELS.MaxInfoLevel;

pub const WIN32_FIND_STREAM_DATA = extern struct {
    StreamSize: LARGE_INTEGER,
    cStreamName: [296]u16,
};

pub const NtmsObjectsTypes = extern enum(i32) {
    UNKNOWN = 0,
    OBJECT = 1,
    CHANGER = 2,
    CHANGER_TYPE = 3,
    COMPUTER = 4,
    DRIVE = 5,
    DRIVE_TYPE = 6,
    IEDOOR = 7,
    IEPORT = 8,
    LIBRARY = 9,
    LIBREQUEST = 10,
    LOGICAL_MEDIA = 11,
    MEDIA_POOL = 12,
    MEDIA_TYPE = 13,
    PARTITION = 14,
    PHYSICAL_MEDIA = 15,
    STORAGESLOT = 16,
    OPREQUEST = 17,
    UI_DESTINATION = 18,
    NUMBER_OF_OBJECT_TYPES = 19,
};
pub const NTMS_UNKNOWN = NtmsObjectsTypes.UNKNOWN;
pub const NTMS_OBJECT = NtmsObjectsTypes.OBJECT;
pub const NTMS_CHANGER = NtmsObjectsTypes.CHANGER;
pub const NTMS_CHANGER_TYPE = NtmsObjectsTypes.CHANGER_TYPE;
pub const NTMS_COMPUTER = NtmsObjectsTypes.COMPUTER;
pub const NTMS_DRIVE = NtmsObjectsTypes.DRIVE;
pub const NTMS_DRIVE_TYPE = NtmsObjectsTypes.DRIVE_TYPE;
pub const NTMS_IEDOOR = NtmsObjectsTypes.IEDOOR;
pub const NTMS_IEPORT = NtmsObjectsTypes.IEPORT;
pub const NTMS_LIBRARY = NtmsObjectsTypes.LIBRARY;
pub const NTMS_LIBREQUEST = NtmsObjectsTypes.LIBREQUEST;
pub const NTMS_LOGICAL_MEDIA = NtmsObjectsTypes.LOGICAL_MEDIA;
pub const NTMS_MEDIA_POOL = NtmsObjectsTypes.MEDIA_POOL;
pub const NTMS_MEDIA_TYPE = NtmsObjectsTypes.MEDIA_TYPE;
pub const NTMS_PARTITION = NtmsObjectsTypes.PARTITION;
pub const NTMS_PHYSICAL_MEDIA = NtmsObjectsTypes.PHYSICAL_MEDIA;
pub const NTMS_STORAGESLOT = NtmsObjectsTypes.STORAGESLOT;
pub const NTMS_OPREQUEST = NtmsObjectsTypes.OPREQUEST;
pub const NTMS_UI_DESTINATION = NtmsObjectsTypes.UI_DESTINATION;
pub const NTMS_NUMBER_OF_OBJECT_TYPES = NtmsObjectsTypes.NUMBER_OF_OBJECT_TYPES;

pub const NTMS_ASYNC_IO = extern struct {
    OperationId: Guid,
    EventId: Guid,
    dwOperationType: u32,
    dwResult: u32,
    dwAsyncState: u32,
    hEvent: HANDLE,
    bOnStateChange: BOOL,
};

pub const NtmsAsyncStatus = extern enum(i32) {
    QUEUED = 0,
    WAIT_RESOURCE = 1,
    WAIT_OPERATOR = 2,
    INPROCESS = 3,
    COMPLETE = 4,
};
pub const NTMS_ASYNCSTATE_QUEUED = NtmsAsyncStatus.QUEUED;
pub const NTMS_ASYNCSTATE_WAIT_RESOURCE = NtmsAsyncStatus.WAIT_RESOURCE;
pub const NTMS_ASYNCSTATE_WAIT_OPERATOR = NtmsAsyncStatus.WAIT_OPERATOR;
pub const NTMS_ASYNCSTATE_INPROCESS = NtmsAsyncStatus.INPROCESS;
pub const NTMS_ASYNCSTATE_COMPLETE = NtmsAsyncStatus.COMPLETE;

pub const NtmsAsyncOperations = extern enum(i32) {
    T = 1,
};
pub const NTMS_ASYNCOP_MOUNT = NtmsAsyncOperations.T;

pub const NtmsSessionOptions = extern enum(i32) {
    E = 1,
};
pub const NTMS_SESSION_QUERYEXPEDITE = NtmsSessionOptions.E;

pub const NtmsMountOptions = extern enum(i32) {
    READ = 1,
    WRITE = 2,
    ERROR_NOT_AVAILABLE = 4,
    ERROR_IF_UNAVAILABLE = 4,
    ERROR_OFFLINE = 8,
    ERROR_IF_OFFLINE = 8,
    SPECIFIC_DRIVE = 16,
    NOWAIT = 32,
};
pub const NTMS_MOUNT_READ = NtmsMountOptions.READ;
pub const NTMS_MOUNT_WRITE = NtmsMountOptions.WRITE;
pub const NTMS_MOUNT_ERROR_NOT_AVAILABLE = NtmsMountOptions.ERROR_NOT_AVAILABLE;
pub const NTMS_MOUNT_ERROR_IF_UNAVAILABLE = NtmsMountOptions.ERROR_IF_UNAVAILABLE;
pub const NTMS_MOUNT_ERROR_OFFLINE = NtmsMountOptions.ERROR_OFFLINE;
pub const NTMS_MOUNT_ERROR_IF_OFFLINE = NtmsMountOptions.ERROR_IF_OFFLINE;
pub const NTMS_MOUNT_SPECIFIC_DRIVE = NtmsMountOptions.SPECIFIC_DRIVE;
pub const NTMS_MOUNT_NOWAIT = NtmsMountOptions.NOWAIT;

pub const NtmsDismountOptions = extern enum(i32) {
    DEFERRED = 1,
    IMMEDIATE = 2,
};
pub const NTMS_DISMOUNT_DEFERRED = NtmsDismountOptions.DEFERRED;
pub const NTMS_DISMOUNT_IMMEDIATE = NtmsDismountOptions.IMMEDIATE;

pub const NtmsMountPriority = extern enum(i32) {
    DEFAULT = 0,
    HIGHEST = 15,
    HIGH = 7,
    NORMAL = 0,
    LOW = -7,
    LOWEST = -15,
};
pub const NTMS_PRIORITY_DEFAULT = NtmsMountPriority.DEFAULT;
pub const NTMS_PRIORITY_HIGHEST = NtmsMountPriority.HIGHEST;
pub const NTMS_PRIORITY_HIGH = NtmsMountPriority.HIGH;
pub const NTMS_PRIORITY_NORMAL = NtmsMountPriority.NORMAL;
pub const NTMS_PRIORITY_LOW = NtmsMountPriority.LOW;
pub const NTMS_PRIORITY_LOWEST = NtmsMountPriority.LOWEST;

pub const NTMS_MOUNT_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: *c_void,
};

pub const NtmsAllocateOptions = extern enum(i32) {
    NEW = 1,
    NEXT = 2,
    ERROR_IF_UNAVAILABLE = 4,
};
pub const NTMS_ALLOCATE_NEW = NtmsAllocateOptions.NEW;
pub const NTMS_ALLOCATE_NEXT = NtmsAllocateOptions.NEXT;
pub const NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE = NtmsAllocateOptions.ERROR_IF_UNAVAILABLE;

pub const NTMS_ALLOCATION_INFORMATION = extern struct {
    dwSize: u32,
    lpReserved: *c_void,
    AllocatedFrom: Guid,
};

pub const NtmsCreateOptions = extern enum(i32) {
    OPEN_EXISTING = 1,
    CREATE_NEW = 2,
    OPEN_ALWAYS = 3,
};
pub const NTMS_OPEN_EXISTING = NtmsCreateOptions.OPEN_EXISTING;
pub const NTMS_CREATE_NEW = NtmsCreateOptions.CREATE_NEW;
pub const NTMS_OPEN_ALWAYS = NtmsCreateOptions.OPEN_ALWAYS;

pub const NtmsDriveState = extern enum(i32) {
    DISMOUNTED = 0,
    MOUNTED = 1,
    LOADED = 2,
    UNLOADED = 5,
    BEING_CLEANED = 6,
    DISMOUNTABLE = 7,
};
pub const NTMS_DRIVESTATE_DISMOUNTED = NtmsDriveState.DISMOUNTED;
pub const NTMS_DRIVESTATE_MOUNTED = NtmsDriveState.MOUNTED;
pub const NTMS_DRIVESTATE_LOADED = NtmsDriveState.LOADED;
pub const NTMS_DRIVESTATE_UNLOADED = NtmsDriveState.UNLOADED;
pub const NTMS_DRIVESTATE_BEING_CLEANED = NtmsDriveState.BEING_CLEANED;
pub const NTMS_DRIVESTATE_DISMOUNTABLE = NtmsDriveState.DISMOUNTABLE;

pub const NTMS_DRIVEINFORMATIONA = extern struct {
    Number: u32,
    State: NtmsDriveState,
    DriveType: Guid,
    szDeviceName: [64]CHAR,
    szSerialNumber: [32]CHAR,
    szRevision: [32]CHAR,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};

pub const NTMS_DRIVEINFORMATIONW = extern struct {
    Number: u32,
    State: NtmsDriveState,
    DriveType: Guid,
    szDeviceName: [64]u16,
    szSerialNumber: [32]u16,
    szRevision: [32]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    dwMountCount: u32,
    LastCleanedTs: SYSTEMTIME,
    SavedPartitionId: Guid,
    Library: Guid,
    Reserved: Guid,
    dwDeferDismountDelay: u32,
};

pub const NtmsLibraryType = extern enum(i32) {
    UNKNOWN = 0,
    OFFLINE = 1,
    ONLINE = 2,
    STANDALONE = 3,
};
pub const NTMS_LIBRARYTYPE_UNKNOWN = NtmsLibraryType.UNKNOWN;
pub const NTMS_LIBRARYTYPE_OFFLINE = NtmsLibraryType.OFFLINE;
pub const NTMS_LIBRARYTYPE_ONLINE = NtmsLibraryType.ONLINE;
pub const NTMS_LIBRARYTYPE_STANDALONE = NtmsLibraryType.STANDALONE;

pub const NtmsLibraryFlags = extern enum(i32) {
    FIXEDOFFLINE = 1,
    CLEANERPRESENT = 2,
    AUTODETECTCHANGE = 4,
    IGNORECLEANERUSESREMAINING = 8,
    RECOGNIZECLEANERBARCODE = 16,
};
pub const NTMS_LIBRARYFLAG_FIXEDOFFLINE = NtmsLibraryFlags.FIXEDOFFLINE;
pub const NTMS_LIBRARYFLAG_CLEANERPRESENT = NtmsLibraryFlags.CLEANERPRESENT;
pub const NTMS_LIBRARYFLAG_AUTODETECTCHANGE = NtmsLibraryFlags.AUTODETECTCHANGE;
pub const NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING = NtmsLibraryFlags.IGNORECLEANERUSESREMAINING;
pub const NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE = NtmsLibraryFlags.RECOGNIZECLEANERBARCODE;

pub const NtmsInventoryMethod = extern enum(i32) {
    NONE = 0,
    FAST = 1,
    OMID = 2,
    DEFAULT = 3,
    SLOT = 4,
    STOP = 5,
    MAX = 6,
};
pub const NTMS_INVENTORY_NONE = NtmsInventoryMethod.NONE;
pub const NTMS_INVENTORY_FAST = NtmsInventoryMethod.FAST;
pub const NTMS_INVENTORY_OMID = NtmsInventoryMethod.OMID;
pub const NTMS_INVENTORY_DEFAULT = NtmsInventoryMethod.DEFAULT;
pub const NTMS_INVENTORY_SLOT = NtmsInventoryMethod.SLOT;
pub const NTMS_INVENTORY_STOP = NtmsInventoryMethod.STOP;
pub const NTMS_INVENTORY_MAX = NtmsInventoryMethod.MAX;

pub const NTMS_LIBRARYINFORMATION = extern struct {
    LibraryType: NtmsLibraryType,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: NtmsInventoryMethod,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
    AutoRecovery: BOOL,
    dwFlags: NtmsLibraryFlags,
};

pub const NTMS_CHANGERINFORMATIONA = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: [32]CHAR,
    szRevision: [32]CHAR,
    szDeviceName: [64]CHAR,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};

pub const NTMS_CHANGERINFORMATIONW = extern struct {
    Number: u32,
    ChangerType: Guid,
    szSerialNumber: [32]u16,
    szRevision: [32]u16,
    szDeviceName: [64]u16,
    ScsiPort: u16,
    ScsiBus: u16,
    ScsiTarget: u16,
    ScsiLun: u16,
    Library: Guid,
};

pub const NtmsSlotState = extern enum(i32) {
    UNKNOWN = 0,
    FULL = 1,
    EMPTY = 2,
    NOTPRESENT = 3,
    NEEDSINVENTORY = 4,
};
pub const NTMS_SLOTSTATE_UNKNOWN = NtmsSlotState.UNKNOWN;
pub const NTMS_SLOTSTATE_FULL = NtmsSlotState.FULL;
pub const NTMS_SLOTSTATE_EMPTY = NtmsSlotState.EMPTY;
pub const NTMS_SLOTSTATE_NOTPRESENT = NtmsSlotState.NOTPRESENT;
pub const NTMS_SLOTSTATE_NEEDSINVENTORY = NtmsSlotState.NEEDSINVENTORY;

pub const NTMS_STORAGESLOTINFORMATION = extern struct {
    Number: u32,
    State: u32,
    Library: Guid,
};

pub const NtmsDoorState = extern enum(i32) {
    UNKNOWN = 0,
    CLOSED = 1,
    OPEN = 2,
};
pub const NTMS_DOORSTATE_UNKNOWN = NtmsDoorState.UNKNOWN;
pub const NTMS_DOORSTATE_CLOSED = NtmsDoorState.CLOSED;
pub const NTMS_DOORSTATE_OPEN = NtmsDoorState.OPEN;

pub const NTMS_IEDOORINFORMATION = extern struct {
    Number: u32,
    State: NtmsDoorState,
    MaxOpenSecs: u16,
    Library: Guid,
};

pub const NtmsPortPosition = extern enum(i32) {
    UNKNOWN = 0,
    EXTENDED = 1,
    RETRACTED = 2,
};
pub const NTMS_PORTPOSITION_UNKNOWN = NtmsPortPosition.UNKNOWN;
pub const NTMS_PORTPOSITION_EXTENDED = NtmsPortPosition.EXTENDED;
pub const NTMS_PORTPOSITION_RETRACTED = NtmsPortPosition.RETRACTED;

pub const NtmsPortContent = extern enum(i32) {
    UNKNOWN = 0,
    FULL = 1,
    EMPTY = 2,
};
pub const NTMS_PORTCONTENT_UNKNOWN = NtmsPortContent.UNKNOWN;
pub const NTMS_PORTCONTENT_FULL = NtmsPortContent.FULL;
pub const NTMS_PORTCONTENT_EMPTY = NtmsPortContent.EMPTY;

pub const NTMS_IEPORTINFORMATION = extern struct {
    Number: u32,
    Content: NtmsPortContent,
    Position: NtmsPortPosition,
    MaxExtendSecs: u16,
    Library: Guid,
};

pub const NtmsBarCodeState = extern enum(i32) {
    OK = 1,
    UNREADABLE = 2,
};
pub const NTMS_BARCODESTATE_OK = NtmsBarCodeState.OK;
pub const NTMS_BARCODESTATE_UNREADABLE = NtmsBarCodeState.UNREADABLE;

pub const NtmsMediaState = extern enum(i32) {
    IDLE = 0,
    INUSE = 1,
    MOUNTED = 2,
    LOADED = 3,
    UNLOADED = 4,
    OPERROR = 5,
    OPREQ = 6,
};
pub const NTMS_MEDIASTATE_IDLE = NtmsMediaState.IDLE;
pub const NTMS_MEDIASTATE_INUSE = NtmsMediaState.INUSE;
pub const NTMS_MEDIASTATE_MOUNTED = NtmsMediaState.MOUNTED;
pub const NTMS_MEDIASTATE_LOADED = NtmsMediaState.LOADED;
pub const NTMS_MEDIASTATE_UNLOADED = NtmsMediaState.UNLOADED;
pub const NTMS_MEDIASTATE_OPERROR = NtmsMediaState.OPERROR;
pub const NTMS_MEDIASTATE_OPREQ = NtmsMediaState.OPREQ;

pub const NTMS_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]CHAR,
    BarCodeState: NtmsBarCodeState,
    szSequenceNumber: [32]CHAR,
    MediaState: NtmsMediaState,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};

pub const NTMS_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]u16,
    BarCodeState: NtmsBarCodeState,
    szSequenceNumber: [32]u16,
    MediaState: NtmsMediaState,
    dwNumberOfPartitions: u32,
    dwMediaTypeCode: u32,
    dwDensityCode: u32,
    MountedPartition: Guid,
};

pub const NTMS_LMIDINFORMATION = extern struct {
    MediaPool: Guid,
    dwNumberOfPartitions: u32,
};

pub const NtmsPartitionState = extern enum(i32) {
    UNKNOWN = 0,
    UNPREPARED = 1,
    INCOMPATIBLE = 2,
    DECOMMISSIONED = 3,
    AVAILABLE = 4,
    ALLOCATED = 5,
    COMPLETE = 6,
    FOREIGN = 7,
    IMPORT = 8,
    RESERVED = 9,
};
pub const NTMS_PARTSTATE_UNKNOWN = NtmsPartitionState.UNKNOWN;
pub const NTMS_PARTSTATE_UNPREPARED = NtmsPartitionState.UNPREPARED;
pub const NTMS_PARTSTATE_INCOMPATIBLE = NtmsPartitionState.INCOMPATIBLE;
pub const NTMS_PARTSTATE_DECOMMISSIONED = NtmsPartitionState.DECOMMISSIONED;
pub const NTMS_PARTSTATE_AVAILABLE = NtmsPartitionState.AVAILABLE;
pub const NTMS_PARTSTATE_ALLOCATED = NtmsPartitionState.ALLOCATED;
pub const NTMS_PARTSTATE_COMPLETE = NtmsPartitionState.COMPLETE;
pub const NTMS_PARTSTATE_FOREIGN = NtmsPartitionState.FOREIGN;
pub const NTMS_PARTSTATE_IMPORT = NtmsPartitionState.IMPORT;
pub const NTMS_PARTSTATE_RESERVED = NtmsPartitionState.RESERVED;

pub const NTMS_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: NtmsPartitionState,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]CHAR,
    szOmidLabelInfo: [256]CHAR,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};

pub const NTMS_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: NtmsPartitionState,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]u16,
    szOmidLabelInfo: [256]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
    Capacity: LARGE_INTEGER,
};

pub const NtmsPoolType = extern enum(i32) {
    UNKNOWN = 0,
    SCRATCH = 1,
    FOREIGN = 2,
    IMPORT = 3,
    APPLICATION = 1000,
};
pub const NTMS_POOLTYPE_UNKNOWN = NtmsPoolType.UNKNOWN;
pub const NTMS_POOLTYPE_SCRATCH = NtmsPoolType.SCRATCH;
pub const NTMS_POOLTYPE_FOREIGN = NtmsPoolType.FOREIGN;
pub const NTMS_POOLTYPE_IMPORT = NtmsPoolType.IMPORT;
pub const NTMS_POOLTYPE_APPLICATION = NtmsPoolType.APPLICATION;

pub const NtmsAllocationPolicy = extern enum(i32) {
    H = 1,
};
pub const NTMS_ALLOCATE_FROMSCRATCH = NtmsAllocationPolicy.H;

pub const NtmsDeallocationPolicy = extern enum(i32) {
    H = 1,
};
pub const NTMS_DEALLOCATE_TOSCRATCH = NtmsDeallocationPolicy.H;

pub const NTMS_MEDIAPOOLINFORMATION = extern struct {
    PoolType: u32,
    MediaType: Guid,
    Parent: Guid,
    AllocationPolicy: u32,
    DeallocationPolicy: u32,
    dwMaxAllocates: u32,
    dwNumberOfPhysicalMedia: u32,
    dwNumberOfLogicalMedia: u32,
    dwNumberOfMediaPools: u32,
};

pub const NtmsReadWriteCharacteristics = extern enum(i32) {
    UNKNOWN = 0,
    REWRITABLE = 1,
    WRITEONCE = 2,
    READONLY = 3,
};
pub const NTMS_MEDIARW_UNKNOWN = NtmsReadWriteCharacteristics.UNKNOWN;
pub const NTMS_MEDIARW_REWRITABLE = NtmsReadWriteCharacteristics.REWRITABLE;
pub const NTMS_MEDIARW_WRITEONCE = NtmsReadWriteCharacteristics.WRITEONCE;
pub const NTMS_MEDIARW_READONLY = NtmsReadWriteCharacteristics.READONLY;

pub const NTMS_MEDIATYPEINFORMATION = extern struct {
    MediaType: u32,
    NumberOfSides: u32,
    ReadWriteCharacteristics: NtmsReadWriteCharacteristics,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_DRIVETYPEINFORMATIONA = extern struct {
    szVendor: [128]CHAR,
    szProduct: [128]CHAR,
    NumberOfHeads: u32,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_DRIVETYPEINFORMATIONW = extern struct {
    szVendor: [128]u16,
    szProduct: [128]u16,
    NumberOfHeads: u32,
    DeviceType: FILE_DEVICE_TYPE,
};

pub const NTMS_CHANGERTYPEINFORMATIONA = extern struct {
    szVendor: [128]CHAR,
    szProduct: [128]CHAR,
    DeviceType: u32,
};

pub const NTMS_CHANGERTYPEINFORMATIONW = extern struct {
    szVendor: [128]u16,
    szProduct: [128]u16,
    DeviceType: u32,
};

pub const NtmsLmOperation = extern enum(i32) {
    REMOVE = 0,
    DISABLECHANGER = 1,
    DISABLELIBRARY = 1,
    ENABLECHANGER = 2,
    ENABLELIBRARY = 2,
    DISABLEDRIVE = 3,
    ENABLEDRIVE = 4,
    DISABLEMEDIA = 5,
    ENABLEMEDIA = 6,
    UPDATEOMID = 7,
    INVENTORY = 8,
    DOORACCESS = 9,
    EJECT = 10,
    EJECTCLEANER = 11,
    INJECT = 12,
    INJECTCLEANER = 13,
    PROCESSOMID = 14,
    CLEANDRIVE = 15,
    DISMOUNT = 16,
    MOUNT = 17,
    WRITESCRATCH = 18,
    CLASSIFY = 19,
    RESERVECLEANER = 20,
    RELEASECLEANER = 21,
    MAXWORKITEM = 22,
};
pub const NTMS_LM_REMOVE = NtmsLmOperation.REMOVE;
pub const NTMS_LM_DISABLECHANGER = NtmsLmOperation.DISABLECHANGER;
pub const NTMS_LM_DISABLELIBRARY = NtmsLmOperation.DISABLELIBRARY;
pub const NTMS_LM_ENABLECHANGER = NtmsLmOperation.ENABLECHANGER;
pub const NTMS_LM_ENABLELIBRARY = NtmsLmOperation.ENABLELIBRARY;
pub const NTMS_LM_DISABLEDRIVE = NtmsLmOperation.DISABLEDRIVE;
pub const NTMS_LM_ENABLEDRIVE = NtmsLmOperation.ENABLEDRIVE;
pub const NTMS_LM_DISABLEMEDIA = NtmsLmOperation.DISABLEMEDIA;
pub const NTMS_LM_ENABLEMEDIA = NtmsLmOperation.ENABLEMEDIA;
pub const NTMS_LM_UPDATEOMID = NtmsLmOperation.UPDATEOMID;
pub const NTMS_LM_INVENTORY = NtmsLmOperation.INVENTORY;
pub const NTMS_LM_DOORACCESS = NtmsLmOperation.DOORACCESS;
pub const NTMS_LM_EJECT = NtmsLmOperation.EJECT;
pub const NTMS_LM_EJECTCLEANER = NtmsLmOperation.EJECTCLEANER;
pub const NTMS_LM_INJECT = NtmsLmOperation.INJECT;
pub const NTMS_LM_INJECTCLEANER = NtmsLmOperation.INJECTCLEANER;
pub const NTMS_LM_PROCESSOMID = NtmsLmOperation.PROCESSOMID;
pub const NTMS_LM_CLEANDRIVE = NtmsLmOperation.CLEANDRIVE;
pub const NTMS_LM_DISMOUNT = NtmsLmOperation.DISMOUNT;
pub const NTMS_LM_MOUNT = NtmsLmOperation.MOUNT;
pub const NTMS_LM_WRITESCRATCH = NtmsLmOperation.WRITESCRATCH;
pub const NTMS_LM_CLASSIFY = NtmsLmOperation.CLASSIFY;
pub const NTMS_LM_RESERVECLEANER = NtmsLmOperation.RESERVECLEANER;
pub const NTMS_LM_RELEASECLEANER = NtmsLmOperation.RELEASECLEANER;
pub const NTMS_LM_MAXWORKITEM = NtmsLmOperation.MAXWORKITEM;

pub const NtmsLmState = extern enum(i32) {
    QUEUED = 0,
    INPROCESS = 1,
    PASSED = 2,
    FAILED = 3,
    INVALID = 4,
    WAITING = 5,
    DEFERRED = 6,
    DEFFERED = 6,
    CANCELLED = 7,
    STOPPED = 8,
};
pub const NTMS_LM_QUEUED = NtmsLmState.QUEUED;
pub const NTMS_LM_INPROCESS = NtmsLmState.INPROCESS;
pub const NTMS_LM_PASSED = NtmsLmState.PASSED;
pub const NTMS_LM_FAILED = NtmsLmState.FAILED;
pub const NTMS_LM_INVALID = NtmsLmState.INVALID;
pub const NTMS_LM_WAITING = NtmsLmState.WAITING;
pub const NTMS_LM_DEFERRED = NtmsLmState.DEFERRED;
pub const NTMS_LM_DEFFERED = NtmsLmState.DEFFERED;
pub const NTMS_LM_CANCELLED = NtmsLmState.CANCELLED;
pub const NTMS_LM_STOPPED = NtmsLmState.STOPPED;

pub const NTMS_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: NtmsLmOperation,
    OperationOption: u32,
    State: NtmsLmState,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};

pub const NTMS_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: NtmsLmOperation,
    OperationOption: u32,
    State: NtmsLmState,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
    dwErrorCode: u32,
    WorkItemId: Guid,
    dwPriority: u32,
};

pub const NtmsOpreqCommand = extern enum(i32) {
    UNKNOWN = 0,
    NEWMEDIA = 1,
    CLEANER = 2,
    DEVICESERVICE = 3,
    MOVEMEDIA = 4,
    MESSAGE = 5,
};
pub const NTMS_OPREQ_UNKNOWN = NtmsOpreqCommand.UNKNOWN;
pub const NTMS_OPREQ_NEWMEDIA = NtmsOpreqCommand.NEWMEDIA;
pub const NTMS_OPREQ_CLEANER = NtmsOpreqCommand.CLEANER;
pub const NTMS_OPREQ_DEVICESERVICE = NtmsOpreqCommand.DEVICESERVICE;
pub const NTMS_OPREQ_MOVEMEDIA = NtmsOpreqCommand.MOVEMEDIA;
pub const NTMS_OPREQ_MESSAGE = NtmsOpreqCommand.MESSAGE;

pub const NtmsOpreqState = extern enum(i32) {
    UNKNOWN = 0,
    SUBMITTED = 1,
    ACTIVE = 2,
    INPROGRESS = 3,
    REFUSED = 4,
    COMPLETE = 5,
};
pub const NTMS_OPSTATE_UNKNOWN = NtmsOpreqState.UNKNOWN;
pub const NTMS_OPSTATE_SUBMITTED = NtmsOpreqState.SUBMITTED;
pub const NTMS_OPSTATE_ACTIVE = NtmsOpreqState.ACTIVE;
pub const NTMS_OPSTATE_INPROGRESS = NtmsOpreqState.INPROGRESS;
pub const NTMS_OPSTATE_REFUSED = NtmsOpreqState.REFUSED;
pub const NTMS_OPSTATE_COMPLETE = NtmsOpreqState.COMPLETE;

pub const NTMS_OPREQUESTINFORMATIONA = extern struct {
    Request: NtmsOpreqCommand,
    Submitted: SYSTEMTIME,
    State: NtmsOpreqState,
    szMessage: [256]CHAR,
    Arg1Type: NtmsObjectsTypes,
    Arg1: Guid,
    Arg2Type: NtmsObjectsTypes,
    Arg2: Guid,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_OPREQUESTINFORMATIONW = extern struct {
    Request: NtmsOpreqCommand,
    Submitted: SYSTEMTIME,
    State: NtmsOpreqState,
    szMessage: [256]u16,
    Arg1Type: NtmsObjectsTypes,
    Arg1: Guid,
    Arg2Type: NtmsObjectsTypes,
    Arg2: Guid,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_COMPUTERINFORMATION = extern struct {
    dwLibRequestPurgeTime: u32,
    dwOpRequestPurgeTime: u32,
    dwLibRequestFlags: u32,
    dwOpRequestFlags: u32,
    dwMediaPoolPolicy: u32,
};

pub const NtmsLibRequestFlags = extern enum(i32) {
    AUTOPURGE = 1,
    FAILEDPURGE = 2,
};
pub const NTMS_LIBREQFLAGS_NOAUTOPURGE = NtmsLibRequestFlags.AUTOPURGE;
pub const NTMS_LIBREQFLAGS_NOFAILEDPURGE = NtmsLibRequestFlags.FAILEDPURGE;

pub const NtmsOpRequestFlags = extern enum(i32) {
    AUTOPURGE = 1,
    FAILEDPURGE = 2,
    ALERTS = 16,
    TRAYICON = 32,
};
pub const NTMS_OPREQFLAGS_NOAUTOPURGE = NtmsOpRequestFlags.AUTOPURGE;
pub const NTMS_OPREQFLAGS_NOFAILEDPURGE = NtmsOpRequestFlags.FAILEDPURGE;
pub const NTMS_OPREQFLAGS_NOALERTS = NtmsOpRequestFlags.ALERTS;
pub const NTMS_OPREQFLAGS_NOTRAYICON = NtmsOpRequestFlags.TRAYICON;

pub const NtmsMediaPoolPolicy = extern enum(i32) {
    PURGEOFFLINESCRATCH = 1,
    KEEPOFFLINEIMPORT = 2,
};
pub const NTMS_POOLPOLICY_PURGEOFFLINESCRATCH = NtmsMediaPoolPolicy.PURGEOFFLINESCRATCH;
pub const NTMS_POOLPOLICY_KEEPOFFLINEIMPORT = NtmsMediaPoolPolicy.KEEPOFFLINEIMPORT;

pub const NtmsOperationalState = extern enum(i32) {
    READY = 0,
    INITIALIZING = 10,
    NEEDS_SERVICE = 20,
    NOT_PRESENT = 21,
};
pub const NTMS_READY = NtmsOperationalState.READY;
pub const NTMS_INITIALIZING = NtmsOperationalState.INITIALIZING;
pub const NTMS_NEEDS_SERVICE = NtmsOperationalState.NEEDS_SERVICE;
pub const NTMS_NOT_PRESENT = NtmsOperationalState.NOT_PRESENT;

pub const NTMS_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: NtmsObjectsTypes,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: NtmsOperationalState,
    szName: [64]CHAR,
    szDescription: [127]CHAR,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const NTMS_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: NtmsObjectsTypes,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: NtmsOperationalState,
    szName: [64]u16,
    szDescription: [127]u16,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const NTMS_I1_LIBRARYINFORMATION = extern struct {
    LibraryType: u32,
    CleanerSlot: Guid,
    CleanerSlotDefault: Guid,
    LibrarySupportsDriveCleaning: BOOL,
    BarCodeReaderInstalled: BOOL,
    InventoryMethod: u32,
    dwCleanerUsesRemaining: u32,
    FirstDriveNumber: u32,
    dwNumberOfDrives: u32,
    FirstSlotNumber: u32,
    dwNumberOfSlots: u32,
    FirstDoorNumber: u32,
    dwNumberOfDoors: u32,
    FirstPortNumber: u32,
    dwNumberOfPorts: u32,
    FirstChangerNumber: u32,
    dwNumberOfChangers: u32,
    dwNumberOfMedia: u32,
    dwNumberOfMediaTypes: u32,
    dwNumberOfLibRequests: u32,
    Reserved: Guid,
};

pub const NTMS_I1_LIBREQUESTINFORMATIONA = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_I1_LIBREQUESTINFORMATIONW = extern struct {
    OperationCode: u32,
    OperationOption: u32,
    State: u32,
    PartitionId: Guid,
    DriveId: Guid,
    PhysMediaId: Guid,
    Library: Guid,
    SlotId: Guid,
    TimeQueued: SYSTEMTIME,
    TimeCompleted: SYSTEMTIME,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_I1_PMIDINFORMATIONA = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]CHAR,
    BarCodeState: u32,
    szSequenceNumber: [32]CHAR,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};

pub const NTMS_I1_PMIDINFORMATIONW = extern struct {
    CurrentLibrary: Guid,
    MediaPool: Guid,
    Location: Guid,
    LocationType: u32,
    MediaType: Guid,
    HomeSlot: Guid,
    szBarCode: [64]u16,
    BarCodeState: u32,
    szSequenceNumber: [32]u16,
    MediaState: u32,
    dwNumberOfPartitions: u32,
};

pub const NTMS_I1_PARTITIONINFORMATIONA = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]CHAR,
    szOmidLabelInfo: [256]CHAR,
    dwMountCount: u32,
    dwAllocateCount: u32,
};

pub const NTMS_I1_PARTITIONINFORMATIONW = extern struct {
    PhysicalMedia: Guid,
    LogicalMedia: Guid,
    State: u32,
    Side: u16,
    dwOmidLabelIdLength: u32,
    OmidLabelId: [255]u8,
    szOmidLabelType: [64]u16,
    szOmidLabelInfo: [256]u16,
    dwMountCount: u32,
    dwAllocateCount: u32,
};

pub const NTMS_I1_OPREQUESTINFORMATIONA = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: [127]CHAR,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: [64]CHAR,
    szUser: [64]CHAR,
    szComputer: [64]CHAR,
};

pub const NTMS_I1_OPREQUESTINFORMATIONW = extern struct {
    Request: u32,
    Submitted: SYSTEMTIME,
    State: u32,
    szMessage: [127]u16,
    Arg1Type: u32,
    Arg1: Guid,
    Arg2Type: u32,
    Arg2: Guid,
    szApplication: [64]u16,
    szUser: [64]u16,
    szComputer: [64]u16,
};

pub const NTMS_I1_OBJECTINFORMATIONA = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: [64]CHAR,
    szDescription: [127]CHAR,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const NTMS_I1_OBJECTINFORMATIONW = extern struct {
    dwSize: u32,
    dwType: u32,
    Created: SYSTEMTIME,
    Modified: SYSTEMTIME,
    ObjectGuid: Guid,
    Enabled: BOOL,
    dwOperationalState: u32,
    szName: [64]u16,
    szDescription: [127]u16,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const NtmsCreateNtmsMediaOptions = extern enum(i32) {
    E = 1,
};
pub const NTMS_ERROR_ON_DUPLICATE = NtmsCreateNtmsMediaOptions.E;

pub const NtmsEnumerateOption = extern enum(i32) {
    DEFAULT = 0,
    ROOTPOOL = 1,
};
pub const NTMS_ENUM_DEFAULT = NtmsEnumerateOption.DEFAULT;
pub const NTMS_ENUM_ROOTPOOL = NtmsEnumerateOption.ROOTPOOL;

pub const NtmsEjectOperation = extern enum(i32) {
    START = 0,
    STOP = 1,
    QUEUE = 2,
    FORCE = 3,
    IMMEDIATE = 4,
    ASK_USER = 5,
};
pub const NTMS_EJECT_START = NtmsEjectOperation.START;
pub const NTMS_EJECT_STOP = NtmsEjectOperation.STOP;
pub const NTMS_EJECT_QUEUE = NtmsEjectOperation.QUEUE;
pub const NTMS_EJECT_FORCE = NtmsEjectOperation.FORCE;
pub const NTMS_EJECT_IMMEDIATE = NtmsEjectOperation.IMMEDIATE;
pub const NTMS_EJECT_ASK_USER = NtmsEjectOperation.ASK_USER;

pub const NtmsInjectOperation = extern enum(i32) {
    START = 0,
    STOP = 1,
    RETRACT = 2,
    STARTMANY = 3,
};
pub const NTMS_INJECT_START = NtmsInjectOperation.START;
pub const NTMS_INJECT_STOP = NtmsInjectOperation.STOP;
pub const NTMS_INJECT_RETRACT = NtmsInjectOperation.RETRACT;
pub const NTMS_INJECT_STARTMANY = NtmsInjectOperation.STARTMANY;

pub const NTMS_FILESYSTEM_INFO = extern struct {
    FileSystemType: [64]u16,
    VolumeName: [256]u16,
    SerialNumber: u32,
};

pub const NtmsDriveType = extern enum(i32) {
    E = 0,
};
pub const NTMS_UNKNOWN_DRIVE = NtmsDriveType.E;

pub const NtmsAccessMask = extern enum(i32) {
    USE_ACCESS = 1,
    MODIFY_ACCESS = 2,
    CONTROL_ACCESS = 4,
};
pub const NTMS_USE_ACCESS = NtmsAccessMask.USE_ACCESS;
pub const NTMS_MODIFY_ACCESS = NtmsAccessMask.MODIFY_ACCESS;
pub const NTMS_CONTROL_ACCESS = NtmsAccessMask.CONTROL_ACCESS;

pub const NtmsUITypes = extern enum(i32) {
    INVALID = 0,
    INFO = 1,
    REQ = 2,
    ERR = 3,
    MAX = 4,
};
pub const NTMS_UITYPE_INVALID = NtmsUITypes.INVALID;
pub const NTMS_UITYPE_INFO = NtmsUITypes.INFO;
pub const NTMS_UITYPE_REQ = NtmsUITypes.REQ;
pub const NTMS_UITYPE_ERR = NtmsUITypes.ERR;
pub const NTMS_UITYPE_MAX = NtmsUITypes.MAX;

pub const NtmsUIOperations = extern enum(i32) {
    DEST_ADD = 1,
    DEST_DELETE = 2,
    DEST_DELETEALL = 3,
    OPERATION_MAX = 4,
};
pub const NTMS_UIDEST_ADD = NtmsUIOperations.DEST_ADD;
pub const NTMS_UIDEST_DELETE = NtmsUIOperations.DEST_DELETE;
pub const NTMS_UIDEST_DELETEALL = NtmsUIOperations.DEST_DELETEALL;
pub const NTMS_UIOPERATION_MAX = NtmsUIOperations.OPERATION_MAX;

pub const NtmsNotificationOperations = extern enum(i32) {
    OBJ_UPDATE = 1,
    OBJ_INSERT = 2,
    OBJ_DELETE = 3,
    EVENT_SIGNAL = 4,
    EVENT_COMPLETE = 5,
};
pub const NTMS_OBJ_UPDATE = NtmsNotificationOperations.OBJ_UPDATE;
pub const NTMS_OBJ_INSERT = NtmsNotificationOperations.OBJ_INSERT;
pub const NTMS_OBJ_DELETE = NtmsNotificationOperations.OBJ_DELETE;
pub const NTMS_EVENT_SIGNAL = NtmsNotificationOperations.EVENT_SIGNAL;
pub const NTMS_EVENT_COMPLETE = NtmsNotificationOperations.EVENT_COMPLETE;

pub const NTMS_NOTIFICATIONINFORMATION = extern struct {
    dwOperation: NtmsNotificationOperations,
    ObjectId: Guid,
};

pub const MediaLabelInfo = extern struct {
    LabelType: [64]u16,
    LabelIDSize: u32,
    LabelID: [256]u8,
    LabelAppDescr: [256]u16,
};

pub const MAXMEDIALABEL = fn(
    pMaxSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLAIMMEDIALABEL = fn(
    pBuffer: *const u8,
    nBufferSize: u32,
    pLabelInfo: *MediaLabelInfo,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLAIMMEDIALABELEX = fn(
    pBuffer: *const u8,
    nBufferSize: u32,
    pLabelInfo: *MediaLabelInfo,
    LabelGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CLS_LSN = extern struct {
    Internal: u64,
};

pub const CLS_CONTEXT_MODE = extern enum(i32) {
    None = 0,
    UndoNext = 1,
    Previous = 2,
    Forward = 3,
};
pub const ClsContextNone = CLS_CONTEXT_MODE.None;
pub const ClsContextUndoNext = CLS_CONTEXT_MODE.UndoNext;
pub const ClsContextPrevious = CLS_CONTEXT_MODE.Previous;
pub const ClsContextForward = CLS_CONTEXT_MODE.Forward;

pub const CLFS_CONTEXT_MODE = extern enum(i32) {
    None = 0,
    UndoNext = 1,
    Previous = 2,
    Forward = 3,
};
pub const ClfsContextNone = CLFS_CONTEXT_MODE.None;
pub const ClfsContextUndoNext = CLFS_CONTEXT_MODE.UndoNext;
pub const ClfsContextPrevious = CLFS_CONTEXT_MODE.Previous;
pub const ClfsContextForward = CLFS_CONTEXT_MODE.Forward;

pub const CLFS_NODE_ID = extern struct {
    cType: u32,
    cbNode: u32,
};

pub const CLS_WRITE_ENTRY = extern struct {
    Buffer: *c_void,
    ByteLength: u32,
};

pub const CLS_INFORMATION = extern struct {
    TotalAvailable: i64,
    CurrentAvailable: i64,
    TotalReservation: i64,
    BaseFileSize: u64,
    ContainerSize: u64,
    TotalContainers: u32,
    FreeContainers: u32,
    TotalClients: u32,
    Attributes: u32,
    FlushThreshold: u32,
    SectorSize: u32,
    MinArchiveTailLsn: CLS_LSN,
    BaseLsn: CLS_LSN,
    LastFlushedLsn: CLS_LSN,
    LastLsn: CLS_LSN,
    RestartLsn: CLS_LSN,
    Identity: Guid,
};

pub const CLFS_LOG_NAME_INFORMATION = extern struct {
    NameLengthInBytes: u16,
    Name: [1]u16,
};

pub const CLFS_STREAM_ID_INFORMATION = extern struct {
    StreamIdentifier: u8,
};

pub const CLFS_PHYSICAL_LSN_INFORMATION = extern struct {
    StreamIdentifier: u8,
    VirtualLsn: CLS_LSN,
    PhysicalLsn: CLS_LSN,
};

pub const CLS_CONTAINER_INFORMATION = extern struct {
    FileAttributes: u32,
    CreationTime: u64,
    LastAccessTime: u64,
    LastWriteTime: u64,
    ContainerSize: i64,
    FileNameActualLength: u32,
    FileNameLength: u32,
    FileName: [256]u16,
    State: u32,
    PhysicalContainerId: u32,
    LogicalContainerId: u32,
};

pub const CLS_LOG_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    BasicInformationPhysical = 1,
    PhysicalNameInformation = 2,
    StreamIdentifierInformation = 3,
    SystemMarkingInformation = 4,
    PhysicalLsnInformation = 5,
};
pub const ClfsLogBasicInformation = CLS_LOG_INFORMATION_CLASS.BasicInformation;
pub const ClfsLogBasicInformationPhysical = CLS_LOG_INFORMATION_CLASS.BasicInformationPhysical;
pub const ClfsLogPhysicalNameInformation = CLS_LOG_INFORMATION_CLASS.PhysicalNameInformation;
pub const ClfsLogStreamIdentifierInformation = CLS_LOG_INFORMATION_CLASS.StreamIdentifierInformation;
pub const ClfsLogSystemMarkingInformation = CLS_LOG_INFORMATION_CLASS.SystemMarkingInformation;
pub const ClfsLogPhysicalLsnInformation = CLS_LOG_INFORMATION_CLASS.PhysicalLsnInformation;

pub const CLS_IOSTATS_CLASS = extern enum(i32) {
    Default = 0,
    Max = 65535,
};
pub const ClsIoStatsDefault = CLS_IOSTATS_CLASS.Default;
pub const ClsIoStatsMax = CLS_IOSTATS_CLASS.Max;

pub const CLFS_IOSTATS_CLASS = extern enum(i32) {
    Default = 0,
    Max = 65535,
};
pub const ClfsIoStatsDefault = CLFS_IOSTATS_CLASS.Default;
pub const ClfsIoStatsMax = CLFS_IOSTATS_CLASS.Max;

pub const CLS_IO_STATISTICS_HEADER = extern struct {
    ubMajorVersion: u8,
    ubMinorVersion: u8,
    eStatsClass: CLFS_IOSTATS_CLASS,
    cbLength: u16,
    coffData: u32,
};

pub const CLS_IO_STATISTICS = extern struct {
    hdrIoStats: CLS_IO_STATISTICS_HEADER,
    cFlush: u64,
    cbFlush: u64,
    cMetaFlush: u64,
    cbMetaFlush: u64,
};

pub const CLS_SCAN_CONTEXT = extern struct {
    cidNode: CLFS_NODE_ID,
    hLog: HANDLE,
    cIndex: u32,
    cContainers: u32,
    cContainersReturned: u32,
    eScanMode: u8,
    pinfoContainer: *CLS_CONTAINER_INFORMATION,
};

pub const CLS_ARCHIVE_DESCRIPTOR = extern struct {
    coffLow: u64,
    coffHigh: u64,
    infoContainer: CLS_CONTAINER_INFORMATION,
};

pub const CLFS_BLOCK_ALLOCATION = fn(
    cbBufferLength: u32,
    pvUserContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const CLFS_BLOCK_DEALLOCATION = fn(
    pvBuffer: *c_void,
    pvUserContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CLFS_LOG_ARCHIVE_MODE = extern enum(i32) {
    Enabled = 1,
    Disabled = 2,
};
pub const ClfsLogArchiveEnabled = CLFS_LOG_ARCHIVE_MODE.Enabled;
pub const ClfsLogArchiveDisabled = CLFS_LOG_ARCHIVE_MODE.Disabled;

pub const PCLFS_COMPLETION_ROUTINE = fn(
    pvOverlapped: *c_void,
    ulReserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CLFS_MGMT_POLICY_TYPE = extern enum(i32) {
    MaximumSize = 0,
    MinimumSize = 1,
    NewContainerSize = 2,
    GrowthRate = 3,
    LogTail = 4,
    AutoShrink = 5,
    AutoGrow = 6,
    NewContainerPrefix = 7,
    NewContainerSuffix = 8,
    NewContainerExtension = 9,
    Invalid = 10,
};
pub const ClfsMgmtPolicyMaximumSize = CLFS_MGMT_POLICY_TYPE.MaximumSize;
pub const ClfsMgmtPolicyMinimumSize = CLFS_MGMT_POLICY_TYPE.MinimumSize;
pub const ClfsMgmtPolicyNewContainerSize = CLFS_MGMT_POLICY_TYPE.NewContainerSize;
pub const ClfsMgmtPolicyGrowthRate = CLFS_MGMT_POLICY_TYPE.GrowthRate;
pub const ClfsMgmtPolicyLogTail = CLFS_MGMT_POLICY_TYPE.LogTail;
pub const ClfsMgmtPolicyAutoShrink = CLFS_MGMT_POLICY_TYPE.AutoShrink;
pub const ClfsMgmtPolicyAutoGrow = CLFS_MGMT_POLICY_TYPE.AutoGrow;
pub const ClfsMgmtPolicyNewContainerPrefix = CLFS_MGMT_POLICY_TYPE.NewContainerPrefix;
pub const ClfsMgmtPolicyNewContainerSuffix = CLFS_MGMT_POLICY_TYPE.NewContainerSuffix;
pub const ClfsMgmtPolicyNewContainerExtension = CLFS_MGMT_POLICY_TYPE.NewContainerExtension;
pub const ClfsMgmtPolicyInvalid = CLFS_MGMT_POLICY_TYPE.Invalid;

pub const CLFS_MGMT_POLICY = extern struct {
    Version: u32,
    LengthInBytes: u32,
    PolicyFlags: u32,
    PolicyType: CLFS_MGMT_POLICY_TYPE,
    PolicyParameters: _PolicyParameters_e__Union,
    const _PolicyParameters_e__Union = u32; // TODO: generate this nested type!
};

pub const CLFS_MGMT_NOTIFICATION_TYPE = extern enum(i32) {
    AdvanceTailNotification = 0,
    LogFullHandlerNotification = 1,
    LogUnpinnedNotification = 2,
    LogWriteNotification = 3,
};
pub const ClfsMgmtAdvanceTailNotification = CLFS_MGMT_NOTIFICATION_TYPE.AdvanceTailNotification;
pub const ClfsMgmtLogFullHandlerNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogFullHandlerNotification;
pub const ClfsMgmtLogUnpinnedNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogUnpinnedNotification;
pub const ClfsMgmtLogWriteNotification = CLFS_MGMT_NOTIFICATION_TYPE.LogWriteNotification;

pub const CLFS_MGMT_NOTIFICATION = extern struct {
    Notification: CLFS_MGMT_NOTIFICATION_TYPE,
    Lsn: CLS_LSN,
    LogIsPinned: u16,
};

pub const PLOG_TAIL_ADVANCE_CALLBACK = fn(
    hLogFile: HANDLE,
    lsnTarget: CLS_LSN,
    pvClientContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLOG_FULL_HANDLER_CALLBACK = fn(
    hLogFile: HANDLE,
    dwError: u32,
    fLogIsPinned: BOOL,
    pvClientContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLOG_UNPINNED_CALLBACK = fn(
    hLogFile: HANDLE,
    pvClientContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LOG_MANAGEMENT_CALLBACKS = extern struct {
    CallbackContext: *c_void,
    AdvanceTailCallback: PLOG_TAIL_ADVANCE_CALLBACK,
    LogFullHandlerCallback: PLOG_FULL_HANDLER_CALLBACK,
    LogUnpinnedCallback: PLOG_UNPINNED_CALLBACK,
};

pub const DISKQUOTA_USER_INFORMATION = extern struct {
    QuotaUsed: i64,
    QuotaThreshold: i64,
    QuotaLimit: i64,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaUser_Value = @import("../zig.zig").Guid.initString("7988b574-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaUser = &IID_IDiskQuotaUser_Value;
pub const IDiskQuotaUser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: fn(
            self: *const IDiskQuotaUser,
            pulID: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IDiskQuotaUser,
            pszAccountContainer: PWSTR,
            cchAccountContainer: u32,
            pszLogonName: PWSTR,
            cchLogonName: u32,
            pszDisplayName: PWSTR,
            cchDisplayName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSidLength: fn(
            self: *const IDiskQuotaUser,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSid: fn(
            self: *const IDiskQuotaUser,
            pbSidBuffer: *u8,
            cbSidBuffer: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaThreshold: fn(
            self: *const IDiskQuotaUser,
            pllThreshold: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaThresholdText: fn(
            self: *const IDiskQuotaUser,
            pszText: PWSTR,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLimit: fn(
            self: *const IDiskQuotaUser,
            pllLimit: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLimitText: fn(
            self: *const IDiskQuotaUser,
            pszText: PWSTR,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaUsed: fn(
            self: *const IDiskQuotaUser,
            pllUsed: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaUsedText: fn(
            self: *const IDiskQuotaUser,
            pszText: PWSTR,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaInformation: fn(
            self: *const IDiskQuotaUser,
            pbQuotaInfo: *c_void,
            cbQuotaInfo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaThreshold: fn(
            self: *const IDiskQuotaUser,
            llThreshold: i64,
            fWriteThrough: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaLimit: fn(
            self: *const IDiskQuotaUser,
            llLimit: i64,
            fWriteThrough: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invalidate: fn(
            self: *const IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccountStatus: fn(
            self: *const IDiskQuotaUser,
            pdwStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetID(self: *const T, pulID: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetID(@ptrCast(*const IDiskQuotaUser, self), pulID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetName(self: *const T, pszAccountContainer: PWSTR, cchAccountContainer: u32, pszLogonName: PWSTR, cchLogonName: u32, pszDisplayName: PWSTR, cchDisplayName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetName(@ptrCast(*const IDiskQuotaUser, self), pszAccountContainer, cchAccountContainer, pszLogonName, cchLogonName, pszDisplayName, cchDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetSidLength(self: *const T, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetSidLength(@ptrCast(*const IDiskQuotaUser, self), pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetSid(self: *const T, pbSidBuffer: *u8, cbSidBuffer: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetSid(@ptrCast(*const IDiskQuotaUser, self), pbSidBuffer, cbSidBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaThreshold(self: *const T, pllThreshold: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaThreshold(@ptrCast(*const IDiskQuotaUser, self), pllThreshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaThresholdText(self: *const T, pszText: PWSTR, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaThresholdText(@ptrCast(*const IDiskQuotaUser, self), pszText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaLimit(self: *const T, pllLimit: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaLimit(@ptrCast(*const IDiskQuotaUser, self), pllLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaLimitText(self: *const T, pszText: PWSTR, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaLimitText(@ptrCast(*const IDiskQuotaUser, self), pszText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaUsed(self: *const T, pllUsed: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaUsed(@ptrCast(*const IDiskQuotaUser, self), pllUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaUsedText(self: *const T, pszText: PWSTR, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaUsedText(@ptrCast(*const IDiskQuotaUser, self), pszText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetQuotaInformation(self: *const T, pbQuotaInfo: *c_void, cbQuotaInfo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetQuotaInformation(@ptrCast(*const IDiskQuotaUser, self), pbQuotaInfo, cbQuotaInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_SetQuotaThreshold(self: *const T, llThreshold: i64, fWriteThrough: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).SetQuotaThreshold(@ptrCast(*const IDiskQuotaUser, self), llThreshold, fWriteThrough);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_SetQuotaLimit(self: *const T, llLimit: i64, fWriteThrough: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).SetQuotaLimit(@ptrCast(*const IDiskQuotaUser, self), llLimit, fWriteThrough);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_Invalidate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).Invalidate(@ptrCast(*const IDiskQuotaUser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUser_GetAccountStatus(self: *const T, pdwStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUser.VTable, self.vtable).GetAccountStatus(@ptrCast(*const IDiskQuotaUser, self), pdwStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumDiskQuotaUsers_Value = @import("../zig.zig").Guid.initString("7988b577-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IEnumDiskQuotaUsers = &IID_IEnumDiskQuotaUsers_Value;
pub const IEnumDiskQuotaUsers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDiskQuotaUsers,
            cUsers: u32,
            rgUsers: **IDiskQuotaUser,
            pcUsersFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDiskQuotaUsers,
            cUsers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDiskQuotaUsers,
            ppEnum: **IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiskQuotaUsers_Next(self: *const T, cUsers: u32, rgUsers: **IDiskQuotaUser, pcUsersFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiskQuotaUsers.VTable, self.vtable).Next(@ptrCast(*const IEnumDiskQuotaUsers, self), cUsers, rgUsers, pcUsersFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiskQuotaUsers_Skip(self: *const T, cUsers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiskQuotaUsers.VTable, self.vtable).Skip(@ptrCast(*const IEnumDiskQuotaUsers, self), cUsers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiskQuotaUsers_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiskQuotaUsers.VTable, self.vtable).Reset(@ptrCast(*const IEnumDiskQuotaUsers, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiskQuotaUsers_Clone(self: *const T, ppEnum: **IEnumDiskQuotaUsers) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiskQuotaUsers.VTable, self.vtable).Clone(@ptrCast(*const IEnumDiskQuotaUsers, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaUserBatch_Value = @import("../zig.zig").Guid.initString("7988b576-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaUserBatch = &IID_IDiskQuotaUserBatch_Value;
pub const IDiskQuotaUserBatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const IDiskQuotaUserBatch,
            pUser: *IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IDiskQuotaUserBatch,
            pUser: *IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: fn(
            self: *const IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushToDisk: fn(
            self: *const IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUserBatch_Add(self: *const T, pUser: *IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUserBatch.VTable, self.vtable).Add(@ptrCast(*const IDiskQuotaUserBatch, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUserBatch_Remove(self: *const T, pUser: *IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUserBatch.VTable, self.vtable).Remove(@ptrCast(*const IDiskQuotaUserBatch, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUserBatch_RemoveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUserBatch.VTable, self.vtable).RemoveAll(@ptrCast(*const IDiskQuotaUserBatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaUserBatch_FlushToDisk(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaUserBatch.VTable, self.vtable).FlushToDisk(@ptrCast(*const IDiskQuotaUserBatch, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaControl_Value = @import("../zig.zig").Guid.initString("7988b572-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaControl = &IID_IDiskQuotaControl_Value;
pub const IDiskQuotaControl = extern struct {
    pub const VTable = extern struct {
        base: IConnectionPointContainer.VTable,
        Initialize: fn(
            self: *const IDiskQuotaControl,
            pszPath: [*:0]const u16,
            bReadWrite: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaState: fn(
            self: *const IDiskQuotaControl,
            dwState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaState: fn(
            self: *const IDiskQuotaControl,
            pdwState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuotaLogFlags: fn(
            self: *const IDiskQuotaControl,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuotaLogFlags: fn(
            self: *const IDiskQuotaControl,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultQuotaThreshold: fn(
            self: *const IDiskQuotaControl,
            llThreshold: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaThreshold: fn(
            self: *const IDiskQuotaControl,
            pllThreshold: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaThresholdText: fn(
            self: *const IDiskQuotaControl,
            pszText: PWSTR,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultQuotaLimit: fn(
            self: *const IDiskQuotaControl,
            llLimit: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaLimit: fn(
            self: *const IDiskQuotaControl,
            pllLimit: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultQuotaLimitText: fn(
            self: *const IDiskQuotaControl,
            pszText: PWSTR,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserSid: fn(
            self: *const IDiskQuotaControl,
            pUserSid: PSID,
            fNameResolution: DISKQUOTA_USERNAME_RESOLVE,
            ppUser: **IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserName: fn(
            self: *const IDiskQuotaControl,
            pszLogonName: [*:0]const u16,
            fNameResolution: DISKQUOTA_USERNAME_RESOLVE,
            ppUser: **IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteUser: fn(
            self: *const IDiskQuotaControl,
            pUser: *IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindUserSid: fn(
            self: *const IDiskQuotaControl,
            pUserSid: PSID,
            fNameResolution: DISKQUOTA_USERNAME_RESOLVE,
            ppUser: **IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindUserName: fn(
            self: *const IDiskQuotaControl,
            pszLogonName: [*:0]const u16,
            ppUser: **IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEnumUsers: fn(
            self: *const IDiskQuotaControl,
            rgpUserSids: *PSID,
            cpSids: u32,
            fNameResolution: DISKQUOTA_USERNAME_RESOLVE,
            ppEnum: **IEnumDiskQuotaUsers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUserBatch: fn(
            self: *const IDiskQuotaControl,
            ppBatch: **IDiskQuotaUserBatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateSidNameCache: fn(
            self: *const IDiskQuotaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GiveUserNameResolutionPriority: fn(
            self: *const IDiskQuotaControl,
            pUser: *IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutdownNameResolution: fn(
            self: *const IDiskQuotaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConnectionPointContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_Initialize(self: *const T, pszPath: [*:0]const u16, bReadWrite: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).Initialize(@ptrCast(*const IDiskQuotaControl, self), pszPath, bReadWrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_SetQuotaState(self: *const T, dwState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).SetQuotaState(@ptrCast(*const IDiskQuotaControl, self), dwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetQuotaState(self: *const T, pdwState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetQuotaState(@ptrCast(*const IDiskQuotaControl, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_SetQuotaLogFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).SetQuotaLogFlags(@ptrCast(*const IDiskQuotaControl, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetQuotaLogFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetQuotaLogFlags(@ptrCast(*const IDiskQuotaControl, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_SetDefaultQuotaThreshold(self: *const T, llThreshold: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).SetDefaultQuotaThreshold(@ptrCast(*const IDiskQuotaControl, self), llThreshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetDefaultQuotaThreshold(self: *const T, pllThreshold: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetDefaultQuotaThreshold(@ptrCast(*const IDiskQuotaControl, self), pllThreshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetDefaultQuotaThresholdText(self: *const T, pszText: PWSTR, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetDefaultQuotaThresholdText(@ptrCast(*const IDiskQuotaControl, self), pszText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_SetDefaultQuotaLimit(self: *const T, llLimit: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).SetDefaultQuotaLimit(@ptrCast(*const IDiskQuotaControl, self), llLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetDefaultQuotaLimit(self: *const T, pllLimit: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetDefaultQuotaLimit(@ptrCast(*const IDiskQuotaControl, self), pllLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GetDefaultQuotaLimitText(self: *const T, pszText: PWSTR, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GetDefaultQuotaLimitText(@ptrCast(*const IDiskQuotaControl, self), pszText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_AddUserSid(self: *const T, pUserSid: PSID, fNameResolution: DISKQUOTA_USERNAME_RESOLVE, ppUser: **IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).AddUserSid(@ptrCast(*const IDiskQuotaControl, self), pUserSid, fNameResolution, ppUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_AddUserName(self: *const T, pszLogonName: [*:0]const u16, fNameResolution: DISKQUOTA_USERNAME_RESOLVE, ppUser: **IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).AddUserName(@ptrCast(*const IDiskQuotaControl, self), pszLogonName, fNameResolution, ppUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_DeleteUser(self: *const T, pUser: *IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).DeleteUser(@ptrCast(*const IDiskQuotaControl, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_FindUserSid(self: *const T, pUserSid: PSID, fNameResolution: DISKQUOTA_USERNAME_RESOLVE, ppUser: **IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).FindUserSid(@ptrCast(*const IDiskQuotaControl, self), pUserSid, fNameResolution, ppUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_FindUserName(self: *const T, pszLogonName: [*:0]const u16, ppUser: **IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).FindUserName(@ptrCast(*const IDiskQuotaControl, self), pszLogonName, ppUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_CreateEnumUsers(self: *const T, rgpUserSids: *PSID, cpSids: u32, fNameResolution: DISKQUOTA_USERNAME_RESOLVE, ppEnum: **IEnumDiskQuotaUsers) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).CreateEnumUsers(@ptrCast(*const IDiskQuotaControl, self), rgpUserSids, cpSids, fNameResolution, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_CreateUserBatch(self: *const T, ppBatch: **IDiskQuotaUserBatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).CreateUserBatch(@ptrCast(*const IDiskQuotaControl, self), ppBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_InvalidateSidNameCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).InvalidateSidNameCache(@ptrCast(*const IDiskQuotaControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_GiveUserNameResolutionPriority(self: *const T, pUser: *IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).GiveUserNameResolutionPriority(@ptrCast(*const IDiskQuotaControl, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaControl_ShutdownNameResolution(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaControl.VTable, self.vtable).ShutdownNameResolution(@ptrCast(*const IDiskQuotaControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiskQuotaEvents_Value = @import("../zig.zig").Guid.initString("7988b579-ec89-11cf-9c00-00aa00a14f56");
pub const IID_IDiskQuotaEvents = &IID_IDiskQuotaEvents_Value;
pub const IDiskQuotaEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUserNameChanged: fn(
            self: *const IDiskQuotaEvents,
            pUser: *IDiskQuotaUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiskQuotaEvents_OnUserNameChanged(self: *const T, pUser: *IDiskQuotaUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiskQuotaEvents.VTable, self.vtable).OnUserNameChanged(@ptrCast(*const IDiskQuotaEvents, self), pUser);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EFS_CERTIFICATE_BLOB = extern struct {
    dwCertEncodingType: u32,
    cbData: u32,
    pbData: *u8,
};

pub const EFS_HASH_BLOB = extern struct {
    cbData: u32,
    pbData: *u8,
};

pub const EFS_RPC_BLOB = extern struct {
    cbData: u32,
    pbData: *u8,
};

pub const EFS_PIN_BLOB = extern struct {
    cbPadding: u32,
    cbData: u32,
    pbData: *u8,
};

pub const EFS_KEY_INFO = extern struct {
    dwVersion: u32,
    Entropy: u32,
    Algorithm: u32,
    KeyLength: u32,
};

pub const EFS_COMPATIBILITY_INFO = extern struct {
    EfsVersion: u32,
};

pub const EFS_VERSION_INFO = extern struct {
    EfsVersion: u32,
    SubVersion: u32,
};

pub const EFS_DECRYPTION_STATUS_INFO = extern struct {
    dwDecryptionError: u32,
    dwHashOffset: u32,
    cbHash: u32,
};

pub const EFS_ENCRYPTION_STATUS_INFO = extern struct {
    bHasCurrentKey: BOOL,
    dwEncryptionError: u32,
};

pub const ENCRYPTION_CERTIFICATE = extern struct {
    cbTotalLength: u32,
    pUserSid: *SID,
    pCertBlob: *EFS_CERTIFICATE_BLOB,
};

pub const ENCRYPTION_CERTIFICATE_HASH = extern struct {
    cbTotalLength: u32,
    pUserSid: *SID,
    pHash: *EFS_HASH_BLOB,
    lpDisplayInformation: PWSTR,
};

pub const ENCRYPTION_CERTIFICATE_HASH_LIST = extern struct {
    nCert_Hash: u32,
    pUsers: **ENCRYPTION_CERTIFICATE_HASH,
};

pub const ENCRYPTION_CERTIFICATE_LIST = extern struct {
    nUsers: u32,
    pUsers: **ENCRYPTION_CERTIFICATE,
};

pub const ENCRYPTED_FILE_METADATA_SIGNATURE = extern struct {
    dwEfsAccessType: u32,
    pCertificatesAdded: *ENCRYPTION_CERTIFICATE_HASH_LIST,
    pEncryptionCertificate: *ENCRYPTION_CERTIFICATE,
    pEfsStreamSignature: *EFS_RPC_BLOB,
};

pub const ENCRYPTION_PROTECTOR = extern struct {
    cbTotalLength: u32,
    pUserSid: *SID,
    lpProtectorDescriptor: PWSTR,
};

pub const ENCRYPTION_PROTECTOR_LIST = extern struct {
    nProtectors: u32,
    pProtectors: **ENCRYPTION_PROTECTOR,
};

pub const WofEnumEntryProc = fn(
    EntryInfo: *const c_void,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const WofEnumFilesProc = fn(
    FilePath: [*:0]const u16,
    ExternalFileInfo: *c_void,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const WIM_ENTRY_INFO = extern struct {
    WimEntryInfoSize: u32,
    WimType: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimPath: [*:0]const u16,
    WimIndex: u32,
    Flags: u32,
};

pub const WIM_EXTERNAL_FILE_INFO = extern struct {
    DataSourceId: LARGE_INTEGER,
    ResourceHash: [20]u8,
    Flags: u32,
};

pub const WOF_FILE_COMPRESSION_INFO_V0 = extern struct {
    Algorithm: u32,
};

pub const WOF_FILE_COMPRESSION_INFO_V1 = extern struct {
    Algorithm: u32,
    Flags: u32,
};

pub const TXF_ID = extern struct {
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const TXF_LOG_RECORD_BASE = extern struct {
    Version: u16,
    RecordType: TXF_LOG_RECORD_TYPE,
    RecordLength: u32,
};

pub const TXF_LOG_RECORD_WRITE = extern struct {
    Version: u16,
    RecordType: u16,
    RecordLength: u32,
    Flags: u32,
    TxfFileId: TXF_ID,
    KtmGuid: Guid,
    ByteOffsetInFile: i64,
    NumBytesWritten: u32,
    ByteOffsetInStructure: u32,
    FileNameLength: u32,
    FileNameByteOffsetInStructure: u32,
};

pub const TXF_LOG_RECORD_TRUNCATE = extern struct {
    Version: u16,
    RecordType: u16,
    RecordLength: u32,
    Flags: u32,
    TxfFileId: TXF_ID,
    KtmGuid: Guid,
    NewFileSize: i64,
    FileNameLength: u32,
    FileNameByteOffsetInStructure: u32,
};

pub const TXF_LOG_RECORD_AFFECTED_FILE = extern struct {
    Version: u16,
    RecordLength: u32,
    Flags: u32,
    TxfFileId: TXF_ID,
    KtmGuid: Guid,
    FileNameLength: u32,
    FileNameByteOffsetInStructure: u32,
};

pub const VOLUME_FAILOVER_SET = extern struct {
    NumberOfDisks: u32,
    DiskNumbers: [1]u32,
};

pub const VOLUME_NUMBER = extern struct {
    VolumeNumber: u32,
    VolumeManagerName: [8]u16,
};

pub const VOLUME_LOGICAL_OFFSET = extern struct {
    LogicalOffset: i64,
};

pub const VOLUME_PHYSICAL_OFFSET = extern struct {
    DiskNumber: u32,
    Offset: i64,
};

pub const VOLUME_PHYSICAL_OFFSETS = extern struct {
    NumberOfPhysicalOffsets: u32,
    PhysicalOffset: [1]VOLUME_PHYSICAL_OFFSET,
};

pub const VOLUME_READ_PLEX_INPUT = extern struct {
    ByteOffset: LARGE_INTEGER,
    Length: u32,
    PlexNumber: u32,
};

pub const VOLUME_SET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: u64,
    RevertOnClose: u8,
    ApplyToAllConnectedVolumes: u8,
    Reserved1: u16,
    Reserved2: u32,
};

pub const VOLUME_GET_BC_PROPERTIES_INPUT = extern struct {
    Version: u32,
    Reserved1: u32,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};

pub const VOLUME_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};

pub const VOLUME_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: u8,
    Discardable: u8,
    Reserved1: [2]u8,
    LowestByteOffset: u64,
    HighestByteOffset: u64,
    AccessType: u32,
    AccessMode: u32,
};

pub const VOLUME_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};

pub const FILE_EXTENT = extern struct {
    VolumeOffset: u64,
    ExtentLength: u64,
};

pub const VOLUME_CRITICAL_IO = extern struct {
    AccessType: u32,
    ExtentsCount: u32,
    Extents: [1]FILE_EXTENT,
};

pub const VOLUME_ALLOCATION_HINT_INPUT = extern struct {
    ClusterSize: u32,
    NumberOfClusters: u32,
    StartingClusterNumber: i64,
};

pub const VOLUME_ALLOCATION_HINT_OUTPUT = extern struct {
    Bitmap: [1]u32,
};

pub const VOLUME_SHRINK_INFO = extern struct {
    VolumeSize: u64,
};

pub const SHARE_INFO_0 = extern struct {
    shi0_netname: PWSTR,
};

pub const SHARE_INFO_1 = extern struct {
    shi1_netname: PWSTR,
    shi1_type: SHARE_TYPE,
    shi1_remark: PWSTR,
};

pub const SHARE_INFO_2 = extern struct {
    shi2_netname: PWSTR,
    shi2_type: SHARE_TYPE,
    shi2_remark: PWSTR,
    shi2_permissions: SHARE_INFO_PERMISSIONS,
    shi2_max_uses: u32,
    shi2_current_uses: u32,
    shi2_path: PWSTR,
    shi2_passwd: PWSTR,
};

pub const SHARE_INFO_501 = extern struct {
    shi501_netname: PWSTR,
    shi501_type: SHARE_TYPE,
    shi501_remark: PWSTR,
    shi501_flags: u32,
};

pub const SHARE_INFO_502 = extern struct {
    shi502_netname: PWSTR,
    shi502_type: SHARE_TYPE,
    shi502_remark: PWSTR,
    shi502_permissions: SHARE_INFO_PERMISSIONS,
    shi502_max_uses: u32,
    shi502_current_uses: u32,
    shi502_path: PWSTR,
    shi502_passwd: PWSTR,
    shi502_reserved: u32,
    shi502_security_descriptor: *SECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_503 = extern struct {
    shi503_netname: PWSTR,
    shi503_type: SHARE_TYPE,
    shi503_remark: PWSTR,
    shi503_permissions: SHARE_INFO_PERMISSIONS,
    shi503_max_uses: u32,
    shi503_current_uses: u32,
    shi503_path: PWSTR,
    shi503_passwd: PWSTR,
    shi503_servername: PWSTR,
    shi503_reserved: u32,
    shi503_security_descriptor: *SECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_1004 = extern struct {
    shi1004_remark: PWSTR,
};

pub const SHARE_INFO_1005 = extern struct {
    shi1005_flags: u32,
};

pub const SHARE_INFO_1006 = extern struct {
    shi1006_max_uses: u32,
};

pub const SHARE_INFO_1501 = extern struct {
    shi1501_reserved: u32,
    shi1501_security_descriptor: *SECURITY_DESCRIPTOR,
};

pub const SHARE_INFO_1503 = extern struct {
    shi1503_sharefilter: Guid,
};

pub const SERVER_ALIAS_INFO_0 = extern struct {
    srvai0_alias: PWSTR,
    srvai0_target: PWSTR,
    srvai0_default: u8,
    srvai0_reserved: u32,
};

pub const SESSION_INFO_0 = extern struct {
    sesi0_cname: PWSTR,
};

pub const SESSION_INFO_1 = extern struct {
    sesi1_cname: PWSTR,
    sesi1_username: PWSTR,
    sesi1_num_opens: u32,
    sesi1_time: u32,
    sesi1_idle_time: u32,
    sesi1_user_flags: SESSION_INFO_USER_FLAGS,
};

pub const SESSION_INFO_2 = extern struct {
    sesi2_cname: PWSTR,
    sesi2_username: PWSTR,
    sesi2_num_opens: u32,
    sesi2_time: u32,
    sesi2_idle_time: u32,
    sesi2_user_flags: SESSION_INFO_USER_FLAGS,
    sesi2_cltype_name: PWSTR,
};

pub const SESSION_INFO_10 = extern struct {
    sesi10_cname: PWSTR,
    sesi10_username: PWSTR,
    sesi10_time: u32,
    sesi10_idle_time: u32,
};

pub const SESSION_INFO_502 = extern struct {
    sesi502_cname: PWSTR,
    sesi502_username: PWSTR,
    sesi502_num_opens: u32,
    sesi502_time: u32,
    sesi502_idle_time: u32,
    sesi502_user_flags: SESSION_INFO_USER_FLAGS,
    sesi502_cltype_name: PWSTR,
    sesi502_transport: PWSTR,
};

pub const CONNECTION_INFO_0 = extern struct {
    coni0_id: u32,
};

pub const CONNECTION_INFO_1 = extern struct {
    coni1_id: u32,
    coni1_type: SHARE_TYPE,
    coni1_num_opens: u32,
    coni1_num_users: u32,
    coni1_time: u32,
    coni1_username: PWSTR,
    coni1_netname: PWSTR,
};

pub const FILE_INFO_2 = extern struct {
    fi2_id: u32,
};

pub const FILE_INFO_3 = extern struct {
    fi3_id: u32,
    fi3_permissions: FILE_INFO_FLAGS_PERMISSIONS,
    fi3_num_locks: u32,
    fi3_pathname: PWSTR,
    fi3_username: PWSTR,
};

pub const SERVER_CERTIFICATE_TYPE = extern enum(i32) {
    C = 0,
};
pub const QUIC = SERVER_CERTIFICATE_TYPE.C;

pub const SERVER_CERTIFICATE_INFO_0 = extern struct {
    srvci0_name: PWSTR,
    srvci0_subject: PWSTR,
    srvci0_issuer: PWSTR,
    srvci0_thumbprint: PWSTR,
    srvci0_friendlyname: PWSTR,
    srvci0_notbefore: PWSTR,
    srvci0_notafter: PWSTR,
    srvci0_storelocation: PWSTR,
    srvci0_storename: PWSTR,
    srvci0_type: u32,
};

pub const STAT_WORKSTATION_0 = extern struct {
    StatisticsStartTime: LARGE_INTEGER,
    BytesReceived: LARGE_INTEGER,
    SmbsReceived: LARGE_INTEGER,
    PagingReadBytesRequested: LARGE_INTEGER,
    NonPagingReadBytesRequested: LARGE_INTEGER,
    CacheReadBytesRequested: LARGE_INTEGER,
    NetworkReadBytesRequested: LARGE_INTEGER,
    BytesTransmitted: LARGE_INTEGER,
    SmbsTransmitted: LARGE_INTEGER,
    PagingWriteBytesRequested: LARGE_INTEGER,
    NonPagingWriteBytesRequested: LARGE_INTEGER,
    CacheWriteBytesRequested: LARGE_INTEGER,
    NetworkWriteBytesRequested: LARGE_INTEGER,
    InitiallyFailedOperations: u32,
    FailedCompletionOperations: u32,
    ReadOperations: u32,
    RandomReadOperations: u32,
    ReadSmbs: u32,
    LargeReadSmbs: u32,
    SmallReadSmbs: u32,
    WriteOperations: u32,
    RandomWriteOperations: u32,
    WriteSmbs: u32,
    LargeWriteSmbs: u32,
    SmallWriteSmbs: u32,
    RawReadsDenied: u32,
    RawWritesDenied: u32,
    NetworkErrors: u32,
    Sessions: u32,
    FailedSessions: u32,
    Reconnects: u32,
    CoreConnects: u32,
    Lanman20Connects: u32,
    Lanman21Connects: u32,
    LanmanNtConnects: u32,
    ServerDisconnects: u32,
    HungSessions: u32,
    UseCount: u32,
    FailedUseCount: u32,
    CurrentCommands: u32,
};

pub const STAT_SERVER_0 = extern struct {
    sts0_start: u32,
    sts0_fopens: u32,
    sts0_devopens: u32,
    sts0_jobsqueued: u32,
    sts0_sopens: u32,
    sts0_stimedout: u32,
    sts0_serrorout: u32,
    sts0_pwerrors: u32,
    sts0_permerrors: u32,
    sts0_syserrors: u32,
    sts0_bytessent_low: u32,
    sts0_bytessent_high: u32,
    sts0_bytesrcvd_low: u32,
    sts0_bytesrcvd_high: u32,
    sts0_avresponse: u32,
    sts0_reqbufneed: u32,
    sts0_bigbufneed: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (371)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SearchPathW(
    lpPath: ?[*:0]const u16,
    lpFileName: [*:0]const u16,
    lpExtension: ?[*:0]const u16,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
    lpFilePart: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SearchPathA(
    lpPath: ?[*:0]const u8,
    lpFileName: [*:0]const u8,
    lpExtension: ?[*:0]const u8,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
    lpFilePart: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetBinaryTypeA(
    lpApplicationName: [*:0]const u8,
    lpBinaryType: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetBinaryTypeW(
    lpApplicationName: [*:0]const u16,
    lpBinaryType: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetShortPathNameA(
    lpszLongPath: [*:0]const u8,
    lpszShortPath: ?[*:0]u8,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLongPathNameTransactedA(
    lpszShortPath: [*:0]const u8,
    lpszLongPath: ?[*:0]u8,
    cchBuffer: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLongPathNameTransactedW(
    lpszShortPath: [*:0]const u16,
    lpszLongPath: ?[*:0]u16,
    cchBuffer: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileCompletionNotificationModes(
    FileHandle: HANDLE,
    Flags: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileShortNameA(
    hFile: HANDLE,
    lpShortName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileShortNameW(
    hFile: HANDLE,
    lpShortName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EncryptFileA(
    lpFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EncryptFileW(
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DecryptFileA(
    lpFileName: [*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DecryptFileW(
    lpFileName: [*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FileEncryptionStatusA(
    lpFileName: [*:0]const u8,
    lpStatus: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FileEncryptionStatusW(
    lpFileName: [*:0]const u16,
    lpStatus: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenEncryptedFileRawA(
    lpFileName: [*:0]const u8,
    ulFlags: u32,
    pvContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenEncryptedFileRawW(
    lpFileName: [*:0]const u16,
    ulFlags: u32,
    pvContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ReadEncryptedFileRaw(
    pfExportCallback: PFE_EXPORT_FUNC,
    pvCallbackContext: ?*c_void,
    pvContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn WriteEncryptedFileRaw(
    pfImportCallback: PFE_IMPORT_FUNC,
    pvCallbackContext: ?*c_void,
    pvContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CloseEncryptedFileRaw(
    pvContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenFile(
    lpFileName: [*:0]const u8,
    lpReOpenBuff: *OFSTRUCT,
    uStyle: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLogicalDriveStringsA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64EnableWow64FsRedirection(
    Wow64FsEnableRedirection: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetSearchPathMode(
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateDirectoryExA(
    lpTemplateDirectory: [*:0]const u8,
    lpNewDirectory: [*:0]const u8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateDirectoryExW(
    lpTemplateDirectory: [*:0]const u16,
    lpNewDirectory: [*:0]const u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateDirectoryTransactedA(
    lpTemplateDirectory: ?[*:0]const u8,
    lpNewDirectory: [*:0]const u8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateDirectoryTransactedW(
    lpTemplateDirectory: ?[*:0]const u16,
    lpNewDirectory: [*:0]const u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn RemoveDirectoryTransactedA(
    lpPathName: [*:0]const u8,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn RemoveDirectoryTransactedW(
    lpPathName: [*:0]const u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFullPathNameTransactedA(
    lpFileName: [*:0]const u8,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
    lpFilePart: ?*?PSTR,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFullPathNameTransactedW(
    lpFileName: [*:0]const u16,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
    lpFilePart: ?*?PWSTR,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DefineDosDeviceA(
    dwFlags: DEFINE_DOS_DEVICE_FLAGS,
    lpDeviceName: [*:0]const u8,
    lpTargetPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryDosDeviceA(
    lpDeviceName: ?[*:0]const u8,
    lpTargetPath: ?[*:0]u8,
    ucchMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateFileTransactedA(
    lpFileName: [*:0]const u8,
    dwDesiredAccess: u32,
    dwShareMode: FILE_SHARE_MODE,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATION_DISPOSITION,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
    hTransaction: HANDLE,
    pusMiniVersion: ?*TXFS_MINIVERSION,
    lpExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateFileTransactedW(
    lpFileName: [*:0]const u16,
    dwDesiredAccess: u32,
    dwShareMode: FILE_SHARE_MODE,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATION_DISPOSITION,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
    hTransaction: HANDLE,
    pusMiniVersion: ?*TXFS_MINIVERSION,
    lpExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ReOpenFile(
    hOriginalFile: HANDLE,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileAttributesTransactedA(
    lpFileName: [*:0]const u8,
    dwFileAttributes: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileAttributesTransactedW(
    lpFileName: [*:0]const u16,
    dwFileAttributes: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileAttributesTransactedA(
    lpFileName: [*:0]const u8,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: *c_void,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileAttributesTransactedW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: *c_void,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetCompressedFileSizeTransactedA(
    lpFileName: [*:0]const u8,
    lpFileSizeHigh: ?*u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetCompressedFileSizeTransactedW(
    lpFileName: [*:0]const u16,
    lpFileSizeHigh: ?*u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn DeleteFileTransactedA(
    lpFileName: [*:0]const u8,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn DeleteFileTransactedW(
    lpFileName: [*:0]const u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CheckNameLegalDOS8Dot3A(
    lpName: [*:0]const u8,
    lpOemName: ?[*:0]u8,
    OemNameSize: u32,
    pbNameContainsSpaces: ?*BOOL,
    pbNameLegal: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CheckNameLegalDOS8Dot3W(
    lpName: [*:0]const u16,
    lpOemName: ?[*:0]u8,
    OemNameSize: u32,
    pbNameContainsSpaces: ?*BOOL,
    pbNameLegal: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstFileTransactedA(
    lpFileName: [*:0]const u8,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: *c_void,
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: *c_void,
    dwAdditionalFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstFileTransactedW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: *c_void,
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: *c_void,
    dwAdditionalFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CopyFileA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: [*:0]const u8,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CopyFileW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CopyFileExA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: [*:0]const u8,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    pbCancel: ?*i32,
    dwCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CopyFileExW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    pbCancel: ?*i32,
    dwCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CopyFileTransactedA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: [*:0]const u8,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    pbCancel: ?*i32,
    dwCopyFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CopyFileTransactedW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    pbCancel: ?*i32,
    dwCopyFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CopyFile2(
    pwszExistingFileName: [*:0]const u16,
    pwszNewFileName: [*:0]const u16,
    pExtendedParameters: ?*COPYFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileExA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: ?[*:0]const u8,
    dwFlags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileExW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: ?[*:0]const u16,
    dwFlags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileWithProgressA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: ?[*:0]const u8,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    dwFlags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MoveFileWithProgressW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: ?[*:0]const u16,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    dwFlags: MOVE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn MoveFileTransactedA(
    lpExistingFileName: [*:0]const u8,
    lpNewFileName: ?[*:0]const u8,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    dwFlags: MOVE_FILE_FLAGS,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn MoveFileTransactedW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: ?[*:0]const u16,
    lpProgressRoutine: ?LPPROGRESS_ROUTINE,
    lpData: ?*c_void,
    dwFlags: MOVE_FILE_FLAGS,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReplaceFileA(
    lpReplacedFileName: [*:0]const u8,
    lpReplacementFileName: [*:0]const u8,
    lpBackupFileName: ?[*:0]const u8,
    dwReplaceFlags: REPLACE_FILE_FLAGS,
    lpExclude: *c_void,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReplaceFileW(
    lpReplacedFileName: [*:0]const u16,
    lpReplacementFileName: [*:0]const u16,
    lpBackupFileName: ?[*:0]const u16,
    dwReplaceFlags: REPLACE_FILE_FLAGS,
    lpExclude: *c_void,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateHardLinkA(
    lpFileName: [*:0]const u8,
    lpExistingFileName: [*:0]const u8,
    lpSecurityAttributes: *SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateHardLinkW(
    lpFileName: [*:0]const u16,
    lpExistingFileName: [*:0]const u16,
    lpSecurityAttributes: *SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateHardLinkTransactedA(
    lpFileName: [*:0]const u8,
    lpExistingFileName: [*:0]const u8,
    lpSecurityAttributes: *SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateHardLinkTransactedW(
    lpFileName: [*:0]const u16,
    lpExistingFileName: [*:0]const u16,
    lpSecurityAttributes: *SECURITY_ATTRIBUTES,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstStreamTransactedW(
    lpFileName: [*:0]const u16,
    InfoLevel: STREAM_INFO_LEVELS,
    lpFindStreamData: *c_void,
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstFileNameTransactedW(
    lpFileName: [*:0]const u16,
    dwFlags: u32,
    StringLength: *u32,
    LinkName: [*:0]u16,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetVolumeLabelA(
    lpRootPathName: ?[*:0]const u8,
    lpVolumeName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetVolumeLabelW(
    lpRootPathName: ?[*:0]const u16,
    lpVolumeName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileBandwidthReservation(
    hFile: HANDLE,
    nPeriodMilliseconds: u32,
    nBytesPerPeriod: u32,
    bDiscardable: BOOL,
    lpTransferSize: *u32,
    lpNumOutstandingRequests: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileBandwidthReservation(
    hFile: HANDLE,
    lpPeriodMilliseconds: *u32,
    lpBytesPerPeriod: *u32,
    pDiscardable: *i32,
    lpTransferSize: *u32,
    lpNumOutstandingRequests: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReadDirectoryChangesW(
    hDirectory: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    nBufferLength: u32,
    bWatchSubtree: BOOL,
    dwNotifyFilter: FILE_NOTIFY_CHANGE,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "KERNEL32" fn ReadDirectoryChangesExW(
    hDirectory: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    nBufferLength: u32,
    bWatchSubtree: BOOL,
    dwNotifyFilter: FILE_NOTIFY_CHANGE,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPOVERLAPPED_COMPLETION_ROUTINE,
    ReadDirectoryNotifyInformationClass: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstVolumeA(
    lpszVolumeName: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextVolumeA(
    hFindVolume: FindVolumeHandle,
    lpszVolumeName: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstVolumeMountPointA(
    lpszRootPathName: [*:0]const u8,
    lpszVolumeMountPoint: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstVolumeMountPointW(
    lpszRootPathName: [*:0]const u16,
    lpszVolumeMountPoint: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeMointPointHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextVolumeMountPointA(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
    lpszVolumeMountPoint: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextVolumeMountPointW(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
    lpszVolumeMountPoint: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindVolumeMountPointClose(
    hFindVolumeMountPoint: FindVolumeMointPointHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetVolumeMountPointA(
    lpszVolumeMountPoint: [*:0]const u8,
    lpszVolumeName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetVolumeMountPointW(
    lpszVolumeMountPoint: [*:0]const u16,
    lpszVolumeName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteVolumeMountPointA(
    lpszVolumeMountPoint: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumeNameForVolumeMountPointA(
    lpszVolumeMountPoint: [*:0]const u8,
    lpszVolumeName: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumePathNameA(
    lpszFileName: [*:0]const u8,
    lpszVolumePathName: [*:0]u8,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumePathNamesForVolumeNameA(
    lpszVolumeName: [*:0]const u8,
    lpszVolumePathNames: ?[*]u8,
    cchBufferLength: u32,
    lpcchReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFileInformationByHandleEx(
    hFile: HANDLE,
    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpFileInformation: *c_void,
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn OpenFileById(
    hVolumeHint: HANDLE,
    lpFileId: *FILE_ID_DESCRIPTOR,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSymbolicLinkA(
    lpSymlinkFileName: [*:0]const u8,
    lpTargetFileName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSymbolicLinkW(
    lpSymlinkFileName: [*:0]const u16,
    lpTargetFileName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSymbolicLinkTransactedA(
    lpSymlinkFileName: [*:0]const u8,
    lpTargetFileName: [*:0]const u8,
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSymbolicLinkTransactedW(
    lpSymlinkFileName: [*:0]const u16,
    lpTargetFileName: [*:0]const u16,
    dwFlags: u32,
    hTransaction: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateDirectoryA(
    lpPathName: [*:0]const u8,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateDirectoryW(
    lpPathName: [*:0]const u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFileA(
    lpFileName: [*:0]const u8,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATION_DISPOSITION,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFileW(
    lpFileName: [*:0]const u16,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: FILE_CREATION_DISPOSITION,
    dwFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DefineDosDeviceW(
    dwFlags: DEFINE_DOS_DEVICE_FLAGS,
    lpDeviceName: [*:0]const u16,
    lpTargetPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteFileA(
    lpFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteFileW(
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteVolumeMountPointW(
    lpszVolumeMountPoint: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindClose(
    hFindFile: FindFileHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindCloseChangeNotification(
    hChangeHandle: FindChangeNotificationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstChangeNotificationA(
    lpPathName: [*:0]const u8,
    bWatchSubtree: BOOL,
    dwNotifyFilter: FILE_NOTIFY_CHANGE,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstChangeNotificationW(
    lpPathName: [*:0]const u16,
    bWatchSubtree: BOOL,
    dwNotifyFilter: FILE_NOTIFY_CHANGE,
) callconv(@import("std").os.windows.WINAPI) FindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstFileA(
    lpFileName: [*:0]const u8,
    lpFindFileData: *WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstFileW(
    lpFileName: [*:0]const u16,
    lpFindFileData: *WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstFileExA(
    lpFileName: [*:0]const u8,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: *c_void,
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: *c_void,
    dwAdditionalFlags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstFileExW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: *c_void,
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: *c_void,
    dwAdditionalFlags: FIND_FIRST_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) FindFileHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindFirstVolumeW(
    lpszVolumeName: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) FindVolumeHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextChangeNotification(
    hChangeHandle: FindChangeNotificationHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextFileA(
    hFindFile: FindFileHandle,
    lpFindFileData: *WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextFileW(
    hFindFile: HANDLE,
    lpFindFileData: *WIN32_FIND_DATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindNextVolumeW(
    hFindVolume: FindVolumeHandle,
    lpszVolumeName: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindVolumeClose(
    hFindVolume: FindVolumeHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FlushFileBuffers(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDiskFreeSpaceA(
    lpRootPathName: ?[*:0]const u8,
    lpSectorsPerCluster: ?*u32,
    lpBytesPerSector: ?*u32,
    lpNumberOfFreeClusters: ?*u32,
    lpTotalNumberOfClusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDiskFreeSpaceW(
    lpRootPathName: ?[*:0]const u16,
    lpSectorsPerCluster: ?*u32,
    lpBytesPerSector: ?*u32,
    lpNumberOfFreeClusters: ?*u32,
    lpTotalNumberOfClusters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDiskFreeSpaceExA(
    lpDirectoryName: ?[*:0]const u8,
    lpFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    lpTotalNumberOfBytes: ?*ULARGE_INTEGER,
    lpTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDiskFreeSpaceExW(
    lpDirectoryName: ?[*:0]const u16,
    lpFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    lpTotalNumberOfBytes: ?*ULARGE_INTEGER,
    lpTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDiskSpaceInformationA(
    rootPath: ?[*:0]const u8,
    diskSpaceInfo: *DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GetDiskSpaceInformationW(
    rootPath: ?[*:0]const u16,
    diskSpaceInfo: *DISK_SPACE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDriveTypeA(
    lpRootPathName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDriveTypeW(
    lpRootPathName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileAttributesA(
    lpFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileAttributesW(
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileAttributesExA(
    lpFileName: [*:0]const u8,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileAttributesExW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileInformationByHandle(
    hFile: HANDLE,
    lpFileInformation: *BY_HANDLE_FILE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileSize(
    hFile: HANDLE,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileSizeEx(
    hFile: HANDLE,
    lpFileSize: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFileType(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFinalPathNameByHandleA(
    hFile: HANDLE,
    lpszFilePath: [*:0]u8,
    cchFilePath: u32,
    dwFlags: FILE_NAME,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetFinalPathNameByHandleW(
    hFile: HANDLE,
    lpszFilePath: [*:0]u16,
    cchFilePath: u32,
    dwFlags: FILE_NAME,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFullPathNameW(
    lpFileName: [*:0]const u16,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
    lpFilePart: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetFullPathNameA(
    lpFileName: [*:0]const u8,
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
    lpFilePart: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLogicalDrives(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLogicalDriveStringsW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLongPathNameA(
    lpszShortPath: [*:0]const u8,
    lpszLongPath: ?[*:0]u8,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLongPathNameW(
    lpszShortPath: [*:0]const u16,
    lpszLongPath: ?[*:0]u16,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetShortPathNameW(
    lpszLongPath: [*:0]const u16,
    lpszShortPath: ?[*:0]u16,
    cchBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTempFileNameW(
    lpPathName: [*:0]const u16,
    lpPrefixString: [*:0]const u16,
    uUnique: u32,
    lpTempFileName: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetVolumeInformationByHandleW(
    hFile: HANDLE,
    lpVolumeNameBuffer: ?[*:0]u16,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?[*:0]u16,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumeInformationW(
    lpRootPathName: ?[*:0]const u16,
    lpVolumeNameBuffer: ?[*:0]u16,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?[*:0]u16,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumePathNameW(
    lpszFileName: [*:0]const u16,
    lpszVolumePathName: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LockFile(
    hFile: HANDLE,
    dwFileOffsetLow: u32,
    dwFileOffsetHigh: u32,
    nNumberOfBytesToLockLow: u32,
    nNumberOfBytesToLockHigh: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LockFileEx(
    hFile: HANDLE,
    dwFlags: LOCK_FILE_FLAGS,
    dwReserved: u32,
    nNumberOfBytesToLockLow: u32,
    nNumberOfBytesToLockHigh: u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryDosDeviceW(
    lpDeviceName: ?[*:0]const u16,
    lpTargetPath: ?[*:0]u16,
    ucchMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReadFile(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*c_void,
    nNumberOfBytesToRead: u32,
    lpNumberOfBytesRead: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReadFileEx(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*c_void,
    nNumberOfBytesToRead: u32,
    lpOverlapped: *OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReadFileScatter(
    hFile: HANDLE,
    aSegmentArray: *FILE_SEGMENT_ELEMENT,
    nNumberOfBytesToRead: u32,
    lpReserved: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RemoveDirectoryA(
    lpPathName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RemoveDirectoryW(
    lpPathName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetEndOfFile(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileAttributesA(
    lpFileName: [*:0]const u8,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileAttributesW(
    lpFileName: [*:0]const u16,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileInformationByHandle(
    hFile: HANDLE,
    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpFileInformation: *c_void,
    dwBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFilePointer(
    hFile: HANDLE,
    lDistanceToMove: i32,
    lpDistanceToMoveHigh: ?*i32,
    dwMoveMethod: SET_FILE_POINTER_MOVE_METHOD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFilePointerEx(
    hFile: HANDLE,
    liDistanceToMove: LARGE_INTEGER,
    lpNewFilePointer: ?*LARGE_INTEGER,
    dwMoveMethod: SET_FILE_POINTER_MOVE_METHOD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileValidData(
    hFile: HANDLE,
    ValidDataLength: i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnlockFile(
    hFile: HANDLE,
    dwFileOffsetLow: u32,
    dwFileOffsetHigh: u32,
    nNumberOfBytesToUnlockLow: u32,
    nNumberOfBytesToUnlockHigh: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnlockFileEx(
    hFile: HANDLE,
    dwReserved: u32,
    nNumberOfBytesToUnlockLow: u32,
    nNumberOfBytesToUnlockHigh: u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WriteFile(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*const c_void,
    nNumberOfBytesToWrite: u32,
    lpNumberOfBytesWritten: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WriteFileEx(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*const c_void,
    nNumberOfBytesToWrite: u32,
    lpOverlapped: *OVERLAPPED,
    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WriteFileGather(
    hFile: HANDLE,
    aSegmentArray: *FILE_SEGMENT_ELEMENT,
    nNumberOfBytesToWrite: u32,
    lpReserved: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTempPathW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumeNameForVolumeMountPointW(
    lpszVolumeMountPoint: [*:0]const u16,
    lpszVolumeName: [*:0]u16,
    cchBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumePathNamesForVolumeNameW(
    lpszVolumeName: [*:0]const u16,
    lpszVolumePathNames: ?[*]u16,
    cchBufferLength: u32,
    lpcchReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CreateFile2(
    lpFileName: [*:0]const u16,
    dwDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    dwCreationDisposition: FILE_CREATION_DISPOSITION,
    pCreateExParams: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetFileIoOverlappedRange(
    FileHandle: HANDLE,
    OverlappedRangeStart: *u8,
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCompressedFileSizeA(
    lpFileName: [*:0]const u8,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCompressedFileSizeW(
    lpFileName: [*:0]const u16,
    lpFileSizeHigh: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstStreamW(
    lpFileName: [*:0]const u16,
    InfoLevel: STREAM_INFO_LEVELS,
    lpFindStreamData: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) FindStreamHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindNextStreamW(
    hFindStream: FindStreamHandle,
    lpFindStreamData: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AreFileApisANSI(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTempPathA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindFirstFileNameW(
    lpFileName: [*:0]const u16,
    dwFlags: u32,
    StringLength: *u32,
    LinkName: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) FindFileNameHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FindNextFileNameW(
    hFindStream: FindFileNameHandle,
    StringLength: *u32,
    LinkName: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetVolumeInformationA(
    lpRootPathName: ?[*:0]const u8,
    lpVolumeNameBuffer: ?[*:0]u8,
    nVolumeNameSize: u32,
    lpVolumeSerialNumber: ?*u32,
    lpMaximumComponentLength: ?*u32,
    lpFileSystemFlags: ?*u32,
    lpFileSystemNameBuffer: ?[*:0]u8,
    nFileSystemNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTempFileNameA(
    lpPathName: [*:0]const u8,
    lpPrefixString: [*:0]const u8,
    uUnique: u32,
    lpTempFileName: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileApisToOEM(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetFileApisToANSI(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CopyFileFromAppW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
    bFailIfExists: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateDirectoryFromAppW(
    lpPathName: [*:0]const u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFileFromAppW(
    lpFileName: [*:0]const u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: u32,
    dwFlagsAndAttributes: u32,
    hTemplateFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn CreateFile2FromAppW(
    lpFileName: [*:0]const u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    dwCreationDisposition: u32,
    pCreateExParams: ?*CREATEFILE2_EXTENDED_PARAMETERS,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn DeleteFileFromAppW(
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn FindFirstFileExFromAppW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: FINDEX_INFO_LEVELS,
    lpFindFileData: *c_void,
    fSearchOp: FINDEX_SEARCH_OPS,
    lpSearchFilter: *c_void,
    dwAdditionalFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn GetFileAttributesExFromAppW(
    lpFileName: [*:0]const u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn MoveFileFromAppW(
    lpExistingFileName: [*:0]const u16,
    lpNewFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn RemoveDirectoryFromAppW(
    lpPathName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn ReplaceFileFromAppW(
    lpReplacedFileName: [*:0]const u16,
    lpReplacementFileName: [*:0]const u16,
    lpBackupFileName: ?[*:0]const u16,
    dwReplaceFlags: u32,
    lpExclude: *c_void,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-file-fromapp-l1-1-0" fn SetFileAttributesFromAppW(
    lpFileName: [*:0]const u16,
    dwFileAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateIoCompletionPort(
    FileHandle: HANDLE,
    ExistingCompletionPort: HANDLE,
    CompletionKey: usize,
    NumberOfConcurrentThreads: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetQueuedCompletionStatus(
    CompletionPort: HANDLE,
    lpNumberOfBytesTransferred: *u32,
    lpCompletionKey: *usize,
    lpOverlapped: **OVERLAPPED,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetQueuedCompletionStatusEx(
    CompletionPort: HANDLE,
    lpCompletionPortEntries: [*]OVERLAPPED_ENTRY,
    ulCount: u32,
    ulNumEntriesRemoved: *u32,
    dwMilliseconds: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn PostQueuedCompletionStatus(
    CompletionPort: HANDLE,
    dwNumberOfBytesTransferred: u32,
    dwCompletionKey: usize,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CancelIoEx(
    hFile: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CancelIo(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CancelSynchronousIo(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64DisableWow64FsRedirection(
    OldValue: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64RevertWow64FsRedirection(
    OlValue: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-wow64-l1-1-1" fn Wow64SetThreadDefaultGuestMachine(
    Machine: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64SuspendThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "clfsw32" fn LsnEqual(
    plsn1: *const CLS_LSN,
    plsn2: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "clfsw32" fn LsnLess(
    plsn1: *const CLS_LSN,
    plsn2: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "clfsw32" fn LsnGreater(
    plsn1: *const CLS_LSN,
    plsn2: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "clfsw32" fn LsnNull(
    plsn: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnContainer(
    plsn: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnCreate(
    cidContainer: u32,
    offBlock: u32,
    cRecord: u32,
) callconv(@import("std").os.windows.WINAPI) CLS_LSN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnBlockOffset(
    plsn: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LsnRecordSequence(
    plsn: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "clfsw32" fn LsnInvalid(
    plsn: *const CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "clfsw32" fn LsnIncrement(
    plsn: *CLS_LSN,
) callconv(@import("std").os.windows.WINAPI) CLS_LSN;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogFile(
    pszLogFileName: [*:0]const u16,
    fDesiredAccess: FILE_ACCESS_FLAGS,
    dwShareMode: FILE_SHARE_MODE,
    psaLogFile: *SECURITY_ATTRIBUTES,
    fCreateDisposition: FILE_CREATION_DISPOSITION,
    fFlagsAndAttributes: FILE_FLAGS_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogByHandle(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogFile(
    pszLogFileName: [*:0]const u16,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AddLogContainer(
    hLog: HANDLE,
    pcbContainer: ?*u64,
    pwszContainerPath: PWSTR,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AddLogContainerSet(
    hLog: HANDLE,
    cContainer: u16,
    pcbContainer: ?*u64,
    rgwszContainerPath: [*]PWSTR,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogContainer(
    hLog: HANDLE,
    pwszContainerPath: PWSTR,
    fForce: BOOL,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogContainerSet(
    hLog: HANDLE,
    cContainer: u16,
    rgwszContainerPath: [*]PWSTR,
    fForce: BOOL,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogArchiveTail(
    hLog: HANDLE,
    plsnArchiveTail: *CLS_LSN,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetEndOfLog(
    hLog: HANDLE,
    plsnEnd: *CLS_LSN,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TruncateLog(
    pvMarshal: *c_void,
    plsnEnd: *CLS_LSN,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogContainerScanContext(
    hLog: HANDLE,
    cFromContainer: u32,
    cContainers: u32,
    eScanMode: u8,
    pcxScan: *CLS_SCAN_CONTEXT,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ScanLogContainers(
    pcxScan: *CLS_SCAN_CONTEXT,
    eScanMode: u8,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AlignReservedLog(
    pvMarshal: *c_void,
    cReservedRecords: u32,
    rgcbReservation: *i64,
    pcbAlignReservation: *i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AllocReservedLog(
    pvMarshal: *c_void,
    cReservedRecords: u32,
    pcbAdjustment: *i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FreeReservedLog(
    pvMarshal: *c_void,
    cReservedRecords: u32,
    pcbAdjustment: *i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogFileInformation(
    hLog: HANDLE,
    pinfoBuffer: *CLS_INFORMATION,
    cbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogArchiveMode(
    hLog: HANDLE,
    eMode: CLFS_LOG_ARCHIVE_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogRestartArea(
    pvMarshal: *c_void,
    ppvRestartBuffer: **c_void,
    pcbRestartBuffer: *u32,
    plsn: *CLS_LSN,
    ppvContext: **c_void,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadPreviousLogRestartArea(
    pvReadContext: *c_void,
    ppvRestartBuffer: **c_void,
    pcbRestartBuffer: *u32,
    plsnRestart: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn WriteLogRestartArea(
    pvMarshal: *c_void,
    pvRestartBuffer: *c_void,
    cbRestartBuffer: u32,
    plsnBase: *CLS_LSN,
    fFlags: CLFS_FLAG,
    pcbWritten: *u32,
    plsnNext: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "clfsw32" fn GetLogReservationInfo(
    pvMarshal: *c_void,
    pcbRecordNumber: *u32,
    pcbUserReservation: *i64,
    pcbCommitReservation: *i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn AdvanceLogBase(
    pvMarshal: *c_void,
    plsnBase: *CLS_LSN,
    fFlags: u32,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CloseAndResetLogFile(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn CreateLogMarshallingArea(
    hLog: HANDLE,
    pfnAllocBuffer: CLFS_BLOCK_ALLOCATION,
    pfnFreeBuffer: CLFS_BLOCK_DEALLOCATION,
    pvBlockAllocContext: *c_void,
    cbMarshallingBuffer: u32,
    cMaxWriteBuffers: u32,
    cMaxReadBuffers: u32,
    ppvMarshal: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeleteLogMarshallingArea(
    pvMarshal: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReserveAndAppendLog(
    pvMarshal: *c_void,
    rgWriteEntries: *CLS_WRITE_ENTRY,
    cWriteEntries: u32,
    plsnUndoNext: *CLS_LSN,
    plsnPrevious: *CLS_LSN,
    cReserveRecords: u32,
    rgcbReservation: *i64,
    fFlags: CLFS_FLAG,
    plsn: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReserveAndAppendLogAligned(
    pvMarshal: *c_void,
    rgWriteEntries: *CLS_WRITE_ENTRY,
    cWriteEntries: u32,
    cbEntryAlignment: u32,
    plsnUndoNext: *CLS_LSN,
    plsnPrevious: *CLS_LSN,
    cReserveRecords: u32,
    rgcbReservation: *i64,
    fFlags: CLFS_FLAG,
    plsn: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FlushLogBuffers(
    pvMarshal: *c_void,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn FlushLogToLsn(
    pvMarshalContext: *c_void,
    plsnFlush: *CLS_LSN,
    plsnLastFlushed: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogRecord(
    pvMarshal: *c_void,
    plsnFirst: *CLS_LSN,
    eContextMode: CLFS_CONTEXT_MODE,
    ppvReadBuffer: **c_void,
    pcbReadBuffer: *u32,
    peRecordType: *u8,
    plsnUndoNext: *CLS_LSN,
    plsnPrevious: *CLS_LSN,
    ppvReadContext: **c_void,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadNextLogRecord(
    pvReadContext: *c_void,
    ppvBuffer: **c_void,
    pcbBuffer: *u32,
    peRecordType: *u8,
    plsnUser: *CLS_LSN,
    plsnUndoNext: *CLS_LSN,
    plsnPrevious: *CLS_LSN,
    plsnRecord: *CLS_LSN,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TerminateReadLog(
    pvCursorContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn PrepareLogArchive(
    hLog: HANDLE,
    pszBaseLogFileName: [*:0]u16,
    cLen: u32,
    plsnLow: ?*const CLS_LSN,
    plsnHigh: ?*const CLS_LSN,
    pcActualLength: ?*u32,
    poffBaseLogFileData: *u64,
    pcbBaseLogFileLength: *u64,
    plsnBase: *CLS_LSN,
    plsnLast: *CLS_LSN,
    plsnCurrentArchiveTail: *CLS_LSN,
    ppvArchiveContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogArchiveMetadata(
    pvArchiveContext: *c_void,
    cbOffset: u32,
    cbBytesToRead: u32,
    pbReadBuffer: *u8,
    pcbBytesRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetNextLogArchiveExtent(
    pvArchiveContext: *c_void,
    rgadExtent: *CLS_ARCHIVE_DESCRIPTOR,
    cDescriptors: u32,
    pcDescriptorsReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn TerminateLogArchive(
    pvArchiveContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ValidateLog(
    pszLogFileName: [*:0]const u16,
    psaLogFile: *SECURITY_ATTRIBUTES,
    pinfoBuffer: *CLS_INFORMATION,
    pcbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogContainerName(
    hLog: HANDLE,
    cidLogicalContainer: u32,
    pwstrContainerName: [*:0]const u16,
    cLenContainerName: u32,
    pcActualLenContainerName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn GetLogIoStatistics(
    hLog: HANDLE,
    pvStatsBuffer: *c_void,
    cbStatsBuffer: u32,
    eStatsClass: CLFS_IOSTATS_CLASS,
    pcbStatsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RegisterManageableLogClient(
    hLog: HANDLE,
    pCallbacks: *LOG_MANAGEMENT_CALLBACKS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn DeregisterManageableLogClient(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn ReadLogNotification(
    hLog: HANDLE,
    pNotification: *CLFS_MGMT_NOTIFICATION,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn InstallLogPolicy(
    hLog: HANDLE,
    pPolicy: *CLFS_MGMT_POLICY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RemoveLogPolicy(
    hLog: HANDLE,
    ePolicyType: CLFS_MGMT_POLICY_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn QueryLogPolicy(
    hLog: HANDLE,
    ePolicyType: CLFS_MGMT_POLICY_TYPE,
    pPolicyBuffer: *CLFS_MGMT_POLICY,
    pcbPolicyBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn SetLogFileSizeWithPolicy(
    hLog: HANDLE,
    pDesiredSize: *u64,
    pResultingSize: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn HandleLogFull(
    hLog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn LogTailAdvanceFailure(
    hLog: HANDLE,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "clfsw32" fn RegisterForLogWriteNotification(
    hLog: HANDLE,
    cbThreshold: u32,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryUsersOnEncryptedFile(
    lpFileName: [*:0]const u16,
    pUsers: **ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryRecoveryAgentsOnEncryptedFile(
    lpFileName: [*:0]const u16,
    pRecoveryAgents: **ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RemoveUsersFromEncryptedFile(
    lpFileName: [*:0]const u16,
    pHashes: *ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddUsersToEncryptedFile(
    lpFileName: [*:0]const u16,
    pEncryptionCertificates: *ENCRYPTION_CERTIFICATE_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetUserFileEncryptionKey(
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn SetUserFileEncryptionKeyEx(
    pEncryptionCertificate: ?*ENCRYPTION_CERTIFICATE,
    dwCapabilities: u32,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FreeEncryptionCertificateHashList(
    pUsers: *ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EncryptionDisable(
    DirPath: [*:0]const u16,
    Disable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DuplicateEncryptionInfoFile(
    SrcFileName: [*:0]const u16,
    DstFileName: [*:0]const u16,
    dwCreationDistribution: u32,
    dwAttributes: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn GetEncryptedFileMetadata(
    lpFileName: [*:0]const u16,
    pcbMetadata: *u32,
    ppbMetadata: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn SetEncryptedFileMetadata(
    lpFileName: [*:0]const u16,
    pbOldMetadata: ?*u8,
    pbNewMetadata: *u8,
    pOwnerHash: *ENCRYPTION_CERTIFICATE_HASH,
    dwOperation: u32,
    pCertificatesAdded: ?*ENCRYPTION_CERTIFICATE_HASH_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn FreeEncryptedFileMetadata(
    pbMetadata: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn LZStart(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn LZDone(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CopyLZFile(
    hfSource: i32,
    hfDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZCopy(
    hfSource: i32,
    hfDest: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZInit(
    hfSource: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetExpandedNameA(
    lpszSource: PSTR,
    lpszBuffer: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetExpandedNameW(
    lpszSource: PWSTR,
    lpszBuffer: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZOpenFileA(
    lpFileName: PSTR,
    lpReOpenBuf: *OFSTRUCT,
    wStyle: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZOpenFileW(
    lpFileName: PWSTR,
    lpReOpenBuf: *OFSTRUCT,
    wStyle: LZOPENFILE_STYLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZSeek(
    hFile: i32,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZRead(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: PSTR,
    cbRead: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LZClose(
    hFile: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WOFUTIL" fn WofShouldCompressBinaries(
    Volume: [*:0]const u16,
    Algorithm: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WOFUTIL" fn WofGetDriverVersion(
    FileOrVolumeHandle: HANDLE,
    Provider: u32,
    WofVersion: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofSetFileDataLocation(
    FileHandle: HANDLE,
    Provider: u32,
    ExternalFileInfo: *c_void,
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofIsExternalFile(
    FilePath: [*:0]const u16,
    IsExternalFile: ?*BOOL,
    Provider: ?*u32,
    ExternalFileInfo: ?*c_void,
    BufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofEnumEntries(
    VolumeName: [*:0]const u16,
    Provider: u32,
    EnumProc: WofEnumEntryProc,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofWimAddEntry(
    VolumeName: [*:0]const u16,
    WimPath: [*:0]const u16,
    WimType: u32,
    WimIndex: u32,
    DataSourceId: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofWimEnumFiles(
    VolumeName: [*:0]const u16,
    DataSourceId: LARGE_INTEGER,
    EnumProc: WofEnumFilesProc,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofWimSuspendEntry(
    VolumeName: [*:0]const u16,
    DataSourceId: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofWimRemoveEntry(
    VolumeName: [*:0]const u16,
    DataSourceId: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofWimUpdateEntry(
    VolumeName: [*:0]const u16,
    DataSourceId: LARGE_INTEGER,
    NewWimPath: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WOFUTIL" fn WofFileEnumFiles(
    VolumeName: [*:0]const u16,
    Algorithm: u32,
    EnumProc: WofEnumFilesProc,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogCreateFileReadContext(
    LogPath: [*:0]const u16,
    BeginningLsn: CLS_LSN,
    EndingLsn: CLS_LSN,
    TxfFileId: *TXF_ID,
    TxfLogContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogCreateRangeReadContext(
    LogPath: [*:0]const u16,
    BeginningLsn: CLS_LSN,
    EndingLsn: CLS_LSN,
    BeginningVirtualClock: *LARGE_INTEGER,
    EndingVirtualClock: *LARGE_INTEGER,
    RecordTypeMask: u32,
    TxfLogContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogDestroyReadContext(
    TxfLogContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "txfw32" fn TxfLogReadRecords(
    TxfLogContext: *c_void,
    BufferLength: u32,
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *c_void,
    BytesUsed: *u32,
    RecordCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfReadMetadataInfo(
    FileHandle: HANDLE,
    TxfFileId: *TXF_ID,
    LastLsn: *CLS_LSN,
    TransactionState: *u32,
    LockingTransaction: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogRecordGetFileName(
    // TODO: what to do with BytesParamIndex 1?
    RecordBuffer: *c_void,
    RecordBufferLengthInBytes: u32,
    // TODO: what to do with BytesParamIndex 3?
    NameBuffer: PWSTR,
    NameBufferLengthInBytes: *u32,
    TxfId: ?*TXF_ID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfLogRecordGetGenericType(
    RecordBuffer: *c_void,
    RecordBufferLengthInBytes: u32,
    GenericType: *u32,
    VirtualClock: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "txfw32" fn TxfSetThreadMiniVersionForCreate(
    MiniVersion: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "txfw32" fn TxfGetThreadMiniVersionForCreate(
    MiniVersion: *u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateTransaction(
    lpTransactionAttributes: *SECURITY_ATTRIBUTES,
    UOW: *Guid,
    CreateOptions: u32,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransaction(
    dwDesiredAccess: u32,
    TransactionId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitTransaction(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitTransactionAsync(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackTransaction(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackTransactionAsync(
    TransactionHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionId(
    TransactionHandle: HANDLE,
    TransactionId: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionInformation(
    TransactionHandle: HANDLE,
    Outcome: *u32,
    IsolationLevel: *u32,
    IsolationFlags: *u32,
    Timeout: *u32,
    BufferLength: u32,
    Description: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetTransactionInformation(
    TransactionHandle: HANDLE,
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: u32,
    Description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateTransactionManager(
    lpTransactionAttributes: *SECURITY_ATTRIBUTES,
    LogFileName: PWSTR,
    CreateOptions: u32,
    CommitStrength: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransactionManager(
    LogFileName: PWSTR,
    DesiredAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenTransactionManagerById(
    TransactionManagerId: *Guid,
    DesiredAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RenameTransactionManager(
    LogFileName: PWSTR,
    ExistingTransactionManagerGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollforwardTransactionManager(
    TransactionManagerHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverTransactionManager(
    TransactionManagerHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetCurrentClockTransactionManager(
    TransactionManagerHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetTransactionManagerId(
    TransactionManagerHandle: HANDLE,
    TransactionManagerId: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateResourceManager(
    lpResourceManagerAttributes: *SECURITY_ATTRIBUTES,
    ResourceManagerId: *Guid,
    CreateOptions: u32,
    TmHandle: HANDLE,
    Description: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenResourceManager(
    dwDesiredAccess: u32,
    TmHandle: HANDLE,
    ResourceManagerId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverResourceManager(
    ResourceManagerHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetNotificationResourceManager(
    ResourceManagerHandle: HANDLE,
    TransactionNotification: *TRANSACTION_NOTIFICATION,
    NotificationLength: u32,
    dwMilliseconds: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetNotificationResourceManagerAsync(
    ResourceManagerHandle: HANDLE,
    TransactionNotification: *TRANSACTION_NOTIFICATION,
    TransactionNotificationLength: u32,
    ReturnLength: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetResourceManagerCompletionPort(
    ResourceManagerHandle: HANDLE,
    IoCompletionPortHandle: HANDLE,
    CompletionKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CreateEnlistment(
    lpEnlistmentAttributes: *SECURITY_ATTRIBUTES,
    ResourceManagerHandle: HANDLE,
    TransactionHandle: HANDLE,
    NotificationMask: u32,
    CreateOptions: u32,
    EnlistmentKey: *c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn OpenEnlistment(
    dwDesiredAccess: u32,
    ResourceManagerHandle: HANDLE,
    EnlistmentId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RecoverEnlistment(
    EnlistmentHandle: HANDLE,
    EnlistmentKey: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetEnlistmentRecoveryInformation(
    EnlistmentHandle: HANDLE,
    BufferSize: u32,
    Buffer: *c_void,
    BufferUsed: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn GetEnlistmentId(
    EnlistmentHandle: HANDLE,
    EnlistmentId: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SetEnlistmentRecoveryInformation(
    EnlistmentHandle: HANDLE,
    BufferSize: u32,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrepareEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrePrepareEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrePrepareComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn PrepareComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn ReadOnlyEnlistment(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn CommitComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn RollbackComplete(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ktmw32" fn SinglePhaseReject(
    EnlistmentHandle: HANDLE,
    TmVirtualClock: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareAdd(
    servername: ?PWSTR,
    level: u32,
    buf: *u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareEnum(
    servername: ?PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "srvcli" fn NetShareEnumSticky(
    servername: ?PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareGetInfo(
    servername: ?PWSTR,
    netname: PWSTR,
    level: u32,
    bufptr: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareSetInfo(
    servername: ?PWSTR,
    netname: PWSTR,
    level: u32,
    buf: *u8,
    parm_err: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareDel(
    servername: ?PWSTR,
    netname: PWSTR,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "srvcli" fn NetShareDelSticky(
    servername: ?PWSTR,
    netname: PWSTR,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareCheck(
    servername: ?PWSTR,
    device: PWSTR,
    type: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetShareDelEx(
    servername: ?PWSTR,
    level: u32,
    buf: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "srvcli" fn NetServerAliasAdd(
    servername: ?PWSTR,
    level: u32,
    buf: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "srvcli" fn NetServerAliasDel(
    servername: ?PWSTR,
    level: u32,
    buf: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "srvcli" fn NetServerAliasEnum(
    servername: ?PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resumehandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetSessionEnum(
    servername: ?PWSTR,
    UncClientName: ?PWSTR,
    username: ?PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetSessionDel(
    servername: ?PWSTR,
    UncClientName: ?PWSTR,
    username: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetSessionGetInfo(
    servername: ?PWSTR,
    UncClientName: PWSTR,
    username: PWSTR,
    level: u32,
    bufptr: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetConnectionEnum(
    servername: ?PWSTR,
    qualifier: PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resume_handle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetFileClose(
    servername: ?PWSTR,
    fileid: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetFileEnum(
    servername: ?PWSTR,
    basepath: ?PWSTR,
    username: ?PWSTR,
    level: u32,
    bufptr: **u8,
    prefmaxlen: u32,
    entriesread: *u32,
    totalentries: *u32,
    resume_handle: ?*usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "srvcli" fn NetFileGetInfo(
    servername: ?PWSTR,
    fileid: u32,
    level: u32,
    bufptr: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "NETAPI32" fn NetStatisticsGet(
    ServerName: *i8,
    Service: *i8,
    Level: u32,
    Options: u32,
    Buffer: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (84)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WIN32_FIND_DATA = WIN32_FIND_DATAA;
        pub const NTMS_DRIVEINFORMATION = NTMS_DRIVEINFORMATIONA;
        pub const NTMS_CHANGERINFORMATION = NTMS_CHANGERINFORMATIONA;
        pub const NTMS_PMIDINFORMATION = NTMS_PMIDINFORMATIONA;
        pub const NTMS_PARTITIONINFORMATION = NTMS_PARTITIONINFORMATIONA;
        pub const NTMS_DRIVETYPEINFORMATION = NTMS_DRIVETYPEINFORMATIONA;
        pub const NTMS_CHANGERTYPEINFORMATION = NTMS_CHANGERTYPEINFORMATIONA;
        pub const NTMS_LIBREQUESTINFORMATION = NTMS_LIBREQUESTINFORMATIONA;
        pub const NTMS_OPREQUESTINFORMATION = NTMS_OPREQUESTINFORMATIONA;
        pub const NTMS_OBJECTINFORMATION = NTMS_OBJECTINFORMATIONA;
        pub const NTMS_I1_LIBREQUESTINFORMATION = NTMS_I1_LIBREQUESTINFORMATIONA;
        pub const NTMS_I1_PMIDINFORMATION = NTMS_I1_PMIDINFORMATIONA;
        pub const NTMS_I1_PARTITIONINFORMATION = NTMS_I1_PARTITIONINFORMATIONA;
        pub const NTMS_I1_OPREQUESTINFORMATION = NTMS_I1_OPREQUESTINFORMATIONA;
        pub const NTMS_I1_OBJECTINFORMATION = NTMS_I1_OBJECTINFORMATIONA;
        pub const SearchPath = SearchPathA;
        pub const GetBinaryType = GetBinaryTypeA;
        pub const GetShortPathName = GetShortPathNameA;
        pub const GetLongPathNameTransacted = GetLongPathNameTransactedA;
        pub const SetFileShortName = SetFileShortNameA;
        pub const EncryptFile = EncryptFileA;
        pub const DecryptFile = DecryptFileA;
        pub const FileEncryptionStatus = FileEncryptionStatusA;
        pub const OpenEncryptedFileRaw = OpenEncryptedFileRawA;
        pub const GetLogicalDriveStrings = GetLogicalDriveStringsA;
        pub const CreateDirectoryEx = CreateDirectoryExA;
        pub const CreateDirectoryTransacted = CreateDirectoryTransactedA;
        pub const RemoveDirectoryTransacted = RemoveDirectoryTransactedA;
        pub const GetFullPathNameTransacted = GetFullPathNameTransactedA;
        pub const DefineDosDevice = DefineDosDeviceA;
        pub const QueryDosDevice = QueryDosDeviceA;
        pub const CreateFileTransacted = CreateFileTransactedA;
        pub const SetFileAttributesTransacted = SetFileAttributesTransactedA;
        pub const GetFileAttributesTransacted = GetFileAttributesTransactedA;
        pub const GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedA;
        pub const DeleteFileTransacted = DeleteFileTransactedA;
        pub const CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3A;
        pub const FindFirstFileTransacted = FindFirstFileTransactedA;
        pub const CopyFile = CopyFileA;
        pub const CopyFileEx = CopyFileExA;
        pub const CopyFileTransacted = CopyFileTransactedA;
        pub const MoveFile = MoveFileA;
        pub const MoveFileEx = MoveFileExA;
        pub const MoveFileWithProgress = MoveFileWithProgressA;
        pub const MoveFileTransacted = MoveFileTransactedA;
        pub const ReplaceFile = ReplaceFileA;
        pub const CreateHardLink = CreateHardLinkA;
        pub const CreateHardLinkTransacted = CreateHardLinkTransactedA;
        pub const SetVolumeLabel = SetVolumeLabelA;
        pub const FindFirstVolume = FindFirstVolumeA;
        pub const FindNextVolume = FindNextVolumeA;
        pub const FindFirstVolumeMountPoint = FindFirstVolumeMountPointA;
        pub const FindNextVolumeMountPoint = FindNextVolumeMountPointA;
        pub const SetVolumeMountPoint = SetVolumeMountPointA;
        pub const DeleteVolumeMountPoint = DeleteVolumeMountPointA;
        pub const GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointA;
        pub const GetVolumePathName = GetVolumePathNameA;
        pub const GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameA;
        pub const CreateSymbolicLink = CreateSymbolicLinkA;
        pub const CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedA;
        pub const CreateDirectory = CreateDirectoryA;
        pub const CreateFile = CreateFileA;
        pub const DeleteFile = DeleteFileA;
        pub const FindFirstChangeNotification = FindFirstChangeNotificationA;
        pub const FindFirstFile = FindFirstFileA;
        pub const FindFirstFileEx = FindFirstFileExA;
        pub const FindNextFile = FindNextFileA;
        pub const GetDiskFreeSpace = GetDiskFreeSpaceA;
        pub const GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
        pub const GetDiskSpaceInformation = GetDiskSpaceInformationA;
        pub const GetDriveType = GetDriveTypeA;
        pub const GetFileAttributes = GetFileAttributesA;
        pub const GetFileAttributesEx = GetFileAttributesExA;
        pub const GetFinalPathNameByHandle = GetFinalPathNameByHandleA;
        pub const GetFullPathName = GetFullPathNameA;
        pub const GetLongPathName = GetLongPathNameA;
        pub const GetTempFileName = GetTempFileNameA;
        pub const GetVolumeInformation = GetVolumeInformationA;
        pub const RemoveDirectory = RemoveDirectoryA;
        pub const SetFileAttributes = SetFileAttributesA;
        pub const GetTempPath = GetTempPathA;
        pub const GetCompressedFileSize = GetCompressedFileSizeA;
        pub const GetExpandedName = GetExpandedNameA;
        pub const LZOpenFile = LZOpenFileA;
    },
    .wide => struct {
        pub const WIN32_FIND_DATA = WIN32_FIND_DATAW;
        pub const NTMS_DRIVEINFORMATION = NTMS_DRIVEINFORMATIONW;
        pub const NTMS_CHANGERINFORMATION = NTMS_CHANGERINFORMATIONW;
        pub const NTMS_PMIDINFORMATION = NTMS_PMIDINFORMATIONW;
        pub const NTMS_PARTITIONINFORMATION = NTMS_PARTITIONINFORMATIONW;
        pub const NTMS_DRIVETYPEINFORMATION = NTMS_DRIVETYPEINFORMATIONW;
        pub const NTMS_CHANGERTYPEINFORMATION = NTMS_CHANGERTYPEINFORMATIONW;
        pub const NTMS_LIBREQUESTINFORMATION = NTMS_LIBREQUESTINFORMATIONW;
        pub const NTMS_OPREQUESTINFORMATION = NTMS_OPREQUESTINFORMATIONW;
        pub const NTMS_OBJECTINFORMATION = NTMS_OBJECTINFORMATIONW;
        pub const NTMS_I1_LIBREQUESTINFORMATION = NTMS_I1_LIBREQUESTINFORMATIONW;
        pub const NTMS_I1_PMIDINFORMATION = NTMS_I1_PMIDINFORMATIONW;
        pub const NTMS_I1_PARTITIONINFORMATION = NTMS_I1_PARTITIONINFORMATIONW;
        pub const NTMS_I1_OPREQUESTINFORMATION = NTMS_I1_OPREQUESTINFORMATIONW;
        pub const NTMS_I1_OBJECTINFORMATION = NTMS_I1_OBJECTINFORMATIONW;
        pub const SearchPath = SearchPathW;
        pub const GetBinaryType = GetBinaryTypeW;
        pub const GetShortPathName = GetShortPathNameW;
        pub const GetLongPathNameTransacted = GetLongPathNameTransactedW;
        pub const SetFileShortName = SetFileShortNameW;
        pub const EncryptFile = EncryptFileW;
        pub const DecryptFile = DecryptFileW;
        pub const FileEncryptionStatus = FileEncryptionStatusW;
        pub const OpenEncryptedFileRaw = OpenEncryptedFileRawW;
        pub const GetLogicalDriveStrings = GetLogicalDriveStringsW;
        pub const CreateDirectoryEx = CreateDirectoryExW;
        pub const CreateDirectoryTransacted = CreateDirectoryTransactedW;
        pub const RemoveDirectoryTransacted = RemoveDirectoryTransactedW;
        pub const GetFullPathNameTransacted = GetFullPathNameTransactedW;
        pub const DefineDosDevice = DefineDosDeviceW;
        pub const QueryDosDevice = QueryDosDeviceW;
        pub const CreateFileTransacted = CreateFileTransactedW;
        pub const SetFileAttributesTransacted = SetFileAttributesTransactedW;
        pub const GetFileAttributesTransacted = GetFileAttributesTransactedW;
        pub const GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedW;
        pub const DeleteFileTransacted = DeleteFileTransactedW;
        pub const CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3W;
        pub const FindFirstFileTransacted = FindFirstFileTransactedW;
        pub const CopyFile = CopyFileW;
        pub const CopyFileEx = CopyFileExW;
        pub const CopyFileTransacted = CopyFileTransactedW;
        pub const MoveFile = MoveFileW;
        pub const MoveFileEx = MoveFileExW;
        pub const MoveFileWithProgress = MoveFileWithProgressW;
        pub const MoveFileTransacted = MoveFileTransactedW;
        pub const ReplaceFile = ReplaceFileW;
        pub const CreateHardLink = CreateHardLinkW;
        pub const CreateHardLinkTransacted = CreateHardLinkTransactedW;
        pub const SetVolumeLabel = SetVolumeLabelW;
        pub const FindFirstVolume = FindFirstVolumeW;
        pub const FindNextVolume = FindNextVolumeW;
        pub const FindFirstVolumeMountPoint = FindFirstVolumeMountPointW;
        pub const FindNextVolumeMountPoint = FindNextVolumeMountPointW;
        pub const SetVolumeMountPoint = SetVolumeMountPointW;
        pub const DeleteVolumeMountPoint = DeleteVolumeMountPointW;
        pub const GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointW;
        pub const GetVolumePathName = GetVolumePathNameW;
        pub const GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameW;
        pub const CreateSymbolicLink = CreateSymbolicLinkW;
        pub const CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedW;
        pub const CreateDirectory = CreateDirectoryW;
        pub const CreateFile = CreateFileW;
        pub const DeleteFile = DeleteFileW;
        pub const FindFirstChangeNotification = FindFirstChangeNotificationW;
        pub const FindFirstFile = FindFirstFileW;
        pub const FindFirstFileEx = FindFirstFileExW;
        pub const FindNextFile = FindNextFileW;
        pub const GetDiskFreeSpace = GetDiskFreeSpaceW;
        pub const GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
        pub const GetDiskSpaceInformation = GetDiskSpaceInformationW;
        pub const GetDriveType = GetDriveTypeW;
        pub const GetFileAttributes = GetFileAttributesW;
        pub const GetFileAttributesEx = GetFileAttributesExW;
        pub const GetFinalPathNameByHandle = GetFinalPathNameByHandleW;
        pub const GetFullPathName = GetFullPathNameW;
        pub const GetLongPathName = GetLongPathNameW;
        pub const GetTempFileName = GetTempFileNameW;
        pub const GetVolumeInformation = GetVolumeInformationW;
        pub const RemoveDirectory = RemoveDirectoryW;
        pub const SetFileAttributes = SetFileAttributesW;
        pub const GetTempPath = GetTempPathW;
        pub const GetCompressedFileSize = GetCompressedFileSizeW;
        pub const GetExpandedName = GetExpandedNameW;
        pub const LZOpenFile = LZOpenFileW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WIN32_FIND_DATA = *opaque{};
        pub const NTMS_DRIVEINFORMATION = *opaque{};
        pub const NTMS_CHANGERINFORMATION = *opaque{};
        pub const NTMS_PMIDINFORMATION = *opaque{};
        pub const NTMS_PARTITIONINFORMATION = *opaque{};
        pub const NTMS_DRIVETYPEINFORMATION = *opaque{};
        pub const NTMS_CHANGERTYPEINFORMATION = *opaque{};
        pub const NTMS_LIBREQUESTINFORMATION = *opaque{};
        pub const NTMS_OPREQUESTINFORMATION = *opaque{};
        pub const NTMS_OBJECTINFORMATION = *opaque{};
        pub const NTMS_I1_LIBREQUESTINFORMATION = *opaque{};
        pub const NTMS_I1_PMIDINFORMATION = *opaque{};
        pub const NTMS_I1_PARTITIONINFORMATION = *opaque{};
        pub const NTMS_I1_OPREQUESTINFORMATION = *opaque{};
        pub const NTMS_I1_OBJECTINFORMATION = *opaque{};
        pub const SearchPath = *opaque{};
        pub const GetBinaryType = *opaque{};
        pub const GetShortPathName = *opaque{};
        pub const GetLongPathNameTransacted = *opaque{};
        pub const SetFileShortName = *opaque{};
        pub const EncryptFile = *opaque{};
        pub const DecryptFile = *opaque{};
        pub const FileEncryptionStatus = *opaque{};
        pub const OpenEncryptedFileRaw = *opaque{};
        pub const GetLogicalDriveStrings = *opaque{};
        pub const CreateDirectoryEx = *opaque{};
        pub const CreateDirectoryTransacted = *opaque{};
        pub const RemoveDirectoryTransacted = *opaque{};
        pub const GetFullPathNameTransacted = *opaque{};
        pub const DefineDosDevice = *opaque{};
        pub const QueryDosDevice = *opaque{};
        pub const CreateFileTransacted = *opaque{};
        pub const SetFileAttributesTransacted = *opaque{};
        pub const GetFileAttributesTransacted = *opaque{};
        pub const GetCompressedFileSizeTransacted = *opaque{};
        pub const DeleteFileTransacted = *opaque{};
        pub const CheckNameLegalDOS8Dot3 = *opaque{};
        pub const FindFirstFileTransacted = *opaque{};
        pub const CopyFile = *opaque{};
        pub const CopyFileEx = *opaque{};
        pub const CopyFileTransacted = *opaque{};
        pub const MoveFile = *opaque{};
        pub const MoveFileEx = *opaque{};
        pub const MoveFileWithProgress = *opaque{};
        pub const MoveFileTransacted = *opaque{};
        pub const ReplaceFile = *opaque{};
        pub const CreateHardLink = *opaque{};
        pub const CreateHardLinkTransacted = *opaque{};
        pub const SetVolumeLabel = *opaque{};
        pub const FindFirstVolume = *opaque{};
        pub const FindNextVolume = *opaque{};
        pub const FindFirstVolumeMountPoint = *opaque{};
        pub const FindNextVolumeMountPoint = *opaque{};
        pub const SetVolumeMountPoint = *opaque{};
        pub const DeleteVolumeMountPoint = *opaque{};
        pub const GetVolumeNameForVolumeMountPoint = *opaque{};
        pub const GetVolumePathName = *opaque{};
        pub const GetVolumePathNamesForVolumeName = *opaque{};
        pub const CreateSymbolicLink = *opaque{};
        pub const CreateSymbolicLinkTransacted = *opaque{};
        pub const CreateDirectory = *opaque{};
        pub const CreateFile = *opaque{};
        pub const DeleteFile = *opaque{};
        pub const FindFirstChangeNotification = *opaque{};
        pub const FindFirstFile = *opaque{};
        pub const FindFirstFileEx = *opaque{};
        pub const FindNextFile = *opaque{};
        pub const GetDiskFreeSpace = *opaque{};
        pub const GetDiskFreeSpaceEx = *opaque{};
        pub const GetDiskSpaceInformation = *opaque{};
        pub const GetDriveType = *opaque{};
        pub const GetFileAttributes = *opaque{};
        pub const GetFileAttributesEx = *opaque{};
        pub const GetFinalPathNameByHandle = *opaque{};
        pub const GetFullPathName = *opaque{};
        pub const GetLongPathName = *opaque{};
        pub const GetTempFileName = *opaque{};
        pub const GetVolumeInformation = *opaque{};
        pub const RemoveDirectory = *opaque{};
        pub const SetFileAttributes = *opaque{};
        pub const GetTempPath = *opaque{};
        pub const GetCompressedFileSize = *opaque{};
        pub const GetExpandedName = *opaque{};
        pub const LZOpenFile = *opaque{};
    } else struct {
        pub const WIN32_FIND_DATA = @compileError("'WIN32_FIND_DATA' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVEINFORMATION = @compileError("'NTMS_DRIVEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERINFORMATION = @compileError("'NTMS_CHANGERINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PMIDINFORMATION = @compileError("'NTMS_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_PARTITIONINFORMATION = @compileError("'NTMS_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_DRIVETYPEINFORMATION = @compileError("'NTMS_DRIVETYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_CHANGERTYPEINFORMATION = @compileError("'NTMS_CHANGERTYPEINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_LIBREQUESTINFORMATION = @compileError("'NTMS_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OPREQUESTINFORMATION = @compileError("'NTMS_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_OBJECTINFORMATION = @compileError("'NTMS_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_LIBREQUESTINFORMATION = @compileError("'NTMS_I1_LIBREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PMIDINFORMATION = @compileError("'NTMS_I1_PMIDINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_PARTITIONINFORMATION = @compileError("'NTMS_I1_PARTITIONINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OPREQUESTINFORMATION = @compileError("'NTMS_I1_OPREQUESTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const NTMS_I1_OBJECTINFORMATION = @compileError("'NTMS_I1_OBJECTINFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const SearchPath = @compileError("'SearchPath' requires that UNICODE be set to true or false in the root module");
        pub const GetBinaryType = @compileError("'GetBinaryType' requires that UNICODE be set to true or false in the root module");
        pub const GetShortPathName = @compileError("'GetShortPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathNameTransacted = @compileError("'GetLongPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileShortName = @compileError("'SetFileShortName' requires that UNICODE be set to true or false in the root module");
        pub const EncryptFile = @compileError("'EncryptFile' requires that UNICODE be set to true or false in the root module");
        pub const DecryptFile = @compileError("'DecryptFile' requires that UNICODE be set to true or false in the root module");
        pub const FileEncryptionStatus = @compileError("'FileEncryptionStatus' requires that UNICODE be set to true or false in the root module");
        pub const OpenEncryptedFileRaw = @compileError("'OpenEncryptedFileRaw' requires that UNICODE be set to true or false in the root module");
        pub const GetLogicalDriveStrings = @compileError("'GetLogicalDriveStrings' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryEx = @compileError("'CreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectoryTransacted = @compileError("'CreateDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectoryTransacted = @compileError("'RemoveDirectoryTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathNameTransacted = @compileError("'GetFullPathNameTransacted' requires that UNICODE be set to true or false in the root module");
        pub const DefineDosDevice = @compileError("'DefineDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const QueryDosDevice = @compileError("'QueryDosDevice' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileTransacted = @compileError("'CreateFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributesTransacted = @compileError("'SetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesTransacted = @compileError("'GetFileAttributesTransacted' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSizeTransacted = @compileError("'GetCompressedFileSizeTransacted' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFileTransacted = @compileError("'DeleteFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CheckNameLegalDOS8Dot3 = @compileError("'CheckNameLegalDOS8Dot3' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileTransacted = @compileError("'FindFirstFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CopyFile = @compileError("'CopyFile' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileEx = @compileError("'CopyFileEx' requires that UNICODE be set to true or false in the root module");
        pub const CopyFileTransacted = @compileError("'CopyFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const MoveFile = @compileError("'MoveFile' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileEx = @compileError("'MoveFileEx' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileWithProgress = @compileError("'MoveFileWithProgress' requires that UNICODE be set to true or false in the root module");
        pub const MoveFileTransacted = @compileError("'MoveFileTransacted' requires that UNICODE be set to true or false in the root module");
        pub const ReplaceFile = @compileError("'ReplaceFile' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLink = @compileError("'CreateHardLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateHardLinkTransacted = @compileError("'CreateHardLinkTransacted' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeLabel = @compileError("'SetVolumeLabel' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolume = @compileError("'FindFirstVolume' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolume = @compileError("'FindNextVolume' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstVolumeMountPoint = @compileError("'FindFirstVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const FindNextVolumeMountPoint = @compileError("'FindNextVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const SetVolumeMountPoint = @compileError("'SetVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const DeleteVolumeMountPoint = @compileError("'DeleteVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeNameForVolumeMountPoint = @compileError("'GetVolumeNameForVolumeMountPoint' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathName = @compileError("'GetVolumePathName' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumePathNamesForVolumeName = @compileError("'GetVolumePathNamesForVolumeName' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLink = @compileError("'CreateSymbolicLink' requires that UNICODE be set to true or false in the root module");
        pub const CreateSymbolicLinkTransacted = @compileError("'CreateSymbolicLinkTransacted' requires that UNICODE be set to true or false in the root module");
        pub const CreateDirectory = @compileError("'CreateDirectory' requires that UNICODE be set to true or false in the root module");
        pub const CreateFile = @compileError("'CreateFile' requires that UNICODE be set to true or false in the root module");
        pub const DeleteFile = @compileError("'DeleteFile' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstChangeNotification = @compileError("'FindFirstChangeNotification' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFile = @compileError("'FindFirstFile' requires that UNICODE be set to true or false in the root module");
        pub const FindFirstFileEx = @compileError("'FindFirstFileEx' requires that UNICODE be set to true or false in the root module");
        pub const FindNextFile = @compileError("'FindNextFile' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpace = @compileError("'GetDiskFreeSpace' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskFreeSpaceEx = @compileError("'GetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const GetDiskSpaceInformation = @compileError("'GetDiskSpaceInformation' requires that UNICODE be set to true or false in the root module");
        pub const GetDriveType = @compileError("'GetDriveType' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributes = @compileError("'GetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetFileAttributesEx = @compileError("'GetFileAttributesEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFinalPathNameByHandle = @compileError("'GetFinalPathNameByHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetFullPathName = @compileError("'GetFullPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetLongPathName = @compileError("'GetLongPathName' requires that UNICODE be set to true or false in the root module");
        pub const GetTempFileName = @compileError("'GetTempFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetVolumeInformation = @compileError("'GetVolumeInformation' requires that UNICODE be set to true or false in the root module");
        pub const RemoveDirectory = @compileError("'RemoveDirectory' requires that UNICODE be set to true or false in the root module");
        pub const SetFileAttributes = @compileError("'SetFileAttributes' requires that UNICODE be set to true or false in the root module");
        pub const GetTempPath = @compileError("'GetTempPath' requires that UNICODE be set to true or false in the root module");
        pub const GetCompressedFileSize = @compileError("'GetCompressedFileSize' requires that UNICODE be set to true or false in the root module");
        pub const GetExpandedName = @compileError("'GetExpandedName' requires that UNICODE be set to true or false in the root module");
        pub const LZOpenFile = @compileError("'LZOpenFile' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (24)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const DETECTION_TYPE = @import("system_services.zig").DETECTION_TYPE;
const IConnectionPointContainer = @import("com.zig").IConnectionPointContainer;
const FILETIME = @import("windows_programming.zig").FILETIME;
const STORAGE_BUS_TYPE = @import("system_services.zig").STORAGE_BUS_TYPE;
const CHAR = @import("system_services.zig").CHAR;
const SID = @import("security.zig").SID;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const PWSTR = @import("system_services.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const SECURITY_DESCRIPTOR = @import("security.zig").SECURITY_DESCRIPTOR;
const PSTR = @import("system_services.zig").PSTR;
const PSID = @import("security.zig").PSID;
const BOOL = @import("system_services.zig").BOOL;
const ULARGE_INTEGER = @import("system_services.zig").ULARGE_INTEGER;
const FILE_SEGMENT_ELEMENT = @import("system_services.zig").FILE_SEGMENT_ELEMENT;
const DISK_CACHE_RETENTION_PRIORITY = @import("system_services.zig").DISK_CACHE_RETENTION_PRIORITY;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const SHRINK_VOLUME_REQUEST_TYPES = @import("system_services.zig").SHRINK_VOLUME_REQUEST_TYPES;
const HANDLE = @import("system_services.zig").HANDLE;
const FILE_STORAGE_TIER_CLASS = @import("system_services.zig").FILE_STORAGE_TIER_CLASS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPOVERLAPPED_COMPLETION_ROUTINE")) { _ = LPOVERLAPPED_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "PFE_EXPORT_FUNC")) { _ = PFE_EXPORT_FUNC; }
    if (@hasDecl(@This(), "PFE_IMPORT_FUNC")) { _ = PFE_IMPORT_FUNC; }
    if (@hasDecl(@This(), "LPPROGRESS_ROUTINE")) { _ = LPPROGRESS_ROUTINE; }
    if (@hasDecl(@This(), "PCOPYFILE2_PROGRESS_ROUTINE")) { _ = PCOPYFILE2_PROGRESS_ROUTINE; }
    if (@hasDecl(@This(), "MAXMEDIALABEL")) { _ = MAXMEDIALABEL; }
    if (@hasDecl(@This(), "CLAIMMEDIALABEL")) { _ = CLAIMMEDIALABEL; }
    if (@hasDecl(@This(), "CLAIMMEDIALABELEX")) { _ = CLAIMMEDIALABELEX; }
    if (@hasDecl(@This(), "CLFS_BLOCK_ALLOCATION")) { _ = CLFS_BLOCK_ALLOCATION; }
    if (@hasDecl(@This(), "CLFS_BLOCK_DEALLOCATION")) { _ = CLFS_BLOCK_DEALLOCATION; }
    if (@hasDecl(@This(), "PCLFS_COMPLETION_ROUTINE")) { _ = PCLFS_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "PLOG_TAIL_ADVANCE_CALLBACK")) { _ = PLOG_TAIL_ADVANCE_CALLBACK; }
    if (@hasDecl(@This(), "PLOG_FULL_HANDLER_CALLBACK")) { _ = PLOG_FULL_HANDLER_CALLBACK; }
    if (@hasDecl(@This(), "PLOG_UNPINNED_CALLBACK")) { _ = PLOG_UNPINNED_CALLBACK; }
    if (@hasDecl(@This(), "WofEnumEntryProc")) { _ = WofEnumEntryProc; }
    if (@hasDecl(@This(), "WofEnumFilesProc")) { _ = WofEnumFilesProc; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
