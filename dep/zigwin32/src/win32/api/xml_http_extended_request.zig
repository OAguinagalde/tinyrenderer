//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (6)
//--------------------------------------------------------------------------------
pub const E_XML_NOTWF = @as(i32, -1072897501);
pub const E_XML_NODTD = @as(i32, -1072897500);
pub const E_XML_INVALID = @as(i32, -1072897499);
pub const E_XML_BUFFERTOOSMALL = @as(i32, -1072897498);
pub const XHR_PROP_ONDATA_ALWAYS = @as(u32, 0);
pub const XHR_PROP_ONDATA_NEVER = @as(u64, 18446744073709551615);

//--------------------------------------------------------------------------------
// Section: Types (90)
//--------------------------------------------------------------------------------
const CLSID_DOMDocument60_Value = @import("../zig.zig").Guid.initString("88d96a05-f192-11d4-a65f-0040963251e5");
pub const CLSID_DOMDocument60 = &CLSID_DOMDocument60_Value;

const CLSID_FreeThreadedDOMDocument60_Value = @import("../zig.zig").Guid.initString("88d96a06-f192-11d4-a65f-0040963251e5");
pub const CLSID_FreeThreadedDOMDocument60 = &CLSID_FreeThreadedDOMDocument60_Value;

const CLSID_XMLSchemaCache60_Value = @import("../zig.zig").Guid.initString("88d96a07-f192-11d4-a65f-0040963251e5");
pub const CLSID_XMLSchemaCache60 = &CLSID_XMLSchemaCache60_Value;

const CLSID_XSLTemplate60_Value = @import("../zig.zig").Guid.initString("88d96a08-f192-11d4-a65f-0040963251e5");
pub const CLSID_XSLTemplate60 = &CLSID_XSLTemplate60_Value;

const CLSID_XMLHTTP60_Value = @import("../zig.zig").Guid.initString("88d96a0a-f192-11d4-a65f-0040963251e5");
pub const CLSID_XMLHTTP60 = &CLSID_XMLHTTP60_Value;

const CLSID_FreeThreadedXMLHTTP60_Value = @import("../zig.zig").Guid.initString("88d96a09-f192-11d4-a65f-0040963251e5");
pub const CLSID_FreeThreadedXMLHTTP60 = &CLSID_FreeThreadedXMLHTTP60_Value;

const CLSID_ServerXMLHTTP60_Value = @import("../zig.zig").Guid.initString("88d96a0b-f192-11d4-a65f-0040963251e5");
pub const CLSID_ServerXMLHTTP60 = &CLSID_ServerXMLHTTP60_Value;

const CLSID_SAXXMLReader60_Value = @import("../zig.zig").Guid.initString("88d96a0c-f192-11d4-a65f-0040963251e5");
pub const CLSID_SAXXMLReader60 = &CLSID_SAXXMLReader60_Value;

const CLSID_MXXMLWriter60_Value = @import("../zig.zig").Guid.initString("88d96a0f-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXXMLWriter60 = &CLSID_MXXMLWriter60_Value;

const CLSID_MXHTMLWriter60_Value = @import("../zig.zig").Guid.initString("88d96a10-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXHTMLWriter60 = &CLSID_MXHTMLWriter60_Value;

const CLSID_SAXAttributes60_Value = @import("../zig.zig").Guid.initString("88d96a0e-f192-11d4-a65f-0040963251e5");
pub const CLSID_SAXAttributes60 = &CLSID_SAXAttributes60_Value;

const CLSID_MXNamespaceManager60_Value = @import("../zig.zig").Guid.initString("88d96a11-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXNamespaceManager60 = &CLSID_MXNamespaceManager60_Value;

const IID_IXMLDOMDocument2_Value = @import("../zig.zig").Guid.initString("2933bf95-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument2 = &IID_IXMLDOMDocument2_Value;
pub const IXMLDOMDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMDocument.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaces: fn(
            self: *const IXMLDOMDocument2,
            namespaceCollection: **IXMLDOMSchemaCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schemas: fn(
            self: *const IXMLDOMDocument2,
            otherCollection: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_schemas: fn(
            self: *const IXMLDOMDocument2,
            otherCollection: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        validate: fn(
            self: *const IXMLDOMDocument2,
            errorObj: **IXMLDOMParseError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setProperty: fn(
            self: *const IXMLDOMDocument2,
            name: BSTR,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProperty: fn(
            self: *const IXMLDOMDocument2,
            name: BSTR,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_get_namespaces(self: *const T, namespaceCollection: **IXMLDOMSchemaCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).get_namespaces(@ptrCast(*const IXMLDOMDocument2, self), namespaceCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_get_schemas(self: *const T, otherCollection: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).get_schemas(@ptrCast(*const IXMLDOMDocument2, self), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_putref_schemas(self: *const T, otherCollection: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).putref_schemas(@ptrCast(*const IXMLDOMDocument2, self), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_validate(self: *const T, errorObj: **IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).validate(@ptrCast(*const IXMLDOMDocument2, self), errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_setProperty(self: *const T, name: BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).setProperty(@ptrCast(*const IXMLDOMDocument2, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_getProperty(self: *const T, name: BSTR, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument2.VTable, self.vtable).getProperty(@ptrCast(*const IXMLDOMDocument2, self), name, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocument3_Value = @import("../zig.zig").Guid.initString("2933bf96-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument3 = &IID_IXMLDOMDocument3_Value;
pub const IXMLDOMDocument3 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMDocument2.VTable,
        validateNode: fn(
            self: *const IXMLDOMDocument3,
            node: *IXMLDOMNode,
            errorObj: **IXMLDOMParseError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        importNode: fn(
            self: *const IXMLDOMDocument3,
            node: *IXMLDOMNode,
            deep: i16,
            clone: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMDocument2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument3_validateNode(self: *const T, node: *IXMLDOMNode, errorObj: **IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument3.VTable, self.vtable).validateNode(@ptrCast(*const IXMLDOMDocument3, self), node, errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument3_importNode(self: *const T, node: *IXMLDOMNode, deep: i16, clone: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument3.VTable, self.vtable).importNode(@ptrCast(*const IXMLDOMDocument3, self), node, deep, clone);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMSchemaCollection_Value = @import("../zig.zig").Guid.initString("373984c8-b845-449b-91e7-45ac83036ade");
pub const IID_IXMLDOMSchemaCollection = &IID_IXMLDOMSchemaCollection_Value;
pub const IXMLDOMSchemaCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: fn(
            self: *const IXMLDOMSchemaCollection,
            namespaceURI: BSTR,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get: fn(
            self: *const IXMLDOMSchemaCollection,
            namespaceURI: BSTR,
            schemaNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IXMLDOMSchemaCollection,
            namespaceURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLDOMSchemaCollection,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: fn(
            self: *const IXMLDOMSchemaCollection,
            index: i32,
            length: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addCollection: fn(
            self: *const IXMLDOMSchemaCollection,
            otherCollection: *IXMLDOMSchemaCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IXMLDOMSchemaCollection,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_add(self: *const T, namespaceURI: BSTR, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).add(@ptrCast(*const IXMLDOMSchemaCollection, self), namespaceURI, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get(self: *const T, namespaceURI: BSTR, schemaNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).get(@ptrCast(*const IXMLDOMSchemaCollection, self), namespaceURI, schemaNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_remove(self: *const T, namespaceURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).remove(@ptrCast(*const IXMLDOMSchemaCollection, self), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get_length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMSchemaCollection, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get_namespaceURI(self: *const T, index: i32, length: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IXMLDOMSchemaCollection, self), index, length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_addCollection(self: *const T, otherCollection: *IXMLDOMSchemaCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).addCollection(@ptrCast(*const IXMLDOMSchemaCollection, self), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMSchemaCollection, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMSelection_Value = @import("../zig.zig").Guid.initString("aa634fc7-5888-44a7-a257-3a47150d3a0e");
pub const IID_IXMLDOMSelection = &IID_IXMLDOMSelection_Value;
pub const IXMLDOMSelection = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNodeList.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expr: fn(
            self: *const IXMLDOMSelection,
            expression: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_expr: fn(
            self: *const IXMLDOMSelection,
            expression: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_context: fn(
            self: *const IXMLDOMSelection,
            ppNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_context: fn(
            self: *const IXMLDOMSelection,
            pNode: *IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        peekNode: fn(
            self: *const IXMLDOMSelection,
            ppNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        matches: fn(
            self: *const IXMLDOMSelection,
            pNode: *IXMLDOMNode,
            ppNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNext: fn(
            self: *const IXMLDOMSelection,
            ppNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAll: fn(
            self: *const IXMLDOMSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clone: fn(
            self: *const IXMLDOMSelection,
            ppNode: **IXMLDOMSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProperty: fn(
            self: *const IXMLDOMSelection,
            name: BSTR,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setProperty: fn(
            self: *const IXMLDOMSelection,
            name: BSTR,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNodeList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_get_expr(self: *const T, expression: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).get_expr(@ptrCast(*const IXMLDOMSelection, self), expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_put_expr(self: *const T, expression: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).put_expr(@ptrCast(*const IXMLDOMSelection, self), expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_get_context(self: *const T, ppNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).get_context(@ptrCast(*const IXMLDOMSelection, self), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_putref_context(self: *const T, pNode: *IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).putref_context(@ptrCast(*const IXMLDOMSelection, self), pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_peekNode(self: *const T, ppNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).peekNode(@ptrCast(*const IXMLDOMSelection, self), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_matches(self: *const T, pNode: *IXMLDOMNode, ppNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).matches(@ptrCast(*const IXMLDOMSelection, self), pNode, ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_removeNext(self: *const T, ppNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).removeNext(@ptrCast(*const IXMLDOMSelection, self), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_removeAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).removeAll(@ptrCast(*const IXMLDOMSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_clone(self: *const T, ppNode: **IXMLDOMSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).clone(@ptrCast(*const IXMLDOMSelection, self), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_getProperty(self: *const T, name: BSTR, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).getProperty(@ptrCast(*const IXMLDOMSelection, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_setProperty(self: *const T, name: BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSelection.VTable, self.vtable).setProperty(@ptrCast(*const IXMLDOMSelection, self), name, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseError2_Value = @import("../zig.zig").Guid.initString("3efaa428-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseError2 = &IID_IXMLDOMParseError2_Value;
pub const IXMLDOMParseError2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMParseError.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorXPath: fn(
            self: *const IXMLDOMParseError2,
            xpathexpr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allErrors: fn(
            self: *const IXMLDOMParseError2,
            allErrors: **IXMLDOMParseErrorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        errorParameters: fn(
            self: *const IXMLDOMParseError2,
            index: i32,
            param1: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorParametersCount: fn(
            self: *const IXMLDOMParseError2,
            count: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMParseError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_errorXPath(self: *const T, xpathexpr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError2.VTable, self.vtable).get_errorXPath(@ptrCast(*const IXMLDOMParseError2, self), xpathexpr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_allErrors(self: *const T, allErrors: **IXMLDOMParseErrorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError2.VTable, self.vtable).get_allErrors(@ptrCast(*const IXMLDOMParseError2, self), allErrors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_errorParameters(self: *const T, index: i32, param1: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError2.VTable, self.vtable).errorParameters(@ptrCast(*const IXMLDOMParseError2, self), index, param1);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_errorParametersCount(self: *const T, count: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError2.VTable, self.vtable).get_errorParametersCount(@ptrCast(*const IXMLDOMParseError2, self), count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseErrorCollection_Value = @import("../zig.zig").Guid.initString("3efaa429-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseErrorCollection = &IID_IXMLDOMParseErrorCollection_Value;
pub const IXMLDOMParseErrorCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const IXMLDOMParseErrorCollection,
            index: i32,
            @"error": **IXMLDOMParseError2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IXMLDOMParseErrorCollection,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_next: fn(
            self: *const IXMLDOMParseErrorCollection,
            @"error": **IXMLDOMParseError2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXMLDOMParseErrorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IXMLDOMParseErrorCollection,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_item(self: *const T, index: i32, @"error": **IXMLDOMParseError2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseErrorCollection.VTable, self.vtable).get_item(@ptrCast(*const IXMLDOMParseErrorCollection, self), index, @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseErrorCollection.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMParseErrorCollection, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_next(self: *const T, @"error": **IXMLDOMParseError2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseErrorCollection.VTable, self.vtable).get_next(@ptrCast(*const IXMLDOMParseErrorCollection, self), @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseErrorCollection.VTable, self.vtable).reset(@ptrCast(*const IXMLDOMParseErrorCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get__newEnum(self: *const T, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseErrorCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMParseErrorCollection, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXSLProcessor_Value = @import("../zig.zig").Guid.initString("2933bf92-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXSLProcessor = &IID_IXSLProcessor_Value;
pub const IXSLProcessor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_input: fn(
            self: *const IXSLProcessor,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_input: fn(
            self: *const IXSLProcessor,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerTemplate: fn(
            self: *const IXSLProcessor,
            ppTemplate: **IXSLTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStartMode: fn(
            self: *const IXSLProcessor,
            mode: BSTR,
            namespaceURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startMode: fn(
            self: *const IXSLProcessor,
            mode: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startModeURI: fn(
            self: *const IXSLProcessor,
            namespaceURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_output: fn(
            self: *const IXSLProcessor,
            output: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_output: fn(
            self: *const IXSLProcessor,
            pOutput: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transform: fn(
            self: *const IXSLProcessor,
            pDone: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXSLProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXSLProcessor,
            pReadyState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addParameter: fn(
            self: *const IXSLProcessor,
            baseName: BSTR,
            parameter: VARIANT,
            namespaceURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addObject: fn(
            self: *const IXSLProcessor,
            obj: *IDispatch,
            namespaceURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stylesheet: fn(
            self: *const IXSLProcessor,
            stylesheet: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_put_input(self: *const T, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).put_input(@ptrCast(*const IXSLProcessor, self), @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_input(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_input(@ptrCast(*const IXSLProcessor, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_ownerTemplate(self: *const T, ppTemplate: **IXSLTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_ownerTemplate(@ptrCast(*const IXSLProcessor, self), ppTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_setStartMode(self: *const T, mode: BSTR, namespaceURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).setStartMode(@ptrCast(*const IXSLProcessor, self), mode, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_startMode(self: *const T, mode: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_startMode(@ptrCast(*const IXSLProcessor, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_startModeURI(self: *const T, namespaceURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_startModeURI(@ptrCast(*const IXSLProcessor, self), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_put_output(self: *const T, output: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).put_output(@ptrCast(*const IXSLProcessor, self), output);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_output(self: *const T, pOutput: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_output(@ptrCast(*const IXSLProcessor, self), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_transform(self: *const T, pDone: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).transform(@ptrCast(*const IXSLProcessor, self), pDone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).reset(@ptrCast(*const IXSLProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_readyState(self: *const T, pReadyState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_readyState(@ptrCast(*const IXSLProcessor, self), pReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_addParameter(self: *const T, baseName: BSTR, parameter: VARIANT, namespaceURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).addParameter(@ptrCast(*const IXSLProcessor, self), baseName, parameter, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_addObject(self: *const T, obj: *IDispatch, namespaceURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).addObject(@ptrCast(*const IXSLProcessor, self), obj, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_stylesheet(self: *const T, stylesheet: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLProcessor.VTable, self.vtable).get_stylesheet(@ptrCast(*const IXSLProcessor, self), stylesheet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXSLTemplate_Value = @import("../zig.zig").Guid.initString("2933bf93-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXSLTemplate = &IID_IXSLTemplate_Value;
pub const IXSLTemplate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_stylesheet: fn(
            self: *const IXSLTemplate,
            stylesheet: *IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stylesheet: fn(
            self: *const IXSLTemplate,
            stylesheet: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createProcessor: fn(
            self: *const IXSLTemplate,
            ppProcessor: **IXSLProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_putref_stylesheet(self: *const T, stylesheet: *IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLTemplate.VTable, self.vtable).putref_stylesheet(@ptrCast(*const IXSLTemplate, self), stylesheet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_get_stylesheet(self: *const T, stylesheet: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLTemplate.VTable, self.vtable).get_stylesheet(@ptrCast(*const IXSLTemplate, self), stylesheet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_createProcessor(self: *const T, ppProcessor: **IXSLProcessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXSLTemplate.VTable, self.vtable).createProcessor(@ptrCast(*const IXSLTemplate, self), ppProcessor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHTTPRequest_Value = @import("../zig.zig").Guid.initString("ed8c108d-4349-11d2-91a4-00c04f7969e8");
pub const IID_IXMLHTTPRequest = &IID_IXMLHTTPRequest_Value;
pub const IXMLHTTPRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        open: fn(
            self: *const IXMLHTTPRequest,
            bstrMethod: BSTR,
            bstrUrl: BSTR,
            varAsync: VARIANT,
            bstrUser: VARIANT,
            bstrPassword: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRequestHeader: fn(
            self: *const IXMLHTTPRequest,
            bstrHeader: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getResponseHeader: fn(
            self: *const IXMLHTTPRequest,
            bstrHeader: BSTR,
            pbstrValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllResponseHeaders: fn(
            self: *const IXMLHTTPRequest,
            pbstrHeaders: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IXMLHTTPRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IXMLHTTPRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: fn(
            self: *const IXMLHTTPRequest,
            plStatus: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_statusText: fn(
            self: *const IXMLHTTPRequest,
            pbstrStatus: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseXML: fn(
            self: *const IXMLHTTPRequest,
            ppBody: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: fn(
            self: *const IXMLHTTPRequest,
            pbstrBody: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseBody: fn(
            self: *const IXMLHTTPRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseStream: fn(
            self: *const IXMLHTTPRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: fn(
            self: *const IXMLHTTPRequest,
            plState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: fn(
            self: *const IXMLHTTPRequest,
            pReadyStateSink: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_open(self: *const T, bstrMethod: BSTR, bstrUrl: BSTR, varAsync: VARIANT, bstrUser: VARIANT, bstrPassword: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).open(@ptrCast(*const IXMLHTTPRequest, self), bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_setRequestHeader(self: *const T, bstrHeader: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).setRequestHeader(@ptrCast(*const IXMLHTTPRequest, self), bstrHeader, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_getResponseHeader(self: *const T, bstrHeader: BSTR, pbstrValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).getResponseHeader(@ptrCast(*const IXMLHTTPRequest, self), bstrHeader, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_getAllResponseHeaders(self: *const T, pbstrHeaders: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).getAllResponseHeaders(@ptrCast(*const IXMLHTTPRequest, self), pbstrHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).send(@ptrCast(*const IXMLHTTPRequest, self), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).abort(@ptrCast(*const IXMLHTTPRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_status(self: *const T, plStatus: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_status(@ptrCast(*const IXMLHTTPRequest, self), plStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_statusText(self: *const T, pbstrStatus: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_statusText(@ptrCast(*const IXMLHTTPRequest, self), pbstrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseXML(self: *const T, ppBody: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_responseXML(@ptrCast(*const IXMLHTTPRequest, self), ppBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseText(self: *const T, pbstrBody: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IXMLHTTPRequest, self), pbstrBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseBody(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_responseBody(@ptrCast(*const IXMLHTTPRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseStream(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_responseStream(@ptrCast(*const IXMLHTTPRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_readyState(self: *const T, plState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLHTTPRequest, self), plState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_put_onreadystatechange(self: *const T, pReadyStateSink: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IXMLHTTPRequest, self), pReadyStateSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SERVERXMLHTTP_OPTION = extern enum(i32) {
    URL = -1,
    URL_CODEPAGE = 0,
    ESCAPE_PERCENT_IN_URL = 1,
    IGNORE_SERVER_SSL_CERT_ERROR_FLAGS = 2,
    SELECT_CLIENT_SSL_CERT = 3,
};
pub const SXH_OPTION_URL = SERVERXMLHTTP_OPTION.URL;
pub const SXH_OPTION_URL_CODEPAGE = SERVERXMLHTTP_OPTION.URL_CODEPAGE;
pub const SXH_OPTION_ESCAPE_PERCENT_IN_URL = SERVERXMLHTTP_OPTION.ESCAPE_PERCENT_IN_URL;
pub const SXH_OPTION_IGNORE_SERVER_SSL_CERT_ERROR_FLAGS = SERVERXMLHTTP_OPTION.IGNORE_SERVER_SSL_CERT_ERROR_FLAGS;
pub const SXH_OPTION_SELECT_CLIENT_SSL_CERT = SERVERXMLHTTP_OPTION.SELECT_CLIENT_SSL_CERT;

pub const SXH_SERVER_CERT_OPTION = extern enum(i32) {
    UNKNOWN_CA = 256,
    WRONG_USAGE = 512,
    CERT_CN_INVALID = 4096,
    CERT_DATE_INVALID = 8192,
    ALL_SERVER_ERRORS = 13056,
};
pub const SXH_SERVER_CERT_IGNORE_UNKNOWN_CA = SXH_SERVER_CERT_OPTION.UNKNOWN_CA;
pub const SXH_SERVER_CERT_IGNORE_WRONG_USAGE = SXH_SERVER_CERT_OPTION.WRONG_USAGE;
pub const SXH_SERVER_CERT_IGNORE_CERT_CN_INVALID = SXH_SERVER_CERT_OPTION.CERT_CN_INVALID;
pub const SXH_SERVER_CERT_IGNORE_CERT_DATE_INVALID = SXH_SERVER_CERT_OPTION.CERT_DATE_INVALID;
pub const SXH_SERVER_CERT_IGNORE_ALL_SERVER_ERRORS = SXH_SERVER_CERT_OPTION.ALL_SERVER_ERRORS;

pub const SXH_PROXY_SETTING = extern enum(i32) {
    DEFAULT = 0,
    PRECONFIG = 0,
    DIRECT = 1,
    PROXY = 2,
};
pub const SXH_PROXY_SET_DEFAULT = SXH_PROXY_SETTING.DEFAULT;
pub const SXH_PROXY_SET_PRECONFIG = SXH_PROXY_SETTING.PRECONFIG;
pub const SXH_PROXY_SET_DIRECT = SXH_PROXY_SETTING.DIRECT;
pub const SXH_PROXY_SET_PROXY = SXH_PROXY_SETTING.PROXY;

const IID_IServerXMLHTTPRequest_Value = @import("../zig.zig").Guid.initString("2e9196bf-13ba-4dd4-91ca-6c571f281495");
pub const IID_IServerXMLHTTPRequest = &IID_IServerXMLHTTPRequest_Value;
pub const IServerXMLHTTPRequest = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest.VTable,
        setTimeouts: fn(
            self: *const IServerXMLHTTPRequest,
            resolveTimeout: i32,
            connectTimeout: i32,
            sendTimeout: i32,
            receiveTimeout: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        waitForResponse: fn(
            self: *const IServerXMLHTTPRequest,
            timeoutInSeconds: VARIANT,
            isSuccessful: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getOption: fn(
            self: *const IServerXMLHTTPRequest,
            option: SERVERXMLHTTP_OPTION,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setOption: fn(
            self: *const IServerXMLHTTPRequest,
            option: SERVERXMLHTTP_OPTION,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_setTimeouts(self: *const T, resolveTimeout: i32, connectTimeout: i32, sendTimeout: i32, receiveTimeout: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest.VTable, self.vtable).setTimeouts(@ptrCast(*const IServerXMLHTTPRequest, self), resolveTimeout, connectTimeout, sendTimeout, receiveTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_waitForResponse(self: *const T, timeoutInSeconds: VARIANT, isSuccessful: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest.VTable, self.vtable).waitForResponse(@ptrCast(*const IServerXMLHTTPRequest, self), timeoutInSeconds, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_getOption(self: *const T, option: SERVERXMLHTTP_OPTION, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest.VTable, self.vtable).getOption(@ptrCast(*const IServerXMLHTTPRequest, self), option, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_setOption(self: *const T, option: SERVERXMLHTTP_OPTION, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest.VTable, self.vtable).setOption(@ptrCast(*const IServerXMLHTTPRequest, self), option, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IServerXMLHTTPRequest2_Value = @import("../zig.zig").Guid.initString("2e01311b-c322-4b0a-bd77-b90cfdc8dce7");
pub const IID_IServerXMLHTTPRequest2 = &IID_IServerXMLHTTPRequest2_Value;
pub const IServerXMLHTTPRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IServerXMLHTTPRequest.VTable,
        setProxy: fn(
            self: *const IServerXMLHTTPRequest2,
            proxySetting: SXH_PROXY_SETTING,
            varProxyServer: VARIANT,
            varBypassList: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setProxyCredentials: fn(
            self: *const IServerXMLHTTPRequest2,
            bstrUserName: BSTR,
            bstrPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServerXMLHTTPRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest2_setProxy(self: *const T, proxySetting: SXH_PROXY_SETTING, varProxyServer: VARIANT, varBypassList: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest2.VTable, self.vtable).setProxy(@ptrCast(*const IServerXMLHTTPRequest2, self), proxySetting, varProxyServer, varBypassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest2_setProxyCredentials(self: *const T, bstrUserName: BSTR, bstrPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerXMLHTTPRequest2.VTable, self.vtable).setProxyCredentials(@ptrCast(*const IServerXMLHTTPRequest2, self), bstrUserName, bstrPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXXMLReader_Value = @import("../zig.zig").Guid.initString("a4f96ed0-f829-476e-81c0-cdc7bd2a0802");
pub const IID_ISAXXMLReader = &IID_ISAXXMLReader_Value;
pub const ISAXXMLReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getFeature: fn(
            self: *const ISAXXMLReader,
            pwchName: [*:0]const u16,
            pvfValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putFeature: fn(
            self: *const ISAXXMLReader,
            pwchName: [*:0]const u16,
            vfValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProperty: fn(
            self: *const ISAXXMLReader,
            pwchName: [*:0]const u16,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putProperty: fn(
            self: *const ISAXXMLReader,
            pwchName: [*:0]const u16,
            varValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEntityResolver: fn(
            self: *const ISAXXMLReader,
            ppResolver: **ISAXEntityResolver,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putEntityResolver: fn(
            self: *const ISAXXMLReader,
            pResolver: *ISAXEntityResolver,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getContentHandler: fn(
            self: *const ISAXXMLReader,
            ppHandler: **ISAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putContentHandler: fn(
            self: *const ISAXXMLReader,
            pHandler: *ISAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDTDHandler: fn(
            self: *const ISAXXMLReader,
            ppHandler: **ISAXDTDHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putDTDHandler: fn(
            self: *const ISAXXMLReader,
            pHandler: *ISAXDTDHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorHandler: fn(
            self: *const ISAXXMLReader,
            ppHandler: **ISAXErrorHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putErrorHandler: fn(
            self: *const ISAXXMLReader,
            pHandler: *ISAXErrorHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBaseURL: fn(
            self: *const ISAXXMLReader,
            ppwchBaseUrl: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putBaseURL: fn(
            self: *const ISAXXMLReader,
            pwchBaseUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSecureBaseURL: fn(
            self: *const ISAXXMLReader,
            ppwchSecureBaseUrl: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putSecureBaseURL: fn(
            self: *const ISAXXMLReader,
            pwchSecureBaseUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parse: fn(
            self: *const ISAXXMLReader,
            varInput: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parseURL: fn(
            self: *const ISAXXMLReader,
            pwchUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getFeature(self: *const T, pwchName: [*:0]const u16, pvfValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getFeature(@ptrCast(*const ISAXXMLReader, self), pwchName, pvfValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putFeature(self: *const T, pwchName: [*:0]const u16, vfValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putFeature(@ptrCast(*const ISAXXMLReader, self), pwchName, vfValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getProperty(self: *const T, pwchName: [*:0]const u16, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getProperty(@ptrCast(*const ISAXXMLReader, self), pwchName, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putProperty(self: *const T, pwchName: [*:0]const u16, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putProperty(@ptrCast(*const ISAXXMLReader, self), pwchName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getEntityResolver(self: *const T, ppResolver: **ISAXEntityResolver) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getEntityResolver(@ptrCast(*const ISAXXMLReader, self), ppResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putEntityResolver(self: *const T, pResolver: *ISAXEntityResolver) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putEntityResolver(@ptrCast(*const ISAXXMLReader, self), pResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getContentHandler(self: *const T, ppHandler: **ISAXContentHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getContentHandler(@ptrCast(*const ISAXXMLReader, self), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putContentHandler(self: *const T, pHandler: *ISAXContentHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putContentHandler(@ptrCast(*const ISAXXMLReader, self), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getDTDHandler(self: *const T, ppHandler: **ISAXDTDHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getDTDHandler(@ptrCast(*const ISAXXMLReader, self), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putDTDHandler(self: *const T, pHandler: *ISAXDTDHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putDTDHandler(@ptrCast(*const ISAXXMLReader, self), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getErrorHandler(self: *const T, ppHandler: **ISAXErrorHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getErrorHandler(@ptrCast(*const ISAXXMLReader, self), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putErrorHandler(self: *const T, pHandler: *ISAXErrorHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putErrorHandler(@ptrCast(*const ISAXXMLReader, self), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getBaseURL(self: *const T, ppwchBaseUrl: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getBaseURL(@ptrCast(*const ISAXXMLReader, self), ppwchBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putBaseURL(self: *const T, pwchBaseUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putBaseURL(@ptrCast(*const ISAXXMLReader, self), pwchBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getSecureBaseURL(self: *const T, ppwchSecureBaseUrl: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).getSecureBaseURL(@ptrCast(*const ISAXXMLReader, self), ppwchSecureBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putSecureBaseURL(self: *const T, pwchSecureBaseUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).putSecureBaseURL(@ptrCast(*const ISAXXMLReader, self), pwchSecureBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_parse(self: *const T, varInput: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).parse(@ptrCast(*const ISAXXMLReader, self), varInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_parseURL(self: *const T, pwchUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLReader.VTable, self.vtable).parseURL(@ptrCast(*const ISAXXMLReader, self), pwchUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXXMLFilter_Value = @import("../zig.zig").Guid.initString("70409222-ca09-4475-acb8-40312fe8d145");
pub const IID_ISAXXMLFilter = &IID_ISAXXMLFilter_Value;
pub const ISAXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: ISAXXMLReader.VTable,
        getParent: fn(
            self: *const ISAXXMLFilter,
            ppReader: **ISAXXMLReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putParent: fn(
            self: *const ISAXXMLFilter,
            pReader: *ISAXXMLReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISAXXMLReader.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLFilter_getParent(self: *const T, ppReader: **ISAXXMLReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLFilter.VTable, self.vtable).getParent(@ptrCast(*const ISAXXMLFilter, self), ppReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLFilter_putParent(self: *const T, pReader: *ISAXXMLReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXXMLFilter.VTable, self.vtable).putParent(@ptrCast(*const ISAXXMLFilter, self), pReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXLocator_Value = @import("../zig.zig").Guid.initString("9b7e472a-0de4-4640-bff3-84d38a051c31");
pub const IID_ISAXLocator = &IID_ISAXLocator_Value;
pub const ISAXLocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getColumnNumber: fn(
            self: *const ISAXLocator,
            pnColumn: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getLineNumber: fn(
            self: *const ISAXLocator,
            pnLine: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPublicId: fn(
            self: *const ISAXLocator,
            ppwchPublicId: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSystemId: fn(
            self: *const ISAXLocator,
            ppwchSystemId: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getColumnNumber(self: *const T, pnColumn: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLocator.VTable, self.vtable).getColumnNumber(@ptrCast(*const ISAXLocator, self), pnColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getLineNumber(self: *const T, pnLine: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLocator.VTable, self.vtable).getLineNumber(@ptrCast(*const ISAXLocator, self), pnLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getPublicId(self: *const T, ppwchPublicId: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLocator.VTable, self.vtable).getPublicId(@ptrCast(*const ISAXLocator, self), ppwchPublicId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getSystemId(self: *const T, ppwchSystemId: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLocator.VTable, self.vtable).getSystemId(@ptrCast(*const ISAXLocator, self), ppwchSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXEntityResolver_Value = @import("../zig.zig").Guid.initString("99bca7bd-e8c4-4d5f-a0cf-6d907901ff07");
pub const IID_ISAXEntityResolver = &IID_ISAXEntityResolver_Value;
pub const ISAXEntityResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        resolveEntity: fn(
            self: *const ISAXEntityResolver,
            pwchPublicId: [*:0]const u16,
            pwchSystemId: [*:0]const u16,
            pvarInput: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXEntityResolver_resolveEntity(self: *const T, pwchPublicId: [*:0]const u16, pwchSystemId: [*:0]const u16, pvarInput: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXEntityResolver.VTable, self.vtable).resolveEntity(@ptrCast(*const ISAXEntityResolver, self), pwchPublicId, pwchSystemId, pvarInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXContentHandler_Value = @import("../zig.zig").Guid.initString("1545cdfa-9e4e-4497-a8a4-2bf7d0112c44");
pub const IID_ISAXContentHandler = &IID_ISAXContentHandler_Value;
pub const ISAXContentHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        putDocumentLocator: fn(
            self: *const ISAXContentHandler,
            pLocator: *ISAXLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startDocument: fn(
            self: *const ISAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDocument: fn(
            self: *const ISAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startPrefixMapping: fn(
            self: *const ISAXContentHandler,
            pwchPrefix: [*:0]const u16,
            cchPrefix: i32,
            pwchUri: [*:0]const u16,
            cchUri: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endPrefixMapping: fn(
            self: *const ISAXContentHandler,
            pwchPrefix: [*:0]const u16,
            cchPrefix: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startElement: fn(
            self: *const ISAXContentHandler,
            pwchNamespaceUri: [*:0]const u16,
            cchNamespaceUri: i32,
            pwchLocalName: [*:0]const u16,
            cchLocalName: i32,
            pwchQName: [*:0]const u16,
            cchQName: i32,
            pAttributes: *ISAXAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endElement: fn(
            self: *const ISAXContentHandler,
            pwchNamespaceUri: [*:0]const u16,
            cchNamespaceUri: i32,
            pwchLocalName: [*:0]const u16,
            cchLocalName: i32,
            pwchQName: [*:0]const u16,
            cchQName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        characters: fn(
            self: *const ISAXContentHandler,
            pwchChars: [*:0]const u16,
            cchChars: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ignorableWhitespace: fn(
            self: *const ISAXContentHandler,
            pwchChars: [*:0]const u16,
            cchChars: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        processingInstruction: fn(
            self: *const ISAXContentHandler,
            pwchTarget: [*:0]const u16,
            cchTarget: i32,
            pwchData: [*:0]const u16,
            cchData: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skippedEntity: fn(
            self: *const ISAXContentHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_putDocumentLocator(self: *const T, pLocator: *ISAXLocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).putDocumentLocator(@ptrCast(*const ISAXContentHandler, self), pLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).startDocument(@ptrCast(*const ISAXContentHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).endDocument(@ptrCast(*const ISAXContentHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startPrefixMapping(self: *const T, pwchPrefix: [*:0]const u16, cchPrefix: i32, pwchUri: [*:0]const u16, cchUri: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).startPrefixMapping(@ptrCast(*const ISAXContentHandler, self), pwchPrefix, cchPrefix, pwchUri, cchUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endPrefixMapping(self: *const T, pwchPrefix: [*:0]const u16, cchPrefix: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).endPrefixMapping(@ptrCast(*const ISAXContentHandler, self), pwchPrefix, cchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startElement(self: *const T, pwchNamespaceUri: [*:0]const u16, cchNamespaceUri: i32, pwchLocalName: [*:0]const u16, cchLocalName: i32, pwchQName: [*:0]const u16, cchQName: i32, pAttributes: *ISAXAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).startElement(@ptrCast(*const ISAXContentHandler, self), pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endElement(self: *const T, pwchNamespaceUri: [*:0]const u16, cchNamespaceUri: i32, pwchLocalName: [*:0]const u16, cchLocalName: i32, pwchQName: [*:0]const u16, cchQName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).endElement(@ptrCast(*const ISAXContentHandler, self), pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_characters(self: *const T, pwchChars: [*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).characters(@ptrCast(*const ISAXContentHandler, self), pwchChars, cchChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_ignorableWhitespace(self: *const T, pwchChars: [*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).ignorableWhitespace(@ptrCast(*const ISAXContentHandler, self), pwchChars, cchChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_processingInstruction(self: *const T, pwchTarget: [*:0]const u16, cchTarget: i32, pwchData: [*:0]const u16, cchData: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).processingInstruction(@ptrCast(*const ISAXContentHandler, self), pwchTarget, cchTarget, pwchData, cchData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_skippedEntity(self: *const T, pwchName: [*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXContentHandler.VTable, self.vtable).skippedEntity(@ptrCast(*const ISAXContentHandler, self), pwchName, cchName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXDTDHandler_Value = @import("../zig.zig").Guid.initString("e15c1baf-afb3-4d60-8c36-19a8c45defed");
pub const IID_ISAXDTDHandler = &IID_ISAXDTDHandler_Value;
pub const ISAXDTDHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        notationDecl: fn(
            self: *const ISAXDTDHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchPublicId: [*:0]const u16,
            cchPublicId: i32,
            pwchSystemId: [*:0]const u16,
            cchSystemId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unparsedEntityDecl: fn(
            self: *const ISAXDTDHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchPublicId: [*:0]const u16,
            cchPublicId: i32,
            pwchSystemId: [*:0]const u16,
            cchSystemId: i32,
            pwchNotationName: [*:0]const u16,
            cchNotationName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDTDHandler_notationDecl(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchPublicId: [*:0]const u16, cchPublicId: i32, pwchSystemId: [*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDTDHandler.VTable, self.vtable).notationDecl(@ptrCast(*const ISAXDTDHandler, self), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDTDHandler_unparsedEntityDecl(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchPublicId: [*:0]const u16, cchPublicId: i32, pwchSystemId: [*:0]const u16, cchSystemId: i32, pwchNotationName: [*:0]const u16, cchNotationName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDTDHandler.VTable, self.vtable).unparsedEntityDecl(@ptrCast(*const ISAXDTDHandler, self), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId, pwchNotationName, cchNotationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXErrorHandler_Value = @import("../zig.zig").Guid.initString("a60511c4-ccf5-479e-98a3-dc8dc545b7d0");
pub const IID_ISAXErrorHandler = &IID_ISAXErrorHandler_Value;
pub const ISAXErrorHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        @"error": fn(
            self: *const ISAXErrorHandler,
            pLocator: *ISAXLocator,
            pwchErrorMessage: [*:0]const u16,
            hrErrorCode: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fatalError: fn(
            self: *const ISAXErrorHandler,
            pLocator: *ISAXLocator,
            pwchErrorMessage: [*:0]const u16,
            hrErrorCode: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ignorableWarning: fn(
            self: *const ISAXErrorHandler,
            pLocator: *ISAXLocator,
            pwchErrorMessage: [*:0]const u16,
            hrErrorCode: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_error(self: *const T, pLocator: *ISAXLocator, pwchErrorMessage: [*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXErrorHandler.VTable, self.vtable).@"error"(@ptrCast(*const ISAXErrorHandler, self), pLocator, pwchErrorMessage, hrErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_fatalError(self: *const T, pLocator: *ISAXLocator, pwchErrorMessage: [*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXErrorHandler.VTable, self.vtable).fatalError(@ptrCast(*const ISAXErrorHandler, self), pLocator, pwchErrorMessage, hrErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_ignorableWarning(self: *const T, pLocator: *ISAXLocator, pwchErrorMessage: [*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXErrorHandler.VTable, self.vtable).ignorableWarning(@ptrCast(*const ISAXErrorHandler, self), pLocator, pwchErrorMessage, hrErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXLexicalHandler_Value = @import("../zig.zig").Guid.initString("7f85d5f5-47a8-4497-bda5-84ba04819ea6");
pub const IID_ISAXLexicalHandler = &IID_ISAXLexicalHandler_Value;
pub const ISAXLexicalHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        startDTD: fn(
            self: *const ISAXLexicalHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchPublicId: [*:0]const u16,
            cchPublicId: i32,
            pwchSystemId: [*:0]const u16,
            cchSystemId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDTD: fn(
            self: *const ISAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startEntity: fn(
            self: *const ISAXLexicalHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endEntity: fn(
            self: *const ISAXLexicalHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startCDATA: fn(
            self: *const ISAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endCDATA: fn(
            self: *const ISAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        comment: fn(
            self: *const ISAXLexicalHandler,
            pwchChars: [*:0]const u16,
            cchChars: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startDTD(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchPublicId: [*:0]const u16, cchPublicId: i32, pwchSystemId: [*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).startDTD(@ptrCast(*const ISAXLexicalHandler, self), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endDTD(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).endDTD(@ptrCast(*const ISAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startEntity(self: *const T, pwchName: [*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).startEntity(@ptrCast(*const ISAXLexicalHandler, self), pwchName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endEntity(self: *const T, pwchName: [*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).endEntity(@ptrCast(*const ISAXLexicalHandler, self), pwchName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).startCDATA(@ptrCast(*const ISAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).endCDATA(@ptrCast(*const ISAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_comment(self: *const T, pwchChars: [*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXLexicalHandler.VTable, self.vtable).comment(@ptrCast(*const ISAXLexicalHandler, self), pwchChars, cchChars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXDeclHandler_Value = @import("../zig.zig").Guid.initString("862629ac-771a-47b2-8337-4e6843c1be90");
pub const IID_ISAXDeclHandler = &IID_ISAXDeclHandler_Value;
pub const ISAXDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        elementDecl: fn(
            self: *const ISAXDeclHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchModel: [*:0]const u16,
            cchModel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attributeDecl: fn(
            self: *const ISAXDeclHandler,
            pwchElementName: [*:0]const u16,
            cchElementName: i32,
            pwchAttributeName: [*:0]const u16,
            cchAttributeName: i32,
            pwchType: [*:0]const u16,
            cchType: i32,
            pwchValueDefault: [*:0]const u16,
            cchValueDefault: i32,
            pwchValue: [*:0]const u16,
            cchValue: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        internalEntityDecl: fn(
            self: *const ISAXDeclHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchValue: [*:0]const u16,
            cchValue: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        externalEntityDecl: fn(
            self: *const ISAXDeclHandler,
            pwchName: [*:0]const u16,
            cchName: i32,
            pwchPublicId: [*:0]const u16,
            cchPublicId: i32,
            pwchSystemId: [*:0]const u16,
            cchSystemId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_elementDecl(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchModel: [*:0]const u16, cchModel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDeclHandler.VTable, self.vtable).elementDecl(@ptrCast(*const ISAXDeclHandler, self), pwchName, cchName, pwchModel, cchModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_attributeDecl(self: *const T, pwchElementName: [*:0]const u16, cchElementName: i32, pwchAttributeName: [*:0]const u16, cchAttributeName: i32, pwchType: [*:0]const u16, cchType: i32, pwchValueDefault: [*:0]const u16, cchValueDefault: i32, pwchValue: [*:0]const u16, cchValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDeclHandler.VTable, self.vtable).attributeDecl(@ptrCast(*const ISAXDeclHandler, self), pwchElementName, cchElementName, pwchAttributeName, cchAttributeName, pwchType, cchType, pwchValueDefault, cchValueDefault, pwchValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_internalEntityDecl(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchValue: [*:0]const u16, cchValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDeclHandler.VTable, self.vtable).internalEntityDecl(@ptrCast(*const ISAXDeclHandler, self), pwchName, cchName, pwchValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_externalEntityDecl(self: *const T, pwchName: [*:0]const u16, cchName: i32, pwchPublicId: [*:0]const u16, cchPublicId: i32, pwchSystemId: [*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXDeclHandler.VTable, self.vtable).externalEntityDecl(@ptrCast(*const ISAXDeclHandler, self), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXAttributes_Value = @import("../zig.zig").Guid.initString("f078abe1-45d2-4832-91ea-4466ce2f25c9");
pub const IID_ISAXAttributes = &IID_ISAXAttributes_Value;
pub const ISAXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getLength: fn(
            self: *const ISAXAttributes,
            pnLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getURI: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchUri: *const *const u16,
            pcchUri: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getLocalName: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchLocalName: *const *const u16,
            pcchLocalName: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getQName: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchQName: *const *const u16,
            pcchQName: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getName: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchUri: *const *const u16,
            pcchUri: *i32,
            ppwchLocalName: *const *const u16,
            pcchLocalName: *i32,
            ppwchQName: *const *const u16,
            pcchQName: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIndexFromName: fn(
            self: *const ISAXAttributes,
            pwchUri: [*:0]const u16,
            cchUri: i32,
            pwchLocalName: [*:0]const u16,
            cchLocalName: i32,
            pnIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIndexFromQName: fn(
            self: *const ISAXAttributes,
            pwchQName: [*:0]const u16,
            cchQName: i32,
            pnIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getType: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchType: *const *const u16,
            pcchType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTypeFromName: fn(
            self: *const ISAXAttributes,
            pwchUri: [*:0]const u16,
            cchUri: i32,
            pwchLocalName: [*:0]const u16,
            cchLocalName: i32,
            ppwchType: *const *const u16,
            pcchType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTypeFromQName: fn(
            self: *const ISAXAttributes,
            pwchQName: [*:0]const u16,
            cchQName: i32,
            ppwchType: *const *const u16,
            pcchType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValue: fn(
            self: *const ISAXAttributes,
            nIndex: i32,
            ppwchValue: *const *const u16,
            pcchValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValueFromName: fn(
            self: *const ISAXAttributes,
            pwchUri: [*:0]const u16,
            cchUri: i32,
            pwchLocalName: [*:0]const u16,
            cchLocalName: i32,
            ppwchValue: *const *const u16,
            pcchValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValueFromQName: fn(
            self: *const ISAXAttributes,
            pwchQName: [*:0]const u16,
            cchQName: i32,
            ppwchValue: *const *const u16,
            pcchValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getLength(self: *const T, pnLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getLength(@ptrCast(*const ISAXAttributes, self), pnLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getURI(self: *const T, nIndex: i32, ppwchUri: *const *const u16, pcchUri: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getURI(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchUri, pcchUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getLocalName(self: *const T, nIndex: i32, ppwchLocalName: *const *const u16, pcchLocalName: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getLocalName(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchLocalName, pcchLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getQName(self: *const T, nIndex: i32, ppwchQName: *const *const u16, pcchQName: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getQName(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchQName, pcchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getName(self: *const T, nIndex: i32, ppwchUri: *const *const u16, pcchUri: *i32, ppwchLocalName: *const *const u16, pcchLocalName: *i32, ppwchQName: *const *const u16, pcchQName: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getName(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchUri, pcchUri, ppwchLocalName, pcchLocalName, ppwchQName, pcchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getIndexFromName(self: *const T, pwchUri: [*:0]const u16, cchUri: i32, pwchLocalName: [*:0]const u16, cchLocalName: i32, pnIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getIndexFromName(@ptrCast(*const ISAXAttributes, self), pwchUri, cchUri, pwchLocalName, cchLocalName, pnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getIndexFromQName(self: *const T, pwchQName: [*:0]const u16, cchQName: i32, pnIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getIndexFromQName(@ptrCast(*const ISAXAttributes, self), pwchQName, cchQName, pnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getType(self: *const T, nIndex: i32, ppwchType: *const *const u16, pcchType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getType(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getTypeFromName(self: *const T, pwchUri: [*:0]const u16, cchUri: i32, pwchLocalName: [*:0]const u16, cchLocalName: i32, ppwchType: *const *const u16, pcchType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getTypeFromName(@ptrCast(*const ISAXAttributes, self), pwchUri, cchUri, pwchLocalName, cchLocalName, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getTypeFromQName(self: *const T, pwchQName: [*:0]const u16, cchQName: i32, ppwchType: *const *const u16, pcchType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getTypeFromQName(@ptrCast(*const ISAXAttributes, self), pwchQName, cchQName, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValue(self: *const T, nIndex: i32, ppwchValue: *const *const u16, pcchValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getValue(@ptrCast(*const ISAXAttributes, self), nIndex, ppwchValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValueFromName(self: *const T, pwchUri: [*:0]const u16, cchUri: i32, pwchLocalName: [*:0]const u16, cchLocalName: i32, ppwchValue: *const *const u16, pcchValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getValueFromName(@ptrCast(*const ISAXAttributes, self), pwchUri, cchUri, pwchLocalName, cchLocalName, ppwchValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValueFromQName(self: *const T, pwchQName: [*:0]const u16, cchQName: i32, ppwchValue: *const *const u16, pcchValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISAXAttributes.VTable, self.vtable).getValueFromQName(@ptrCast(*const ISAXAttributes, self), pwchQName, cchQName, ppwchValue, pcchValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXXMLReader_Value = @import("../zig.zig").Guid.initString("8c033caa-6cd6-4f73-b728-4531af74945f");
pub const IID_IVBSAXXMLReader = &IID_IVBSAXXMLReader_Value;
pub const IVBSAXXMLReader = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getFeature: fn(
            self: *const IVBSAXXMLReader,
            strName: BSTR,
            fValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putFeature: fn(
            self: *const IVBSAXXMLReader,
            strName: BSTR,
            fValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProperty: fn(
            self: *const IVBSAXXMLReader,
            strName: BSTR,
            varValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putProperty: fn(
            self: *const IVBSAXXMLReader,
            strName: BSTR,
            varValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entityResolver: fn(
            self: *const IVBSAXXMLReader,
            oResolver: **IVBSAXEntityResolver,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_entityResolver: fn(
            self: *const IVBSAXXMLReader,
            oResolver: *IVBSAXEntityResolver,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: **IVBSAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_contentHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: *IVBSAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: **IVBSAXDTDHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dtdHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: *IVBSAXDTDHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: **IVBSAXErrorHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_errorHandler: fn(
            self: *const IVBSAXXMLReader,
            oHandler: *IVBSAXErrorHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseURL: fn(
            self: *const IVBSAXXMLReader,
            strBaseURL: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseURL: fn(
            self: *const IVBSAXXMLReader,
            strBaseURL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_secureBaseURL: fn(
            self: *const IVBSAXXMLReader,
            strSecureBaseURL: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_secureBaseURL: fn(
            self: *const IVBSAXXMLReader,
            strSecureBaseURL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parse: fn(
            self: *const IVBSAXXMLReader,
            varInput: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parseURL: fn(
            self: *const IVBSAXXMLReader,
            strURL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_getFeature(self: *const T, strName: BSTR, fValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).getFeature(@ptrCast(*const IVBSAXXMLReader, self), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putFeature(self: *const T, strName: BSTR, fValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putFeature(@ptrCast(*const IVBSAXXMLReader, self), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_getProperty(self: *const T, strName: BSTR, varValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).getProperty(@ptrCast(*const IVBSAXXMLReader, self), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putProperty(self: *const T, strName: BSTR, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putProperty(@ptrCast(*const IVBSAXXMLReader, self), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_entityResolver(self: *const T, oResolver: **IVBSAXEntityResolver) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_entityResolver(@ptrCast(*const IVBSAXXMLReader, self), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_entityResolver(self: *const T, oResolver: *IVBSAXEntityResolver) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putref_entityResolver(@ptrCast(*const IVBSAXXMLReader, self), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_contentHandler(self: *const T, oHandler: **IVBSAXContentHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_contentHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_contentHandler(self: *const T, oHandler: *IVBSAXContentHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putref_contentHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_dtdHandler(self: *const T, oHandler: **IVBSAXDTDHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_dtdHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_dtdHandler(self: *const T, oHandler: *IVBSAXDTDHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putref_dtdHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_errorHandler(self: *const T, oHandler: **IVBSAXErrorHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_errorHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_errorHandler(self: *const T, oHandler: *IVBSAXErrorHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).putref_errorHandler(@ptrCast(*const IVBSAXXMLReader, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_baseURL(self: *const T, strBaseURL: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_baseURL(@ptrCast(*const IVBSAXXMLReader, self), strBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_put_baseURL(self: *const T, strBaseURL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).put_baseURL(@ptrCast(*const IVBSAXXMLReader, self), strBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_secureBaseURL(self: *const T, strSecureBaseURL: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).get_secureBaseURL(@ptrCast(*const IVBSAXXMLReader, self), strSecureBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_put_secureBaseURL(self: *const T, strSecureBaseURL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).put_secureBaseURL(@ptrCast(*const IVBSAXXMLReader, self), strSecureBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_parse(self: *const T, varInput: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).parse(@ptrCast(*const IVBSAXXMLReader, self), varInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_parseURL(self: *const T, strURL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLReader.VTable, self.vtable).parseURL(@ptrCast(*const IVBSAXXMLReader, self), strURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXXMLFilter_Value = @import("../zig.zig").Guid.initString("1299eb1b-5b88-433e-82de-82ca75ad4e04");
pub const IID_IVBSAXXMLFilter = &IID_IVBSAXXMLFilter_Value;
pub const IVBSAXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: fn(
            self: *const IVBSAXXMLFilter,
            oReader: **IVBSAXXMLReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_parent: fn(
            self: *const IVBSAXXMLFilter,
            oReader: *IVBSAXXMLReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLFilter_get_parent(self: *const T, oReader: **IVBSAXXMLReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLFilter.VTable, self.vtable).get_parent(@ptrCast(*const IVBSAXXMLFilter, self), oReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLFilter_putref_parent(self: *const T, oReader: *IVBSAXXMLReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXXMLFilter.VTable, self.vtable).putref_parent(@ptrCast(*const IVBSAXXMLFilter, self), oReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXLocator_Value = @import("../zig.zig").Guid.initString("796e7ac5-5aa2-4eff-acad-3faaf01a3288");
pub const IID_IVBSAXLocator = &IID_IVBSAXLocator_Value;
pub const IVBSAXLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnNumber: fn(
            self: *const IVBSAXLocator,
            nColumn: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineNumber: fn(
            self: *const IVBSAXLocator,
            nLine: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: fn(
            self: *const IVBSAXLocator,
            strPublicId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: fn(
            self: *const IVBSAXLocator,
            strSystemId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_columnNumber(self: *const T, nColumn: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLocator.VTable, self.vtable).get_columnNumber(@ptrCast(*const IVBSAXLocator, self), nColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_lineNumber(self: *const T, nLine: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLocator.VTable, self.vtable).get_lineNumber(@ptrCast(*const IVBSAXLocator, self), nLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_publicId(self: *const T, strPublicId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLocator.VTable, self.vtable).get_publicId(@ptrCast(*const IVBSAXLocator, self), strPublicId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_systemId(self: *const T, strSystemId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLocator.VTable, self.vtable).get_systemId(@ptrCast(*const IVBSAXLocator, self), strSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXEntityResolver_Value = @import("../zig.zig").Guid.initString("0c05d096-f45b-4aca-ad1a-aa0bc25518dc");
pub const IID_IVBSAXEntityResolver = &IID_IVBSAXEntityResolver_Value;
pub const IVBSAXEntityResolver = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        resolveEntity: fn(
            self: *const IVBSAXEntityResolver,
            strPublicId: *BSTR,
            strSystemId: *BSTR,
            varInput: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXEntityResolver_resolveEntity(self: *const T, strPublicId: *BSTR, strSystemId: *BSTR, varInput: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXEntityResolver.VTable, self.vtable).resolveEntity(@ptrCast(*const IVBSAXEntityResolver, self), strPublicId, strSystemId, varInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXContentHandler_Value = @import("../zig.zig").Guid.initString("2ed7290a-4dd5-4b46-bb26-4e4155e77faa");
pub const IID_IVBSAXContentHandler = &IID_IVBSAXContentHandler_Value;
pub const IVBSAXContentHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_documentLocator: fn(
            self: *const IVBSAXContentHandler,
            oLocator: *IVBSAXLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startDocument: fn(
            self: *const IVBSAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDocument: fn(
            self: *const IVBSAXContentHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startPrefixMapping: fn(
            self: *const IVBSAXContentHandler,
            strPrefix: *BSTR,
            strURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endPrefixMapping: fn(
            self: *const IVBSAXContentHandler,
            strPrefix: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startElement: fn(
            self: *const IVBSAXContentHandler,
            strNamespaceURI: *BSTR,
            strLocalName: *BSTR,
            strQName: *BSTR,
            oAttributes: *IVBSAXAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endElement: fn(
            self: *const IVBSAXContentHandler,
            strNamespaceURI: *BSTR,
            strLocalName: *BSTR,
            strQName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        characters: fn(
            self: *const IVBSAXContentHandler,
            strChars: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ignorableWhitespace: fn(
            self: *const IVBSAXContentHandler,
            strChars: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        processingInstruction: fn(
            self: *const IVBSAXContentHandler,
            strTarget: *BSTR,
            strData: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skippedEntity: fn(
            self: *const IVBSAXContentHandler,
            strName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_putref_documentLocator(self: *const T, oLocator: *IVBSAXLocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).putref_documentLocator(@ptrCast(*const IVBSAXContentHandler, self), oLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).startDocument(@ptrCast(*const IVBSAXContentHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).endDocument(@ptrCast(*const IVBSAXContentHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startPrefixMapping(self: *const T, strPrefix: *BSTR, strURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).startPrefixMapping(@ptrCast(*const IVBSAXContentHandler, self), strPrefix, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endPrefixMapping(self: *const T, strPrefix: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).endPrefixMapping(@ptrCast(*const IVBSAXContentHandler, self), strPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startElement(self: *const T, strNamespaceURI: *BSTR, strLocalName: *BSTR, strQName: *BSTR, oAttributes: *IVBSAXAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).startElement(@ptrCast(*const IVBSAXContentHandler, self), strNamespaceURI, strLocalName, strQName, oAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endElement(self: *const T, strNamespaceURI: *BSTR, strLocalName: *BSTR, strQName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).endElement(@ptrCast(*const IVBSAXContentHandler, self), strNamespaceURI, strLocalName, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_characters(self: *const T, strChars: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).characters(@ptrCast(*const IVBSAXContentHandler, self), strChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_ignorableWhitespace(self: *const T, strChars: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).ignorableWhitespace(@ptrCast(*const IVBSAXContentHandler, self), strChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_processingInstruction(self: *const T, strTarget: *BSTR, strData: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).processingInstruction(@ptrCast(*const IVBSAXContentHandler, self), strTarget, strData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_skippedEntity(self: *const T, strName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXContentHandler.VTable, self.vtable).skippedEntity(@ptrCast(*const IVBSAXContentHandler, self), strName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXDTDHandler_Value = @import("../zig.zig").Guid.initString("24fb3297-302d-4620-ba39-3a732d850558");
pub const IID_IVBSAXDTDHandler = &IID_IVBSAXDTDHandler_Value;
pub const IVBSAXDTDHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        notationDecl: fn(
            self: *const IVBSAXDTDHandler,
            strName: *BSTR,
            strPublicId: *BSTR,
            strSystemId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unparsedEntityDecl: fn(
            self: *const IVBSAXDTDHandler,
            strName: *BSTR,
            strPublicId: *BSTR,
            strSystemId: *BSTR,
            strNotationName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDTDHandler_notationDecl(self: *const T, strName: *BSTR, strPublicId: *BSTR, strSystemId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDTDHandler.VTable, self.vtable).notationDecl(@ptrCast(*const IVBSAXDTDHandler, self), strName, strPublicId, strSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDTDHandler_unparsedEntityDecl(self: *const T, strName: *BSTR, strPublicId: *BSTR, strSystemId: *BSTR, strNotationName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDTDHandler.VTable, self.vtable).unparsedEntityDecl(@ptrCast(*const IVBSAXDTDHandler, self), strName, strPublicId, strSystemId, strNotationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXErrorHandler_Value = @import("../zig.zig").Guid.initString("d963d3fe-173c-4862-9095-b92f66995f52");
pub const IID_IVBSAXErrorHandler = &IID_IVBSAXErrorHandler_Value;
pub const IVBSAXErrorHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        @"error": fn(
            self: *const IVBSAXErrorHandler,
            oLocator: *IVBSAXLocator,
            strErrorMessage: *BSTR,
            nErrorCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fatalError: fn(
            self: *const IVBSAXErrorHandler,
            oLocator: *IVBSAXLocator,
            strErrorMessage: *BSTR,
            nErrorCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ignorableWarning: fn(
            self: *const IVBSAXErrorHandler,
            oLocator: *IVBSAXLocator,
            strErrorMessage: *BSTR,
            nErrorCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_error(self: *const T, oLocator: *IVBSAXLocator, strErrorMessage: *BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXErrorHandler.VTable, self.vtable).@"error"(@ptrCast(*const IVBSAXErrorHandler, self), oLocator, strErrorMessage, nErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_fatalError(self: *const T, oLocator: *IVBSAXLocator, strErrorMessage: *BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXErrorHandler.VTable, self.vtable).fatalError(@ptrCast(*const IVBSAXErrorHandler, self), oLocator, strErrorMessage, nErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_ignorableWarning(self: *const T, oLocator: *IVBSAXLocator, strErrorMessage: *BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXErrorHandler.VTable, self.vtable).ignorableWarning(@ptrCast(*const IVBSAXErrorHandler, self), oLocator, strErrorMessage, nErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXLexicalHandler_Value = @import("../zig.zig").Guid.initString("032aac35-8c0e-4d9d-979f-e3b702935576");
pub const IID_IVBSAXLexicalHandler = &IID_IVBSAXLexicalHandler_Value;
pub const IVBSAXLexicalHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDTD: fn(
            self: *const IVBSAXLexicalHandler,
            strName: *BSTR,
            strPublicId: *BSTR,
            strSystemId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDTD: fn(
            self: *const IVBSAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startEntity: fn(
            self: *const IVBSAXLexicalHandler,
            strName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endEntity: fn(
            self: *const IVBSAXLexicalHandler,
            strName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        startCDATA: fn(
            self: *const IVBSAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endCDATA: fn(
            self: *const IVBSAXLexicalHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        comment: fn(
            self: *const IVBSAXLexicalHandler,
            strChars: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startDTD(self: *const T, strName: *BSTR, strPublicId: *BSTR, strSystemId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).startDTD(@ptrCast(*const IVBSAXLexicalHandler, self), strName, strPublicId, strSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endDTD(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).endDTD(@ptrCast(*const IVBSAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startEntity(self: *const T, strName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).startEntity(@ptrCast(*const IVBSAXLexicalHandler, self), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endEntity(self: *const T, strName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).endEntity(@ptrCast(*const IVBSAXLexicalHandler, self), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).startCDATA(@ptrCast(*const IVBSAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).endCDATA(@ptrCast(*const IVBSAXLexicalHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_comment(self: *const T, strChars: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXLexicalHandler.VTable, self.vtable).comment(@ptrCast(*const IVBSAXLexicalHandler, self), strChars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXDeclHandler_Value = @import("../zig.zig").Guid.initString("e8917260-7579-4be1-b5dd-7afbfa6f077b");
pub const IID_IVBSAXDeclHandler = &IID_IVBSAXDeclHandler_Value;
pub const IVBSAXDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        elementDecl: fn(
            self: *const IVBSAXDeclHandler,
            strName: *BSTR,
            strModel: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attributeDecl: fn(
            self: *const IVBSAXDeclHandler,
            strElementName: *BSTR,
            strAttributeName: *BSTR,
            strType: *BSTR,
            strValueDefault: *BSTR,
            strValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        internalEntityDecl: fn(
            self: *const IVBSAXDeclHandler,
            strName: *BSTR,
            strValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        externalEntityDecl: fn(
            self: *const IVBSAXDeclHandler,
            strName: *BSTR,
            strPublicId: *BSTR,
            strSystemId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_elementDecl(self: *const T, strName: *BSTR, strModel: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDeclHandler.VTable, self.vtable).elementDecl(@ptrCast(*const IVBSAXDeclHandler, self), strName, strModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_attributeDecl(self: *const T, strElementName: *BSTR, strAttributeName: *BSTR, strType: *BSTR, strValueDefault: *BSTR, strValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDeclHandler.VTable, self.vtable).attributeDecl(@ptrCast(*const IVBSAXDeclHandler, self), strElementName, strAttributeName, strType, strValueDefault, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_internalEntityDecl(self: *const T, strName: *BSTR, strValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDeclHandler.VTable, self.vtable).internalEntityDecl(@ptrCast(*const IVBSAXDeclHandler, self), strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_externalEntityDecl(self: *const T, strName: *BSTR, strPublicId: *BSTR, strSystemId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXDeclHandler.VTable, self.vtable).externalEntityDecl(@ptrCast(*const IVBSAXDeclHandler, self), strName, strPublicId, strSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXAttributes_Value = @import("../zig.zig").Guid.initString("10dc0586-132b-4cac-8bb3-db00ac8b7ee0");
pub const IID_IVBSAXAttributes = &IID_IVBSAXAttributes_Value;
pub const IVBSAXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IVBSAXAttributes,
            nLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getURI: fn(
            self: *const IVBSAXAttributes,
            nIndex: i32,
            strURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getLocalName: fn(
            self: *const IVBSAXAttributes,
            nIndex: i32,
            strLocalName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getQName: fn(
            self: *const IVBSAXAttributes,
            nIndex: i32,
            strQName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIndexFromName: fn(
            self: *const IVBSAXAttributes,
            strURI: BSTR,
            strLocalName: BSTR,
            nIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIndexFromQName: fn(
            self: *const IVBSAXAttributes,
            strQName: BSTR,
            nIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getType: fn(
            self: *const IVBSAXAttributes,
            nIndex: i32,
            strType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTypeFromName: fn(
            self: *const IVBSAXAttributes,
            strURI: BSTR,
            strLocalName: BSTR,
            strType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTypeFromQName: fn(
            self: *const IVBSAXAttributes,
            strQName: BSTR,
            strType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValue: fn(
            self: *const IVBSAXAttributes,
            nIndex: i32,
            strValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValueFromName: fn(
            self: *const IVBSAXAttributes,
            strURI: BSTR,
            strLocalName: BSTR,
            strValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getValueFromQName: fn(
            self: *const IVBSAXAttributes,
            strQName: BSTR,
            strValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_get_length(self: *const T, nLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).get_length(@ptrCast(*const IVBSAXAttributes, self), nLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getURI(self: *const T, nIndex: i32, strURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getURI(@ptrCast(*const IVBSAXAttributes, self), nIndex, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getLocalName(self: *const T, nIndex: i32, strLocalName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getLocalName(@ptrCast(*const IVBSAXAttributes, self), nIndex, strLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getQName(self: *const T, nIndex: i32, strQName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getQName(@ptrCast(*const IVBSAXAttributes, self), nIndex, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getIndexFromName(self: *const T, strURI: BSTR, strLocalName: BSTR, nIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getIndexFromName(@ptrCast(*const IVBSAXAttributes, self), strURI, strLocalName, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getIndexFromQName(self: *const T, strQName: BSTR, nIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getIndexFromQName(@ptrCast(*const IVBSAXAttributes, self), strQName, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getType(self: *const T, nIndex: i32, strType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getType(@ptrCast(*const IVBSAXAttributes, self), nIndex, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getTypeFromName(self: *const T, strURI: BSTR, strLocalName: BSTR, strType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getTypeFromName(@ptrCast(*const IVBSAXAttributes, self), strURI, strLocalName, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getTypeFromQName(self: *const T, strQName: BSTR, strType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getTypeFromQName(@ptrCast(*const IVBSAXAttributes, self), strQName, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValue(self: *const T, nIndex: i32, strValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getValue(@ptrCast(*const IVBSAXAttributes, self), nIndex, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValueFromName(self: *const T, strURI: BSTR, strLocalName: BSTR, strValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getValueFromName(@ptrCast(*const IVBSAXAttributes, self), strURI, strLocalName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValueFromQName(self: *const T, strQName: BSTR, strValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBSAXAttributes.VTable, self.vtable).getValueFromQName(@ptrCast(*const IVBSAXAttributes, self), strQName, strValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXWriter_Value = @import("../zig.zig").Guid.initString("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d");
pub const IID_IMXWriter = &IID_IMXWriter_Value;
pub const IMXWriter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_output: fn(
            self: *const IMXWriter,
            varDestination: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_output: fn(
            self: *const IMXWriter,
            varDestination: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_encoding: fn(
            self: *const IMXWriter,
            strEncoding: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_encoding: fn(
            self: *const IMXWriter,
            strEncoding: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_byteOrderMark: fn(
            self: *const IMXWriter,
            fWriteByteOrderMark: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_byteOrderMark: fn(
            self: *const IMXWriter,
            fWriteByteOrderMark: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_indent: fn(
            self: *const IMXWriter,
            fIndentMode: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_indent: fn(
            self: *const IMXWriter,
            fIndentMode: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_standalone: fn(
            self: *const IMXWriter,
            fValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_standalone: fn(
            self: *const IMXWriter,
            fValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_omitXMLDeclaration: fn(
            self: *const IMXWriter,
            fValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_omitXMLDeclaration: fn(
            self: *const IMXWriter,
            fValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_version: fn(
            self: *const IMXWriter,
            strVersion: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const IMXWriter,
            strVersion: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disableOutputEscaping: fn(
            self: *const IMXWriter,
            fValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disableOutputEscaping: fn(
            self: *const IMXWriter,
            fValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        flush: fn(
            self: *const IMXWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_output(self: *const T, varDestination: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_output(@ptrCast(*const IMXWriter, self), varDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_output(self: *const T, varDestination: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_output(@ptrCast(*const IMXWriter, self), varDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_encoding(self: *const T, strEncoding: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_encoding(@ptrCast(*const IMXWriter, self), strEncoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_encoding(self: *const T, strEncoding: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_encoding(@ptrCast(*const IMXWriter, self), strEncoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_byteOrderMark(self: *const T, fWriteByteOrderMark: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_byteOrderMark(@ptrCast(*const IMXWriter, self), fWriteByteOrderMark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_byteOrderMark(self: *const T, fWriteByteOrderMark: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_byteOrderMark(@ptrCast(*const IMXWriter, self), fWriteByteOrderMark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_indent(self: *const T, fIndentMode: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_indent(@ptrCast(*const IMXWriter, self), fIndentMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_indent(self: *const T, fIndentMode: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_indent(@ptrCast(*const IMXWriter, self), fIndentMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_standalone(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_standalone(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_standalone(self: *const T, fValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_standalone(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_omitXMLDeclaration(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_omitXMLDeclaration(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_omitXMLDeclaration(self: *const T, fValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_omitXMLDeclaration(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_version(self: *const T, strVersion: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_version(@ptrCast(*const IMXWriter, self), strVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_version(self: *const T, strVersion: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_version(@ptrCast(*const IMXWriter, self), strVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_disableOutputEscaping(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).put_disableOutputEscaping(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_disableOutputEscaping(self: *const T, fValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).get_disableOutputEscaping(@ptrCast(*const IMXWriter, self), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXWriter.VTable, self.vtable).flush(@ptrCast(*const IMXWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXAttributes_Value = @import("../zig.zig").Guid.initString("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262");
pub const IID_IMXAttributes = &IID_IMXAttributes_Value;
pub const IMXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addAttribute: fn(
            self: *const IMXAttributes,
            strURI: BSTR,
            strLocalName: BSTR,
            strQName: BSTR,
            strType: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addAttributeFromIndex: fn(
            self: *const IMXAttributes,
            varAtts: VARIANT,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IMXAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IMXAttributes,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strURI: BSTR,
            strLocalName: BSTR,
            strQName: BSTR,
            strType: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributes: fn(
            self: *const IMXAttributes,
            varAtts: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setLocalName: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strLocalName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setQName: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strQName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setType: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setURI: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setValue: fn(
            self: *const IMXAttributes,
            nIndex: i32,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_addAttribute(self: *const T, strURI: BSTR, strLocalName: BSTR, strQName: BSTR, strType: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).addAttribute(@ptrCast(*const IMXAttributes, self), strURI, strLocalName, strQName, strType, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_addAttributeFromIndex(self: *const T, varAtts: VARIANT, nIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).addAttributeFromIndex(@ptrCast(*const IMXAttributes, self), varAtts, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).clear(@ptrCast(*const IMXAttributes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_removeAttribute(self: *const T, nIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).removeAttribute(@ptrCast(*const IMXAttributes, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setAttribute(self: *const T, nIndex: i32, strURI: BSTR, strLocalName: BSTR, strQName: BSTR, strType: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setAttribute(@ptrCast(*const IMXAttributes, self), nIndex, strURI, strLocalName, strQName, strType, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setAttributes(self: *const T, varAtts: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setAttributes(@ptrCast(*const IMXAttributes, self), varAtts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setLocalName(self: *const T, nIndex: i32, strLocalName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setLocalName(@ptrCast(*const IMXAttributes, self), nIndex, strLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setQName(self: *const T, nIndex: i32, strQName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setQName(@ptrCast(*const IMXAttributes, self), nIndex, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setType(self: *const T, nIndex: i32, strType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setType(@ptrCast(*const IMXAttributes, self), nIndex, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setURI(self: *const T, nIndex: i32, strURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setURI(@ptrCast(*const IMXAttributes, self), nIndex, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setValue(self: *const T, nIndex: i32, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXAttributes.VTable, self.vtable).setValue(@ptrCast(*const IMXAttributes, self), nIndex, strValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXReaderControl_Value = @import("../zig.zig").Guid.initString("808f4e35-8d5a-4fbe-8466-33a41279ed30");
pub const IID_IMXReaderControl = &IID_IMXReaderControl_Value;
pub const IMXReaderControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        abort: fn(
            self: *const IMXReaderControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        @"resume": fn(
            self: *const IMXReaderControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        @"suspend": fn(
            self: *const IMXReaderControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXReaderControl.VTable, self.vtable).abort(@ptrCast(*const IMXReaderControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXReaderControl.VTable, self.vtable).@"resume"(@ptrCast(*const IMXReaderControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXReaderControl.VTable, self.vtable).@"suspend"(@ptrCast(*const IMXReaderControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXSchemaDeclHandler_Value = @import("../zig.zig").Guid.initString("fa4bb38c-faf9-4cca-9302-d1dd0fe520db");
pub const IID_IMXSchemaDeclHandler = &IID_IMXSchemaDeclHandler_Value;
pub const IMXSchemaDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        schemaElementDecl: fn(
            self: *const IMXSchemaDeclHandler,
            oSchemaElement: *ISchemaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXSchemaDeclHandler_schemaElementDecl(self: *const T, oSchemaElement: *ISchemaElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXSchemaDeclHandler.VTable, self.vtable).schemaElementDecl(@ptrCast(*const IMXSchemaDeclHandler, self), oSchemaElement);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXNamespacePrefixes_Value = @import("../zig.zig").Guid.initString("c90352f4-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXNamespacePrefixes = &IID_IMXNamespacePrefixes_Value;
pub const IMXNamespacePrefixes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const IMXNamespacePrefixes,
            index: i32,
            prefix: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const IMXNamespacePrefixes,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const IMXNamespacePrefixes,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get_item(self: *const T, index: i32, prefix: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespacePrefixes.VTable, self.vtable).get_item(@ptrCast(*const IMXNamespacePrefixes, self), index, prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get_length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespacePrefixes.VTable, self.vtable).get_length(@ptrCast(*const IMXNamespacePrefixes, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespacePrefixes.VTable, self.vtable).get__newEnum(@ptrCast(*const IMXNamespacePrefixes, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBMXNamespaceManager_Value = @import("../zig.zig").Guid.initString("c90352f5-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IVBMXNamespaceManager = &IID_IVBMXNamespaceManager_Value;
pub const IVBMXNamespaceManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_allowOverride: fn(
            self: *const IVBMXNamespaceManager,
            fOverride: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allowOverride: fn(
            self: *const IVBMXNamespaceManager,
            fOverride: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IVBMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pushContext: fn(
            self: *const IVBMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pushNodeContext: fn(
            self: *const IVBMXNamespaceManager,
            contextNode: *IXMLDOMNode,
            fDeep: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        popContext: fn(
            self: *const IVBMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        declarePrefix: fn(
            self: *const IVBMXNamespaceManager,
            prefix: BSTR,
            namespaceURI: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDeclaredPrefixes: fn(
            self: *const IVBMXNamespaceManager,
            prefixes: **IMXNamespacePrefixes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPrefixes: fn(
            self: *const IVBMXNamespaceManager,
            namespaceURI: BSTR,
            prefixes: **IMXNamespacePrefixes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getURI: fn(
            self: *const IVBMXNamespaceManager,
            prefix: BSTR,
            uri: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getURIFromNode: fn(
            self: *const IVBMXNamespaceManager,
            strPrefix: BSTR,
            contextNode: *IXMLDOMNode,
            uri: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_put_allowOverride(self: *const T, fOverride: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).put_allowOverride(@ptrCast(*const IVBMXNamespaceManager, self), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_get_allowOverride(self: *const T, fOverride: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).get_allowOverride(@ptrCast(*const IVBMXNamespaceManager, self), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).reset(@ptrCast(*const IVBMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_pushContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).pushContext(@ptrCast(*const IVBMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_pushNodeContext(self: *const T, contextNode: *IXMLDOMNode, fDeep: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).pushNodeContext(@ptrCast(*const IVBMXNamespaceManager, self), contextNode, fDeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_popContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).popContext(@ptrCast(*const IVBMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_declarePrefix(self: *const T, prefix: BSTR, namespaceURI: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).declarePrefix(@ptrCast(*const IVBMXNamespaceManager, self), prefix, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getDeclaredPrefixes(self: *const T, prefixes: **IMXNamespacePrefixes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).getDeclaredPrefixes(@ptrCast(*const IVBMXNamespaceManager, self), prefixes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getPrefixes(self: *const T, namespaceURI: BSTR, prefixes: **IMXNamespacePrefixes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).getPrefixes(@ptrCast(*const IVBMXNamespaceManager, self), namespaceURI, prefixes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getURI(self: *const T, prefix: BSTR, uri: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).getURI(@ptrCast(*const IVBMXNamespaceManager, self), prefix, uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getURIFromNode(self: *const T, strPrefix: BSTR, contextNode: *IXMLDOMNode, uri: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVBMXNamespaceManager.VTable, self.vtable).getURIFromNode(@ptrCast(*const IVBMXNamespaceManager, self), strPrefix, contextNode, uri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXNamespaceManager_Value = @import("../zig.zig").Guid.initString("c90352f6-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXNamespaceManager = &IID_IMXNamespaceManager_Value;
pub const IMXNamespaceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        putAllowOverride: fn(
            self: *const IMXNamespaceManager,
            fOverride: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllowOverride: fn(
            self: *const IMXNamespaceManager,
            fOverride: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pushContext: fn(
            self: *const IMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pushNodeContext: fn(
            self: *const IMXNamespaceManager,
            contextNode: *IXMLDOMNode,
            fDeep: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        popContext: fn(
            self: *const IMXNamespaceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        declarePrefix: fn(
            self: *const IMXNamespaceManager,
            prefix: [*:0]const u16,
            namespaceURI: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDeclaredPrefix: fn(
            self: *const IMXNamespaceManager,
            nIndex: i32,
            pwchPrefix: [*:0]u16,
            pcchPrefix: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPrefix: fn(
            self: *const IMXNamespaceManager,
            pwszNamespaceURI: [*:0]const u16,
            nIndex: i32,
            pwchPrefix: [*:0]u16,
            pcchPrefix: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getURI: fn(
            self: *const IMXNamespaceManager,
            pwchPrefix: [*:0]const u16,
            pContextNode: *IXMLDOMNode,
            pwchUri: [*:0]u16,
            pcchUri: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_putAllowOverride(self: *const T, fOverride: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).putAllowOverride(@ptrCast(*const IMXNamespaceManager, self), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getAllowOverride(self: *const T, fOverride: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).getAllowOverride(@ptrCast(*const IMXNamespaceManager, self), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).reset(@ptrCast(*const IMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_pushContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).pushContext(@ptrCast(*const IMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_pushNodeContext(self: *const T, contextNode: *IXMLDOMNode, fDeep: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).pushNodeContext(@ptrCast(*const IMXNamespaceManager, self), contextNode, fDeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_popContext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).popContext(@ptrCast(*const IMXNamespaceManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_declarePrefix(self: *const T, prefix: [*:0]const u16, namespaceURI: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).declarePrefix(@ptrCast(*const IMXNamespaceManager, self), prefix, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getDeclaredPrefix(self: *const T, nIndex: i32, pwchPrefix: [*:0]u16, pcchPrefix: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).getDeclaredPrefix(@ptrCast(*const IMXNamespaceManager, self), nIndex, pwchPrefix, pcchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getPrefix(self: *const T, pwszNamespaceURI: [*:0]const u16, nIndex: i32, pwchPrefix: [*:0]u16, pcchPrefix: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).getPrefix(@ptrCast(*const IMXNamespaceManager, self), pwszNamespaceURI, nIndex, pwchPrefix, pcchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getURI(self: *const T, pwchPrefix: [*:0]const u16, pContextNode: *IXMLDOMNode, pwchUri: [*:0]u16, pcchUri: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXNamespaceManager.VTable, self.vtable).getURI(@ptrCast(*const IMXNamespaceManager, self), pwchPrefix, pContextNode, pwchUri, pcchUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXXMLFilter_Value = @import("../zig.zig").Guid.initString("c90352f7-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXXMLFilter = &IID_IMXXMLFilter_Value;
pub const IMXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getFeature: fn(
            self: *const IMXXMLFilter,
            strName: BSTR,
            fValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putFeature: fn(
            self: *const IMXXMLFilter,
            strName: BSTR,
            fValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProperty: fn(
            self: *const IMXXMLFilter,
            strName: BSTR,
            varValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putProperty: fn(
            self: *const IMXXMLFilter,
            strName: BSTR,
            varValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entityResolver: fn(
            self: *const IMXXMLFilter,
            oResolver: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_entityResolver: fn(
            self: *const IMXXMLFilter,
            oResolver: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_contentHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dtdHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_errorHandler: fn(
            self: *const IMXXMLFilter,
            oHandler: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_getFeature(self: *const T, strName: BSTR, fValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).getFeature(@ptrCast(*const IMXXMLFilter, self), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putFeature(self: *const T, strName: BSTR, fValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putFeature(@ptrCast(*const IMXXMLFilter, self), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_getProperty(self: *const T, strName: BSTR, varValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).getProperty(@ptrCast(*const IMXXMLFilter, self), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putProperty(self: *const T, strName: BSTR, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putProperty(@ptrCast(*const IMXXMLFilter, self), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_entityResolver(self: *const T, oResolver: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).get_entityResolver(@ptrCast(*const IMXXMLFilter, self), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_entityResolver(self: *const T, oResolver: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putref_entityResolver(@ptrCast(*const IMXXMLFilter, self), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_contentHandler(self: *const T, oHandler: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).get_contentHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_contentHandler(self: *const T, oHandler: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putref_contentHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_dtdHandler(self: *const T, oHandler: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).get_dtdHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_dtdHandler(self: *const T, oHandler: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putref_dtdHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_errorHandler(self: *const T, oHandler: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).get_errorHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_errorHandler(self: *const T, oHandler: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMXXMLFilter.VTable, self.vtable).putref_errorHandler(@ptrCast(*const IMXXMLFilter, self), oHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SOMITEMTYPE = extern enum(i32) {
    SCHEMA = 4096,
    ATTRIBUTE = 4097,
    ATTRIBUTEGROUP = 4098,
    NOTATION = 4099,
    ANNOTATION = 4100,
    IDENTITYCONSTRAINT = 4352,
    KEY = 4353,
    KEYREF = 4354,
    UNIQUE = 4355,
    ANYTYPE = 8192,
    DATATYPE = 8448,
    DATATYPE_ANYTYPE = 8449,
    DATATYPE_ANYURI = 8450,
    DATATYPE_BASE64BINARY = 8451,
    DATATYPE_BOOLEAN = 8452,
    DATATYPE_BYTE = 8453,
    DATATYPE_DATE = 8454,
    DATATYPE_DATETIME = 8455,
    DATATYPE_DAY = 8456,
    DATATYPE_DECIMAL = 8457,
    DATATYPE_DOUBLE = 8458,
    DATATYPE_DURATION = 8459,
    DATATYPE_ENTITIES = 8460,
    DATATYPE_ENTITY = 8461,
    DATATYPE_FLOAT = 8462,
    DATATYPE_HEXBINARY = 8463,
    DATATYPE_ID = 8464,
    DATATYPE_IDREF = 8465,
    DATATYPE_IDREFS = 8466,
    DATATYPE_INT = 8467,
    DATATYPE_INTEGER = 8468,
    DATATYPE_LANGUAGE = 8469,
    DATATYPE_LONG = 8470,
    DATATYPE_MONTH = 8471,
    DATATYPE_MONTHDAY = 8472,
    DATATYPE_NAME = 8473,
    DATATYPE_NCNAME = 8474,
    DATATYPE_NEGATIVEINTEGER = 8475,
    DATATYPE_NMTOKEN = 8476,
    DATATYPE_NMTOKENS = 8477,
    DATATYPE_NONNEGATIVEINTEGER = 8478,
    DATATYPE_NONPOSITIVEINTEGER = 8479,
    DATATYPE_NORMALIZEDSTRING = 8480,
    DATATYPE_NOTATION = 8481,
    DATATYPE_POSITIVEINTEGER = 8482,
    DATATYPE_QNAME = 8483,
    DATATYPE_SHORT = 8484,
    DATATYPE_STRING = 8485,
    DATATYPE_TIME = 8486,
    DATATYPE_TOKEN = 8487,
    DATATYPE_UNSIGNEDBYTE = 8488,
    DATATYPE_UNSIGNEDINT = 8489,
    DATATYPE_UNSIGNEDLONG = 8490,
    DATATYPE_UNSIGNEDSHORT = 8491,
    DATATYPE_YEAR = 8492,
    DATATYPE_YEARMONTH = 8493,
    DATATYPE_ANYSIMPLETYPE = 8703,
    SIMPLETYPE = 8704,
    COMPLEXTYPE = 9216,
    PARTICLE = 16384,
    ANY = 16385,
    ANYATTRIBUTE = 16386,
    ELEMENT = 16387,
    GROUP = 16640,
    ALL = 16641,
    CHOICE = 16642,
    SEQUENCE = 16643,
    EMPTYPARTICLE = 16644,
    NULL = 2048,
    NULL_TYPE = 10240,
    NULL_ANY = 18433,
    NULL_ANYATTRIBUTE = 18434,
    NULL_ELEMENT = 18435,
};
pub const SOMITEM_SCHEMA = SOMITEMTYPE.SCHEMA;
pub const SOMITEM_ATTRIBUTE = SOMITEMTYPE.ATTRIBUTE;
pub const SOMITEM_ATTRIBUTEGROUP = SOMITEMTYPE.ATTRIBUTEGROUP;
pub const SOMITEM_NOTATION = SOMITEMTYPE.NOTATION;
pub const SOMITEM_ANNOTATION = SOMITEMTYPE.ANNOTATION;
pub const SOMITEM_IDENTITYCONSTRAINT = SOMITEMTYPE.IDENTITYCONSTRAINT;
pub const SOMITEM_KEY = SOMITEMTYPE.KEY;
pub const SOMITEM_KEYREF = SOMITEMTYPE.KEYREF;
pub const SOMITEM_UNIQUE = SOMITEMTYPE.UNIQUE;
pub const SOMITEM_ANYTYPE = SOMITEMTYPE.ANYTYPE;
pub const SOMITEM_DATATYPE = SOMITEMTYPE.DATATYPE;
pub const SOMITEM_DATATYPE_ANYTYPE = SOMITEMTYPE.DATATYPE_ANYTYPE;
pub const SOMITEM_DATATYPE_ANYURI = SOMITEMTYPE.DATATYPE_ANYURI;
pub const SOMITEM_DATATYPE_BASE64BINARY = SOMITEMTYPE.DATATYPE_BASE64BINARY;
pub const SOMITEM_DATATYPE_BOOLEAN = SOMITEMTYPE.DATATYPE_BOOLEAN;
pub const SOMITEM_DATATYPE_BYTE = SOMITEMTYPE.DATATYPE_BYTE;
pub const SOMITEM_DATATYPE_DATE = SOMITEMTYPE.DATATYPE_DATE;
pub const SOMITEM_DATATYPE_DATETIME = SOMITEMTYPE.DATATYPE_DATETIME;
pub const SOMITEM_DATATYPE_DAY = SOMITEMTYPE.DATATYPE_DAY;
pub const SOMITEM_DATATYPE_DECIMAL = SOMITEMTYPE.DATATYPE_DECIMAL;
pub const SOMITEM_DATATYPE_DOUBLE = SOMITEMTYPE.DATATYPE_DOUBLE;
pub const SOMITEM_DATATYPE_DURATION = SOMITEMTYPE.DATATYPE_DURATION;
pub const SOMITEM_DATATYPE_ENTITIES = SOMITEMTYPE.DATATYPE_ENTITIES;
pub const SOMITEM_DATATYPE_ENTITY = SOMITEMTYPE.DATATYPE_ENTITY;
pub const SOMITEM_DATATYPE_FLOAT = SOMITEMTYPE.DATATYPE_FLOAT;
pub const SOMITEM_DATATYPE_HEXBINARY = SOMITEMTYPE.DATATYPE_HEXBINARY;
pub const SOMITEM_DATATYPE_ID = SOMITEMTYPE.DATATYPE_ID;
pub const SOMITEM_DATATYPE_IDREF = SOMITEMTYPE.DATATYPE_IDREF;
pub const SOMITEM_DATATYPE_IDREFS = SOMITEMTYPE.DATATYPE_IDREFS;
pub const SOMITEM_DATATYPE_INT = SOMITEMTYPE.DATATYPE_INT;
pub const SOMITEM_DATATYPE_INTEGER = SOMITEMTYPE.DATATYPE_INTEGER;
pub const SOMITEM_DATATYPE_LANGUAGE = SOMITEMTYPE.DATATYPE_LANGUAGE;
pub const SOMITEM_DATATYPE_LONG = SOMITEMTYPE.DATATYPE_LONG;
pub const SOMITEM_DATATYPE_MONTH = SOMITEMTYPE.DATATYPE_MONTH;
pub const SOMITEM_DATATYPE_MONTHDAY = SOMITEMTYPE.DATATYPE_MONTHDAY;
pub const SOMITEM_DATATYPE_NAME = SOMITEMTYPE.DATATYPE_NAME;
pub const SOMITEM_DATATYPE_NCNAME = SOMITEMTYPE.DATATYPE_NCNAME;
pub const SOMITEM_DATATYPE_NEGATIVEINTEGER = SOMITEMTYPE.DATATYPE_NEGATIVEINTEGER;
pub const SOMITEM_DATATYPE_NMTOKEN = SOMITEMTYPE.DATATYPE_NMTOKEN;
pub const SOMITEM_DATATYPE_NMTOKENS = SOMITEMTYPE.DATATYPE_NMTOKENS;
pub const SOMITEM_DATATYPE_NONNEGATIVEINTEGER = SOMITEMTYPE.DATATYPE_NONNEGATIVEINTEGER;
pub const SOMITEM_DATATYPE_NONPOSITIVEINTEGER = SOMITEMTYPE.DATATYPE_NONPOSITIVEINTEGER;
pub const SOMITEM_DATATYPE_NORMALIZEDSTRING = SOMITEMTYPE.DATATYPE_NORMALIZEDSTRING;
pub const SOMITEM_DATATYPE_NOTATION = SOMITEMTYPE.DATATYPE_NOTATION;
pub const SOMITEM_DATATYPE_POSITIVEINTEGER = SOMITEMTYPE.DATATYPE_POSITIVEINTEGER;
pub const SOMITEM_DATATYPE_QNAME = SOMITEMTYPE.DATATYPE_QNAME;
pub const SOMITEM_DATATYPE_SHORT = SOMITEMTYPE.DATATYPE_SHORT;
pub const SOMITEM_DATATYPE_STRING = SOMITEMTYPE.DATATYPE_STRING;
pub const SOMITEM_DATATYPE_TIME = SOMITEMTYPE.DATATYPE_TIME;
pub const SOMITEM_DATATYPE_TOKEN = SOMITEMTYPE.DATATYPE_TOKEN;
pub const SOMITEM_DATATYPE_UNSIGNEDBYTE = SOMITEMTYPE.DATATYPE_UNSIGNEDBYTE;
pub const SOMITEM_DATATYPE_UNSIGNEDINT = SOMITEMTYPE.DATATYPE_UNSIGNEDINT;
pub const SOMITEM_DATATYPE_UNSIGNEDLONG = SOMITEMTYPE.DATATYPE_UNSIGNEDLONG;
pub const SOMITEM_DATATYPE_UNSIGNEDSHORT = SOMITEMTYPE.DATATYPE_UNSIGNEDSHORT;
pub const SOMITEM_DATATYPE_YEAR = SOMITEMTYPE.DATATYPE_YEAR;
pub const SOMITEM_DATATYPE_YEARMONTH = SOMITEMTYPE.DATATYPE_YEARMONTH;
pub const SOMITEM_DATATYPE_ANYSIMPLETYPE = SOMITEMTYPE.DATATYPE_ANYSIMPLETYPE;
pub const SOMITEM_SIMPLETYPE = SOMITEMTYPE.SIMPLETYPE;
pub const SOMITEM_COMPLEXTYPE = SOMITEMTYPE.COMPLEXTYPE;
pub const SOMITEM_PARTICLE = SOMITEMTYPE.PARTICLE;
pub const SOMITEM_ANY = SOMITEMTYPE.ANY;
pub const SOMITEM_ANYATTRIBUTE = SOMITEMTYPE.ANYATTRIBUTE;
pub const SOMITEM_ELEMENT = SOMITEMTYPE.ELEMENT;
pub const SOMITEM_GROUP = SOMITEMTYPE.GROUP;
pub const SOMITEM_ALL = SOMITEMTYPE.ALL;
pub const SOMITEM_CHOICE = SOMITEMTYPE.CHOICE;
pub const SOMITEM_SEQUENCE = SOMITEMTYPE.SEQUENCE;
pub const SOMITEM_EMPTYPARTICLE = SOMITEMTYPE.EMPTYPARTICLE;
pub const SOMITEM_NULL = SOMITEMTYPE.NULL;
pub const SOMITEM_NULL_TYPE = SOMITEMTYPE.NULL_TYPE;
pub const SOMITEM_NULL_ANY = SOMITEMTYPE.NULL_ANY;
pub const SOMITEM_NULL_ANYATTRIBUTE = SOMITEMTYPE.NULL_ANYATTRIBUTE;
pub const SOMITEM_NULL_ELEMENT = SOMITEMTYPE.NULL_ELEMENT;

pub const SCHEMAUSE = extern enum(i32) {
    OPTIONAL = 0,
    PROHIBITED = 1,
    REQUIRED = 2,
};
pub const SCHEMAUSE_OPTIONAL = SCHEMAUSE.OPTIONAL;
pub const SCHEMAUSE_PROHIBITED = SCHEMAUSE.PROHIBITED;
pub const SCHEMAUSE_REQUIRED = SCHEMAUSE.REQUIRED;

pub const SCHEMADERIVATIONMETHOD = extern enum(i32) {
    EMPTY = 0,
    SUBSTITUTION = 1,
    EXTENSION = 2,
    RESTRICTION = 4,
    LIST = 8,
    UNION = 16,
    ALL = 255,
    NONE = 256,
};
pub const SCHEMADERIVATIONMETHOD_EMPTY = SCHEMADERIVATIONMETHOD.EMPTY;
pub const SCHEMADERIVATIONMETHOD_SUBSTITUTION = SCHEMADERIVATIONMETHOD.SUBSTITUTION;
pub const SCHEMADERIVATIONMETHOD_EXTENSION = SCHEMADERIVATIONMETHOD.EXTENSION;
pub const SCHEMADERIVATIONMETHOD_RESTRICTION = SCHEMADERIVATIONMETHOD.RESTRICTION;
pub const SCHEMADERIVATIONMETHOD_LIST = SCHEMADERIVATIONMETHOD.LIST;
pub const SCHEMADERIVATIONMETHOD_UNION = SCHEMADERIVATIONMETHOD.UNION;
pub const SCHEMADERIVATIONMETHOD_ALL = SCHEMADERIVATIONMETHOD.ALL;
pub const SCHEMADERIVATIONMETHOD_NONE = SCHEMADERIVATIONMETHOD.NONE;

pub const SCHEMACONTENTTYPE = extern enum(i32) {
    EMPTY = 0,
    TEXTONLY = 1,
    ELEMENTONLY = 2,
    MIXED = 3,
};
pub const SCHEMACONTENTTYPE_EMPTY = SCHEMACONTENTTYPE.EMPTY;
pub const SCHEMACONTENTTYPE_TEXTONLY = SCHEMACONTENTTYPE.TEXTONLY;
pub const SCHEMACONTENTTYPE_ELEMENTONLY = SCHEMACONTENTTYPE.ELEMENTONLY;
pub const SCHEMACONTENTTYPE_MIXED = SCHEMACONTENTTYPE.MIXED;

pub const SCHEMAPROCESSCONTENTS = extern enum(i32) {
    NONE = 0,
    SKIP = 1,
    LAX = 2,
    STRICT = 3,
};
pub const SCHEMAPROCESSCONTENTS_NONE = SCHEMAPROCESSCONTENTS.NONE;
pub const SCHEMAPROCESSCONTENTS_SKIP = SCHEMAPROCESSCONTENTS.SKIP;
pub const SCHEMAPROCESSCONTENTS_LAX = SCHEMAPROCESSCONTENTS.LAX;
pub const SCHEMAPROCESSCONTENTS_STRICT = SCHEMAPROCESSCONTENTS.STRICT;

pub const SCHEMAWHITESPACE = extern enum(i32) {
    NONE = -1,
    PRESERVE = 0,
    REPLACE = 1,
    COLLAPSE = 2,
};
pub const SCHEMAWHITESPACE_NONE = SCHEMAWHITESPACE.NONE;
pub const SCHEMAWHITESPACE_PRESERVE = SCHEMAWHITESPACE.PRESERVE;
pub const SCHEMAWHITESPACE_REPLACE = SCHEMAWHITESPACE.REPLACE;
pub const SCHEMAWHITESPACE_COLLAPSE = SCHEMAWHITESPACE.COLLAPSE;

pub const SCHEMATYPEVARIETY = extern enum(i32) {
    NONE = -1,
    ATOMIC = 0,
    LIST = 1,
    UNION = 2,
};
pub const SCHEMATYPEVARIETY_NONE = SCHEMATYPEVARIETY.NONE;
pub const SCHEMATYPEVARIETY_ATOMIC = SCHEMATYPEVARIETY.ATOMIC;
pub const SCHEMATYPEVARIETY_LIST = SCHEMATYPEVARIETY.LIST;
pub const SCHEMATYPEVARIETY_UNION = SCHEMATYPEVARIETY.UNION;

const IID_IXMLDOMSchemaCollection2_Value = @import("../zig.zig").Guid.initString("50ea08b0-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_IXMLDOMSchemaCollection2 = &IID_IXMLDOMSchemaCollection2_Value;
pub const IXMLDOMSchemaCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMSchemaCollection.VTable,
        validate: fn(
            self: *const IXMLDOMSchemaCollection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_validateOnLoad: fn(
            self: *const IXMLDOMSchemaCollection2,
            validateOnLoad: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_validateOnLoad: fn(
            self: *const IXMLDOMSchemaCollection2,
            validateOnLoad: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSchema: fn(
            self: *const IXMLDOMSchemaCollection2,
            namespaceURI: BSTR,
            schema: **ISchema,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDeclaration: fn(
            self: *const IXMLDOMSchemaCollection2,
            node: *IXMLDOMNode,
            item: **ISchemaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMSchemaCollection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_validate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection2.VTable, self.vtable).validate(@ptrCast(*const IXMLDOMSchemaCollection2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_put_validateOnLoad(self: *const T, validateOnLoad: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection2.VTable, self.vtable).put_validateOnLoad(@ptrCast(*const IXMLDOMSchemaCollection2, self), validateOnLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_get_validateOnLoad(self: *const T, validateOnLoad: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection2.VTable, self.vtable).get_validateOnLoad(@ptrCast(*const IXMLDOMSchemaCollection2, self), validateOnLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_getSchema(self: *const T, namespaceURI: BSTR, schema: **ISchema) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection2.VTable, self.vtable).getSchema(@ptrCast(*const IXMLDOMSchemaCollection2, self), namespaceURI, schema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_getDeclaration(self: *const T, node: *IXMLDOMNode, item: **ISchemaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMSchemaCollection2.VTable, self.vtable).getDeclaration(@ptrCast(*const IXMLDOMSchemaCollection2, self), node, item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaStringCollection_Value = @import("../zig.zig").Guid.initString("50ea08b1-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaStringCollection = &IID_ISchemaStringCollection_Value;
pub const ISchemaStringCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const ISchemaStringCollection,
            index: i32,
            bstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const ISchemaStringCollection,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const ISchemaStringCollection,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get_item(self: *const T, index: i32, bstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaStringCollection.VTable, self.vtable).get_item(@ptrCast(*const ISchemaStringCollection, self), index, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get_length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaStringCollection.VTable, self.vtable).get_length(@ptrCast(*const ISchemaStringCollection, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get__newEnum(self: *const T, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaStringCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const ISchemaStringCollection, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaItemCollection_Value = @import("../zig.zig").Guid.initString("50ea08b2-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaItemCollection = &IID_ISchemaItemCollection_Value;
pub const ISchemaItemCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: fn(
            self: *const ISchemaItemCollection,
            index: i32,
            item: **ISchemaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        itemByName: fn(
            self: *const ISchemaItemCollection,
            name: BSTR,
            item: **ISchemaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        itemByQName: fn(
            self: *const ISchemaItemCollection,
            name: BSTR,
            namespaceURI: BSTR,
            item: **ISchemaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const ISchemaItemCollection,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: fn(
            self: *const ISchemaItemCollection,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get_item(self: *const T, index: i32, item: **ISchemaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItemCollection.VTable, self.vtable).get_item(@ptrCast(*const ISchemaItemCollection, self), index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_itemByName(self: *const T, name: BSTR, item: **ISchemaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItemCollection.VTable, self.vtable).itemByName(@ptrCast(*const ISchemaItemCollection, self), name, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_itemByQName(self: *const T, name: BSTR, namespaceURI: BSTR, item: **ISchemaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItemCollection.VTable, self.vtable).itemByQName(@ptrCast(*const ISchemaItemCollection, self), name, namespaceURI, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get_length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItemCollection.VTable, self.vtable).get_length(@ptrCast(*const ISchemaItemCollection, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get__newEnum(self: *const T, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItemCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const ISchemaItemCollection, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaItem_Value = @import("../zig.zig").Guid.initString("50ea08b3-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaItem = &IID_ISchemaItem_Value;
pub const ISchemaItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: fn(
            self: *const ISchemaItem,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: fn(
            self: *const ISchemaItem,
            namespaceURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schema: fn(
            self: *const ISchemaItem,
            schema: **ISchema,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_id: fn(
            self: *const ISchemaItem,
            id: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_itemType: fn(
            self: *const ISchemaItem,
            itemType: *SOMITEMTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unhandledAttributes: fn(
            self: *const ISchemaItem,
            attributes: **IVBSAXAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        writeAnnotation: fn(
            self: *const ISchemaItem,
            annotationSink: *IUnknown,
            isWritten: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_name(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_name(@ptrCast(*const ISchemaItem, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_namespaceURI(self: *const T, namespaceURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_namespaceURI(@ptrCast(*const ISchemaItem, self), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_schema(self: *const T, schema: **ISchema) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_schema(@ptrCast(*const ISchemaItem, self), schema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_id(self: *const T, id: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_id(@ptrCast(*const ISchemaItem, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_itemType(self: *const T, itemType: *SOMITEMTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_itemType(@ptrCast(*const ISchemaItem, self), itemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_unhandledAttributes(self: *const T, attributes: **IVBSAXAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).get_unhandledAttributes(@ptrCast(*const ISchemaItem, self), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_writeAnnotation(self: *const T, annotationSink: *IUnknown, isWritten: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaItem.VTable, self.vtable).writeAnnotation(@ptrCast(*const ISchemaItem, self), annotationSink, isWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchema_Value = @import("../zig.zig").Guid.initString("50ea08b4-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchema = &IID_ISchema_Value;
pub const ISchema = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_targetNamespace: fn(
            self: *const ISchema,
            targetNamespace: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: fn(
            self: *const ISchema,
            version: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_types: fn(
            self: *const ISchema,
            types: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_elements: fn(
            self: *const ISchema,
            elements: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const ISchema,
            attributes: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributeGroups: fn(
            self: *const ISchema,
            attributeGroups: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_modelGroups: fn(
            self: *const ISchema,
            modelGroups: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notations: fn(
            self: *const ISchema,
            notations: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schemaLocations: fn(
            self: *const ISchema,
            schemaLocations: **ISchemaStringCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_targetNamespace(self: *const T, targetNamespace: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_targetNamespace(@ptrCast(*const ISchema, self), targetNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_version(self: *const T, version: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_version(@ptrCast(*const ISchema, self), version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_types(self: *const T, types: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_types(@ptrCast(*const ISchema, self), types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_elements(self: *const T, elements: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_elements(@ptrCast(*const ISchema, self), elements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_attributes(self: *const T, attributes: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_attributes(@ptrCast(*const ISchema, self), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_attributeGroups(self: *const T, attributeGroups: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_attributeGroups(@ptrCast(*const ISchema, self), attributeGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_modelGroups(self: *const T, modelGroups: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_modelGroups(@ptrCast(*const ISchema, self), modelGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_notations(self: *const T, notations: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_notations(@ptrCast(*const ISchema, self), notations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_schemaLocations(self: *const T, schemaLocations: **ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchema.VTable, self.vtable).get_schemaLocations(@ptrCast(*const ISchema, self), schemaLocations);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaParticle_Value = @import("../zig.zig").Guid.initString("50ea08b5-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaParticle = &IID_ISchemaParticle_Value;
pub const ISchemaParticle = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minOccurs: fn(
            self: *const ISchemaParticle,
            minOccurs: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxOccurs: fn(
            self: *const ISchemaParticle,
            maxOccurs: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaParticle_get_minOccurs(self: *const T, minOccurs: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaParticle.VTable, self.vtable).get_minOccurs(@ptrCast(*const ISchemaParticle, self), minOccurs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaParticle_get_maxOccurs(self: *const T, maxOccurs: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaParticle.VTable, self.vtable).get_maxOccurs(@ptrCast(*const ISchemaParticle, self), maxOccurs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAttribute_Value = @import("../zig.zig").Guid.initString("50ea08b6-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAttribute = &IID_ISchemaAttribute_Value;
pub const ISchemaAttribute = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const ISchemaAttribute,
            type: **ISchemaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scope: fn(
            self: *const ISchemaAttribute,
            scope: **ISchemaComplexType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: fn(
            self: *const ISchemaAttribute,
            defaultValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fixedValue: fn(
            self: *const ISchemaAttribute,
            fixedValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_use: fn(
            self: *const ISchemaAttribute,
            use: *SCHEMAUSE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isReference: fn(
            self: *const ISchemaAttribute,
            reference: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_type(self: *const T, type: **ISchemaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_type(@ptrCast(*const ISchemaAttribute, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_scope(self: *const T, scope: **ISchemaComplexType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_scope(@ptrCast(*const ISchemaAttribute, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_defaultValue(self: *const T, defaultValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_defaultValue(@ptrCast(*const ISchemaAttribute, self), defaultValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_fixedValue(self: *const T, fixedValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_fixedValue(@ptrCast(*const ISchemaAttribute, self), fixedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_use(self: *const T, use: *SCHEMAUSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_use(@ptrCast(*const ISchemaAttribute, self), use);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_isReference(self: *const T, reference: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttribute.VTable, self.vtable).get_isReference(@ptrCast(*const ISchemaAttribute, self), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaElement_Value = @import("../zig.zig").Guid.initString("50ea08b7-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaElement = &IID_ISchemaElement_Value;
pub const ISchemaElement = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: fn(
            self: *const ISchemaElement,
            type: **ISchemaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scope: fn(
            self: *const ISchemaElement,
            scope: **ISchemaComplexType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: fn(
            self: *const ISchemaElement,
            defaultValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fixedValue: fn(
            self: *const ISchemaElement,
            fixedValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isNillable: fn(
            self: *const ISchemaElement,
            nillable: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_identityConstraints: fn(
            self: *const ISchemaElement,
            constraints: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_substitutionGroup: fn(
            self: *const ISchemaElement,
            element: **ISchemaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_substitutionGroupExclusions: fn(
            self: *const ISchemaElement,
            exclusions: *SCHEMADERIVATIONMETHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disallowedSubstitutions: fn(
            self: *const ISchemaElement,
            disallowed: *SCHEMADERIVATIONMETHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAbstract: fn(
            self: *const ISchemaElement,
            abstract: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isReference: fn(
            self: *const ISchemaElement,
            reference: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_type(self: *const T, type: **ISchemaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_type(@ptrCast(*const ISchemaElement, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_scope(self: *const T, scope: **ISchemaComplexType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_scope(@ptrCast(*const ISchemaElement, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_defaultValue(self: *const T, defaultValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const ISchemaElement, self), defaultValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_fixedValue(self: *const T, fixedValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_fixedValue(@ptrCast(*const ISchemaElement, self), fixedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isNillable(self: *const T, nillable: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_isNillable(@ptrCast(*const ISchemaElement, self), nillable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_identityConstraints(self: *const T, constraints: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_identityConstraints(@ptrCast(*const ISchemaElement, self), constraints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_substitutionGroup(self: *const T, element: **ISchemaElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_substitutionGroup(@ptrCast(*const ISchemaElement, self), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_substitutionGroupExclusions(self: *const T, exclusions: *SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_substitutionGroupExclusions(@ptrCast(*const ISchemaElement, self), exclusions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_disallowedSubstitutions(self: *const T, disallowed: *SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_disallowedSubstitutions(@ptrCast(*const ISchemaElement, self), disallowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isAbstract(self: *const T, abstract: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_isAbstract(@ptrCast(*const ISchemaElement, self), abstract);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isReference(self: *const T, reference: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaElement.VTable, self.vtable).get_isReference(@ptrCast(*const ISchemaElement, self), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaType_Value = @import("../zig.zig").Guid.initString("50ea08b8-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaType = &IID_ISchemaType_Value;
pub const ISchemaType = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseTypes: fn(
            self: *const ISchemaType,
            baseTypes: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_final: fn(
            self: *const ISchemaType,
            final: *SCHEMADERIVATIONMETHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_variety: fn(
            self: *const ISchemaType,
            variety: *SCHEMATYPEVARIETY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_derivedBy: fn(
            self: *const ISchemaType,
            derivedBy: *SCHEMADERIVATIONMETHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isValid: fn(
            self: *const ISchemaType,
            data: BSTR,
            valid: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minExclusive: fn(
            self: *const ISchemaType,
            minExclusive: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minInclusive: fn(
            self: *const ISchemaType,
            minInclusive: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxExclusive: fn(
            self: *const ISchemaType,
            maxExclusive: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxInclusive: fn(
            self: *const ISchemaType,
            maxInclusive: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_totalDigits: fn(
            self: *const ISchemaType,
            totalDigits: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fractionDigits: fn(
            self: *const ISchemaType,
            fractionDigits: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: fn(
            self: *const ISchemaType,
            length: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minLength: fn(
            self: *const ISchemaType,
            minLength: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxLength: fn(
            self: *const ISchemaType,
            maxLength: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enumeration: fn(
            self: *const ISchemaType,
            enumeration: **ISchemaStringCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whitespace: fn(
            self: *const ISchemaType,
            whitespace: *SCHEMAWHITESPACE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_patterns: fn(
            self: *const ISchemaType,
            patterns: **ISchemaStringCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_baseTypes(self: *const T, baseTypes: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_baseTypes(@ptrCast(*const ISchemaType, self), baseTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_final(self: *const T, final: *SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_final(@ptrCast(*const ISchemaType, self), final);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_variety(self: *const T, variety: *SCHEMATYPEVARIETY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_variety(@ptrCast(*const ISchemaType, self), variety);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_derivedBy(self: *const T, derivedBy: *SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_derivedBy(@ptrCast(*const ISchemaType, self), derivedBy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_isValid(self: *const T, data: BSTR, valid: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).isValid(@ptrCast(*const ISchemaType, self), data, valid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minExclusive(self: *const T, minExclusive: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_minExclusive(@ptrCast(*const ISchemaType, self), minExclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minInclusive(self: *const T, minInclusive: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_minInclusive(@ptrCast(*const ISchemaType, self), minInclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxExclusive(self: *const T, maxExclusive: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_maxExclusive(@ptrCast(*const ISchemaType, self), maxExclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxInclusive(self: *const T, maxInclusive: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_maxInclusive(@ptrCast(*const ISchemaType, self), maxInclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_totalDigits(self: *const T, totalDigits: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_totalDigits(@ptrCast(*const ISchemaType, self), totalDigits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_fractionDigits(self: *const T, fractionDigits: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_fractionDigits(@ptrCast(*const ISchemaType, self), fractionDigits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_length(self: *const T, length: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_length(@ptrCast(*const ISchemaType, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minLength(self: *const T, minLength: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_minLength(@ptrCast(*const ISchemaType, self), minLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxLength(self: *const T, maxLength: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_maxLength(@ptrCast(*const ISchemaType, self), maxLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_enumeration(self: *const T, enumeration: **ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_enumeration(@ptrCast(*const ISchemaType, self), enumeration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_whitespace(self: *const T, whitespace: *SCHEMAWHITESPACE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_whitespace(@ptrCast(*const ISchemaType, self), whitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_patterns(self: *const T, patterns: **ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaType.VTable, self.vtable).get_patterns(@ptrCast(*const ISchemaType, self), patterns);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaComplexType_Value = @import("../zig.zig").Guid.initString("50ea08b9-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaComplexType = &IID_ISchemaComplexType_Value;
pub const ISchemaComplexType = extern struct {
    pub const VTable = extern struct {
        base: ISchemaType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAbstract: fn(
            self: *const ISchemaComplexType,
            abstract: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anyAttribute: fn(
            self: *const ISchemaComplexType,
            anyAttribute: **ISchemaAny,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const ISchemaComplexType,
            attributes: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentType: fn(
            self: *const ISchemaComplexType,
            contentType: *SCHEMACONTENTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentModel: fn(
            self: *const ISchemaComplexType,
            contentModel: **ISchemaModelGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prohibitedSubstitutions: fn(
            self: *const ISchemaComplexType,
            prohibited: *SCHEMADERIVATIONMETHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_isAbstract(self: *const T, abstract: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_isAbstract(@ptrCast(*const ISchemaComplexType, self), abstract);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_anyAttribute(self: *const T, anyAttribute: **ISchemaAny) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_anyAttribute(@ptrCast(*const ISchemaComplexType, self), anyAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_attributes(self: *const T, attributes: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_attributes(@ptrCast(*const ISchemaComplexType, self), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_contentType(self: *const T, contentType: *SCHEMACONTENTTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_contentType(@ptrCast(*const ISchemaComplexType, self), contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_contentModel(self: *const T, contentModel: **ISchemaModelGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_contentModel(@ptrCast(*const ISchemaComplexType, self), contentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_prohibitedSubstitutions(self: *const T, prohibited: *SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaComplexType.VTable, self.vtable).get_prohibitedSubstitutions(@ptrCast(*const ISchemaComplexType, self), prohibited);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAttributeGroup_Value = @import("../zig.zig").Guid.initString("50ea08ba-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAttributeGroup = &IID_ISchemaAttributeGroup_Value;
pub const ISchemaAttributeGroup = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anyAttribute: fn(
            self: *const ISchemaAttributeGroup,
            anyAttribute: **ISchemaAny,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: fn(
            self: *const ISchemaAttributeGroup,
            attributes: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttributeGroup_get_anyAttribute(self: *const T, anyAttribute: **ISchemaAny) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttributeGroup.VTable, self.vtable).get_anyAttribute(@ptrCast(*const ISchemaAttributeGroup, self), anyAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttributeGroup_get_attributes(self: *const T, attributes: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAttributeGroup.VTable, self.vtable).get_attributes(@ptrCast(*const ISchemaAttributeGroup, self), attributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaModelGroup_Value = @import("../zig.zig").Guid.initString("50ea08bb-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaModelGroup = &IID_ISchemaModelGroup_Value;
pub const ISchemaModelGroup = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_particles: fn(
            self: *const ISchemaModelGroup,
            particles: **ISchemaItemCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaModelGroup_get_particles(self: *const T, particles: **ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaModelGroup.VTable, self.vtable).get_particles(@ptrCast(*const ISchemaModelGroup, self), particles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAny_Value = @import("../zig.zig").Guid.initString("50ea08bc-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAny = &IID_ISchemaAny_Value;
pub const ISchemaAny = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaces: fn(
            self: *const ISchemaAny,
            namespaces: **ISchemaStringCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_processContents: fn(
            self: *const ISchemaAny,
            processContents: *SCHEMAPROCESSCONTENTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAny_get_namespaces(self: *const T, namespaces: **ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAny.VTable, self.vtable).get_namespaces(@ptrCast(*const ISchemaAny, self), namespaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAny_get_processContents(self: *const T, processContents: *SCHEMAPROCESSCONTENTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaAny.VTable, self.vtable).get_processContents(@ptrCast(*const ISchemaAny, self), processContents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaIdentityConstraint_Value = @import("../zig.zig").Guid.initString("50ea08bd-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaIdentityConstraint = &IID_ISchemaIdentityConstraint_Value;
pub const ISchemaIdentityConstraint = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selector: fn(
            self: *const ISchemaIdentityConstraint,
            selector: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fields: fn(
            self: *const ISchemaIdentityConstraint,
            fields: **ISchemaStringCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_referencedKey: fn(
            self: *const ISchemaIdentityConstraint,
            key: **ISchemaIdentityConstraint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_selector(self: *const T, selector: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaIdentityConstraint.VTable, self.vtable).get_selector(@ptrCast(*const ISchemaIdentityConstraint, self), selector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_fields(self: *const T, fields: **ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaIdentityConstraint.VTable, self.vtable).get_fields(@ptrCast(*const ISchemaIdentityConstraint, self), fields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_referencedKey(self: *const T, key: **ISchemaIdentityConstraint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaIdentityConstraint.VTable, self.vtable).get_referencedKey(@ptrCast(*const ISchemaIdentityConstraint, self), key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaNotation_Value = @import("../zig.zig").Guid.initString("50ea08be-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaNotation = &IID_ISchemaNotation_Value;
pub const ISchemaNotation = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemIdentifier: fn(
            self: *const ISchemaNotation,
            uri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicIdentifier: fn(
            self: *const ISchemaNotation,
            uri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaNotation_get_systemIdentifier(self: *const T, uri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaNotation.VTable, self.vtable).get_systemIdentifier(@ptrCast(*const ISchemaNotation, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaNotation_get_publicIdentifier(self: *const T, uri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaNotation.VTable, self.vtable).get_publicIdentifier(@ptrCast(*const ISchemaNotation, self), uri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __msxml6_ReferenceRemainingTypes__ = extern struct {
    __tagDomNodeType__: DOMNodeType,
    __domNodeType__: DOMNodeType,
    __serverXmlHttpOptionEnum__: SERVERXMLHTTP_OPTION,
    __serverXmlHttpOption__: SERVERXMLHTTP_OPTION,
    __serverCertOptionEnum__: SXH_SERVER_CERT_OPTION,
    __serverCertOption__: SXH_SERVER_CERT_OPTION,
    __proxySettingEnum__: SXH_PROXY_SETTING,
    __proxySetting__: SXH_PROXY_SETTING,
    __somItemTypeEnum__: SOMITEMTYPE,
    __somItemType__: SOMITEMTYPE,
    __schemaUseEnum__: SCHEMAUSE,
    __schemaUse__: SCHEMAUSE,
    __schemaDerivationMethodEnum__: SCHEMADERIVATIONMETHOD,
    __schemaDerivationMethod__: SCHEMADERIVATIONMETHOD,
    __schemaContentTypeEnum__: SCHEMACONTENTTYPE,
    __schemaContentType__: SCHEMACONTENTTYPE,
    __schemaProcessContentsEnum__: SCHEMAPROCESSCONTENTS,
    __schemaProcessContents__: SCHEMAPROCESSCONTENTS,
    __schemaWhitespaceEnum__: SCHEMAWHITESPACE,
    __schemaWhitespace__: SCHEMAWHITESPACE,
    __schemaTypeVarietyEnum__: SCHEMATYPEVARIETY,
    __schemaTypeVariety__: SCHEMATYPEVARIETY,
};

pub const XHR_COOKIE_STATE = extern enum(i32) {
    UNKNOWN = 0,
    ACCEPT = 1,
    PROMPT = 2,
    LEASH = 3,
    DOWNGRADE = 4,
    REJECT = 5,
};
pub const XHR_COOKIE_STATE_UNKNOWN = XHR_COOKIE_STATE.UNKNOWN;
pub const XHR_COOKIE_STATE_ACCEPT = XHR_COOKIE_STATE.ACCEPT;
pub const XHR_COOKIE_STATE_PROMPT = XHR_COOKIE_STATE.PROMPT;
pub const XHR_COOKIE_STATE_LEASH = XHR_COOKIE_STATE.LEASH;
pub const XHR_COOKIE_STATE_DOWNGRADE = XHR_COOKIE_STATE.DOWNGRADE;
pub const XHR_COOKIE_STATE_REJECT = XHR_COOKIE_STATE.REJECT;

pub const XHR_COOKIE_FLAG = extern enum(i32) {
    IS_SECURE = 1,
    IS_SESSION = 2,
    THIRD_PARTY = 16,
    PROMPT_REQUIRED = 32,
    EVALUATE_P3P = 64,
    APPLY_P3P = 128,
    P3P_ENABLED = 256,
    IS_RESTRICTED = 512,
    IE6 = 1024,
    IS_LEGACY = 2048,
    NON_SCRIPT = 4096,
    HTTPONLY = 8192,
};
pub const XHR_COOKIE_IS_SECURE = XHR_COOKIE_FLAG.IS_SECURE;
pub const XHR_COOKIE_IS_SESSION = XHR_COOKIE_FLAG.IS_SESSION;
pub const XHR_COOKIE_THIRD_PARTY = XHR_COOKIE_FLAG.THIRD_PARTY;
pub const XHR_COOKIE_PROMPT_REQUIRED = XHR_COOKIE_FLAG.PROMPT_REQUIRED;
pub const XHR_COOKIE_EVALUATE_P3P = XHR_COOKIE_FLAG.EVALUATE_P3P;
pub const XHR_COOKIE_APPLY_P3P = XHR_COOKIE_FLAG.APPLY_P3P;
pub const XHR_COOKIE_P3P_ENABLED = XHR_COOKIE_FLAG.P3P_ENABLED;
pub const XHR_COOKIE_IS_RESTRICTED = XHR_COOKIE_FLAG.IS_RESTRICTED;
pub const XHR_COOKIE_IE6 = XHR_COOKIE_FLAG.IE6;
pub const XHR_COOKIE_IS_LEGACY = XHR_COOKIE_FLAG.IS_LEGACY;
pub const XHR_COOKIE_NON_SCRIPT = XHR_COOKIE_FLAG.NON_SCRIPT;
pub const XHR_COOKIE_HTTPONLY = XHR_COOKIE_FLAG.HTTPONLY;

pub const XHR_CRED_PROMPT = extern enum(i32) {
    ALL = 0,
    NONE = 1,
    PROXY = 2,
};
pub const XHR_CRED_PROMPT_ALL = XHR_CRED_PROMPT.ALL;
pub const XHR_CRED_PROMPT_NONE = XHR_CRED_PROMPT.NONE;
pub const XHR_CRED_PROMPT_PROXY = XHR_CRED_PROMPT.PROXY;

pub const XHR_AUTH = extern enum(i32) {
    ALL = 0,
    NONE = 1,
    PROXY = 2,
};
pub const XHR_AUTH_ALL = XHR_AUTH.ALL;
pub const XHR_AUTH_NONE = XHR_AUTH.NONE;
pub const XHR_AUTH_PROXY = XHR_AUTH.PROXY;

pub const XHR_PROPERTY = extern enum(i32) {
    NO_CRED_PROMPT = 0,
    NO_AUTH = 1,
    TIMEOUT = 2,
    NO_DEFAULT_HEADERS = 3,
    REPORT_REDIRECT_STATUS = 4,
    NO_CACHE = 5,
    EXTENDED_ERROR = 6,
    QUERY_STRING_UTF8 = 7,
    IGNORE_CERT_ERRORS = 8,
    ONDATA_THRESHOLD = 9,
    SET_ENTERPRISEID = 10,
    MAX_CONNECTIONS = 11,
};
pub const XHR_PROP_NO_CRED_PROMPT = XHR_PROPERTY.NO_CRED_PROMPT;
pub const XHR_PROP_NO_AUTH = XHR_PROPERTY.NO_AUTH;
pub const XHR_PROP_TIMEOUT = XHR_PROPERTY.TIMEOUT;
pub const XHR_PROP_NO_DEFAULT_HEADERS = XHR_PROPERTY.NO_DEFAULT_HEADERS;
pub const XHR_PROP_REPORT_REDIRECT_STATUS = XHR_PROPERTY.REPORT_REDIRECT_STATUS;
pub const XHR_PROP_NO_CACHE = XHR_PROPERTY.NO_CACHE;
pub const XHR_PROP_EXTENDED_ERROR = XHR_PROPERTY.EXTENDED_ERROR;
pub const XHR_PROP_QUERY_STRING_UTF8 = XHR_PROPERTY.QUERY_STRING_UTF8;
pub const XHR_PROP_IGNORE_CERT_ERRORS = XHR_PROPERTY.IGNORE_CERT_ERRORS;
pub const XHR_PROP_ONDATA_THRESHOLD = XHR_PROPERTY.ONDATA_THRESHOLD;
pub const XHR_PROP_SET_ENTERPRISEID = XHR_PROPERTY.SET_ENTERPRISEID;
pub const XHR_PROP_MAX_CONNECTIONS = XHR_PROPERTY.MAX_CONNECTIONS;

pub const XHR_CERT_IGNORE_FLAG = extern enum(u32) {
    REVOCATION_FAILED = 128,
    UNKNOWN_CA = 256,
    CERT_CN_INVALID = 4096,
    CERT_DATE_INVALID = 8192,
    ALL_SERVER_ERRORS = 12672,
};
pub const XHR_CERT_IGNORE_REVOCATION_FAILED = XHR_CERT_IGNORE_FLAG.REVOCATION_FAILED;
pub const XHR_CERT_IGNORE_UNKNOWN_CA = XHR_CERT_IGNORE_FLAG.UNKNOWN_CA;
pub const XHR_CERT_IGNORE_CERT_CN_INVALID = XHR_CERT_IGNORE_FLAG.CERT_CN_INVALID;
pub const XHR_CERT_IGNORE_CERT_DATE_INVALID = XHR_CERT_IGNORE_FLAG.CERT_DATE_INVALID;
pub const XHR_CERT_IGNORE_ALL_SERVER_ERRORS = XHR_CERT_IGNORE_FLAG.ALL_SERVER_ERRORS;

pub const XHR_CERT_ERROR_FLAG = extern enum(u32) {
    REVOCATION_FAILED = 8388608,
    UNKNOWN_CA = 16777216,
    CERT_CN_INVALID = 33554432,
    CERT_DATE_INVALID = 67108864,
    ALL_SERVER_ERRORS = 125829120,
};
pub const XHR_CERT_ERROR_REVOCATION_FAILED = XHR_CERT_ERROR_FLAG.REVOCATION_FAILED;
pub const XHR_CERT_ERROR_UNKNOWN_CA = XHR_CERT_ERROR_FLAG.UNKNOWN_CA;
pub const XHR_CERT_ERROR_CERT_CN_INVALID = XHR_CERT_ERROR_FLAG.CERT_CN_INVALID;
pub const XHR_CERT_ERROR_CERT_DATE_INVALID = XHR_CERT_ERROR_FLAG.CERT_DATE_INVALID;
pub const XHR_CERT_ERROR_ALL_SERVER_ERRORS = XHR_CERT_ERROR_FLAG.ALL_SERVER_ERRORS;

pub const XHR_COOKIE = extern struct {
    pwszUrl: PWSTR,
    pwszName: PWSTR,
    pwszValue: PWSTR,
    pwszP3PPolicy: PWSTR,
    ftExpires: FILETIME,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest2Callback_Value = @import("../zig.zig").Guid.initString("a44a9299-e321-40de-8866-341b41669162");
pub const IID_IXMLHTTPRequest2Callback = &IID_IXMLHTTPRequest2Callback_Value;
pub const IXMLHTTPRequest2Callback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRedirect: fn(
            self: *const IXMLHTTPRequest2Callback,
            pXHR: *IXMLHTTPRequest2,
            pwszRedirectUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnHeadersAvailable: fn(
            self: *const IXMLHTTPRequest2Callback,
            pXHR: *IXMLHTTPRequest2,
            dwStatus: u32,
            pwszStatus: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataAvailable: fn(
            self: *const IXMLHTTPRequest2Callback,
            pXHR: *IXMLHTTPRequest2,
            pResponseStream: *ISequentialStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnResponseReceived: fn(
            self: *const IXMLHTTPRequest2Callback,
            pXHR: *IXMLHTTPRequest2,
            pResponseStream: *ISequentialStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnError: fn(
            self: *const IXMLHTTPRequest2Callback,
            pXHR: *IXMLHTTPRequest2,
            hrError: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnRedirect(self: *const T, pXHR: *IXMLHTTPRequest2, pwszRedirectUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2Callback.VTable, self.vtable).OnRedirect(@ptrCast(*const IXMLHTTPRequest2Callback, self), pXHR, pwszRedirectUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnHeadersAvailable(self: *const T, pXHR: *IXMLHTTPRequest2, dwStatus: u32, pwszStatus: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2Callback.VTable, self.vtable).OnHeadersAvailable(@ptrCast(*const IXMLHTTPRequest2Callback, self), pXHR, dwStatus, pwszStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnDataAvailable(self: *const T, pXHR: *IXMLHTTPRequest2, pResponseStream: *ISequentialStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2Callback.VTable, self.vtable).OnDataAvailable(@ptrCast(*const IXMLHTTPRequest2Callback, self), pXHR, pResponseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnResponseReceived(self: *const T, pXHR: *IXMLHTTPRequest2, pResponseStream: *ISequentialStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2Callback.VTable, self.vtable).OnResponseReceived(@ptrCast(*const IXMLHTTPRequest2Callback, self), pXHR, pResponseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnError(self: *const T, pXHR: *IXMLHTTPRequest2, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2Callback.VTable, self.vtable).OnError(@ptrCast(*const IXMLHTTPRequest2Callback, self), pXHR, hrError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest2_Value = @import("../zig.zig").Guid.initString("e5d37dc0-552a-4d52-9cc0-a14d546fbd04");
pub const IID_IXMLHTTPRequest2 = &IID_IXMLHTTPRequest2_Value;
pub const IXMLHTTPRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IXMLHTTPRequest2,
            pwszMethod: [*:0]const u16,
            pwszUrl: [*:0]const u16,
            pStatusCallback: *IXMLHTTPRequest2Callback,
            pwszUserName: [*:0]const u16,
            pwszPassword: [*:0]const u16,
            pwszProxyUserName: [*:0]const u16,
            pwszProxyPassword: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Send: fn(
            self: *const IXMLHTTPRequest2,
            pBody: *ISequentialStream,
            cbBody: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IXMLHTTPRequest2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: fn(
            self: *const IXMLHTTPRequest2,
            pCookie: *const XHR_COOKIE,
            pdwCookieState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCustomResponseStream: fn(
            self: *const IXMLHTTPRequest2,
            pSequentialStream: *ISequentialStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXMLHTTPRequest2,
            eProperty: XHR_PROPERTY,
            ullValue: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRequestHeader: fn(
            self: *const IXMLHTTPRequest2,
            pwszHeader: [*:0]const u16,
            pwszValue: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllResponseHeaders: fn(
            self: *const IXMLHTTPRequest2,
            ppwszHeaders: **u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: fn(
            self: *const IXMLHTTPRequest2,
            pwszUrl: [*:0]const u16,
            pwszName: [*:0]const u16,
            dwFlags: u32,
            pcCookies: *u32,
            ppCookies: [*]*XHR_COOKIE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResponseHeader: fn(
            self: *const IXMLHTTPRequest2,
            pwszHeader: [*:0]const u16,
            ppwszValue: **u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Open(self: *const T, pwszMethod: [*:0]const u16, pwszUrl: [*:0]const u16, pStatusCallback: *IXMLHTTPRequest2Callback, pwszUserName: [*:0]const u16, pwszPassword: [*:0]const u16, pwszProxyUserName: [*:0]const u16, pwszProxyPassword: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).Open(@ptrCast(*const IXMLHTTPRequest2, self), pwszMethod, pwszUrl, pStatusCallback, pwszUserName, pwszPassword, pwszProxyUserName, pwszProxyPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Send(self: *const T, pBody: *ISequentialStream, cbBody: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).Send(@ptrCast(*const IXMLHTTPRequest2, self), pBody, cbBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).Abort(@ptrCast(*const IXMLHTTPRequest2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetCookie(self: *const T, pCookie: *const XHR_COOKIE, pdwCookieState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).SetCookie(@ptrCast(*const IXMLHTTPRequest2, self), pCookie, pdwCookieState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetCustomResponseStream(self: *const T, pSequentialStream: *ISequentialStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).SetCustomResponseStream(@ptrCast(*const IXMLHTTPRequest2, self), pSequentialStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetProperty(self: *const T, eProperty: XHR_PROPERTY, ullValue: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).SetProperty(@ptrCast(*const IXMLHTTPRequest2, self), eProperty, ullValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetRequestHeader(self: *const T, pwszHeader: [*:0]const u16, pwszValue: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).SetRequestHeader(@ptrCast(*const IXMLHTTPRequest2, self), pwszHeader, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetAllResponseHeaders(self: *const T, ppwszHeaders: **u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).GetAllResponseHeaders(@ptrCast(*const IXMLHTTPRequest2, self), ppwszHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetCookie(self: *const T, pwszUrl: [*:0]const u16, pwszName: [*:0]const u16, dwFlags: u32, pcCookies: *u32, ppCookies: [*]*XHR_COOKIE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).GetCookie(@ptrCast(*const IXMLHTTPRequest2, self), pwszUrl, pwszName, dwFlags, pcCookies, ppCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetResponseHeader(self: *const T, pwszHeader: [*:0]const u16, ppwszValue: **u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest2.VTable, self.vtable).GetResponseHeader(@ptrCast(*const IXMLHTTPRequest2, self), pwszHeader, ppwszValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const XHR_CERT = extern struct {
    cbCert: u32,
    pbCert: *u8,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest3Callback_Value = @import("../zig.zig").Guid.initString("b9e57830-8c6c-4a6f-9c13-47772bb047bb");
pub const IID_IXMLHTTPRequest3Callback = &IID_IXMLHTTPRequest3Callback_Value;
pub const IXMLHTTPRequest3Callback = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest2Callback.VTable,
        OnServerCertificateReceived: fn(
            self: *const IXMLHTTPRequest3Callback,
            pXHR: *IXMLHTTPRequest3,
            dwCertificateErrors: u32,
            cServerCertificateChain: u32,
            rgServerCertificateChain: [*]const XHR_CERT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClientCertificateRequested: fn(
            self: *const IXMLHTTPRequest3Callback,
            pXHR: *IXMLHTTPRequest3,
            cIssuerList: u32,
            rgpwszIssuerList: [*]const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest2Callback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3Callback_OnServerCertificateReceived(self: *const T, pXHR: *IXMLHTTPRequest3, dwCertificateErrors: u32, cServerCertificateChain: u32, rgServerCertificateChain: [*]const XHR_CERT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest3Callback.VTable, self.vtable).OnServerCertificateReceived(@ptrCast(*const IXMLHTTPRequest3Callback, self), pXHR, dwCertificateErrors, cServerCertificateChain, rgServerCertificateChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3Callback_OnClientCertificateRequested(self: *const T, pXHR: *IXMLHTTPRequest3, cIssuerList: u32, rgpwszIssuerList: [*]const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest3Callback.VTable, self.vtable).OnClientCertificateRequested(@ptrCast(*const IXMLHTTPRequest3Callback, self), pXHR, cIssuerList, rgpwszIssuerList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest3_Value = @import("../zig.zig").Guid.initString("a1c9feee-0617-4f23-9d58-8961ea43567c");
pub const IID_IXMLHTTPRequest3 = &IID_IXMLHTTPRequest3_Value;
pub const IXMLHTTPRequest3 = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest2.VTable,
        SetClientCertificate: fn(
            self: *const IXMLHTTPRequest3,
            cbClientCertificateHash: u32,
            pbClientCertificateHash: [*:0]const u8,
            pwszPin: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3_SetClientCertificate(self: *const T, cbClientCertificateHash: u32, pbClientCertificateHash: [*:0]const u8, pwszPin: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHTTPRequest3.VTable, self.vtable).SetClientCertificate(@ptrCast(*const IXMLHTTPRequest3, self), cbClientCertificateHash, pbClientCertificateHash, pwszPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (13)
//--------------------------------------------------------------------------------
const IDispatch = @import("automation.zig").IDispatch;
const IXMLDOMNodeList = @import("windows_programming.zig").IXMLDOMNodeList;
const IXMLDOMDocument = @import("windows_programming.zig").IXMLDOMDocument;
const PWSTR = @import("system_services.zig").PWSTR;
const FILETIME = @import("windows_programming.zig").FILETIME;
const IUnknown = @import("com.zig").IUnknown;
const DOMNodeType = @import("windows_programming.zig").DOMNodeType;
const HRESULT = @import("com.zig").HRESULT;
const BSTR = @import("automation.zig").BSTR;
const IXMLDOMNode = @import("windows_programming.zig").IXMLDOMNode;
const IXMLDOMParseError = @import("windows_programming.zig").IXMLDOMParseError;
const VARIANT = @import("automation.zig").VARIANT;
const ISequentialStream = @import("structured_storage.zig").ISequentialStream;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
