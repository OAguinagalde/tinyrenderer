//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3228)
//--------------------------------------------------------------------------------
pub const CERT_COMPARE_SHIFT = @as(i32, 16);
pub const CVT_SECONDS = @as(u32, 1);
pub const DBSESSIONCOUNTDEFAULT = @as(u32, 100);
pub const DBFLAGS_READONLY = @as(u32, 1);
pub const DBFLAGS_CREATEIFNEEDED = @as(u32, 2);
pub const DBFLAGS_CIRCULARLOGGING = @as(u32, 4);
pub const DBFLAGS_LAZYFLUSH = @as(u32, 8);
pub const DBFLAGS_MAXCACHESIZEX100 = @as(u32, 16);
pub const DBFLAGS_CHECKPOINTDEPTH60MB = @as(u32, 32);
pub const DBFLAGS_LOGBUFFERSLARGE = @as(u32, 64);
pub const DBFLAGS_LOGBUFFERSHUGE = @as(u32, 128);
pub const DBFLAGS_LOGFILESIZE16MB = @as(u32, 256);
pub const DBFLAGS_MULTITHREADTRANSACTIONS = @as(u32, 512);
pub const DBFLAGS_DISABLESNAPSHOTBACKUP = @as(u32, 1024);
pub const DBFLAGS_ENABLEVOLATILEREQUESTS = @as(u32, 2048);
pub const LDAPF_SSLENABLE = @as(u32, 1);
pub const LDAPF_SIGNDISABLE = @as(u32, 2);
pub const CSVER_MAJOR_WIN2K = @as(u32, 1);
pub const CSVER_MINOR_WIN2K = @as(u32, 1);
pub const CSVER_MAJOR_WHISTLER = @as(u32, 2);
pub const CSVER_MINOR_WHISTLER_BETA2 = @as(u32, 1);
pub const CSVER_MINOR_WHISTLER_BETA3 = @as(u32, 2);
pub const CSVER_MAJOR_LONGHORN = @as(u32, 3);
pub const CSVER_MINOR_LONGHORN_BETA1 = @as(u32, 1);
pub const CSVER_MAJOR_WIN7 = @as(u32, 4);
pub const CSVER_MINOR_WIN7 = @as(u32, 1);
pub const CSVER_MAJOR_WIN8 = @as(u32, 5);
pub const CSVER_MINOR_WIN8 = @as(u32, 1);
pub const CSVER_MAJOR_WINBLUE = @as(u32, 6);
pub const CSVER_MINOR_WINBLUE = @as(u32, 1);
pub const CSVER_MAJOR_THRESHOLD = @as(u32, 7);
pub const CSVER_MINOR_THRESHOLD = @as(u32, 1);
pub const CCLOCKSKEWMINUTESDEFAULT = @as(u32, 10);
pub const CVIEWAGEMINUTESDEFAULT = @as(u32, 16);
pub const SETUP_SERVER_FLAG = @as(u32, 1);
pub const SETUP_CLIENT_FLAG = @as(u32, 2);
pub const SETUP_SUSPEND_FLAG = @as(u32, 4);
pub const SETUP_REQUEST_FLAG = @as(u32, 8);
pub const SETUP_ONLINE_FLAG = @as(u32, 16);
pub const SETUP_DENIED_FLAG = @as(u32, 32);
pub const SETUP_CREATEDB_FLAG = @as(u32, 64);
pub const SETUP_ATTEMPT_VROOT_CREATE = @as(u32, 128);
pub const SETUP_FORCECRL_FLAG = @as(u32, 256);
pub const SETUP_UPDATE_CAOBJECT_SVRTYPE = @as(u32, 512);
pub const SETUP_SERVER_UPGRADED_FLAG = @as(u32, 1024);
pub const SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG = @as(u32, 2048);
pub const SETUP_SECURITY_CHANGED = @as(u32, 4096);
pub const SETUP_DCOM_SECURITY_UPDATED_FLAG = @as(u32, 8192);
pub const SETUP_SERVER_IS_UP_TO_DATE_FLAG = @as(u32, 16384);
pub const CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE = @as(u32, 1);
pub const CRLF_DELETE_EXPIRED_CRLS = @as(u32, 2);
pub const CRLF_CRLNUMBER_CRITICAL = @as(u32, 4);
pub const CRLF_REVCHECK_IGNORE_OFFLINE = @as(u32, 8);
pub const CRLF_IGNORE_INVALID_POLICIES = @as(u32, 16);
pub const CRLF_REBUILD_MODIFIED_SUBJECT_ONLY = @as(u32, 32);
pub const CRLF_SAVE_FAILED_CERTS = @as(u32, 64);
pub const CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES = @as(u32, 128);
pub const CRLF_IGNORE_CROSS_CERT_TRUST_ERROR = @as(u32, 256);
pub const CRLF_PUBLISH_EXPIRED_CERT_CRLS = @as(u32, 512);
pub const CRLF_ENFORCE_ENROLLMENT_AGENT = @as(u32, 1024);
pub const CRLF_DISABLE_RDN_REORDER = @as(u32, 2048);
pub const CRLF_DISABLE_ROOT_CROSS_CERTS = @as(u32, 4096);
pub const CRLF_LOG_FULL_RESPONSE = @as(u32, 8192);
pub const CRLF_USE_XCHG_CERT_TEMPLATE = @as(u32, 16384);
pub const CRLF_USE_CROSS_CERT_TEMPLATE = @as(u32, 32768);
pub const CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT = @as(u32, 65536);
pub const CRLF_REVCHECK_IGNORE_NOREVCHECK = @as(u32, 131072);
pub const CRLF_PRESERVE_EXPIRED_CA_CERTS = @as(u32, 262144);
pub const CRLF_PRESERVE_REVOKED_CA_CERTS = @as(u32, 524288);
pub const CRLF_DISABLE_CHAIN_VERIFICATION = @as(u32, 1048576);
pub const CRLF_BUILD_ROOTCA_CRLENTRIES_BASEDONKEY = @as(u32, 2097152);
pub const KRAF_ENABLEFOREIGN = @as(u32, 1);
pub const KRAF_SAVEBADREQUESTKEY = @as(u32, 2);
pub const KRAF_ENABLEARCHIVEALL = @as(u32, 4);
pub const KRAF_DISABLEUSEDEFAULTPROVIDER = @as(u32, 8);
pub const IF_LOCKICERTREQUEST = @as(u32, 1);
pub const IF_NOREMOTEICERTREQUEST = @as(u32, 2);
pub const IF_NOLOCALICERTREQUEST = @as(u32, 4);
pub const IF_NORPCICERTREQUEST = @as(u32, 8);
pub const IF_NOREMOTEICERTADMIN = @as(u32, 16);
pub const IF_NOLOCALICERTADMIN = @as(u32, 32);
pub const IF_NOREMOTEICERTADMINBACKUP = @as(u32, 64);
pub const IF_NOLOCALICERTADMINBACKUP = @as(u32, 128);
pub const IF_NOSNAPSHOTBACKUP = @as(u32, 256);
pub const IF_ENFORCEENCRYPTICERTREQUEST = @as(u32, 512);
pub const IF_ENFORCEENCRYPTICERTADMIN = @as(u32, 1024);
pub const IF_ENABLEEXITKEYRETRIEVAL = @as(u32, 2048);
pub const IF_ENABLEADMINASAUDITOR = @as(u32, 4096);
pub const PROCFLG_NONE = @as(u32, 0);
pub const PROCFLG_ENFORCEGOODKEYS = @as(u32, 1);
pub const CSURL_SERVERPUBLISH = @as(u32, 1);
pub const CSURL_ADDTOCERTCDP = @as(u32, 2);
pub const CSURL_ADDTOFRESHESTCRL = @as(u32, 4);
pub const CSURL_ADDTOCRLCDP = @as(u32, 8);
pub const CSURL_PUBLISHRETRY = @as(u32, 16);
pub const CSURL_ADDTOCERTOCSP = @as(u32, 32);
pub const CSURL_SERVERPUBLISHDELTA = @as(u32, 64);
pub const CSURL_ADDTOIDP = @as(u32, 128);
pub const CAPATHLENGTH_INFINITE = @as(u32, 4294967295);
pub const REQDISP_PENDING = @as(u32, 0);
pub const REQDISP_ISSUE = @as(u32, 1);
pub const REQDISP_DENY = @as(u32, 2);
pub const REQDISP_USEREQUESTATTRIBUTE = @as(u32, 3);
pub const REQDISP_MASK = @as(u32, 255);
pub const REQDISP_PENDINGFIRST = @as(u32, 256);
pub const REVEXT_CDPLDAPURL_OLD = @as(u32, 1);
pub const REVEXT_CDPHTTPURL_OLD = @as(u32, 2);
pub const REVEXT_CDPFTPURL_OLD = @as(u32, 4);
pub const REVEXT_CDPFILEURL_OLD = @as(u32, 8);
pub const REVEXT_CDPURLMASK_OLD = @as(u32, 255);
pub const REVEXT_CDPENABLE = @as(u32, 256);
pub const REVEXT_ASPENABLE = @as(u32, 512);
pub const ISSCERT_LDAPURL_OLD = @as(u32, 1);
pub const ISSCERT_HTTPURL_OLD = @as(u32, 2);
pub const ISSCERT_FTPURL_OLD = @as(u32, 4);
pub const ISSCERT_FILEURL_OLD = @as(u32, 8);
pub const ISSCERT_URLMASK_OLD = @as(u32, 255);
pub const ISSCERT_ENABLE = @as(u32, 256);
pub const EDITF_ENABLEREQUESTEXTENSIONS = @as(u32, 1);
pub const EDITF_REQUESTEXTENSIONLIST = @as(u32, 2);
pub const EDITF_DISABLEEXTENSIONLIST = @as(u32, 4);
pub const EDITF_ADDOLDKEYUSAGE = @as(u32, 8);
pub const EDITF_ADDOLDCERTTYPE = @as(u32, 16);
pub const EDITF_ATTRIBUTEENDDATE = @as(u32, 32);
pub const EDITF_BASICCONSTRAINTSCRITICAL = @as(u32, 64);
pub const EDITF_BASICCONSTRAINTSCA = @as(u32, 128);
pub const EDITF_ENABLEAKIKEYID = @as(u32, 256);
pub const EDITF_ATTRIBUTECA = @as(u32, 512);
pub const EDITF_IGNOREREQUESTERGROUP = @as(u32, 1024);
pub const EDITF_ENABLEAKIISSUERNAME = @as(u32, 2048);
pub const EDITF_ENABLEAKIISSUERSERIAL = @as(u32, 4096);
pub const EDITF_ENABLEAKICRITICAL = @as(u32, 8192);
pub const EDITF_SERVERUPGRADED = @as(u32, 16384);
pub const EDITF_ATTRIBUTEEKU = @as(u32, 32768);
pub const EDITF_ENABLEDEFAULTSMIME = @as(u32, 65536);
pub const EDITF_EMAILOPTIONAL = @as(u32, 131072);
pub const EDITF_ATTRIBUTESUBJECTALTNAME2 = @as(u32, 262144);
pub const EDITF_ENABLELDAPREFERRALS = @as(u32, 524288);
pub const EDITF_ENABLECHASECLIENTDC = @as(u32, 1048576);
pub const EDITF_AUDITCERTTEMPLATELOAD = @as(u32, 2097152);
pub const EDITF_DISABLEOLDOSCNUPN = @as(u32, 4194304);
pub const EDITF_DISABLELDAPPACKAGELIST = @as(u32, 8388608);
pub const EDITF_ENABLEUPNMAP = @as(u32, 16777216);
pub const EDITF_ENABLEOCSPREVNOCHECK = @as(u32, 33554432);
pub const EDITF_ENABLERENEWONBEHALFOF = @as(u32, 67108864);
pub const EDITF_ENABLEKEYENCIPHERMENTCACERT = @as(u32, 134217728);
pub const EXITPUB_FILE = @as(u32, 1);
pub const EXITPUB_ACTIVEDIRECTORY = @as(u32, 2);
pub const EXITPUB_REMOVEOLDCERTS = @as(u32, 16);
pub const TP_MACHINEPOLICY = @as(u32, 1);
pub const KR_ENABLE_MACHINE = @as(u32, 1);
pub const KR_ENABLE_USER = @as(u32, 2);
pub const EXTENSION_CRITICAL_FLAG = @as(u32, 1);
pub const EXTENSION_DISABLE_FLAG = @as(u32, 2);
pub const EXTENSION_DELETE_FLAG = @as(u32, 4);
pub const EXTENSION_POLICY_MASK = @as(u32, 65535);
pub const EXTENSION_ORIGIN_REQUEST = @as(u32, 65536);
pub const EXTENSION_ORIGIN_POLICY = @as(u32, 131072);
pub const EXTENSION_ORIGIN_ADMIN = @as(u32, 196608);
pub const EXTENSION_ORIGIN_SERVER = @as(u32, 262144);
pub const EXTENSION_ORIGIN_RENEWALCERT = @as(u32, 327680);
pub const EXTENSION_ORIGIN_IMPORTEDCERT = @as(u32, 393216);
pub const EXTENSION_ORIGIN_PKCS7 = @as(u32, 458752);
pub const EXTENSION_ORIGIN_CMC = @as(u32, 524288);
pub const EXTENSION_ORIGIN_CACERT = @as(u32, 589824);
pub const EXTENSION_ORIGIN_MASK = @as(u32, 983040);
pub const CPF_BASE = @as(u32, 1);
pub const CPF_DELTA = @as(u32, 2);
pub const CPF_COMPLETE = @as(u32, 4);
pub const CPF_SHADOW = @as(u32, 8);
pub const CPF_CASTORE_ERROR = @as(u32, 16);
pub const CPF_BADURL_ERROR = @as(u32, 32);
pub const CPF_MANUAL = @as(u32, 64);
pub const CPF_SIGNATURE_ERROR = @as(u32, 128);
pub const CPF_LDAP_ERROR = @as(u32, 256);
pub const CPF_FILE_ERROR = @as(u32, 512);
pub const CPF_FTP_ERROR = @as(u32, 1024);
pub const CPF_HTTP_ERROR = @as(u32, 2048);
pub const CPF_POSTPONED_BASE_LDAP_ERROR = @as(u32, 4096);
pub const CPF_POSTPONED_BASE_FILE_ERROR = @as(u32, 8192);
pub const PROPTYPE_MASK = @as(u32, 255);
pub const PROPCALLER_SERVER = @as(u32, 256);
pub const PROPCALLER_POLICY = @as(u32, 512);
pub const PROPCALLER_EXIT = @as(u32, 768);
pub const PROPCALLER_ADMIN = @as(u32, 1024);
pub const PROPCALLER_REQUEST = @as(u32, 1280);
pub const PROPCALLER_MASK = @as(u32, 3840);
pub const PROPFLAGS_INDEXED = @as(u32, 65536);
pub const CR_FLG_FORCETELETEX = @as(u32, 1);
pub const CR_FLG_RENEWAL = @as(u32, 2);
pub const CR_FLG_FORCEUTF8 = @as(u32, 4);
pub const CR_FLG_CAXCHGCERT = @as(u32, 8);
pub const CR_FLG_ENROLLONBEHALFOF = @as(u32, 16);
pub const CR_FLG_SUBJECTUNMODIFIED = @as(u32, 32);
pub const CR_FLG_VALIDENCRYPTEDKEYHASH = @as(u32, 64);
pub const CR_FLG_CACROSSCERT = @as(u32, 128);
pub const CR_FLG_ENFORCEUTF8 = @as(u32, 256);
pub const CR_FLG_DEFINEDCACERT = @as(u32, 512);
pub const CR_FLG_CHALLENGEPENDING = @as(u32, 1024);
pub const CR_FLG_CHALLENGESATISFIED = @as(u32, 2048);
pub const CR_FLG_TRUSTONUSE = @as(u32, 4096);
pub const CR_FLG_TRUSTEKCERT = @as(u32, 8192);
pub const CR_FLG_TRUSTEKKEY = @as(u32, 16384);
pub const CR_FLG_PUBLISHERROR = @as(u32, 2147483648);
pub const DB_DISP_ACTIVE = @as(u32, 8);
pub const DB_DISP_PENDING = @as(u32, 9);
pub const DB_DISP_QUEUE_MAX = @as(u32, 9);
pub const DB_DISP_FOREIGN = @as(u32, 12);
pub const DB_DISP_CA_CERT = @as(u32, 15);
pub const DB_DISP_CA_CERT_CHAIN = @as(u32, 16);
pub const DB_DISP_KRA_CERT = @as(u32, 17);
pub const DB_DISP_LOG_MIN = @as(u32, 20);
pub const DB_DISP_ISSUED = @as(u32, 20);
pub const DB_DISP_REVOKED = @as(u32, 21);
pub const DB_DISP_LOG_FAILED_MIN = @as(u32, 30);
pub const DB_DISP_ERROR = @as(u32, 30);
pub const DB_DISP_DENIED = @as(u32, 31);
pub const VR_PENDING = @as(u32, 0);
pub const VR_INSTANT_OK = @as(u32, 1);
pub const VR_INSTANT_BAD = @as(u32, 2);
pub const AUDIT_TYPE_LEGACY = @as(u32, 1);
pub const AUDIT_TYPE_WMI = @as(u32, 2);
pub const AP_ParamTypeBits = @as(u32, 8);
pub const AP_ParamTypeMask = @as(i32, 255);
pub const APF_AuditFailure = @as(u32, 0);
pub const APF_AuditSuccess = @as(u32, 1);
pub const AUTHZP_WPD_EVENT = @as(u32, 16);
pub const AUTHZ_ALLOW_MULTIPLE_SOURCE_INSTANCES = @as(u32, 1);
pub const AUTHZ_MIGRATED_LEGACY_PUBLISHER = @as(u32, 2);
pub const AUTHZ_AUDIT_INSTANCE_INFORMATION = @as(u32, 2);
pub const LOOKUP_VIEW_LOCAL_INFORMATION = @as(u32, 1);
pub const LOOKUP_TRANSLATE_NAMES = @as(u32, 2048);
pub const SECPKG_ATTR_ISSUER_LIST = @as(u32, 80);
pub const SECPKG_ATTR_REMOTE_CRED = @as(u32, 81);
pub const SECPKG_ATTR_SUPPORTED_ALGS = @as(u32, 86);
pub const SECPKG_ATTR_CIPHER_STRENGTHS = @as(u32, 87);
pub const SECPKG_ATTR_SUPPORTED_PROTOCOLS = @as(u32, 88);
pub const SECPKG_ATTR_MAPPED_CRED_ATTR = @as(u32, 92);
pub const SECPKG_ATTR_REMOTE_CERTIFICATES = @as(u32, 95);
pub const SECPKG_ATTR_CLIENT_CERT_POLICY = @as(u32, 96);
pub const SECPKG_ATTR_CC_POLICY_RESULT = @as(u32, 97);
pub const SECPKG_ATTR_USE_NCRYPT = @as(u32, 98);
pub const SECPKG_ATTR_LOCAL_CERT_INFO = @as(u32, 99);
pub const SECPKG_ATTR_CIPHER_INFO = @as(u32, 100);
pub const SECPKG_ATTR_REMOTE_CERT_CHAIN = @as(u32, 103);
pub const SECPKG_ATTR_UI_INFO = @as(u32, 104);
pub const SECPKG_ATTR_KEYING_MATERIAL = @as(u32, 107);
pub const SECPKG_ATTR_SRTP_PARAMETERS = @as(u32, 108);
pub const SECPKG_ATTR_TOKEN_BINDING = @as(u32, 109);
pub const SECPKG_ATTR_CONNECTION_INFO_EX = @as(u32, 110);
pub const SECPKG_ATTR_KEYING_MATERIAL_TOKEN_BINDING = @as(u32, 111);
pub const SECPKG_ATTR_KEYING_MATERIAL_INPROC = @as(u32, 112);
pub const INHERITED_ACCESS_ENTRY = @as(u32, 16);
pub const INHERITED_PARENT = @as(u32, 268435456);
pub const INHERITED_GRANDPARENT = @as(u32, 536870912);
pub const TRUSTEE_ACCESS_ALLOWED = @as(i32, 1);
pub const TRUSTEE_ACCESS_READ = @as(i32, 2);
pub const TRUSTEE_ACCESS_WRITE = @as(i32, 4);
pub const TRUSTEE_ACCESS_EXPLICIT = @as(i32, 1);
pub const TRUSTEE_ACCESS_ALL = @as(i32, -1);
pub const ACTRL_RESERVED = @as(u32, 0);
pub const ACTRL_PERM_1 = @as(u32, 1);
pub const ACTRL_PERM_2 = @as(u32, 2);
pub const ACTRL_PERM_3 = @as(u32, 4);
pub const ACTRL_PERM_4 = @as(u32, 8);
pub const ACTRL_PERM_5 = @as(u32, 16);
pub const ACTRL_PERM_6 = @as(u32, 32);
pub const ACTRL_PERM_7 = @as(u32, 64);
pub const ACTRL_PERM_8 = @as(u32, 128);
pub const ACTRL_PERM_9 = @as(u32, 256);
pub const ACTRL_PERM_10 = @as(u32, 512);
pub const ACTRL_PERM_11 = @as(u32, 1024);
pub const ACTRL_PERM_12 = @as(u32, 2048);
pub const ACTRL_PERM_13 = @as(u32, 4096);
pub const ACTRL_PERM_14 = @as(u32, 8192);
pub const ACTRL_PERM_15 = @as(u32, 16384);
pub const ACTRL_PERM_16 = @as(u32, 32768);
pub const ACTRL_PERM_17 = @as(u32, 65536);
pub const ACTRL_PERM_18 = @as(u32, 131072);
pub const ACTRL_PERM_19 = @as(u32, 262144);
pub const ACTRL_PERM_20 = @as(u32, 524288);
pub const ACTRL_ACCESS_PROTECTED = @as(u32, 1);
pub const ACTRL_SYSTEM_ACCESS = @as(u32, 67108864);
pub const ACTRL_DELETE = @as(u32, 134217728);
pub const ACTRL_READ_CONTROL = @as(u32, 268435456);
pub const ACTRL_CHANGE_ACCESS = @as(u32, 536870912);
pub const ACTRL_CHANGE_OWNER = @as(u32, 1073741824);
pub const ACTRL_SYNCHRONIZE = @as(u32, 2147483648);
pub const ACTRL_STD_RIGHTS_ALL = @as(u32, 4160749568);
pub const ACTRL_ACCESS_NO_OPTIONS = @as(u32, 0);
pub const ACTRL_ACCESS_SUPPORTS_OBJECT_ENTRIES = @as(u32, 1);
pub const SECPKG_CLIENT_PROCESS_TERMINATED = @as(u32, 1);
pub const SECPKG_CLIENT_THREAD_TERMINATED = @as(u32, 2);
pub const SECPKG_CALL_KERNEL_MODE = @as(u32, 1);
pub const SECPKG_CALL_ANSI = @as(u32, 2);
pub const SECPKG_CALL_URGENT = @as(u32, 4);
pub const SECPKG_CALL_RECURSIVE = @as(u32, 8);
pub const SECPKG_CALL_IN_PROC = @as(u32, 16);
pub const SECPKG_CALL_CLEANUP = @as(u32, 32);
pub const SECPKG_CALL_WOWCLIENT = @as(u32, 64);
pub const SECPKG_CALL_THREAD_TERM = @as(u32, 128);
pub const SECPKG_CALL_PROCESS_TERM = @as(u32, 256);
pub const SECPKG_CALL_IS_TCB = @as(u32, 512);
pub const SECPKG_CALL_NETWORK_ONLY = @as(u32, 1024);
pub const SECPKG_CALL_WINLOGON = @as(u32, 2048);
pub const SECPKG_CALL_ASYNC_UPDATE = @as(u32, 4096);
pub const SECPKG_CALL_SYSTEM_PROC = @as(u32, 8192);
pub const SECPKG_CALL_NEGO = @as(u32, 16384);
pub const SECPKG_CALL_NEGO_EXTENDER = @as(u32, 32768);
pub const SECPKG_CALL_BUFFER_MARSHAL = @as(u32, 65536);
pub const SECPKG_CALL_UNLOCK = @as(u32, 131072);
pub const SECPKG_CALL_CLOUDAP_CONNECT = @as(u32, 262144);
pub const SECPKG_CALL_WOWX86 = @as(u32, 64);
pub const SECPKG_CALL_WOWA32 = @as(u32, 262144);
pub const SECPKG_CREDENTIAL_VERSION = @as(u32, 201);
pub const SECPKG_CREDENTIAL_FLAGS_CALLER_HAS_TCB = @as(u32, 1);
pub const SECPKG_CREDENTIAL_FLAGS_CREDMAN_CRED = @as(u32, 2);
pub const SECPKG_SURROGATE_LOGON_VERSION_1 = @as(u32, 1);
pub const SECBUFFER_UNMAPPED = @as(u32, 1073741824);
pub const SECBUFFER_KERNEL_MAP = @as(u32, 536870912);
pub const PRIMARY_CRED_CLEAR_PASSWORD = @as(u32, 1);
pub const PRIMARY_CRED_OWF_PASSWORD = @as(u32, 2);
pub const PRIMARY_CRED_UPDATE = @as(u32, 4);
pub const PRIMARY_CRED_CACHED_LOGON = @as(u32, 8);
pub const PRIMARY_CRED_LOGON_NO_TCB = @as(u32, 16);
pub const PRIMARY_CRED_LOGON_LUA = @as(u32, 32);
pub const PRIMARY_CRED_INTERACTIVE_SMARTCARD_LOGON = @as(u32, 64);
pub const PRIMARY_CRED_REFRESH_NEEDED = @as(u32, 128);
pub const PRIMARY_CRED_INTERNET_USER = @as(u32, 256);
pub const PRIMARY_CRED_AUTH_ID = @as(u32, 512);
pub const PRIMARY_CRED_DO_NOT_SPLIT = @as(u32, 1024);
pub const PRIMARY_CRED_PROTECTED_USER = @as(u32, 2048);
pub const PRIMARY_CRED_EX = @as(u32, 4096);
pub const PRIMARY_CRED_TRANSFER = @as(u32, 8192);
pub const PRIMARY_CRED_RESTRICTED_TS = @as(u32, 16384);
pub const PRIMARY_CRED_PACKED_CREDS = @as(u32, 32768);
pub const PRIMARY_CRED_ENTERPRISE_INTERNET_USER = @as(u32, 65536);
pub const PRIMARY_CRED_ENCRYPTED_CREDGUARD_PASSWORD = @as(u32, 131072);
pub const PRIMARY_CRED_CACHED_INTERACTIVE_LOGON = @as(u32, 262144);
pub const PRIMARY_CRED_INTERACTIVE_NGC_LOGON = @as(u32, 524288);
pub const PRIMARY_CRED_INTERACTIVE_FIDO_LOGON = @as(u32, 1048576);
pub const PRIMARY_CRED_ARSO_LOGON = @as(u32, 2097152);
pub const PRIMARY_CRED_LOGON_PACKAGE_SHIFT = @as(u32, 24);
pub const PRIMARY_CRED_PACKAGE_MASK = @as(u32, 4278190080);
pub const MAX_CRED_SIZE = @as(u32, 1024);
pub const SECPKG_STATE_ENCRYPTION_PERMITTED = @as(u32, 1);
pub const SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED = @as(u32, 2);
pub const SECPKG_STATE_DOMAIN_CONTROLLER = @as(u32, 4);
pub const SECPKG_STATE_WORKSTATION = @as(u32, 8);
pub const SECPKG_STATE_STANDALONE = @as(u32, 16);
pub const SECPKG_STATE_CRED_ISOLATION_ENABLED = @as(u32, 32);
pub const SECPKG_STATE_RESERVED_1 = @as(u32, 2147483648);
pub const SECPKG_MAX_OID_LENGTH = @as(u32, 32);
pub const SECPKG_ATTR_SASL_CONTEXT = @as(u32, 65536);
pub const SECPKG_ATTR_THUNK_ALL = @as(u32, 65536);
pub const UNDERSTANDS_LONG_NAMES = @as(u32, 1);
pub const NO_LONG_NAMES = @as(u32, 2);
pub const SECPKG_CALL_PACKAGE_TRANSFER_CRED_REQUEST_FLAG_OPTIMISTIC_LOGON = @as(u32, 1);
pub const SECPKG_CALL_PACKAGE_TRANSFER_CRED_REQUEST_FLAG_CLEANUP_CREDENTIALS = @as(u32, 2);
pub const SECPKG_CALL_PACKAGE_TRANSFER_CRED_REQUEST_FLAG_TO_SSO_SESSION = @as(u32, 4);
pub const NOTIFIER_FLAG_NEW_THREAD = @as(u32, 1);
pub const NOTIFIER_FLAG_ONE_SHOT = @as(u32, 2);
pub const NOTIFIER_FLAG_SECONDS = @as(u32, 2147483648);
pub const NOTIFIER_TYPE_INTERVAL = @as(u32, 1);
pub const NOTIFIER_TYPE_HANDLE_WAIT = @as(u32, 2);
pub const NOTIFIER_TYPE_STATE_CHANGE = @as(u32, 3);
pub const NOTIFIER_TYPE_NOTIFY_EVENT = @as(u32, 4);
pub const NOTIFIER_TYPE_IMMEDIATE = @as(u32, 16);
pub const NOTIFY_CLASS_PACKAGE_CHANGE = @as(u32, 1);
pub const NOTIFY_CLASS_ROLE_CHANGE = @as(u32, 2);
pub const NOTIFY_CLASS_DOMAIN_CHANGE = @as(u32, 3);
pub const NOTIFY_CLASS_REGISTRY_CHANGE = @as(u32, 4);
pub const LSA_QUERY_CLIENT_PRELOGON_SESSION_ID = @as(u32, 1);
pub const CREDP_FLAGS_IN_PROCESS = @as(u32, 1);
pub const CREDP_FLAGS_USE_MIDL_HEAP = @as(u32, 2);
pub const CREDP_FLAGS_DONT_CACHE_TI = @as(u32, 4);
pub const CREDP_FLAGS_CLEAR_PASSWORD = @as(u32, 8);
pub const CREDP_FLAGS_USER_ENCRYPTED_PASSWORD = @as(u32, 16);
pub const CREDP_FLAGS_TRUSTED_CALLER = @as(u32, 32);
pub const CREDP_FLAGS_VALIDATE_PROXY_TARGET = @as(u32, 64);
pub const CRED_MARSHALED_TI_SIZE_SIZE = @as(u32, 12);
pub const SECPKG_INTERFACE_VERSION = @as(u32, 65536);
pub const SECPKG_INTERFACE_VERSION_2 = @as(u32, 131072);
pub const SECPKG_INTERFACE_VERSION_3 = @as(u32, 262144);
pub const SECPKG_INTERFACE_VERSION_4 = @as(u32, 524288);
pub const SECPKG_INTERFACE_VERSION_5 = @as(u32, 1048576);
pub const SECPKG_INTERFACE_VERSION_6 = @as(u32, 2097152);
pub const SECPKG_INTERFACE_VERSION_7 = @as(u32, 4194304);
pub const SECPKG_INTERFACE_VERSION_8 = @as(u32, 8388608);
pub const SECPKG_INTERFACE_VERSION_9 = @as(u32, 16777216);
pub const SECPKG_INTERFACE_VERSION_10 = @as(u32, 33554432);
pub const WLX_VERSION_1_0 = @as(u32, 65536);
pub const WLX_VERSION_1_1 = @as(u32, 65537);
pub const WLX_VERSION_1_2 = @as(u32, 65538);
pub const WLX_VERSION_1_3 = @as(u32, 65539);
pub const WLX_VERSION_1_4 = @as(u32, 65540);
pub const WLX_SAS_TYPE_TIMEOUT = @as(u32, 0);
pub const WLX_SAS_TYPE_CTRL_ALT_DEL = @as(u32, 1);
pub const WLX_SAS_TYPE_SCRNSVR_TIMEOUT = @as(u32, 2);
pub const WLX_SAS_TYPE_SCRNSVR_ACTIVITY = @as(u32, 3);
pub const WLX_SAS_TYPE_USER_LOGOFF = @as(u32, 4);
pub const WLX_SAS_TYPE_SC_INSERT = @as(u32, 5);
pub const WLX_SAS_TYPE_SC_REMOVE = @as(u32, 6);
pub const WLX_SAS_TYPE_AUTHENTICATED = @as(u32, 7);
pub const WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED = @as(u32, 8);
pub const WLX_SAS_TYPE_SC_LAST_READER_REMOVED = @as(u32, 9);
pub const WLX_SAS_TYPE_SWITCHUSER = @as(u32, 10);
pub const WLX_SAS_TYPE_MAX_MSFT_VALUE = @as(u32, 127);
pub const WLX_LOGON_OPT_NO_PROFILE = @as(u32, 1);
pub const WLX_PROFILE_TYPE_V1_0 = @as(u32, 1);
pub const WLX_PROFILE_TYPE_V2_0 = @as(u32, 2);
pub const WLX_SAS_ACTION_LOGON = @as(u32, 1);
pub const WLX_SAS_ACTION_NONE = @as(u32, 2);
pub const WLX_SAS_ACTION_LOCK_WKSTA = @as(u32, 3);
pub const WLX_SAS_ACTION_LOGOFF = @as(u32, 4);
pub const WLX_SAS_ACTION_PWD_CHANGED = @as(u32, 6);
pub const WLX_SAS_ACTION_TASKLIST = @as(u32, 7);
pub const WLX_SAS_ACTION_UNLOCK_WKSTA = @as(u32, 8);
pub const WLX_SAS_ACTION_FORCE_LOGOFF = @as(u32, 9);
pub const WLX_SAS_ACTION_SHUTDOWN_SLEEP = @as(u32, 12);
pub const WLX_SAS_ACTION_SHUTDOWN_SLEEP2 = @as(u32, 13);
pub const WLX_SAS_ACTION_SHUTDOWN_HIBERNATE = @as(u32, 14);
pub const WLX_SAS_ACTION_RECONNECTED = @as(u32, 15);
pub const WLX_SAS_ACTION_DELAYED_FORCE_LOGOFF = @as(u32, 16);
pub const WLX_SAS_ACTION_SWITCH_CONSOLE = @as(u32, 17);
pub const WLX_WM_SAS = @as(u32, 1625);
pub const WLX_DLG_SAS = @as(u32, 101);
pub const WLX_DLG_INPUT_TIMEOUT = @as(u32, 102);
pub const WLX_DLG_SCREEN_SAVER_TIMEOUT = @as(u32, 103);
pub const WLX_DLG_USER_LOGOFF = @as(u32, 104);
pub const WLX_DIRECTORY_LENGTH = @as(u32, 256);
pub const WLX_CREDENTIAL_TYPE_V1_0 = @as(u32, 1);
pub const WLX_CREDENTIAL_TYPE_V2_0 = @as(u32, 2);
pub const WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0 = @as(u32, 1);
pub const STATUSMSG_OPTION_NOANIMATION = @as(u32, 1);
pub const STATUSMSG_OPTION_SETFOREGROUND = @as(u32, 2);
pub const WLX_DESKTOP_NAME = @as(u32, 1);
pub const WLX_DESKTOP_HANDLE = @as(u32, 2);
pub const WLX_CREATE_INSTANCE_ONLY = @as(u32, 1);
pub const WLX_CREATE_USER = @as(u32, 2);
pub const WLX_OPTION_USE_CTRL_ALT_DEL = @as(u32, 1);
pub const WLX_OPTION_CONTEXT_POINTER = @as(u32, 2);
pub const WLX_OPTION_USE_SMART_CARD = @as(u32, 3);
pub const WLX_OPTION_FORCE_LOGOFF_TIME = @as(u32, 4);
pub const WLX_OPTION_IGNORE_AUTO_LOGON = @as(u32, 8);
pub const WLX_OPTION_NO_SWITCH_ON_SAS = @as(u32, 9);
pub const WLX_OPTION_SMART_CARD_PRESENT = @as(u32, 65537);
pub const WLX_OPTION_SMART_CARD_INFO = @as(u32, 65538);
pub const WLX_OPTION_DISPATCH_TABLE_SIZE = @as(u32, 65539);
pub const TPMVSC_DEFAULT_ADMIN_ALGORITHM_ID = @as(u32, 130);
pub const ISSP_LEVEL = @as(u32, 32);
pub const ISSP_MODE = @as(u32, 1);
pub const SECPKG_FLAG_INTEGRITY = @as(u32, 1);
pub const SECPKG_FLAG_PRIVACY = @as(u32, 2);
pub const SECPKG_FLAG_TOKEN_ONLY = @as(u32, 4);
pub const SECPKG_FLAG_DATAGRAM = @as(u32, 8);
pub const SECPKG_FLAG_CONNECTION = @as(u32, 16);
pub const SECPKG_FLAG_MULTI_REQUIRED = @as(u32, 32);
pub const SECPKG_FLAG_CLIENT_ONLY = @as(u32, 64);
pub const SECPKG_FLAG_EXTENDED_ERROR = @as(u32, 128);
pub const SECPKG_FLAG_IMPERSONATION = @as(u32, 256);
pub const SECPKG_FLAG_ACCEPT_WIN32_NAME = @as(u32, 512);
pub const SECPKG_FLAG_STREAM = @as(u32, 1024);
pub const SECPKG_FLAG_NEGOTIABLE = @as(u32, 2048);
pub const SECPKG_FLAG_GSS_COMPATIBLE = @as(u32, 4096);
pub const SECPKG_FLAG_LOGON = @as(u32, 8192);
pub const SECPKG_FLAG_ASCII_BUFFERS = @as(u32, 16384);
pub const SECPKG_FLAG_FRAGMENT = @as(u32, 32768);
pub const SECPKG_FLAG_MUTUAL_AUTH = @as(u32, 65536);
pub const SECPKG_FLAG_DELEGATION = @as(u32, 131072);
pub const SECPKG_FLAG_READONLY_WITH_CHECKSUM = @as(u32, 262144);
pub const SECPKG_FLAG_RESTRICTED_TOKENS = @as(u32, 524288);
pub const SECPKG_FLAG_NEGO_EXTENDER = @as(u32, 1048576);
pub const SECPKG_FLAG_NEGOTIABLE2 = @as(u32, 2097152);
pub const SECPKG_FLAG_APPCONTAINER_PASSTHROUGH = @as(u32, 4194304);
pub const SECPKG_FLAG_APPCONTAINER_CHECKS = @as(u32, 8388608);
pub const SECPKG_FLAG_CREDENTIAL_ISOLATION_ENABLED = @as(u32, 16777216);
pub const SECPKG_FLAG_APPLY_LOOPBACK = @as(u32, 33554432);
pub const SECPKG_ID_NONE = @as(u32, 65535);
pub const SECPKG_CALLFLAGS_APPCONTAINER = @as(u32, 1);
pub const SECPKG_CALLFLAGS_APPCONTAINER_AUTHCAPABLE = @as(u32, 2);
pub const SECPKG_CALLFLAGS_FORCE_SUPPLIED = @as(u32, 4);
pub const SECPKG_CALLFLAGS_APPCONTAINER_UPNCAPABLE = @as(u32, 8);
pub const SECBUFFER_VERSION = @as(u32, 0);
pub const SECBUFFER_EMPTY = @as(u32, 0);
pub const SECBUFFER_DATA = @as(u32, 1);
pub const SECBUFFER_TOKEN = @as(u32, 2);
pub const SECBUFFER_PKG_PARAMS = @as(u32, 3);
pub const SECBUFFER_MISSING = @as(u32, 4);
pub const SECBUFFER_EXTRA = @as(u32, 5);
pub const SECBUFFER_STREAM_TRAILER = @as(u32, 6);
pub const SECBUFFER_STREAM_HEADER = @as(u32, 7);
pub const SECBUFFER_NEGOTIATION_INFO = @as(u32, 8);
pub const SECBUFFER_PADDING = @as(u32, 9);
pub const SECBUFFER_STREAM = @as(u32, 10);
pub const SECBUFFER_MECHLIST = @as(u32, 11);
pub const SECBUFFER_MECHLIST_SIGNATURE = @as(u32, 12);
pub const SECBUFFER_TARGET = @as(u32, 13);
pub const SECBUFFER_CHANNEL_BINDINGS = @as(u32, 14);
pub const SECBUFFER_CHANGE_PASS_RESPONSE = @as(u32, 15);
pub const SECBUFFER_TARGET_HOST = @as(u32, 16);
pub const SECBUFFER_ALERT = @as(u32, 17);
pub const SECBUFFER_APPLICATION_PROTOCOLS = @as(u32, 18);
pub const SECBUFFER_SRTP_PROTECTION_PROFILES = @as(u32, 19);
pub const SECBUFFER_SRTP_MASTER_KEY_IDENTIFIER = @as(u32, 20);
pub const SECBUFFER_TOKEN_BINDING = @as(u32, 21);
pub const SECBUFFER_PRESHARED_KEY = @as(u32, 22);
pub const SECBUFFER_PRESHARED_KEY_IDENTITY = @as(u32, 23);
pub const SECBUFFER_DTLS_MTU = @as(u32, 24);
pub const SECBUFFER_SEND_GENERIC_TLS_EXTENSION = @as(u32, 25);
pub const SECBUFFER_SUBSCRIBE_GENERIC_TLS_EXTENSION = @as(u32, 26);
pub const SECBUFFER_FLAGS = @as(u32, 27);
pub const SECBUFFER_TRAFFIC_SECRETS = @as(u32, 28);
pub const SECBUFFER_ATTRMASK = @as(u32, 4026531840);
pub const SECBUFFER_READONLY = @as(u32, 2147483648);
pub const SECBUFFER_READONLY_WITH_CHECKSUM = @as(u32, 268435456);
pub const SECBUFFER_RESERVED = @as(u32, 1610612736);
pub const SZ_ALG_MAX_SIZE = @as(u32, 64);
pub const SECURITY_NATIVE_DREP = @as(u32, 16);
pub const SECURITY_NETWORK_DREP = @as(u32, 0);
pub const SECPKG_CRED_BOTH = @as(u32, 3);
pub const SECPKG_CRED_DEFAULT = @as(u32, 4);
pub const SECPKG_CRED_RESERVED = @as(u32, 4026531840);
pub const SECPKG_CRED_AUTOLOGON_RESTRICTED = @as(u32, 16);
pub const SECPKG_CRED_PROCESS_POLICY_ONLY = @as(u32, 32);
pub const ISC_REQ_DELEGATE = @as(u32, 1);
pub const ISC_REQ_MUTUAL_AUTH = @as(u32, 2);
pub const ISC_REQ_REPLAY_DETECT = @as(u32, 4);
pub const ISC_REQ_SEQUENCE_DETECT = @as(u32, 8);
pub const ISC_REQ_CONFIDENTIALITY = @as(u32, 16);
pub const ISC_REQ_USE_SESSION_KEY = @as(u32, 32);
pub const ISC_REQ_PROMPT_FOR_CREDS = @as(u32, 64);
pub const ISC_REQ_USE_SUPPLIED_CREDS = @as(u32, 128);
pub const ISC_REQ_ALLOCATE_MEMORY = @as(u32, 256);
pub const ISC_REQ_USE_DCE_STYLE = @as(u32, 512);
pub const ISC_REQ_DATAGRAM = @as(u32, 1024);
pub const ISC_REQ_CONNECTION = @as(u32, 2048);
pub const ISC_REQ_CALL_LEVEL = @as(u32, 4096);
pub const ISC_REQ_FRAGMENT_SUPPLIED = @as(u32, 8192);
pub const ISC_REQ_EXTENDED_ERROR = @as(u32, 16384);
pub const ISC_REQ_STREAM = @as(u32, 32768);
pub const ISC_REQ_INTEGRITY = @as(u32, 65536);
pub const ISC_REQ_IDENTIFY = @as(u32, 131072);
pub const ISC_REQ_NULL_SESSION = @as(u32, 262144);
pub const ISC_REQ_MANUAL_CRED_VALIDATION = @as(u32, 524288);
pub const ISC_REQ_RESERVED1 = @as(u32, 1048576);
pub const ISC_REQ_FRAGMENT_TO_FIT = @as(u32, 2097152);
pub const ISC_REQ_FORWARD_CREDENTIALS = @as(u32, 4194304);
pub const ISC_REQ_NO_INTEGRITY = @as(u32, 8388608);
pub const ISC_REQ_USE_HTTP_STYLE = @as(u32, 16777216);
pub const ISC_REQ_UNVERIFIED_TARGET_NAME = @as(u32, 536870912);
pub const ISC_REQ_CONFIDENTIALITY_ONLY = @as(u32, 1073741824);
pub const ISC_REQ_MESSAGES = @as(u64, 4294967296);
pub const ISC_RET_DELEGATE = @as(u32, 1);
pub const ISC_RET_MUTUAL_AUTH = @as(u32, 2);
pub const ISC_RET_REPLAY_DETECT = @as(u32, 4);
pub const ISC_RET_SEQUENCE_DETECT = @as(u32, 8);
pub const ISC_RET_CONFIDENTIALITY = @as(u32, 16);
pub const ISC_RET_USE_SESSION_KEY = @as(u32, 32);
pub const ISC_RET_USED_COLLECTED_CREDS = @as(u32, 64);
pub const ISC_RET_USED_SUPPLIED_CREDS = @as(u32, 128);
pub const ISC_RET_ALLOCATED_MEMORY = @as(u32, 256);
pub const ISC_RET_USED_DCE_STYLE = @as(u32, 512);
pub const ISC_RET_DATAGRAM = @as(u32, 1024);
pub const ISC_RET_CONNECTION = @as(u32, 2048);
pub const ISC_RET_INTERMEDIATE_RETURN = @as(u32, 4096);
pub const ISC_RET_CALL_LEVEL = @as(u32, 8192);
pub const ISC_RET_EXTENDED_ERROR = @as(u32, 16384);
pub const ISC_RET_STREAM = @as(u32, 32768);
pub const ISC_RET_INTEGRITY = @as(u32, 65536);
pub const ISC_RET_IDENTIFY = @as(u32, 131072);
pub const ISC_RET_NULL_SESSION = @as(u32, 262144);
pub const ISC_RET_MANUAL_CRED_VALIDATION = @as(u32, 524288);
pub const ISC_RET_RESERVED1 = @as(u32, 1048576);
pub const ISC_RET_FRAGMENT_ONLY = @as(u32, 2097152);
pub const ISC_RET_FORWARD_CREDENTIALS = @as(u32, 4194304);
pub const ISC_RET_USED_HTTP_STYLE = @as(u32, 16777216);
pub const ISC_RET_NO_ADDITIONAL_TOKEN = @as(u32, 33554432);
pub const ISC_RET_REAUTHENTICATION = @as(u32, 134217728);
pub const ISC_RET_CONFIDENTIALITY_ONLY = @as(u32, 1073741824);
pub const ISC_RET_MESSAGES = @as(u64, 4294967296);
pub const ASC_REQ_MUTUAL_AUTH = @as(u32, 2);
pub const ASC_REQ_CONFIDENTIALITY = @as(u32, 16);
pub const ASC_REQ_USE_SESSION_KEY = @as(u32, 32);
pub const ASC_REQ_SESSION_TICKET = @as(u32, 64);
pub const ASC_REQ_USE_DCE_STYLE = @as(u32, 512);
pub const ASC_REQ_DATAGRAM = @as(u32, 1024);
pub const ASC_REQ_CALL_LEVEL = @as(u32, 4096);
pub const ASC_REQ_FRAGMENT_SUPPLIED = @as(u32, 8192);
pub const ASC_REQ_INTEGRITY = @as(u32, 131072);
pub const ASC_REQ_LICENSING = @as(u32, 262144);
pub const ASC_REQ_IDENTIFY = @as(u32, 524288);
pub const ASC_REQ_ALLOW_NULL_SESSION = @as(u32, 1048576);
pub const ASC_REQ_ALLOW_NON_USER_LOGONS = @as(u32, 2097152);
pub const ASC_REQ_ALLOW_CONTEXT_REPLAY = @as(u32, 4194304);
pub const ASC_REQ_FRAGMENT_TO_FIT = @as(u32, 8388608);
pub const ASC_REQ_NO_TOKEN = @as(u32, 16777216);
pub const ASC_REQ_PROXY_BINDINGS = @as(u32, 67108864);
pub const ASC_REQ_ALLOW_MISSING_BINDINGS = @as(u32, 268435456);
pub const ASC_REQ_MESSAGES = @as(u64, 4294967296);
pub const ASC_RET_DELEGATE = @as(u32, 1);
pub const ASC_RET_MUTUAL_AUTH = @as(u32, 2);
pub const ASC_RET_REPLAY_DETECT = @as(u32, 4);
pub const ASC_RET_SEQUENCE_DETECT = @as(u32, 8);
pub const ASC_RET_CONFIDENTIALITY = @as(u32, 16);
pub const ASC_RET_USE_SESSION_KEY = @as(u32, 32);
pub const ASC_RET_SESSION_TICKET = @as(u32, 64);
pub const ASC_RET_ALLOCATED_MEMORY = @as(u32, 256);
pub const ASC_RET_USED_DCE_STYLE = @as(u32, 512);
pub const ASC_RET_DATAGRAM = @as(u32, 1024);
pub const ASC_RET_CONNECTION = @as(u32, 2048);
pub const ASC_RET_CALL_LEVEL = @as(u32, 8192);
pub const ASC_RET_THIRD_LEG_FAILED = @as(u32, 16384);
pub const ASC_RET_EXTENDED_ERROR = @as(u32, 32768);
pub const ASC_RET_STREAM = @as(u32, 65536);
pub const ASC_RET_INTEGRITY = @as(u32, 131072);
pub const ASC_RET_LICENSING = @as(u32, 262144);
pub const ASC_RET_IDENTIFY = @as(u32, 524288);
pub const ASC_RET_NULL_SESSION = @as(u32, 1048576);
pub const ASC_RET_ALLOW_NON_USER_LOGONS = @as(u32, 2097152);
pub const ASC_RET_ALLOW_CONTEXT_REPLAY = @as(u32, 4194304);
pub const ASC_RET_FRAGMENT_ONLY = @as(u32, 8388608);
pub const ASC_RET_NO_TOKEN = @as(u32, 16777216);
pub const ASC_RET_NO_ADDITIONAL_TOKEN = @as(u32, 33554432);
pub const ASC_RET_MESSAGES = @as(u64, 4294967296);
pub const SECPKG_CRED_ATTR_NAMES = @as(u32, 1);
pub const SECPKG_CRED_ATTR_SSI_PROVIDER = @as(u32, 2);
pub const SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS = @as(u32, 3);
pub const SECPKG_CRED_ATTR_CERT = @as(u32, 4);
pub const SECPKG_CRED_ATTR_PAC_BYPASS = @as(u32, 5);
pub const KDC_PROXY_SETTINGS_V1 = @as(u32, 1);
pub const KDC_PROXY_SETTINGS_FLAGS_FORCEPROXY = @as(u32, 1);
pub const SECPKG_ATTR_PROTO_INFO = @as(u32, 7);
pub const SECPKG_ATTR_USER_FLAGS = @as(u32, 11);
pub const SECPKG_ATTR_USE_VALIDATED = @as(u32, 15);
pub const SECPKG_ATTR_CREDENTIAL_NAME = @as(u32, 16);
pub const SECPKG_ATTR_TARGET = @as(u32, 19);
pub const SECPKG_ATTR_AUTHENTICATION_ID = @as(u32, 20);
pub const SECPKG_ATTR_LOGOFF_TIME = @as(u32, 21);
pub const SECPKG_ATTR_NEGO_KEYS = @as(u32, 22);
pub const SECPKG_ATTR_PROMPTING_NEEDED = @as(u32, 24);
pub const SECPKG_ATTR_NEGO_PKG_INFO = @as(u32, 31);
pub const SECPKG_ATTR_NEGO_STATUS = @as(u32, 32);
pub const SECPKG_ATTR_CONTEXT_DELETED = @as(u32, 33);
pub const SECPKG_ATTR_APPLICATION_PROTOCOL = @as(u32, 35);
pub const SECPKG_ATTR_NEGOTIATED_TLS_EXTENSIONS = @as(u32, 36);
pub const SECPKG_ATTR_IS_LOOPBACK = @as(u32, 37);
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_KERBEROS = @as(u32, 1);
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_NTLM = @as(u32, 2);
pub const SECPKG_NEGOTIATION_COMPLETE = @as(u32, 0);
pub const SECPKG_NEGOTIATION_OPTIMISTIC = @as(u32, 1);
pub const SECPKG_NEGOTIATION_IN_PROGRESS = @as(u32, 2);
pub const SECPKG_NEGOTIATION_DIRECT = @as(u32, 3);
pub const SECPKG_NEGOTIATION_TRY_MULTICRED = @as(u32, 4);
pub const MAX_PROTOCOL_ID_SIZE = @as(u32, 255);
pub const SECQOP_WRAP_NO_ENCRYPT = @as(u32, 2147483649);
pub const SECQOP_WRAP_OOB_DATA = @as(u32, 1073741824);
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION = @as(u32, 1);
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 = @as(u32, 2);
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3 = @as(u32, 3);
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4 = @as(u32, 4);
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_5 = @as(u32, 5);
pub const SASL_OPTION_SEND_SIZE = @as(u32, 1);
pub const SASL_OPTION_RECV_SIZE = @as(u32, 2);
pub const SASL_OPTION_AUTHZ_STRING = @as(u32, 3);
pub const SASL_OPTION_AUTHZ_PROCESSING = @as(u32, 4);
pub const SEC_WINNT_AUTH_IDENTITY_VERSION_2 = @as(u32, 513);
pub const SEC_WINNT_AUTH_IDENTITY_VERSION = @as(u32, 512);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_PROCESS_ENCRYPTED = @as(u32, 16);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SYSTEM_PROTECTED = @as(u32, 32);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_USER_PROTECTED = @as(u32, 64);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SYSTEM_ENCRYPTED = @as(u32, 128);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_RESERVED = @as(u32, 65536);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_NULL_USER = @as(u32, 131072);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_NULL_DOMAIN = @as(u32, 262144);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_ID_PROVIDER = @as(u32, 524288);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_USE_MASK = @as(u32, 4278190080);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_SAVE = @as(u32, 2147483648);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_SAVE_CRED_CHECKED = @as(u32, 1073741824);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_NO_CHECKBOX = @as(u32, 536870912);
pub const SEC_WINNT_AUTH_IDENTITY_FLAGS_SSPIPFC_CREDPROV_DO_NOT_LOAD = @as(u32, 268435456);
pub const SSPIPFC_CREDPROV_DO_NOT_SAVE = @as(u32, 1);
pub const SSPIPFC_NO_CHECKBOX = @as(u32, 2);
pub const SSPIPFC_CREDPROV_DO_NOT_LOAD = @as(u32, 4);
pub const SSPIPFC_USE_CREDUIBROKER = @as(u32, 8);
pub const NGC_DATA_FLAG_KERB_CERTIFICATE_LOGON_FLAG_CHECK_DUPLICATES = @as(u32, 1);
pub const NGC_DATA_FLAG_KERB_CERTIFICATE_LOGON_FLAG_USE_CERTIFICATE_INFO = @as(u32, 2);
pub const NGC_DATA_FLAG_IS_SMARTCARD_DATA = @as(u32, 4);
pub const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_LOGON = @as(u32, 1);
pub const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_PROCESS = @as(u32, 2);
pub const SEC_WINNT_AUTH_IDENTITY_ENCRYPT_FOR_SYSTEM = @as(u32, 4);
pub const SEC_WINNT_AUTH_IDENTITY_MARSHALLED = @as(u32, 4);
pub const SEC_WINNT_AUTH_IDENTITY_ONLY = @as(u32, 8);
pub const SECPKG_OPTIONS_PERMANENT = @as(u32, 1);
pub const NERR_BASE = @as(u32, 2100);
pub const NERR_PasswordExpired = @as(u32, 2242);
pub const CRED_MAX_STRING_LENGTH = @as(u32, 256);
pub const CRED_MAX_GENERIC_TARGET_NAME_LENGTH = @as(u32, 32767);
pub const CRED_MAX_TARGETNAME_NAMESPACE_LENGTH = @as(u32, 256);
pub const CRED_MAX_TARGETNAME_ATTRIBUTE_LENGTH = @as(u32, 256);
pub const CRED_MAX_VALUE_SIZE = @as(u32, 256);
pub const CRED_MAX_ATTRIBUTES = @as(u32, 64);
pub const CRED_LOGON_TYPES_MASK = @as(u32, 61440);
pub const CRED_TI_SERVER_FORMAT_UNKNOWN = @as(u32, 1);
pub const CRED_TI_DOMAIN_FORMAT_UNKNOWN = @as(u32, 2);
pub const CRED_TI_ONLY_PASSWORD_REQUIRED = @as(u32, 4);
pub const CRED_TI_USERNAME_TARGET = @as(u32, 8);
pub const CRED_TI_CREATE_EXPLICIT_CRED = @as(u32, 16);
pub const CRED_TI_WORKGROUP_MEMBER = @as(u32, 32);
pub const CRED_TI_DNSTREE_IS_DFS_SERVER = @as(u32, 64);
pub const CRED_TI_VALID_FLAGS = @as(u32, 61567);
pub const CERT_HASH_LENGTH = @as(u32, 20);
pub const CRED_PACK_PROTECTED_CREDENTIALS = @as(u32, 1);
pub const CRED_PACK_WOW_BUFFER = @as(u32, 2);
pub const CRED_PACK_GENERIC_CREDENTIALS = @as(u32, 4);
pub const CRED_PACK_ID_PROVIDER_CREDENTIALS = @as(u32, 8);
pub const CREDUI_MAX_MESSAGE_LENGTH = @as(u32, 1024);
pub const CREDUI_MAX_CAPTION_LENGTH = @as(u32, 128);
pub const CRED_PRESERVE_CREDENTIAL_BLOB = @as(u32, 1);
pub const CRED_CACHE_TARGET_INFORMATION = @as(u32, 1);
pub const CRED_ALLOW_NAME_RESOLUTION = @as(u32, 1);
pub const CRED_PROTECT_AS_SELF = @as(u32, 1);
pub const CRED_PROTECT_TO_SYSTEM = @as(u32, 2);
pub const CRED_UNPROTECT_AS_SELF = @as(u32, 1);
pub const CRED_UNPROTECT_ALLOW_TO_SYSTEM = @as(u32, 2);
pub const Audit_System_SecurityStateChange = Guid.initString("0cce9210-69ae-11d9-bed3-505054503030");
pub const Audit_System_SecuritySubsystemExtension = Guid.initString("0cce9211-69ae-11d9-bed3-505054503030");
pub const Audit_System_Integrity = Guid.initString("0cce9212-69ae-11d9-bed3-505054503030");
pub const Audit_System_IPSecDriverEvents = Guid.initString("0cce9213-69ae-11d9-bed3-505054503030");
pub const Audit_System_Others = Guid.initString("0cce9214-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_Logon = Guid.initString("0cce9215-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_Logoff = Guid.initString("0cce9216-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_AccountLockout = Guid.initString("0cce9217-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_IPSecMainMode = Guid.initString("0cce9218-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_IPSecQuickMode = Guid.initString("0cce9219-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_IPSecUserMode = Guid.initString("0cce921a-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_SpecialLogon = Guid.initString("0cce921b-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_Others = Guid.initString("0cce921c-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_FileSystem = Guid.initString("0cce921d-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Registry = Guid.initString("0cce921e-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Kernel = Guid.initString("0cce921f-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Sam = Guid.initString("0cce9220-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_CertificationServices = Guid.initString("0cce9221-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_ApplicationGenerated = Guid.initString("0cce9222-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Handle = Guid.initString("0cce9223-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Share = Guid.initString("0cce9224-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_FirewallPacketDrops = Guid.initString("0cce9225-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_FirewallConnection = Guid.initString("0cce9226-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_Other = Guid.initString("0cce9227-69ae-11d9-bed3-505054503030");
pub const Audit_PrivilegeUse_Sensitive = Guid.initString("0cce9228-69ae-11d9-bed3-505054503030");
pub const Audit_PrivilegeUse_NonSensitive = Guid.initString("0cce9229-69ae-11d9-bed3-505054503030");
pub const Audit_PrivilegeUse_Others = Guid.initString("0cce922a-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_ProcessCreation = Guid.initString("0cce922b-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_ProcessTermination = Guid.initString("0cce922c-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_DpapiActivity = Guid.initString("0cce922d-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_RpcCall = Guid.initString("0cce922e-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_AuditPolicy = Guid.initString("0cce922f-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_AuthenticationPolicy = Guid.initString("0cce9230-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_AuthorizationPolicy = Guid.initString("0cce9231-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_MpsscvRulePolicy = Guid.initString("0cce9232-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_WfpIPSecPolicy = Guid.initString("0cce9233-69ae-11d9-bed3-505054503030");
pub const Audit_PolicyChange_Others = Guid.initString("0cce9234-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_UserAccount = Guid.initString("0cce9235-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_ComputerAccount = Guid.initString("0cce9236-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_SecurityGroup = Guid.initString("0cce9237-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_DistributionGroup = Guid.initString("0cce9238-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_ApplicationGroup = Guid.initString("0cce9239-69ae-11d9-bed3-505054503030");
pub const Audit_AccountManagement_Others = Guid.initString("0cce923a-69ae-11d9-bed3-505054503030");
pub const Audit_DSAccess_DSAccess = Guid.initString("0cce923b-69ae-11d9-bed3-505054503030");
pub const Audit_DsAccess_AdAuditChanges = Guid.initString("0cce923c-69ae-11d9-bed3-505054503030");
pub const Audit_Ds_Replication = Guid.initString("0cce923d-69ae-11d9-bed3-505054503030");
pub const Audit_Ds_DetailedReplication = Guid.initString("0cce923e-69ae-11d9-bed3-505054503030");
pub const Audit_AccountLogon_CredentialValidation = Guid.initString("0cce923f-69ae-11d9-bed3-505054503030");
pub const Audit_AccountLogon_Kerberos = Guid.initString("0cce9240-69ae-11d9-bed3-505054503030");
pub const Audit_AccountLogon_Others = Guid.initString("0cce9241-69ae-11d9-bed3-505054503030");
pub const Audit_AccountLogon_KerbCredentialValidation = Guid.initString("0cce9242-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_NPS = Guid.initString("0cce9243-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_DetailedFileShare = Guid.initString("0cce9244-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_RemovableStorage = Guid.initString("0cce9245-69ae-11d9-bed3-505054503030");
pub const Audit_ObjectAccess_CbacStaging = Guid.initString("0cce9246-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_Claims = Guid.initString("0cce9247-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_PnpActivity = Guid.initString("0cce9248-69ae-11d9-bed3-505054503030");
pub const Audit_Logon_Groups = Guid.initString("0cce9249-69ae-11d9-bed3-505054503030");
pub const Audit_DetailedTracking_TokenRightAdjusted = Guid.initString("0cce924a-69ae-11d9-bed3-505054503030");
pub const Audit_System = Guid.initString("69979848-797a-11d9-bed3-505054503030");
pub const Audit_Logon = Guid.initString("69979849-797a-11d9-bed3-505054503030");
pub const Audit_ObjectAccess = Guid.initString("6997984a-797a-11d9-bed3-505054503030");
pub const Audit_PrivilegeUse = Guid.initString("6997984b-797a-11d9-bed3-505054503030");
pub const Audit_DetailedTracking = Guid.initString("6997984c-797a-11d9-bed3-505054503030");
pub const Audit_PolicyChange = Guid.initString("6997984d-797a-11d9-bed3-505054503030");
pub const Audit_AccountManagement = Guid.initString("6997984e-797a-11d9-bed3-505054503030");
pub const Audit_DirectoryServiceAccess = Guid.initString("6997984f-797a-11d9-bed3-505054503030");
pub const Audit_AccountLogon = Guid.initString("69979850-797a-11d9-bed3-505054503030");
pub const LSA_MODE_PASSWORD_PROTECTED = @as(i32, 1);
pub const LSA_MODE_INDIVIDUAL_ACCOUNTS = @as(i32, 2);
pub const LSA_MODE_MANDATORY_ACCESS = @as(i32, 4);
pub const LSA_MODE_LOG_FULL = @as(i32, 8);
pub const SE_ADT_OBJECT_ONLY = @as(u32, 1);
pub const SE_MAX_AUDIT_PARAMETERS = @as(u32, 32);
pub const SE_MAX_GENERIC_AUDIT_PARAMETERS = @as(u32, 28);
pub const SE_ADT_PARAMETERS_SELF_RELATIVE = @as(u32, 1);
pub const SE_ADT_PARAMETERS_SEND_TO_LSA = @as(u32, 2);
pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT = @as(u32, 4);
pub const SE_ADT_PARAMETER_GENERIC_AUDIT = @as(u32, 8);
pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS = @as(u32, 16);
pub const POLICY_AUDIT_EVENT_UNCHANGED = @as(i32, 0);
pub const POLICY_AUDIT_EVENT_SUCCESS = @as(i32, 1);
pub const POLICY_AUDIT_EVENT_FAILURE = @as(i32, 2);
pub const POLICY_AUDIT_EVENT_NONE = @as(i32, 4);
pub const POLICY_VIEW_LOCAL_INFORMATION = @as(i32, 1);
pub const POLICY_VIEW_AUDIT_INFORMATION = @as(i32, 2);
pub const POLICY_GET_PRIVATE_INFORMATION = @as(i32, 4);
pub const POLICY_TRUST_ADMIN = @as(i32, 8);
pub const POLICY_CREATE_ACCOUNT = @as(i32, 16);
pub const POLICY_CREATE_SECRET = @as(i32, 32);
pub const POLICY_CREATE_PRIVILEGE = @as(i32, 64);
pub const POLICY_SET_DEFAULT_QUOTA_LIMITS = @as(i32, 128);
pub const POLICY_SET_AUDIT_REQUIREMENTS = @as(i32, 256);
pub const POLICY_AUDIT_LOG_ADMIN = @as(i32, 512);
pub const POLICY_SERVER_ADMIN = @as(i32, 1024);
pub const POLICY_LOOKUP_NAMES = @as(i32, 2048);
pub const POLICY_NOTIFICATION = @as(i32, 4096);
pub const PER_USER_POLICY_UNCHANGED = @as(u32, 0);
pub const PER_USER_AUDIT_SUCCESS_INCLUDE = @as(u32, 1);
pub const PER_USER_AUDIT_SUCCESS_EXCLUDE = @as(u32, 2);
pub const PER_USER_AUDIT_FAILURE_INCLUDE = @as(u32, 4);
pub const PER_USER_AUDIT_FAILURE_EXCLUDE = @as(u32, 8);
pub const PER_USER_AUDIT_NONE = @as(u32, 16);
pub const POLICY_QOS_SCHANNEL_REQUIRED = @as(u32, 1);
pub const POLICY_QOS_OUTBOUND_INTEGRITY = @as(u32, 2);
pub const POLICY_QOS_OUTBOUND_CONFIDENTIALITY = @as(u32, 4);
pub const POLICY_QOS_INBOUND_INTEGRITY = @as(u32, 8);
pub const POLICY_QOS_INBOUND_CONFIDENTIALITY = @as(u32, 16);
pub const POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE = @as(u32, 32);
pub const POLICY_QOS_RAS_SERVER_ALLOWED = @as(u32, 64);
pub const POLICY_QOS_DHCP_SERVER_ALLOWED = @as(u32, 128);
pub const POLICY_KERBEROS_VALIDATE_CLIENT = @as(u32, 128);
pub const TRUST_ATTRIBUTE_TREE_PARENT = @as(u32, 4194304);
pub const TRUST_ATTRIBUTE_TREE_ROOT = @as(u32, 8388608);
pub const TRUST_ATTRIBUTES_VALID = @as(u32, 4278386687);
pub const TRUST_ATTRIBUTE_QUARANTINED_DOMAIN = @as(u32, 4);
pub const TRUST_ATTRIBUTE_TRUST_USES_RC4_ENCRYPTION = @as(u32, 128);
pub const TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS = @as(u32, 256);
pub const TRUST_ATTRIBUTE_CROSS_ORGANIZATION_NO_TGT_DELEGATION = @as(u32, 512);
pub const TRUST_ATTRIBUTE_PIM_TRUST = @as(u32, 1024);
pub const TRUST_ATTRIBUTE_CROSS_ORGANIZATION_ENABLE_TGT_DELEGATION = @as(u32, 2048);
pub const TRUST_ATTRIBUTES_USER = @as(u32, 4278190080);
pub const LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED = @as(u32, 2147483648);
pub const LSA_FTRECORD_DISABLED_REASONS = @as(i32, 65535);
pub const LSA_TLN_DISABLED_NEW = @as(i32, 1);
pub const LSA_TLN_DISABLED_ADMIN = @as(i32, 2);
pub const LSA_TLN_DISABLED_CONFLICT = @as(i32, 4);
pub const LSA_SID_DISABLED_ADMIN = @as(i32, 1);
pub const LSA_SID_DISABLED_CONFLICT = @as(i32, 2);
pub const LSA_NB_DISABLED_ADMIN = @as(i32, 4);
pub const LSA_NB_DISABLED_CONFLICT = @as(i32, 8);
pub const MAX_RECORDS_IN_FOREST_TRUST_INFO = @as(u32, 4000);
pub const MAXIMUM_CAPES_PER_CAP = @as(u32, 127);
pub const CENTRAL_ACCESS_POLICY_OWNER_RIGHTS_PRESENT_FLAG = @as(u32, 1);
pub const CENTRAL_ACCESS_POLICY_STAGED_OWNER_RIGHTS_PRESENT_FLAG = @as(u32, 256);
pub const CENTRAL_ACCESS_POLICY_STAGED_FLAG = @as(u32, 65536);
pub const LSASETCAPS_RELOAD_FLAG = @as(u32, 1);
pub const NEGOTIATE_MAX_PREFIX = @as(u32, 32);
pub const DOMAIN_NO_LM_OWF_CHANGE = @as(i32, 64);
pub const MSV1_0_CHALLENGE_LENGTH = @as(u32, 8);
pub const MSV1_0_USER_SESSION_KEY_LENGTH = @as(u32, 16);
pub const MSV1_0_LANMAN_SESSION_KEY_LENGTH = @as(u32, 8);
pub const MSV1_0_USE_CLIENT_CHALLENGE = @as(u32, 128);
pub const MSV1_0_DISABLE_PERSONAL_FALLBACK = @as(u32, 4096);
pub const MSV1_0_ALLOW_FORCE_GUEST = @as(u32, 8192);
pub const MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED = @as(u32, 16384);
pub const MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY = @as(u32, 32768);
pub const MSV1_0_SUBAUTHENTICATION_DLL_EX = @as(u32, 1048576);
pub const MSV1_0_ALLOW_MSVCHAPV2 = @as(u32, 65536);
pub const MSV1_0_S4U2SELF = @as(u32, 131072);
pub const MSV1_0_CHECK_LOGONHOURS_FOR_S4U = @as(u32, 262144);
pub const MSV1_0_INTERNET_DOMAIN = @as(u32, 524288);
pub const MSV1_0_SUBAUTHENTICATION_DLL = @as(u32, 4278190080);
pub const MSV1_0_SUBAUTHENTICATION_DLL_SHIFT = @as(u32, 24);
pub const MSV1_0_MNS_LOGON = @as(u32, 16777216);
pub const MSV1_0_SUBAUTHENTICATION_DLL_RAS = @as(u32, 2);
pub const MSV1_0_SUBAUTHENTICATION_DLL_IIS = @as(u32, 132);
pub const MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS = @as(u32, 2);
pub const LOGON_NTLMV2_ENABLED = @as(u32, 256);
pub const LOGON_NT_V2 = @as(u32, 2048);
pub const LOGON_LM_V2 = @as(u32, 4096);
pub const LOGON_NTLM_V2 = @as(u32, 8192);
pub const LOGON_OPTIMIZED = @as(u32, 16384);
pub const LOGON_WINLOGON = @as(u32, 32768);
pub const LOGON_PKINIT = @as(u32, 65536);
pub const LOGON_NO_OPTIMIZED = @as(u32, 131072);
pub const LOGON_NO_ELEVATION = @as(u32, 262144);
pub const LOGON_MANAGED_SERVICE = @as(u32, 524288);
pub const MSV1_0_SUBAUTHENTICATION_FLAGS = @as(u32, 4278190080);
pub const LOGON_GRACE_LOGON = @as(u32, 16777216);
pub const MSV1_0_OWF_PASSWORD_LENGTH = @as(u32, 16);
pub const MSV1_0_SHA_PASSWORD_LENGTH = @as(u32, 20);
pub const MSV1_0_CREDENTIAL_KEY_LENGTH = @as(u32, 20);
pub const MSV1_0_CRED_REMOVED = @as(u32, 4);
pub const MSV1_0_CRED_CREDKEY_PRESENT = @as(u32, 8);
pub const MSV1_0_CRED_SHA_PRESENT = @as(u32, 16);
pub const MSV1_0_CRED_VERSION_V2 = @as(u32, 2);
pub const MSV1_0_CRED_VERSION_V3 = @as(u32, 4);
pub const MSV1_0_CRED_VERSION_IUM = @as(u32, 4294901761);
pub const MSV1_0_CRED_VERSION_REMOTE = @as(u32, 4294901762);
pub const MSV1_0_CRED_VERSION_ARSO = @as(u32, 4294901763);
pub const MSV1_0_CRED_VERSION_RESERVED_1 = @as(u32, 4294967294);
pub const MSV1_0_CRED_VERSION_INVALID = @as(u32, 4294967295);
pub const MSV1_0_NTLM3_RESPONSE_LENGTH = @as(u32, 16);
pub const MSV1_0_NTLM3_OWF_LENGTH = @as(u32, 16);
pub const MSV1_0_MAX_NTLM3_LIFE = @as(u32, 1800);
pub const MSV1_0_MAX_AVL_SIZE = @as(u32, 64000);
pub const MSV1_0_AV_FLAG_FORCE_GUEST = @as(u32, 1);
pub const MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES = @as(u32, 2);
pub const MSV1_0_AV_FLAG_UNVERIFIED_TARGET = @as(u32, 4);
pub const RTL_ENCRYPT_MEMORY_SIZE = @as(u32, 8);
pub const RTL_ENCRYPT_OPTION_CROSS_PROCESS = @as(u32, 1);
pub const RTL_ENCRYPT_OPTION_SAME_LOGON = @as(u32, 2);
pub const RTL_ENCRYPT_OPTION_FOR_SYSTEM = @as(u32, 4);
pub const KERBEROS_VERSION = @as(u32, 5);
pub const KERBEROS_REVISION = @as(u32, 6);
pub const KERB_ETYPE_AES128_CTS_HMAC_SHA1_96 = @as(u32, 17);
pub const KERB_ETYPE_AES256_CTS_HMAC_SHA1_96 = @as(u32, 18);
pub const KERB_ETYPE_RC4_PLAIN2 = @as(i32, -129);
pub const KERB_ETYPE_RC4_LM = @as(i32, -130);
pub const KERB_ETYPE_RC4_SHA = @as(i32, -131);
pub const KERB_ETYPE_DES_PLAIN = @as(i32, -132);
pub const KERB_ETYPE_RC4_HMAC_OLD = @as(i32, -133);
pub const KERB_ETYPE_RC4_PLAIN_OLD = @as(i32, -134);
pub const KERB_ETYPE_RC4_HMAC_OLD_EXP = @as(i32, -135);
pub const KERB_ETYPE_RC4_PLAIN_OLD_EXP = @as(i32, -136);
pub const KERB_ETYPE_RC4_PLAIN = @as(i32, -140);
pub const KERB_ETYPE_RC4_PLAIN_EXP = @as(i32, -141);
pub const KERB_ETYPE_AES128_CTS_HMAC_SHA1_96_PLAIN = @as(i32, -148);
pub const KERB_ETYPE_AES256_CTS_HMAC_SHA1_96_PLAIN = @as(i32, -149);
pub const KERB_ETYPE_DSA_SHA1_CMS = @as(u32, 9);
pub const KERB_ETYPE_RSA_MD5_CMS = @as(u32, 10);
pub const KERB_ETYPE_RSA_SHA1_CMS = @as(u32, 11);
pub const KERB_ETYPE_RC2_CBC_ENV = @as(u32, 12);
pub const KERB_ETYPE_RSA_ENV = @as(u32, 13);
pub const KERB_ETYPE_RSA_ES_OEAP_ENV = @as(u32, 14);
pub const KERB_ETYPE_DES_EDE3_CBC_ENV = @as(u32, 15);
pub const KERB_ETYPE_DSA_SIGN = @as(u32, 8);
pub const KERB_ETYPE_RSA_PRIV = @as(u32, 9);
pub const KERB_ETYPE_RSA_PUB = @as(u32, 10);
pub const KERB_ETYPE_RSA_PUB_MD5 = @as(u32, 11);
pub const KERB_ETYPE_RSA_PUB_SHA1 = @as(u32, 12);
pub const KERB_ETYPE_PKCS7_PUB = @as(u32, 13);
pub const KERB_ETYPE_DES3_CBC_MD5 = @as(u32, 5);
pub const KERB_ETYPE_DES3_CBC_SHA1 = @as(u32, 7);
pub const KERB_ETYPE_DES3_CBC_SHA1_KD = @as(u32, 16);
pub const KERB_ETYPE_DES_CBC_MD5_NT = @as(u32, 20);
pub const KERB_ETYPE_RC4_HMAC_NT_EXP = @as(u32, 24);
pub const KERB_CHECKSUM_NONE = @as(u32, 0);
pub const KERB_CHECKSUM_CRC32 = @as(u32, 1);
pub const KERB_CHECKSUM_MD4 = @as(u32, 2);
pub const KERB_CHECKSUM_KRB_DES_MAC = @as(u32, 4);
pub const KERB_CHECKSUM_KRB_DES_MAC_K = @as(u32, 5);
pub const KERB_CHECKSUM_MD5 = @as(u32, 7);
pub const KERB_CHECKSUM_MD5_DES = @as(u32, 8);
pub const KERB_CHECKSUM_SHA1_NEW = @as(u32, 14);
pub const KERB_CHECKSUM_HMAC_SHA1_96_AES128 = @as(u32, 15);
pub const KERB_CHECKSUM_HMAC_SHA1_96_AES256 = @as(u32, 16);
pub const KERB_CHECKSUM_LM = @as(i32, -130);
pub const KERB_CHECKSUM_SHA1 = @as(i32, -131);
pub const KERB_CHECKSUM_REAL_CRC32 = @as(i32, -132);
pub const KERB_CHECKSUM_DES_MAC = @as(i32, -133);
pub const KERB_CHECKSUM_DES_MAC_MD5 = @as(i32, -134);
pub const KERB_CHECKSUM_MD25 = @as(i32, -135);
pub const KERB_CHECKSUM_RC4_MD5 = @as(i32, -136);
pub const KERB_CHECKSUM_MD5_HMAC = @as(i32, -137);
pub const KERB_CHECKSUM_HMAC_MD5 = @as(i32, -138);
pub const KERB_CHECKSUM_HMAC_SHA1_96_AES128_Ki = @as(i32, -150);
pub const KERB_CHECKSUM_HMAC_SHA1_96_AES256_Ki = @as(i32, -151);
pub const AUTH_REQ_ALLOW_FORWARDABLE = @as(u32, 1);
pub const AUTH_REQ_ALLOW_PROXIABLE = @as(u32, 2);
pub const AUTH_REQ_ALLOW_POSTDATE = @as(u32, 4);
pub const AUTH_REQ_ALLOW_RENEWABLE = @as(u32, 8);
pub const AUTH_REQ_ALLOW_NOADDRESS = @as(u32, 16);
pub const AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY = @as(u32, 32);
pub const AUTH_REQ_ALLOW_VALIDATE = @as(u32, 64);
pub const AUTH_REQ_VALIDATE_CLIENT = @as(u32, 128);
pub const AUTH_REQ_OK_AS_DELEGATE = @as(u32, 256);
pub const AUTH_REQ_PREAUTH_REQUIRED = @as(u32, 512);
pub const AUTH_REQ_TRANSITIVE_TRUST = @as(u32, 1024);
pub const AUTH_REQ_ALLOW_S4U_DELEGATE = @as(u32, 2048);
pub const KERB_TICKET_FLAGS_name_canonicalize = @as(u32, 65536);
pub const KERB_TICKET_FLAGS_cname_in_pa_data = @as(u32, 262144);
pub const KERB_TICKET_FLAGS_enc_pa_rep = @as(u32, 65536);
pub const KRB_NT_UNKNOWN = @as(u32, 0);
pub const KRB_NT_PRINCIPAL = @as(u32, 1);
pub const KRB_NT_PRINCIPAL_AND_ID = @as(i32, -131);
pub const KRB_NT_SRV_INST = @as(u32, 2);
pub const KRB_NT_SRV_INST_AND_ID = @as(i32, -132);
pub const KRB_NT_SRV_HST = @as(u32, 3);
pub const KRB_NT_SRV_XHST = @as(u32, 4);
pub const KRB_NT_UID = @as(u32, 5);
pub const KRB_NT_ENTERPRISE_PRINCIPAL = @as(u32, 10);
pub const KRB_NT_WELLKNOWN = @as(u32, 11);
pub const KRB_NT_ENT_PRINCIPAL_AND_ID = @as(i32, -130);
pub const KRB_NT_MS_PRINCIPAL = @as(i32, -128);
pub const KRB_NT_MS_PRINCIPAL_AND_ID = @as(i32, -129);
pub const KRB_NT_MS_BRANCH_ID = @as(i32, -133);
pub const KRB_NT_X500_PRINCIPAL = @as(u32, 6);
pub const KERB_WRAP_NO_ENCRYPT = @as(u32, 2147483649);
pub const KERB_CERTIFICATE_LOGON_FLAG_CHECK_DUPLICATES = @as(u32, 1);
pub const KERB_CERTIFICATE_LOGON_FLAG_USE_CERTIFICATE_INFO = @as(u32, 2);
pub const KERB_CERTIFICATE_S4U_LOGON_FLAG_CHECK_DUPLICATES = @as(u32, 1);
pub const KERB_CERTIFICATE_S4U_LOGON_FLAG_CHECK_LOGONHOURS = @as(u32, 2);
pub const KERB_CERTIFICATE_S4U_LOGON_FLAG_FAIL_IF_NT_AUTH_POLICY_REQUIRED = @as(u32, 4);
pub const KERB_CERTIFICATE_S4U_LOGON_FLAG_IDENTIFY = @as(u32, 8);
pub const KERB_LOGON_FLAG_ALLOW_EXPIRED_TICKET = @as(u32, 1);
pub const KERB_LOGON_FLAG_REDIRECTED = @as(u32, 2);
pub const KERB_S4U_LOGON_FLAG_CHECK_LOGONHOURS = @as(u32, 2);
pub const KERB_S4U_LOGON_FLAG_IDENTIFY = @as(u32, 8);
pub const KERB_USE_DEFAULT_TICKET_FLAGS = @as(u32, 0);
pub const KERB_RETRIEVE_TICKET_DEFAULT = @as(u32, 0);
pub const KERB_RETRIEVE_TICKET_DONT_USE_CACHE = @as(u32, 1);
pub const KERB_RETRIEVE_TICKET_USE_CACHE_ONLY = @as(u32, 2);
pub const KERB_RETRIEVE_TICKET_USE_CREDHANDLE = @as(u32, 4);
pub const KERB_RETRIEVE_TICKET_AS_KERB_CRED = @as(u32, 8);
pub const KERB_RETRIEVE_TICKET_WITH_SEC_CRED = @as(u32, 16);
pub const KERB_RETRIEVE_TICKET_CACHE_TICKET = @as(u32, 32);
pub const KERB_RETRIEVE_TICKET_MAX_LIFETIME = @as(u32, 64);
pub const KERB_ETYPE_DEFAULT = @as(u32, 0);
pub const KERB_PURGE_ALL_TICKETS = @as(u32, 1);
pub const KERB_S4U2PROXY_CACHE_ENTRY_INFO_FLAG_NEGATIVE = @as(u32, 1);
pub const KERB_S4U2PROXY_CRED_FLAG_NEGATIVE = @as(u32, 1);
pub const DS_UNKNOWN_ADDRESS_TYPE = @as(u32, 0);
pub const KERB_SETPASS_USE_LOGONID = @as(u32, 1);
pub const KERB_SETPASS_USE_CREDHANDLE = @as(u32, 2);
pub const KERB_DECRYPT_FLAG_DEFAULT_KEY = @as(u32, 1);
pub const KERB_REFRESH_SCCRED_RELEASE = @as(u32, 0);
pub const KERB_REFRESH_SCCRED_GETTGT = @as(u32, 1);
pub const KERB_TRANSFER_CRED_WITH_TICKETS = @as(u32, 1);
pub const KERB_TRANSFER_CRED_CLEANUP_CREDENTIALS = @as(u32, 2);
pub const KERB_QUERY_DOMAIN_EXTENDED_POLICIES_RESPONSE_FLAG_DAC_DISABLED = @as(u32, 1);
pub const AUDIT_SET_SYSTEM_POLICY = @as(u32, 1);
pub const AUDIT_QUERY_SYSTEM_POLICY = @as(u32, 2);
pub const AUDIT_SET_USER_POLICY = @as(u32, 4);
pub const AUDIT_QUERY_USER_POLICY = @as(u32, 8);
pub const AUDIT_ENUMERATE_USERS = @as(u32, 16);
pub const AUDIT_SET_MISC_POLICY = @as(u32, 32);
pub const AUDIT_QUERY_MISC_POLICY = @as(u32, 64);
pub const WNGETCON_CONNECTED = @as(u32, 0);
pub const WNGETCON_DISCONNECTED = @as(u32, 1);
pub const WNNC_SPEC_VERSION = @as(u32, 1);
pub const WNNC_SPEC_VERSION51 = @as(u32, 327681);
pub const WNNC_NET_TYPE = @as(u32, 2);
pub const WNNC_NET_NONE = @as(u32, 0);
pub const WNNC_DRIVER_VERSION = @as(u32, 3);
pub const WNNC_USER = @as(u32, 4);
pub const WNNC_USR_GETUSER = @as(u32, 1);
pub const WNNC_CONNECTION = @as(u32, 6);
pub const WNNC_CON_ADDCONNECTION = @as(u32, 1);
pub const WNNC_CON_CANCELCONNECTION = @as(u32, 2);
pub const WNNC_CON_GETCONNECTIONS = @as(u32, 4);
pub const WNNC_CON_ADDCONNECTION3 = @as(u32, 8);
pub const WNNC_CON_ADDCONNECTION4 = @as(u32, 16);
pub const WNNC_CON_GETPERFORMANCE = @as(u32, 64);
pub const WNNC_CON_DEFER = @as(u32, 128);
pub const WNNC_DIALOG = @as(u32, 8);
pub const WNNC_DLG_DEVICEMODE = @as(u32, 1);
pub const WNNC_DLG_PROPERTYDIALOG = @as(u32, 32);
pub const WNNC_DLG_SEARCHDIALOG = @as(u32, 64);
pub const WNNC_DLG_FORMATNETWORKNAME = @as(u32, 128);
pub const WNNC_DLG_PERMISSIONEDITOR = @as(u32, 256);
pub const WNNC_DLG_GETRESOURCEPARENT = @as(u32, 512);
pub const WNNC_DLG_GETRESOURCEINFORMATION = @as(u32, 2048);
pub const WNNC_ADMIN = @as(u32, 9);
pub const WNNC_ADM_GETDIRECTORYTYPE = @as(u32, 1);
pub const WNNC_ADM_DIRECTORYNOTIFY = @as(u32, 2);
pub const WNNC_ENUMERATION = @as(u32, 11);
pub const WNNC_ENUM_GLOBAL = @as(u32, 1);
pub const WNNC_ENUM_LOCAL = @as(u32, 2);
pub const WNNC_ENUM_CONTEXT = @as(u32, 4);
pub const WNNC_ENUM_SHAREABLE = @as(u32, 8);
pub const WNNC_START = @as(u32, 12);
pub const WNNC_WAIT_FOR_START = @as(u32, 1);
pub const WNNC_CONNECTION_FLAGS = @as(u32, 13);
pub const WNTYPE_DRIVE = @as(u32, 1);
pub const WNTYPE_FILE = @as(u32, 2);
pub const WNTYPE_PRINTER = @as(u32, 3);
pub const WNTYPE_COMM = @as(u32, 4);
pub const WNSRCH_REFRESH_FIRST_LEVEL = @as(u32, 1);
pub const WNDT_NORMAL = @as(u32, 0);
pub const WNDT_NETWORK = @as(u32, 1);
pub const WN_NETWORK_CLASS = @as(u32, 1);
pub const WN_CREDENTIAL_CLASS = @as(u32, 2);
pub const WN_PRIMARY_AUTHENT_CLASS = @as(u32, 4);
pub const WN_SERVICE_CLASS = @as(u32, 8);
pub const WN_VALID_LOGON_ACCOUNT = @as(u32, 1);
pub const WN_NT_PASSWORD_CHANGED = @as(u32, 2);
pub const NOTIFY_PRE = @as(u32, 1);
pub const NOTIFY_POST = @as(u32, 2);
pub const WNPERMC_PERM = @as(u32, 1);
pub const WNPERMC_AUDIT = @as(u32, 2);
pub const WNPERMC_OWNER = @as(u32, 4);
pub const LSA_MAXIMUM_SID_COUNT = @as(i32, 256);
pub const LSA_MAXIMUM_ENUMERATION_LENGTH = @as(u32, 32000);
pub const LSA_CALL_LICENSE_SERVER = @as(u32, 2147483648);
pub const SE_ADT_POLICY_AUDIT_EVENT_TYPE_EX_BEGIN = @as(u32, 100);
pub const LSA_LOOKUP_ISOLATED_AS_LOCAL = @as(u32, 2147483648);
pub const LSA_LOOKUP_DISALLOW_CONNECTED_ACCOUNT_INTERNET_SID = @as(u32, 2147483648);
pub const LSA_LOOKUP_PREFER_INTERNET_NAMES = @as(u32, 1073741824);
pub const ACCOUNT_VIEW = @as(i32, 1);
pub const ACCOUNT_ADJUST_PRIVILEGES = @as(i32, 2);
pub const ACCOUNT_ADJUST_QUOTAS = @as(i32, 4);
pub const ACCOUNT_ADJUST_SYSTEM_ACCESS = @as(i32, 8);
pub const TRUSTED_QUERY_DOMAIN_NAME = @as(i32, 1);
pub const TRUSTED_QUERY_CONTROLLERS = @as(i32, 2);
pub const TRUSTED_SET_CONTROLLERS = @as(i32, 4);
pub const TRUSTED_QUERY_POSIX = @as(i32, 8);
pub const TRUSTED_SET_POSIX = @as(i32, 16);
pub const TRUSTED_SET_AUTH = @as(i32, 32);
pub const TRUSTED_QUERY_AUTH = @as(i32, 64);
pub const SECRET_SET_VALUE = @as(i32, 1);
pub const SECRET_QUERY_VALUE = @as(i32, 2);
pub const LSA_GLOBAL_SECRET_PREFIX_LENGTH = @as(u32, 2);
pub const LSA_LOCAL_SECRET_PREFIX_LENGTH = @as(u32, 2);
pub const LSA_SECRET_MAXIMUM_COUNT = @as(i32, 4096);
pub const LSA_SECRET_MAXIMUM_LENGTH = @as(i32, 512);
pub const NEGOTIATE_ALLOW_NTLM = @as(u32, 268435456);
pub const NEGOTIATE_NEG_NTLM = @as(u32, 536870912);
pub const MAX_USER_RECORDS = @as(u32, 1000);
pub const SCARD_SCOPE_TERMINAL = @as(u32, 1);
pub const SCARD_PROVIDER_PRIMARY = @as(u32, 1);
pub const SCARD_PROVIDER_CSP = @as(u32, 2);
pub const SCARD_PROVIDER_KSP = @as(u32, 3);
pub const SCARD_STATE_UNPOWERED = @as(u32, 1024);
pub const SCARD_SHARE_EXCLUSIVE = @as(u32, 1);
pub const SCARD_SHARE_SHARED = @as(u32, 2);
pub const SCARD_SHARE_DIRECT = @as(u32, 3);
pub const SCARD_LEAVE_CARD = @as(u32, 0);
pub const SCARD_RESET_CARD = @as(u32, 1);
pub const SCARD_UNPOWER_CARD = @as(u32, 2);
pub const SCARD_EJECT_CARD = @as(u32, 3);
pub const SC_DLG_MINIMAL_UI = @as(u32, 1);
pub const SC_DLG_NO_UI = @as(u32, 2);
pub const SC_DLG_FORCE_UI = @as(u32, 4);
pub const SCERR_NOCARDNAME = @as(u32, 16384);
pub const SCERR_NOGUIDS = @as(u32, 32768);
pub const SCARD_AUDIT_CHV_FAILURE = @as(u32, 0);
pub const SCARD_AUDIT_CHV_SUCCESS = @as(u32, 1);
pub const USER_ACCOUNT_DISABLED = @as(u32, 1);
pub const USER_HOME_DIRECTORY_REQUIRED = @as(u32, 2);
pub const USER_PASSWORD_NOT_REQUIRED = @as(u32, 4);
pub const USER_TEMP_DUPLICATE_ACCOUNT = @as(u32, 8);
pub const USER_NORMAL_ACCOUNT = @as(u32, 16);
pub const USER_MNS_LOGON_ACCOUNT = @as(u32, 32);
pub const USER_INTERDOMAIN_TRUST_ACCOUNT = @as(u32, 64);
pub const USER_WORKSTATION_TRUST_ACCOUNT = @as(u32, 128);
pub const USER_SERVER_TRUST_ACCOUNT = @as(u32, 256);
pub const USER_DONT_EXPIRE_PASSWORD = @as(u32, 512);
pub const USER_ACCOUNT_AUTO_LOCKED = @as(u32, 1024);
pub const USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED = @as(u32, 2048);
pub const USER_SMARTCARD_REQUIRED = @as(u32, 4096);
pub const USER_TRUSTED_FOR_DELEGATION = @as(u32, 8192);
pub const USER_NOT_DELEGATED = @as(u32, 16384);
pub const USER_USE_DES_KEY_ONLY = @as(u32, 32768);
pub const USER_DONT_REQUIRE_PREAUTH = @as(u32, 65536);
pub const USER_PASSWORD_EXPIRED = @as(u32, 131072);
pub const USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION = @as(u32, 262144);
pub const USER_NO_AUTH_DATA_REQUIRED = @as(u32, 524288);
pub const USER_PARTIAL_SECRETS_ACCOUNT = @as(u32, 1048576);
pub const USER_USE_AES_KEYS = @as(u32, 2097152);
pub const SAM_DAYS_PER_WEEK = @as(u32, 7);
pub const USER_ALL_PARAMETERS = @as(u32, 2097152);
pub const CLEAR_BLOCK_LENGTH = @as(u32, 8);
pub const MSV1_0_VALIDATION_LOGOFF_TIME = @as(u32, 1);
pub const MSV1_0_VALIDATION_KICKOFF_TIME = @as(u32, 2);
pub const MSV1_0_VALIDATION_LOGON_SERVER = @as(u32, 4);
pub const MSV1_0_VALIDATION_LOGON_DOMAIN = @as(u32, 8);
pub const MSV1_0_VALIDATION_SESSION_KEY = @as(u32, 16);
pub const MSV1_0_VALIDATION_USER_FLAGS = @as(u32, 32);
pub const MSV1_0_VALIDATION_USER_ID = @as(u32, 64);
pub const MSV1_0_SUBAUTH_ACCOUNT_DISABLED = @as(u32, 1);
pub const MSV1_0_SUBAUTH_PASSWORD = @as(u32, 2);
pub const MSV1_0_SUBAUTH_WORKSTATIONS = @as(u32, 4);
pub const MSV1_0_SUBAUTH_LOGON_HOURS = @as(u32, 8);
pub const MSV1_0_SUBAUTH_ACCOUNT_EXPIRY = @as(u32, 16);
pub const MSV1_0_SUBAUTH_PASSWORD_EXPIRY = @as(u32, 32);
pub const MSV1_0_SUBAUTH_ACCOUNT_TYPE = @as(u32, 64);
pub const MSV1_0_SUBAUTH_LOCKOUT = @as(u32, 128);
pub const UNISP_RPC_ID = @as(u32, 14);
pub const RCRED_STATUS_NOCRED = @as(u32, 0);
pub const RCRED_CRED_EXISTS = @as(u32, 1);
pub const RCRED_STATUS_UNKNOWN_ISSUER = @as(u32, 2);
pub const LCRED_STATUS_NOCRED = @as(u32, 0);
pub const LCRED_CRED_EXISTS = @as(u32, 1);
pub const LCRED_STATUS_UNKNOWN_ISSUER = @as(u32, 2);
pub const SECPKGCONTEXT_CONNECTION_INFO_EX_V1 = @as(u32, 1);
pub const SECPKGCONTEXT_CIPHERINFO_V1 = @as(u32, 1);
pub const SSL_SESSION_RECONNECT = @as(u32, 1);
pub const KERN_CONTEXT_CERT_INFO_V1 = @as(u32, 0);
pub const ENABLE_TLS_CLIENT_EARLY_START = @as(u32, 1);
pub const SCH_CRED_V1 = @as(u32, 1);
pub const SCH_CRED_V2 = @as(u32, 2);
pub const SCH_CRED_VERSION = @as(u32, 2);
pub const SCH_CRED_V3 = @as(u32, 3);
pub const SCHANNEL_CRED_VERSION = @as(u32, 4);
pub const SCH_CREDENTIALS_VERSION = @as(u32, 5);
pub const TLS_PARAMS_OPTIONAL = @as(u32, 1);
pub const SCH_CRED_MAX_SUPPORTED_PARAMETERS = @as(u32, 16);
pub const SCH_CRED_MAX_SUPPORTED_ALPN_IDS = @as(u32, 16);
pub const SCH_CRED_MAX_SUPPORTED_CRYPTO_SETTINGS = @as(u32, 16);
pub const SCH_CRED_MAX_SUPPORTED_CHAINING_MODES = @as(u32, 16);
pub const SCH_MAX_EXT_SUBSCRIPTIONS = @as(u32, 2);
pub const SCH_CRED_FORMAT_CERT_CONTEXT = @as(u32, 0);
pub const SCH_CRED_FORMAT_CERT_HASH = @as(u32, 1);
pub const SCH_CRED_FORMAT_CERT_HASH_STORE = @as(u32, 2);
pub const SCH_CRED_MAX_STORE_NAME_SIZE = @as(u32, 128);
pub const SCH_CRED_MAX_SUPPORTED_ALGS = @as(u32, 256);
pub const SCH_CRED_MAX_SUPPORTED_CERTS = @as(u32, 100);
pub const SCH_MACHINE_CERT_HASH = @as(u32, 1);
pub const SCH_CRED_DISABLE_RECONNECTS = @as(u32, 128);
pub const SCH_CRED_RESTRICTED_ROOTS = @as(u32, 8192);
pub const SCH_CRED_REVOCATION_CHECK_CACHE_ONLY = @as(u32, 16384);
pub const SCH_CRED_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 32768);
pub const SCH_CRED_MEMORY_STORE_CERT = @as(u32, 65536);
pub const SCH_CRED_SNI_CREDENTIAL = @as(u32, 524288);
pub const SCH_CRED_SNI_ENABLE_OCSP = @as(u32, 1048576);
pub const SCH_USE_DTLS_ONLY = @as(u32, 16777216);
pub const SCH_ALLOW_NULL_ENCRYPTION = @as(u32, 33554432);
pub const SCHANNEL_RENEGOTIATE = @as(u32, 0);
pub const SCHANNEL_SHUTDOWN = @as(u32, 1);
pub const SCHANNEL_ALERT = @as(u32, 2);
pub const SCHANNEL_SESSION = @as(u32, 3);
pub const TLS1_ALERT_CLOSE_NOTIFY = @as(u32, 0);
pub const TLS1_ALERT_UNEXPECTED_MESSAGE = @as(u32, 10);
pub const TLS1_ALERT_BAD_RECORD_MAC = @as(u32, 20);
pub const TLS1_ALERT_DECRYPTION_FAILED = @as(u32, 21);
pub const TLS1_ALERT_RECORD_OVERFLOW = @as(u32, 22);
pub const TLS1_ALERT_DECOMPRESSION_FAIL = @as(u32, 30);
pub const TLS1_ALERT_HANDSHAKE_FAILURE = @as(u32, 40);
pub const TLS1_ALERT_BAD_CERTIFICATE = @as(u32, 42);
pub const TLS1_ALERT_UNSUPPORTED_CERT = @as(u32, 43);
pub const TLS1_ALERT_CERTIFICATE_REVOKED = @as(u32, 44);
pub const TLS1_ALERT_CERTIFICATE_EXPIRED = @as(u32, 45);
pub const TLS1_ALERT_CERTIFICATE_UNKNOWN = @as(u32, 46);
pub const TLS1_ALERT_ILLEGAL_PARAMETER = @as(u32, 47);
pub const TLS1_ALERT_UNKNOWN_CA = @as(u32, 48);
pub const TLS1_ALERT_ACCESS_DENIED = @as(u32, 49);
pub const TLS1_ALERT_DECODE_ERROR = @as(u32, 50);
pub const TLS1_ALERT_DECRYPT_ERROR = @as(u32, 51);
pub const TLS1_ALERT_EXPORT_RESTRICTION = @as(u32, 60);
pub const TLS1_ALERT_PROTOCOL_VERSION = @as(u32, 70);
pub const TLS1_ALERT_INSUFFIENT_SECURITY = @as(u32, 71);
pub const TLS1_ALERT_INTERNAL_ERROR = @as(u32, 80);
pub const TLS1_ALERT_USER_CANCELED = @as(u32, 90);
pub const TLS1_ALERT_NO_RENEGOTIATION = @as(u32, 100);
pub const TLS1_ALERT_UNSUPPORTED_EXT = @as(u32, 110);
pub const TLS1_ALERT_UNKNOWN_PSK_IDENTITY = @as(u32, 115);
pub const TLS1_ALERT_NO_APP_PROTOCOL = @as(u32, 120);
pub const SP_PROT_PCT1_SERVER = @as(u32, 1);
pub const SP_PROT_PCT1_CLIENT = @as(u32, 2);
pub const SP_PROT_SSL2_SERVER = @as(u32, 4);
pub const SP_PROT_SSL2_CLIENT = @as(u32, 8);
pub const SP_PROT_SSL3_SERVER = @as(u32, 16);
pub const SP_PROT_SSL3_CLIENT = @as(u32, 32);
pub const SP_PROT_TLS1_SERVER = @as(u32, 64);
pub const SP_PROT_TLS1_CLIENT = @as(u32, 128);
pub const SP_PROT_UNI_SERVER = @as(u32, 1073741824);
pub const SP_PROT_UNI_CLIENT = @as(u32, 2147483648);
pub const SP_PROT_ALL = @as(u32, 4294967295);
pub const SP_PROT_NONE = @as(u32, 0);
pub const SP_PROT_TLS1_1_SERVER = @as(u32, 256);
pub const SP_PROT_TLS1_1_CLIENT = @as(u32, 512);
pub const SP_PROT_TLS1_2_SERVER = @as(u32, 1024);
pub const SP_PROT_TLS1_2_CLIENT = @as(u32, 2048);
pub const SP_PROT_TLS1_3_SERVER = @as(u32, 4096);
pub const SP_PROT_TLS1_3_CLIENT = @as(u32, 8192);
pub const SP_PROT_DTLS_SERVER = @as(u32, 65536);
pub const SP_PROT_DTLS_CLIENT = @as(u32, 131072);
pub const SP_PROT_DTLS1_2_SERVER = @as(u32, 262144);
pub const SP_PROT_DTLS1_2_CLIENT = @as(u32, 524288);
pub const SCHANNEL_SECRET_TYPE_CAPI = @as(u32, 1);
pub const SCHANNEL_SECRET_PRIVKEY = @as(u32, 2);
pub const SCH_CRED_X509_CERTCHAIN = @as(u32, 1);
pub const SCH_CRED_X509_CAPI = @as(u32, 2);
pub const SCH_CRED_CERT_CONTEXT = @as(u32, 3);
pub const OID_OAssociatedIdentityProviderObject = Guid.initString("98c5a3dd-db68-4f1a-8d2b-9079cdfeaf61");
pub const AUTHZ_SKIP_TOKEN_GROUPS = @as(u32, 2);
pub const AUTHZ_REQUIRE_S4U_LOGON = @as(u32, 4);
pub const AUTHZ_COMPUTE_PRIVILEGES = @as(u32, 8);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_INVALID = @as(u32, 0);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_INT64 = @as(u32, 1);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_UINT64 = @as(u32, 2);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_STRING = @as(u32, 3);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_FQBN = @as(u32, 4);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_SID = @as(u32, 5);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = @as(u32, 6);
pub const AUTHZ_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = @as(u32, 16);
pub const AUTHZ_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 = @as(u32, 1);
pub const AUTHZ_RPC_INIT_INFO_CLIENT_VERSION_V1 = @as(u32, 1);
pub const AUTHZ_INIT_INFO_VERSION_V1 = @as(u32, 1);
pub const AUTHZ_WPD_CATEGORY_FLAG = @as(u32, 16);
pub const AUTHZ_FLAG_ALLOW_MULTIPLE_SOURCE_INSTANCES = @as(u32, 1);
pub const OLESCRIPT_E_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352319));
pub const SI_EDIT_PERMS = @as(i32, 0);
pub const SI_EDIT_OWNER = @as(i32, 1);
pub const SI_CONTAINER = @as(i32, 4);
pub const SI_READONLY = @as(i32, 8);
pub const SI_RESET = @as(i32, 32);
pub const SI_OWNER_READONLY = @as(i32, 64);
pub const SI_OWNER_RECURSE = @as(i32, 256);
pub const SI_NO_ACL_PROTECT = @as(i32, 512);
pub const SI_NO_TREE_APPLY = @as(i32, 1024);
pub const SI_PAGE_TITLE = @as(i32, 2048);
pub const SI_SERVER_IS_DC = @as(i32, 4096);
pub const SI_RESET_DACL_TREE = @as(i32, 16384);
pub const SI_RESET_SACL_TREE = @as(i32, 32768);
pub const SI_OBJECT_GUID = @as(i32, 65536);
pub const SI_ACCESS_SPECIFIC = @as(i32, 65536);
pub const SI_ACCESS_GENERAL = @as(i32, 131072);
pub const SI_ACCESS_CONTAINER = @as(i32, 262144);
pub const SI_ACCESS_PROPERTY = @as(i32, 524288);
pub const DOBJ_RES_CONT = @as(i32, 1);
pub const DOBJ_RES_ROOT = @as(i32, 2);
pub const DOBJ_VOL_NTACLS = @as(i32, 4);
pub const DOBJ_COND_NTACLS = @as(i32, 8);
pub const DOBJ_RIBBON_LAUNCH = @as(i32, 16);
pub const SECURITY_OBJECT_ID_OBJECT_SD = @as(u32, 1);
pub const SECURITY_OBJECT_ID_SHARE = @as(u32, 2);
pub const SECURITY_OBJECT_ID_CENTRAL_POLICY = @as(u32, 3);
pub const SECURITY_OBJECT_ID_CENTRAL_ACCESS_RULE = @as(u32, 4);
pub const SDDL_REVISION_1 = @as(u32, 1);
pub const SDDL_ALIAS_SIZE = @as(u32, 2);
pub const DSSI_READ_ONLY = @as(u32, 1);
pub const DSSI_NO_ACCESS_CHECK = @as(u32, 2);
pub const DSSI_NO_EDIT_SACL = @as(u32, 4);
pub const DSSI_NO_EDIT_OWNER = @as(u32, 8);
pub const DSSI_IS_ROOT = @as(u32, 16);
pub const DSSI_NO_FILTER = @as(u32, 32);
pub const DSSI_NO_READONLY_MESSAGE = @as(u32, 64);
pub const SERVICE_NO_CHANGE = @as(u32, 4294967295);
pub const SERVICE_CONTROL_STOP = @as(u32, 1);
pub const SERVICE_CONTROL_PAUSE = @as(u32, 2);
pub const SERVICE_CONTROL_CONTINUE = @as(u32, 3);
pub const SERVICE_CONTROL_INTERROGATE = @as(u32, 4);
pub const SERVICE_CONTROL_SHUTDOWN = @as(u32, 5);
pub const SERVICE_CONTROL_PARAMCHANGE = @as(u32, 6);
pub const SERVICE_CONTROL_NETBINDADD = @as(u32, 7);
pub const SERVICE_CONTROL_NETBINDREMOVE = @as(u32, 8);
pub const SERVICE_CONTROL_NETBINDENABLE = @as(u32, 9);
pub const SERVICE_CONTROL_NETBINDDISABLE = @as(u32, 10);
pub const SERVICE_CONTROL_DEVICEEVENT = @as(u32, 11);
pub const SERVICE_CONTROL_HARDWAREPROFILECHANGE = @as(u32, 12);
pub const SERVICE_CONTROL_POWEREVENT = @as(u32, 13);
pub const SERVICE_CONTROL_SESSIONCHANGE = @as(u32, 14);
pub const SERVICE_CONTROL_PRESHUTDOWN = @as(u32, 15);
pub const SERVICE_CONTROL_TIMECHANGE = @as(u32, 16);
pub const SERVICE_CONTROL_TRIGGEREVENT = @as(u32, 32);
pub const SERVICE_CONTROL_LOWRESOURCES = @as(u32, 96);
pub const SERVICE_CONTROL_SYSTEMLOWRESOURCES = @as(u32, 97);
pub const SERVICE_ACCEPT_STOP = @as(u32, 1);
pub const SERVICE_ACCEPT_PAUSE_CONTINUE = @as(u32, 2);
pub const SERVICE_ACCEPT_SHUTDOWN = @as(u32, 4);
pub const SERVICE_ACCEPT_PARAMCHANGE = @as(u32, 8);
pub const SERVICE_ACCEPT_NETBINDCHANGE = @as(u32, 16);
pub const SERVICE_ACCEPT_HARDWAREPROFILECHANGE = @as(u32, 32);
pub const SERVICE_ACCEPT_POWEREVENT = @as(u32, 64);
pub const SERVICE_ACCEPT_SESSIONCHANGE = @as(u32, 128);
pub const SERVICE_ACCEPT_PRESHUTDOWN = @as(u32, 256);
pub const SERVICE_ACCEPT_TIMECHANGE = @as(u32, 512);
pub const SERVICE_ACCEPT_TRIGGEREVENT = @as(u32, 1024);
pub const SERVICE_ACCEPT_USER_LOGOFF = @as(u32, 2048);
pub const SERVICE_ACCEPT_LOWRESOURCES = @as(u32, 8192);
pub const SERVICE_ACCEPT_SYSTEMLOWRESOURCES = @as(u32, 16384);
pub const SC_MANAGER_CONNECT = @as(u32, 1);
pub const SC_MANAGER_CREATE_SERVICE = @as(u32, 2);
pub const SC_MANAGER_ENUMERATE_SERVICE = @as(u32, 4);
pub const SC_MANAGER_LOCK = @as(u32, 8);
pub const SC_MANAGER_QUERY_LOCK_STATUS = @as(u32, 16);
pub const SC_MANAGER_MODIFY_BOOT_CONFIG = @as(u32, 32);
pub const SERVICE_QUERY_CONFIG = @as(u32, 1);
pub const SERVICE_CHANGE_CONFIG = @as(u32, 2);
pub const SERVICE_QUERY_STATUS = @as(u32, 4);
pub const SERVICE_ENUMERATE_DEPENDENTS = @as(u32, 8);
pub const SERVICE_START = @as(u32, 16);
pub const SERVICE_STOP = @as(u32, 32);
pub const SERVICE_PAUSE_CONTINUE = @as(u32, 64);
pub const SERVICE_INTERROGATE = @as(u32, 128);
pub const SERVICE_USER_DEFINED_CONTROL = @as(u32, 256);
pub const SERVICE_NOTIFY_STATUS_CHANGE_1 = @as(u32, 1);
pub const SERVICE_NOTIFY_STATUS_CHANGE_2 = @as(u32, 2);
pub const SERVICE_STOP_REASON_FLAG_MIN = @as(u32, 0);
pub const SERVICE_STOP_REASON_FLAG_UNPLANNED = @as(u32, 268435456);
pub const SERVICE_STOP_REASON_FLAG_CUSTOM = @as(u32, 536870912);
pub const SERVICE_STOP_REASON_FLAG_PLANNED = @as(u32, 1073741824);
pub const SERVICE_STOP_REASON_FLAG_MAX = @as(u32, 2147483648);
pub const SERVICE_STOP_REASON_MAJOR_MIN = @as(u32, 0);
pub const SERVICE_STOP_REASON_MAJOR_OTHER = @as(u32, 65536);
pub const SERVICE_STOP_REASON_MAJOR_HARDWARE = @as(u32, 131072);
pub const SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM = @as(u32, 196608);
pub const SERVICE_STOP_REASON_MAJOR_SOFTWARE = @as(u32, 262144);
pub const SERVICE_STOP_REASON_MAJOR_APPLICATION = @as(u32, 327680);
pub const SERVICE_STOP_REASON_MAJOR_NONE = @as(u32, 393216);
pub const SERVICE_STOP_REASON_MAJOR_MAX = @as(u32, 458752);
pub const SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM = @as(u32, 4194304);
pub const SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM = @as(u32, 16711680);
pub const SERVICE_STOP_REASON_MINOR_MIN = @as(u32, 0);
pub const SERVICE_STOP_REASON_MINOR_OTHER = @as(u32, 1);
pub const SERVICE_STOP_REASON_MINOR_MAINTENANCE = @as(u32, 2);
pub const SERVICE_STOP_REASON_MINOR_INSTALLATION = @as(u32, 3);
pub const SERVICE_STOP_REASON_MINOR_UPGRADE = @as(u32, 4);
pub const SERVICE_STOP_REASON_MINOR_RECONFIG = @as(u32, 5);
pub const SERVICE_STOP_REASON_MINOR_HUNG = @as(u32, 6);
pub const SERVICE_STOP_REASON_MINOR_UNSTABLE = @as(u32, 7);
pub const SERVICE_STOP_REASON_MINOR_DISK = @as(u32, 8);
pub const SERVICE_STOP_REASON_MINOR_NETWORKCARD = @as(u32, 9);
pub const SERVICE_STOP_REASON_MINOR_ENVIRONMENT = @as(u32, 10);
pub const SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER = @as(u32, 11);
pub const SERVICE_STOP_REASON_MINOR_OTHERDRIVER = @as(u32, 12);
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK = @as(u32, 13);
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE = @as(u32, 14);
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX = @as(u32, 15);
pub const SERVICE_STOP_REASON_MINOR_SECURITY = @as(u32, 16);
pub const SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY = @as(u32, 17);
pub const SERVICE_STOP_REASON_MINOR_WMI = @as(u32, 18);
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL = @as(u32, 19);
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL = @as(u32, 20);
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL = @as(u32, 21);
pub const SERVICE_STOP_REASON_MINOR_MMC = @as(u32, 22);
pub const SERVICE_STOP_REASON_MINOR_NONE = @as(u32, 23);
pub const SERVICE_STOP_REASON_MINOR_MEMOTYLIMIT = @as(u32, 24);
pub const SERVICE_STOP_REASON_MINOR_MAX = @as(u32, 25);
pub const SERVICE_STOP_REASON_MINOR_MIN_CUSTOM = @as(u32, 256);
pub const SERVICE_STOP_REASON_MINOR_MAX_CUSTOM = @as(u32, 65535);
pub const SERVICE_CONTROL_STATUS_REASON_INFO = @as(u32, 1);
pub const SERVICE_SID_TYPE_NONE = @as(u32, 0);
pub const SERVICE_SID_TYPE_UNRESTRICTED = @as(u32, 1);
pub const SERVICE_TRIGGER_TYPE_CUSTOM_SYSTEM_STATE_CHANGE = @as(u32, 7);
pub const SERVICE_TRIGGER_TYPE_AGGREGATE = @as(u32, 30);
pub const SERVICE_START_REASON_DEMAND = @as(u32, 1);
pub const SERVICE_START_REASON_AUTO = @as(u32, 2);
pub const SERVICE_START_REASON_TRIGGER = @as(u32, 4);
pub const SERVICE_START_REASON_RESTART_ON_FAILURE = @as(u32, 8);
pub const SERVICE_START_REASON_DELAYEDAUTO = @as(u32, 16);
pub const SERVICE_DYNAMIC_INFORMATION_LEVEL_START_REASON = @as(u32, 1);
pub const SERVICE_LAUNCH_PROTECTED_NONE = @as(u32, 0);
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS = @as(u32, 1);
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT = @as(u32, 2);
pub const SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT = @as(u32, 3);
pub const NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID = Guid.initString("4f27f2de-14e2-430b-a549-7cd48cbc8245");
pub const NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID = Guid.initString("cc4ba62a-162e-4648-847a-b6bdf993e335");
pub const DOMAIN_JOIN_GUID = Guid.initString("1ce20aba-9851-4421-9430-1ddeb766e809");
pub const DOMAIN_LEAVE_GUID = Guid.initString("ddaf516e-58c2-4866-9574-c3b615d42ea1");
pub const FIREWALL_PORT_OPEN_GUID = Guid.initString("b7569e07-8421-4ee0-ad10-86915afdad09");
pub const FIREWALL_PORT_CLOSE_GUID = Guid.initString("a144ed38-8e12-4de4-9d96-e64740b1a524");
pub const MACHINE_POLICY_PRESENT_GUID = Guid.initString("659fcae6-5bdb-4da9-b1ff-ca2a178d46e0");
pub const USER_POLICY_PRESENT_GUID = Guid.initString("54fb46c8-f089-464c-b1fd-59d1b62c3b50");
pub const RPC_INTERFACE_EVENT_GUID = Guid.initString("bc90d167-9470-4139-a9ba-be0bbbf5b74d");
pub const NAMED_PIPE_EVENT_GUID = Guid.initString("1f81d131-3fac-4537-9e0c-7e7b0c2f4b55");
pub const CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID = Guid.initString("2d7a2816-0c5e-45fc-9ce7-570e5ecde9c9");
pub const CERTENROLL_INDEX_BASE = @as(u32, 0);
pub const BCRYPT_OBJECT_ALIGNMENT = @as(u32, 16);
pub const KDF_HASH_ALGORITHM = @as(u32, 0);
pub const KDF_SECRET_PREPEND = @as(u32, 1);
pub const KDF_SECRET_APPEND = @as(u32, 2);
pub const KDF_HMAC_KEY = @as(u32, 3);
pub const KDF_TLS_PRF_LABEL = @as(u32, 4);
pub const KDF_TLS_PRF_SEED = @as(u32, 5);
pub const KDF_SECRET_HANDLE = @as(u32, 6);
pub const KDF_TLS_PRF_PROTOCOL = @as(u32, 7);
pub const KDF_ALGORITHMID = @as(u32, 8);
pub const KDF_PARTYUINFO = @as(u32, 9);
pub const KDF_PARTYVINFO = @as(u32, 10);
pub const KDF_SUPPPUBINFO = @as(u32, 11);
pub const KDF_SUPPPRIVINFO = @as(u32, 12);
pub const KDF_LABEL = @as(u32, 13);
pub const KDF_CONTEXT = @as(u32, 14);
pub const KDF_SALT = @as(u32, 15);
pub const KDF_ITERATION_COUNT = @as(u32, 16);
pub const KDF_GENERIC_PARAMETER = @as(u32, 17);
pub const KDF_KEYBITLENGTH = @as(u32, 18);
pub const KDF_HKDF_SALT = @as(u32, 19);
pub const KDF_HKDF_INFO = @as(u32, 20);
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_ROUTER = @as(u32, 1);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = @as(u32, 4);
pub const BCRYPT_SUPPORTED_PAD_OAEP = @as(u32, 8);
pub const BCRYPT_SUPPORTED_PAD_PSS = @as(u32, 16);
pub const BCRYPT_BLOCK_PADDING = @as(u32, 1);
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = @as(u32, 16);
pub const BCRYPTBUFFER_VERSION = @as(u32, 0);
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC = @as(u32, 827016005);
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC = @as(u32, 843793221);
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC = @as(u32, 860570437);
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC = @as(u32, 877347653);
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC = @as(u32, 894124869);
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC = @as(u32, 910902085);
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = @as(u32, 1347109701);
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = @as(u32, 1447772997);
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = @as(u32, 827540293);
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = @as(u32, 844317509);
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = @as(u32, 861094725);
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = @as(u32, 877871941);
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = @as(u32, 894649157);
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = @as(u32, 911426373);
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = @as(u32, 1346650949);
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = @as(u32, 1447314245);
pub const BCRYPT_ECC_FULLKEY_BLOB_V1 = @as(u32, 1);
pub const BCRYPT_DH_PARAMETERS_MAGIC = @as(u32, 1297107012);
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2 = @as(u32, 843206724);
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2 = @as(u32, 844517444);
pub const BCRYPT_KEY_DATA_BLOB_MAGIC = @as(u32, 1296188491);
pub const BCRYPT_KEY_DATA_BLOB_VERSION1 = @as(u32, 1);
pub const BCRYPT_DSA_PARAMETERS_MAGIC = @as(u32, 1297109828);
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = @as(u32, 843927620);
pub const BCRYPT_ECC_PARAMETERS_MAGIC = @as(u32, 1346585413);
pub const BCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const BCRYPT_CAPI_AES_FLAG = @as(u32, 16);
pub const BCRYPT_MULTI_FLAG = @as(u32, 64);
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = @as(u32, 4);
pub const BCRYPT_BUFFERS_LOCKED_FLAG = @as(u32, 64);
pub const BCRYPT_EXTENDED_KEYSIZE = @as(u32, 128);
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = @as(u32, 256);
pub const BCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const BCRYPT_PUBLIC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_PRIVATE_KEY_FLAG = @as(u32, 2);
pub const BCRYPT_NO_KEY_VALIDATION = @as(u32, 8);
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = @as(u32, 1);
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG = @as(u32, 2);
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = @as(u32, 2);
pub const CRYPT_OVERWRITE = @as(u32, 1);
pub const CRYPT_PRIORITY_TOP = @as(u32, 0);
pub const CRYPT_PRIORITY_BOTTOM = @as(u32, 4294967295);
pub const NCRYPT_NAMED_DESCRIPTOR_FLAG = @as(u32, 1);
pub const NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING = @as(u32, 1);
pub const NCRYPT_MAX_KEY_NAME_LENGTH = @as(u32, 512);
pub const NCRYPT_MAX_ALG_ID_LENGTH = @as(u32, 512);
pub const NCRYPT_KEY_PROTECTION_INTERFACE = @as(u32, 65540);
pub const NCRYPTBUFFER_VERSION = @as(u32, 0);
pub const NCRYPTBUFFER_EMPTY = @as(u32, 0);
pub const NCRYPTBUFFER_DATA = @as(u32, 1);
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = @as(u32, 3);
pub const NCRYPTBUFFER_PROTECTION_FLAGS = @as(u32, 4);
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM = @as(u32, 20);
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM = @as(u32, 21);
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION = @as(u32, 22);
pub const NCRYPTBUFFER_SSL_CLEAR_KEY = @as(u32, 23);
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA = @as(u32, 24);
pub const NCRYPTBUFFER_SSL_SESSION_HASH = @as(u32, 25);
pub const NCRYPTBUFFER_PKCS_OID = @as(u32, 40);
pub const NCRYPTBUFFER_PKCS_ALG_OID = @as(u32, 41);
pub const NCRYPTBUFFER_PKCS_ALG_PARAM = @as(u32, 42);
pub const NCRYPTBUFFER_PKCS_ALG_ID = @as(u32, 43);
pub const NCRYPTBUFFER_PKCS_ATTRS = @as(u32, 44);
pub const NCRYPTBUFFER_PKCS_KEY_NAME = @as(u32, 45);
pub const NCRYPTBUFFER_PKCS_SECRET = @as(u32, 46);
pub const NCRYPTBUFFER_CERT_BLOB = @as(u32, 47);
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = @as(u32, 48);
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = @as(u32, 49);
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = @as(u32, 50);
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = @as(u32, 51);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = @as(u32, 52);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = @as(u32, 53);
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = @as(u32, 54);
pub const NCRYPTBUFFER_ECC_CURVE_NAME = @as(u32, 60);
pub const NCRYPTBUFFER_ECC_PARAMETERS = @as(u32, 61);
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD = @as(u32, 70);
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = @as(u32, 71);
pub const NCRYPTBUFFER_TPM_SEAL_TICKET = @as(u32, 72);
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = @as(u32, 73);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = @as(u32, 80);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = @as(u32, 81);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = @as(u32, 82);
pub const NCRYPT_CIPHER_NO_PADDING_FLAG = @as(u32, 0);
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = @as(u32, 1);
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG = @as(u32, 2);
pub const NCRYPT_PLATFORM_ATTEST_MAGIC = @as(u32, 1146110288);
pub const NCRYPT_KEY_ATTEST_MAGIC = @as(u32, 1146110283);
pub const NCRYPT_CLAIM_AUTHORITY_ONLY = @as(u32, 1);
pub const NCRYPT_CLAIM_SUBJECT_ONLY = @as(u32, 2);
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = @as(u32, 258);
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = @as(u32, 3);
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = @as(u32, 4);
pub const NCRYPT_CLAIM_UNKNOWN = @as(u32, 4096);
pub const NCRYPT_CLAIM_PLATFORM = @as(u32, 65536);
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = @as(u32, 1);
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = @as(u32, 2);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_PAD_CIPHER_FLAG = @as(u32, 16);
pub const NCRYPT_ATTESTATION_FLAG = @as(u32, 32);
pub const NCRYPT_SEALING_FLAG = @as(u32, 256);
pub const NCRYPT_DO_NOT_FINALIZE_FLAG = @as(u32, 1024);
pub const NCRYPT_EXPORT_LEGACY_FLAG = @as(u32, 2048);
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG = @as(u32, 4096);
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = @as(u32, 8192);
pub const NCRYPT_NO_CACHED_PASSWORD = @as(u32, 16384);
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = @as(u32, 32768);
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = @as(u32, 65536);
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = @as(u32, 131072);
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG = @as(u32, 262144);
pub const NCRYPT_AUTHORITY_KEY_FLAG = @as(u32, 256);
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = @as(u32, 0);
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = @as(u32, 1);
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = @as(u32, 2);
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = @as(u32, 32);
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = @as(u32, 0);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = @as(u32, 1);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = @as(u32, 2);
pub const NCRYPT_TPM12_PROVIDER = @as(u32, 65536);
pub const NCRYPT_PCP_SIGNATURE_KEY = @as(u32, 1);
pub const NCRYPT_PCP_ENCRYPTION_KEY = @as(u32, 2);
pub const NCRYPT_PCP_STORAGE_KEY = @as(u32, 4);
pub const NCRYPT_PCP_IDENTITY_KEY = @as(u32, 8);
pub const NCRYPT_PCP_HMACVERIFICATION_KEY = @as(u32, 16);
pub const NCRYPT_MAX_PROPERTY_NAME = @as(u32, 64);
pub const NCRYPT_MAX_PROPERTY_DATA = @as(u32, 1048576);
pub const NCRYPT_ALLOW_EXPORT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_ARCHIVING_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_FLAG = @as(u32, 1);
pub const NCRYPT_IMPL_SOFTWARE_FLAG = @as(u32, 2);
pub const NCRYPT_IMPL_REMOVABLE_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG = @as(u32, 16);
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = @as(u32, 32);
pub const NCRYPT_ALLOW_DECRYPT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_SIGNING_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG = @as(u32, 8);
pub const NCRYPT_ALLOW_ALL_USAGES = @as(u32, 16777215);
pub const NCRYPT_UI_PROTECT_KEY_FLAG = @as(u32, 1);
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = @as(u32, 2);
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = @as(u32, 4);
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = @as(u32, 8);
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_PIN_BYTE_LENGTH = @as(u32, 90);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = @as(u32, 90);
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = @as(u32, 1);
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION = @as(u32, 1);
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS = @as(u32, 1);
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC = @as(u32, 1380470851);
pub const NCRYPT_KDF_KEY_BLOB_MAGIC = @as(u32, 826688587);
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = @as(u32, 1263817296);
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = @as(u32, 1297371211);
pub const ALG_CLASS_ANY = @as(u32, 0);
pub const ALG_CLASS_SIGNATURE = @as(u32, 8192);
pub const ALG_CLASS_MSG_ENCRYPT = @as(u32, 16384);
pub const ALG_CLASS_DATA_ENCRYPT = @as(u32, 24576);
pub const ALG_CLASS_HASH = @as(u32, 32768);
pub const ALG_CLASS_KEY_EXCHANGE = @as(u32, 40960);
pub const ALG_CLASS_ALL = @as(u32, 57344);
pub const ALG_TYPE_ANY = @as(u32, 0);
pub const ALG_TYPE_DSS = @as(u32, 512);
pub const ALG_TYPE_RSA = @as(u32, 1024);
pub const ALG_TYPE_BLOCK = @as(u32, 1536);
pub const ALG_TYPE_STREAM = @as(u32, 2048);
pub const ALG_TYPE_DH = @as(u32, 2560);
pub const ALG_TYPE_SECURECHANNEL = @as(u32, 3072);
pub const ALG_TYPE_ECDH = @as(u32, 3584);
pub const ALG_TYPE_THIRDPARTY = @as(u32, 4096);
pub const ALG_SID_ANY = @as(u32, 0);
pub const ALG_SID_THIRDPARTY_ANY = @as(u32, 0);
pub const ALG_SID_RSA_ANY = @as(u32, 0);
pub const ALG_SID_RSA_PKCS = @as(u32, 1);
pub const ALG_SID_RSA_MSATWORK = @as(u32, 2);
pub const ALG_SID_RSA_ENTRUST = @as(u32, 3);
pub const ALG_SID_RSA_PGP = @as(u32, 4);
pub const ALG_SID_DSS_ANY = @as(u32, 0);
pub const ALG_SID_DSS_PKCS = @as(u32, 1);
pub const ALG_SID_DSS_DMS = @as(u32, 2);
pub const ALG_SID_ECDSA = @as(u32, 3);
pub const ALG_SID_DES = @as(u32, 1);
pub const ALG_SID_3DES = @as(u32, 3);
pub const ALG_SID_DESX = @as(u32, 4);
pub const ALG_SID_IDEA = @as(u32, 5);
pub const ALG_SID_CAST = @as(u32, 6);
pub const ALG_SID_SAFERSK64 = @as(u32, 7);
pub const ALG_SID_SAFERSK128 = @as(u32, 8);
pub const ALG_SID_3DES_112 = @as(u32, 9);
pub const ALG_SID_CYLINK_MEK = @as(u32, 12);
pub const ALG_SID_RC5 = @as(u32, 13);
pub const ALG_SID_AES_128 = @as(u32, 14);
pub const ALG_SID_AES_192 = @as(u32, 15);
pub const ALG_SID_AES_256 = @as(u32, 16);
pub const ALG_SID_AES = @as(u32, 17);
pub const ALG_SID_SKIPJACK = @as(u32, 10);
pub const ALG_SID_TEK = @as(u32, 11);
pub const CRYPT_MODE_CBCI = @as(u32, 6);
pub const CRYPT_MODE_CFBP = @as(u32, 7);
pub const CRYPT_MODE_OFBP = @as(u32, 8);
pub const CRYPT_MODE_CBCOFM = @as(u32, 9);
pub const CRYPT_MODE_CBCOFMI = @as(u32, 10);
pub const ALG_SID_RC2 = @as(u32, 2);
pub const ALG_SID_RC4 = @as(u32, 1);
pub const ALG_SID_SEAL = @as(u32, 2);
pub const ALG_SID_DH_SANDF = @as(u32, 1);
pub const ALG_SID_DH_EPHEM = @as(u32, 2);
pub const ALG_SID_AGREED_KEY_ANY = @as(u32, 3);
pub const ALG_SID_KEA = @as(u32, 4);
pub const ALG_SID_ECDH = @as(u32, 5);
pub const ALG_SID_ECDH_EPHEM = @as(u32, 6);
pub const ALG_SID_MD2 = @as(u32, 1);
pub const ALG_SID_MD4 = @as(u32, 2);
pub const ALG_SID_MD5 = @as(u32, 3);
pub const ALG_SID_SHA = @as(u32, 4);
pub const ALG_SID_SHA1 = @as(u32, 4);
pub const ALG_SID_MAC = @as(u32, 5);
pub const ALG_SID_RIPEMD = @as(u32, 6);
pub const ALG_SID_RIPEMD160 = @as(u32, 7);
pub const ALG_SID_SSL3SHAMD5 = @as(u32, 8);
pub const ALG_SID_HMAC = @as(u32, 9);
pub const ALG_SID_TLS1PRF = @as(u32, 10);
pub const ALG_SID_HASH_REPLACE_OWF = @as(u32, 11);
pub const ALG_SID_SHA_256 = @as(u32, 12);
pub const ALG_SID_SHA_384 = @as(u32, 13);
pub const ALG_SID_SHA_512 = @as(u32, 14);
pub const ALG_SID_SSL3_MASTER = @as(u32, 1);
pub const ALG_SID_SCHANNEL_MASTER_HASH = @as(u32, 2);
pub const ALG_SID_SCHANNEL_MAC_KEY = @as(u32, 3);
pub const ALG_SID_PCT1_MASTER = @as(u32, 4);
pub const ALG_SID_SSL2_MASTER = @as(u32, 5);
pub const ALG_SID_TLS1_MASTER = @as(u32, 6);
pub const ALG_SID_SCHANNEL_ENC_KEY = @as(u32, 7);
pub const ALG_SID_ECMQV = @as(u32, 1);
pub const ALG_SID_EXAMPLE = @as(u32, 80);
pub const SIGNATURE_RESOURCE_NUMBER = @as(u32, 666);
pub const CRYPT_VERIFYCONTEXT = @as(u32, 4026531840);
pub const CRYPT_NEWKEYSET = @as(u32, 8);
pub const CRYPT_DELETEKEYSET = @as(u32, 16);
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL = @as(u32, 128);
pub const CRYPT_UPDATE_KEY = @as(u32, 8);
pub const CRYPT_USER_PROTECTED_STRONG = @as(u32, 1048576);
pub const RSA1024BIT_KEY = @as(u32, 67108864);
pub const CRYPT_SERVER = @as(u32, 1024);
pub const KEY_LENGTH_MASK = @as(u32, 4294901760);
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = @as(u32, 32);
pub const CRYPT_SECRETDIGEST = @as(u32, 1);
pub const CRYPT_OWF_REPL_LM_HASH = @as(u32, 1);
pub const CRYPT_LITTLE_ENDIAN = @as(u32, 1);
pub const CRYPT_NOHASHOID = @as(u32, 1);
pub const CRYPT_TYPE2_FORMAT = @as(u32, 2);
pub const CRYPT_X931_FORMAT = @as(u32, 4);
pub const CRYPT_MACHINE_DEFAULT = @as(u32, 1);
pub const CRYPT_USER_DEFAULT = @as(u32, 2);
pub const CRYPT_DELETE_DEFAULT = @as(u32, 4);
pub const SIMPLEBLOB = @as(u32, 1);
pub const PUBLICKEYBLOB = @as(u32, 6);
pub const PRIVATEKEYBLOB = @as(u32, 7);
pub const PLAINTEXTKEYBLOB = @as(u32, 8);
pub const OPAQUEKEYBLOB = @as(u32, 9);
pub const PUBLICKEYBLOBEX = @as(u32, 10);
pub const SYMMETRICWRAPKEYBLOB = @as(u32, 11);
pub const KEYSTATEBLOB = @as(u32, 12);
pub const CRYPT_USERDATA = @as(u32, 1);
pub const KP_IV = @as(u32, 1);
pub const KP_PADDING = @as(u32, 3);
pub const KP_MODE = @as(u32, 4);
pub const KP_MODE_BITS = @as(u32, 5);
pub const KP_P = @as(u32, 11);
pub const KP_G = @as(u32, 12);
pub const KP_Q = @as(u32, 13);
pub const KP_X = @as(u32, 14);
pub const KP_Y = @as(u32, 15);
pub const KP_RA = @as(u32, 16);
pub const KP_RB = @as(u32, 17);
pub const KP_INFO = @as(u32, 18);
pub const KP_EFFECTIVE_KEYLEN = @as(u32, 19);
pub const KP_SCHANNEL_ALG = @as(u32, 20);
pub const KP_CLIENT_RANDOM = @as(u32, 21);
pub const KP_SERVER_RANDOM = @as(u32, 22);
pub const KP_RP = @as(u32, 23);
pub const KP_PRECOMP_MD5 = @as(u32, 24);
pub const KP_PRECOMP_SHA = @as(u32, 25);
pub const KP_CLEAR_KEY = @as(u32, 27);
pub const KP_PUB_EX_LEN = @as(u32, 28);
pub const KP_PUB_EX_VAL = @as(u32, 29);
pub const KP_KEYVAL = @as(u32, 30);
pub const KP_ADMIN_PIN = @as(u32, 31);
pub const KP_KEYEXCHANGE_PIN = @as(u32, 32);
pub const KP_SIGNATURE_PIN = @as(u32, 33);
pub const KP_PREHASH = @as(u32, 34);
pub const KP_ROUNDS = @as(u32, 35);
pub const KP_OAEP_PARAMS = @as(u32, 36);
pub const KP_CMS_KEY_INFO = @as(u32, 37);
pub const KP_CMS_DH_KEY_INFO = @as(u32, 38);
pub const KP_PUB_PARAMS = @as(u32, 39);
pub const KP_VERIFY_PARAMS = @as(u32, 40);
pub const KP_HIGHEST_VERSION = @as(u32, 41);
pub const KP_PIN_ID = @as(u32, 43);
pub const KP_PIN_INFO = @as(u32, 44);
pub const PKCS5_PADDING = @as(u32, 1);
pub const RANDOM_PADDING = @as(u32, 2);
pub const ZERO_PADDING = @as(u32, 3);
pub const CRYPT_MODE_CBC = @as(u32, 1);
pub const CRYPT_MODE_ECB = @as(u32, 2);
pub const CRYPT_MODE_OFB = @as(u32, 3);
pub const CRYPT_MODE_CFB = @as(u32, 4);
pub const CRYPT_MODE_CTS = @as(u32, 5);
pub const CRYPT_ENCRYPT = @as(u32, 1);
pub const CRYPT_DECRYPT = @as(u32, 2);
pub const CRYPT_EXPORT = @as(u32, 4);
pub const CRYPT_READ = @as(u32, 8);
pub const CRYPT_WRITE = @as(u32, 16);
pub const CRYPT_MAC = @as(u32, 32);
pub const CRYPT_EXPORT_KEY = @as(u32, 64);
pub const CRYPT_IMPORT_KEY = @as(u32, 128);
pub const CRYPT_ARCHIVE = @as(u32, 256);
pub const HP_ALGID = @as(u32, 1);
pub const HP_HASHSIZE = @as(u32, 4);
pub const HP_TLS1PRF_LABEL = @as(u32, 6);
pub const HP_TLS1PRF_SEED = @as(u32, 7);
pub const CRYPT_FAILED = @as(u32, 0);
pub const CRYPT_SUCCEED = @as(u32, 1);
pub const PP_ENUMALGS = @as(u32, 1);
pub const PP_ENUMCONTAINERS = @as(u32, 2);
pub const PP_IMPTYPE = @as(u32, 3);
pub const PP_NAME = @as(u32, 4);
pub const PP_VERSION = @as(u32, 5);
pub const PP_CONTAINER = @as(u32, 6);
pub const PP_CHANGE_PASSWORD = @as(u32, 7);
pub const PP_CERTCHAIN = @as(u32, 9);
pub const PP_KEY_TYPE_SUBTYPE = @as(u32, 10);
pub const PP_PROVTYPE = @as(u32, 16);
pub const PP_KEYSTORAGE = @as(u32, 17);
pub const PP_APPLI_CERT = @as(u32, 18);
pub const PP_SYM_KEYSIZE = @as(u32, 19);
pub const PP_SESSION_KEYSIZE = @as(u32, 20);
pub const PP_ENUMALGS_EX = @as(u32, 22);
pub const PP_ENUMMANDROOTS = @as(u32, 25);
pub const PP_ENUMELECTROOTS = @as(u32, 26);
pub const PP_KEYSET_TYPE = @as(u32, 27);
pub const PP_ADMIN_PIN = @as(u32, 31);
pub const PP_SIG_KEYSIZE_INC = @as(u32, 34);
pub const PP_KEYX_KEYSIZE_INC = @as(u32, 35);
pub const PP_UNIQUE_CONTAINER = @as(u32, 36);
pub const PP_SGC_INFO = @as(u32, 37);
pub const PP_KEYSPEC = @as(u32, 39);
pub const PP_ENUMEX_SIGNING_PROT = @as(u32, 40);
pub const PP_CRYPT_COUNT_KEY_USE = @as(u32, 41);
pub const PP_SMARTCARD_GUID = @as(u32, 45);
pub const PP_SMARTCARD_READER_ICON = @as(u32, 47);
pub const CRYPT_FIRST = @as(u32, 1);
pub const CRYPT_NEXT = @as(u32, 2);
pub const CRYPT_SGC_ENUM = @as(u32, 4);
pub const CRYPT_IMPL_HARDWARE = @as(u32, 1);
pub const CRYPT_IMPL_SOFTWARE = @as(u32, 2);
pub const CRYPT_IMPL_MIXED = @as(u32, 3);
pub const CRYPT_IMPL_UNKNOWN = @as(u32, 4);
pub const CRYPT_IMPL_REMOVABLE = @as(u32, 8);
pub const CRYPT_SEC_DESCR = @as(u32, 1);
pub const CRYPT_PSTORE = @as(u32, 2);
pub const CRYPT_UI_PROMPT = @as(u32, 4);
pub const CRYPT_FLAG_PCT1 = @as(u32, 1);
pub const CRYPT_FLAG_SSL2 = @as(u32, 2);
pub const CRYPT_FLAG_SSL3 = @as(u32, 4);
pub const CRYPT_FLAG_TLS1 = @as(u32, 8);
pub const CRYPT_FLAG_IPSEC = @as(u32, 16);
pub const CRYPT_FLAG_SIGNING = @as(u32, 32);
pub const CRYPT_SGC = @as(u32, 1);
pub const CRYPT_FASTSGC = @as(u32, 2);
pub const PP_CONTEXT_INFO = @as(u32, 11);
pub const PP_DISMISS_PIN_UI_SEC = @as(u32, 49);
pub const PROV_RSA_FULL = @as(u32, 1);
pub const PROV_RSA_SIG = @as(u32, 2);
pub const PROV_DSS = @as(u32, 3);
pub const PROV_FORTEZZA = @as(u32, 4);
pub const PROV_MS_EXCHANGE = @as(u32, 5);
pub const PROV_SSL = @as(u32, 6);
pub const PROV_RSA_SCHANNEL = @as(u32, 12);
pub const PROV_DSS_DH = @as(u32, 13);
pub const PROV_EC_ECDSA_SIG = @as(u32, 14);
pub const PROV_EC_ECNRA_SIG = @as(u32, 15);
pub const PROV_EC_ECDSA_FULL = @as(u32, 16);
pub const PROV_EC_ECNRA_FULL = @as(u32, 17);
pub const PROV_DH_SCHANNEL = @as(u32, 18);
pub const PROV_SPYRUS_LYNKS = @as(u32, 20);
pub const PROV_RNG = @as(u32, 21);
pub const PROV_INTEL_SEC = @as(u32, 22);
pub const PROV_REPLACE_OWF = @as(u32, 23);
pub const PROV_RSA_AES = @as(u32, 24);
pub const PROV_STT_MER = @as(u32, 7);
pub const PROV_STT_ACQ = @as(u32, 8);
pub const PROV_STT_BRND = @as(u32, 9);
pub const PROV_STT_ROOT = @as(u32, 10);
pub const PROV_STT_ISS = @as(u32, 11);
pub const MAXUIDLEN = @as(u32, 64);
pub const CUR_BLOB_VERSION = @as(u32, 2);
pub const SCHANNEL_MAC_KEY = @as(u32, 0);
pub const SCHANNEL_ENC_KEY = @as(u32, 1);
pub const INTERNATIONAL_USAGE = @as(u32, 1);
pub const CERT_RDN_TYPE_MASK = @as(u32, 255);
pub const CERT_RDN_FLAGS_MASK = @as(u32, 4278190080);
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG = @as(u32, 2147483648);
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 536870912);
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = @as(u32, 1073741824);
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = @as(u32, 1);
pub const CERT_V1 = @as(u32, 0);
pub const CERT_V2 = @as(u32, 1);
pub const CERT_V3 = @as(u32, 2);
pub const CERT_INFO_VERSION_FLAG = @as(u32, 1);
pub const CERT_INFO_SERIAL_NUMBER_FLAG = @as(u32, 2);
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = @as(u32, 3);
pub const CERT_INFO_ISSUER_FLAG = @as(u32, 4);
pub const CERT_INFO_NOT_BEFORE_FLAG = @as(u32, 5);
pub const CERT_INFO_NOT_AFTER_FLAG = @as(u32, 6);
pub const CERT_INFO_SUBJECT_FLAG = @as(u32, 7);
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = @as(u32, 8);
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = @as(u32, 9);
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = @as(u32, 10);
pub const CERT_INFO_EXTENSION_FLAG = @as(u32, 11);
pub const CRL_V1 = @as(u32, 0);
pub const CRL_V2 = @as(u32, 1);
pub const CERT_BUNDLE_CERTIFICATE = @as(u32, 0);
pub const CERT_BUNDLE_CRL = @as(u32, 1);
pub const CERT_REQUEST_V1 = @as(u32, 0);
pub const CERT_KEYGEN_REQUEST_V1 = @as(u32, 0);
pub const CTL_V1 = @as(u32, 0);
pub const CERT_ENCODING_TYPE_MASK = @as(u32, 65535);
pub const CMSG_ENCODING_TYPE_MASK = @as(u32, 4294901760);
pub const CRYPT_ASN_ENCODING = @as(u32, 1);
pub const CRYPT_NDR_ENCODING = @as(u32, 2);
pub const X509_NDR_ENCODING = @as(u32, 2);
pub const PKCS_7_NDR_ENCODING = @as(u32, 131072);
pub const CRYPT_FORMAT_STR_MULTI_LINE = @as(u32, 1);
pub const CRYPT_FORMAT_STR_NO_HEX = @as(u32, 16);
pub const CRYPT_FORMAT_SIMPLE = @as(u32, 1);
pub const CRYPT_FORMAT_X509 = @as(u32, 2);
pub const CRYPT_FORMAT_OID = @as(u32, 4);
pub const CRYPT_FORMAT_RDN_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_RDN_CRLF = @as(u32, 512);
pub const CRYPT_FORMAT_RDN_UNQUOTE = @as(u32, 1024);
pub const CRYPT_FORMAT_RDN_REVERSE = @as(u32, 2048);
pub const CRYPT_FORMAT_COMMA = @as(u32, 4096);
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 65536);
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 262144);
pub const CRYPT_DECODE_NOCOPY_FLAG = @as(u32, 1);
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG = @as(u32, 2);
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG = @as(u32, 4);
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_DECODE_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 67108864);
pub const CRYPT_ENCODE_DECODE_NONE = @as(u32, 0);
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = @as(u32, 1);
pub const CERT_ROOT_PROGRAM_FLAG_OU = @as(u32, 16);
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS = @as(u32, 8);
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK = @as(u32, 1023);
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = @as(u32, 22);
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK = @as(u32, 63);
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE = @as(u32, 128);
pub const CERT_NON_REPUDIATION_KEY_USAGE = @as(u32, 64);
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE = @as(u32, 32);
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE = @as(u32, 16);
pub const CERT_KEY_AGREEMENT_KEY_USAGE = @as(u32, 8);
pub const CERT_KEY_CERT_SIGN_KEY_USAGE = @as(u32, 4);
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_ENCIPHER_ONLY_KEY_USAGE = @as(u32, 1);
pub const CERT_DECIPHER_ONLY_KEY_USAGE = @as(u32, 128);
pub const CERT_ALT_NAME_X400_ADDRESS = @as(u32, 4);
pub const CERT_ALT_NAME_EDI_PARTY_NAME = @as(u32, 6);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = @as(u32, 255);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_CA_SUBJECT_FLAG = @as(u32, 128);
pub const CERT_END_ENTITY_SUBJECT_FLAG = @as(u32, 64);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = @as(u32, 9);
pub const CRL_REASON_AA_COMPROMISE = @as(u32, 10);
pub const CRL_DIST_POINT_NO_NAME = @as(u32, 0);
pub const CRL_DIST_POINT_FULL_NAME = @as(u32, 1);
pub const CRL_DIST_POINT_ISSUER_RDN_NAME = @as(u32, 2);
pub const CRL_REASON_UNUSED_FLAG = @as(u32, 128);
pub const CRL_REASON_KEY_COMPROMISE_FLAG = @as(u32, 64);
pub const CRL_REASON_CA_COMPROMISE_FLAG = @as(u32, 32);
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG = @as(u32, 16);
pub const CRL_REASON_SUPERSEDED_FLAG = @as(u32, 8);
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG = @as(u32, 4);
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG = @as(u32, 2);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = @as(u32, 1);
pub const CRL_REASON_AA_COMPROMISE_FLAG = @as(u32, 128);
pub const CRL_DIST_POINT_ERR_INDEX_MASK = @as(u32, 127);
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = @as(i32, -2147483648);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = @as(u32, 255);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CERT_EXCLUDED_SUBTREE_BIT = @as(i32, -2147483648);
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 1);
pub const CERT_DSS_R_LEN = @as(u32, 20);
pub const CERT_DSS_S_LEN = @as(u32, 20);
pub const CRYPT_X942_COUNTER_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_RC2_40BIT_VERSION = @as(u32, 160);
pub const CRYPT_RC2_56BIT_VERSION = @as(u32, 52);
pub const CRYPT_RC2_64BIT_VERSION = @as(u32, 120);
pub const CRYPT_RC2_128BIT_VERSION = @as(u32, 58);
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = @as(u32, 1);
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = @as(u32, 128);
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = @as(u32, 64);
pub const NETSCAPE_SMIME_CERT_TYPE = @as(u32, 32);
pub const NETSCAPE_SIGN_CERT_TYPE = @as(u32, 16);
pub const NETSCAPE_SSL_CA_CERT_TYPE = @as(u32, 4);
pub const NETSCAPE_SMIME_CA_CERT_TYPE = @as(u32, 2);
pub const NETSCAPE_SIGN_CA_CERT_TYPE = @as(u32, 1);
pub const CMC_TAGGED_CERT_REQUEST_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_NO_CHOICE = @as(u32, 0);
pub const CMC_OTHER_INFO_FAIL_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_PEND_CHOICE = @as(u32, 2);
pub const CMC_STATUS_SUCCESS = @as(u32, 0);
pub const CMC_STATUS_FAILED = @as(u32, 2);
pub const CMC_STATUS_PENDING = @as(u32, 3);
pub const CMC_STATUS_NO_SUPPORT = @as(u32, 4);
pub const CMC_STATUS_CONFIRM_REQUIRED = @as(u32, 5);
pub const CMC_FAIL_BAD_ALG = @as(u32, 0);
pub const CMC_FAIL_BAD_MESSAGE_CHECK = @as(u32, 1);
pub const CMC_FAIL_BAD_REQUEST = @as(u32, 2);
pub const CMC_FAIL_BAD_TIME = @as(u32, 3);
pub const CMC_FAIL_BAD_CERT_ID = @as(u32, 4);
pub const CMC_FAIL_UNSUPORTED_EXT = @as(u32, 5);
pub const CMC_FAIL_MUST_ARCHIVE_KEYS = @as(u32, 6);
pub const CMC_FAIL_BAD_IDENTITY = @as(u32, 7);
pub const CMC_FAIL_POP_REQUIRED = @as(u32, 8);
pub const CMC_FAIL_POP_FAILED = @as(u32, 9);
pub const CMC_FAIL_NO_KEY_REUSE = @as(u32, 10);
pub const CMC_FAIL_INTERNAL_CA_ERROR = @as(u32, 11);
pub const CMC_FAIL_TRY_LATER = @as(u32, 12);
pub const CERT_BIOMETRIC_PICTURE_TYPE = @as(u32, 0);
pub const CERT_BIOMETRIC_SIGNATURE_TYPE = @as(u32, 1);
pub const OCSP_REQUEST_V1 = @as(u32, 0);
pub const OCSP_SUCCESSFUL_RESPONSE = @as(u32, 0);
pub const OCSP_MALFORMED_REQUEST_RESPONSE = @as(u32, 1);
pub const OCSP_INTERNAL_ERROR_RESPONSE = @as(u32, 2);
pub const OCSP_TRY_LATER_RESPONSE = @as(u32, 3);
pub const OCSP_SIG_REQUIRED_RESPONSE = @as(u32, 5);
pub const OCSP_UNAUTHORIZED_RESPONSE = @as(u32, 6);
pub const OCSP_BASIC_GOOD_CERT_STATUS = @as(u32, 0);
pub const OCSP_BASIC_REVOKED_CERT_STATUS = @as(u32, 1);
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS = @as(u32, 2);
pub const OCSP_BASIC_RESPONSE_V1 = @as(u32, 0);
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID = @as(u32, 1);
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID = @as(u32, 2);
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = @as(u32, 1);
pub const CRYPT_REGISTER_FIRST_INDEX = @as(u32, 0);
pub const CRYPT_REGISTER_LAST_INDEX = @as(u32, 4294967295);
pub const CRYPT_MATCH_ANY_ENCODING_TYPE = @as(u32, 4294967295);
pub const CALG_OID_INFO_CNG_ONLY = @as(u32, 4294967295);
pub const CALG_OID_INFO_PARAMETERS = @as(u32, 4294967294);
pub const CRYPT_HASH_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = @as(u32, 2);
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID = @as(u32, 3);
pub const CRYPT_SIGN_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_RDN_ATTR_OID_GROUP_ID = @as(u32, 5);
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = @as(u32, 6);
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = @as(u32, 7);
pub const CRYPT_POLICY_OID_GROUP_ID = @as(u32, 8);
pub const CRYPT_TEMPLATE_OID_GROUP_ID = @as(u32, 9);
pub const CRYPT_KDF_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_LAST_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = @as(u32, 1);
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = @as(u32, 2);
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = @as(u32, 4);
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = @as(u32, 536870912);
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = @as(u32, 268435456);
pub const CRYPT_OID_INFO_OID_KEY = @as(u32, 1);
pub const CRYPT_OID_INFO_NAME_KEY = @as(u32, 2);
pub const CRYPT_OID_INFO_ALGID_KEY = @as(u32, 3);
pub const CRYPT_OID_INFO_SIGN_KEY = @as(u32, 4);
pub const CRYPT_OID_INFO_CNG_ALGID_KEY = @as(u32, 5);
pub const CRYPT_OID_INFO_CNG_SIGN_KEY = @as(u32, 6);
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = @as(u32, 4294901760);
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PREFER_CNG_ALGID_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = @as(u32, 268369920);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = @as(u32, 16);
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = @as(u32, 0);
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = @as(u32, 1);
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE = @as(u32, 2);
pub const CMSG_ENCRYPTED = @as(u32, 6);
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = @as(u32, 1);
pub const CMSG_KEY_TRANS_RECIPIENT = @as(u32, 1);
pub const CMSG_KEY_AGREE_RECIPIENT = @as(u32, 2);
pub const CMSG_MAIL_LIST_RECIPIENT = @as(u32, 3);
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = @as(u32, 2147483648);
pub const CMSG_RC4_NO_SALT_FLAG = @as(u32, 1073741824);
pub const CMSG_INDEFINITE_LENGTH = @as(u32, 4294967295);
pub const CMSG_BARE_CONTENT_FLAG = @as(u32, 1);
pub const CMSG_LENGTH_ONLY_FLAG = @as(u32, 2);
pub const CMSG_DETACHED_FLAG = @as(u32, 4);
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = @as(u32, 8);
pub const CMSG_CONTENTS_OCTETS_FLAG = @as(u32, 16);
pub const CMSG_MAX_LENGTH_FLAG = @as(u32, 32);
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = @as(u32, 64);
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG = @as(u32, 128);
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_TYPE_PARAM = @as(u32, 1);
pub const CMSG_CONTENT_PARAM = @as(u32, 2);
pub const CMSG_BARE_CONTENT_PARAM = @as(u32, 3);
pub const CMSG_INNER_CONTENT_TYPE_PARAM = @as(u32, 4);
pub const CMSG_SIGNER_COUNT_PARAM = @as(u32, 5);
pub const CMSG_SIGNER_INFO_PARAM = @as(u32, 6);
pub const CMSG_SIGNER_CERT_INFO_PARAM = @as(u32, 7);
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM = @as(u32, 8);
pub const CMSG_SIGNER_AUTH_ATTR_PARAM = @as(u32, 9);
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM = @as(u32, 10);
pub const CMSG_CERT_COUNT_PARAM = @as(u32, 11);
pub const CMSG_CERT_PARAM = @as(u32, 12);
pub const CMSG_CRL_COUNT_PARAM = @as(u32, 13);
pub const CMSG_CRL_PARAM = @as(u32, 14);
pub const CMSG_ENVELOPE_ALGORITHM_PARAM = @as(u32, 15);
pub const CMSG_RECIPIENT_COUNT_PARAM = @as(u32, 17);
pub const CMSG_RECIPIENT_INDEX_PARAM = @as(u32, 18);
pub const CMSG_RECIPIENT_INFO_PARAM = @as(u32, 19);
pub const CMSG_HASH_ALGORITHM_PARAM = @as(u32, 20);
pub const CMSG_HASH_DATA_PARAM = @as(u32, 21);
pub const CMSG_COMPUTED_HASH_PARAM = @as(u32, 22);
pub const CMSG_ENCRYPT_PARAM = @as(u32, 26);
pub const CMSG_ENCRYPTED_DIGEST = @as(u32, 27);
pub const CMSG_ENCODED_SIGNER = @as(u32, 28);
pub const CMSG_ENCODED_MESSAGE = @as(u32, 29);
pub const CMSG_VERSION_PARAM = @as(u32, 30);
pub const CMSG_ATTR_CERT_COUNT_PARAM = @as(u32, 31);
pub const CMSG_ATTR_CERT_PARAM = @as(u32, 32);
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM = @as(u32, 33);
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM = @as(u32, 34);
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = @as(u32, 35);
pub const CMSG_CMS_RECIPIENT_INFO_PARAM = @as(u32, 36);
pub const CMSG_UNPROTECTED_ATTR_PARAM = @as(u32, 37);
pub const CMSG_SIGNER_CERT_ID_PARAM = @as(u32, 38);
pub const CMSG_CMS_SIGNER_INFO_PARAM = @as(u32, 39);
pub const CMSG_SIGNED_DATA_V1 = @as(u32, 1);
pub const CMSG_SIGNED_DATA_V3 = @as(u32, 3);
pub const CMSG_SIGNER_INFO_V1 = @as(u32, 1);
pub const CMSG_SIGNER_INFO_V3 = @as(u32, 3);
pub const CMSG_HASHED_DATA_V0 = @as(u32, 0);
pub const CMSG_HASHED_DATA_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_RECIPIENT_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V3 = @as(u32, 3);
pub const CMSG_ENVELOPED_RECIPIENT_V4 = @as(u32, 4);
pub const CMSG_CTRL_VERIFY_SIGNATURE = @as(u32, 1);
pub const CMSG_CTRL_DECRYPT = @as(u32, 2);
pub const CMSG_CTRL_VERIFY_HASH = @as(u32, 5);
pub const CMSG_CTRL_ADD_SIGNER = @as(u32, 6);
pub const CMSG_CTRL_DEL_SIGNER = @as(u32, 7);
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = @as(u32, 8);
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = @as(u32, 9);
pub const CMSG_CTRL_ADD_CERT = @as(u32, 10);
pub const CMSG_CTRL_DEL_CERT = @as(u32, 11);
pub const CMSG_CTRL_ADD_CRL = @as(u32, 12);
pub const CMSG_CTRL_DEL_CRL = @as(u32, 13);
pub const CMSG_CTRL_ADD_ATTR_CERT = @as(u32, 14);
pub const CMSG_CTRL_DEL_ATTR_CERT = @as(u32, 15);
pub const CMSG_CTRL_KEY_TRANS_DECRYPT = @as(u32, 16);
pub const CMSG_CTRL_KEY_AGREE_DECRYPT = @as(u32, 17);
pub const CMSG_CTRL_MAIL_LIST_DECRYPT = @as(u32, 18);
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX = @as(u32, 19);
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO = @as(u32, 20);
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = @as(u32, 21);
pub const CMSG_VERIFY_SIGNER_PUBKEY = @as(u32, 1);
pub const CMSG_VERIFY_SIGNER_CERT = @as(u32, 2);
pub const CMSG_VERIFY_SIGNER_CHAIN = @as(u32, 3);
pub const CMSG_VERIFY_SIGNER_NULL = @as(u32, 4);
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = @as(u32, 4);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = @as(u32, 8);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = @as(u32, 16);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 32);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CERT_KEY_PROV_HANDLE_PROP_ID = @as(u32, 1);
pub const CERT_KEY_PROV_INFO_PROP_ID = @as(u32, 2);
pub const CERT_SHA1_HASH_PROP_ID = @as(u32, 3);
pub const CERT_MD5_HASH_PROP_ID = @as(u32, 4);
pub const CERT_KEY_CONTEXT_PROP_ID = @as(u32, 5);
pub const CERT_KEY_SPEC_PROP_ID = @as(u32, 6);
pub const CERT_IE30_RESERVED_PROP_ID = @as(u32, 7);
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID = @as(u32, 8);
pub const CERT_ENHKEY_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID = @as(u32, 10);
pub const CERT_FRIENDLY_NAME_PROP_ID = @as(u32, 11);
pub const CERT_PVK_FILE_PROP_ID = @as(u32, 12);
pub const CERT_DESCRIPTION_PROP_ID = @as(u32, 13);
pub const CERT_ACCESS_STATE_PROP_ID = @as(u32, 14);
pub const CERT_SIGNATURE_HASH_PROP_ID = @as(u32, 15);
pub const CERT_SMART_CARD_DATA_PROP_ID = @as(u32, 16);
pub const CERT_EFS_PROP_ID = @as(u32, 17);
pub const CERT_FORTEZZA_DATA_PROP_ID = @as(u32, 18);
pub const CERT_ARCHIVED_PROP_ID = @as(u32, 19);
pub const CERT_KEY_IDENTIFIER_PROP_ID = @as(u32, 20);
pub const CERT_AUTO_ENROLL_PROP_ID = @as(u32, 21);
pub const CERT_PUBKEY_ALG_PARA_PROP_ID = @as(u32, 22);
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = @as(u32, 23);
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 24);
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 25);
pub const CERT_ENROLLMENT_PROP_ID = @as(u32, 26);
pub const CERT_DATE_STAMP_PROP_ID = @as(u32, 27);
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = @as(u32, 28);
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = @as(u32, 29);
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID = @as(u32, 30);
pub const CERT_RENEWAL_PROP_ID = @as(u32, 64);
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID = @as(u32, 65);
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID = @as(u32, 66);
pub const CERT_AIA_URL_RETRIEVED_PROP_ID = @as(u32, 67);
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 68);
pub const CERT_BACKED_UP_PROP_ID = @as(u32, 69);
pub const CERT_OCSP_RESPONSE_PROP_ID = @as(u32, 70);
pub const CERT_REQUEST_ORIGINATOR_PROP_ID = @as(u32, 71);
pub const CERT_SOURCE_LOCATION_PROP_ID = @as(u32, 72);
pub const CERT_SOURCE_URL_PROP_ID = @as(u32, 73);
pub const CERT_NEW_KEY_PROP_ID = @as(u32, 74);
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID = @as(u32, 75);
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID = @as(u32, 76);
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = @as(u32, 77);
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 78);
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 79);
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID = @as(u32, 80);
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 81);
pub const CERT_CA_DISABLE_CRL_PROP_ID = @as(u32, 82);
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = @as(u32, 83);
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = @as(u32, 84);
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 85);
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID = @as(u32, 86);
pub const CERT_CEP_PROP_ID = @as(u32, 87);
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 89);
pub const CERT_SCARD_PIN_ID_PROP_ID = @as(u32, 90);
pub const CERT_SCARD_PIN_INFO_PROP_ID = @as(u32, 91);
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 92);
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 93);
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 94);
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 95);
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 96);
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = @as(u32, 97);
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = @as(u32, 98);
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = @as(u32, 99);
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID = @as(u32, 100);
pub const CERT_SMART_CARD_READER_PROP_ID = @as(u32, 101);
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = @as(u32, 102);
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = @as(u32, 103);
pub const CERT_DISALLOWED_FILETIME_PROP_ID = @as(u32, 104);
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = @as(u32, 105);
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = @as(u32, 106);
pub const CERT_SHA256_HASH_PROP_ID = @as(u32, 107);
pub const CERT_SCEP_SERVER_CERTS_PROP_ID = @as(u32, 108);
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = @as(u32, 109);
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = @as(u32, 110);
pub const CERT_SCEP_CA_CERT_PROP_ID = @as(u32, 111);
pub const CERT_SCEP_SIGNER_CERT_PROP_ID = @as(u32, 112);
pub const CERT_SCEP_NONCE_PROP_ID = @as(u32, 113);
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = @as(u32, 114);
pub const CERT_SCEP_FLAGS_PROP_ID = @as(u32, 115);
pub const CERT_SCEP_GUID_PROP_ID = @as(u32, 116);
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = @as(u32, 117);
pub const CERT_ISOLATED_KEY_PROP_ID = @as(u32, 118);
pub const CERT_SERIAL_CHAIN_PROP_ID = @as(u32, 119);
pub const CERT_KEY_CLASSIFICATION_PROP_ID = @as(u32, 120);
pub const CERT_OCSP_MUST_STAPLE_PROP_ID = @as(u32, 121);
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = @as(u32, 122);
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = @as(u32, 123);
pub const CERT_PIN_SHA256_HASH_PROP_ID = @as(u32, 124);
pub const CERT_CLR_DELETE_KEY_PROP_ID = @as(u32, 125);
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID = @as(u32, 126);
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = @as(u32, 127);
pub const CERT_FIRST_RESERVED_PROP_ID = @as(u32, 128);
pub const CERT_LAST_RESERVED_PROP_ID = @as(u32, 32767);
pub const CERT_FIRST_USER_PROP_ID = @as(u32, 32768);
pub const CERT_LAST_USER_PROP_ID = @as(u32, 65535);
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = @as(u32, 1);
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = @as(u32, 2);
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = @as(u32, 4);
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = @as(u32, 8);
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG = @as(u32, 16);
pub const CERT_STORE_SIGNATURE_FLAG = @as(u32, 1);
pub const CERT_STORE_TIME_VALIDITY_FLAG = @as(u32, 2);
pub const CERT_STORE_REVOCATION_FLAG = @as(u32, 4);
pub const CERT_STORE_NO_CRL_FLAG = @as(u32, 65536);
pub const CERT_STORE_NO_ISSUER_FLAG = @as(u32, 131072);
pub const CERT_STORE_BASE_CRL_FLAG = @as(u32, 256);
pub const CERT_STORE_DELTA_CRL_FLAG = @as(u32, 512);
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG = @as(u32, 32);
pub const CERT_STORE_SHARE_STORE_FLAG = @as(u32, 64);
pub const CERT_STORE_MANIFOLD_FLAG = @as(u32, 256);
pub const CERT_SYSTEM_STORE_MASK = @as(u32, 4294901760);
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = @as(u32, 1073741824);
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG = @as(u32, 536870912);
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT = @as(u32, 16);
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID = @as(u32, 1);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = @as(u32, 2);
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = @as(u32, 4);
pub const CERT_SYSTEM_STORE_SERVICES_ID = @as(u32, 5);
pub const CERT_SYSTEM_STORE_USERS_ID = @as(u32, 6);
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = @as(u32, 7);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = @as(u32, 8);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = @as(u32, 9);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = @as(u32, 10);
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = @as(u32, 1);
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = @as(u32, 2);
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = @as(u32, 4);
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = @as(u32, 16);
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = @as(u32, 32);
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST = @as(u32, 65536);
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK = @as(u32, 3);
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = @as(u32, 0);
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = @as(u32, 1);
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = @as(u32, 2);
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = @as(u32, 256);
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = @as(u32, 512);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = @as(u32, 1);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = @as(u32, 2);
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = @as(u32, 4);
pub const CERT_REGISTRY_STORE_REMOTE_FLAG = @as(u32, 65536);
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG = @as(u32, 131072);
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = @as(u32, 2147483648);
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG = @as(u32, 16777216);
pub const CERT_REGISTRY_STORE_ROAMING_FLAG = @as(u32, 262144);
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = @as(u32, 524288);
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG = @as(u32, 1048576);
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_SIGN_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = @as(u32, 131072);
pub const CERT_LDAP_STORE_OPENED_FLAG = @as(u32, 262144);
pub const CERT_LDAP_STORE_UNBIND_FLAG = @as(u32, 524288);
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = @as(u32, 32);
pub const CERT_STORE_PROV_SHARED_USER_FLAG = @as(u32, 64);
pub const CERT_STORE_PROV_CLOSE_FUNC = @as(u32, 0);
pub const CERT_STORE_PROV_READ_CERT_FUNC = @as(u32, 1);
pub const CERT_STORE_PROV_WRITE_CERT_FUNC = @as(u32, 2);
pub const CERT_STORE_PROV_DELETE_CERT_FUNC = @as(u32, 3);
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = @as(u32, 4);
pub const CERT_STORE_PROV_READ_CRL_FUNC = @as(u32, 5);
pub const CERT_STORE_PROV_WRITE_CRL_FUNC = @as(u32, 6);
pub const CERT_STORE_PROV_DELETE_CRL_FUNC = @as(u32, 7);
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = @as(u32, 8);
pub const CERT_STORE_PROV_READ_CTL_FUNC = @as(u32, 9);
pub const CERT_STORE_PROV_WRITE_CTL_FUNC = @as(u32, 10);
pub const CERT_STORE_PROV_DELETE_CTL_FUNC = @as(u32, 11);
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = @as(u32, 12);
pub const CERT_STORE_PROV_CONTROL_FUNC = @as(u32, 13);
pub const CERT_STORE_PROV_FIND_CERT_FUNC = @as(u32, 14);
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = @as(u32, 15);
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = @as(u32, 16);
pub const CERT_STORE_PROV_FIND_CRL_FUNC = @as(u32, 17);
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = @as(u32, 18);
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = @as(u32, 19);
pub const CERT_STORE_PROV_FIND_CTL_FUNC = @as(u32, 20);
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = @as(u32, 21);
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = @as(u32, 22);
pub const CERT_STORE_PROV_WRITE_ADD_FLAG = @as(u32, 1);
pub const CERT_STORE_SAVE_AS_PKCS12 = @as(u32, 3);
pub const CERT_CLOSE_STORE_FORCE_FLAG = @as(u32, 1);
pub const CERT_CLOSE_STORE_CHECK_FLAG = @as(u32, 2);
pub const CERT_COMPARE_MASK = @as(u32, 65535);
pub const CERT_COMPARE_ANY = @as(u32, 0);
pub const CERT_COMPARE_SHA1_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME = @as(u32, 2);
pub const CERT_COMPARE_ATTR = @as(u32, 3);
pub const CERT_COMPARE_MD5_HASH = @as(u32, 4);
pub const CERT_COMPARE_PROPERTY = @as(u32, 5);
pub const CERT_COMPARE_PUBLIC_KEY = @as(u32, 6);
pub const CERT_COMPARE_NAME_STR_A = @as(u32, 7);
pub const CERT_COMPARE_NAME_STR_W = @as(u32, 8);
pub const CERT_COMPARE_KEY_SPEC = @as(u32, 9);
pub const CERT_COMPARE_ENHKEY_USAGE = @as(u32, 10);
pub const CERT_COMPARE_SUBJECT_CERT = @as(u32, 11);
pub const CERT_COMPARE_ISSUER_OF = @as(u32, 12);
pub const CERT_COMPARE_EXISTING = @as(u32, 13);
pub const CERT_COMPARE_SIGNATURE_HASH = @as(u32, 14);
pub const CERT_COMPARE_KEY_IDENTIFIER = @as(u32, 15);
pub const CERT_COMPARE_CERT_ID = @as(u32, 16);
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS = @as(u32, 17);
pub const CERT_COMPARE_PUBKEY_MD5_HASH = @as(u32, 18);
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS = @as(u32, 19);
pub const CERT_COMPARE_HASH_STR = @as(u32, 20);
pub const CERT_COMPARE_HAS_PRIVATE_KEY = @as(u32, 21);
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = @as(u32, 2147483648);
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = @as(u32, 1073741824);
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = @as(u32, 1);
pub const CRL_FIND_ANY = @as(u32, 0);
pub const CRL_FIND_ISSUED_BY = @as(u32, 1);
pub const CRL_FIND_EXISTING = @as(u32, 2);
pub const CRL_FIND_ISSUED_FOR = @as(u32, 3);
pub const CRL_FIND_ISSUED_BY_AKI_FLAG = @as(u32, 1);
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = @as(u32, 2);
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG = @as(u32, 4);
pub const CRL_FIND_ISSUED_BY_BASE_FLAG = @as(u32, 8);
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = @as(u32, 16);
pub const CERT_STORE_ADD_NEW = @as(u32, 1);
pub const CERT_STORE_ADD_USE_EXISTING = @as(u32, 2);
pub const CERT_STORE_ADD_REPLACE_EXISTING = @as(u32, 3);
pub const CERT_STORE_ADD_ALWAYS = @as(u32, 4);
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = @as(u32, 5);
pub const CERT_STORE_ADD_NEWER = @as(u32, 6);
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = @as(u32, 7);
pub const CERT_STORE_CERTIFICATE_CONTEXT = @as(u32, 1);
pub const CERT_STORE_CRL_CONTEXT = @as(u32, 2);
pub const CERT_STORE_CTL_CONTEXT = @as(u32, 3);
pub const CTL_ANY_SUBJECT_TYPE = @as(u32, 1);
pub const CTL_CERT_SUBJECT_TYPE = @as(u32, 2);
pub const CTL_FIND_NO_LIST_ID_CBDATA = @as(u32, 4294967295);
pub const CERT_STORE_CTRL_RESYNC = @as(u32, 1);
pub const CERT_STORE_CTRL_NOTIFY_CHANGE = @as(u32, 2);
pub const CERT_STORE_CTRL_COMMIT = @as(u32, 3);
pub const CERT_STORE_CTRL_AUTO_RESYNC = @as(u32, 4);
pub const CERT_STORE_CTRL_CANCEL_NOTIFY = @as(u32, 5);
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID = @as(u32, 4096);
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG = @as(u32, 1);
pub const CERT_CREATE_CONTEXT_SORTED_FLAG = @as(u32, 2);
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = @as(u32, 4);
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = @as(u32, 2);
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = @as(u32, 4);
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = @as(u32, 1);
pub const CMSG_TRUSTED_SIGNER_FLAG = @as(u32, 1);
pub const CMSG_SIGNER_ONLY_FLAG = @as(u32, 2);
pub const CMSG_USE_SIGNER_INDEX_FLAG = @as(u32, 4);
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG = @as(u32, 32768);
pub const CMSG_ENCODE_SORTED_CTL_FLAG = @as(u32, 1);
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 2);
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = @as(u32, 1);
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = @as(u32, 2);
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG = @as(u32, 4);
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = @as(u32, 8);
pub const CERT_VERIFY_UPDATED_CTL_FLAG = @as(u32, 1);
pub const CERT_CONTEXT_REVOCATION_TYPE = @as(u32, 1);
pub const CERT_VERIFY_REV_CHAIN_FLAG = @as(u32, 1);
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = @as(u32, 2);
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = @as(u32, 4);
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG = @as(u32, 8);
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = @as(u32, 16);
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = @as(u32, 32);
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG = @as(u32, 1);
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = @as(u32, 8);
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = @as(u32, 128);
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = @as(u32, 458752);
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = @as(u32, 65536);
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = @as(u32, 131072);
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = @as(u32, 262144);
pub const CERT_XML_NAME_STR = @as(u32, 4);
pub const CERT_NAME_STR_SEMICOLON_FLAG = @as(u32, 1073741824);
pub const CERT_NAME_STR_NO_PLUS_FLAG = @as(u32, 536870912);
pub const CERT_NAME_STR_NO_QUOTING_FLAG = @as(u32, 268435456);
pub const CERT_NAME_STR_CRLF_FLAG = @as(u32, 134217728);
pub const CERT_NAME_STR_COMMA_FLAG = @as(u32, 67108864);
pub const CERT_NAME_STR_REVERSE_FLAG = @as(u32, 33554432);
pub const CERT_NAME_STR_FORWARD_FLAG = @as(u32, 16777216);
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = @as(u32, 131072);
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 262144);
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = @as(u32, 524288);
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = @as(u32, 1048576);
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = @as(u32, 2097152);
pub const CERT_NAME_EMAIL_TYPE = @as(u32, 1);
pub const CERT_NAME_RDN_TYPE = @as(u32, 2);
pub const CERT_NAME_ATTR_TYPE = @as(u32, 3);
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE = @as(u32, 4);
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE = @as(u32, 5);
pub const CERT_NAME_DNS_TYPE = @as(u32, 6);
pub const CERT_NAME_URL_TYPE = @as(u32, 7);
pub const CERT_NAME_UPN_TYPE = @as(u32, 8);
pub const CERT_NAME_ISSUER_FLAG = @as(u32, 1);
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = @as(u32, 1);
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = @as(u32, 4);
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = @as(u32, 64);
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = @as(u32, 4);
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = @as(u32, 1);
pub const CRYPT_CACHE_ONLY_RETRIEVAL = @as(u32, 2);
pub const CRYPT_WIRE_ONLY_RETRIEVAL = @as(u32, 4);
pub const CRYPT_DONT_CACHE_RESULT = @as(u32, 8);
pub const CRYPT_ASYNC_RETRIEVAL = @as(u32, 16);
pub const CRYPT_STICKY_CACHE_RETRIEVAL = @as(u32, 4096);
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = @as(u32, 8192);
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL = @as(u32, 16384);
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = @as(u32, 32768);
pub const CRYPT_LDAP_SIGN_RETRIEVAL = @as(u32, 65536);
pub const CRYPT_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = @as(u32, 262144);
pub const CRYPT_AIA_RETRIEVAL = @as(u32, 524288);
pub const CRYPT_HTTP_POST_RETRIEVAL = @as(u32, 1048576);
pub const CRYPT_PROXY_CACHE_RETRIEVAL = @as(u32, 2097152);
pub const CRYPT_NOT_MODIFIED_RETRIEVAL = @as(u32, 4194304);
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = @as(u32, 8388608);
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = @as(u32, 67108864);
pub const CRYPT_ENABLE_FILE_RETRIEVAL = @as(u32, 134217728);
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY = @as(u32, 268435456);
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const CRYPT_VERIFY_DATA_HASH = @as(u32, 64);
pub const CRYPT_KEEP_TIME_VALID = @as(u32, 128);
pub const CRYPT_DONT_VERIFY_SIGNATURE = @as(u32, 256);
pub const CRYPT_DONT_CHECK_TIME_VALIDITY = @as(u32, 512);
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = @as(u32, 1024);
pub const CRYPT_ACCUMULATIVE_TIMEOUT = @as(u32, 2048);
pub const CRYPT_OCSP_ONLY_RETRIEVAL = @as(u32, 16777216);
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = @as(u32, 33554432);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = @as(u32, 2);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = @as(u32, 3);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = @as(u32, 5);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = @as(u32, 6);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = @as(u32, 7);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = @as(u32, 32768);
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = @as(u32, 4096);
pub const CRYPT_KEYID_MACHINE_FLAG = @as(u32, 32);
pub const CRYPT_KEYID_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_KEYID_DELETE_FLAG = @as(u32, 16);
pub const CRYPT_KEYID_SET_NEW_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = @as(u32, 3);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = @as(u32, 100000);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = @as(u32, 10);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = @as(u32, 1);
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = @as(u32, 2);
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = @as(u32, 4);
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = @as(u32, 8);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = @as(u32, 1023);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = @as(u32, 2147483648);
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = @as(u32, 65536);
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = @as(u32, 131072);
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = @as(u32, 262144);
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = @as(u32, 1048576);
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = @as(u32, 2097152);
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = @as(u32, 4194304);
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = @as(u32, 8388608);
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 16777216);
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 33554432);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = @as(u32, 134217728);
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = @as(u32, 268435456);
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = @as(u32, 536870912);
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = @as(u32, 1073741824);
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 16384);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 32768);
pub const CERT_CHAIN_AUTO_CURRENT_USER = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE = @as(u32, 2);
pub const CERT_CHAIN_AUTO_IMPERSONATED = @as(u32, 3);
pub const CERT_CHAIN_AUTO_PROCESS_INFO = @as(u32, 4);
pub const CERT_CHAIN_AUTO_PINRULE_INFO = @as(u32, 5);
pub const CERT_CHAIN_AUTO_NETWORK_INFO = @as(u32, 6);
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = @as(u32, 7);
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = @as(u32, 2);
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG = @as(u32, 4);
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = @as(u32, 8);
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT = @as(u32, 5);
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT = @as(u32, 500);
pub const CRYPTNET_OCSP_AFTER_CRL_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 20);
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT = @as(u32, 60);
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT = @as(u32, 50);
pub const CRYPTNET_CRL_BEFORE_OCSP_ENABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = @as(u32, 2);
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = @as(u32, 12);
pub const CERT_CHAIN_CACHE_END_CERT = @as(u32, 1);
pub const CERT_CHAIN_THREAD_STORE_SYNC = @as(u32, 2);
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = @as(u32, 8);
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = @as(u32, 16);
pub const CERT_CHAIN_ENABLE_SHARE_STORE = @as(u32, 32);
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = @as(u32, 1);
pub const CERT_TRUST_NO_ERROR = @as(u32, 0);
pub const CERT_TRUST_IS_NOT_TIME_VALID = @as(u32, 1);
pub const CERT_TRUST_IS_NOT_TIME_NESTED = @as(u32, 2);
pub const CERT_TRUST_IS_REVOKED = @as(u32, 4);
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID = @as(u32, 8);
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = @as(u32, 16);
pub const CERT_TRUST_IS_UNTRUSTED_ROOT = @as(u32, 32);
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = @as(u32, 64);
pub const CERT_TRUST_IS_CYCLIC = @as(u32, 128);
pub const CERT_TRUST_INVALID_EXTENSION = @as(u32, 256);
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = @as(u32, 512);
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS = @as(u32, 2048);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = @as(u32, 4096);
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = @as(u32, 8192);
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = @as(u32, 16384);
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = @as(u32, 32768);
pub const CERT_TRUST_IS_OFFLINE_REVOCATION = @as(u32, 16777216);
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = @as(u32, 33554432);
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST = @as(u32, 67108864);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = @as(u32, 134217728);
pub const CERT_TRUST_HAS_WEAK_SIGNATURE = @as(u32, 1048576);
pub const CERT_TRUST_HAS_WEAK_HYGIENE = @as(u32, 2097152);
pub const CERT_TRUST_IS_PARTIAL_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID = @as(u32, 131072);
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = @as(u32, 262144);
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = @as(u32, 524288);
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = @as(u32, 1);
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER = @as(u32, 2);
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER = @as(u32, 4);
pub const CERT_TRUST_IS_SELF_SIGNED = @as(u32, 8);
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = @as(u32, 16);
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = @as(u32, 32);
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = @as(u32, 64);
pub const CERT_TRUST_IS_KEY_ROLLOVER = @as(u32, 128);
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP = @as(u32, 262144);
pub const CERT_TRUST_SSL_TIME_VALID_OCSP = @as(u32, 524288);
pub const CERT_TRUST_SSL_RECONNECT_OCSP = @as(u32, 1048576);
pub const CERT_TRUST_HAS_PREFERRED_ISSUER = @as(u32, 256);
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = @as(u32, 512);
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_IS_PEER_TRUSTED = @as(u32, 2048);
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = @as(u32, 4096);
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = @as(u32, 8192);
pub const CERT_TRUST_IS_CA_TRUSTED = @as(u32, 16384);
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = @as(u32, 32768);
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = @as(u32, 131072);
pub const CERT_TRUST_IS_COMPLEX_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_SSL_TIME_VALID = @as(u32, 16777216);
pub const CERT_TRUST_NO_TIME_CHECK = @as(u32, 33554432);
pub const USAGE_MATCH_TYPE_AND = @as(u32, 0);
pub const USAGE_MATCH_TYPE_OR = @as(u32, 1);
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = @as(u32, 1);
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT = @as(u32, 268435456);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN = @as(u32, 536870912);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = @as(u32, 1073741824);
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = @as(u32, 2147483648);
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = @as(u32, 134217728);
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = @as(u32, 64);
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = @as(u32, 128);
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = @as(u32, 256);
pub const CERT_CHAIN_TIMESTAMP_TIME = @as(u32, 512);
pub const CERT_CHAIN_ENABLE_PEER_TRUST = @as(u32, 1024);
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST = @as(u32, 2048);
pub const CERT_CHAIN_DISABLE_MD2_MD4 = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_AIA = @as(u32, 8192);
pub const CERT_CHAIN_HAS_MOTW = @as(u32, 16384);
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = @as(u32, 65536);
pub const CERT_CHAIN_FIND_BY_ISSUER = @as(u32, 1);
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = @as(u32, 134217728);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = @as(u32, 2147483648);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = @as(u32, 1073741824);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = @as(u32, 65536);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = @as(u32, 131072);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = @as(u32, 262144);
pub const SSL_F12_ERROR_TEXT_LENGTH = @as(u32, 256);
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = @as(u32, 2);
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = @as(u32, 2);
pub const SSL_HPKP_PKP_HEADER_INDEX = @as(u32, 0);
pub const SSL_HPKP_PKP_RO_HEADER_INDEX = @as(u32, 1);
pub const SSL_HPKP_HEADER_COUNT = @as(u32, 2);
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH = @as(u32, 512);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = @as(i32, -2);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = @as(i32, -1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = @as(u32, 2);
pub const CRYPT_STRING_BASE64URI = @as(u32, 13);
pub const CRYPT_STRING_ENCODEMASK = @as(u32, 255);
pub const CRYPT_STRING_RESERVED100 = @as(u32, 256);
pub const CRYPT_STRING_RESERVED200 = @as(u32, 512);
pub const CRYPT_STRING_PERCENTESCAPE = @as(u32, 134217728);
pub const CRYPT_STRING_HASHDATA = @as(u32, 268435456);
pub const CRYPT_STRING_NOCRLF = @as(u32, 1073741824);
pub const CRYPT_STRING_NOCR = @as(u32, 2147483648);
pub const PKCS12_IMPORT_SILENT = @as(u32, 64);
pub const PKCS12_ONLY_CERTIFICATES = @as(u32, 1024);
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = @as(u32, 2048);
pub const PKCS12_VIRTUAL_ISOLATION_KEY = @as(u32, 65536);
pub const PKCS12_IMPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = @as(u32, 0);
pub const REPORT_NO_PRIVATE_KEY = @as(u32, 1);
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = @as(u32, 2);
pub const EXPORT_PRIVATE_KEYS = @as(u32, 4);
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS = @as(u32, 32);
pub const PKCS12_EXPORT_SILENT = @as(u32, 64);
pub const PKCS12_EXPORT_PBES2_PARAMS = @as(u32, 128);
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = @as(u32, 256);
pub const PKCS12_ENCRYPT_CERTIFICATES = @as(u32, 512);
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = @as(u32, 4096);
pub const PKCS12_EXPORT_ECC_CURVE_OID = @as(u32, 8192);
pub const PKCS12_EXPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = @as(u32, 1);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = @as(u32, 2);
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = @as(u32, 1);
pub const CERT_SELECT_MAX_PARA = @as(u32, 500);
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME = @as(u32, 12);
pub const CERT_SELECT_BY_FRIENDLYNAME = @as(u32, 13);
pub const CERT_SELECT_BY_THUMBPRINT = @as(u32, 14);
pub const CERT_SELECT_ALLOW_EXPIRED = @as(u32, 1);
pub const CERT_SELECT_TRUSTED_ROOT = @as(u32, 2);
pub const CERT_SELECT_DISALLOW_SELFSIGNED = @as(u32, 4);
pub const CERT_SELECT_HAS_PRIVATE_KEY = @as(u32, 8);
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = @as(u32, 16);
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = @as(u32, 32);
pub const CERT_SELECT_HARDWARE_ONLY = @as(u32, 64);
pub const CERT_SELECT_ALLOW_DUPLICATES = @as(u32, 128);
pub const CERT_SELECT_IGNORE_AUTOSELECT = @as(u32, 256);
pub const TIMESTAMP_FAILURE_BAD_ALG = @as(u32, 0);
pub const TIMESTAMP_FAILURE_BAD_REQUEST = @as(u32, 2);
pub const TIMESTAMP_FAILURE_BAD_FORMAT = @as(u32, 5);
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = @as(u32, 14);
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = @as(u32, 15);
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = @as(u32, 16);
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = @as(u32, 17);
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE = @as(u32, 25);
pub const TIMESTAMP_DONT_HASH_DATA = @as(u32, 1);
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const TIMESTAMP_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = @as(u32, 1);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = @as(u32, 32);
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = @as(u32, 33);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = @as(u32, 65535);
pub const CERT_FILE_HASH_USE_TYPE = @as(u32, 1);
pub const CERT_TIMESTAMP_HASH_USE_TYPE = @as(u32, 2);
pub const CRYPT_XML_BLOB_MAX = @as(u32, 2147483640);
pub const CRYPT_XML_ID_MAX = @as(u32, 256);
pub const CRYPT_XML_SIGNATURES_MAX = @as(u32, 16);
pub const CRYPT_XML_TRANSFORM_MAX = @as(u32, 16);
pub const CRYPT_XML_SIGNATURE_VALUE_MAX = @as(u32, 2048);
pub const CRYPT_XML_DIGEST_VALUE_MAX = @as(u32, 128);
pub const CRYPT_XML_OBJECTS_MAX = @as(u32, 256);
pub const CRYPT_XML_REFERENCES_MAX = @as(u32, 32760);
pub const CRYPT_XML_E_BASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885376));
pub const CRYPT_XML_E_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885375));
pub const CRYPT_XML_E_TOO_MANY_TRANSFORMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885374));
pub const CRYPT_XML_E_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885373));
pub const CRYPT_XML_E_ALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885372));
pub const CRYPT_XML_E_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885371));
pub const CRYPT_XML_E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885370));
pub const CRYPT_XML_E_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885369));
pub const CRYPT_XML_E_UNRESOLVED_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885368));
pub const CRYPT_XML_E_INVALID_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885367));
pub const CRYPT_XML_E_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885366));
pub const CRYPT_XML_E_HASH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885365));
pub const CRYPT_XML_E_SIGN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885364));
pub const CRYPT_XML_E_VERIFY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885363));
pub const CRYPT_XML_E_TOO_MANY_SIGNATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885362));
pub const CRYPT_XML_E_INVALID_KEYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885361));
pub const CRYPT_XML_E_UNEXPECTED_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885360));
pub const CRYPT_XML_E_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885359));
pub const CRYPT_XML_E_NON_UNIQUE_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT = @as(u32, 1073741824);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT = @as(u32, 536870912);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT = @as(u32, 134217728);
pub const CRYPT_XML_FLAG_ECDSA_DSIG11 = @as(u32, 67108864);
pub const CRYPT_XML_STATUS_NO_ERROR = @as(u32, 0);
pub const CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY = @as(u32, 1);
pub const CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT = @as(u32, 1);
pub const CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_HASH = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_SIGN = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI = @as(u32, 1);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID = @as(u32, 3);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID = @as(u32, 4);
pub const CAIF_DSENTRY = @as(u32, 1);
pub const CAIF_SHAREDFOLDERENTRY = @as(u32, 2);
pub const CAIF_REGISTRY = @as(u32, 4);
pub const CAIF_LOCAL = @as(u32, 8);
pub const CAIF_REGISTRYPARENT = @as(u32, 16);
pub const CR_IN_ENCODEANY = @as(u32, 255);
pub const CR_IN_ENCODEMASK = @as(u32, 255);
pub const CR_IN_FORMATANY = @as(u32, 0);
pub const CR_IN_PKCS10 = @as(u32, 256);
pub const CR_IN_KEYGEN = @as(u32, 512);
pub const CR_IN_PKCS7 = @as(u32, 768);
pub const CR_IN_CMC = @as(u32, 1024);
pub const CR_IN_CHALLENGERESPONSE = @as(u32, 1280);
pub const CR_IN_SIGNEDCERTIFICATETIMESTAMPLIST = @as(u32, 1536);
pub const CR_IN_FORMATMASK = @as(u32, 65280);
pub const CR_IN_SCEP = @as(u32, 65536);
pub const CR_IN_RPC = @as(u32, 131072);
pub const CR_IN_HTTP = @as(u32, 196608);
pub const CR_IN_FULLRESPONSE = @as(u32, 262144);
pub const CR_IN_CRLS = @as(u32, 524288);
pub const CR_IN_MACHINE = @as(u32, 1048576);
pub const CR_IN_ROBO = @as(u32, 2097152);
pub const CR_IN_CLIENTIDNONE = @as(u32, 4194304);
pub const CR_IN_CONNECTONLY = @as(u32, 8388608);
pub const CR_IN_RETURNCHALLENGE = @as(u32, 16777216);
pub const CR_IN_SCEPPOST = @as(u32, 33554432);
pub const CR_IN_CERTIFICATETRANSPARENCY = @as(u32, 67108864);
pub const CC_UIPICKCONFIGSKIPLOCALCA = @as(u32, 5);
pub const CR_DISP_REVOKED = @as(u32, 6);
pub const CR_OUT_BASE64REQUESTHEADER = @as(u32, 3);
pub const CR_OUT_HEX = @as(u32, 4);
pub const CR_OUT_HEXASCII = @as(u32, 5);
pub const CR_OUT_BASE64X509CRLHEADER = @as(u32, 9);
pub const CR_OUT_HEXADDR = @as(u32, 10);
pub const CR_OUT_HEXASCIIADDR = @as(u32, 11);
pub const CR_OUT_HEXRAW = @as(u32, 12);
pub const CR_OUT_ENCODEMASK = @as(u32, 255);
pub const CR_OUT_CHAIN = @as(u32, 256);
pub const CR_OUT_CRLS = @as(u32, 512);
pub const CR_OUT_NOCRLF = @as(u32, 1073741824);
pub const CR_OUT_NOCR = @as(u32, 2147483648);
pub const CR_GEMT_DEFAULT = @as(u32, 0);
pub const CR_GEMT_HRESULT_STRING = @as(u32, 1);
pub const CR_GEMT_HTTP_ERROR = @as(u32, 2);
pub const CR_PROP_NONE = @as(u32, 0);
pub const CR_PROP_FILEVERSION = @as(u32, 1);
pub const CR_PROP_PRODUCTVERSION = @as(u32, 2);
pub const CR_PROP_EXITCOUNT = @as(u32, 3);
pub const CR_PROP_EXITDESCRIPTION = @as(u32, 4);
pub const CR_PROP_POLICYDESCRIPTION = @as(u32, 5);
pub const CR_PROP_CANAME = @as(u32, 6);
pub const CR_PROP_SANITIZEDCANAME = @as(u32, 7);
pub const CR_PROP_SHAREDFOLDER = @as(u32, 8);
pub const CR_PROP_PARENTCA = @as(u32, 9);
pub const CR_PROP_CATYPE = @as(u32, 10);
pub const CR_PROP_CASIGCERTCOUNT = @as(u32, 11);
pub const CR_PROP_CASIGCERT = @as(u32, 12);
pub const CR_PROP_CASIGCERTCHAIN = @as(u32, 13);
pub const CR_PROP_CAXCHGCERTCOUNT = @as(u32, 14);
pub const CR_PROP_CAXCHGCERT = @as(u32, 15);
pub const CR_PROP_CAXCHGCERTCHAIN = @as(u32, 16);
pub const CR_PROP_BASECRL = @as(u32, 17);
pub const CR_PROP_DELTACRL = @as(u32, 18);
pub const CR_PROP_CACERTSTATE = @as(u32, 19);
pub const CR_PROP_CRLSTATE = @as(u32, 20);
pub const CR_PROP_CAPROPIDMAX = @as(u32, 21);
pub const CR_PROP_DNSNAME = @as(u32, 22);
pub const CR_PROP_ROLESEPARATIONENABLED = @as(u32, 23);
pub const CR_PROP_KRACERTUSEDCOUNT = @as(u32, 24);
pub const CR_PROP_KRACERTCOUNT = @as(u32, 25);
pub const CR_PROP_KRACERT = @as(u32, 26);
pub const CR_PROP_KRACERTSTATE = @as(u32, 27);
pub const CR_PROP_ADVANCEDSERVER = @as(u32, 28);
pub const CR_PROP_TEMPLATES = @as(u32, 29);
pub const CR_PROP_BASECRLPUBLISHSTATUS = @as(u32, 30);
pub const CR_PROP_DELTACRLPUBLISHSTATUS = @as(u32, 31);
pub const CR_PROP_CASIGCERTCRLCHAIN = @as(u32, 32);
pub const CR_PROP_CAXCHGCERTCRLCHAIN = @as(u32, 33);
pub const CR_PROP_CACERTSTATUSCODE = @as(u32, 34);
pub const CR_PROP_CAFORWARDCROSSCERT = @as(u32, 35);
pub const CR_PROP_CABACKWARDCROSSCERT = @as(u32, 36);
pub const CR_PROP_CAFORWARDCROSSCERTSTATE = @as(u32, 37);
pub const CR_PROP_CABACKWARDCROSSCERTSTATE = @as(u32, 38);
pub const CR_PROP_CACERTVERSION = @as(u32, 39);
pub const CR_PROP_SANITIZEDCASHORTNAME = @as(u32, 40);
pub const CR_PROP_CERTCDPURLS = @as(u32, 41);
pub const CR_PROP_CERTAIAURLS = @as(u32, 42);
pub const CR_PROP_CERTAIAOCSPURLS = @as(u32, 43);
pub const CR_PROP_LOCALENAME = @as(u32, 44);
pub const CR_PROP_SUBJECTTEMPLATE_OIDS = @as(u32, 45);
pub const CR_PROP_SCEPSERVERCERTS = @as(u32, 1000);
pub const CR_PROP_SCEPSERVERCAPABILITIES = @as(u32, 1001);
pub const CR_PROP_SCEPSERVERCERTSCHAIN = @as(u32, 1002);
pub const FR_PROP_CLAIMCHALLENGE = @as(u32, 22);
pub const CRYTPDLG_FLAGS_MASK = @as(u32, 4278190080);
pub const CRYPTDLG_REVOCATION_DEFAULT = @as(u32, 0);
pub const CRYPTDLG_REVOCATION_ONLINE = @as(u32, 2147483648);
pub const CRYPTDLG_REVOCATION_CACHE = @as(u32, 1073741824);
pub const CRYPTDLG_REVOCATION_NONE = @as(u32, 536870912);
pub const CRYPTDLG_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 268435456);
pub const CRYPTDLG_DISABLE_AIA = @as(u32, 134217728);
pub const CRYPTDLG_POLICY_MASK = @as(u32, 65535);
pub const POLICY_IGNORE_NON_CRITICAL_BC = @as(u32, 1);
pub const CRYPTDLG_ACTION_MASK = @as(u32, 4294901760);
pub const ACTION_REVOCATION_DEFAULT_ONLINE = @as(u32, 65536);
pub const ACTION_REVOCATION_DEFAULT_CACHE = @as(u32, 131072);
pub const CERT_DISPWELL_SELECT = @as(u32, 1);
pub const CERT_DISPWELL_TRUST_CA_CERT = @as(u32, 2);
pub const CERT_DISPWELL_TRUST_LEAF_CERT = @as(u32, 3);
pub const CERT_DISPWELL_TRUST_ADD_CA_CERT = @as(u32, 4);
pub const CERT_DISPWELL_TRUST_ADD_LEAF_CERT = @as(u32, 5);
pub const CERT_DISPWELL_DISTRUST_CA_CERT = @as(u32, 6);
pub const CERT_DISPWELL_DISTRUST_LEAF_CERT = @as(u32, 7);
pub const CERT_DISPWELL_DISTRUST_ADD_CA_CERT = @as(u32, 8);
pub const CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT = @as(u32, 9);
pub const CSS_SELECTCERT_MASK = @as(u32, 16777215);
pub const SELCERT_PROPERTIES = @as(u32, 100);
pub const SELCERT_FINEPRINT = @as(u32, 101);
pub const SELCERT_CERTLIST = @as(u32, 102);
pub const SELCERT_ISSUED_TO = @as(u32, 103);
pub const SELCERT_VALIDITY = @as(u32, 104);
pub const SELCERT_ALGORITHM = @as(u32, 105);
pub const SELCERT_SERIAL_NUM = @as(u32, 106);
pub const SELCERT_THUMBPRINT = @as(u32, 107);
pub const CM_VIEWFLAGS_MASK = @as(u32, 16777215);
pub const CERTVIEW_CRYPTUI_LPARAM = @as(u32, 8388608);
pub const CERT_FILTER_OP_EXISTS = @as(u32, 1);
pub const CERT_FILTER_OP_NOT_EXISTS = @as(u32, 2);
pub const CERT_FILTER_OP_EQUALITY = @as(u32, 3);
pub const CERT_FILTER_INCLUDE_V1_CERTS = @as(u32, 1);
pub const CERT_FILTER_VALID_TIME_RANGE = @as(u32, 2);
pub const CERT_FILTER_VALID_SIGNATURE = @as(u32, 4);
pub const CERT_FILTER_LEAF_CERTS_ONLY = @as(u32, 8);
pub const CERT_FILTER_ISSUER_CERTS_ONLY = @as(u32, 16);
pub const CERT_FILTER_KEY_EXISTS = @as(u32, 32);
pub const CERT_VALIDITY_BEFORE_START = @as(u32, 1);
pub const CERT_VALIDITY_AFTER_END = @as(u32, 2);
pub const CERT_VALIDITY_SIGNATURE_FAILS = @as(u32, 4);
pub const CERT_VALIDITY_CERTIFICATE_REVOKED = @as(u32, 8);
pub const CERT_VALIDITY_KEY_USAGE_EXT_FAILURE = @as(u32, 16);
pub const CERT_VALIDITY_EXTENDED_USAGE_FAILURE = @as(u32, 32);
pub const CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE = @as(u32, 64);
pub const CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION = @as(u32, 128);
pub const CERT_VALIDITY_ISSUER_INVALID = @as(u32, 256);
pub const CERT_VALIDITY_OTHER_EXTENSION_FAILURE = @as(u32, 512);
pub const CERT_VALIDITY_PERIOD_NESTING_FAILURE = @as(u32, 1024);
pub const CERT_VALIDITY_OTHER_ERROR = @as(u32, 2048);
pub const CERT_VALIDITY_ISSUER_DISTRUST = @as(u32, 33554432);
pub const CERT_VALIDITY_EXPLICITLY_DISTRUSTED = @as(u32, 16777216);
pub const CERT_VALIDITY_NO_ISSUER_CERT_FOUND = @as(u32, 268435456);
pub const CERT_VALIDITY_NO_CRL_FOUND = @as(u32, 536870912);
pub const CERT_VALIDITY_CRL_OUT_OF_DATE = @as(u32, 1073741824);
pub const CERT_VALIDITY_NO_TRUST_DATA = @as(u32, 2147483648);
pub const CERT_VALIDITY_MASK_TRUST = @as(u32, 4294901760);
pub const CERT_VALIDITY_MASK_VALIDITY = @as(u32, 65535);
pub const CERT_TRUST_MASK = @as(u32, 16777215);
pub const CERT_TRUST_DO_FULL_SEARCH = @as(u32, 1);
pub const CERT_TRUST_PERMIT_MISSING_CRLS = @as(u32, 2);
pub const CERT_TRUST_DO_FULL_TRUST = @as(u32, 5);
pub const CERT_CREDENTIAL_PROVIDER_ID = @as(i32, -509);
pub const CRYPTUI_SELECT_ISSUEDTO_COLUMN = @as(u64, 1);
pub const CRYPTUI_SELECT_ISSUEDBY_COLUMN = @as(u64, 2);
pub const CRYPTUI_SELECT_INTENDEDUSE_COLUMN = @as(u64, 4);
pub const CRYPTUI_SELECT_FRIENDLYNAME_COLUMN = @as(u64, 8);
pub const CRYPTUI_SELECT_LOCATION_COLUMN = @as(u64, 16);
pub const CRYPTUI_SELECT_EXPIRATION_COLUMN = @as(u64, 32);
pub const CRYPTUI_CERT_MGR_TAB_MASK = @as(u32, 15);
pub const CRYPTUI_CERT_MGR_PUBLISHER_TAB = @as(u32, 4);
pub const CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG = @as(u32, 32768);
pub const CRYPTUI_WIZ_DIGITAL_SIGN_EXCLUDE_PAGE_HASHES = @as(u32, 2);
pub const CRYPTUI_WIZ_DIGITAL_SIGN_INCLUDE_PAGE_HASHES = @as(u32, 4);
pub const CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE = @as(u32, 5);
pub const CSBACKUP_TYPE_MASK = @as(u32, 3);
pub const CSRESTORE_TYPE_FULL = @as(u32, 1);
pub const CSRESTORE_TYPE_ONLINE = @as(u32, 2);
pub const CSRESTORE_TYPE_CATCHUP = @as(u32, 4);
pub const CSRESTORE_TYPE_MASK = @as(u32, 5);
pub const CSBACKUP_DISABLE_INCREMENTAL = @as(u32, 4294967295);
pub const CSBFT_DIRECTORY = @as(u32, 128);
pub const CSBFT_DATABASE_DIRECTORY = @as(u32, 64);
pub const CSBFT_LOG_DIRECTORY = @as(u32, 32);
pub const CSCONTROL_SHUTDOWN = @as(u64, 1);
pub const CSCONTROL_SUSPEND = @as(u64, 2);
pub const CSCONTROL_RESTART = @as(u64, 3);
pub const CRYPTCAT_MAX_MEMBERTAG = @as(u32, 64);
pub const CRYPTCAT_MEMBER_SORTED = @as(u32, 1073741824);
pub const CRYPTCAT_ATTR_AUTHENTICATED = @as(u32, 268435456);
pub const CRYPTCAT_ATTR_UNAUTHENTICATED = @as(u32, 536870912);
pub const CRYPTCAT_ATTR_NAMEASCII = @as(u32, 1);
pub const CRYPTCAT_ATTR_NAMEOBJID = @as(u32, 2);
pub const CRYPTCAT_ATTR_DATAASCII = @as(u32, 65536);
pub const CRYPTCAT_ATTR_DATABASE64 = @as(u32, 131072);
pub const CRYPTCAT_ATTR_DATAREPLACE = @as(u32, 262144);
pub const CRYPTCAT_ATTR_NO_AUTO_COMPAT_ENTRY = @as(u32, 16777216);
pub const CRYPTCAT_E_AREA_HEADER = @as(u32, 0);
pub const CRYPTCAT_E_AREA_MEMBER = @as(u32, 65536);
pub const CRYPTCAT_E_AREA_ATTRIBUTE = @as(u32, 131072);
pub const CRYPTCAT_E_CDF_UNSUPPORTED = @as(u32, 1);
pub const CRYPTCAT_E_CDF_DUPLICATE = @as(u32, 2);
pub const CRYPTCAT_E_CDF_TAGNOTFOUND = @as(u32, 4);
pub const CRYPTCAT_E_CDF_MEMBER_FILE_PATH = @as(u32, 65537);
pub const CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA = @as(u32, 65538);
pub const CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND = @as(u32, 65540);
pub const CRYPTCAT_E_CDF_BAD_GUID_CONV = @as(u32, 131073);
pub const CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES = @as(u32, 131074);
pub const CRYPTCAT_E_CDF_ATTR_TYPECOMBO = @as(u32, 131076);
pub const CRYPTCAT_ADDCATALOG_NONE = @as(u32, 0);
pub const CRYPTCAT_ADDCATALOG_HARDLINK = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_RESERVED = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_STRONG = @as(u32, 8);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = @as(u32, 16);
pub const CRYPTPROTECT_UI_FORBIDDEN = @as(u32, 1);
pub const CRYPTPROTECT_LOCAL_MACHINE = @as(u32, 4);
pub const CRYPTPROTECT_CRED_SYNC = @as(u32, 8);
pub const CRYPTPROTECT_AUDIT = @as(u32, 16);
pub const CRYPTPROTECT_NO_RECOVERY = @as(u32, 32);
pub const CRYPTPROTECT_VERIFY_PROTECTION = @as(u32, 64);
pub const CRYPTPROTECT_CRED_REGENERATE = @as(u32, 128);
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = @as(u32, 268435455);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = @as(u32, 4294967295);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = @as(u32, 16);
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = @as(u32, 0);
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = @as(u32, 1);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = @as(u32, 2);
pub const MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE = @as(u32, 65536);
pub const MSSIP_FLAGS_USE_CATALOG = @as(u32, 131072);
pub const MSSIP_FLAGS_MULTI_HASH = @as(u32, 262144);
pub const SPC_INC_PE_RESOURCES_FLAG = @as(u32, 128);
pub const SPC_INC_PE_DEBUG_INFO_FLAG = @as(u32, 64);
pub const SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG = @as(u32, 32);
pub const SPC_EXC_PE_PAGE_HASHES_FLAG = @as(u32, 16);
pub const SPC_INC_PE_PAGE_HASHES_FLAG = @as(u32, 256);
pub const SPC_DIGEST_GENERATE_FLAG = @as(u32, 512);
pub const SPC_DIGEST_SIGN_FLAG = @as(u32, 1024);
pub const SPC_DIGEST_SIGN_EX_FLAG = @as(u32, 16384);
pub const SPC_RELAXED_PE_MARKER_CHECK = @as(u32, 2048);
pub const SPC_MARKER_CHECK_SKIP_SIP_INDIRECT_DATA_FLAG = @as(u32, 1);
pub const SIP_CAP_SET_VERSION_2 = @as(u32, 2);
pub const SIP_CAP_SET_VERSION_3 = @as(u32, 3);
pub const SIP_CAP_SET_CUR_VER = @as(u32, 3);
pub const SIP_CAP_FLAG_SEALING = @as(u32, 1);
pub const SIP_MAX_MAGIC_NUMBER = @as(u32, 4);
pub const WINTRUST_MAX_HEADER_BYTES_TO_MAP_DEFAULT = @as(u32, 10485760);
pub const WINTRUST_MAX_HASH_BYTES_TO_MAP_DEFAULT = @as(u32, 1048576);
pub const WSS_VERIFY_SEALING = @as(u32, 4);
pub const WSS_INPUT_FLAG_MASK = @as(u32, 7);
pub const WSS_OUT_SEALING_STATUS_VERIFIED = @as(u32, 2147483648);
pub const WSS_OUT_HAS_SEALING_INTENT = @as(u32, 1073741824);
pub const WSS_OUT_FILE_SUPPORTS_SEAL = @as(u32, 536870912);
pub const WSS_OUTPUT_FLAG_MASK = @as(u32, 3758096384);
pub const TRUSTERROR_STEP_WVTPARAMS = @as(u32, 0);
pub const TRUSTERROR_STEP_FILEIO = @as(u32, 2);
pub const TRUSTERROR_STEP_SIP = @as(u32, 3);
pub const TRUSTERROR_STEP_SIPSUBJINFO = @as(u32, 5);
pub const TRUSTERROR_STEP_CATALOGFILE = @as(u32, 6);
pub const TRUSTERROR_STEP_CERTSTORE = @as(u32, 7);
pub const TRUSTERROR_STEP_MESSAGE = @as(u32, 8);
pub const TRUSTERROR_STEP_MSG_SIGNERCOUNT = @as(u32, 9);
pub const TRUSTERROR_STEP_MSG_INNERCNTTYPE = @as(u32, 10);
pub const TRUSTERROR_STEP_MSG_INNERCNT = @as(u32, 11);
pub const TRUSTERROR_STEP_MSG_STORE = @as(u32, 12);
pub const TRUSTERROR_STEP_MSG_SIGNERINFO = @as(u32, 13);
pub const TRUSTERROR_STEP_MSG_SIGNERCERT = @as(u32, 14);
pub const TRUSTERROR_STEP_MSG_CERTCHAIN = @as(u32, 15);
pub const TRUSTERROR_STEP_MSG_COUNTERSIGINFO = @as(u32, 16);
pub const TRUSTERROR_STEP_MSG_COUNTERSIGCERT = @as(u32, 17);
pub const TRUSTERROR_STEP_VERIFY_MSGHASH = @as(u32, 18);
pub const TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA = @as(u32, 19);
pub const TRUSTERROR_STEP_FINAL_WVTINIT = @as(u32, 30);
pub const TRUSTERROR_STEP_FINAL_INITPROV = @as(u32, 31);
pub const TRUSTERROR_STEP_FINAL_OBJPROV = @as(u32, 32);
pub const TRUSTERROR_STEP_FINAL_SIGPROV = @as(u32, 33);
pub const TRUSTERROR_STEP_FINAL_CERTPROV = @as(u32, 34);
pub const TRUSTERROR_STEP_FINAL_CERTCHKPROV = @as(u32, 35);
pub const TRUSTERROR_STEP_FINAL_POLICYPROV = @as(u32, 36);
pub const TRUSTERROR_STEP_FINAL_UIPROV = @as(u32, 37);
pub const TRUSTERROR_MAX_STEPS = @as(u32, 38);
pub const WSS_OBJTRUST_SUPPORT = @as(u32, 1);
pub const WSS_SIGTRUST_SUPPORT = @as(u32, 2);
pub const WSS_CERTTRUST_SUPPORT = @as(u32, 4);
pub const WT_CURRENT_VERSION = @as(u32, 512);
pub const WT_ADD_ACTION_ID_RET_RESULT_FLAG = @as(u32, 1);
pub const SPC_UUID_LENGTH = @as(u32, 16);
pub const WIN_CERT_REVISION_1_0 = @as(u32, 256);
pub const WIN_CERT_REVISION_2_0 = @as(u32, 512);
pub const WIN_CERT_TYPE_X509 = @as(u32, 1);
pub const WIN_CERT_TYPE_PKCS_SIGNED_DATA = @as(u32, 2);
pub const WIN_CERT_TYPE_RESERVED_1 = @as(u32, 3);
pub const WIN_CERT_TYPE_TS_STACK_SIGNED = @as(u32, 4);
pub const WT_TRUSTDBDIALOG_NO_UI_FLAG = @as(u32, 1);
pub const WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG = @as(u32, 2);
pub const WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG = @as(u32, 256);
pub const WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG = @as(u32, 512);
pub const CRYPT_ENUM_ALL_PROVIDERS = @as(u32, 1);
pub const XEPR_ENUM_FIRST = @as(i32, -1);
pub const XEPR_DATE = @as(u32, 5);
pub const XEPR_TEMPLATENAME = @as(u32, 6);
pub const XEPR_VERSION = @as(u32, 7);
pub const XEPR_V1TEMPLATENAME = @as(u32, 9);
pub const XEPR_V2TEMPLATEOID = @as(u32, 16);
pub const XEKL_KEYSIZE_DEFAULT = @as(u32, 4);
pub const XECP_STRING_PROPERTY = @as(u32, 1);
pub const XECI_DISABLE = @as(u32, 0);
pub const XECI_XENROLL = @as(u32, 1);
pub const XECI_AUTOENROLL = @as(u32, 2);
pub const XECI_REQWIZARD = @as(u32, 3);
pub const XECI_CERTREQ = @as(u32, 4);
pub const CA_DISP_INCOMPLETE = @as(u32, 0);
pub const CA_DISP_ERROR = @as(u32, 1);
pub const CA_DISP_REVOKED = @as(u32, 2);
pub const CA_DISP_VALID = @as(u32, 3);
pub const CA_DISP_INVALID = @as(u32, 4);
pub const CA_DISP_UNDER_SUBMISSION = @as(u32, 5);
pub const KRA_DISP_EXPIRED = @as(u32, 0);
pub const KRA_DISP_NOTFOUND = @as(u32, 1);
pub const KRA_DISP_REVOKED = @as(u32, 2);
pub const KRA_DISP_VALID = @as(u32, 3);
pub const KRA_DISP_INVALID = @as(u32, 4);
pub const KRA_DISP_UNTRUSTED = @as(u32, 5);
pub const KRA_DISP_NOTLOADED = @as(u32, 6);
pub const CA_ACCESS_MASKROLES = @as(u32, 255);
pub const CA_CRL_BASE = @as(u32, 1);
pub const CA_CRL_DELTA = @as(u32, 2);
pub const CA_CRL_REPUBLISH = @as(u32, 16);
pub const ICF_ALLOWFOREIGN = @as(u32, 65536);
pub const ICF_EXISTINGROW = @as(u32, 131072);
pub const IKF_OVERWRITE = @as(u32, 65536);
pub const EAN_NAMEOBJECTID = @as(u32, 2147483648);
pub const EANR_SUPPRESS_IA5CONVERSION = @as(u32, 2147483648);
pub const EXITEVENT_INVALID = @as(u32, 0);
pub const EXITEVENT_STARTUP = @as(u32, 128);
pub const EXITEVENT_CERTIMPORTED = @as(u32, 512);
pub const CMM_REFRESHONLY = @as(u32, 1);
pub const CMM_READONLY = @as(u32, 2);
pub const ENUMEXT_OBJECTID = @as(u32, 1);
pub const CV_OUT_HEXRAW = @as(u32, 12);
pub const CV_OUT_ENCODEMASK = @as(u32, 255);
pub const CV_OUT_NOCRLF = @as(u32, 1073741824);
pub const CV_OUT_NOCR = @as(u32, 2147483648);
pub const CVR_SEEK_NONE = @as(u32, 0);
pub const CVR_SEEK_MASK = @as(u32, 255);
pub const CVR_SEEK_NODELTA = @as(u32, 4096);
pub const CVR_SORT_NONE = @as(u32, 0);
pub const CVR_SORT_ASCEND = @as(u32, 1);
pub const CVR_SORT_DESCEND = @as(u32, 2);
pub const CV_COLUMN_EXTENSION_DEFAULT = @as(i32, -4);
pub const CV_COLUMN_ATTRIBUTE_DEFAULT = @as(i32, -5);
pub const CV_COLUMN_CRL_DEFAULT = @as(i32, -6);
pub const CV_COLUMN_LOG_REVOKED_DEFAULT = @as(i32, -7);
pub const CVRC_TABLE_MASK = @as(u32, 61440);
pub const CVRC_TABLE_SHIFT = @as(u32, 12);
pub const cNodetypeSceTemplateServices = Guid.initString("24a7f717-1f0c-11d1-affb-00c04fb984f9");
pub const cNodetypeSceAnalysisServices = Guid.initString("678050c7-1ff8-11d1-affb-00c04fb984f9");
pub const cNodetypeSceEventLog = Guid.initString("2ce06698-4bf3-11d1-8c30-00c04fb984f9");
pub const SCESTATUS_SUCCESS = @as(i32, 0);
pub const SCESTATUS_INVALID_PARAMETER = @as(i32, 1);
pub const SCESTATUS_RECORD_NOT_FOUND = @as(i32, 2);
pub const SCESTATUS_INVALID_DATA = @as(i32, 3);
pub const SCESTATUS_OBJECT_EXIST = @as(i32, 4);
pub const SCESTATUS_BUFFER_TOO_SMALL = @as(i32, 5);
pub const SCESTATUS_PROFILE_NOT_FOUND = @as(i32, 6);
pub const SCESTATUS_BAD_FORMAT = @as(i32, 7);
pub const SCESTATUS_NOT_ENOUGH_RESOURCE = @as(i32, 8);
pub const SCESTATUS_ACCESS_DENIED = @as(i32, 9);
pub const SCESTATUS_CANT_DELETE = @as(i32, 10);
pub const SCESTATUS_PREFIX_OVERFLOW = @as(i32, 11);
pub const SCESTATUS_OTHER_ERROR = @as(i32, 12);
pub const SCESTATUS_ALREADY_RUNNING = @as(i32, 13);
pub const SCESTATUS_SERVICE_NOT_SUPPORT = @as(i32, 14);
pub const SCESTATUS_MOD_NOT_FOUND = @as(i32, 15);
pub const SCESTATUS_EXCEPTION_IN_SERVER = @as(i32, 16);
pub const SCESTATUS_NO_TEMPLATE_GIVEN = @as(i32, 17);
pub const SCESTATUS_NO_MAPPING = @as(i32, 18);
pub const SCESTATUS_TRUST_FAIL = @as(i32, 19);
pub const SCESVC_ENUMERATION_MAX = @as(i32, 100);
pub const SAFER_SCOPEID_MACHINE = @as(u32, 1);
pub const SAFER_SCOPEID_USER = @as(u32, 2);
pub const SAFER_LEVELID_FULLYTRUSTED = @as(u32, 262144);
pub const SAFER_LEVELID_NORMALUSER = @as(u32, 131072);
pub const SAFER_LEVELID_CONSTRAINED = @as(u32, 65536);
pub const SAFER_LEVELID_UNTRUSTED = @as(u32, 4096);
pub const SAFER_LEVELID_DISALLOWED = @as(u32, 0);
pub const SAFER_LEVEL_OPEN = @as(u32, 1);
pub const SAFER_MAX_FRIENDLYNAME_SIZE = @as(u32, 256);
pub const SAFER_MAX_DESCRIPTION_SIZE = @as(u32, 256);
pub const SAFER_MAX_HASH_SIZE = @as(u32, 64);
pub const SAFER_CRITERIA_IMAGEPATH = @as(u32, 1);
pub const SAFER_CRITERIA_NOSIGNEDHASH = @as(u32, 2);
pub const SAFER_CRITERIA_IMAGEHASH = @as(u32, 4);
pub const SAFER_CRITERIA_AUTHENTICODE = @as(u32, 8);
pub const SAFER_CRITERIA_URLZONE = @as(u32, 16);
pub const SAFER_CRITERIA_APPX_PACKAGE = @as(u32, 32);
pub const SAFER_CRITERIA_IMAGEPATH_NT = @as(u32, 4096);
pub const SAFER_POLICY_JOBID_MASK = @as(u32, 4278190080);
pub const SAFER_POLICY_JOBID_CONSTRAINED = @as(u32, 67108864);
pub const SAFER_POLICY_JOBID_UNTRUSTED = @as(u32, 50331648);
pub const SAFER_POLICY_ONLY_EXES = @as(u32, 65536);
pub const SAFER_POLICY_SANDBOX_INERT = @as(u32, 131072);
pub const SAFER_POLICY_HASH_DUPLICATE = @as(u32, 262144);
pub const SAFER_POLICY_ONLY_AUDIT = @as(u32, 4096);
pub const SAFER_POLICY_BLOCK_CLIENT_UI = @as(u32, 8192);
pub const SAFER_POLICY_UIFLAGS_MASK = @as(u32, 255);
pub const SAFER_POLICY_UIFLAGS_INFORMATION_PROMPT = @as(u32, 1);
pub const SAFER_POLICY_UIFLAGS_OPTION_PROMPT = @as(u32, 2);
pub const SAFER_POLICY_UIFLAGS_HIDDEN = @as(u32, 4);
pub const SL_SYSTEM_STATE_REBOOT_POLICY_FOUND = @as(u32, 1);
pub const SL_SYSTEM_STATE_TAMPERED = @as(u32, 2);
pub const SL_REARM_REBOOT_REQUIRED = @as(u32, 1);
pub const SPP_MIGRATION_GATHER_MIGRATABLE_APPS = @as(u32, 1);
pub const SPP_MIGRATION_GATHER_ACTIVATED_WINDOWS_STATE = @as(u32, 2);
pub const SPP_MIGRATION_GATHER_ALL = @as(u32, 4294967295);
pub const wszCMM_PROP_NAME = "Name";
pub const wszCMM_PROP_DESCRIPTION = "Description";
pub const wszCMM_PROP_COPYRIGHT = "Copyright";
pub const wszCMM_PROP_FILEVER = "File Version";
pub const wszCMM_PROP_PRODUCTVER = "Product Version";
pub const wszCMM_PROP_DISPLAY_HWND = "HWND";
pub const wszCMM_PROP_ISMULTITHREADED = "IsMultiThreaded";

//--------------------------------------------------------------------------------
// Section: Types (2121)
//--------------------------------------------------------------------------------
pub const PLSA_AP_CALL_PACKAGE_UNTRUSTED = fn(
    ClientRequest: **c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SEC_THREAD_START = fn(
    lpThreadParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TOKEN_ACCESS_MASK = extern enum(u32) {
    DELETE = 65536,
    READ_CONTROL = 131072,
    WRITE_DAC = 262144,
    WRITE_OWNER = 524288,
    ACCESS_SYSTEM_SECURITY = 16777216,
    TOKEN_ASSIGN_PRIMARY = 1,
    TOKEN_DUPLICATE = 2,
    TOKEN_IMPERSONATE = 4,
    TOKEN_QUERY = 8,
    TOKEN_QUERY_SOURCE = 16,
    TOKEN_ADJUST_PRIVILEGES = 32,
    TOKEN_ADJUST_GROUPS = 64,
    TOKEN_ADJUST_DEFAULT = 128,
    TOKEN_ADJUST_SESSIONID = 256,
    TOKEN_ALL_ACCESS = 983295,
    _,
};
pub const DELETE = TOKEN_ACCESS_MASK.DELETE;
pub const READ_CONTROL = TOKEN_ACCESS_MASK.READ_CONTROL;
pub const WRITE_DAC = TOKEN_ACCESS_MASK.WRITE_DAC;
pub const WRITE_OWNER = TOKEN_ACCESS_MASK.WRITE_OWNER;
pub const ACCESS_SYSTEM_SECURITY = TOKEN_ACCESS_MASK.ACCESS_SYSTEM_SECURITY;
pub const TOKEN_ASSIGN_PRIMARY = TOKEN_ACCESS_MASK.TOKEN_ASSIGN_PRIMARY;
pub const TOKEN_DUPLICATE = TOKEN_ACCESS_MASK.TOKEN_DUPLICATE;
pub const TOKEN_IMPERSONATE = TOKEN_ACCESS_MASK.TOKEN_IMPERSONATE;
pub const TOKEN_QUERY = TOKEN_ACCESS_MASK.TOKEN_QUERY;
pub const TOKEN_QUERY_SOURCE = TOKEN_ACCESS_MASK.TOKEN_QUERY_SOURCE;
pub const TOKEN_ADJUST_PRIVILEGES = TOKEN_ACCESS_MASK.TOKEN_ADJUST_PRIVILEGES;
pub const TOKEN_ADJUST_GROUPS = TOKEN_ACCESS_MASK.TOKEN_ADJUST_GROUPS;
pub const TOKEN_ADJUST_DEFAULT = TOKEN_ACCESS_MASK.TOKEN_ADJUST_DEFAULT;
pub const TOKEN_ADJUST_SESSIONID = TOKEN_ACCESS_MASK.TOKEN_ADJUST_SESSIONID;
pub const TOKEN_ALL_ACCESS = TOKEN_ACCESS_MASK.TOKEN_ALL_ACCESS;

pub const GENERIC_MAPPING = extern struct {
    GenericRead: u32,
    GenericWrite: u32,
    GenericExecute: u32,
    GenericAll: u32,
};

pub const LUID_AND_ATTRIBUTES = extern struct {
    Luid: LUID,
    Attributes: TOKEN_PRIVILEGES_ATTRIBUTES,
};

pub const SID_IDENTIFIER_AUTHORITY = extern struct {
    Value: [6]u8,
};

pub const SID = extern struct {
    Revision: u8,
    SubAuthorityCount: u8,
    IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    SubAuthority: [1]u32,
};

pub const SID_NAME_USE = extern enum(i32) {
    User = 1,
    Group = 2,
    Domain = 3,
    Alias = 4,
    WellKnownGroup = 5,
    DeletedAccount = 6,
    Invalid = 7,
    Unknown = 8,
    Computer = 9,
    Label = 10,
    LogonSession = 11,
};
pub const SidTypeUser = SID_NAME_USE.User;
pub const SidTypeGroup = SID_NAME_USE.Group;
pub const SidTypeDomain = SID_NAME_USE.Domain;
pub const SidTypeAlias = SID_NAME_USE.Alias;
pub const SidTypeWellKnownGroup = SID_NAME_USE.WellKnownGroup;
pub const SidTypeDeletedAccount = SID_NAME_USE.DeletedAccount;
pub const SidTypeInvalid = SID_NAME_USE.Invalid;
pub const SidTypeUnknown = SID_NAME_USE.Unknown;
pub const SidTypeComputer = SID_NAME_USE.Computer;
pub const SidTypeLabel = SID_NAME_USE.Label;
pub const SidTypeLogonSession = SID_NAME_USE.LogonSession;

pub const SID_AND_ATTRIBUTES = extern struct {
    Sid: PSID,
    Attributes: u32,
};

pub const SID_AND_ATTRIBUTES_HASH = extern struct {
    SidCount: u32,
    SidAttr: *SID_AND_ATTRIBUTES,
    Hash: [32]usize,
};

pub const WELL_KNOWN_SID_TYPE = extern enum(i32) {
    NullSid = 0,
    WorldSid = 1,
    LocalSid = 2,
    CreatorOwnerSid = 3,
    CreatorGroupSid = 4,
    CreatorOwnerServerSid = 5,
    CreatorGroupServerSid = 6,
    NtAuthoritySid = 7,
    DialupSid = 8,
    NetworkSid = 9,
    BatchSid = 10,
    InteractiveSid = 11,
    ServiceSid = 12,
    AnonymousSid = 13,
    ProxySid = 14,
    EnterpriseControllersSid = 15,
    SelfSid = 16,
    AuthenticatedUserSid = 17,
    RestrictedCodeSid = 18,
    TerminalServerSid = 19,
    RemoteLogonIdSid = 20,
    LogonIdsSid = 21,
    LocalSystemSid = 22,
    LocalServiceSid = 23,
    NetworkServiceSid = 24,
    BuiltinDomainSid = 25,
    BuiltinAdministratorsSid = 26,
    BuiltinUsersSid = 27,
    BuiltinGuestsSid = 28,
    BuiltinPowerUsersSid = 29,
    BuiltinAccountOperatorsSid = 30,
    BuiltinSystemOperatorsSid = 31,
    BuiltinPrintOperatorsSid = 32,
    BuiltinBackupOperatorsSid = 33,
    BuiltinReplicatorSid = 34,
    BuiltinPreWindows2000CompatibleAccessSid = 35,
    BuiltinRemoteDesktopUsersSid = 36,
    BuiltinNetworkConfigurationOperatorsSid = 37,
    AccountAdministratorSid = 38,
    AccountGuestSid = 39,
    AccountKrbtgtSid = 40,
    AccountDomainAdminsSid = 41,
    AccountDomainUsersSid = 42,
    AccountDomainGuestsSid = 43,
    AccountComputersSid = 44,
    AccountControllersSid = 45,
    AccountCertAdminsSid = 46,
    AccountSchemaAdminsSid = 47,
    AccountEnterpriseAdminsSid = 48,
    AccountPolicyAdminsSid = 49,
    AccountRasAndIasServersSid = 50,
    NTLMAuthenticationSid = 51,
    DigestAuthenticationSid = 52,
    SChannelAuthenticationSid = 53,
    ThisOrganizationSid = 54,
    OtherOrganizationSid = 55,
    BuiltinIncomingForestTrustBuildersSid = 56,
    BuiltinPerfMonitoringUsersSid = 57,
    BuiltinPerfLoggingUsersSid = 58,
    BuiltinAuthorizationAccessSid = 59,
    BuiltinTerminalServerLicenseServersSid = 60,
    BuiltinDCOMUsersSid = 61,
    BuiltinIUsersSid = 62,
    IUserSid = 63,
    BuiltinCryptoOperatorsSid = 64,
    UntrustedLabelSid = 65,
    LowLabelSid = 66,
    MediumLabelSid = 67,
    HighLabelSid = 68,
    SystemLabelSid = 69,
    WriteRestrictedCodeSid = 70,
    CreatorOwnerRightsSid = 71,
    CacheablePrincipalsGroupSid = 72,
    NonCacheablePrincipalsGroupSid = 73,
    EnterpriseReadonlyControllersSid = 74,
    AccountReadonlyControllersSid = 75,
    BuiltinEventLogReadersGroup = 76,
    NewEnterpriseReadonlyControllersSid = 77,
    BuiltinCertSvcDComAccessGroup = 78,
    MediumPlusLabelSid = 79,
    LocalLogonSid = 80,
    ConsoleLogonSid = 81,
    ThisOrganizationCertificateSid = 82,
    ApplicationPackageAuthoritySid = 83,
    BuiltinAnyPackageSid = 84,
    CapabilityInternetClientSid = 85,
    CapabilityInternetClientServerSid = 86,
    CapabilityPrivateNetworkClientServerSid = 87,
    CapabilityPicturesLibrarySid = 88,
    CapabilityVideosLibrarySid = 89,
    CapabilityMusicLibrarySid = 90,
    CapabilityDocumentsLibrarySid = 91,
    CapabilitySharedUserCertificatesSid = 92,
    CapabilityEnterpriseAuthenticationSid = 93,
    CapabilityRemovableStorageSid = 94,
    BuiltinRDSRemoteAccessServersSid = 95,
    BuiltinRDSEndpointServersSid = 96,
    BuiltinRDSManagementServersSid = 97,
    UserModeDriversSid = 98,
    BuiltinHyperVAdminsSid = 99,
    AccountCloneableControllersSid = 100,
    BuiltinAccessControlAssistanceOperatorsSid = 101,
    BuiltinRemoteManagementUsersSid = 102,
    AuthenticationAuthorityAssertedSid = 103,
    AuthenticationServiceAssertedSid = 104,
    LocalAccountSid = 105,
    LocalAccountAndAdministratorSid = 106,
    AccountProtectedUsersSid = 107,
    CapabilityAppointmentsSid = 108,
    CapabilityContactsSid = 109,
    AccountDefaultSystemManagedSid = 110,
    BuiltinDefaultSystemManagedGroupSid = 111,
    BuiltinStorageReplicaAdminsSid = 112,
    AccountKeyAdminsSid = 113,
    AccountEnterpriseKeyAdminsSid = 114,
    AuthenticationKeyTrustSid = 115,
    AuthenticationKeyPropertyMFASid = 116,
    AuthenticationKeyPropertyAttestationSid = 117,
    AuthenticationFreshKeyAuthSid = 118,
    BuiltinDeviceOwnersSid = 119,
};
pub const WinNullSid = WELL_KNOWN_SID_TYPE.NullSid;
pub const WinWorldSid = WELL_KNOWN_SID_TYPE.WorldSid;
pub const WinLocalSid = WELL_KNOWN_SID_TYPE.LocalSid;
pub const WinCreatorOwnerSid = WELL_KNOWN_SID_TYPE.CreatorOwnerSid;
pub const WinCreatorGroupSid = WELL_KNOWN_SID_TYPE.CreatorGroupSid;
pub const WinCreatorOwnerServerSid = WELL_KNOWN_SID_TYPE.CreatorOwnerServerSid;
pub const WinCreatorGroupServerSid = WELL_KNOWN_SID_TYPE.CreatorGroupServerSid;
pub const WinNtAuthoritySid = WELL_KNOWN_SID_TYPE.NtAuthoritySid;
pub const WinDialupSid = WELL_KNOWN_SID_TYPE.DialupSid;
pub const WinNetworkSid = WELL_KNOWN_SID_TYPE.NetworkSid;
pub const WinBatchSid = WELL_KNOWN_SID_TYPE.BatchSid;
pub const WinInteractiveSid = WELL_KNOWN_SID_TYPE.InteractiveSid;
pub const WinServiceSid = WELL_KNOWN_SID_TYPE.ServiceSid;
pub const WinAnonymousSid = WELL_KNOWN_SID_TYPE.AnonymousSid;
pub const WinProxySid = WELL_KNOWN_SID_TYPE.ProxySid;
pub const WinEnterpriseControllersSid = WELL_KNOWN_SID_TYPE.EnterpriseControllersSid;
pub const WinSelfSid = WELL_KNOWN_SID_TYPE.SelfSid;
pub const WinAuthenticatedUserSid = WELL_KNOWN_SID_TYPE.AuthenticatedUserSid;
pub const WinRestrictedCodeSid = WELL_KNOWN_SID_TYPE.RestrictedCodeSid;
pub const WinTerminalServerSid = WELL_KNOWN_SID_TYPE.TerminalServerSid;
pub const WinRemoteLogonIdSid = WELL_KNOWN_SID_TYPE.RemoteLogonIdSid;
pub const WinLogonIdsSid = WELL_KNOWN_SID_TYPE.LogonIdsSid;
pub const WinLocalSystemSid = WELL_KNOWN_SID_TYPE.LocalSystemSid;
pub const WinLocalServiceSid = WELL_KNOWN_SID_TYPE.LocalServiceSid;
pub const WinNetworkServiceSid = WELL_KNOWN_SID_TYPE.NetworkServiceSid;
pub const WinBuiltinDomainSid = WELL_KNOWN_SID_TYPE.BuiltinDomainSid;
pub const WinBuiltinAdministratorsSid = WELL_KNOWN_SID_TYPE.BuiltinAdministratorsSid;
pub const WinBuiltinUsersSid = WELL_KNOWN_SID_TYPE.BuiltinUsersSid;
pub const WinBuiltinGuestsSid = WELL_KNOWN_SID_TYPE.BuiltinGuestsSid;
pub const WinBuiltinPowerUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPowerUsersSid;
pub const WinBuiltinAccountOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinAccountOperatorsSid;
pub const WinBuiltinSystemOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinSystemOperatorsSid;
pub const WinBuiltinPrintOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinPrintOperatorsSid;
pub const WinBuiltinBackupOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinBackupOperatorsSid;
pub const WinBuiltinReplicatorSid = WELL_KNOWN_SID_TYPE.BuiltinReplicatorSid;
pub const WinBuiltinPreWindows2000CompatibleAccessSid = WELL_KNOWN_SID_TYPE.BuiltinPreWindows2000CompatibleAccessSid;
pub const WinBuiltinRemoteDesktopUsersSid = WELL_KNOWN_SID_TYPE.BuiltinRemoteDesktopUsersSid;
pub const WinBuiltinNetworkConfigurationOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinNetworkConfigurationOperatorsSid;
pub const WinAccountAdministratorSid = WELL_KNOWN_SID_TYPE.AccountAdministratorSid;
pub const WinAccountGuestSid = WELL_KNOWN_SID_TYPE.AccountGuestSid;
pub const WinAccountKrbtgtSid = WELL_KNOWN_SID_TYPE.AccountKrbtgtSid;
pub const WinAccountDomainAdminsSid = WELL_KNOWN_SID_TYPE.AccountDomainAdminsSid;
pub const WinAccountDomainUsersSid = WELL_KNOWN_SID_TYPE.AccountDomainUsersSid;
pub const WinAccountDomainGuestsSid = WELL_KNOWN_SID_TYPE.AccountDomainGuestsSid;
pub const WinAccountComputersSid = WELL_KNOWN_SID_TYPE.AccountComputersSid;
pub const WinAccountControllersSid = WELL_KNOWN_SID_TYPE.AccountControllersSid;
pub const WinAccountCertAdminsSid = WELL_KNOWN_SID_TYPE.AccountCertAdminsSid;
pub const WinAccountSchemaAdminsSid = WELL_KNOWN_SID_TYPE.AccountSchemaAdminsSid;
pub const WinAccountEnterpriseAdminsSid = WELL_KNOWN_SID_TYPE.AccountEnterpriseAdminsSid;
pub const WinAccountPolicyAdminsSid = WELL_KNOWN_SID_TYPE.AccountPolicyAdminsSid;
pub const WinAccountRasAndIasServersSid = WELL_KNOWN_SID_TYPE.AccountRasAndIasServersSid;
pub const WinNTLMAuthenticationSid = WELL_KNOWN_SID_TYPE.NTLMAuthenticationSid;
pub const WinDigestAuthenticationSid = WELL_KNOWN_SID_TYPE.DigestAuthenticationSid;
pub const WinSChannelAuthenticationSid = WELL_KNOWN_SID_TYPE.SChannelAuthenticationSid;
pub const WinThisOrganizationSid = WELL_KNOWN_SID_TYPE.ThisOrganizationSid;
pub const WinOtherOrganizationSid = WELL_KNOWN_SID_TYPE.OtherOrganizationSid;
pub const WinBuiltinIncomingForestTrustBuildersSid = WELL_KNOWN_SID_TYPE.BuiltinIncomingForestTrustBuildersSid;
pub const WinBuiltinPerfMonitoringUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPerfMonitoringUsersSid;
pub const WinBuiltinPerfLoggingUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPerfLoggingUsersSid;
pub const WinBuiltinAuthorizationAccessSid = WELL_KNOWN_SID_TYPE.BuiltinAuthorizationAccessSid;
pub const WinBuiltinTerminalServerLicenseServersSid = WELL_KNOWN_SID_TYPE.BuiltinTerminalServerLicenseServersSid;
pub const WinBuiltinDCOMUsersSid = WELL_KNOWN_SID_TYPE.BuiltinDCOMUsersSid;
pub const WinBuiltinIUsersSid = WELL_KNOWN_SID_TYPE.BuiltinIUsersSid;
pub const WinIUserSid = WELL_KNOWN_SID_TYPE.IUserSid;
pub const WinBuiltinCryptoOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinCryptoOperatorsSid;
pub const WinUntrustedLabelSid = WELL_KNOWN_SID_TYPE.UntrustedLabelSid;
pub const WinLowLabelSid = WELL_KNOWN_SID_TYPE.LowLabelSid;
pub const WinMediumLabelSid = WELL_KNOWN_SID_TYPE.MediumLabelSid;
pub const WinHighLabelSid = WELL_KNOWN_SID_TYPE.HighLabelSid;
pub const WinSystemLabelSid = WELL_KNOWN_SID_TYPE.SystemLabelSid;
pub const WinWriteRestrictedCodeSid = WELL_KNOWN_SID_TYPE.WriteRestrictedCodeSid;
pub const WinCreatorOwnerRightsSid = WELL_KNOWN_SID_TYPE.CreatorOwnerRightsSid;
pub const WinCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.CacheablePrincipalsGroupSid;
pub const WinNonCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.NonCacheablePrincipalsGroupSid;
pub const WinEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.EnterpriseReadonlyControllersSid;
pub const WinAccountReadonlyControllersSid = WELL_KNOWN_SID_TYPE.AccountReadonlyControllersSid;
pub const WinBuiltinEventLogReadersGroup = WELL_KNOWN_SID_TYPE.BuiltinEventLogReadersGroup;
pub const WinNewEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.NewEnterpriseReadonlyControllersSid;
pub const WinBuiltinCertSvcDComAccessGroup = WELL_KNOWN_SID_TYPE.BuiltinCertSvcDComAccessGroup;
pub const WinMediumPlusLabelSid = WELL_KNOWN_SID_TYPE.MediumPlusLabelSid;
pub const WinLocalLogonSid = WELL_KNOWN_SID_TYPE.LocalLogonSid;
pub const WinConsoleLogonSid = WELL_KNOWN_SID_TYPE.ConsoleLogonSid;
pub const WinThisOrganizationCertificateSid = WELL_KNOWN_SID_TYPE.ThisOrganizationCertificateSid;
pub const WinApplicationPackageAuthoritySid = WELL_KNOWN_SID_TYPE.ApplicationPackageAuthoritySid;
pub const WinBuiltinAnyPackageSid = WELL_KNOWN_SID_TYPE.BuiltinAnyPackageSid;
pub const WinCapabilityInternetClientSid = WELL_KNOWN_SID_TYPE.CapabilityInternetClientSid;
pub const WinCapabilityInternetClientServerSid = WELL_KNOWN_SID_TYPE.CapabilityInternetClientServerSid;
pub const WinCapabilityPrivateNetworkClientServerSid = WELL_KNOWN_SID_TYPE.CapabilityPrivateNetworkClientServerSid;
pub const WinCapabilityPicturesLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityPicturesLibrarySid;
pub const WinCapabilityVideosLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityVideosLibrarySid;
pub const WinCapabilityMusicLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityMusicLibrarySid;
pub const WinCapabilityDocumentsLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityDocumentsLibrarySid;
pub const WinCapabilitySharedUserCertificatesSid = WELL_KNOWN_SID_TYPE.CapabilitySharedUserCertificatesSid;
pub const WinCapabilityEnterpriseAuthenticationSid = WELL_KNOWN_SID_TYPE.CapabilityEnterpriseAuthenticationSid;
pub const WinCapabilityRemovableStorageSid = WELL_KNOWN_SID_TYPE.CapabilityRemovableStorageSid;
pub const WinBuiltinRDSRemoteAccessServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSRemoteAccessServersSid;
pub const WinBuiltinRDSEndpointServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSEndpointServersSid;
pub const WinBuiltinRDSManagementServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSManagementServersSid;
pub const WinUserModeDriversSid = WELL_KNOWN_SID_TYPE.UserModeDriversSid;
pub const WinBuiltinHyperVAdminsSid = WELL_KNOWN_SID_TYPE.BuiltinHyperVAdminsSid;
pub const WinAccountCloneableControllersSid = WELL_KNOWN_SID_TYPE.AccountCloneableControllersSid;
pub const WinBuiltinAccessControlAssistanceOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinAccessControlAssistanceOperatorsSid;
pub const WinBuiltinRemoteManagementUsersSid = WELL_KNOWN_SID_TYPE.BuiltinRemoteManagementUsersSid;
pub const WinAuthenticationAuthorityAssertedSid = WELL_KNOWN_SID_TYPE.AuthenticationAuthorityAssertedSid;
pub const WinAuthenticationServiceAssertedSid = WELL_KNOWN_SID_TYPE.AuthenticationServiceAssertedSid;
pub const WinLocalAccountSid = WELL_KNOWN_SID_TYPE.LocalAccountSid;
pub const WinLocalAccountAndAdministratorSid = WELL_KNOWN_SID_TYPE.LocalAccountAndAdministratorSid;
pub const WinAccountProtectedUsersSid = WELL_KNOWN_SID_TYPE.AccountProtectedUsersSid;
pub const WinCapabilityAppointmentsSid = WELL_KNOWN_SID_TYPE.CapabilityAppointmentsSid;
pub const WinCapabilityContactsSid = WELL_KNOWN_SID_TYPE.CapabilityContactsSid;
pub const WinAccountDefaultSystemManagedSid = WELL_KNOWN_SID_TYPE.AccountDefaultSystemManagedSid;
pub const WinBuiltinDefaultSystemManagedGroupSid = WELL_KNOWN_SID_TYPE.BuiltinDefaultSystemManagedGroupSid;
pub const WinBuiltinStorageReplicaAdminsSid = WELL_KNOWN_SID_TYPE.BuiltinStorageReplicaAdminsSid;
pub const WinAccountKeyAdminsSid = WELL_KNOWN_SID_TYPE.AccountKeyAdminsSid;
pub const WinAccountEnterpriseKeyAdminsSid = WELL_KNOWN_SID_TYPE.AccountEnterpriseKeyAdminsSid;
pub const WinAuthenticationKeyTrustSid = WELL_KNOWN_SID_TYPE.AuthenticationKeyTrustSid;
pub const WinAuthenticationKeyPropertyMFASid = WELL_KNOWN_SID_TYPE.AuthenticationKeyPropertyMFASid;
pub const WinAuthenticationKeyPropertyAttestationSid = WELL_KNOWN_SID_TYPE.AuthenticationKeyPropertyAttestationSid;
pub const WinAuthenticationFreshKeyAuthSid = WELL_KNOWN_SID_TYPE.AuthenticationFreshKeyAuthSid;
pub const WinBuiltinDeviceOwnersSid = WELL_KNOWN_SID_TYPE.BuiltinDeviceOwnersSid;

pub const ACL = extern struct {
    AclRevision: u8,
    Sbz1: u8,
    AclSize: u16,
    AceCount: u16,
    Sbz2: u16,
};

pub const ACE_HEADER = extern struct {
    AceType: u8,
    AceFlags: u8,
    AceSize: u16,
};

pub const ACCESS_ALLOWED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_DENIED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ALARM_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_SCOPED_POLICY_ID_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_MANDATORY_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_DENIED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_ALARM_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: u32,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_DENIED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ALARM_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACL_INFORMATION_CLASS = extern enum(i32) {
    RevisionInformation = 1,
    SizeInformation = 2,
};
pub const AclRevisionInformation = ACL_INFORMATION_CLASS.RevisionInformation;
pub const AclSizeInformation = ACL_INFORMATION_CLASS.SizeInformation;

pub const ACL_REVISION_INFORMATION = extern struct {
    AclRevision: u32,
};

pub const ACL_SIZE_INFORMATION = extern struct {
    AceCount: u32,
    AclBytesInUse: u32,
    AclBytesFree: u32,
};

pub const SECURITY_DESCRIPTOR = extern struct {
    Revision: u8,
    Sbz1: u8,
    Control: u16,
    Owner: PSID,
    Group: PSID,
    Sacl: *ACL,
    Dacl: *ACL,
};

pub const OBJECT_TYPE_LIST = extern struct {
    Level: u16,
    Sbz: u16,
    ObjectType: *Guid,
};

pub const AUDIT_EVENT_TYPE = extern enum(i32) {
    ObjectAccess = 0,
    DirectoryServiceAccess = 1,
};
pub const AuditEventObjectAccess = AUDIT_EVENT_TYPE.ObjectAccess;
pub const AuditEventDirectoryServiceAccess = AUDIT_EVENT_TYPE.DirectoryServiceAccess;

pub const PRIVILEGE_SET = extern struct {
    PrivilegeCount: u32,
    Control: u32,
    Privilege: [1]LUID_AND_ATTRIBUTES,
};

pub const SECURITY_IMPERSONATION_LEVEL = extern enum(i32) {
    Anonymous = 0,
    Identification = 1,
    Impersonation = 2,
    Delegation = 3,
};
pub const SecurityAnonymous = SECURITY_IMPERSONATION_LEVEL.Anonymous;
pub const SecurityIdentification = SECURITY_IMPERSONATION_LEVEL.Identification;
pub const SecurityImpersonation = SECURITY_IMPERSONATION_LEVEL.Impersonation;
pub const SecurityDelegation = SECURITY_IMPERSONATION_LEVEL.Delegation;

pub const TOKEN_TYPE = extern enum(i32) {
    Primary = 1,
    Impersonation = 2,
};
pub const TokenPrimary = TOKEN_TYPE.Primary;
pub const TokenImpersonation = TOKEN_TYPE.Impersonation;

pub const TOKEN_ELEVATION_TYPE = extern enum(i32) {
    Default = 1,
    Full = 2,
    Limited = 3,
};
pub const TokenElevationTypeDefault = TOKEN_ELEVATION_TYPE.Default;
pub const TokenElevationTypeFull = TOKEN_ELEVATION_TYPE.Full;
pub const TokenElevationTypeLimited = TOKEN_ELEVATION_TYPE.Limited;

pub const TOKEN_INFORMATION_CLASS = extern enum(i32) {
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    TokenPrivateNameSpace = 42,
    TokenSingletonAttributes = 43,
    TokenBnoIsolation = 44,
    TokenChildProcessFlags = 45,
    TokenIsLessPrivilegedAppContainer = 46,
    TokenIsSandboxed = 47,
    TokenOriginatingProcessTrustLevel = 48,
    MaxTokenInfoClass = 49,
};
pub const TokenUser = TOKEN_INFORMATION_CLASS.TokenUser;
pub const TokenGroups = TOKEN_INFORMATION_CLASS.TokenGroups;
pub const TokenPrivileges = TOKEN_INFORMATION_CLASS.TokenPrivileges;
pub const TokenOwner = TOKEN_INFORMATION_CLASS.TokenOwner;
pub const TokenPrimaryGroup = TOKEN_INFORMATION_CLASS.TokenPrimaryGroup;
pub const TokenDefaultDacl = TOKEN_INFORMATION_CLASS.TokenDefaultDacl;
pub const TokenSource = TOKEN_INFORMATION_CLASS.TokenSource;
pub const TokenType = TOKEN_INFORMATION_CLASS.TokenType;
pub const TokenImpersonationLevel = TOKEN_INFORMATION_CLASS.TokenImpersonationLevel;
pub const TokenStatistics = TOKEN_INFORMATION_CLASS.TokenStatistics;
pub const TokenRestrictedSids = TOKEN_INFORMATION_CLASS.TokenRestrictedSids;
pub const TokenSessionId = TOKEN_INFORMATION_CLASS.TokenSessionId;
pub const TokenGroupsAndPrivileges = TOKEN_INFORMATION_CLASS.TokenGroupsAndPrivileges;
pub const TokenSessionReference = TOKEN_INFORMATION_CLASS.TokenSessionReference;
pub const TokenSandBoxInert = TOKEN_INFORMATION_CLASS.TokenSandBoxInert;
pub const TokenAuditPolicy = TOKEN_INFORMATION_CLASS.TokenAuditPolicy;
pub const TokenOrigin = TOKEN_INFORMATION_CLASS.TokenOrigin;
pub const TokenElevationType = TOKEN_INFORMATION_CLASS.TokenElevationType;
pub const TokenLinkedToken = TOKEN_INFORMATION_CLASS.TokenLinkedToken;
pub const TokenElevation = TOKEN_INFORMATION_CLASS.TokenElevation;
pub const TokenHasRestrictions = TOKEN_INFORMATION_CLASS.TokenHasRestrictions;
pub const TokenAccessInformation = TOKEN_INFORMATION_CLASS.TokenAccessInformation;
pub const TokenVirtualizationAllowed = TOKEN_INFORMATION_CLASS.TokenVirtualizationAllowed;
pub const TokenVirtualizationEnabled = TOKEN_INFORMATION_CLASS.TokenVirtualizationEnabled;
pub const TokenIntegrityLevel = TOKEN_INFORMATION_CLASS.TokenIntegrityLevel;
pub const TokenUIAccess = TOKEN_INFORMATION_CLASS.TokenUIAccess;
pub const TokenMandatoryPolicy = TOKEN_INFORMATION_CLASS.TokenMandatoryPolicy;
pub const TokenLogonSid = TOKEN_INFORMATION_CLASS.TokenLogonSid;
pub const TokenIsAppContainer = TOKEN_INFORMATION_CLASS.TokenIsAppContainer;
pub const TokenCapabilities = TOKEN_INFORMATION_CLASS.TokenCapabilities;
pub const TokenAppContainerSid = TOKEN_INFORMATION_CLASS.TokenAppContainerSid;
pub const TokenAppContainerNumber = TOKEN_INFORMATION_CLASS.TokenAppContainerNumber;
pub const TokenUserClaimAttributes = TOKEN_INFORMATION_CLASS.TokenUserClaimAttributes;
pub const TokenDeviceClaimAttributes = TOKEN_INFORMATION_CLASS.TokenDeviceClaimAttributes;
pub const TokenRestrictedUserClaimAttributes = TOKEN_INFORMATION_CLASS.TokenRestrictedUserClaimAttributes;
pub const TokenRestrictedDeviceClaimAttributes = TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceClaimAttributes;
pub const TokenDeviceGroups = TOKEN_INFORMATION_CLASS.TokenDeviceGroups;
pub const TokenRestrictedDeviceGroups = TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceGroups;
pub const TokenSecurityAttributes = TOKEN_INFORMATION_CLASS.TokenSecurityAttributes;
pub const TokenIsRestricted = TOKEN_INFORMATION_CLASS.TokenIsRestricted;
pub const TokenProcessTrustLevel = TOKEN_INFORMATION_CLASS.TokenProcessTrustLevel;
pub const TokenPrivateNameSpace = TOKEN_INFORMATION_CLASS.TokenPrivateNameSpace;
pub const TokenSingletonAttributes = TOKEN_INFORMATION_CLASS.TokenSingletonAttributes;
pub const TokenBnoIsolation = TOKEN_INFORMATION_CLASS.TokenBnoIsolation;
pub const TokenChildProcessFlags = TOKEN_INFORMATION_CLASS.TokenChildProcessFlags;
pub const TokenIsLessPrivilegedAppContainer = TOKEN_INFORMATION_CLASS.TokenIsLessPrivilegedAppContainer;
pub const TokenIsSandboxed = TOKEN_INFORMATION_CLASS.TokenIsSandboxed;
pub const TokenOriginatingProcessTrustLevel = TOKEN_INFORMATION_CLASS.TokenOriginatingProcessTrustLevel;
pub const MaxTokenInfoClass = TOKEN_INFORMATION_CLASS.MaxTokenInfoClass;

pub const TOKEN_USER = extern struct {
    User: SID_AND_ATTRIBUTES,
};

pub const TOKEN_GROUPS = extern struct {
    GroupCount: u32,
    Groups: [1]SID_AND_ATTRIBUTES,
};

pub const TOKEN_PRIVILEGES = extern struct {
    PrivilegeCount: u32,
    Privileges: [1]LUID_AND_ATTRIBUTES,
};

pub const TOKEN_OWNER = extern struct {
    Owner: PSID,
};

pub const TOKEN_PRIMARY_GROUP = extern struct {
    PrimaryGroup: PSID,
};

pub const TOKEN_DEFAULT_DACL = extern struct {
    DefaultDacl: *ACL,
};

pub const TOKEN_USER_CLAIMS = extern struct {
    UserClaims: *c_void,
};

pub const TOKEN_DEVICE_CLAIMS = extern struct {
    DeviceClaims: *c_void,
};

pub const TOKEN_GROUPS_AND_PRIVILEGES = extern struct {
    SidCount: u32,
    SidLength: u32,
    Sids: *SID_AND_ATTRIBUTES,
    RestrictedSidCount: u32,
    RestrictedSidLength: u32,
    RestrictedSids: *SID_AND_ATTRIBUTES,
    PrivilegeCount: u32,
    PrivilegeLength: u32,
    Privileges: *LUID_AND_ATTRIBUTES,
    AuthenticationId: LUID,
};

pub const TOKEN_LINKED_TOKEN = extern struct {
    LinkedToken: HANDLE,
};

pub const TOKEN_ELEVATION = extern struct {
    TokenIsElevated: u32,
};

pub const TOKEN_MANDATORY_LABEL = extern struct {
    Label: SID_AND_ATTRIBUTES,
};

pub const TOKEN_MANDATORY_POLICY = extern struct {
    Policy: TOKEN_MANDATORY_POLICY_ID,
};

pub const TOKEN_ACCESS_INFORMATION = extern struct {
    SidHash: *SID_AND_ATTRIBUTES_HASH,
    RestrictedSidHash: *SID_AND_ATTRIBUTES_HASH,
    Privileges: *TOKEN_PRIVILEGES,
    AuthenticationId: LUID,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    Flags: u32,
    AppContainerNumber: u32,
    PackageSid: PSID,
    CapabilitiesHash: *SID_AND_ATTRIBUTES_HASH,
    TrustLevelSid: PSID,
    SecurityAttributes: *c_void,
};

pub const TOKEN_AUDIT_POLICY = extern struct {
    PerUserPolicy: [30]u8,
};

pub const TOKEN_SOURCE = extern struct {
    SourceName: [8]CHAR,
    SourceIdentifier: LUID,
};

pub const TOKEN_STATISTICS = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ExpirationTime: LARGE_INTEGER,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DynamicCharged: u32,
    DynamicAvailable: u32,
    GroupCount: u32,
    PrivilegeCount: u32,
    ModifiedId: LUID,
};

pub const TOKEN_CONTROL = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ModifiedId: LUID,
    TokenSource: TOKEN_SOURCE,
};

pub const TOKEN_ORIGIN = extern struct {
    OriginatingLogonSession: LUID,
};

pub const MANDATORY_LEVEL = extern enum(i32) {
    Untrusted = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    System = 4,
    SecureProcess = 5,
    Count = 6,
};
pub const MandatoryLevelUntrusted = MANDATORY_LEVEL.Untrusted;
pub const MandatoryLevelLow = MANDATORY_LEVEL.Low;
pub const MandatoryLevelMedium = MANDATORY_LEVEL.Medium;
pub const MandatoryLevelHigh = MANDATORY_LEVEL.High;
pub const MandatoryLevelSystem = MANDATORY_LEVEL.System;
pub const MandatoryLevelSecureProcess = MANDATORY_LEVEL.SecureProcess;
pub const MandatoryLevelCount = MANDATORY_LEVEL.Count;

pub const TOKEN_APPCONTAINER_INFORMATION = extern struct {
    TokenAppContainer: PSID,
};

pub const CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = extern struct {
    Version: u64,
    Name: PWSTR,
};

pub const CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = extern struct {
    pValue: *c_void,
    ValueLength: u32,
};

pub const CLAIM_SECURITY_ATTRIBUTE_V1 = extern struct {
    Name: PWSTR,
    ValueType: CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE,
    Reserved: u16,
    Flags: u32,
    ValueCount: u32,
    Values: _Values_e__Union,
    const _Values_e__Union = u32; // TODO: generate this nested type!
};

pub const CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = extern struct {
    Name: u32,
    ValueType: CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE,
    Reserved: u16,
    Flags: CLAIM_SECURITY_ATTRIBUTE_FLAGS,
    ValueCount: u32,
    Values: _Values_e__Union,
    const _Values_e__Union = u32; // TODO: generate this nested type!
};

pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION = extern struct {
    Version: u16,
    Reserved: u16,
    AttributeCount: u32,
    Attribute: _Attribute_e__Union,
    const _Attribute_e__Union = u32; // TODO: generate this nested type!
};

pub const SECURITY_QUALITY_OF_SERVICE = extern struct {
    Length: u32,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    ContextTrackingMode: u8,
    EffectiveOnly: u8,
};

pub const SECURITY_CAPABILITIES = extern struct {
    AppContainerSid: PSID,
    Capabilities: *SID_AND_ATTRIBUTES,
    CapabilityCount: u32,
    Reserved: u32,
};

pub const QUOTA_LIMITS = extern struct {
    PagedPoolLimit: usize,
    NonPagedPoolLimit: usize,
    MinimumWorkingSetSize: usize,
    MaximumWorkingSetSize: usize,
    PagefileLimit: usize,
    TimeLimit: LARGE_INTEGER,
};

pub const _SC_NOTIFICATION_REGISTRATION = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _HMAPPER = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

// TODO: this type has a FreeFunc 'CryptCloseAsyncHandle', what can Zig do with this information?
pub const HCRYPTASYNC = ?*opaque{};

// TODO: this type has a FreeFunc 'CertFreeCertificateChainEngine', what can Zig do with this information?
pub const HCERTCHAINENGINE = ?*opaque{};

// TODO: this type has a FreeFunc 'LsaDeregisterLogonProcess', what can Zig do with this information?
pub const LsaHandle = isize;

pub const PSID = isize;

pub const AUTHZ_ACCESS_CHECK_RESULTS_HANDLE = isize;

pub const AUTHZ_CLIENT_CONTEXT_HANDLE = isize;

pub const AUTHZ_RESOURCE_MANAGER_HANDLE = isize;

pub const AUTHZ_AUDIT_EVENT_HANDLE = isize;

pub const AUTHZ_AUDIT_EVENT_TYPE_HANDLE = isize;

pub const AUTHZ_SECURITY_EVENT_PROVIDER_HANDLE = isize;

pub const HDIAGNOSTIC_DATA_QUERY_SESSION = isize;

pub const HDIAGNOSTIC_REPORT = isize;

pub const HDIAGNOSTIC_EVENT_TAG_DESCRIPTION = isize;

pub const HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION = isize;

pub const HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION = isize;

pub const HDIAGNOSTIC_RECORD = isize;

pub const NCRYPT_DESCRIPTOR_HANDLE = isize;

pub const NCRYPT_STREAM_HANDLE = isize;

pub const SAFER_LEVEL_HANDLE = isize;

pub const SC_HANDLE = isize;

pub const SERVICE_STATUS_HANDLE = isize;

pub const NETRESOURCEA = extern struct {
    dwScope: NET_RESOURCE_SCOPE,
    dwType: NET_RESOURCE_TYPE,
    dwDisplayType: u32,
    dwUsage: u32,
    lpLocalName: PSTR,
    lpRemoteName: PSTR,
    lpComment: PSTR,
    lpProvider: PSTR,
};

pub const NETRESOURCEW = extern struct {
    dwScope: NET_RESOURCE_SCOPE,
    dwType: NET_RESOURCE_TYPE,
    dwDisplayType: u32,
    dwUsage: u32,
    lpLocalName: PWSTR,
    lpRemoteName: PWSTR,
    lpComment: PWSTR,
    lpProvider: PWSTR,
};

pub const UNIVERSAL_NAME_INFOA = extern struct {
    lpUniversalName: PSTR,
};

pub const UNIVERSAL_NAME_INFOW = extern struct {
    lpUniversalName: PWSTR,
};

pub const REMOTE_NAME_INFOA = extern struct {
    lpUniversalName: PSTR,
    lpConnectionName: PSTR,
    lpRemainingPath: PSTR,
};

pub const REMOTE_NAME_INFOW = extern struct {
    lpUniversalName: PWSTR,
    lpConnectionName: PWSTR,
    lpRemainingPath: PWSTR,
};

pub const NETCONNECTINFOSTRUCT = extern struct {
    cbStructure: u32,
    dwFlags: u32,
    dwSpeed: u32,
    dwDelay: u32,
    dwOptDataSize: u32,
};

pub const UNICODE_STRING = extern struct {
    Length: u16,
    MaximumLength: u16,
    Buffer: [*]u16,
};

pub const SEC_WINNT_AUTH_IDENTITY_W = extern struct {
    User: *u16,
    UserLength: u32,
    Domain: *u16,
    DomainLength: u32,
    Password: *u16,
    PasswordLength: u32,
    Flags: SEC_WINNT_AUTH_IDENTITY,
};

pub const SEC_WINNT_AUTH_IDENTITY_A = extern struct {
    User: *u8,
    UserLength: u32,
    Domain: *u8,
    DomainLength: u32,
    Password: *u8,
    PasswordLength: u32,
    Flags: SEC_WINNT_AUTH_IDENTITY,
};

pub const PROCESS_INFORMATION_CLASS = extern enum(i32) {
    MemoryPriority = 0,
    MemoryExhaustionInfo = 1,
    AppMemoryInfo = 2,
    InPrivateInfo = 3,
    PowerThrottling = 4,
    ReservedValue1 = 5,
    TelemetryCoverageInfo = 6,
    ProtectionLevelInfo = 7,
    LeapSecondInfo = 8,
    InformationClassMax = 9,
};
pub const ProcessMemoryPriority = PROCESS_INFORMATION_CLASS.MemoryPriority;
pub const ProcessMemoryExhaustionInfo = PROCESS_INFORMATION_CLASS.MemoryExhaustionInfo;
pub const ProcessAppMemoryInfo = PROCESS_INFORMATION_CLASS.AppMemoryInfo;
pub const ProcessInPrivateInfo = PROCESS_INFORMATION_CLASS.InPrivateInfo;
pub const ProcessPowerThrottling = PROCESS_INFORMATION_CLASS.PowerThrottling;
pub const ProcessReservedValue1 = PROCESS_INFORMATION_CLASS.ReservedValue1;
pub const ProcessTelemetryCoverageInfo = PROCESS_INFORMATION_CLASS.TelemetryCoverageInfo;
pub const ProcessProtectionLevelInfo = PROCESS_INFORMATION_CLASS.ProtectionLevelInfo;
pub const ProcessLeapSecondInfo = PROCESS_INFORMATION_CLASS.LeapSecondInfo;
pub const ProcessInformationClassMax = PROCESS_INFORMATION_CLASS.InformationClassMax;

pub const MSA_INFO_LEVEL = extern enum(i32) {
    @"0" = 0,
    Max = 1,
};
pub const MsaInfoLevel0 = MSA_INFO_LEVEL.@"0";
pub const MsaInfoLevelMax = MSA_INFO_LEVEL.Max;

pub const MSA_INFO_STATE = extern enum(i32) {
    NotExist = 1,
    NotService = 2,
    CannotInstall = 3,
    CanInstall = 4,
    Installed = 5,
};
pub const MsaInfoNotExist = MSA_INFO_STATE.NotExist;
pub const MsaInfoNotService = MSA_INFO_STATE.NotService;
pub const MsaInfoCannotInstall = MSA_INFO_STATE.CannotInstall;
pub const MsaInfoCanInstall = MSA_INFO_STATE.CanInstall;
pub const MsaInfoInstalled = MSA_INFO_STATE.Installed;

pub const MSA_INFO_0 = extern struct {
    State: MSA_INFO_STATE,
};

pub const SERVICE_TRIGGER_CUSTOM_STATE_ID = extern struct {
    Data: [2]u32,
};

pub const SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = extern struct {
    u: _u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const SERVICE_DESCRIPTIONA = extern struct {
    lpDescription: PSTR,
};

pub const SERVICE_DESCRIPTIONW = extern struct {
    lpDescription: PWSTR,
};

pub const SC_ACTION_TYPE = extern enum(i32) {
    NONE = 0,
    RESTART = 1,
    REBOOT = 2,
    RUN_COMMAND = 3,
    OWN_RESTART = 4,
};
pub const SC_ACTION_NONE = SC_ACTION_TYPE.NONE;
pub const SC_ACTION_RESTART = SC_ACTION_TYPE.RESTART;
pub const SC_ACTION_REBOOT = SC_ACTION_TYPE.REBOOT;
pub const SC_ACTION_RUN_COMMAND = SC_ACTION_TYPE.RUN_COMMAND;
pub const SC_ACTION_OWN_RESTART = SC_ACTION_TYPE.OWN_RESTART;

pub const SC_ACTION = extern struct {
    Type: SC_ACTION_TYPE,
    Delay: u32,
};

pub const SERVICE_FAILURE_ACTIONSA = extern struct {
    dwResetPeriod: u32,
    lpRebootMsg: PSTR,
    lpCommand: PSTR,
    cActions: u32,
    lpsaActions: *SC_ACTION,
};

pub const SERVICE_FAILURE_ACTIONSW = extern struct {
    dwResetPeriod: u32,
    lpRebootMsg: PWSTR,
    lpCommand: PWSTR,
    cActions: u32,
    lpsaActions: *SC_ACTION,
};

pub const SERVICE_DELAYED_AUTO_START_INFO = extern struct {
    fDelayedAutostart: BOOL,
};

pub const SERVICE_FAILURE_ACTIONS_FLAG = extern struct {
    fFailureActionsOnNonCrashFailures: BOOL,
};

pub const SERVICE_SID_INFO = extern struct {
    dwServiceSidType: u32,
};

pub const SERVICE_REQUIRED_PRIVILEGES_INFOA = extern struct {
    pmszRequiredPrivileges: PSTR,
};

pub const SERVICE_REQUIRED_PRIVILEGES_INFOW = extern struct {
    pmszRequiredPrivileges: PWSTR,
};

pub const SERVICE_PRESHUTDOWN_INFO = extern struct {
    dwPreshutdownTimeout: u32,
};

pub const SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = extern struct {
    dwDataType: SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE,
    cbData: u32,
    pData: *u8,
};

pub const SERVICE_TRIGGER = extern struct {
    dwTriggerType: SERVICE_TRIGGER_TYPE,
    dwAction: SERVICE_TRIGGER_ACTION,
    pTriggerSubtype: *Guid,
    cDataItems: u32,
    pDataItems: *SERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
};

pub const SERVICE_TRIGGER_INFO = extern struct {
    cTriggers: u32,
    pTriggers: *SERVICE_TRIGGER,
    pReserved: *u8,
};

pub const SERVICE_PREFERRED_NODE_INFO = extern struct {
    usPreferredNode: u16,
    fDelete: u8,
};

pub const SERVICE_TIMECHANGE_INFO = extern struct {
    liNewTime: LARGE_INTEGER,
    liOldTime: LARGE_INTEGER,
};

pub const SERVICE_LAUNCH_PROTECTED_INFO = extern struct {
    dwLaunchProtected: u32,
};

pub const SC_STATUS_TYPE = extern enum(i32) {
    O = 0,
};
pub const SC_STATUS_PROCESS_INFO = SC_STATUS_TYPE.O;

pub const SC_ENUM_TYPE = extern enum(i32) {
    O = 0,
};
pub const SC_ENUM_PROCESS_INFO = SC_ENUM_TYPE.O;

pub const SERVICE_STATUS = extern struct {
    dwServiceType: ENUM_SERVICE_TYPE,
    dwCurrentState: SERVICE_STATUS_CURRENT_STATE,
    dwControlsAccepted: u32,
    dwWin32ExitCode: u32,
    dwServiceSpecificExitCode: u32,
    dwCheckPoint: u32,
    dwWaitHint: u32,
};

pub const SERVICE_STATUS_PROCESS = extern struct {
    dwServiceType: ENUM_SERVICE_TYPE,
    dwCurrentState: SERVICE_STATUS_CURRENT_STATE,
    dwControlsAccepted: u32,
    dwWin32ExitCode: u32,
    dwServiceSpecificExitCode: u32,
    dwCheckPoint: u32,
    dwWaitHint: u32,
    dwProcessId: u32,
    dwServiceFlags: SERVICE_RUNS_IN_PROCESS,
};

pub const ENUM_SERVICE_STATUSA = extern struct {
    lpServiceName: PSTR,
    lpDisplayName: PSTR,
    ServiceStatus: SERVICE_STATUS,
};

pub const ENUM_SERVICE_STATUSW = extern struct {
    lpServiceName: PWSTR,
    lpDisplayName: PWSTR,
    ServiceStatus: SERVICE_STATUS,
};

pub const ENUM_SERVICE_STATUS_PROCESSA = extern struct {
    lpServiceName: PSTR,
    lpDisplayName: PSTR,
    ServiceStatusProcess: SERVICE_STATUS_PROCESS,
};

pub const ENUM_SERVICE_STATUS_PROCESSW = extern struct {
    lpServiceName: PWSTR,
    lpDisplayName: PWSTR,
    ServiceStatusProcess: SERVICE_STATUS_PROCESS,
};

pub const QUERY_SERVICE_LOCK_STATUSA = extern struct {
    fIsLocked: u32,
    lpLockOwner: PSTR,
    dwLockDuration: u32,
};

pub const QUERY_SERVICE_LOCK_STATUSW = extern struct {
    fIsLocked: u32,
    lpLockOwner: PWSTR,
    dwLockDuration: u32,
};

pub const QUERY_SERVICE_CONFIGA = extern struct {
    dwServiceType: ENUM_SERVICE_TYPE,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: PSTR,
    lpLoadOrderGroup: PSTR,
    dwTagId: u32,
    lpDependencies: PSTR,
    lpServiceStartName: PSTR,
    lpDisplayName: PSTR,
};

pub const QUERY_SERVICE_CONFIGW = extern struct {
    dwServiceType: ENUM_SERVICE_TYPE,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: PWSTR,
    lpLoadOrderGroup: PWSTR,
    dwTagId: u32,
    lpDependencies: PWSTR,
    lpServiceStartName: PWSTR,
    lpDisplayName: PWSTR,
};

pub const SERVICE_MAIN_FUNCTIONW = fn(
    dwNumServicesArgs: u32,
    lpServiceArgVectors: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_MAIN_FUNCTIONA = fn(
    dwNumServicesArgs: u32,
    lpServiceArgVectors: **i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPSERVICE_MAIN_FUNCTIONW = fn(
    dwNumServicesArgs: u32,
    lpServiceArgVectors: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPSERVICE_MAIN_FUNCTIONA = fn(
    dwNumServicesArgs: u32,
    lpServiceArgVectors: *PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_TABLE_ENTRYA = extern struct {
    lpServiceName: PSTR,
    lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
};

pub const SERVICE_TABLE_ENTRYW = extern struct {
    lpServiceName: PWSTR,
    lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
};

pub const HANDLER_FUNCTION = fn(
    dwControl: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const HANDLER_FUNCTION_EX = fn(
    dwControl: u32,
    dwEventType: u32,
    lpEventData: *c_void,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPHANDLER_FUNCTION = fn(
    dwControl: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPHANDLER_FUNCTION_EX = fn(
    dwControl: u32,
    dwEventType: u32,
    lpEventData: *c_void,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_SC_NOTIFY_CALLBACK = fn(
    pParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_NOTIFY_1 = extern struct {
    dwVersion: u32,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: *c_void,
    dwNotificationStatus: u32,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};

pub const SERVICE_NOTIFY_2A = extern struct {
    dwVersion: u32,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: *c_void,
    dwNotificationStatus: u32,
    ServiceStatus: SERVICE_STATUS_PROCESS,
    dwNotificationTriggered: u32,
    pszServiceNames: PSTR,
};

pub const SERVICE_NOTIFY_2W = extern struct {
    dwVersion: u32,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: *c_void,
    dwNotificationStatus: u32,
    ServiceStatus: SERVICE_STATUS_PROCESS,
    dwNotificationTriggered: u32,
    pszServiceNames: PWSTR,
};

pub const SERVICE_CONTROL_STATUS_REASON_PARAMSA = extern struct {
    dwReason: u32,
    pszComment: PSTR,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};

pub const SERVICE_CONTROL_STATUS_REASON_PARAMSW = extern struct {
    dwReason: u32,
    pszComment: PWSTR,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};

pub const SERVICE_START_REASON = extern struct {
    dwReason: u32,
};

pub const SC_EVENT_TYPE = extern enum(i32) {
    DATABASE_CHANGE = 0,
    PROPERTY_CHANGE = 1,
    STATUS_CHANGE = 2,
};
pub const SC_EVENT_DATABASE_CHANGE = SC_EVENT_TYPE.DATABASE_CHANGE;
pub const SC_EVENT_PROPERTY_CHANGE = SC_EVENT_TYPE.PROPERTY_CHANGE;
pub const SC_EVENT_STATUS_CHANGE = SC_EVENT_TYPE.STATUS_CHANGE;

pub const PSC_NOTIFICATION_CALLBACK = fn(
    dwNotify: u32,
    pCallbackContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_REGISTRY_STATE_TYPE = extern enum(i32) {
    ServiceRegistryStateParameters = 0,
    ServiceRegistryStatePersistent = 1,
    MaxServiceRegistryStateType = 2,
};
pub const ServiceRegistryStateParameters = SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStateParameters;
pub const ServiceRegistryStatePersistent = SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStatePersistent;
pub const MaxServiceRegistryStateType = SERVICE_REGISTRY_STATE_TYPE.MaxServiceRegistryStateType;

pub const SERVICE_DIRECTORY_TYPE = extern enum(i32) {
    PersistentState = 0,
    TypeMax = 1,
};
pub const ServiceDirectoryPersistentState = SERVICE_DIRECTORY_TYPE.PersistentState;
pub const ServiceDirectoryTypeMax = SERVICE_DIRECTORY_TYPE.TypeMax;

pub const LSA_TRUST_INFORMATION = extern struct {
    Name: UNICODE_STRING,
    Sid: PSID,
};

pub const LSA_REFERENCED_DOMAIN_LIST = extern struct {
    Entries: u32,
    Domains: *LSA_TRUST_INFORMATION,
};

pub const LSA_TRANSLATED_SID2 = extern struct {
    Use: SID_NAME_USE,
    Sid: PSID,
    DomainIndex: i32,
    Flags: u32,
};

pub const LSA_TRANSLATED_NAME = extern struct {
    Use: SID_NAME_USE,
    Name: UNICODE_STRING,
    DomainIndex: i32,
};

pub const POLICY_ACCOUNT_DOMAIN_INFO = extern struct {
    DomainName: UNICODE_STRING,
    DomainSid: PSID,
};

pub const POLICY_DNS_DOMAIN_INFO = extern struct {
    Name: UNICODE_STRING,
    DnsDomainName: UNICODE_STRING,
    DnsForestName: UNICODE_STRING,
    DomainGuid: Guid,
    Sid: PSID,
};

pub const LSA_LOOKUP_DOMAIN_INFO_CLASS = extern enum(i32) {
    AccountDomainInformation = 5,
    DnsDomainInformation = 12,
};
pub const AccountDomainInformation = LSA_LOOKUP_DOMAIN_INFO_CLASS.AccountDomainInformation;
pub const DnsDomainInformation = LSA_LOOKUP_DOMAIN_INFO_CLASS.DnsDomainInformation;

pub const SECURITY_LOGON_TYPE = extern enum(i32) {
    UndefinedLogonType = 0,
    Interactive = 2,
    Network = 3,
    Batch = 4,
    Service = 5,
    Proxy = 6,
    Unlock = 7,
    NetworkCleartext = 8,
    NewCredentials = 9,
    RemoteInteractive = 10,
    CachedInteractive = 11,
    CachedRemoteInteractive = 12,
    CachedUnlock = 13,
};
pub const UndefinedLogonType = SECURITY_LOGON_TYPE.UndefinedLogonType;
pub const Interactive = SECURITY_LOGON_TYPE.Interactive;
pub const Network = SECURITY_LOGON_TYPE.Network;
pub const Batch = SECURITY_LOGON_TYPE.Batch;
pub const Service = SECURITY_LOGON_TYPE.Service;
pub const Proxy = SECURITY_LOGON_TYPE.Proxy;
pub const Unlock = SECURITY_LOGON_TYPE.Unlock;
pub const NetworkCleartext = SECURITY_LOGON_TYPE.NetworkCleartext;
pub const NewCredentials = SECURITY_LOGON_TYPE.NewCredentials;
pub const RemoteInteractive = SECURITY_LOGON_TYPE.RemoteInteractive;
pub const CachedInteractive = SECURITY_LOGON_TYPE.CachedInteractive;
pub const CachedRemoteInteractive = SECURITY_LOGON_TYPE.CachedRemoteInteractive;
pub const CachedUnlock = SECURITY_LOGON_TYPE.CachedUnlock;

pub const SE_ADT_PARAMETER_TYPE = extern enum(i32) {
    None = 0,
    String = 1,
    FileSpec = 2,
    Ulong = 3,
    Sid = 4,
    LogonId = 5,
    NoLogonId = 6,
    AccessMask = 7,
    Privs = 8,
    ObjectTypes = 9,
    HexUlong = 10,
    Ptr = 11,
    Time = 12,
    Guid = 13,
    Luid = 14,
    HexInt64 = 15,
    StringList = 16,
    SidList = 17,
    Duration = 18,
    UserAccountControl = 19,
    NoUac = 20,
    Message = 21,
    DateTime = 22,
    SockAddr = 23,
    SD = 24,
    LogonHours = 25,
    LogonIdNoSid = 26,
    UlongNoConv = 27,
    SockAddrNoPort = 28,
    AccessReason = 29,
    StagingReason = 30,
    ResourceAttribute = 31,
    Claims = 32,
    LogonIdAsSid = 33,
    MultiSzString = 34,
    LogonIdEx = 35,
};
pub const SeAdtParmTypeNone = SE_ADT_PARAMETER_TYPE.None;
pub const SeAdtParmTypeString = SE_ADT_PARAMETER_TYPE.String;
pub const SeAdtParmTypeFileSpec = SE_ADT_PARAMETER_TYPE.FileSpec;
pub const SeAdtParmTypeUlong = SE_ADT_PARAMETER_TYPE.Ulong;
pub const SeAdtParmTypeSid = SE_ADT_PARAMETER_TYPE.Sid;
pub const SeAdtParmTypeLogonId = SE_ADT_PARAMETER_TYPE.LogonId;
pub const SeAdtParmTypeNoLogonId = SE_ADT_PARAMETER_TYPE.NoLogonId;
pub const SeAdtParmTypeAccessMask = SE_ADT_PARAMETER_TYPE.AccessMask;
pub const SeAdtParmTypePrivs = SE_ADT_PARAMETER_TYPE.Privs;
pub const SeAdtParmTypeObjectTypes = SE_ADT_PARAMETER_TYPE.ObjectTypes;
pub const SeAdtParmTypeHexUlong = SE_ADT_PARAMETER_TYPE.HexUlong;
pub const SeAdtParmTypePtr = SE_ADT_PARAMETER_TYPE.Ptr;
pub const SeAdtParmTypeTime = SE_ADT_PARAMETER_TYPE.Time;
pub const SeAdtParmTypeGuid = SE_ADT_PARAMETER_TYPE.Guid;
pub const SeAdtParmTypeLuid = SE_ADT_PARAMETER_TYPE.Luid;
pub const SeAdtParmTypeHexInt64 = SE_ADT_PARAMETER_TYPE.HexInt64;
pub const SeAdtParmTypeStringList = SE_ADT_PARAMETER_TYPE.StringList;
pub const SeAdtParmTypeSidList = SE_ADT_PARAMETER_TYPE.SidList;
pub const SeAdtParmTypeDuration = SE_ADT_PARAMETER_TYPE.Duration;
pub const SeAdtParmTypeUserAccountControl = SE_ADT_PARAMETER_TYPE.UserAccountControl;
pub const SeAdtParmTypeNoUac = SE_ADT_PARAMETER_TYPE.NoUac;
pub const SeAdtParmTypeMessage = SE_ADT_PARAMETER_TYPE.Message;
pub const SeAdtParmTypeDateTime = SE_ADT_PARAMETER_TYPE.DateTime;
pub const SeAdtParmTypeSockAddr = SE_ADT_PARAMETER_TYPE.SockAddr;
pub const SeAdtParmTypeSD = SE_ADT_PARAMETER_TYPE.SD;
pub const SeAdtParmTypeLogonHours = SE_ADT_PARAMETER_TYPE.LogonHours;
pub const SeAdtParmTypeLogonIdNoSid = SE_ADT_PARAMETER_TYPE.LogonIdNoSid;
pub const SeAdtParmTypeUlongNoConv = SE_ADT_PARAMETER_TYPE.UlongNoConv;
pub const SeAdtParmTypeSockAddrNoPort = SE_ADT_PARAMETER_TYPE.SockAddrNoPort;
pub const SeAdtParmTypeAccessReason = SE_ADT_PARAMETER_TYPE.AccessReason;
pub const SeAdtParmTypeStagingReason = SE_ADT_PARAMETER_TYPE.StagingReason;
pub const SeAdtParmTypeResourceAttribute = SE_ADT_PARAMETER_TYPE.ResourceAttribute;
pub const SeAdtParmTypeClaims = SE_ADT_PARAMETER_TYPE.Claims;
pub const SeAdtParmTypeLogonIdAsSid = SE_ADT_PARAMETER_TYPE.LogonIdAsSid;
pub const SeAdtParmTypeMultiSzString = SE_ADT_PARAMETER_TYPE.MultiSzString;
pub const SeAdtParmTypeLogonIdEx = SE_ADT_PARAMETER_TYPE.LogonIdEx;

pub const SE_ADT_OBJECT_TYPE = extern struct {
    ObjectType: Guid,
    Flags: u16,
    Level: u16,
    AccessMask: u32,
};

pub const SE_ADT_PARAMETER_ARRAY_ENTRY = extern struct {
    Type: SE_ADT_PARAMETER_TYPE,
    Length: u32,
    Data: [2]usize,
    Address: *c_void,
};

pub const SE_ADT_ACCESS_REASON = extern struct {
    AccessMask: u32,
    AccessReasons: [32]u32,
    ObjectTypeIndex: u32,
    AccessGranted: u32,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
};

pub const SE_ADT_CLAIMS = extern struct {
    Length: u32,
    Claims: *c_void,
};

pub const SE_ADT_PARAMETER_ARRAY = extern struct {
    CategoryId: u32,
    AuditId: u32,
    ParameterCount: u32,
    Length: u32,
    FlatSubCategoryId: u16,
    Type: u16,
    Flags: u32,
    Parameters: [32]SE_ADT_PARAMETER_ARRAY_ENTRY,
};

pub const SE_ADT_PARAMETER_ARRAY_EX = extern struct {
    CategoryId: u32,
    AuditId: u32,
    Version: u32,
    ParameterCount: u32,
    Length: u32,
    FlatSubCategoryId: u16,
    Type: u16,
    Flags: u32,
    Parameters: [32]SE_ADT_PARAMETER_ARRAY_ENTRY,
};

pub const POLICY_AUDIT_EVENT_TYPE = extern enum(i32) {
    System = 0,
    Logon = 1,
    ObjectAccess = 2,
    PrivilegeUse = 3,
    DetailedTracking = 4,
    PolicyChange = 5,
    AccountManagement = 6,
    DirectoryServiceAccess = 7,
    AccountLogon = 8,
};
pub const AuditCategorySystem = POLICY_AUDIT_EVENT_TYPE.System;
pub const AuditCategoryLogon = POLICY_AUDIT_EVENT_TYPE.Logon;
pub const AuditCategoryObjectAccess = POLICY_AUDIT_EVENT_TYPE.ObjectAccess;
pub const AuditCategoryPrivilegeUse = POLICY_AUDIT_EVENT_TYPE.PrivilegeUse;
pub const AuditCategoryDetailedTracking = POLICY_AUDIT_EVENT_TYPE.DetailedTracking;
pub const AuditCategoryPolicyChange = POLICY_AUDIT_EVENT_TYPE.PolicyChange;
pub const AuditCategoryAccountManagement = POLICY_AUDIT_EVENT_TYPE.AccountManagement;
pub const AuditCategoryDirectoryServiceAccess = POLICY_AUDIT_EVENT_TYPE.DirectoryServiceAccess;
pub const AuditCategoryAccountLogon = POLICY_AUDIT_EVENT_TYPE.AccountLogon;

pub const LSA_TRANSLATED_SID = extern struct {
    Use: SID_NAME_USE,
    RelativeId: u32,
    DomainIndex: i32,
};

pub const POLICY_LSA_SERVER_ROLE = extern enum(i32) {
    Backup = 2,
    Primary = 3,
};
pub const PolicyServerRoleBackup = POLICY_LSA_SERVER_ROLE.Backup;
pub const PolicyServerRolePrimary = POLICY_LSA_SERVER_ROLE.Primary;

pub const POLICY_INFORMATION_CLASS = extern enum(i32) {
    AuditLogInformation = 1,
    AuditEventsInformation = 2,
    PrimaryDomainInformation = 3,
    PdAccountInformation = 4,
    AccountDomainInformation = 5,
    LsaServerRoleInformation = 6,
    ReplicaSourceInformation = 7,
    DefaultQuotaInformation = 8,
    ModificationInformation = 9,
    AuditFullSetInformation = 10,
    AuditFullQueryInformation = 11,
    DnsDomainInformation = 12,
    DnsDomainInformationInt = 13,
    LocalAccountDomainInformation = 14,
    MachineAccountInformation = 15,
    LastEntry = 16,
};
pub const PolicyAuditLogInformation = POLICY_INFORMATION_CLASS.AuditLogInformation;
pub const PolicyAuditEventsInformation = POLICY_INFORMATION_CLASS.AuditEventsInformation;
pub const PolicyPrimaryDomainInformation = POLICY_INFORMATION_CLASS.PrimaryDomainInformation;
pub const PolicyPdAccountInformation = POLICY_INFORMATION_CLASS.PdAccountInformation;
pub const PolicyAccountDomainInformation = POLICY_INFORMATION_CLASS.AccountDomainInformation;
pub const PolicyLsaServerRoleInformation = POLICY_INFORMATION_CLASS.LsaServerRoleInformation;
pub const PolicyReplicaSourceInformation = POLICY_INFORMATION_CLASS.ReplicaSourceInformation;
pub const PolicyDefaultQuotaInformation = POLICY_INFORMATION_CLASS.DefaultQuotaInformation;
pub const PolicyModificationInformation = POLICY_INFORMATION_CLASS.ModificationInformation;
pub const PolicyAuditFullSetInformation = POLICY_INFORMATION_CLASS.AuditFullSetInformation;
pub const PolicyAuditFullQueryInformation = POLICY_INFORMATION_CLASS.AuditFullQueryInformation;
pub const PolicyDnsDomainInformation = POLICY_INFORMATION_CLASS.DnsDomainInformation;
pub const PolicyDnsDomainInformationInt = POLICY_INFORMATION_CLASS.DnsDomainInformationInt;
pub const PolicyLocalAccountDomainInformation = POLICY_INFORMATION_CLASS.LocalAccountDomainInformation;
pub const PolicyMachineAccountInformation = POLICY_INFORMATION_CLASS.MachineAccountInformation;
pub const PolicyLastEntry = POLICY_INFORMATION_CLASS.LastEntry;

pub const POLICY_AUDIT_LOG_INFO = extern struct {
    AuditLogPercentFull: u32,
    MaximumLogSize: u32,
    AuditRetentionPeriod: LARGE_INTEGER,
    AuditLogFullShutdownInProgress: u8,
    TimeToShutdown: LARGE_INTEGER,
    NextAuditRecordId: u32,
};

pub const POLICY_AUDIT_EVENTS_INFO = extern struct {
    AuditingMode: u8,
    EventAuditingOptions: *u32,
    MaximumAuditEventCount: u32,
};

pub const POLICY_AUDIT_SUBCATEGORIES_INFO = extern struct {
    MaximumSubCategoryCount: u32,
    EventAuditingOptions: *u32,
};

pub const POLICY_AUDIT_CATEGORIES_INFO = extern struct {
    MaximumCategoryCount: u32,
    SubCategoriesInfo: *POLICY_AUDIT_SUBCATEGORIES_INFO,
};

pub const POLICY_PRIMARY_DOMAIN_INFO = extern struct {
    Name: UNICODE_STRING,
    Sid: PSID,
};

pub const POLICY_PD_ACCOUNT_INFO = extern struct {
    Name: UNICODE_STRING,
};

pub const POLICY_LSA_SERVER_ROLE_INFO = extern struct {
    LsaServerRole: POLICY_LSA_SERVER_ROLE,
};

pub const POLICY_REPLICA_SOURCE_INFO = extern struct {
    ReplicaSource: UNICODE_STRING,
    ReplicaAccountName: UNICODE_STRING,
};

pub const POLICY_DEFAULT_QUOTA_INFO = extern struct {
    QuotaLimits: QUOTA_LIMITS,
};

pub const POLICY_MODIFICATION_INFO = extern struct {
    ModifiedId: LARGE_INTEGER,
    DatabaseCreationTime: LARGE_INTEGER,
};

pub const POLICY_AUDIT_FULL_SET_INFO = extern struct {
    ShutDownOnFull: u8,
};

pub const POLICY_AUDIT_FULL_QUERY_INFO = extern struct {
    ShutDownOnFull: u8,
    LogIsFull: u8,
};

pub const POLICY_DOMAIN_INFORMATION_CLASS = extern enum(i32) {
    EfsInformation = 2,
    KerberosTicketInformation = 3,
};
pub const PolicyDomainEfsInformation = POLICY_DOMAIN_INFORMATION_CLASS.EfsInformation;
pub const PolicyDomainKerberosTicketInformation = POLICY_DOMAIN_INFORMATION_CLASS.KerberosTicketInformation;

pub const POLICY_DOMAIN_EFS_INFO = extern struct {
    InfoLength: u32,
    EfsBlob: *u8,
};

pub const POLICY_DOMAIN_KERBEROS_TICKET_INFO = extern struct {
    AuthenticationOptions: u32,
    MaxServiceTicketAge: LARGE_INTEGER,
    MaxTicketAge: LARGE_INTEGER,
    MaxRenewAge: LARGE_INTEGER,
    MaxClockSkew: LARGE_INTEGER,
    Reserved: LARGE_INTEGER,
};

pub const POLICY_MACHINE_ACCT_INFO = extern struct {
    Rid: u32,
    Sid: PSID,
};

pub const POLICY_NOTIFICATION_INFORMATION_CLASS = extern enum(i32) {
    AuditEventsInformation = 1,
    AccountDomainInformation = 2,
    ServerRoleInformation = 3,
    DnsDomainInformation = 4,
    DomainEfsInformation = 5,
    DomainKerberosTicketInformation = 6,
    MachineAccountPasswordInformation = 7,
    GlobalSaclInformation = 8,
    Max = 9,
};
pub const PolicyNotifyAuditEventsInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.AuditEventsInformation;
pub const PolicyNotifyAccountDomainInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.AccountDomainInformation;
pub const PolicyNotifyServerRoleInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.ServerRoleInformation;
pub const PolicyNotifyDnsDomainInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.DnsDomainInformation;
pub const PolicyNotifyDomainEfsInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.DomainEfsInformation;
pub const PolicyNotifyDomainKerberosTicketInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.DomainKerberosTicketInformation;
pub const PolicyNotifyMachineAccountPasswordInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.MachineAccountPasswordInformation;
pub const PolicyNotifyGlobalSaclInformation = POLICY_NOTIFICATION_INFORMATION_CLASS.GlobalSaclInformation;
pub const PolicyNotifyMax = POLICY_NOTIFICATION_INFORMATION_CLASS.Max;

pub const TRUSTED_INFORMATION_CLASS = extern enum(i32) {
    DomainNameInformation = 1,
    ControllersInformation = 2,
    PosixOffsetInformation = 3,
    PasswordInformation = 4,
    DomainInformationBasic = 5,
    DomainInformationEx = 6,
    DomainAuthInformation = 7,
    DomainFullInformation = 8,
    DomainAuthInformationInternal = 9,
    DomainFullInformationInternal = 10,
    DomainInformationEx2Internal = 11,
    DomainFullInformation2Internal = 12,
    DomainSupportedEncryptionTypes = 13,
};
pub const TrustedDomainNameInformation = TRUSTED_INFORMATION_CLASS.DomainNameInformation;
pub const TrustedControllersInformation = TRUSTED_INFORMATION_CLASS.ControllersInformation;
pub const TrustedPosixOffsetInformation = TRUSTED_INFORMATION_CLASS.PosixOffsetInformation;
pub const TrustedPasswordInformation = TRUSTED_INFORMATION_CLASS.PasswordInformation;
pub const TrustedDomainInformationBasic = TRUSTED_INFORMATION_CLASS.DomainInformationBasic;
pub const TrustedDomainInformationEx = TRUSTED_INFORMATION_CLASS.DomainInformationEx;
pub const TrustedDomainAuthInformation = TRUSTED_INFORMATION_CLASS.DomainAuthInformation;
pub const TrustedDomainFullInformation = TRUSTED_INFORMATION_CLASS.DomainFullInformation;
pub const TrustedDomainAuthInformationInternal = TRUSTED_INFORMATION_CLASS.DomainAuthInformationInternal;
pub const TrustedDomainFullInformationInternal = TRUSTED_INFORMATION_CLASS.DomainFullInformationInternal;
pub const TrustedDomainInformationEx2Internal = TRUSTED_INFORMATION_CLASS.DomainInformationEx2Internal;
pub const TrustedDomainFullInformation2Internal = TRUSTED_INFORMATION_CLASS.DomainFullInformation2Internal;
pub const TrustedDomainSupportedEncryptionTypes = TRUSTED_INFORMATION_CLASS.DomainSupportedEncryptionTypes;

pub const TRUSTED_DOMAIN_NAME_INFO = extern struct {
    Name: UNICODE_STRING,
};

pub const TRUSTED_CONTROLLERS_INFO = extern struct {
    Entries: u32,
    Names: *UNICODE_STRING,
};

pub const TRUSTED_POSIX_OFFSET_INFO = extern struct {
    Offset: u32,
};

pub const TRUSTED_PASSWORD_INFO = extern struct {
    Password: UNICODE_STRING,
    OldPassword: UNICODE_STRING,
};

pub const TRUSTED_DOMAIN_INFORMATION_EX = extern struct {
    Name: UNICODE_STRING,
    FlatName: UNICODE_STRING,
    Sid: PSID,
    TrustDirection: TRUSTED_DOMAIN_TRUST_DIRECTION,
    TrustType: TRUSTED_DOMAIN_TRUST_TYPE,
    TrustAttributes: TRUSTED_DOMAIN_TRUST_ATTRIBUTES,
};

pub const TRUSTED_DOMAIN_INFORMATION_EX2 = extern struct {
    Name: UNICODE_STRING,
    FlatName: UNICODE_STRING,
    Sid: PSID,
    TrustDirection: u32,
    TrustType: u32,
    TrustAttributes: u32,
    ForestTrustLength: u32,
    ForestTrustInfo: *u8,
};

pub const LSA_AUTH_INFORMATION = extern struct {
    LastUpdateTime: LARGE_INTEGER,
    AuthType: LSA_AUTH_INFORMATION_AUTH_TYPE,
    AuthInfoLength: u32,
    AuthInfo: *u8,
};

pub const TRUSTED_DOMAIN_AUTH_INFORMATION = extern struct {
    IncomingAuthInfos: u32,
    IncomingAuthenticationInformation: *LSA_AUTH_INFORMATION,
    IncomingPreviousAuthenticationInformation: *LSA_AUTH_INFORMATION,
    OutgoingAuthInfos: u32,
    OutgoingAuthenticationInformation: *LSA_AUTH_INFORMATION,
    OutgoingPreviousAuthenticationInformation: *LSA_AUTH_INFORMATION,
};

pub const TRUSTED_DOMAIN_FULL_INFORMATION = extern struct {
    Information: TRUSTED_DOMAIN_INFORMATION_EX,
    PosixOffset: TRUSTED_POSIX_OFFSET_INFO,
    AuthInformation: TRUSTED_DOMAIN_AUTH_INFORMATION,
};

pub const TRUSTED_DOMAIN_FULL_INFORMATION2 = extern struct {
    Information: TRUSTED_DOMAIN_INFORMATION_EX2,
    PosixOffset: TRUSTED_POSIX_OFFSET_INFO,
    AuthInformation: TRUSTED_DOMAIN_AUTH_INFORMATION,
};

pub const TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES = extern struct {
    SupportedEncryptionTypes: u32,
};

pub const LSA_FOREST_TRUST_RECORD_TYPE = extern enum(i32) {
    TopLevelName = 0,
    TopLevelNameEx = 1,
    DomainInfo = 2,
    RecordTypeLast = 2,
};
pub const ForestTrustTopLevelName = LSA_FOREST_TRUST_RECORD_TYPE.TopLevelName;
pub const ForestTrustTopLevelNameEx = LSA_FOREST_TRUST_RECORD_TYPE.TopLevelNameEx;
pub const ForestTrustDomainInfo = LSA_FOREST_TRUST_RECORD_TYPE.DomainInfo;
pub const ForestTrustRecordTypeLast = LSA_FOREST_TRUST_RECORD_TYPE.RecordTypeLast;

pub const LSA_FOREST_TRUST_DOMAIN_INFO = extern struct {
    Sid: PSID,
    DnsName: UNICODE_STRING,
    NetbiosName: UNICODE_STRING,
};

pub const LSA_FOREST_TRUST_BINARY_DATA = extern struct {
    Length: u32,
    Buffer: *u8,
};

pub const LSA_FOREST_TRUST_RECORD = extern struct {
    Flags: u32,
    ForestTrustType: LSA_FOREST_TRUST_RECORD_TYPE,
    Time: LARGE_INTEGER,
    ForestTrustData: _ForestTrustData_e__Union,
    const _ForestTrustData_e__Union = u32; // TODO: generate this nested type!
};

pub const LSA_FOREST_TRUST_INFORMATION = extern struct {
    RecordCount: u32,
    Entries: **LSA_FOREST_TRUST_RECORD,
};

pub const LSA_FOREST_TRUST_COLLISION_RECORD_TYPE = extern enum(i32) {
    Tdo = 0,
    Xref = 1,
    Other = 2,
};
pub const CollisionTdo = LSA_FOREST_TRUST_COLLISION_RECORD_TYPE.Tdo;
pub const CollisionXref = LSA_FOREST_TRUST_COLLISION_RECORD_TYPE.Xref;
pub const CollisionOther = LSA_FOREST_TRUST_COLLISION_RECORD_TYPE.Other;

pub const LSA_FOREST_TRUST_COLLISION_RECORD = extern struct {
    Index: u32,
    Type: LSA_FOREST_TRUST_COLLISION_RECORD_TYPE,
    Flags: u32,
    Name: UNICODE_STRING,
};

pub const LSA_FOREST_TRUST_COLLISION_INFORMATION = extern struct {
    RecordCount: u32,
    Entries: **LSA_FOREST_TRUST_COLLISION_RECORD,
};

pub const LSA_ENUMERATION_INFORMATION = extern struct {
    Sid: PSID,
};

pub const LSA_LAST_INTER_LOGON_INFO = extern struct {
    LastSuccessfulLogon: LARGE_INTEGER,
    LastFailedLogon: LARGE_INTEGER,
    FailedAttemptCountSinceLastSuccessfulLogon: u32,
};

pub const SECURITY_LOGON_SESSION_DATA = extern struct {
    Size: u32,
    LogonId: LUID,
    UserName: UNICODE_STRING,
    LogonDomain: UNICODE_STRING,
    AuthenticationPackage: UNICODE_STRING,
    LogonType: u32,
    Session: u32,
    Sid: PSID,
    LogonTime: LARGE_INTEGER,
    LogonServer: UNICODE_STRING,
    DnsDomainName: UNICODE_STRING,
    Upn: UNICODE_STRING,
    UserFlags: u32,
    LastLogonInfo: LSA_LAST_INTER_LOGON_INFO,
    LogonScript: UNICODE_STRING,
    ProfilePath: UNICODE_STRING,
    HomeDirectory: UNICODE_STRING,
    HomeDirectoryDrive: UNICODE_STRING,
    LogoffTime: LARGE_INTEGER,
    KickOffTime: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
};

pub const CENTRAL_ACCESS_POLICY_ENTRY = extern struct {
    Name: UNICODE_STRING,
    Description: UNICODE_STRING,
    ChangeId: UNICODE_STRING,
    LengthAppliesTo: u32,
    AppliesTo: *u8,
    LengthSD: u32,
    SD: *SECURITY_DESCRIPTOR,
    LengthStagedSD: u32,
    StagedSD: *SECURITY_DESCRIPTOR,
    Flags: u32,
};

pub const CENTRAL_ACCESS_POLICY = extern struct {
    CAPID: PSID,
    Name: UNICODE_STRING,
    Description: UNICODE_STRING,
    ChangeId: UNICODE_STRING,
    Flags: u32,
    CAPECount: u32,
    CAPEs: **CENTRAL_ACCESS_POLICY_ENTRY,
};

pub const NEGOTIATE_MESSAGES = extern enum(i32) {
    EnumPackagePrefixes = 0,
    GetCallerName = 1,
    TransferCredentials = 2,
    MsgReserved1 = 3,
    CallPackageMax = 4,
};
pub const NegEnumPackagePrefixes = NEGOTIATE_MESSAGES.EnumPackagePrefixes;
pub const NegGetCallerName = NEGOTIATE_MESSAGES.GetCallerName;
pub const NegTransferCredentials = NEGOTIATE_MESSAGES.TransferCredentials;
pub const NegMsgReserved1 = NEGOTIATE_MESSAGES.MsgReserved1;
pub const NegCallPackageMax = NEGOTIATE_MESSAGES.CallPackageMax;

pub const NEGOTIATE_PACKAGE_PREFIX = extern struct {
    PackageId: usize,
    PackageDataA: *c_void,
    PackageDataW: *c_void,
    PrefixLen: usize,
    Prefix: [32]u8,
};

pub const NEGOTIATE_PACKAGE_PREFIXES = extern struct {
    MessageType: u32,
    PrefixCount: u32,
    Offset: u32,
    Pad: u32,
};

pub const NEGOTIATE_CALLER_NAME_REQUEST = extern struct {
    MessageType: u32,
    LogonId: LUID,
};

pub const NEGOTIATE_CALLER_NAME_RESPONSE = extern struct {
    MessageType: u32,
    CallerName: PWSTR,
};

pub const DOMAIN_PASSWORD_INFORMATION = extern struct {
    MinPasswordLength: u16,
    PasswordHistoryLength: u16,
    PasswordProperties: DOMAIN_PASSWORD_PROPERTIES,
    MaxPasswordAge: LARGE_INTEGER,
    MinPasswordAge: LARGE_INTEGER,
};

pub const PSAM_PASSWORD_NOTIFICATION_ROUTINE = fn(
    UserName: *UNICODE_STRING,
    RelativeId: u32,
    NewPassword: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PSAM_INIT_NOTIFICATION_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PSAM_PASSWORD_FILTER_ROUTINE = fn(
    AccountName: *UNICODE_STRING,
    FullName: *UNICODE_STRING,
    Password: *UNICODE_STRING,
    SetOperation: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const MSV1_0_LOGON_SUBMIT_TYPE = extern enum(i32) {
    InteractiveLogon = 2,
    Lm20Logon = 3,
    NetworkLogon = 4,
    SubAuthLogon = 5,
    WorkstationUnlockLogon = 7,
    S4ULogon = 12,
    VirtualLogon = 82,
    NoElevationLogon = 83,
    LuidLogon = 84,
};
pub const MsV1_0InteractiveLogon = MSV1_0_LOGON_SUBMIT_TYPE.InteractiveLogon;
pub const MsV1_0Lm20Logon = MSV1_0_LOGON_SUBMIT_TYPE.Lm20Logon;
pub const MsV1_0NetworkLogon = MSV1_0_LOGON_SUBMIT_TYPE.NetworkLogon;
pub const MsV1_0SubAuthLogon = MSV1_0_LOGON_SUBMIT_TYPE.SubAuthLogon;
pub const MsV1_0WorkstationUnlockLogon = MSV1_0_LOGON_SUBMIT_TYPE.WorkstationUnlockLogon;
pub const MsV1_0S4ULogon = MSV1_0_LOGON_SUBMIT_TYPE.S4ULogon;
pub const MsV1_0VirtualLogon = MSV1_0_LOGON_SUBMIT_TYPE.VirtualLogon;
pub const MsV1_0NoElevationLogon = MSV1_0_LOGON_SUBMIT_TYPE.NoElevationLogon;
pub const MsV1_0LuidLogon = MSV1_0_LOGON_SUBMIT_TYPE.LuidLogon;

pub const MSV1_0_PROFILE_BUFFER_TYPE = extern enum(i32) {
    InteractiveProfile = 2,
    Lm20LogonProfile = 3,
    SmartCardProfile = 4,
};
pub const MsV1_0InteractiveProfile = MSV1_0_PROFILE_BUFFER_TYPE.InteractiveProfile;
pub const MsV1_0Lm20LogonProfile = MSV1_0_PROFILE_BUFFER_TYPE.Lm20LogonProfile;
pub const MsV1_0SmartCardProfile = MSV1_0_PROFILE_BUFFER_TYPE.SmartCardProfile;

pub const MSV1_0_INTERACTIVE_LOGON = extern struct {
    MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    LogonDomainName: UNICODE_STRING,
    UserName: UNICODE_STRING,
    Password: UNICODE_STRING,
};

pub const MSV1_0_INTERACTIVE_PROFILE = extern struct {
    MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    LogonCount: u16,
    BadPasswordCount: u16,
    LogonTime: LARGE_INTEGER,
    LogoffTime: LARGE_INTEGER,
    KickOffTime: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
    LogonScript: UNICODE_STRING,
    HomeDirectory: UNICODE_STRING,
    FullName: UNICODE_STRING,
    ProfilePath: UNICODE_STRING,
    HomeDirectoryDrive: UNICODE_STRING,
    LogonServer: UNICODE_STRING,
    UserFlags: u32,
};

pub const MSV1_0_LM20_LOGON = extern struct {
    MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    LogonDomainName: UNICODE_STRING,
    UserName: UNICODE_STRING,
    Workstation: UNICODE_STRING,
    ChallengeToClient: [8]u8,
    CaseSensitiveChallengeResponse: STRING,
    CaseInsensitiveChallengeResponse: STRING,
    ParameterControl: u32,
};

pub const MSV1_0_SUBAUTH_LOGON = extern struct {
    MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    LogonDomainName: UNICODE_STRING,
    UserName: UNICODE_STRING,
    Workstation: UNICODE_STRING,
    ChallengeToClient: [8]u8,
    AuthenticationInfo1: STRING,
    AuthenticationInfo2: STRING,
    ParameterControl: MSV_SUBAUTH_LOGON_PARAMETER_CONTROL,
    SubAuthPackageId: u32,
};

pub const MSV1_0_S4U_LOGON = extern struct {
    MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    Flags: u32,
    UserPrincipalName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
};

pub const MSV1_0_LM20_LOGON_PROFILE = extern struct {
    MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    KickOffTime: LARGE_INTEGER,
    LogoffTime: LARGE_INTEGER,
    UserFlags: MSV_SUB_AUTHENTICATION_FILTER,
    UserSessionKey: [16]u8,
    LogonDomainName: UNICODE_STRING,
    LanmanSessionKey: [8]u8,
    LogonServer: UNICODE_STRING,
    UserParameters: UNICODE_STRING,
};

pub const MSV1_0_CREDENTIAL_KEY_TYPE = extern enum(i32) {
    InvalidCredKey = 0,
    DeprecatedIUMCredKey = 1,
    DomainUserCredKey = 2,
    LocalUserCredKey = 3,
    ExternallySuppliedCredKey = 4,
};
pub const InvalidCredKey = MSV1_0_CREDENTIAL_KEY_TYPE.InvalidCredKey;
pub const DeprecatedIUMCredKey = MSV1_0_CREDENTIAL_KEY_TYPE.DeprecatedIUMCredKey;
pub const DomainUserCredKey = MSV1_0_CREDENTIAL_KEY_TYPE.DomainUserCredKey;
pub const LocalUserCredKey = MSV1_0_CREDENTIAL_KEY_TYPE.LocalUserCredKey;
pub const ExternallySuppliedCredKey = MSV1_0_CREDENTIAL_KEY_TYPE.ExternallySuppliedCredKey;

pub const MSV1_0_CREDENTIAL_KEY = extern struct {
    Data: [20]u8,
};

pub const MSV1_0_SUPPLEMENTAL_CREDENTIAL = extern struct {
    Version: u32,
    Flags: MSV_SUPPLEMENTAL_CREDENTIAL_FLAGS,
    LmPassword: [16]u8,
    NtPassword: [16]u8,
};

pub const MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 = extern struct {
    Version: u32,
    Flags: u32,
    NtPassword: [16]u8,
    CredentialKey: MSV1_0_CREDENTIAL_KEY,
};

pub const MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 = extern struct {
    Version: u32,
    Flags: u32,
    CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    NtPassword: [16]u8,
    CredentialKey: MSV1_0_CREDENTIAL_KEY,
    ShaPassword: [20]u8,
};

pub const MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL = extern struct {
    Version: u32,
    EncryptedCredsSize: u32,
    EncryptedCreds: [1]u8,
};

pub const MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL = extern struct {
    Version: u32,
    Flags: u32,
    CredentialKey: MSV1_0_CREDENTIAL_KEY,
    CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    EncryptedCredsSize: u32,
    EncryptedCreds: [1]u8,
};

pub const MSV1_0_NTLM3_RESPONSE = extern struct {
    Response: [16]u8,
    RespType: u8,
    HiRespType: u8,
    Flags: u16,
    MsgWord: u32,
    TimeStamp: u64,
    ChallengeFromClient: [8]u8,
    AvPairsOff: u32,
    Buffer: [1]u8,
};

pub const MSV1_0_AVID = extern enum(i32) {
    EOL = 0,
    NbComputerName = 1,
    NbDomainName = 2,
    DnsComputerName = 3,
    DnsDomainName = 4,
    DnsTreeName = 5,
    Flags = 6,
    Timestamp = 7,
    Restrictions = 8,
    TargetName = 9,
    ChannelBindings = 10,
};
pub const MsvAvEOL = MSV1_0_AVID.EOL;
pub const MsvAvNbComputerName = MSV1_0_AVID.NbComputerName;
pub const MsvAvNbDomainName = MSV1_0_AVID.NbDomainName;
pub const MsvAvDnsComputerName = MSV1_0_AVID.DnsComputerName;
pub const MsvAvDnsDomainName = MSV1_0_AVID.DnsDomainName;
pub const MsvAvDnsTreeName = MSV1_0_AVID.DnsTreeName;
pub const MsvAvFlags = MSV1_0_AVID.Flags;
pub const MsvAvTimestamp = MSV1_0_AVID.Timestamp;
pub const MsvAvRestrictions = MSV1_0_AVID.Restrictions;
pub const MsvAvTargetName = MSV1_0_AVID.TargetName;
pub const MsvAvChannelBindings = MSV1_0_AVID.ChannelBindings;

pub const MSV1_0_AV_PAIR = extern struct {
    AvId: u16,
    AvLen: u16,
};

pub const MSV1_0_PROTOCOL_MESSAGE_TYPE = extern enum(i32) {
    Lm20ChallengeRequest = 0,
    Lm20GetChallengeResponse = 1,
    EnumerateUsers = 2,
    GetUserInfo = 3,
    ReLogonUsers = 4,
    ChangePassword = 5,
    ChangeCachedPassword = 6,
    GenericPassthrough = 7,
    CacheLogon = 8,
    SubAuth = 9,
    DeriveCredential = 10,
    CacheLookup = 11,
    SetProcessOption = 12,
    ConfigLocalAliases = 13,
    ClearCachedCredentials = 14,
    LookupToken = 15,
    ValidateAuth = 16,
    CacheLookupEx = 17,
    GetCredentialKey = 18,
    SetThreadOption = 19,
    DecryptDpapiMasterKey = 20,
    GetStrongCredentialKey = 21,
    TransferCred = 22,
    ProvisionTbal = 23,
    DeleteTbalSecrets = 24,
};
pub const MsV1_0Lm20ChallengeRequest = MSV1_0_PROTOCOL_MESSAGE_TYPE.Lm20ChallengeRequest;
pub const MsV1_0Lm20GetChallengeResponse = MSV1_0_PROTOCOL_MESSAGE_TYPE.Lm20GetChallengeResponse;
pub const MsV1_0EnumerateUsers = MSV1_0_PROTOCOL_MESSAGE_TYPE.EnumerateUsers;
pub const MsV1_0GetUserInfo = MSV1_0_PROTOCOL_MESSAGE_TYPE.GetUserInfo;
pub const MsV1_0ReLogonUsers = MSV1_0_PROTOCOL_MESSAGE_TYPE.ReLogonUsers;
pub const MsV1_0ChangePassword = MSV1_0_PROTOCOL_MESSAGE_TYPE.ChangePassword;
pub const MsV1_0ChangeCachedPassword = MSV1_0_PROTOCOL_MESSAGE_TYPE.ChangeCachedPassword;
pub const MsV1_0GenericPassthrough = MSV1_0_PROTOCOL_MESSAGE_TYPE.GenericPassthrough;
pub const MsV1_0CacheLogon = MSV1_0_PROTOCOL_MESSAGE_TYPE.CacheLogon;
pub const MsV1_0SubAuth = MSV1_0_PROTOCOL_MESSAGE_TYPE.SubAuth;
pub const MsV1_0DeriveCredential = MSV1_0_PROTOCOL_MESSAGE_TYPE.DeriveCredential;
pub const MsV1_0CacheLookup = MSV1_0_PROTOCOL_MESSAGE_TYPE.CacheLookup;
pub const MsV1_0SetProcessOption = MSV1_0_PROTOCOL_MESSAGE_TYPE.SetProcessOption;
pub const MsV1_0ConfigLocalAliases = MSV1_0_PROTOCOL_MESSAGE_TYPE.ConfigLocalAliases;
pub const MsV1_0ClearCachedCredentials = MSV1_0_PROTOCOL_MESSAGE_TYPE.ClearCachedCredentials;
pub const MsV1_0LookupToken = MSV1_0_PROTOCOL_MESSAGE_TYPE.LookupToken;
pub const MsV1_0ValidateAuth = MSV1_0_PROTOCOL_MESSAGE_TYPE.ValidateAuth;
pub const MsV1_0CacheLookupEx = MSV1_0_PROTOCOL_MESSAGE_TYPE.CacheLookupEx;
pub const MsV1_0GetCredentialKey = MSV1_0_PROTOCOL_MESSAGE_TYPE.GetCredentialKey;
pub const MsV1_0SetThreadOption = MSV1_0_PROTOCOL_MESSAGE_TYPE.SetThreadOption;
pub const MsV1_0DecryptDpapiMasterKey = MSV1_0_PROTOCOL_MESSAGE_TYPE.DecryptDpapiMasterKey;
pub const MsV1_0GetStrongCredentialKey = MSV1_0_PROTOCOL_MESSAGE_TYPE.GetStrongCredentialKey;
pub const MsV1_0TransferCred = MSV1_0_PROTOCOL_MESSAGE_TYPE.TransferCred;
pub const MsV1_0ProvisionTbal = MSV1_0_PROTOCOL_MESSAGE_TYPE.ProvisionTbal;
pub const MsV1_0DeleteTbalSecrets = MSV1_0_PROTOCOL_MESSAGE_TYPE.DeleteTbalSecrets;

pub const MSV1_0_CHANGEPASSWORD_REQUEST = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    DomainName: UNICODE_STRING,
    AccountName: UNICODE_STRING,
    OldPassword: UNICODE_STRING,
    NewPassword: UNICODE_STRING,
    Impersonating: u8,
};

pub const MSV1_0_CHANGEPASSWORD_RESPONSE = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    PasswordInfoValid: u8,
    DomainPasswordInfo: DOMAIN_PASSWORD_INFORMATION,
};

pub const MSV1_0_PASSTHROUGH_REQUEST = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    DomainName: UNICODE_STRING,
    PackageName: UNICODE_STRING,
    DataLength: u32,
    LogonData: *u8,
    Pad: u32,
};

pub const MSV1_0_PASSTHROUGH_RESPONSE = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    Pad: u32,
    DataLength: u32,
    ValidationData: *u8,
};

pub const MSV1_0_SUBAUTH_REQUEST = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    SubAuthPackageId: u32,
    SubAuthInfoLength: u32,
    SubAuthSubmitBuffer: *u8,
};

pub const MSV1_0_SUBAUTH_RESPONSE = extern struct {
    MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    SubAuthInfoLength: u32,
    SubAuthReturnBuffer: *u8,
};

pub const KERB_LOGON_SUBMIT_TYPE = extern enum(i32) {
    InteractiveLogon = 2,
    SmartCardLogon = 6,
    WorkstationUnlockLogon = 7,
    SmartCardUnlockLogon = 8,
    ProxyLogon = 9,
    TicketLogon = 10,
    TicketUnlockLogon = 11,
    S4ULogon = 12,
    CertificateLogon = 13,
    CertificateS4ULogon = 14,
    CertificateUnlockLogon = 15,
    NoElevationLogon = 83,
    LuidLogon = 84,
};
pub const KerbInteractiveLogon = KERB_LOGON_SUBMIT_TYPE.InteractiveLogon;
pub const KerbSmartCardLogon = KERB_LOGON_SUBMIT_TYPE.SmartCardLogon;
pub const KerbWorkstationUnlockLogon = KERB_LOGON_SUBMIT_TYPE.WorkstationUnlockLogon;
pub const KerbSmartCardUnlockLogon = KERB_LOGON_SUBMIT_TYPE.SmartCardUnlockLogon;
pub const KerbProxyLogon = KERB_LOGON_SUBMIT_TYPE.ProxyLogon;
pub const KerbTicketLogon = KERB_LOGON_SUBMIT_TYPE.TicketLogon;
pub const KerbTicketUnlockLogon = KERB_LOGON_SUBMIT_TYPE.TicketUnlockLogon;
pub const KerbS4ULogon = KERB_LOGON_SUBMIT_TYPE.S4ULogon;
pub const KerbCertificateLogon = KERB_LOGON_SUBMIT_TYPE.CertificateLogon;
pub const KerbCertificateS4ULogon = KERB_LOGON_SUBMIT_TYPE.CertificateS4ULogon;
pub const KerbCertificateUnlockLogon = KERB_LOGON_SUBMIT_TYPE.CertificateUnlockLogon;
pub const KerbNoElevationLogon = KERB_LOGON_SUBMIT_TYPE.NoElevationLogon;
pub const KerbLuidLogon = KERB_LOGON_SUBMIT_TYPE.LuidLogon;

pub const KERB_INTERACTIVE_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    LogonDomainName: UNICODE_STRING,
    UserName: UNICODE_STRING,
    Password: UNICODE_STRING,
};

pub const KERB_INTERACTIVE_UNLOCK_LOGON = extern struct {
    Logon: KERB_INTERACTIVE_LOGON,
    LogonId: LUID,
};

pub const KERB_SMART_CARD_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    Pin: UNICODE_STRING,
    CspDataLength: u32,
    CspData: *u8,
};

pub const KERB_SMART_CARD_UNLOCK_LOGON = extern struct {
    Logon: KERB_SMART_CARD_LOGON,
    LogonId: LUID,
};

pub const KERB_CERTIFICATE_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    DomainName: UNICODE_STRING,
    UserName: UNICODE_STRING,
    Pin: UNICODE_STRING,
    Flags: u32,
    CspDataLength: u32,
    CspData: *u8,
};

pub const KERB_CERTIFICATE_UNLOCK_LOGON = extern struct {
    Logon: KERB_CERTIFICATE_LOGON,
    LogonId: LUID,
};

pub const KERB_CERTIFICATE_S4U_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    Flags: u32,
    UserPrincipalName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    CertificateLength: u32,
    Certificate: *u8,
};

pub const KERB_TICKET_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    Flags: u32,
    ServiceTicketLength: u32,
    TicketGrantingTicketLength: u32,
    ServiceTicket: *u8,
    TicketGrantingTicket: *u8,
};

pub const KERB_TICKET_UNLOCK_LOGON = extern struct {
    Logon: KERB_TICKET_LOGON,
    LogonId: LUID,
};

pub const KERB_S4U_LOGON = extern struct {
    MessageType: KERB_LOGON_SUBMIT_TYPE,
    Flags: u32,
    ClientUpn: UNICODE_STRING,
    ClientRealm: UNICODE_STRING,
};

pub const KERB_PROFILE_BUFFER_TYPE = extern enum(i32) {
    InteractiveProfile = 2,
    SmartCardProfile = 4,
    TicketProfile = 6,
};
pub const KerbInteractiveProfile = KERB_PROFILE_BUFFER_TYPE.InteractiveProfile;
pub const KerbSmartCardProfile = KERB_PROFILE_BUFFER_TYPE.SmartCardProfile;
pub const KerbTicketProfile = KERB_PROFILE_BUFFER_TYPE.TicketProfile;

pub const KERB_INTERACTIVE_PROFILE = extern struct {
    MessageType: KERB_PROFILE_BUFFER_TYPE,
    LogonCount: u16,
    BadPasswordCount: u16,
    LogonTime: LARGE_INTEGER,
    LogoffTime: LARGE_INTEGER,
    KickOffTime: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
    LogonScript: UNICODE_STRING,
    HomeDirectory: UNICODE_STRING,
    FullName: UNICODE_STRING,
    ProfilePath: UNICODE_STRING,
    HomeDirectoryDrive: UNICODE_STRING,
    LogonServer: UNICODE_STRING,
    UserFlags: u32,
};

pub const KERB_SMART_CARD_PROFILE = extern struct {
    Profile: KERB_INTERACTIVE_PROFILE,
    CertificateSize: u32,
    CertificateData: *u8,
};

pub const KERB_CRYPTO_KEY = extern struct {
    KeyType: KERB_CRYPTO_KEY_TYPE,
    Length: u32,
    Value: *u8,
};

pub const KERB_CRYPTO_KEY32 = extern struct {
    KeyType: i32,
    Length: u32,
    Offset: u32,
};

pub const KERB_TICKET_PROFILE = extern struct {
    Profile: KERB_INTERACTIVE_PROFILE,
    SessionKey: KERB_CRYPTO_KEY,
};

pub const KERB_PROTOCOL_MESSAGE_TYPE = extern enum(i32) {
    DebugRequestMessage = 0,
    QueryTicketCacheMessage = 1,
    ChangeMachinePasswordMessage = 2,
    VerifyPacMessage = 3,
    RetrieveTicketMessage = 4,
    UpdateAddressesMessage = 5,
    PurgeTicketCacheMessage = 6,
    ChangePasswordMessage = 7,
    RetrieveEncodedTicketMessage = 8,
    DecryptDataMessage = 9,
    AddBindingCacheEntryMessage = 10,
    SetPasswordMessage = 11,
    SetPasswordExMessage = 12,
    VerifyCredentialsMessage = 13,
    QueryTicketCacheExMessage = 14,
    PurgeTicketCacheExMessage = 15,
    RefreshSmartcardCredentialsMessage = 16,
    AddExtraCredentialsMessage = 17,
    QuerySupplementalCredentialsMessage = 18,
    TransferCredentialsMessage = 19,
    QueryTicketCacheEx2Message = 20,
    SubmitTicketMessage = 21,
    AddExtraCredentialsExMessage = 22,
    QueryKdcProxyCacheMessage = 23,
    PurgeKdcProxyCacheMessage = 24,
    QueryTicketCacheEx3Message = 25,
    CleanupMachinePkinitCredsMessage = 26,
    AddBindingCacheEntryExMessage = 27,
    QueryBindingCacheMessage = 28,
    PurgeBindingCacheMessage = 29,
    PinKdcMessage = 30,
    UnpinAllKdcsMessage = 31,
    QueryDomainExtendedPoliciesMessage = 32,
    QueryS4U2ProxyCacheMessage = 33,
    RetrieveKeyTabMessage = 34,
};
pub const KerbDebugRequestMessage = KERB_PROTOCOL_MESSAGE_TYPE.DebugRequestMessage;
pub const KerbQueryTicketCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryTicketCacheMessage;
pub const KerbChangeMachinePasswordMessage = KERB_PROTOCOL_MESSAGE_TYPE.ChangeMachinePasswordMessage;
pub const KerbVerifyPacMessage = KERB_PROTOCOL_MESSAGE_TYPE.VerifyPacMessage;
pub const KerbRetrieveTicketMessage = KERB_PROTOCOL_MESSAGE_TYPE.RetrieveTicketMessage;
pub const KerbUpdateAddressesMessage = KERB_PROTOCOL_MESSAGE_TYPE.UpdateAddressesMessage;
pub const KerbPurgeTicketCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.PurgeTicketCacheMessage;
pub const KerbChangePasswordMessage = KERB_PROTOCOL_MESSAGE_TYPE.ChangePasswordMessage;
pub const KerbRetrieveEncodedTicketMessage = KERB_PROTOCOL_MESSAGE_TYPE.RetrieveEncodedTicketMessage;
pub const KerbDecryptDataMessage = KERB_PROTOCOL_MESSAGE_TYPE.DecryptDataMessage;
pub const KerbAddBindingCacheEntryMessage = KERB_PROTOCOL_MESSAGE_TYPE.AddBindingCacheEntryMessage;
pub const KerbSetPasswordMessage = KERB_PROTOCOL_MESSAGE_TYPE.SetPasswordMessage;
pub const KerbSetPasswordExMessage = KERB_PROTOCOL_MESSAGE_TYPE.SetPasswordExMessage;
pub const KerbVerifyCredentialsMessage = KERB_PROTOCOL_MESSAGE_TYPE.VerifyCredentialsMessage;
pub const KerbQueryTicketCacheExMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryTicketCacheExMessage;
pub const KerbPurgeTicketCacheExMessage = KERB_PROTOCOL_MESSAGE_TYPE.PurgeTicketCacheExMessage;
pub const KerbRefreshSmartcardCredentialsMessage = KERB_PROTOCOL_MESSAGE_TYPE.RefreshSmartcardCredentialsMessage;
pub const KerbAddExtraCredentialsMessage = KERB_PROTOCOL_MESSAGE_TYPE.AddExtraCredentialsMessage;
pub const KerbQuerySupplementalCredentialsMessage = KERB_PROTOCOL_MESSAGE_TYPE.QuerySupplementalCredentialsMessage;
pub const KerbTransferCredentialsMessage = KERB_PROTOCOL_MESSAGE_TYPE.TransferCredentialsMessage;
pub const KerbQueryTicketCacheEx2Message = KERB_PROTOCOL_MESSAGE_TYPE.QueryTicketCacheEx2Message;
pub const KerbSubmitTicketMessage = KERB_PROTOCOL_MESSAGE_TYPE.SubmitTicketMessage;
pub const KerbAddExtraCredentialsExMessage = KERB_PROTOCOL_MESSAGE_TYPE.AddExtraCredentialsExMessage;
pub const KerbQueryKdcProxyCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryKdcProxyCacheMessage;
pub const KerbPurgeKdcProxyCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.PurgeKdcProxyCacheMessage;
pub const KerbQueryTicketCacheEx3Message = KERB_PROTOCOL_MESSAGE_TYPE.QueryTicketCacheEx3Message;
pub const KerbCleanupMachinePkinitCredsMessage = KERB_PROTOCOL_MESSAGE_TYPE.CleanupMachinePkinitCredsMessage;
pub const KerbAddBindingCacheEntryExMessage = KERB_PROTOCOL_MESSAGE_TYPE.AddBindingCacheEntryExMessage;
pub const KerbQueryBindingCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryBindingCacheMessage;
pub const KerbPurgeBindingCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.PurgeBindingCacheMessage;
pub const KerbPinKdcMessage = KERB_PROTOCOL_MESSAGE_TYPE.PinKdcMessage;
pub const KerbUnpinAllKdcsMessage = KERB_PROTOCOL_MESSAGE_TYPE.UnpinAllKdcsMessage;
pub const KerbQueryDomainExtendedPoliciesMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryDomainExtendedPoliciesMessage;
pub const KerbQueryS4U2ProxyCacheMessage = KERB_PROTOCOL_MESSAGE_TYPE.QueryS4U2ProxyCacheMessage;
pub const KerbRetrieveKeyTabMessage = KERB_PROTOCOL_MESSAGE_TYPE.RetrieveKeyTabMessage;

pub const KERB_QUERY_TKT_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
};

pub const KERB_TICKET_CACHE_INFO = extern struct {
    ServerName: UNICODE_STRING,
    RealmName: UNICODE_STRING,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    RenewTime: LARGE_INTEGER,
    EncryptionType: i32,
    TicketFlags: KERB_TICKET_FLAGS,
};

pub const KERB_TICKET_CACHE_INFO_EX = extern struct {
    ClientName: UNICODE_STRING,
    ClientRealm: UNICODE_STRING,
    ServerName: UNICODE_STRING,
    ServerRealm: UNICODE_STRING,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    RenewTime: LARGE_INTEGER,
    EncryptionType: i32,
    TicketFlags: u32,
};

pub const KERB_TICKET_CACHE_INFO_EX2 = extern struct {
    ClientName: UNICODE_STRING,
    ClientRealm: UNICODE_STRING,
    ServerName: UNICODE_STRING,
    ServerRealm: UNICODE_STRING,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    RenewTime: LARGE_INTEGER,
    EncryptionType: i32,
    TicketFlags: u32,
    SessionKeyType: u32,
    BranchId: u32,
};

pub const KERB_TICKET_CACHE_INFO_EX3 = extern struct {
    ClientName: UNICODE_STRING,
    ClientRealm: UNICODE_STRING,
    ServerName: UNICODE_STRING,
    ServerRealm: UNICODE_STRING,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    RenewTime: LARGE_INTEGER,
    EncryptionType: i32,
    TicketFlags: u32,
    SessionKeyType: u32,
    BranchId: u32,
    CacheFlags: u32,
    KdcCalled: UNICODE_STRING,
};

pub const KERB_QUERY_TKT_CACHE_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfTickets: u32,
    Tickets: [1]KERB_TICKET_CACHE_INFO,
};

pub const KERB_QUERY_TKT_CACHE_EX_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfTickets: u32,
    Tickets: [1]KERB_TICKET_CACHE_INFO_EX,
};

pub const KERB_QUERY_TKT_CACHE_EX2_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfTickets: u32,
    Tickets: [1]KERB_TICKET_CACHE_INFO_EX2,
};

pub const KERB_QUERY_TKT_CACHE_EX3_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfTickets: u32,
    Tickets: [1]KERB_TICKET_CACHE_INFO_EX3,
};

pub const SecHandle = extern struct {
    dwLower: usize,
    dwUpper: usize,
};

pub const KERB_AUTH_DATA = extern struct {
    Type: u32,
    Length: u32,
    Data: *u8,
};

pub const KERB_NET_ADDRESS = extern struct {
    Family: u32,
    Length: u32,
    Address: [*]u8,
};

pub const KERB_NET_ADDRESSES = extern struct {
    Number: u32,
    Addresses: [1]KERB_NET_ADDRESS,
};

pub const KERB_EXTERNAL_NAME = extern struct {
    NameType: i16,
    NameCount: u16,
    Names: [1]UNICODE_STRING,
};

pub const KERB_EXTERNAL_TICKET = extern struct {
    ServiceName: *KERB_EXTERNAL_NAME,
    TargetName: *KERB_EXTERNAL_NAME,
    ClientName: *KERB_EXTERNAL_NAME,
    DomainName: UNICODE_STRING,
    TargetDomainName: UNICODE_STRING,
    AltTargetDomainName: UNICODE_STRING,
    SessionKey: KERB_CRYPTO_KEY,
    TicketFlags: KERB_TICKET_FLAGS,
    Flags: u32,
    KeyExpirationTime: LARGE_INTEGER,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    RenewUntil: LARGE_INTEGER,
    TimeSkew: LARGE_INTEGER,
    EncodedTicketSize: u32,
    EncodedTicket: *u8,
};

pub const KERB_RETRIEVE_TKT_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    TargetName: UNICODE_STRING,
    TicketFlags: u32,
    CacheOptions: u32,
    EncryptionType: KERB_CRYPTO_KEY_TYPE,
    CredentialsHandle: SecHandle,
};

pub const KERB_RETRIEVE_TKT_RESPONSE = extern struct {
    Ticket: KERB_EXTERNAL_TICKET,
};

pub const KERB_PURGE_TKT_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    ServerName: UNICODE_STRING,
    RealmName: UNICODE_STRING,
};

pub const KERB_PURGE_TKT_CACHE_EX_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    Flags: u32,
    TicketTemplate: KERB_TICKET_CACHE_INFO_EX,
};

pub const KERB_SUBMIT_TKT_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    Flags: u32,
    Key: KERB_CRYPTO_KEY32,
    KerbCredSize: u32,
    KerbCredOffset: u32,
};

pub const KERB_QUERY_KDC_PROXY_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    LogonId: LUID,
};

pub const KDC_PROXY_CACHE_ENTRY_DATA = extern struct {
    SinceLastUsed: u64,
    DomainName: UNICODE_STRING,
    ProxyServerName: UNICODE_STRING,
    ProxyServerVdir: UNICODE_STRING,
    ProxyServerPort: u16,
    LogonId: LUID,
    CredUserName: UNICODE_STRING,
    CredDomainName: UNICODE_STRING,
    GlobalCache: u8,
};

pub const KERB_QUERY_KDC_PROXY_CACHE_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfEntries: u32,
    Entries: *KDC_PROXY_CACHE_ENTRY_DATA,
};

pub const KERB_PURGE_KDC_PROXY_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    LogonId: LUID,
};

pub const KERB_PURGE_KDC_PROXY_CACHE_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfPurged: u32,
};

pub const KERB_S4U2PROXY_CACHE_ENTRY_INFO = extern struct {
    ServerName: UNICODE_STRING,
    Flags: u32,
    LastStatus: NTSTATUS,
    Expiry: LARGE_INTEGER,
};

pub const KERB_S4U2PROXY_CRED = extern struct {
    UserName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    Flags: u32,
    LastStatus: NTSTATUS,
    Expiry: LARGE_INTEGER,
    CountOfEntries: u32,
    Entries: *KERB_S4U2PROXY_CACHE_ENTRY_INFO,
};

pub const KERB_QUERY_S4U2PROXY_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    LogonId: LUID,
};

pub const KERB_QUERY_S4U2PROXY_CACHE_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfCreds: u32,
    Creds: *KERB_S4U2PROXY_CRED,
};

pub const KERB_RETRIEVE_KEY_TAB_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    UserName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    Password: UNICODE_STRING,
};

pub const KERB_RETRIEVE_KEY_TAB_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    KeyTabLength: u32,
    KeyTab: *u8,
};

pub const KERB_CHANGEPASSWORD_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    DomainName: UNICODE_STRING,
    AccountName: UNICODE_STRING,
    OldPassword: UNICODE_STRING,
    NewPassword: UNICODE_STRING,
    Impersonating: u8,
};

pub const KERB_SETPASSWORD_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    CredentialsHandle: SecHandle,
    Flags: u32,
    DomainName: UNICODE_STRING,
    AccountName: UNICODE_STRING,
    Password: UNICODE_STRING,
};

pub const KERB_SETPASSWORD_EX_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    CredentialsHandle: SecHandle,
    Flags: u32,
    AccountRealm: UNICODE_STRING,
    AccountName: UNICODE_STRING,
    Password: UNICODE_STRING,
    ClientRealm: UNICODE_STRING,
    ClientName: UNICODE_STRING,
    Impersonating: u8,
    KdcAddress: UNICODE_STRING,
    KdcAddressType: u32,
};

pub const KERB_DECRYPT_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
    Flags: u32,
    CryptoType: i32,
    KeyUsage: i32,
    Key: KERB_CRYPTO_KEY,
    EncryptedDataSize: u32,
    InitialVectorSize: u32,
    InitialVector: *u8,
    EncryptedData: *u8,
};

pub const KERB_DECRYPT_RESPONSE = extern struct {
    DecryptedData: [1]u8,
};

pub const KERB_ADD_BINDING_CACHE_ENTRY_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    RealmName: UNICODE_STRING,
    KdcAddress: UNICODE_STRING,
    AddressType: KERB_ADDRESS_TYPE,
};

pub const KERB_REFRESH_SCCRED_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CredentialBlob: UNICODE_STRING,
    LogonId: LUID,
    Flags: u32,
};

pub const KERB_ADD_CREDENTIALS_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    UserName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    Password: UNICODE_STRING,
    LogonId: LUID,
    Flags: KERB_REQUEST_FLAGS,
};

pub const KERB_ADD_CREDENTIALS_REQUEST_EX = extern struct {
    Credentials: KERB_ADD_CREDENTIALS_REQUEST,
    PrincipalNameCount: u32,
    PrincipalNames: [1]UNICODE_STRING,
};

pub const KERB_TRANSFER_CRED_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    OriginLogonId: LUID,
    DestinationLogonId: LUID,
    Flags: u32,
};

pub const KERB_CLEANUP_MACHINE_PKINIT_CREDS_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    LogonId: LUID,
};

pub const KERB_BINDING_CACHE_ENTRY_DATA = extern struct {
    DiscoveryTime: u64,
    RealmName: UNICODE_STRING,
    KdcAddress: UNICODE_STRING,
    AddressType: KERB_ADDRESS_TYPE,
    Flags: u32,
    DcFlags: u32,
    CacheFlags: u32,
    KdcName: UNICODE_STRING,
};

pub const KERB_QUERY_BINDING_CACHE_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    CountOfEntries: u32,
    Entries: *KERB_BINDING_CACHE_ENTRY_DATA,
};

pub const KERB_ADD_BINDING_CACHE_ENTRY_EX_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    RealmName: UNICODE_STRING,
    KdcAddress: UNICODE_STRING,
    AddressType: KERB_ADDRESS_TYPE,
    DcFlags: u32,
};

pub const KERB_QUERY_BINDING_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
};

pub const KERB_PURGE_BINDING_CACHE_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
};

pub const KERB_QUERY_DOMAIN_EXTENDED_POLICIES_REQUEST = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    DomainName: UNICODE_STRING,
};

pub const KERB_QUERY_DOMAIN_EXTENDED_POLICIES_RESPONSE = extern struct {
    MessageType: KERB_PROTOCOL_MESSAGE_TYPE,
    Flags: u32,
    ExtendedPolicies: u32,
    DsFlags: u32,
};

pub const KERB_CERTIFICATE_INFO_TYPE = extern enum(i32) {
    o = 1,
};
pub const CertHashInfo = KERB_CERTIFICATE_INFO_TYPE.o;

pub const KERB_CERTIFICATE_HASHINFO = extern struct {
    StoreNameLength: u16,
    HashLength: u16,
};

pub const KERB_CERTIFICATE_INFO = extern struct {
    CertInfoSize: u32,
    InfoType: u32,
};

pub const POLICY_AUDIT_SID_ARRAY = extern struct {
    UsersCount: u32,
    UserSidArray: *PSID,
};

pub const AUDIT_POLICY_INFORMATION = extern struct {
    AuditSubCategoryGuid: Guid,
    AuditingInformation: u32,
    AuditCategoryGuid: Guid,
};

pub const PKU2U_CERT_BLOB = extern struct {
    CertOffset: u32,
    CertLength: u16,
};

pub const PKU2U_CREDUI_CONTEXT = extern struct {
    Version: u64,
    cbHeaderLength: u16,
    cbStructureLength: u32,
    CertArrayCount: u16,
    CertArrayOffset: u32,
};

pub const PKU2U_LOGON_SUBMIT_TYPE = extern enum(i32) {
    n = 14,
};
pub const Pku2uCertificateS4ULogon = PKU2U_LOGON_SUBMIT_TYPE.n;

pub const PKU2U_CERTIFICATE_S4U_LOGON = extern struct {
    MessageType: PKU2U_LOGON_SUBMIT_TYPE,
    Flags: u32,
    UserPrincipalName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    CertificateLength: u32,
    Certificate: *u8,
};

pub const SecPkgInfoW = extern struct {
    fCapabilities: u32,
    wVersion: u16,
    wRPCID: u16,
    cbMaxToken: u32,
    Name: *u16,
    Comment: *u16,
};

pub const SecPkgInfoA = extern struct {
    fCapabilities: u32,
    wVersion: u16,
    wRPCID: u16,
    cbMaxToken: u32,
    Name: *i8,
    Comment: *i8,
};

pub const SecBuffer = extern struct {
    cbBuffer: u32,
    BufferType: u32,
    pvBuffer: *c_void,
};

pub const SecBufferDesc = extern struct {
    ulVersion: u32,
    cBuffers: u32,
    pBuffers: *SecBuffer,
};

pub const SEC_NEGOTIATION_INFO = extern struct {
    Size: u32,
    NameLength: u32,
    Name: *u16,
    Reserved: *c_void,
};

pub const SEC_CHANNEL_BINDINGS = extern struct {
    dwInitiatorAddrType: u32,
    cbInitiatorLength: u32,
    dwInitiatorOffset: u32,
    dwAcceptorAddrType: u32,
    cbAcceptorLength: u32,
    dwAcceptorOffset: u32,
    cbApplicationDataLength: u32,
    dwApplicationDataOffset: u32,
};

pub const SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = extern enum(i32) {
    None = 0,
    NPN = 1,
    ALPN = 2,
};
pub const SecApplicationProtocolNegotiationExt_None = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT.None;
pub const SecApplicationProtocolNegotiationExt_NPN = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT.NPN;
pub const SecApplicationProtocolNegotiationExt_ALPN = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT.ALPN;

pub const SEC_APPLICATION_PROTOCOL_LIST = extern struct {
    ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT,
    ProtocolListSize: u16,
    ProtocolList: [1]u8,
};

pub const SEC_APPLICATION_PROTOCOLS = extern struct {
    ProtocolListsSize: u32,
    ProtocolLists: [1]SEC_APPLICATION_PROTOCOL_LIST,
};

pub const SEC_SRTP_PROTECTION_PROFILES = extern struct {
    ProfilesSize: u16,
    ProfilesList: [1]u16,
};

pub const SEC_SRTP_MASTER_KEY_IDENTIFIER = extern struct {
    MasterKeyIdentifierSize: u8,
    MasterKeyIdentifier: [1]u8,
};

pub const SEC_TOKEN_BINDING = extern struct {
    MajorVersion: u8,
    MinorVersion: u8,
    KeyParametersSize: u16,
    KeyParameters: [1]u8,
};

pub const SEC_PRESHAREDKEY = extern struct {
    KeySize: u16,
    Key: [1]u8,
};

pub const SEC_PRESHAREDKEY_IDENTITY = extern struct {
    KeyIdentitySize: u16,
    KeyIdentity: [1]u8,
};

pub const SEC_DTLS_MTU = extern struct {
    PathMTU: u16,
};

pub const SEC_FLAGS = extern struct {
    Flags: u64,
};

pub const SEC_TRAFFIC_SECRET_TYPE = extern enum(i32) {
    None = 0,
    Client = 1,
    Server = 2,
};
pub const SecTrafficSecret_None = SEC_TRAFFIC_SECRET_TYPE.None;
pub const SecTrafficSecret_Client = SEC_TRAFFIC_SECRET_TYPE.Client;
pub const SecTrafficSecret_Server = SEC_TRAFFIC_SECRET_TYPE.Server;

pub const SEC_TRAFFIC_SECRETS = extern struct {
    SymmetricAlgId: [64]u16,
    ChainingMode: [64]u16,
    HashAlgId: [64]u16,
    KeySize: u16,
    IvSize: u16,
    MsgSequenceStart: u16,
    MsgSequenceEnd: u16,
    TrafficSecretType: SEC_TRAFFIC_SECRET_TYPE,
    TrafficSecretSize: u16,
    TrafficSecret: [1]u8,
};

pub const SecPkgCredentials_NamesW = extern struct {
    sUserName: *u16,
};

pub const SecPkgCredentials_NamesA = extern struct {
    sUserName: *i8,
};

pub const SecPkgCredentials_SSIProviderW = extern struct {
    sProviderName: *u16,
    ProviderInfoLength: u32,
    ProviderInfo: PSTR,
};

pub const SecPkgCredentials_SSIProviderA = extern struct {
    sProviderName: *i8,
    ProviderInfoLength: u32,
    ProviderInfo: PSTR,
};

pub const SecPkgCredentials_KdcProxySettingsW = extern struct {
    Version: u32,
    Flags: u32,
    ProxyServerOffset: u16,
    ProxyServerLength: u16,
    ClientTlsCredOffset: u16,
    ClientTlsCredLength: u16,
};

pub const SecPkgCredentials_Cert = extern struct {
    EncodedCertSize: u32,
    EncodedCert: *u8,
};

pub const SecPkgContext_SubjectAttributes = extern struct {
    AttributeInfo: *c_void,
};

pub const SECPKG_CRED_CLASS = extern enum(i32) {
    None = 0,
    Ephemeral = 10,
    PersistedGeneric = 20,
    PersistedSpecific = 30,
    Explicit = 40,
};
pub const SecPkgCredClass_None = SECPKG_CRED_CLASS.None;
pub const SecPkgCredClass_Ephemeral = SECPKG_CRED_CLASS.Ephemeral;
pub const SecPkgCredClass_PersistedGeneric = SECPKG_CRED_CLASS.PersistedGeneric;
pub const SecPkgCredClass_PersistedSpecific = SECPKG_CRED_CLASS.PersistedSpecific;
pub const SecPkgCredClass_Explicit = SECPKG_CRED_CLASS.Explicit;

pub const SecPkgContext_CredInfo = extern struct {
    CredClass: SECPKG_CRED_CLASS,
    IsPromptingNeeded: u32,
};

pub const SecPkgContext_NegoPackageInfo = extern struct {
    PackageMask: u32,
};

pub const SecPkgContext_NegoStatus = extern struct {
    LastStatus: u32,
};

pub const SecPkgContext_Sizes = extern struct {
    cbMaxToken: u32,
    cbMaxSignature: u32,
    cbBlockSize: u32,
    cbSecurityTrailer: u32,
};

pub const SecPkgContext_StreamSizes = extern struct {
    cbHeader: u32,
    cbTrailer: u32,
    cbMaximumMessage: u32,
    cBuffers: u32,
    cbBlockSize: u32,
};

pub const SecPkgContext_NamesW = extern struct {
    sUserName: *u16,
};

pub const SECPKG_ATTR_LCT_STATUS = extern enum(i32) {
    Yes = 0,
    No = 1,
    Maybe = 2,
};
pub const SecPkgAttrLastClientTokenYes = SECPKG_ATTR_LCT_STATUS.Yes;
pub const SecPkgAttrLastClientTokenNo = SECPKG_ATTR_LCT_STATUS.No;
pub const SecPkgAttrLastClientTokenMaybe = SECPKG_ATTR_LCT_STATUS.Maybe;

pub const SecPkgContext_LastClientTokenStatus = extern struct {
    LastClientTokenStatus: SECPKG_ATTR_LCT_STATUS,
};

pub const SecPkgContext_NamesA = extern struct {
    sUserName: *i8,
};

pub const SecPkgContext_Lifespan = extern struct {
    tsStart: LARGE_INTEGER,
    tsExpiry: LARGE_INTEGER,
};

pub const SecPkgContext_DceInfo = extern struct {
    AuthzSvc: u32,
    pPac: *c_void,
};

pub const SecPkgContext_KeyInfoA = extern struct {
    sSignatureAlgorithmName: *i8,
    sEncryptAlgorithmName: *i8,
    KeySize: u32,
    SignatureAlgorithm: u32,
    EncryptAlgorithm: u32,
};

pub const SecPkgContext_KeyInfoW = extern struct {
    sSignatureAlgorithmName: *u16,
    sEncryptAlgorithmName: *u16,
    KeySize: u32,
    SignatureAlgorithm: u32,
    EncryptAlgorithm: u32,
};

pub const SecPkgContext_AuthorityA = extern struct {
    sAuthorityName: *i8,
};

pub const SecPkgContext_AuthorityW = extern struct {
    sAuthorityName: *u16,
};

pub const SecPkgContext_ProtoInfoA = extern struct {
    sProtocolName: *i8,
    majorVersion: u32,
    minorVersion: u32,
};

pub const SecPkgContext_ProtoInfoW = extern struct {
    sProtocolName: *u16,
    majorVersion: u32,
    minorVersion: u32,
};

pub const SecPkgContext_PasswordExpiry = extern struct {
    tsPasswordExpires: LARGE_INTEGER,
};

pub const SecPkgContext_LogoffTime = extern struct {
    tsLogoffTime: LARGE_INTEGER,
};

pub const SecPkgContext_SessionKey = extern struct {
    SessionKeyLength: u32,
    SessionKey: *u8,
};

pub const SecPkgContext_NegoKeys = extern struct {
    KeyType: u32,
    KeyLength: u16,
    KeyValue: *u8,
    VerifyKeyType: u32,
    VerifyKeyLength: u16,
    VerifyKeyValue: *u8,
};

pub const SecPkgContext_PackageInfoW = extern struct {
    PackageInfo: *SecPkgInfoW,
};

pub const SecPkgContext_PackageInfoA = extern struct {
    PackageInfo: *SecPkgInfoA,
};

pub const SecPkgContext_UserFlags = extern struct {
    UserFlags: u32,
};

pub const SecPkgContext_Flags = extern struct {
    Flags: u32,
};

pub const SecPkgContext_NegotiationInfoA = extern struct {
    PackageInfo: *SecPkgInfoA,
    NegotiationState: u32,
};

pub const SecPkgContext_NegotiationInfoW = extern struct {
    PackageInfo: *SecPkgInfoW,
    NegotiationState: u32,
};

pub const SecPkgContext_NativeNamesW = extern struct {
    sClientName: *u16,
    sServerName: *u16,
};

pub const SecPkgContext_NativeNamesA = extern struct {
    sClientName: *i8,
    sServerName: *i8,
};

pub const SecPkgContext_CredentialNameW = extern struct {
    CredentialType: u32,
    sCredentialName: *u16,
};

pub const SecPkgContext_CredentialNameA = extern struct {
    CredentialType: u32,
    sCredentialName: *i8,
};

pub const SecPkgContext_AccessToken = extern struct {
    AccessToken: *c_void,
};

pub const SecPkgContext_TargetInformation = extern struct {
    MarshalledTargetInfoLength: u32,
    MarshalledTargetInfo: *u8,
};

pub const SecPkgContext_AuthzID = extern struct {
    AuthzIDLength: u32,
    AuthzID: PSTR,
};

pub const SecPkgContext_Target = extern struct {
    TargetLength: u32,
    Target: PSTR,
};

pub const SecPkgContext_ClientSpecifiedTarget = extern struct {
    sTargetName: *u16,
};

pub const SecPkgContext_Bindings = extern struct {
    BindingsLength: u32,
    Bindings: *SEC_CHANNEL_BINDINGS,
};

pub const SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS = extern enum(i32) {
    None = 0,
    Success = 1,
    SelectedClientOnly = 2,
};
pub const SecApplicationProtocolNegotiationStatus_None = SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS.None;
pub const SecApplicationProtocolNegotiationStatus_Success = SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS.Success;
pub const SecApplicationProtocolNegotiationStatus_SelectedClientOnly = SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS.SelectedClientOnly;

pub const SecPkgContext_ApplicationProtocol = extern struct {
    ProtoNegoStatus: SEC_APPLICATION_PROTOCOL_NEGOTIATION_STATUS,
    ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT,
    ProtocolIdSize: u8,
    ProtocolId: [255]u8,
};

pub const SecPkgContext_NegotiatedTlsExtensions = extern struct {
    ExtensionsCount: u32,
    Extensions: *u16,
};

pub const SECPKG_APP_MODE_INFO = extern struct {
    UserFunction: u32,
    Argument1: usize,
    Argument2: usize,
    UserData: SecBuffer,
    ReturnToLsa: u8,
};

pub const SEC_GET_KEY_FN = fn(
    Arg: *c_void,
    Principal: *c_void,
    KeyVer: u32,
    Key: **c_void,
    Status: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const ACQUIRE_CREDENTIALS_HANDLE_FN_W = fn(
    param0: *u16,
    param1: *u16,
    param2: u32,
    param3: *c_void,
    param4: *c_void,
    param5: SEC_GET_KEY_FN,
    param6: *c_void,
    param7: *SecHandle,
    param8: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ACQUIRE_CREDENTIALS_HANDLE_FN_A = fn(
    param0: *i8,
    param1: *i8,
    param2: u32,
    param3: *c_void,
    param4: *c_void,
    param5: SEC_GET_KEY_FN,
    param6: *c_void,
    param7: *SecHandle,
    param8: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const FREE_CREDENTIALS_HANDLE_FN = fn(
    param0: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ADD_CREDENTIALS_FN_W = fn(
    param0: *SecHandle,
    param1: *u16,
    param2: *u16,
    param3: u32,
    param4: *c_void,
    param5: SEC_GET_KEY_FN,
    param6: *c_void,
    param7: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ADD_CREDENTIALS_FN_A = fn(
    param0: *SecHandle,
    param1: *i8,
    param2: *i8,
    param3: u32,
    param4: *c_void,
    param5: SEC_GET_KEY_FN,
    param6: *c_void,
    param7: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHANGE_PASSWORD_FN_W = fn(
    param0: *u16,
    param1: *u16,
    param2: *u16,
    param3: *u16,
    param4: *u16,
    param5: u8,
    param6: u32,
    param7: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHANGE_PASSWORD_FN_A = fn(
    param0: *i8,
    param1: *i8,
    param2: *i8,
    param3: *i8,
    param4: *i8,
    param5: u8,
    param6: u32,
    param7: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INITIALIZE_SECURITY_CONTEXT_FN_W = fn(
    param0: *SecHandle,
    param1: *SecHandle,
    param2: *u16,
    param3: u32,
    param4: u32,
    param5: u32,
    param6: *SecBufferDesc,
    param7: u32,
    param8: *SecHandle,
    param9: *SecBufferDesc,
    param10: *u32,
    param11: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INITIALIZE_SECURITY_CONTEXT_FN_A = fn(
    param0: *SecHandle,
    param1: *SecHandle,
    param2: *i8,
    param3: u32,
    param4: u32,
    param5: u32,
    param6: *SecBufferDesc,
    param7: u32,
    param8: *SecHandle,
    param9: *SecBufferDesc,
    param10: *u32,
    param11: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ACCEPT_SECURITY_CONTEXT_FN = fn(
    param0: *SecHandle,
    param1: *SecHandle,
    param2: *SecBufferDesc,
    param3: u32,
    param4: u32,
    param5: *SecHandle,
    param6: *SecBufferDesc,
    param7: *u32,
    param8: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const COMPLETE_AUTH_TOKEN_FN = fn(
    param0: *SecHandle,
    param1: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMPERSONATE_SECURITY_CONTEXT_FN = fn(
    param0: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const REVERT_SECURITY_CONTEXT_FN = fn(
    param0: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_SECURITY_CONTEXT_TOKEN_FN = fn(
    param0: *SecHandle,
    param1: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DELETE_SECURITY_CONTEXT_FN = fn(
    param0: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const APPLY_CONTROL_TOKEN_FN = fn(
    param0: *SecHandle,
    param1: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CONTEXT_ATTRIBUTES_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CONTEXT_ATTRIBUTES_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SET_CONTEXT_ATTRIBUTES_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SET_CONTEXT_ATTRIBUTES_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SET_CREDENTIALS_ATTRIBUTES_FN_W = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SET_CREDENTIALS_ATTRIBUTES_FN_A = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *c_void,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const FREE_CONTEXT_BUFFER_FN = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const MAKE_SIGNATURE_FN = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *SecBufferDesc,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VERIFY_SIGNATURE_FN = fn(
    param0: *SecHandle,
    param1: *SecBufferDesc,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENCRYPT_MESSAGE_FN = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *SecBufferDesc,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DECRYPT_MESSAGE_FN = fn(
    param0: *SecHandle,
    param1: *SecBufferDesc,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENUMERATE_SECURITY_PACKAGES_FN_W = fn(
    param0: *u32,
    param1: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENUMERATE_SECURITY_PACKAGES_FN_A = fn(
    param0: *u32,
    param1: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_SECURITY_PACKAGE_INFO_FN_W = fn(
    param0: *u16,
    param1: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const QUERY_SECURITY_PACKAGE_INFO_FN_A = fn(
    param0: *i8,
    param1: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SecDelegationType = extern enum(i32) {
    Full = 0,
    Service = 1,
    Tree = 2,
    Directory = 3,
    Object = 4,
};
pub const SecFull = SecDelegationType.Full;
pub const SecService = SecDelegationType.Service;
pub const SecTree = SecDelegationType.Tree;
pub const SecDirectory = SecDelegationType.Directory;
pub const SecObject = SecDelegationType.Object;

pub const EXPORT_SECURITY_CONTEXT_FN = fn(
    param0: *SecHandle,
    param1: u32,
    param2: *SecBuffer,
    param3: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMPORT_SECURITY_CONTEXT_FN_W = fn(
    param0: *u16,
    param1: *SecBuffer,
    param2: *c_void,
    param3: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMPORT_SECURITY_CONTEXT_FN_A = fn(
    param0: *i8,
    param1: *SecBuffer,
    param2: *c_void,
    param3: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SecurityFunctionTableW = extern struct {
    dwVersion: u32,
    EnumerateSecurityPackagesW: ENUMERATE_SECURITY_PACKAGES_FN_W,
    QueryCredentialsAttributesW: QUERY_CREDENTIALS_ATTRIBUTES_FN_W,
    AcquireCredentialsHandleW: ACQUIRE_CREDENTIALS_HANDLE_FN_W,
    FreeCredentialsHandle: FREE_CREDENTIALS_HANDLE_FN,
    Reserved2: *c_void,
    InitializeSecurityContextW: INITIALIZE_SECURITY_CONTEXT_FN_W,
    AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN,
    CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN,
    DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN,
    ApplyControlToken: APPLY_CONTROL_TOKEN_FN,
    QueryContextAttributesW: QUERY_CONTEXT_ATTRIBUTES_FN_W,
    ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN,
    RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN,
    MakeSignature: MAKE_SIGNATURE_FN,
    VerifySignature: VERIFY_SIGNATURE_FN,
    FreeContextBuffer: FREE_CONTEXT_BUFFER_FN,
    QuerySecurityPackageInfoW: QUERY_SECURITY_PACKAGE_INFO_FN_W,
    Reserved3: *c_void,
    Reserved4: *c_void,
    ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN,
    ImportSecurityContextW: IMPORT_SECURITY_CONTEXT_FN_W,
    AddCredentialsW: ADD_CREDENTIALS_FN_W,
    Reserved8: *c_void,
    QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN,
    EncryptMessage: ENCRYPT_MESSAGE_FN,
    DecryptMessage: DECRYPT_MESSAGE_FN,
    SetContextAttributesW: SET_CONTEXT_ATTRIBUTES_FN_W,
    SetCredentialsAttributesW: SET_CREDENTIALS_ATTRIBUTES_FN_W,
    ChangeAccountPasswordW: CHANGE_PASSWORD_FN_W,
    QueryContextAttributesExW: QUERY_CONTEXT_ATTRIBUTES_EX_FN_W,
    QueryCredentialsAttributesExW: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W,
};

pub const SecurityFunctionTableA = extern struct {
    dwVersion: u32,
    EnumerateSecurityPackagesA: ENUMERATE_SECURITY_PACKAGES_FN_A,
    QueryCredentialsAttributesA: QUERY_CREDENTIALS_ATTRIBUTES_FN_A,
    AcquireCredentialsHandleA: ACQUIRE_CREDENTIALS_HANDLE_FN_A,
    FreeCredentialsHandle: FREE_CREDENTIALS_HANDLE_FN,
    Reserved2: *c_void,
    InitializeSecurityContextA: INITIALIZE_SECURITY_CONTEXT_FN_A,
    AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN,
    CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN,
    DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN,
    ApplyControlToken: APPLY_CONTROL_TOKEN_FN,
    QueryContextAttributesA: QUERY_CONTEXT_ATTRIBUTES_FN_A,
    ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN,
    RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN,
    MakeSignature: MAKE_SIGNATURE_FN,
    VerifySignature: VERIFY_SIGNATURE_FN,
    FreeContextBuffer: FREE_CONTEXT_BUFFER_FN,
    QuerySecurityPackageInfoA: QUERY_SECURITY_PACKAGE_INFO_FN_A,
    Reserved3: *c_void,
    Reserved4: *c_void,
    ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN,
    ImportSecurityContextA: IMPORT_SECURITY_CONTEXT_FN_A,
    AddCredentialsA: ADD_CREDENTIALS_FN_A,
    Reserved8: *c_void,
    QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN,
    EncryptMessage: ENCRYPT_MESSAGE_FN,
    DecryptMessage: DECRYPT_MESSAGE_FN,
    SetContextAttributesA: SET_CONTEXT_ATTRIBUTES_FN_A,
    SetCredentialsAttributesA: SET_CREDENTIALS_ATTRIBUTES_FN_A,
    ChangeAccountPasswordA: CHANGE_PASSWORD_FN_A,
    QueryContextAttributesExA: QUERY_CONTEXT_ATTRIBUTES_EX_FN_A,
    QueryCredentialsAttributesExA: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A,
};

pub const INIT_SECURITY_INTERFACE_A = fn(
) callconv(@import("std").os.windows.WINAPI) *SecurityFunctionTableA;

pub const INIT_SECURITY_INTERFACE_W = fn(
) callconv(@import("std").os.windows.WINAPI) *SecurityFunctionTableW;

pub const SASL_AUTHZID_STATE = extern enum(i32) {
    Forbidden = 0,
    Processed = 1,
};
pub const Sasl_AuthZIDForbidden = SASL_AUTHZID_STATE.Forbidden;
pub const Sasl_AuthZIDProcessed = SASL_AUTHZID_STATE.Processed;

pub const SEC_WINNT_AUTH_IDENTITY_EX2 = extern struct {
    Version: u32,
    cbHeaderLength: u16,
    cbStructureLength: u32,
    UserOffset: u32,
    UserLength: u16,
    DomainOffset: u32,
    DomainLength: u16,
    PackedCredentialsOffset: u32,
    PackedCredentialsLength: u16,
    Flags: u32,
    PackageListOffset: u32,
    PackageListLength: u16,
};

pub const SEC_WINNT_AUTH_IDENTITY_EXW = extern struct {
    Version: u32,
    Length: u32,
    User: *u16,
    UserLength: u32,
    Domain: *u16,
    DomainLength: u32,
    Password: *u16,
    PasswordLength: u32,
    Flags: u32,
    PackageList: *u16,
    PackageListLength: u32,
};

pub const SEC_WINNT_AUTH_IDENTITY_EXA = extern struct {
    Version: u32,
    Length: u32,
    User: *u8,
    UserLength: u32,
    Domain: *u8,
    DomainLength: u32,
    Password: *u8,
    PasswordLength: u32,
    Flags: u32,
    PackageList: *u8,
    PackageListLength: u32,
};

pub const SEC_WINNT_AUTH_IDENTITY_INFO = extern union {
    AuthIdExw: SEC_WINNT_AUTH_IDENTITY_EXW,
    AuthIdExa: SEC_WINNT_AUTH_IDENTITY_EXA,
    AuthId_a: SEC_WINNT_AUTH_IDENTITY_A,
    AuthId_w: SEC_WINNT_AUTH_IDENTITY_W,
    AuthIdEx2: SEC_WINNT_AUTH_IDENTITY_EX2,
};

pub const SECURITY_PACKAGE_OPTIONS = extern struct {
    Size: u32,
    Type: SECURITY_PACKAGE_OPTIONS_TYPE,
    Flags: u32,
    SignatureSize: u32,
    Signature: *c_void,
};

pub const CREDENTIAL_ATTRIBUTEA = extern struct {
    Keyword: PSTR,
    Flags: u32,
    ValueSize: u32,
    Value: *u8,
};

pub const CREDENTIAL_ATTRIBUTEW = extern struct {
    Keyword: PWSTR,
    Flags: u32,
    ValueSize: u32,
    Value: *u8,
};

pub const CREDENTIALA = extern struct {
    Flags: CRED_FLAGS,
    Type: CRED_TYPE,
    TargetName: PSTR,
    Comment: PSTR,
    LastWritten: FILETIME,
    CredentialBlobSize: u32,
    CredentialBlob: *u8,
    Persist: CRED_PERSIST,
    AttributeCount: u32,
    Attributes: *CREDENTIAL_ATTRIBUTEA,
    TargetAlias: PSTR,
    UserName: PSTR,
};

pub const CREDENTIALW = extern struct {
    Flags: CRED_FLAGS,
    Type: CRED_TYPE,
    TargetName: PWSTR,
    Comment: PWSTR,
    LastWritten: FILETIME,
    CredentialBlobSize: u32,
    CredentialBlob: *u8,
    Persist: CRED_PERSIST,
    AttributeCount: u32,
    Attributes: *CREDENTIAL_ATTRIBUTEW,
    TargetAlias: PWSTR,
    UserName: PWSTR,
};

pub const CREDENTIAL_TARGET_INFORMATIONA = extern struct {
    TargetName: PSTR,
    NetbiosServerName: PSTR,
    DnsServerName: PSTR,
    NetbiosDomainName: PSTR,
    DnsDomainName: PSTR,
    DnsTreeName: PSTR,
    PackageName: PSTR,
    Flags: u32,
    CredTypeCount: u32,
    CredTypes: *u32,
};

pub const CREDENTIAL_TARGET_INFORMATIONW = extern struct {
    TargetName: PWSTR,
    NetbiosServerName: PWSTR,
    DnsServerName: PWSTR,
    NetbiosDomainName: PWSTR,
    DnsDomainName: PWSTR,
    DnsTreeName: PWSTR,
    PackageName: PWSTR,
    Flags: u32,
    CredTypeCount: u32,
    CredTypes: *u32,
};

pub const CERT_CREDENTIAL_INFO = extern struct {
    cbSize: u32,
    rgbHashOfCert: [20]u8,
};

pub const USERNAME_TARGET_CREDENTIAL_INFO = extern struct {
    UserName: PWSTR,
};

pub const BINARY_BLOB_CREDENTIAL_INFO = extern struct {
    cbBlob: u32,
    pbBlob: *u8,
};

pub const CRED_MARSHAL_TYPE = extern enum(i32) {
    CertCredential = 1,
    UsernameTargetCredential = 2,
    BinaryBlobCredential = 3,
    UsernameForPackedCredentials = 4,
    BinaryBlobForSystem = 5,
};
pub const CertCredential = CRED_MARSHAL_TYPE.CertCredential;
pub const UsernameTargetCredential = CRED_MARSHAL_TYPE.UsernameTargetCredential;
pub const BinaryBlobCredential = CRED_MARSHAL_TYPE.BinaryBlobCredential;
pub const UsernameForPackedCredentials = CRED_MARSHAL_TYPE.UsernameForPackedCredentials;
pub const BinaryBlobForSystem = CRED_MARSHAL_TYPE.BinaryBlobForSystem;

pub const CRED_PROTECTION_TYPE = extern enum(i32) {
    Unprotected = 0,
    UserProtection = 1,
    TrustedProtection = 2,
    ForSystemProtection = 3,
};
pub const CredUnprotected = CRED_PROTECTION_TYPE.Unprotected;
pub const CredUserProtection = CRED_PROTECTION_TYPE.UserProtection;
pub const CredTrustedProtection = CRED_PROTECTION_TYPE.TrustedProtection;
pub const CredForSystemProtection = CRED_PROTECTION_TYPE.ForSystemProtection;

pub const CREDUI_INFOA = extern struct {
    cbSize: u32,
    hwndParent: HWND,
    pszMessageText: [*:0]const u8,
    pszCaptionText: [*:0]const u8,
    hbmBanner: HBITMAP,
};

pub const CREDUI_INFOW = extern struct {
    cbSize: u32,
    hwndParent: HWND,
    pszMessageText: [*:0]const u16,
    pszCaptionText: [*:0]const u16,
    hbmBanner: HBITMAP,
};

pub const LSA_TOKEN_INFORMATION_TYPE = extern enum(i32) {
    Null = 0,
    V1 = 1,
    V2 = 2,
    V3 = 3,
};
pub const LsaTokenInformationNull = LSA_TOKEN_INFORMATION_TYPE.Null;
pub const LsaTokenInformationV1 = LSA_TOKEN_INFORMATION_TYPE.V1;
pub const LsaTokenInformationV2 = LSA_TOKEN_INFORMATION_TYPE.V2;
pub const LsaTokenInformationV3 = LSA_TOKEN_INFORMATION_TYPE.V3;

pub const LSA_TOKEN_INFORMATION_NULL = extern struct {
    ExpirationTime: LARGE_INTEGER,
    Groups: *TOKEN_GROUPS,
};

pub const LSA_TOKEN_INFORMATION_V1 = extern struct {
    ExpirationTime: LARGE_INTEGER,
    User: TOKEN_USER,
    Groups: *TOKEN_GROUPS,
    PrimaryGroup: TOKEN_PRIMARY_GROUP,
    Privileges: *TOKEN_PRIVILEGES,
    Owner: TOKEN_OWNER,
    DefaultDacl: TOKEN_DEFAULT_DACL,
};

pub const LSA_TOKEN_INFORMATION_V3 = extern struct {
    ExpirationTime: LARGE_INTEGER,
    User: TOKEN_USER,
    Groups: *TOKEN_GROUPS,
    PrimaryGroup: TOKEN_PRIMARY_GROUP,
    Privileges: *TOKEN_PRIVILEGES,
    Owner: TOKEN_OWNER,
    DefaultDacl: TOKEN_DEFAULT_DACL,
    UserClaims: TOKEN_USER_CLAIMS,
    DeviceClaims: TOKEN_DEVICE_CLAIMS,
    DeviceGroups: *TOKEN_GROUPS,
};

pub const PLSA_CREATE_LOGON_SESSION = fn(
    LogonId: *LUID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_DELETE_LOGON_SESSION = fn(
    LogonId: *LUID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_ADD_CREDENTIAL = fn(
    LogonId: *LUID,
    AuthenticationPackage: u32,
    PrimaryKeyValue: *STRING,
    Credentials: *STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_CREDENTIALS = fn(
    LogonId: *LUID,
    AuthenticationPackage: u32,
    QueryContext: *u32,
    RetrieveAllCredentials: u8,
    PrimaryKeyValue: *STRING,
    PrimaryKeyLength: *u32,
    Credentials: *STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_DELETE_CREDENTIAL = fn(
    LogonId: *LUID,
    AuthenticationPackage: u32,
    PrimaryKeyValue: *STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_ALLOCATE_LSA_HEAP = fn(
    Length: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PLSA_FREE_LSA_HEAP = fn(
    Base: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_ALLOCATE_PRIVATE_HEAP = fn(
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PLSA_FREE_PRIVATE_HEAP = fn(
    Base: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_ALLOCATE_CLIENT_BUFFER = fn(
    ClientRequest: **c_void,
    LengthRequired: u32,
    ClientBaseAddress: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_FREE_CLIENT_BUFFER = fn(
    ClientRequest: **c_void,
    ClientBaseAddress: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_COPY_TO_CLIENT_BUFFER = fn(
    ClientRequest: **c_void,
    Length: u32,
    // TODO: what to do with BytesParamIndex 1?
    ClientBaseAddress: *c_void,
    // TODO: what to do with BytesParamIndex 1?
    BufferToCopy: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_COPY_FROM_CLIENT_BUFFER = fn(
    ClientRequest: **c_void,
    Length: u32,
    // TODO: what to do with BytesParamIndex 1?
    BufferToCopy: *c_void,
    // TODO: what to do with BytesParamIndex 1?
    ClientBaseAddress: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const LSA_DISPATCH_TABLE = extern struct {
    CreateLogonSession: PLSA_CREATE_LOGON_SESSION,
    DeleteLogonSession: PLSA_DELETE_LOGON_SESSION,
    AddCredential: PLSA_ADD_CREDENTIAL,
    GetCredentials: PLSA_GET_CREDENTIALS,
    DeleteCredential: PLSA_DELETE_CREDENTIAL,
    AllocateLsaHeap: PLSA_ALLOCATE_LSA_HEAP,
    FreeLsaHeap: PLSA_FREE_LSA_HEAP,
    AllocateClientBuffer: PLSA_ALLOCATE_CLIENT_BUFFER,
    FreeClientBuffer: PLSA_FREE_CLIENT_BUFFER,
    CopyToClientBuffer: PLSA_COPY_TO_CLIENT_BUFFER,
    CopyFromClientBuffer: PLSA_COPY_FROM_CLIENT_BUFFER,
};

pub const PLSA_AP_INITIALIZE_PACKAGE = fn(
    AuthenticationPackageId: u32,
    LsaDispatchTable: *LSA_DISPATCH_TABLE,
    Database: ?*STRING,
    Confidentiality: ?*STRING,
    AuthenticationPackageName: **STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_LOGON_USER = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    AuthenticationInformation: *c_void,
    ClientAuthenticationBase: *c_void,
    AuthenticationInformationLength: u32,
    ProfileBuffer: **c_void,
    ProfileBufferLength: *u32,
    LogonId: *LUID,
    SubStatus: *i32,
    TokenInformationType: *LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: **c_void,
    AccountName: **UNICODE_STRING,
    AuthenticatingAuthority: **UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_LOGON_USER_EX = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    AuthenticationInformation: *c_void,
    ClientAuthenticationBase: *c_void,
    AuthenticationInformationLength: u32,
    ProfileBuffer: **c_void,
    ProfileBufferLength: *u32,
    LogonId: *LUID,
    SubStatus: *i32,
    TokenInformationType: *LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: **c_void,
    AccountName: **UNICODE_STRING,
    AuthenticatingAuthority: **UNICODE_STRING,
    MachineName: **UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_CALL_PACKAGE = fn(
    ClientRequest: **c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_CALL_PACKAGE_PASSTHROUGH = fn(
    ClientRequest: **c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_LOGON_TERMINATED = fn(
    LogonId: *LUID,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE = fn(
    ClearPassword: *UNICODE_STRING,
    // TODO: what to do with BytesParamIndex 2?
    OldCredentials: *c_void,
    OldCredentialSize: u32,
    UserAccountControl: u32,
    UPN: ?*UNICODE_STRING,
    UserName: *UNICODE_STRING,
    NetbiosDomainName: *UNICODE_STRING,
    DnsDomainName: *UNICODE_STRING,
    NewCredentials: **c_void,
    NewCredentialSize: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE = fn(
    CredentialName: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE = fn(
    p: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SAM_REGISTER_MAPPING_ELEMENT = extern struct {
    Original: PSTR,
    Mapped: PSTR,
    Continuable: u8,
};

pub const SAM_REGISTER_MAPPING_LIST = extern struct {
    Count: u32,
    Elements: *SAM_REGISTER_MAPPING_ELEMENT,
};

pub const SAM_REGISTER_MAPPING_TABLE = extern struct {
    Count: u32,
    Lists: *SAM_REGISTER_MAPPING_LIST,
};

pub const PSAM_CREDENTIAL_UPDATE_REGISTER_MAPPED_ENTRYPOINTS_ROUTINE = fn(
    Table: *SAM_REGISTER_MAPPING_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_CLIENT_INFO = extern struct {
    LogonId: LUID,
    ProcessID: u32,
    ThreadID: u32,
    HasTcbPrivilege: u8,
    Impersonating: u8,
    Restricted: u8,
    ClientFlags: u8,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    ClientToken: HANDLE,
};

pub const SECPKG_CALL_INFO = extern struct {
    ProcessId: u32,
    ThreadId: u32,
    Attributes: u32,
    CallCount: u32,
    MechOid: *c_void,
};

pub const SECPKG_SUPPLEMENTAL_CRED = extern struct {
    PackageName: UNICODE_STRING,
    CredentialSize: u32,
    Credentials: *u8,
};

pub const SECPKG_BYTE_VECTOR = extern struct {
    ByteArrayOffset: u32,
    ByteArrayLength: u16,
};

pub const SECPKG_SHORT_VECTOR = extern struct {
    ShortArrayOffset: u32,
    ShortArrayCount: u16,
};

pub const SECPKG_SUPPLIED_CREDENTIAL = extern struct {
    cbHeaderLength: u16,
    cbStructureLength: u16,
    UserName: SECPKG_SHORT_VECTOR,
    DomainName: SECPKG_SHORT_VECTOR,
    PackedCredentials: SECPKG_BYTE_VECTOR,
    CredFlags: u32,
};

pub const SECPKG_CREDENTIAL = extern struct {
    Version: u64,
    cbHeaderLength: u16,
    cbStructureLength: u32,
    ClientProcess: u32,
    ClientThread: u32,
    LogonId: LUID,
    ClientToken: HANDLE,
    SessionId: u32,
    ModifiedId: LUID,
    fCredentials: u32,
    Flags: u32,
    PrincipalName: SECPKG_BYTE_VECTOR,
    PackageList: SECPKG_BYTE_VECTOR,
    MarshaledSuppliedCreds: SECPKG_BYTE_VECTOR,
};

pub const SECPKG_SUPPLEMENTAL_CRED_ARRAY = extern struct {
    CredentialCount: u32,
    Credentials: [1]SECPKG_SUPPLEMENTAL_CRED,
};

pub const SECPKG_SURROGATE_LOGON_ENTRY = extern struct {
    Type: Guid,
    Data: *c_void,
};

pub const SECPKG_SURROGATE_LOGON = extern struct {
    Version: u32,
    SurrogateLogonID: LUID,
    EntryCount: u32,
    Entries: *SECPKG_SURROGATE_LOGON_ENTRY,
};

pub const PLSA_CALLBACK_FUNCTION = fn(
    Argument1: usize,
    Argument2: usize,
    InputBuffer: *SecBuffer,
    OutputBuffer: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_PRIMARY_CRED = extern struct {
    LogonId: LUID,
    DownlevelName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    Password: UNICODE_STRING,
    OldPassword: UNICODE_STRING,
    UserSid: PSID,
    Flags: u32,
    DnsDomainName: UNICODE_STRING,
    Upn: UNICODE_STRING,
    LogonServer: UNICODE_STRING,
    Spare1: UNICODE_STRING,
    Spare2: UNICODE_STRING,
    Spare3: UNICODE_STRING,
    Spare4: UNICODE_STRING,
};

pub const SECPKG_PRIMARY_CRED_EX = extern struct {
    LogonId: LUID,
    DownlevelName: UNICODE_STRING,
    DomainName: UNICODE_STRING,
    Password: UNICODE_STRING,
    OldPassword: UNICODE_STRING,
    UserSid: PSID,
    Flags: u32,
    DnsDomainName: UNICODE_STRING,
    Upn: UNICODE_STRING,
    LogonServer: UNICODE_STRING,
    Spare1: UNICODE_STRING,
    Spare2: UNICODE_STRING,
    Spare3: UNICODE_STRING,
    Spare4: UNICODE_STRING,
    PackageId: usize,
    PrevLogonId: LUID,
};

pub const SECPKG_PARAMETERS = extern struct {
    Version: u32,
    MachineState: u32,
    SetupMode: u32,
    DomainSid: PSID,
    DomainName: UNICODE_STRING,
    DnsDomainName: UNICODE_STRING,
    DomainGuid: Guid,
};

pub const SECPKG_EXTENDED_INFORMATION_CLASS = extern enum(i32) {
    GssInfo = 1,
    ContextThunks = 2,
    MutualAuthLevel = 3,
    WowClientDll = 4,
    ExtraOids = 5,
    MaxInfo = 6,
    Nego2Info = 7,
};
pub const SecpkgGssInfo = SECPKG_EXTENDED_INFORMATION_CLASS.GssInfo;
pub const SecpkgContextThunks = SECPKG_EXTENDED_INFORMATION_CLASS.ContextThunks;
pub const SecpkgMutualAuthLevel = SECPKG_EXTENDED_INFORMATION_CLASS.MutualAuthLevel;
pub const SecpkgWowClientDll = SECPKG_EXTENDED_INFORMATION_CLASS.WowClientDll;
pub const SecpkgExtraOids = SECPKG_EXTENDED_INFORMATION_CLASS.ExtraOids;
pub const SecpkgMaxInfo = SECPKG_EXTENDED_INFORMATION_CLASS.MaxInfo;
pub const SecpkgNego2Info = SECPKG_EXTENDED_INFORMATION_CLASS.Nego2Info;

pub const SECPKG_GSS_INFO = extern struct {
    EncodedIdLength: u32,
    EncodedId: [4]u8,
};

pub const SECPKG_CONTEXT_THUNKS = extern struct {
    InfoLevelCount: u32,
    Levels: [1]u32,
};

pub const SECPKG_MUTUAL_AUTH_LEVEL = extern struct {
    MutualAuthLevel: u32,
};

pub const SECPKG_WOW_CLIENT_DLL = extern struct {
    WowClientDllPath: UNICODE_STRING,
};

pub const SECPKG_SERIALIZED_OID = extern struct {
    OidLength: u32,
    OidAttributes: u32,
    OidValue: [32]u8,
};

pub const SECPKG_EXTRA_OIDS = extern struct {
    OidCount: u32,
    Oids: [1]SECPKG_SERIALIZED_OID,
};

pub const SECPKG_NEGO2_INFO = extern struct {
    AuthScheme: [16]u8,
    PackageFlags: u32,
};

pub const SECPKG_EXTENDED_INFORMATION = extern struct {
    Class: SECPKG_EXTENDED_INFORMATION_CLASS,
    Info: _Info_e__Union,
    const _Info_e__Union = u32; // TODO: generate this nested type!
};

pub const SECPKG_TARGETINFO = extern struct {
    DomainSid: PSID,
    ComputerName: [*:0]const u16,
};

pub const SecPkgContext_SaslContext = extern struct {
    SaslContext: *c_void,
};

pub const SECURITY_USER_DATA = extern struct {
    UserName: UNICODE_STRING,
    LogonDomainName: UNICODE_STRING,
    LogonServer: UNICODE_STRING,
    pSid: PSID,
};

pub const SECPKG_CALL_PACKAGE_MESSAGE_TYPE = extern enum(i32) {
    MinMessage = 1024,
    PinDcMessage = 1024,
    UnpinAllDcsMessage = 1025,
    TransferCredMessage = 1026,
    MaxMessage = 1026,
};
pub const SecPkgCallPackageMinMessage = SECPKG_CALL_PACKAGE_MESSAGE_TYPE.MinMessage;
pub const SecPkgCallPackagePinDcMessage = SECPKG_CALL_PACKAGE_MESSAGE_TYPE.PinDcMessage;
pub const SecPkgCallPackageUnpinAllDcsMessage = SECPKG_CALL_PACKAGE_MESSAGE_TYPE.UnpinAllDcsMessage;
pub const SecPkgCallPackageTransferCredMessage = SECPKG_CALL_PACKAGE_MESSAGE_TYPE.TransferCredMessage;
pub const SecPkgCallPackageMaxMessage = SECPKG_CALL_PACKAGE_MESSAGE_TYPE.MaxMessage;

pub const SECPKG_CALL_PACKAGE_PIN_DC_REQUEST = extern struct {
    MessageType: u32,
    Flags: u32,
    DomainName: UNICODE_STRING,
    DcName: UNICODE_STRING,
    DcFlags: u32,
};

pub const SECPKG_CALL_PACKAGE_UNPIN_ALL_DCS_REQUEST = extern struct {
    MessageType: u32,
    Flags: u32,
};

pub const SECPKG_CALL_PACKAGE_TRANSFER_CRED_REQUEST = extern struct {
    MessageType: u32,
    OriginLogonId: LUID,
    DestinationLogonId: LUID,
    Flags: u32,
};

pub const PLSA_REDIRECTED_LOGON_INIT = fn(
    RedirectedLogonHandle: HANDLE,
    PackageName: *const UNICODE_STRING,
    SessionId: u32,
    LogonId: *const LUID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_REDIRECTED_LOGON_CALLBACK = fn(
    RedirectedLogonHandle: HANDLE,
    Buffer: *c_void,
    BufferLength: u32,
    ReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK = fn(
    RedirectedLogonHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_REDIRECTED_LOGON_GET_LOGON_CREDS = fn(
    RedirectedLogonHandle: HANDLE,
    LogonBuffer: **u8,
    LogonBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_REDIRECTED_LOGON_GET_SUPP_CREDS = fn(
    RedirectedLogonHandle: HANDLE,
    SupplementalCredentials: **SECPKG_SUPPLEMENTAL_CRED_ARRAY,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_REDIRECTED_LOGON_BUFFER = extern struct {
    RedirectedLogonGuid: Guid,
    RedirectedLogonHandle: HANDLE,
    Init: PLSA_REDIRECTED_LOGON_INIT,
    Callback: PLSA_REDIRECTED_LOGON_CALLBACK,
    CleanupCallback: PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK,
    GetLogonCreds: PLSA_REDIRECTED_LOGON_GET_LOGON_CREDS,
    GetSupplementalCreds: PLSA_REDIRECTED_LOGON_GET_SUPP_CREDS,
};

pub const SECPKG_POST_LOGON_USER_INFO = extern struct {
    Flags: u32,
    LogonId: LUID,
    LinkedLogonId: LUID,
};

pub const PLSA_IMPERSONATE_CLIENT = fn(
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_UNLOAD_PACKAGE = fn(
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_DUPLICATE_HANDLE = fn(
    SourceHandle: HANDLE,
    DestionationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS = fn(
    LogonId: *LUID,
    SupplementalCredSize: u32,
    // TODO: what to do with BytesParamIndex 1?
    SupplementalCreds: *c_void,
    Synchronous: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CREATE_THREAD = fn(
    SecurityAttributes: *SECURITY_ATTRIBUTES,
    StackSize: u32,
    StartFunction: LPTHREAD_START_ROUTINE,
    ThreadParameter: *c_void,
    CreationFlags: u32,
    ThreadId: *u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PLSA_GET_CLIENT_INFO = fn(
    ClientInfo: *SECPKG_CLIENT_INFO,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_REGISTER_NOTIFICATION = fn(
    StartFunction: LPTHREAD_START_ROUTINE,
    Parameter: ?*c_void,
    NotificationType: u32,
    NotificationClass: u32,
    NotificationFlags: u32,
    IntervalMinutes: u32,
    WaitEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PLSA_CANCEL_NOTIFICATION = fn(
    NotifyHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_MAP_BUFFER = fn(
    InputBuffer: *SecBuffer,
    OutputBuffer: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CREATE_TOKEN = fn(
    LogonId: *LUID,
    TokenSource: *TOKEN_SOURCE,
    LogonType: SECURITY_LOGON_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenInformationType: LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: *c_void,
    TokenGroups: ?*TOKEN_GROUPS,
    AccountName: *UNICODE_STRING,
    AuthorityName: *UNICODE_STRING,
    Workstation: ?*UNICODE_STRING,
    ProfilePath: ?*UNICODE_STRING,
    Token: *HANDLE,
    SubStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_SESSIONINFO_TYPE = extern enum(i32) {
    d = 0,
};
pub const SecSessionPrimaryCred = SECPKG_SESSIONINFO_TYPE.d;

pub const PLSA_CREATE_TOKEN_EX = fn(
    LogonId: *LUID,
    TokenSource: *TOKEN_SOURCE,
    LogonType: SECURITY_LOGON_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenInformationType: LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: *c_void,
    TokenGroups: ?*TOKEN_GROUPS,
    Workstation: ?*UNICODE_STRING,
    ProfilePath: ?*UNICODE_STRING,
    SessionInformation: *c_void,
    SessionInformationType: SECPKG_SESSIONINFO_TYPE,
    Token: *HANDLE,
    SubStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AUDIT_LOGON = fn(
    Status: NTSTATUS,
    SubStatus: NTSTATUS,
    AccountName: ?*UNICODE_STRING,
    AuthenticatingAuthority: ?*UNICODE_STRING,
    WorkstationName: ?*UNICODE_STRING,
    UserSid: PSID,
    LogonType: SECURITY_LOGON_TYPE,
    TokenSource: *TOKEN_SOURCE,
    LogonId: *LUID,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_CALL_PACKAGE = fn(
    AuthenticationPackage: *UNICODE_STRING,
    // TODO: what to do with BytesParamIndex 2?
    ProtocolSubmitBuffer: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CALL_PACKAGEEX = fn(
    AuthenticationPackage: *UNICODE_STRING,
    ClientBufferBase: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CALL_PACKAGE_PASSTHROUGH = fn(
    AuthenticationPackage: *UNICODE_STRING,
    ClientBufferBase: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: **c_void,
    ReturnBufferLength: *u32,
    ProtocolStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_CALL_INFO = fn(
    Info: *SECPKG_CALL_INFO,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PLSA_CREATE_SHARED_MEMORY = fn(
    MaxSize: u32,
    InitialSize: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PLSA_ALLOCATE_SHARED_MEMORY = fn(
    SharedMem: *c_void,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PLSA_FREE_SHARED_MEMORY = fn(
    SharedMem: *c_void,
    Memory: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_DELETE_SHARED_MEMORY = fn(
    SharedMem: *c_void,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PLSA_GET_APP_MODE_INFO = fn(
    UserFunction: ?*u32,
    Argument1: ?*usize,
    Argument2: ?*usize,
    UserData: ?*SecBuffer,
    ReturnToLsa: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_SET_APP_MODE_INFO = fn(
    UserFunction: u32,
    Argument1: usize,
    Argument2: usize,
    UserData: ?*SecBuffer,
    ReturnToLsa: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_NAME_TYPE = extern enum(i32) {
    SamCompatible = 0,
    AlternateId = 1,
    Flat = 2,
    DN = 3,
    SPN = 4,
};
pub const SecNameSamCompatible = SECPKG_NAME_TYPE.SamCompatible;
pub const SecNameAlternateId = SECPKG_NAME_TYPE.AlternateId;
pub const SecNameFlat = SECPKG_NAME_TYPE.Flat;
pub const SecNameDN = SECPKG_NAME_TYPE.DN;
pub const SecNameSPN = SECPKG_NAME_TYPE.SPN;

pub const PLSA_OPEN_SAM_USER = fn(
    Name: *UNICODE_STRING,
    NameType: SECPKG_NAME_TYPE,
    Prefix: *UNICODE_STRING,
    AllowGuest: u8,
    Reserved: u32,
    UserHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_USER_CREDENTIALS = fn(
    UserHandle: *c_void,
    PrimaryCreds: **c_void,
    PrimaryCredsSize: *u32,
    SupplementalCreds: **c_void,
    SupplementalCredsSize: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_USER_AUTH_DATA = fn(
    UserHandle: *c_void,
    UserAuthData: **u8,
    UserAuthDataSize: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CLOSE_SAM_USER = fn(
    UserHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_AUTH_DATA_FOR_USER = fn(
    Name: *UNICODE_STRING,
    NameType: SECPKG_NAME_TYPE,
    Prefix: ?*UNICODE_STRING,
    UserAuthData: **u8,
    UserAuthDataSize: *u32,
    UserFlatName: ?*UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CONVERT_AUTH_DATA_TO_TOKEN = fn(
    UserAuthData: *c_void,
    UserAuthDataSize: u32,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenSource: *TOKEN_SOURCE,
    LogonType: SECURITY_LOGON_TYPE,
    AuthorityName: *UNICODE_STRING,
    Token: *HANDLE,
    LogonId: *LUID,
    AccountName: *UNICODE_STRING,
    SubStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CRACK_SINGLE_NAME = fn(
    FormatOffered: u32,
    PerformAtGC: u8,
    NameInput: *UNICODE_STRING,
    Prefix: ?*UNICODE_STRING,
    RequestedFormat: u32,
    CrackedName: *UNICODE_STRING,
    DnsDomainName: *UNICODE_STRING,
    SubStatus: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AUDIT_ACCOUNT_LOGON = fn(
    AuditId: u32,
    Success: u8,
    Source: ?*UNICODE_STRING,
    ClientName: ?*UNICODE_STRING,
    MappedName: ?*UNICODE_STRING,
    Status: NTSTATUS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_CLIENT_CALLBACK = fn(
    Callback: [*]u8,
    Argument1: usize,
    Argument2: usize,
    Input: *SecBuffer,
    Output: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_REGISTER_CALLBACK = fn(
    CallbackId: u32,
    Callback: PLSA_CALLBACK_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_GET_EXTENDED_CALL_FLAGS = fn(
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_EVENT_PACKAGE_CHANGE = extern struct {
    ChangeType: SECPKG_PACKAGE_CHANGE_TYPE,
    PackageId: usize,
    PackageName: UNICODE_STRING,
};

pub const SECPKG_EVENT_ROLE_CHANGE = extern struct {
    PreviousRole: u32,
    NewRole: u32,
};

pub const SECPKG_EVENT_NOTIFY = extern struct {
    EventClass: u32,
    Reserved: u32,
    EventDataSize: u32,
    EventData: *c_void,
    PackageParameter: *c_void,
};

pub const PLSA_UPDATE_PRIMARY_CREDENTIALS = fn(
    PrimaryCredentials: *SECPKG_PRIMARY_CRED,
    Credentials: ?*SECPKG_SUPPLEMENTAL_CRED_ARRAY,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_PROTECT_MEMORY = fn(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *c_void,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_OPEN_TOKEN_BY_LOGON_ID = fn(
    LogonId: *LUID,
    RetTokenHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_EXPAND_AUTH_DATA_FOR_DOMAIN = fn(
    // TODO: what to do with BytesParamIndex 1?
    UserAuthData: *u8,
    UserAuthDataSize: u32,
    Reserved: *c_void,
    ExpandedAuthData: **u8,
    ExpandedAuthDataSize: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const CRED_FETCH = extern enum(i32) {
    Default = 0,
    DPAPI = 1,
    Forced = 2,
};
pub const CredFetchDefault = CRED_FETCH.Default;
pub const CredFetchDPAPI = CRED_FETCH.DPAPI;
pub const CredFetchForced = CRED_FETCH.Forced;

pub const PLSA_GET_SERVICE_ACCOUNT_PASSWORD = fn(
    AccountName: *UNICODE_STRING,
    DomainName: ?*UNICODE_STRING,
    CredFetch: CRED_FETCH,
    FileTimeExpiry: *FILETIME,
    CurrentPassword: *UNICODE_STRING,
    PreviousPassword: *UNICODE_STRING,
    FileTimeCurrPwdValidForOutbound: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AUDIT_LOGON_EX = fn(
    Status: NTSTATUS,
    SubStatus: NTSTATUS,
    AccountName: ?*UNICODE_STRING,
    AuthenticatingAuthority: ?*UNICODE_STRING,
    WorkstationName: ?*UNICODE_STRING,
    UserSid: PSID,
    LogonType: SECURITY_LOGON_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenSource: *TOKEN_SOURCE,
    LogonId: *LUID,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PLSA_CHECK_PROTECTED_USER_BY_TOKEN = fn(
    UserToken: HANDLE,
    ProtectedUser: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_QUERY_CLIENT_REQUEST = fn(
    ClientRequest: **c_void,
    QueryType: u32,
    ReplyBuffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const ENCRYPTED_CREDENTIALW = extern struct {
    Cred: CREDENTIALW,
    ClearCredentialBlobSize: u32,
};

pub const CredReadFn = fn(
    LogonId: *LUID,
    CredFlags: u32,
    TargetName: PWSTR,
    Type: u32,
    Flags: u32,
    Credential: **ENCRYPTED_CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const CredReadDomainCredentialsFn = fn(
    LogonId: *LUID,
    CredFlags: u32,
    TargetInfo: *CREDENTIAL_TARGET_INFORMATIONW,
    Flags: u32,
    Count: *u32,
    Credential: ***ENCRYPTED_CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const CredFreeCredentialsFn = fn(
    Count: u32,
    Credentials: ?[*]?*ENCRYPTED_CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CredWriteFn = fn(
    LogonId: *LUID,
    CredFlags: u32,
    Credential: *ENCRYPTED_CREDENTIALW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const CrediUnmarshalandDecodeStringFn = fn(
    MarshaledString: PWSTR,
    Blob: **u8,
    BlobSize: *u32,
    IsFailureFatal: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SEC_WINNT_AUTH_IDENTITY32 = extern struct {
    User: u32,
    UserLength: u32,
    Domain: u32,
    DomainLength: u32,
    Password: u32,
    PasswordLength: u32,
    Flags: u32,
};

pub const SEC_WINNT_AUTH_IDENTITY_EX32 = extern struct {
    Version: u32,
    Length: u32,
    User: u32,
    UserLength: u32,
    Domain: u32,
    DomainLength: u32,
    Password: u32,
    PasswordLength: u32,
    Flags: u32,
    PackageList: u32,
    PackageListLength: u32,
};

pub const LSA_SECPKG_FUNCTION_TABLE = extern struct {
    CreateLogonSession: PLSA_CREATE_LOGON_SESSION,
    DeleteLogonSession: PLSA_DELETE_LOGON_SESSION,
    AddCredential: PLSA_ADD_CREDENTIAL,
    GetCredentials: PLSA_GET_CREDENTIALS,
    DeleteCredential: PLSA_DELETE_CREDENTIAL,
    AllocateLsaHeap: PLSA_ALLOCATE_LSA_HEAP,
    FreeLsaHeap: PLSA_FREE_LSA_HEAP,
    AllocateClientBuffer: PLSA_ALLOCATE_CLIENT_BUFFER,
    FreeClientBuffer: PLSA_FREE_CLIENT_BUFFER,
    CopyToClientBuffer: PLSA_COPY_TO_CLIENT_BUFFER,
    CopyFromClientBuffer: PLSA_COPY_FROM_CLIENT_BUFFER,
    ImpersonateClient: PLSA_IMPERSONATE_CLIENT,
    UnloadPackage: PLSA_UNLOAD_PACKAGE,
    DuplicateHandle: PLSA_DUPLICATE_HANDLE,
    SaveSupplementalCredentials: PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS,
    CreateThread: PLSA_CREATE_THREAD,
    GetClientInfo: PLSA_GET_CLIENT_INFO,
    RegisterNotification: PLSA_REGISTER_NOTIFICATION,
    CancelNotification: PLSA_CANCEL_NOTIFICATION,
    MapBuffer: PLSA_MAP_BUFFER,
    CreateToken: PLSA_CREATE_TOKEN,
    AuditLogon: PLSA_AUDIT_LOGON,
    CallPackage: PLSA_CALL_PACKAGE,
    FreeReturnBuffer: PLSA_FREE_LSA_HEAP,
    GetCallInfo: PLSA_GET_CALL_INFO,
    CallPackageEx: PLSA_CALL_PACKAGEEX,
    CreateSharedMemory: PLSA_CREATE_SHARED_MEMORY,
    AllocateSharedMemory: PLSA_ALLOCATE_SHARED_MEMORY,
    FreeSharedMemory: PLSA_FREE_SHARED_MEMORY,
    DeleteSharedMemory: PLSA_DELETE_SHARED_MEMORY,
    OpenSamUser: PLSA_OPEN_SAM_USER,
    GetUserCredentials: PLSA_GET_USER_CREDENTIALS,
    GetUserAuthData: PLSA_GET_USER_AUTH_DATA,
    CloseSamUser: PLSA_CLOSE_SAM_USER,
    ConvertAuthDataToToken: PLSA_CONVERT_AUTH_DATA_TO_TOKEN,
    ClientCallback: PLSA_CLIENT_CALLBACK,
    UpdateCredentials: PLSA_UPDATE_PRIMARY_CREDENTIALS,
    GetAuthDataForUser: PLSA_GET_AUTH_DATA_FOR_USER,
    CrackSingleName: PLSA_CRACK_SINGLE_NAME,
    AuditAccountLogon: PLSA_AUDIT_ACCOUNT_LOGON,
    CallPackagePassthrough: PLSA_CALL_PACKAGE_PASSTHROUGH,
    CrediRead: CredReadFn,
    CrediReadDomainCredentials: CredReadDomainCredentialsFn,
    CrediFreeCredentials: CredFreeCredentialsFn,
    LsaProtectMemory: PLSA_PROTECT_MEMORY,
    LsaUnprotectMemory: PLSA_PROTECT_MEMORY,
    OpenTokenByLogonId: PLSA_OPEN_TOKEN_BY_LOGON_ID,
    ExpandAuthDataForDomain: PLSA_EXPAND_AUTH_DATA_FOR_DOMAIN,
    AllocatePrivateHeap: PLSA_ALLOCATE_PRIVATE_HEAP,
    FreePrivateHeap: PLSA_FREE_PRIVATE_HEAP,
    CreateTokenEx: PLSA_CREATE_TOKEN_EX,
    CrediWrite: CredWriteFn,
    CrediUnmarshalandDecodeString: CrediUnmarshalandDecodeStringFn,
    DummyFunction6: PLSA_PROTECT_MEMORY,
    GetExtendedCallFlags: PLSA_GET_EXTENDED_CALL_FLAGS,
    DuplicateTokenHandle: PLSA_DUPLICATE_HANDLE,
    GetServiceAccountPassword: PLSA_GET_SERVICE_ACCOUNT_PASSWORD,
    DummyFunction7: PLSA_PROTECT_MEMORY,
    AuditLogonEx: PLSA_AUDIT_LOGON_EX,
    CheckProtectedUserByToken: PLSA_CHECK_PROTECTED_USER_BY_TOKEN,
    QueryClientRequest: PLSA_QUERY_CLIENT_REQUEST,
    GetAppModeInfo: PLSA_GET_APP_MODE_INFO,
    SetAppModeInfo: PLSA_SET_APP_MODE_INFO,
};

pub const PLSA_LOCATE_PKG_BY_ID = fn(
    PackgeId: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const SECPKG_DLL_FUNCTIONS = extern struct {
    AllocateHeap: PLSA_ALLOCATE_LSA_HEAP,
    FreeHeap: PLSA_FREE_LSA_HEAP,
    RegisterCallback: PLSA_REGISTER_CALLBACK,
    LocatePackageById: PLSA_LOCATE_PKG_BY_ID,
};

pub const SpInitializeFn = fn(
    PackageId: usize,
    Parameters: *SECPKG_PARAMETERS,
    FunctionTable: *LSA_SECPKG_FUNCTION_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpShutdownFn = fn(
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetInfoFn = fn(
    PackageInfo: *SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetExtendedInformationFn = fn(
    Class: SECPKG_EXTENDED_INFORMATION_CLASS,
    ppInformation: **SECPKG_EXTENDED_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpSetExtendedInformationFn = fn(
    Class: SECPKG_EXTENDED_INFORMATION_CLASS,
    Info: *SECPKG_EXTENDED_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_LOGON_USER_EX2 = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferSize: u32,
    ProfileBuffer: **c_void,
    ProfileBufferSize: *u32,
    LogonId: *LUID,
    SubStatus: *i32,
    TokenInformationType: *LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: **c_void,
    AccountName: **UNICODE_STRING,
    AuthenticatingAuthority: **UNICODE_STRING,
    MachineName: **UNICODE_STRING,
    PrimaryCredentials: *SECPKG_PRIMARY_CRED,
    SupplementalCredentials: **SECPKG_SUPPLEMENTAL_CRED_ARRAY,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_LOGON_USER_EX3 = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferSize: u32,
    SurrogateLogon: *SECPKG_SURROGATE_LOGON,
    ProfileBuffer: **c_void,
    ProfileBufferSize: *u32,
    LogonId: *LUID,
    SubStatus: *i32,
    TokenInformationType: *LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: **c_void,
    AccountName: **UNICODE_STRING,
    AuthenticatingAuthority: **UNICODE_STRING,
    MachineName: **UNICODE_STRING,
    PrimaryCredentials: *SECPKG_PRIMARY_CRED,
    SupplementalCredentials: **SECPKG_SUPPLEMENTAL_CRED_ARRAY,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_PRE_LOGON_USER_SURROGATE = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferSize: u32,
    SurrogateLogon: *SECPKG_SURROGATE_LOGON,
    SubStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PLSA_AP_POST_LOGON_USER_SURROGATE = fn(
    ClientRequest: **c_void,
    LogonType: SECURITY_LOGON_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferSize: u32,
    SurrogateLogon: *SECPKG_SURROGATE_LOGON,
    // TODO: what to do with BytesParamIndex 7?
    ProfileBuffer: *c_void,
    ProfileBufferSize: u32,
    LogonId: *LUID,
    Status: NTSTATUS,
    SubStatus: NTSTATUS,
    TokenInformationType: LSA_TOKEN_INFORMATION_TYPE,
    TokenInformation: *c_void,
    AccountName: *UNICODE_STRING,
    AuthenticatingAuthority: *UNICODE_STRING,
    MachineName: *UNICODE_STRING,
    PrimaryCredentials: *SECPKG_PRIMARY_CRED,
    SupplementalCredentials: *SECPKG_SUPPLEMENTAL_CRED_ARRAY,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpAcceptCredentialsFn = fn(
    LogonType: SECURITY_LOGON_TYPE,
    AccountName: *UNICODE_STRING,
    PrimaryCredentials: ?*SECPKG_PRIMARY_CRED,
    SupplementalCredentials: ?*SECPKG_SUPPLEMENTAL_CRED,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpAcquireCredentialsHandleFn = fn(
    PrincipalName: ?*UNICODE_STRING,
    CredentialUseFlags: u32,
    LogonId: ?*LUID,
    AuthorizationData: ?*c_void,
    GetKeyFunciton: ?*c_void,
    GetKeyArgument: ?*c_void,
    CredentialHandle: *usize,
    ExpirationTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpFreeCredentialsHandleFn = fn(
    CredentialHandle: usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpQueryCredentialsAttributesFn = fn(
    CredentialHandle: usize,
    CredentialAttribute: u32,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpSetCredentialsAttributesFn = fn(
    CredentialHandle: usize,
    CredentialAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *c_void,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpAddCredentialsFn = fn(
    CredentialHandle: usize,
    PrincipalName: ?*UNICODE_STRING,
    Package: *UNICODE_STRING,
    CredentialUseFlags: u32,
    AuthorizationData: *c_void,
    GetKeyFunciton: *c_void,
    GetKeyArgument: *c_void,
    ExpirationTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpSaveCredentialsFn = fn(
    CredentialHandle: usize,
    Credentials: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetCredentialsFn = fn(
    CredentialHandle: usize,
    Credentials: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpDeleteCredentialsFn = fn(
    CredentialHandle: usize,
    Key: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpInitLsaModeContextFn = fn(
    CredentialHandle: usize,
    ContextHandle: usize,
    TargetName: ?*UNICODE_STRING,
    ContextRequirements: u32,
    TargetDataRep: u32,
    InputBuffers: *SecBufferDesc,
    NewContextHandle: *usize,
    OutputBuffers: *SecBufferDesc,
    ContextAttributes: *u32,
    ExpirationTime: *LARGE_INTEGER,
    MappedContext: *u8,
    ContextData: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpDeleteContextFn = fn(
    ContextHandle: usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpApplyControlTokenFn = fn(
    ContextHandle: usize,
    ControlToken: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpAcceptLsaModeContextFn = fn(
    CredentialHandle: usize,
    ContextHandle: usize,
    InputBuffer: *SecBufferDesc,
    ContextRequirements: u32,
    TargetDataRep: u32,
    NewContextHandle: *usize,
    OutputBuffer: *SecBufferDesc,
    ContextAttributes: *u32,
    ExpirationTime: *LARGE_INTEGER,
    MappedContext: *u8,
    ContextData: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetUserInfoFn = fn(
    LogonId: *LUID,
    Flags: u32,
    UserData: **SECURITY_USER_DATA,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpQueryContextAttributesFn = fn(
    ContextHandle: usize,
    ContextAttribute: u32,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpSetContextAttributesFn = fn(
    ContextHandle: usize,
    ContextAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *c_void,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpChangeAccountPasswordFn = fn(
    pDomainName: *UNICODE_STRING,
    pAccountName: *UNICODE_STRING,
    pOldPassword: *UNICODE_STRING,
    pNewPassword: *UNICODE_STRING,
    Impersonating: u8,
    pOutput: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpQueryMetaDataFn = fn(
    CredentialHandle: usize,
    TargetName: ?*UNICODE_STRING,
    ContextRequirements: u32,
    MetaDataLength: *u32,
    MetaData: **u8,
    ContextHandle: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpExchangeMetaDataFn = fn(
    CredentialHandle: usize,
    TargetName: ?*UNICODE_STRING,
    ContextRequirements: u32,
    MetaDataLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    MetaData: *u8,
    ContextHandle: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetCredUIContextFn = fn(
    ContextHandle: usize,
    CredType: *Guid,
    FlatCredUIContextLength: *u32,
    FlatCredUIContext: **u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpUpdateCredentialsFn = fn(
    ContextHandle: usize,
    CredType: *Guid,
    FlatCredUIContextLength: u32,
    // TODO: what to do with BytesParamIndex 2?
    FlatCredUIContext: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpValidateTargetInfoFn = fn(
    ClientRequest: ?*?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    ClientBufferBase: *c_void,
    SubmitBufferLength: u32,
    TargetInfo: *SECPKG_TARGETINFO,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const LSA_AP_POST_LOGON_USER = fn(
    PostLogonUserInfo: *SECPKG_POST_LOGON_USER_INFO,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetRemoteCredGuardLogonBufferFn = fn(
    CredHandle: usize,
    ContextHandle: usize,
    TargetName: *const UNICODE_STRING,
    RedirectedLogonHandle: *HANDLE,
    Callback: *PLSA_REDIRECTED_LOGON_CALLBACK,
    CleanupCallback: *PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK,
    LogonBufferSize: *u32,
    LogonBuffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetRemoteCredGuardSupplementalCredsFn = fn(
    CredHandle: usize,
    TargetName: *const UNICODE_STRING,
    RedirectedLogonHandle: *HANDLE,
    Callback: *PLSA_REDIRECTED_LOGON_CALLBACK,
    CleanupCallback: *PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK,
    SupplementalCredsSize: *u32,
    SupplementalCreds: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetTbalSupplementalCredsFn = fn(
    LogonId: LUID,
    SupplementalCredsSize: *u32,
    SupplementalCreds: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_FUNCTION_TABLE = extern struct {
    InitializePackage: PLSA_AP_INITIALIZE_PACKAGE,
    LogonUserA: PLSA_AP_LOGON_USER,
    CallPackage: PLSA_AP_CALL_PACKAGE,
    LogonTerminated: PLSA_AP_LOGON_TERMINATED,
    CallPackageUntrusted: PLSA_AP_CALL_PACKAGE,
    CallPackagePassthrough: PLSA_AP_CALL_PACKAGE_PASSTHROUGH,
    LogonUserExA: PLSA_AP_LOGON_USER_EX,
    LogonUserEx2: PLSA_AP_LOGON_USER_EX2,
    Initialize: SpInitializeFn,
    Shutdown: SpShutdownFn,
    GetInfo: SpGetInfoFn,
    AcceptCredentials: SpAcceptCredentialsFn,
    AcquireCredentialsHandleA: SpAcquireCredentialsHandleFn,
    QueryCredentialsAttributesA: SpQueryCredentialsAttributesFn,
    FreeCredentialsHandle: SpFreeCredentialsHandleFn,
    SaveCredentials: SpSaveCredentialsFn,
    GetCredentials: SpGetCredentialsFn,
    DeleteCredentials: SpDeleteCredentialsFn,
    InitLsaModeContext: SpInitLsaModeContextFn,
    AcceptLsaModeContext: SpAcceptLsaModeContextFn,
    DeleteContext: SpDeleteContextFn,
    ApplyControlToken: SpApplyControlTokenFn,
    GetUserInfo: SpGetUserInfoFn,
    GetExtendedInformation: SpGetExtendedInformationFn,
    QueryContextAttributesA: SpQueryContextAttributesFn,
    AddCredentialsA: SpAddCredentialsFn,
    SetExtendedInformation: SpSetExtendedInformationFn,
    SetContextAttributesA: SpSetContextAttributesFn,
    SetCredentialsAttributesA: SpSetCredentialsAttributesFn,
    ChangeAccountPasswordA: SpChangeAccountPasswordFn,
    QueryMetaData: SpQueryMetaDataFn,
    ExchangeMetaData: SpExchangeMetaDataFn,
    GetCredUIContext: SpGetCredUIContextFn,
    UpdateCredentials: SpUpdateCredentialsFn,
    ValidateTargetInfo: SpValidateTargetInfoFn,
    PostLogonUser: LSA_AP_POST_LOGON_USER,
    GetRemoteCredGuardLogonBuffer: SpGetRemoteCredGuardLogonBufferFn,
    GetRemoteCredGuardSupplementalCreds: SpGetRemoteCredGuardSupplementalCredsFn,
    GetTbalSupplementalCreds: SpGetTbalSupplementalCredsFn,
    LogonUserEx3: PLSA_AP_LOGON_USER_EX3,
    PreLogonUserSurrogate: PLSA_AP_PRE_LOGON_USER_SURROGATE,
    PostLogonUserSurrogate: PLSA_AP_POST_LOGON_USER_SURROGATE,
};

pub const SpInstanceInitFn = fn(
    Version: u32,
    FunctionTable: *SECPKG_DLL_FUNCTIONS,
    UserFunctions: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpInitUserModeContextFn = fn(
    ContextHandle: usize,
    PackedContext: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpMakeSignatureFn = fn(
    ContextHandle: usize,
    QualityOfProtection: u32,
    MessageBuffers: *SecBufferDesc,
    MessageSequenceNumber: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpVerifySignatureFn = fn(
    ContextHandle: usize,
    MessageBuffers: *SecBufferDesc,
    MessageSequenceNumber: u32,
    QualityOfProtection: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpSealMessageFn = fn(
    ContextHandle: usize,
    QualityOfProtection: u32,
    MessageBuffers: *SecBufferDesc,
    MessageSequenceNumber: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpUnsealMessageFn = fn(
    ContextHandle: usize,
    MessageBuffers: *SecBufferDesc,
    MessageSequenceNumber: u32,
    QualityOfProtection: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpGetContextTokenFn = fn(
    ContextHandle: usize,
    ImpersonationToken: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpExportSecurityContextFn = fn(
    phContext: usize,
    fFlags: u32,
    pPackedContext: *SecBuffer,
    pToken: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpImportSecurityContextFn = fn(
    pPackedContext: *SecBuffer,
    Token: HANDLE,
    phContext: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpCompleteAuthTokenFn = fn(
    ContextHandle: usize,
    InputBuffer: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpFormatCredentialsFn = fn(
    Credentials: *SecBuffer,
    FormattedCredentials: *SecBuffer,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpMarshallSupplementalCredsFn = fn(
    CredentialSize: u32,
    // TODO: what to do with BytesParamIndex 0?
    Credentials: *u8,
    MarshalledCredSize: *u32,
    MarshalledCreds: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_USER_FUNCTION_TABLE = extern struct {
    InstanceInit: SpInstanceInitFn,
    InitUserModeContext: SpInitUserModeContextFn,
    MakeSignature: SpMakeSignatureFn,
    VerifySignature: SpVerifySignatureFn,
    SealMessage: SpSealMessageFn,
    UnsealMessage: SpUnsealMessageFn,
    GetContextToken: SpGetContextTokenFn,
    QueryContextAttributesA: SpQueryContextAttributesFn,
    CompleteAuthToken: SpCompleteAuthTokenFn,
    DeleteUserModeContext: SpDeleteContextFn,
    FormatCredentials: SpFormatCredentialsFn,
    MarshallSupplementalCreds: SpMarshallSupplementalCredsFn,
    ExportContext: SpExportSecurityContextFn,
    ImportContext: SpImportSecurityContextFn,
};

pub const SpLsaModeInitializeFn = fn(
    LsaVersion: u32,
    PackageVersion: *u32,
    ppTables: **SECPKG_FUNCTION_TABLE,
    pcTables: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SpUserModeInitializeFn = fn(
    LsaVersion: u32,
    PackageVersion: *u32,
    ppTables: **SECPKG_USER_FUNCTION_TABLE,
    pcTables: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KSEC_CONTEXT_TYPE = extern enum(i32) {
    Paged = 0,
    NonPaged = 1,
};
pub const KSecPaged = KSEC_CONTEXT_TYPE.Paged;
pub const KSecNonPaged = KSEC_CONTEXT_TYPE.NonPaged;

pub const KSEC_LIST_ENTRY = extern struct {
    List: LIST_ENTRY,
    RefCount: i32,
    Signature: u32,
    OwningList: *c_void,
    Reserved: *c_void,
};

pub const PKSEC_CREATE_CONTEXT_LIST = fn(
    Type: KSEC_CONTEXT_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PKSEC_INSERT_LIST_ENTRY = fn(
    List: *c_void,
    Entry: *KSEC_LIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PKSEC_REFERENCE_LIST_ENTRY = fn(
    Entry: *KSEC_LIST_ENTRY,
    Signature: u32,
    RemoveNoRef: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PKSEC_DEREFERENCE_LIST_ENTRY = fn(
    Entry: *KSEC_LIST_ENTRY,
    Delete: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PKSEC_SERIALIZE_WINNT_AUTH_DATA = fn(
    pvAuthData: *c_void,
    Size: *u32,
    SerializedData: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PKSEC_SERIALIZE_SCHANNEL_AUTH_DATA = fn(
    pvAuthData: *c_void,
    Size: *u32,
    SerializedData: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PKSEC_LOCATE_PKG_BY_ID = fn(
    PackageId: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const SECPKG_KERNEL_FUNCTIONS = extern struct {
    AllocateHeap: PLSA_ALLOCATE_LSA_HEAP,
    FreeHeap: PLSA_FREE_LSA_HEAP,
    CreateContextList: PKSEC_CREATE_CONTEXT_LIST,
    InsertListEntry: PKSEC_INSERT_LIST_ENTRY,
    ReferenceListEntry: PKSEC_REFERENCE_LIST_ENTRY,
    DereferenceListEntry: PKSEC_DEREFERENCE_LIST_ENTRY,
    SerializeWinntAuthData: PKSEC_SERIALIZE_WINNT_AUTH_DATA,
    SerializeSchannelAuthData: PKSEC_SERIALIZE_SCHANNEL_AUTH_DATA,
    LocatePackageById: PKSEC_LOCATE_PKG_BY_ID,
};

pub const KspInitPackageFn = fn(
    FunctionTable: *SECPKG_KERNEL_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspDeleteContextFn = fn(
    ContextId: usize,
    LsaContextId: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspInitContextFn = fn(
    ContextId: usize,
    ContextData: *SecBuffer,
    NewContextId: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspMakeSignatureFn = fn(
    ContextId: usize,
    fQOP: u32,
    Message: *SecBufferDesc,
    MessageSeqNo: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspVerifySignatureFn = fn(
    ContextId: usize,
    Message: *SecBufferDesc,
    MessageSeqNo: u32,
    pfQOP: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspSealMessageFn = fn(
    ContextId: usize,
    fQOP: u32,
    Message: *SecBufferDesc,
    MessageSeqNo: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspUnsealMessageFn = fn(
    ContextId: usize,
    Message: *SecBufferDesc,
    MessageSeqNo: u32,
    pfQOP: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspGetTokenFn = fn(
    ContextId: usize,
    ImpersonationToken: ?*HANDLE,
    RawToken: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspQueryAttributesFn = fn(
    ContextId: usize,
    Attribute: u32,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspCompleteTokenFn = fn(
    ContextId: usize,
    Token: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspMapHandleFn = fn(
    ContextId: usize,
    LsaContextId: *usize,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspSetPagingModeFn = fn(
    PagingMode: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const KspSerializeAuthDataFn = fn(
    pvAuthData: *c_void,
    Size: *u32,
    SerializedData: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SECPKG_KERNEL_FUNCTION_TABLE = extern struct {
    Initialize: KspInitPackageFn,
    DeleteContext: KspDeleteContextFn,
    InitContext: KspInitContextFn,
    MapHandle: KspMapHandleFn,
    Sign: KspMakeSignatureFn,
    Verify: KspVerifySignatureFn,
    Seal: KspSealMessageFn,
    Unseal: KspUnsealMessageFn,
    GetToken: KspGetTokenFn,
    QueryAttributes: KspQueryAttributesFn,
    CompleteToken: KspCompleteTokenFn,
    ExportContext: SpExportSecurityContextFn,
    ImportContext: SpImportSecurityContextFn,
    SetPackagePagingMode: KspSetPagingModeFn,
    SerializeAuthData: KspSerializeAuthDataFn,
};

pub const SecPkgCred_SupportedAlgs = extern struct {
    cSupportedAlgs: u32,
    palgSupportedAlgs: *u32,
};

pub const SecPkgCred_CipherStrengths = extern struct {
    dwMinimumCipherStrength: u32,
    dwMaximumCipherStrength: u32,
};

pub const SecPkgCred_SupportedProtocols = extern struct {
    grbitProtocol: u32,
};

pub const SecPkgCred_ClientCertPolicy = extern struct {
    dwFlags: u32,
    guidPolicyId: Guid,
    dwCertFlags: u32,
    dwUrlRetrievalTimeout: u32,
    fCheckRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
    fOmitUsageCheck: BOOL,
    pwszSslCtlStoreName: PWSTR,
    pwszSslCtlIdentifier: PWSTR,
};

pub const CMS_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pbOID: *u8,
    cbOID: u32,
};

pub const HMAC_Info = extern struct {
    HashAlgid: u32,
    pbInnerString: *u8,
    cbInnerString: u32,
    pbOuterString: *u8,
    cbOuterString: u32,
};

pub const SCHANNEL_ALG = extern struct {
    dwUse: u32,
    Algid: u32,
    cBits: u32,
    dwFlags: u32,
    dwReserved: u32,
};

pub const PROV_ENUMALGS = extern struct {
    aiAlgid: u32,
    dwBitLen: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
};

pub const PROV_ENUMALGS_EX = extern struct {
    aiAlgid: u32,
    dwDefaultLen: u32,
    dwMinLen: u32,
    dwMaxLen: u32,
    dwProtocols: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
    dwLongNameLen: u32,
    szLongName: [40]CHAR,
};

pub const PUBLICKEYSTRUC = extern struct {
    bType: u8,
    bVersion: u8,
    reserved: u16,
    aiKeyAlg: u32,
};

pub const RSAPUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
    pubexp: u32,
};

pub const PUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
};

pub const DSSSEED = extern struct {
    counter: u32,
    seed: [20]u8,
};

pub const PUBKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    DSSSeed: DSSSEED,
};

pub const PRIVKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    bitlenX: u32,
    DSSSeed: DSSSEED,
};

pub const KEY_TYPE_SUBTYPE = extern struct {
    dwKeySpec: u32,
    Type: Guid,
    Subtype: Guid,
};

pub const CERT_FORTEZZA_DATA_PROP = extern struct {
    SerialNumber: [8]u8,
    CertIndex: i32,
    CertLabel: [36]u8,
};

pub const CRYPT_RC4_KEY_STATE = extern struct {
    Key: [16]u8,
    SBox: [256]u8,
    i: u8,
    j: u8,
};

pub const CRYPT_DES_KEY_STATE = extern struct {
    Key: [8]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_3DES_KEY_STATE = extern struct {
    Key: [24]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_AES_128_KEY_STATE = extern struct {
    Key: [16]u8,
    IV: [16]u8,
    EncryptionState: [176]u8,
    DecryptionState: [176]u8,
    Feedback: [16]u8,
};

pub const CRYPT_AES_256_KEY_STATE = extern struct {
    Key: [32]u8,
    IV: [16]u8,
    EncryptionState: [240]u8,
    DecryptionState: [240]u8,
    Feedback: [16]u8,
};

pub const CRYPTOAPI_BLOB = extern struct {
    cbData: u32,
    pbData: *u8,
};

pub const CMS_DH_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pszContentEncObjId: PSTR,
    PubInfo: CRYPTOAPI_BLOB,
    pReserved: *c_void,
};

pub const BCRYPT_KEY_LENGTHS_STRUCT = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
};

pub const BCRYPT_OID = extern struct {
    cbOID: u32,
    pbOID: *u8,
};

pub const BCRYPT_OID_LIST = extern struct {
    dwOIDCount: u32,
    pOIDs: *BCRYPT_OID,
};

pub const BCRYPT_PKCS1_PADDING_INFO = extern struct {
    pszAlgId: [*:0]const u16,
};

pub const BCRYPT_PSS_PADDING_INFO = extern struct {
    pszAlgId: [*:0]const u16,
    cbSalt: u32,
};

pub const BCRYPT_OAEP_PADDING_INFO = extern struct {
    pszAlgId: [*:0]const u16,
    pbLabel: *u8,
    cbLabel: u32,
};

pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = extern struct {
    cbSize: u32,
    dwInfoVersion: u32,
    pbNonce: *u8,
    cbNonce: u32,
    pbAuthData: *u8,
    cbAuthData: u32,
    pbTag: *u8,
    cbTag: u32,
    pbMacContext: *u8,
    cbMacContext: u32,
    cbAAD: u32,
    cbData: u64,
    dwFlags: u32,
};

pub const BCryptBuffer = extern struct {
    cbBuffer: u32,
    BufferType: u32,
    pvBuffer: *c_void,
};

pub const BCryptBufferDesc = extern struct {
    ulVersion: u32,
    cBuffers: u32,
    pBuffers: *BCryptBuffer,
};

pub const BCRYPT_KEY_BLOB = extern struct {
    Magic: u32,
};

pub const BCRYPT_RSAKEY_BLOB = extern struct {
    Magic: BCRYPT_RSAKEY_BLOB_MAGIC,
    BitLength: u32,
    cbPublicExp: u32,
    cbModulus: u32,
    cbPrime1: u32,
    cbPrime2: u32,
};

pub const BCRYPT_ECCKEY_BLOB = extern struct {
    dwMagic: u32,
    cbKey: u32,
};

pub const SSL_ECCKEY_BLOB = extern struct {
    dwCurveType: u32,
    cbKey: u32,
};

pub const ECC_CURVE_TYPE_ENUM = extern enum(i32) {
    SHORT_WEIERSTRASS_CURVE = 1,
    TWISTED_EDWARDS_CURVE = 2,
    MONTGOMERY_CURVE = 3,
};
pub const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = ECC_CURVE_TYPE_ENUM.SHORT_WEIERSTRASS_CURVE;
pub const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = ECC_CURVE_TYPE_ENUM.TWISTED_EDWARDS_CURVE;
pub const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = ECC_CURVE_TYPE_ENUM.MONTGOMERY_CURVE;

pub const ECC_CURVE_ALG_ID_ENUM = extern enum(i32) {
    D = 0,
};
pub const BCRYPT_NO_CURVE_GENERATION_ALG_ID = ECC_CURVE_ALG_ID_ENUM.D;

pub const BCRYPT_ECCFULLKEY_BLOB = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    dwCurveType: ECC_CURVE_TYPE_ENUM,
    dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    cbFieldLength: u32,
    cbSubgroupOrder: u32,
    cbCofactor: u32,
    cbSeed: u32,
};

pub const BCRYPT_DH_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DH_KEY_BLOB_MAGIC,
    cbKey: u32,
};

pub const BCRYPT_DH_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
};

pub const BCRYPT_DSA_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const HASHALGORITHM_ENUM = extern enum(i32) {
    @"1" = 0,
    @"256" = 1,
    @"512" = 2,
};
pub const DSA_HASH_ALGORITHM_SHA1 = HASHALGORITHM_ENUM.@"1";
pub const DSA_HASH_ALGORITHM_SHA256 = HASHALGORITHM_ENUM.@"256";
pub const DSA_HASH_ALGORITHM_SHA512 = HASHALGORITHM_ENUM.@"512";

pub const DSAFIPSVERSION_ENUM = extern enum(i32) {
    @"2" = 0,
    @"3" = 1,
};
pub const DSA_FIPS186_2 = DSAFIPSVERSION_ENUM.@"2";
pub const DSA_FIPS186_3 = DSAFIPSVERSION_ENUM.@"3";

pub const BCRYPT_DSA_KEY_BLOB_V2 = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_KEY_DATA_BLOB_HEADER = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    cbKeyData: u32,
};

pub const BCRYPT_DSA_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const BCRYPT_DSA_PARAMETER_HEADER_V2 = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_ECC_CURVE_NAMES = extern struct {
    dwEccCurveNames: u32,
    pEccCurveNames: *PWSTR,
};

pub const BCRYPT_HASH_OPERATION_TYPE = extern enum(i32) {
    HASH_DATA = 1,
    FINISH_HASH = 2,
};
pub const BCRYPT_HASH_OPERATION_HASH_DATA = BCRYPT_HASH_OPERATION_TYPE.HASH_DATA;
pub const BCRYPT_HASH_OPERATION_FINISH_HASH = BCRYPT_HASH_OPERATION_TYPE.FINISH_HASH;

pub const BCRYPT_MULTI_HASH_OPERATION = extern struct {
    iHash: u32,
    hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pbBuffer: *u8,
    cbBuffer: u32,
};

pub const BCRYPT_MULTI_OPERATION_TYPE = extern enum(i32) {
    H = 1,
};
pub const BCRYPT_OPERATION_TYPE_HASH = BCRYPT_MULTI_OPERATION_TYPE.H;

pub const BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = extern struct {
    cbPerObject: u32,
    cbPerElement: u32,
};

pub const BCRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszName: PWSTR,
    dwClass: u32,
    dwFlags: u32,
};

pub const BCRYPT_PROVIDER_NAME = extern struct {
    pszProviderName: PWSTR,
};

pub const BCRYPT_INTERFACE_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const CRYPT_INTERFACE_REG = extern struct {
    dwInterface: BCRYPT_INTERFACE,
    dwFlags: BCRYPT_TABLE,
    cFunctions: u32,
    rgpszFunctions: *PWSTR,
};

pub const CRYPT_IMAGE_REG = extern struct {
    pszImage: PWSTR,
    cInterfaces: u32,
    rgpInterfaces: **CRYPT_INTERFACE_REG,
};

pub const CRYPT_PROVIDER_REG = extern struct {
    cAliases: u32,
    rgpszAliases: *PWSTR,
    pUM: *CRYPT_IMAGE_REG,
    pKM: *CRYPT_IMAGE_REG,
};

pub const CRYPT_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: *PWSTR,
};

pub const CRYPT_CONTEXT_CONFIG = extern struct {
    dwFlags: CRYPT_CONTEXT_CONFIG_FLAGS,
    dwReserved: u32,
};

pub const CRYPT_CONTEXT_FUNCTION_CONFIG = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

pub const CRYPT_CONTEXTS = extern struct {
    cContexts: u32,
    rgpszContexts: *PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTIONS = extern struct {
    cFunctions: u32,
    rgpszFunctions: *PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTION_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: *PWSTR,
};

pub const CRYPT_PROPERTY_REF = extern struct {
    pszProperty: PWSTR,
    cbValue: u32,
    pbValue: *u8,
};

pub const CRYPT_IMAGE_REF = extern struct {
    pszImage: PWSTR,
    dwFlags: CRYPT_IMAGE_REF_FLAGS,
};

pub const CRYPT_PROVIDER_REF = extern struct {
    dwInterface: u32,
    pszFunction: PWSTR,
    pszProvider: PWSTR,
    cProperties: u32,
    rgpProperties: **CRYPT_PROPERTY_REF,
    pUM: *CRYPT_IMAGE_REF,
    pKM: *CRYPT_IMAGE_REF,
};

pub const CRYPT_PROVIDER_REFS = extern struct {
    cProviders: u32,
    rgpProviders: **CRYPT_PROVIDER_REF,
};

pub const PFN_NCRYPT_ALLOC = fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_NCRYPT_FREE = fn(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NCRYPT_ALLOC_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: PFN_NCRYPT_ALLOC,
    pfnFree: PFN_NCRYPT_FREE,
};

pub const NCRYPT_CIPHER_PADDING_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pbIV: *u8,
    cbIV: u32,
    pbOtherInfo: *u8,
    cbOtherInfo: u32,
};

pub const NCRYPT_PLATFORM_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pcrMask: u32,
};

pub const NCRYPT_KEY_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pbKeyBlob: *u8,
    cbKeyBlob: u32,
    pbKeyAuth: *u8,
    cbKeyAuth: u32,
};

pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = extern struct {
    Version: u32,
    Flags: u32,
    cbPublicKeyBlob: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    cbSignature: u32,
    cbReport: u32,
    cbAttributes: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = extern struct {
    Version: u32,
    TrustletId: u64,
    MinSvn: u32,
    FlagsMask: u32,
    FlagsExpected: u32,
    _bitfield: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = extern struct {
    Version: u32,
    KeyUsage: u32,
    _bitfield: u32,
    cbAlgName: u32,
    cbNonce: u32,
    cbAuthTag: u32,
    cbWrappingKey: u32,
    cbIsolatedKey: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = extern struct {
    Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
};

pub const __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    HeaderSize: u32,
    cbCertifyInfo: u32,
    cbSignature: u32,
    cbTpmPublic: u32,
};

pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    pcrAlg: u32,
    cbSignature: u32,
    cbQuote: u32,
    cbPcrs: u32,
};

pub const NCryptAlgorithmName = extern struct {
    pszName: PWSTR,
    dwClass: NCRYPT_ALGORITHM_NAME_CLASS,
    dwAlgOperations: NCRYPT_OPERATION,
    dwFlags: u32,
};

pub const NCryptKeyName = extern struct {
    pszName: PWSTR,
    pszAlgid: PWSTR,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: u32,
};

pub const NCryptProviderName = extern struct {
    pszName: PWSTR,
    pszComment: PWSTR,
};

pub const NCRYPT_UI_POLICY = extern struct {
    dwVersion: u32,
    dwFlags: u32,
    pszCreationTitle: [*:0]const u16,
    pszFriendlyName: [*:0]const u16,
    pszDescription: [*:0]const u16,
};

pub const NCRYPT_KEY_ACCESS_POLICY_BLOB = extern struct {
    dwVersion: u32,
    dwPolicyFlags: u32,
    cbUserSid: u32,
    cbApplicationSid: u32,
};

pub const NCRYPT_SUPPORTED_LENGTHS = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
    dwDefaultLength: u32,
};

pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = extern struct {
    dwVersion: u32,
    iExpiration: i32,
    pabNonce: [32]u8,
    pabPolicyRef: [32]u8,
    pabHMAC: [32]u8,
};

pub const NCRYPT_PCP_TPM_FW_VERSION_INFO = extern struct {
    major1: u16,
    major2: u16,
    minor1: u16,
    minor2: u16,
};

pub const NCRYPT_PCP_RAW_POLICYDIGEST = extern struct {
    dwVersion: u32,
    cbDigest: u32,
};

pub const NCRYPT_KEY_BLOB_HEADER = extern struct {
    cbSize: u32,
    dwMagic: u32,
    cbAlgName: u32,
    cbKeyData: u32,
};

pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = extern struct {
    magic: u32,
    cbHeader: u32,
    cbPublic: u32,
    cbPrivate: u32,
    cbName: u32,
};

pub const CRYPT_BIT_BLOB = extern struct {
    cbData: u32,
    pbData: *u8,
    cUnusedBits: u32,
};

pub const CRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszObjId: PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_OBJID_TABLE = extern struct {
    dwAlgId: u32,
    pszObjId: [*:0]const u8,
};

pub const CRYPT_HASH_INFO = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
};

pub const CERT_EXTENSION = extern struct {
    pszObjId: PSTR,
    fCritical: BOOL,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE_TYPE_VALUE = extern struct {
    pszObjId: PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE = extern struct {
    pszObjId: PSTR,
    cValue: u32,
    rgValue: *CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTES = extern struct {
    cAttr: u32,
    rgAttr: *CRYPT_ATTRIBUTE,
};

pub const CERT_RDN_ATTR = extern struct {
    pszObjId: PSTR,
    dwValueType: CERT_RDN_ATTR_VALUE_TYPE,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_RDN = extern struct {
    cRDNAttr: u32,
    rgRDNAttr: *CERT_RDN_ATTR,
};

pub const CERT_NAME_INFO = extern struct {
    cRDN: u32,
    rgRDN: *CERT_RDN,
};

pub const CERT_NAME_VALUE = extern struct {
    dwValueType: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_PUBLIC_KEY_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_ECC_PRIVATE_KEY_INFO = extern struct {
    dwVersion: u32,
    PrivateKey: CRYPTOAPI_BLOB,
    szCurveOid: PSTR,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_PRIVATE_KEY_INFO = extern struct {
    Version: u32,
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PrivateKey: CRYPTOAPI_BLOB,
    pAttributes: *CRYPT_ATTRIBUTES,
};

pub const CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = extern struct {
    EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
};

pub const PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = fn(
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbClearTextKey: ?*u8,
    pcbClearTextKey: *u32,
    pVoidDecryptFunc: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = fn(
    pAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pClearTextPrivateKey: *CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbEncryptedKey: ?*u8,
    pcbEncryptedKey: *u32,
    pVoidEncryptFunc: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_RESOLVE_HCRYPTPROV_FUNC = fn(
    pPrivateKeyInfo: *CRYPT_PRIVATE_KEY_INFO,
    phCryptProv: *usize,
    pVoidResolveFunc: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PKCS8_IMPORT_PARAMS = extern struct {
    PrivateKey: CRYPTOAPI_BLOB,
    pResolvehCryptProvFunc: PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pVoidResolveFunc: *c_void,
    pDecryptPrivateKeyFunc: PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pVoidDecryptFunc: *c_void,
};

pub const CRYPT_PKCS8_EXPORT_PARAMS = extern struct {
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: PSTR,
    pEncryptPrivateKeyFunc: PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pVoidEncryptFunc: *c_void,
};

pub const CERT_INFO = extern struct {
    dwVersion: u32,
    SerialNumber: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    NotBefore: FILETIME,
    NotAfter: FILETIME,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    IssuerUniqueId: CRYPT_BIT_BLOB,
    SubjectUniqueId: CRYPT_BIT_BLOB,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CRL_ENTRY = extern struct {
    SerialNumber: CRYPTOAPI_BLOB,
    RevocationDate: FILETIME,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CRL_INFO = extern struct {
    dwVersion: u32,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cCRLEntry: u32,
    rgCRLEntry: *CRL_ENTRY,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CERT_OR_CRL_BLOB = extern struct {
    dwChoice: u32,
    cbEncoded: u32,
    pbEncoded: *u8,
};

pub const CERT_OR_CRL_BUNDLE = extern struct {
    cItem: u32,
    rgItem: *CERT_OR_CRL_BLOB,
};

pub const CERT_REQUEST_INFO = extern struct {
    dwVersion: u32,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    cAttribute: u32,
    rgAttribute: *CRYPT_ATTRIBUTE,
};

pub const CERT_KEYGEN_REQUEST_INFO = extern struct {
    dwVersion: u32,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pwszChallengeString: PWSTR,
};

pub const CERT_SIGNED_CONTENT_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
};

pub const CTL_USAGE = extern struct {
    cUsageIdentifier: u32,
    rgpszUsageIdentifier: *PSTR,
};

pub const CTL_ENTRY = extern struct {
    SubjectIdentifier: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: *CRYPT_ATTRIBUTE,
};

pub const CTL_INFO = extern struct {
    dwVersion: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    SequenceNumber: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cCTLEntry: u32,
    rgCTLEntry: *CTL_ENTRY,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CRYPT_TIME_STAMP_REQUEST_INFO = extern struct {
    pszTimeStampAlgorithm: PSTR,
    pszContentType: PSTR,
    Content: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: *CRYPT_ATTRIBUTE,
};

pub const CRYPT_ENROLLMENT_NAME_VALUE_PAIR = extern struct {
    pwszName: PWSTR,
    pwszValue: PWSTR,
};

pub const CRYPT_CSP_PROVIDER = extern struct {
    dwKeySpec: u32,
    pwszProviderName: PWSTR,
    Signature: CRYPT_BIT_BLOB,
};

pub const PFN_CRYPT_ALLOC = fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_CRYPT_FREE = fn(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ENCODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: PFN_CRYPT_ALLOC,
    pfnFree: PFN_CRYPT_FREE,
};

pub const CRYPT_DECODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: PFN_CRYPT_ALLOC,
    pfnFree: PFN_CRYPT_FREE,
};

pub const CERT_EXTENSIONS = extern struct {
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CERT_AUTHORITY_KEY_ID_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    CertIssuer: CRYPTOAPI_BLOB,
    CertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_PRIVATE_KEY_VALIDITY = extern struct {
    NotBefore: FILETIME,
    NotAfter: FILETIME,
};

pub const CERT_KEY_ATTRIBUTES_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    pPrivateKeyUsagePeriod: *CERT_PRIVATE_KEY_VALIDITY,
};

pub const CERT_POLICY_ID = extern struct {
    cCertPolicyElementId: u32,
    rgpszCertPolicyElementId: *PSTR,
};

pub const CERT_KEY_USAGE_RESTRICTION_INFO = extern struct {
    cCertPolicyId: u32,
    rgCertPolicyId: *CERT_POLICY_ID,
    RestrictedKeyUsage: CRYPT_BIT_BLOB,
};

pub const CERT_OTHER_NAME = extern struct {
    pszObjId: PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_ALT_NAME_ENTRY = extern struct {
    dwAltNameChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_ALT_NAME_INFO = extern struct {
    cAltEntry: u32,
    rgAltEntry: *CERT_ALT_NAME_ENTRY,
};

pub const CERT_BASIC_CONSTRAINTS_INFO = extern struct {
    SubjectType: CRYPT_BIT_BLOB,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
    cSubtreesConstraint: u32,
    rgSubtreesConstraint: *CRYPTOAPI_BLOB,
};

pub const CERT_BASIC_CONSTRAINTS2_INFO = extern struct {
    fCA: BOOL,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
};

pub const CERT_POLICY_QUALIFIER_INFO = extern struct {
    pszPolicyQualifierId: PSTR,
    Qualifier: CRYPTOAPI_BLOB,
};

pub const CERT_POLICY_INFO = extern struct {
    pszPolicyIdentifier: PSTR,
    cPolicyQualifier: u32,
    rgPolicyQualifier: *CERT_POLICY_QUALIFIER_INFO,
};

pub const CERT_POLICIES_INFO = extern struct {
    cPolicyInfo: u32,
    rgPolicyInfo: *CERT_POLICY_INFO,
};

pub const CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = extern struct {
    pszOrganization: PSTR,
    cNoticeNumbers: u32,
    rgNoticeNumbers: *i32,
};

pub const CERT_POLICY_QUALIFIER_USER_NOTICE = extern struct {
    pNoticeReference: *CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pszDisplayText: PWSTR,
};

pub const CPS_URLS = extern struct {
    pszURL: PWSTR,
    pAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pDigest: *CRYPTOAPI_BLOB,
};

pub const CERT_POLICY95_QUALIFIER1 = extern struct {
    pszPracticesReference: PWSTR,
    pszNoticeIdentifier: PSTR,
    pszNSINoticeIdentifier: PSTR,
    cCPSURLs: u32,
    rgCPSURLs: *CPS_URLS,
};

pub const CERT_POLICY_MAPPING = extern struct {
    pszIssuerDomainPolicy: PSTR,
    pszSubjectDomainPolicy: PSTR,
};

pub const CERT_POLICY_MAPPINGS_INFO = extern struct {
    cPolicyMapping: u32,
    rgPolicyMapping: *CERT_POLICY_MAPPING,
};

pub const CERT_POLICY_CONSTRAINTS_INFO = extern struct {
    fRequireExplicitPolicy: BOOL,
    dwRequireExplicitPolicySkipCerts: u32,
    fInhibitPolicyMapping: BOOL,
    dwInhibitPolicyMappingSkipCerts: u32,
};

pub const CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = extern struct {
    pszObjId: PSTR,
    cValue: u32,
    rgValue: *CRYPTOAPI_BLOB,
};

pub const CRYPT_CONTENT_INFO = extern struct {
    pszObjId: PSTR,
    Content: CRYPTOAPI_BLOB,
};

pub const CRYPT_SEQUENCE_OF_ANY = extern struct {
    cValue: u32,
    rgValue: *CRYPTOAPI_BLOB,
};

pub const CERT_AUTHORITY_KEY_ID2_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    AuthorityCertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ACCESS_DESCRIPTION = extern struct {
    pszAccessMethod: PSTR,
    AccessLocation: CERT_ALT_NAME_ENTRY,
};

pub const CERT_AUTHORITY_INFO_ACCESS = extern struct {
    cAccDescr: u32,
    rgAccDescr: *CERT_ACCESS_DESCRIPTION,
};

pub const CRL_DIST_POINT_NAME = extern struct {
    dwDistPointNameChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRL_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    ReasonFlags: CRYPT_BIT_BLOB,
    CRLIssuer: CERT_ALT_NAME_INFO,
};

pub const CRL_DIST_POINTS_INFO = extern struct {
    cDistPoint: u32,
    rgDistPoint: *CRL_DIST_POINT,
};

pub const CROSS_CERT_DIST_POINTS_INFO = extern struct {
    dwSyncDeltaTime: u32,
    cDistPoint: u32,
    rgDistPoint: *CERT_ALT_NAME_INFO,
};

pub const CERT_PAIR = extern struct {
    Forward: CRYPTOAPI_BLOB,
    Reverse: CRYPTOAPI_BLOB,
};

pub const CRL_ISSUING_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    fOnlyContainsUserCerts: BOOL,
    fOnlyContainsCACerts: BOOL,
    OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    fIndirectCRL: BOOL,
};

pub const CERT_GENERAL_SUBTREE = extern struct {
    Base: CERT_ALT_NAME_ENTRY,
    dwMinimum: u32,
    fMaximum: BOOL,
    dwMaximum: u32,
};

pub const CERT_NAME_CONSTRAINTS_INFO = extern struct {
    cPermittedSubtree: u32,
    rgPermittedSubtree: *CERT_GENERAL_SUBTREE,
    cExcludedSubtree: u32,
    rgExcludedSubtree: *CERT_GENERAL_SUBTREE,
};

pub const CERT_DSS_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_ECC_SIGNATURE = extern struct {
    r: CRYPTOAPI_BLOB,
    s: CRYPTOAPI_BLOB,
};

pub const CERT_X942_DH_VALIDATION_PARAMS = extern struct {
    seed: CRYPT_BIT_BLOB,
    pgenCounter: u32,
};

pub const CERT_X942_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    j: CRYPTOAPI_BLOB,
    pValidationParams: *CERT_X942_DH_VALIDATION_PARAMS,
};

pub const CRYPT_X942_OTHER_INFO = extern struct {
    pszContentEncryptionObjId: PSTR,
    rgbCounter: [4]u8,
    rgbKeyLength: [4]u8,
    PubInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_ECC_CMS_SHARED_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EntityUInfo: CRYPTOAPI_BLOB,
    rgbSuppPubInfo: [4]u8,
};

pub const CRYPT_RC2_CBC_PARAMETERS = extern struct {
    dwVersion: u32,
    fIV: BOOL,
    rgbIV: [8]u8,
};

pub const CRYPT_SMIME_CAPABILITY = extern struct {
    pszObjId: PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_SMIME_CAPABILITIES = extern struct {
    cCapability: u32,
    rgCapability: *CRYPT_SMIME_CAPABILITY,
};

pub const CERT_QC_STATEMENT = extern struct {
    pszStatementId: PSTR,
    StatementInfo: CRYPTOAPI_BLOB,
};

pub const CERT_QC_STATEMENTS_EXT_INFO = extern struct {
    cStatement: u32,
    rgStatement: *CERT_QC_STATEMENT,
};

pub const CRYPT_MASK_GEN_ALGORITHM = extern struct {
    pszObjId: PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_RSA_SSA_PSS_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    dwSaltLength: u32,
    dwTrailerField: u32,
};

pub const CRYPT_PSOURCE_ALGORITHM = extern struct {
    pszObjId: PSTR,
    EncodingParameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_RSAES_OAEP_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
};

pub const CMC_TAGGED_ATTRIBUTE = extern struct {
    dwBodyPartID: u32,
    Attribute: CRYPT_ATTRIBUTE,
};

pub const CMC_TAGGED_CERT_REQUEST = extern struct {
    dwBodyPartID: u32,
    SignedCertRequest: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_REQUEST = extern struct {
    dwTaggedRequestChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMC_TAGGED_CONTENT_INFO = extern struct {
    dwBodyPartID: u32,
    EncodedContentInfo: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_OTHER_MSG = extern struct {
    dwBodyPartID: u32,
    pszObjId: PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CMC_DATA_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: *CMC_TAGGED_ATTRIBUTE,
    cTaggedRequest: u32,
    rgTaggedRequest: *CMC_TAGGED_REQUEST,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: *CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: *CMC_TAGGED_OTHER_MSG,
};

pub const CMC_RESPONSE_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: *CMC_TAGGED_ATTRIBUTE,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: *CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: *CMC_TAGGED_OTHER_MSG,
};

pub const CMC_PEND_INFO = extern struct {
    PendToken: CRYPTOAPI_BLOB,
    PendTime: FILETIME,
};

pub const CMC_STATUS_INFO = extern struct {
    dwStatus: u32,
    cBodyList: u32,
    rgdwBodyList: *u32,
    pwszStatusString: PWSTR,
    dwOtherInfoChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMC_ADD_EXTENSIONS_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: *u32,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CMC_ADD_ATTRIBUTES_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: *u32,
    cAttribute: u32,
    rgAttribute: *CRYPT_ATTRIBUTE,
};

pub const CERT_TEMPLATE_EXT = extern struct {
    pszObjId: PSTR,
    dwMajorVersion: u32,
    fMinorVersion: BOOL,
    dwMinorVersion: u32,
};

pub const CERT_HASHED_URL = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
    pwszUrl: PWSTR,
};

pub const CERT_LOGOTYPE_DETAILS = extern struct {
    pwszMimeType: PWSTR,
    cHashedUrl: u32,
    rgHashedUrl: *CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_REFERENCE = extern struct {
    cHashedUrl: u32,
    rgHashedUrl: *CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_IMAGE_INFO = extern struct {
    dwLogotypeImageInfoChoice: CERT_LOGOTYPE_IMAGE_INFO_TYPE,
    dwFileSize: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwLogotypeImageResolutionChoice: CERT_LOGOTYPE_CHOICE,
    Anonymous: _Anonymous_e__Union,
    pwszLanguage: PWSTR,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_LOGOTYPE_IMAGE = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeImageInfo: *CERT_LOGOTYPE_IMAGE_INFO,
};

pub const CERT_LOGOTYPE_AUDIO_INFO = extern struct {
    dwFileSize: u32,
    dwPlayTime: u32,
    dwChannels: u32,
    dwSampleRate: u32,
    pwszLanguage: PWSTR,
};

pub const CERT_LOGOTYPE_AUDIO = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeAudioInfo: *CERT_LOGOTYPE_AUDIO_INFO,
};

pub const CERT_LOGOTYPE_DATA = extern struct {
    cLogotypeImage: u32,
    rgLogotypeImage: *CERT_LOGOTYPE_IMAGE,
    cLogotypeAudio: u32,
    rgLogotypeAudio: *CERT_LOGOTYPE_AUDIO,
};

pub const CERT_LOGOTYPE_INFO = extern struct {
    dwLogotypeInfoChoice: CERT_LOGOTYPE_OPTION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_OTHER_LOGOTYPE_INFO = extern struct {
    pszObjId: PSTR,
    LogotypeInfo: CERT_LOGOTYPE_INFO,
};

pub const CERT_LOGOTYPE_EXT_INFO = extern struct {
    cCommunityLogo: u32,
    rgCommunityLogo: *CERT_LOGOTYPE_INFO,
    pIssuerLogo: *CERT_LOGOTYPE_INFO,
    pSubjectLogo: *CERT_LOGOTYPE_INFO,
    cOtherLogo: u32,
    rgOtherLogo: *CERT_OTHER_LOGOTYPE_INFO,
};

pub const CERT_BIOMETRIC_DATA = extern struct {
    dwTypeOfBiometricDataChoice: CERT_BIOMETRIC_DATA_TYPE,
    Anonymous: _Anonymous_e__Union,
    HashedUrl: CERT_HASHED_URL,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_BIOMETRIC_EXT_INFO = extern struct {
    cBiometricData: u32,
    rgBiometricData: *CERT_BIOMETRIC_DATA,
};

pub const OCSP_SIGNATURE_INFO = extern struct {
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
    cCertEncoded: u32,
    rgCertEncoded: *CRYPTOAPI_BLOB,
};

pub const OCSP_SIGNED_REQUEST_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    pOptionalSignatureInfo: *OCSP_SIGNATURE_INFO,
};

pub const OCSP_CERT_ID = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IssuerNameHash: CRYPTOAPI_BLOB,
    IssuerKeyHash: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const OCSP_REQUEST_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const OCSP_REQUEST_INFO = extern struct {
    dwVersion: u32,
    pRequestorName: *CERT_ALT_NAME_ENTRY,
    cRequestEntry: u32,
    rgRequestEntry: *OCSP_REQUEST_ENTRY,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const OCSP_RESPONSE_INFO = extern struct {
    dwStatus: u32,
    pszObjId: PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const OCSP_BASIC_SIGNED_RESPONSE_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureInfo: OCSP_SIGNATURE_INFO,
};

pub const OCSP_BASIC_REVOKED_INFO = extern struct {
    RevocationDate: FILETIME,
    dwCrlReasonCode: CERT_REVOCATION_STATUS_REASON,
};

pub const OCSP_BASIC_RESPONSE_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    dwCertStatus: u32,
    Anonymous: _Anonymous_e__Union,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const OCSP_BASIC_RESPONSE_INFO = extern struct {
    dwVersion: u32,
    dwResponderIdChoice: u32,
    Anonymous: _Anonymous_e__Union,
    ProducedAt: FILETIME,
    cResponseEntry: u32,
    rgResponseEntry: *OCSP_BASIC_RESPONSE_ENTRY,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_SUPPORTED_ALGORITHM_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    IntendedCertPolicies: CERT_POLICIES_INFO,
};

pub const CERT_TPM_SPECIFICATION_INFO = extern struct {
    pwszFamily: PWSTR,
    dwLevel: u32,
    dwRevision: u32,
};

pub const CRYPT_OID_FUNC_ENTRY = extern struct {
    pszOID: [*:0]const u8,
    pvFuncAddr: *c_void,
};

pub const PFN_CRYPT_ENUM_OID_FUNC = fn(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pszOID: [*:0]const u8,
    cValue: u32,
    rgdwValueType: [*]const u32,
    rgpwszValueName: [*]const [*:0]const u16,
    rgpbValueData: [*]const *const u8,
    rgcbValueData: [*]const u32,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_OID_INFO = extern struct {
    cbSize: u32,
    pszOID: [*:0]const u8,
    pwszName: [*:0]const u16,
    dwGroupId: u32,
    Anonymous: _Anonymous_e__Union,
    ExtraInfo: CRYPTOAPI_BLOB,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFN_CRYPT_ENUM_OID_INFO = fn(
    pInfo: *CRYPT_OID_INFO,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STRONG_SIGN_SERIALIZED_INFO = extern struct {
    dwFlags: CERT_STRONG_SIGN_FLAGS,
    pwszCNGSignHashAlgids: PWSTR,
    pwszCNGPubKeyMinBitLengths: PWSTR,
};

pub const CERT_STRONG_SIGN_PARA = extern struct {
    cbSize: u32,
    dwInfoChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_ISSUER_SERIAL_NUMBER = extern struct {
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ID = extern struct {
    dwIdChoice: CERT_ID_OPTION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_SIGNER_ENCODE_INFO = extern struct {
    cbSize: u32,
    pCertInfo: *CERT_INFO,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: u32,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: *c_void,
    cAuthAttr: u32,
    rgAuthAttr: *CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: *CRYPT_ATTRIBUTE,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_SIGNED_ENCODE_INFO = extern struct {
    cbSize: u32,
    cSigners: u32,
    rgSigners: *CMSG_SIGNER_ENCODE_INFO,
    cCertEncoded: u32,
    rgCertEncoded: *CRYPTOAPI_BLOB,
    cCrlEncoded: u32,
    rgCrlEncoded: *CRYPTOAPI_BLOB,
};

pub const CMSG_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: *c_void,
    cRecipients: u32,
    rgpRecipients: **CERT_INFO,
};

pub const CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: *c_void,
    hCryptProv: usize,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = extern struct {
    cbSize: u32,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
    Date: FILETIME,
    pOtherAttr: *CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: *c_void,
    KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyWrapAuxInfo: *c_void,
    hCryptProv: usize,
    dwKeySpec: u32,
    dwKeyChoice: CMSG_KEY_AGREE_OPTION,
    Anonymous: _Anonymous_e__Union,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: **CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: *c_void,
    hCryptProv: usize,
    dwKeyChoice: u32,
    Anonymous: _Anonymous_e__Union,
    KeyId: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: *CRYPT_ATTRIBUTE_TYPE_VALUE,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_RECIPIENT_ENCODE_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_RC2_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SP3_COMPATIBLE_AUX_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const CMSG_RC4_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
};

pub const CMSG_HASHED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: *c_void,
};

pub const CMSG_ENCRYPTED_ENCODE_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: *c_void,
};

pub const PFN_CMSG_STREAM_OUTPUT = fn(
    pvArg: ?*const c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_STREAM_INFO = extern struct {
    cbContent: u32,
    pfnStreamOutput: PFN_CMSG_STREAM_OUTPUT,
    pvArg: *c_void,
};

pub const CMSG_SIGNER_INFO = extern struct {
    dwVersion: u32,
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_CMS_SIGNER_INFO = extern struct {
    dwVersion: u32,
    SignerId: CERT_ID,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_KEY_TRANS_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    RecipientId: CERT_ID,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = extern struct {
    RecipientId: CERT_ID,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: *CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: _Anonymous_e__Union,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: **CMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_MAIL_LIST_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    KeyId: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: *CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_CMS_RECIPIENT_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    dwSignerIndex: u32,
    dwSignerType: u32,
    pvSigner: *c_void,
};

pub const CMSG_CTRL_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: u32,
    dwRecipientIndex: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: u32,
    pKeyTrans: *CMSG_KEY_TRANS_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: u32,
    pKeyAgree: *CMSG_KEY_AGREE_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwRecipientEncryptedKeyIndex: u32,
    OriginatorPublicKey: CRYPT_BIT_BLOB,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    pMailList: *CMSG_MAIL_LIST_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwKeyChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    blob: CRYPTOAPI_BLOB,
};

pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    dwUnauthAttrIndex: u32,
};

pub const PFN_CMSG_ALLOC = fn(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_CMSG_FREE = fn(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CMSG_GEN_ENCRYPT_KEY = fn(
    phCryptProv: *usize,
    paiEncrypt: *CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptAuxInfo: ?*c_void,
    pPublicKeyInfo: *CERT_PUBLIC_KEY_INFO,
    pfnAlloc: PFN_CMSG_ALLOC,
    phEncryptKey: *usize,
    ppbEncryptParameters: **u8,
    pcbEncryptParameters: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_EXPORT_ENCRYPT_KEY = fn(
    hCryptProv: usize,
    hEncryptKey: usize,
    pPublicKeyInfo: *CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 4?
    pbData: ?*u8,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_ENCRYPT_KEY = fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    paiEncrypt: *CRYPT_ALGORITHM_IDENTIFIER,
    paiPubKey: *CRYPT_ALGORITHM_IDENTIFIER,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedKey: *u8,
    cbEncodedKey: u32,
    phEncryptKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CONTENT_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: *c_void,
    cRecipients: u32,
    rgCmsRecipients: *CMSG_RECIPIENT_ENCODE_INFO,
    pfnAlloc: PFN_CMSG_ALLOC,
    pfnFree: PFN_CMSG_FREE,
    dwEncryptFlags: u32,
    Anonymous: _Anonymous_e__Union,
    dwFlags: u32,
    fCNG: BOOL,
    pbCNGContentEncryptKeyObject: *u8,
    pbContentEncryptKey: *u8,
    cbContentEncryptKey: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = fn(
    pContentEncryptInfo: *CMSG_CONTENT_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_TRANS_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_TRANS = fn(
    pContentEncryptInfo: *CMSG_CONTENT_ENCRYPT_INFO,
    pKeyTransEncodeInfo: *CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    pKeyTransEncryptInfo: *CMSG_KEY_TRANS_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_KEY_AGREE_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: _Anonymous_e__Union,
    cKeyAgreeKeyEncryptInfo: u32,
    rgpKeyAgreeKeyEncryptInfo: **CMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    dwFlags: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFN_CMSG_EXPORT_KEY_AGREE = fn(
    pContentEncryptInfo: *CMSG_CONTENT_ENCRYPT_INFO,
    pKeyAgreeEncodeInfo: *CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    pKeyAgreeEncryptInfo: *CMSG_KEY_AGREE_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_MAIL_LIST_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_MAIL_LIST = fn(
    pContentEncryptInfo: *CMSG_CONTENT_ENCRYPT_INFO,
    pMailListEncodeInfo: *CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    pMailListEncryptInfo: *CMSG_MAIL_LIST_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_TRANS = fn(
    pContentEncryptionAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pKeyTransDecryptPara: *CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
    phContentEncryptKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_AGREE = fn(
    pContentEncryptionAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pKeyAgreeDecryptPara: *CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
    phContentEncryptKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_MAIL_LIST = fn(
    pContentEncryptionAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pMailListDecryptPara: *CMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
    phContentEncryptKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CNG_CONTENT_DECRYPT_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pfnAlloc: PFN_CMSG_ALLOC,
    pfnFree: PFN_CMSG_FREE,
    hNCryptKey: usize,
    pbContentEncryptKey: *u8,
    cbContentEncryptKey: u32,
    hCNGContentEncryptKey: *c_void,
    pbCNGContentEncryptKeyObject: *u8,
};

pub const PFN_CMSG_CNG_IMPORT_KEY_TRANS = fn(
    pCNGContentDecryptInfo: *CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyTransDecryptPara: *CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_KEY_AGREE = fn(
    pCNGContentDecryptInfo: *CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyAgreeDecryptPara: *CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = fn(
    pCNGContentDecryptInfo: *CMSG_CNG_CONTENT_DECRYPT_INFO,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCertEncoded: *u8,
    cbCertEncoded: u32,
    pCertInfo: *CERT_INFO,
    hCertStore: *c_void,
};

pub const CRL_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCrlEncoded: *u8,
    cbCrlEncoded: u32,
    pCrlInfo: *CRL_INFO,
    hCertStore: *c_void,
};

pub const CTL_CONTEXT = extern struct {
    dwMsgAndCertEncodingType: u32,
    pbCtlEncoded: *u8,
    cbCtlEncoded: u32,
    pCtlInfo: *CTL_INFO,
    hCertStore: *c_void,
    hCryptMsg: *c_void,
    pbCtlContent: *u8,
    cbCtlContent: u32,
};

pub const CertKeyType = extern enum(u32) {
    Other = 0,
    VirtualSmartCard = 1,
    PhysicalSmartCard = 2,
    Passport = 3,
    PassportRemote = 4,
    PassportSmartCard = 5,
    Hardware = 6,
    Software = 7,
    SelfSigned = 8,
};
pub const KeyTypeOther = CertKeyType.Other;
pub const KeyTypeVirtualSmartCard = CertKeyType.VirtualSmartCard;
pub const KeyTypePhysicalSmartCard = CertKeyType.PhysicalSmartCard;
pub const KeyTypePassport = CertKeyType.Passport;
pub const KeyTypePassportRemote = CertKeyType.PassportRemote;
pub const KeyTypePassportSmartCard = CertKeyType.PassportSmartCard;
pub const KeyTypeHardware = CertKeyType.Hardware;
pub const KeyTypeSoftware = CertKeyType.Software;
pub const KeyTypeSelfSigned = CertKeyType.SelfSigned;

pub const CRYPT_KEY_PROV_PARAM = extern struct {
    dwParam: u32,
    pbData: *u8,
    cbData: u32,
    dwFlags: u32,
};

pub const CRYPT_KEY_PROV_INFO = extern struct {
    pwszContainerName: PWSTR,
    pwszProvName: PWSTR,
    dwProvType: u32,
    dwFlags: CRYPT_KEY_PROV_FLAGS,
    cProvParam: u32,
    rgProvParam: *CRYPT_KEY_PROV_PARAM,
    dwKeySpec: u32,
};

pub const CERT_KEY_CONTEXT = extern struct {
    cbSize: u32,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ROOT_INFO_LUID = extern struct {
    LowPart: u32,
    HighPart: i32,
};

pub const CRYPT_SMART_CARD_ROOT_INFO = extern struct {
    rgbCardID: [16]u8,
    luid: ROOT_INFO_LUID,
};

pub const CERT_SYSTEM_STORE_RELOCATE_PARA = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const CERT_REGISTRY_STORE_CLIENT_GPT_PARA = extern struct {
    hKeyBase: HKEY,
    pwszRegPath: PWSTR,
};

pub const CERT_REGISTRY_STORE_ROAMING_PARA = extern struct {
    hKey: HKEY,
    pwszStoreDirectory: PWSTR,
};

pub const CERT_LDAP_STORE_OPENED_PARA = extern struct {
    pvLdapSessionHandle: *c_void,
    pwszLdapUrl: [*:0]const u16,
};

pub const CERT_STORE_PROV_INFO = extern struct {
    cbSize: u32,
    cStoreProvFunc: u32,
    rgpvStoreProvFunc: **c_void,
    hStoreProv: *c_void,
    dwStoreProvFlags: CERT_STORE_PROV_FLAGS,
    hStoreProvFuncAddr2: *c_void,
};

pub const PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = fn(
    lpszStoreProvider: [*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: usize,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const c_void,
    hCertStore: *c_void,
    pStoreProvInfo: *CERT_STORE_PROV_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CLOSE = fn(
    hStoreProv: ?*c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CERT_STORE_PROV_READ_CERT = fn(
    hStoreProv: *c_void,
    pStoreCertContext: *CERT_CONTEXT,
    dwFlags: u32,
    ppProvCertContext: **CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CERT = fn(
    hStoreProv: *c_void,
    pCertContext: *CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CERT = fn(
    hStoreProv: *c_void,
    pCertContext: *CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = fn(
    hStoreProv: *c_void,
    pCertContext: *CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CRL = fn(
    hStoreProv: *c_void,
    pStoreCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
    ppProvCrlContext: **CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CRL = fn(
    hStoreProv: *c_void,
    pCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CRL = fn(
    hStoreProv: *c_void,
    pCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = fn(
    hStoreProv: *c_void,
    pCrlContext: *CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CTL = fn(
    hStoreProv: *c_void,
    pStoreCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
    ppProvCtlContext: **CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CTL = fn(
    hStoreProv: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CTL = fn(
    hStoreProv: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = fn(
    hStoreProv: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CONTROL = fn(
    hStoreProv: *c_void,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STORE_PROV_FIND_INFO = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: *const c_void,
};

pub const PFN_CERT_STORE_PROV_FIND_CERT = fn(
    hStoreProv: *c_void,
    pFindInfo: *CERT_STORE_PROV_FIND_INFO,
    pPrevCertContext: *CERT_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: **c_void,
    ppProvCertContext: **CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CERT = fn(
    hStoreProv: *c_void,
    pCertContext: *CERT_CONTEXT,
    pvStoreProvFindInfo: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = fn(
    hStoreProv: *c_void,
    pCertContext: *CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CRL = fn(
    hStoreProv: *c_void,
    pFindInfo: *CERT_STORE_PROV_FIND_INFO,
    pPrevCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: **c_void,
    ppProvCrlContext: **CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CRL = fn(
    hStoreProv: *c_void,
    pCrlContext: *CRL_CONTEXT,
    pvStoreProvFindInfo: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = fn(
    hStoreProv: *c_void,
    pCrlContext: *CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CTL = fn(
    hStoreProv: *c_void,
    pFindInfo: *CERT_STORE_PROV_FIND_INFO,
    pPrevCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: **c_void,
    ppProvCtlContext: **CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CTL = fn(
    hStoreProv: *c_void,
    pCtlContext: *CTL_CONTEXT,
    pvStoreProvFindInfo: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = fn(
    hStoreProv: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRL_FIND_ISSUED_FOR_PARA = extern struct {
    pSubjectCert: *CERT_CONTEXT,
    pIssuerCert: *CERT_CONTEXT,
};

pub const CTL_ANY_SUBJECT_INFO = extern struct {
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    SubjectIdentifier: CRYPTOAPI_BLOB,
};

pub const CTL_FIND_USAGE_PARA = extern struct {
    cbSize: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    pSigner: *CERT_INFO,
};

pub const CTL_FIND_SUBJECT_PARA = extern struct {
    cbSize: u32,
    pUsagePara: *CTL_FIND_USAGE_PARA,
    dwSubjectType: u32,
    pvSubject: *c_void,
};

pub const PFN_CERT_CREATE_CONTEXT_SORT_FUNC = fn(
    cbTotalEncoded: u32,
    cbRemainEncoded: u32,
    cEntry: u32,
    pvSort: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CREATE_CONTEXT_PARA = extern struct {
    cbSize: u32,
    pfnFree: PFN_CRYPT_FREE,
    pvFree: *c_void,
    pfnSort: PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pvSort: *c_void,
};

pub const CERT_SYSTEM_STORE_INFO = extern struct {
    cbSize: u32,
};

pub const CERT_PHYSICAL_STORE_INFO = extern struct {
    cbSize: u32,
    pszOpenStoreProvider: PSTR,
    dwOpenEncodingType: u32,
    dwOpenFlags: u32,
    OpenParameters: CRYPTOAPI_BLOB,
    dwFlags: u32,
    dwPriority: u32,
};

pub const PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = fn(
    pwszStoreLocation: [*:0]const u16,
    dwFlags: u32,
    pvReserved: *c_void,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_SYSTEM_STORE = fn(
    pvSystemStore: *const c_void,
    dwFlags: CERT_SYSTEM_STORE_FLAGS,
    pStoreInfo: *CERT_SYSTEM_STORE_INFO,
    pvReserved: *c_void,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_PHYSICAL_STORE = fn(
    pvSystemStore: *const c_void,
    dwFlags: u32,
    pwszStoreName: [*:0]const u16,
    pStoreInfo: *CERT_PHYSICAL_STORE_INFO,
    pvReserved: *c_void,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CTL_VERIFY_USAGE_PARA = extern struct {
    cbSize: u32,
    ListIdentifier: CRYPTOAPI_BLOB,
    cCtlStore: u32,
    rghCtlStore: **c_void,
    cSignerStore: u32,
    rghSignerStore: **c_void,
};

pub const CTL_VERIFY_USAGE_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    dwFlags: u32,
    ppCtl: **CTL_CONTEXT,
    dwCtlEntryIndex: u32,
    ppSigner: **CERT_CONTEXT,
    dwSignerIndex: u32,
};

pub const CERT_REVOCATION_CRL_INFO = extern struct {
    cbSize: u32,
    pBaseCrlContext: *CRL_CONTEXT,
    pDeltaCrlContext: *CRL_CONTEXT,
    pCrlEntry: *CRL_ENTRY,
    fDeltaCrlEntry: BOOL,
};

pub const CERT_REVOCATION_PARA = extern struct {
    cbSize: u32,
    pIssuerCert: *CERT_CONTEXT,
    cCertStore: u32,
    rgCertStore: **c_void,
    hCrlStore: *c_void,
    pftTimeToUse: *FILETIME,
};

pub const CERT_REVOCATION_STATUS = extern struct {
    cbSize: u32,
    dwIndex: u32,
    dwError: u32,
    dwReason: CERT_REVOCATION_STATUS_REASON,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
};

pub const CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = extern struct {
    CertSignHashCNGAlgPropData: CRYPTOAPI_BLOB,
    CertIssuerPubKeyBitLengthPropData: CRYPTOAPI_BLOB,
};

pub const CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = extern struct {
    cCNGHashAlgid: u32,
    rgpwszCNGHashAlgid: *PWSTR,
    dwWeakIndex: u32,
};

pub const PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = fn(
    dwCertEncodingType: u32,
    pSignatureAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    ppvDecodedSignPara: ?*?*c_void,
    ppwszCNGHashAlgid: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = fn(
    hKey: usize,
    dwCertEncodingType: u32,
    pSignatureAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*c_void,
    pwszCNGPubKeyAlgid: [*:0]const u16,
    pwszCNGHashAlgid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: *u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: ?*u8,
    pcbSignature: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = fn(
    dwCertEncodingType: u32,
    pPubKeyInfo: *CERT_PUBLIC_KEY_INFO,
    pSignatureAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*c_void,
    pwszCNGPubKeyAlgid: [*:0]const u16,
    pwszCNGHashAlgid: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: *u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: *u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = extern struct {
    cOID: u32,
    rgpszOID: *PSTR,
};

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = fn(
    hNCryptKey: usize,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = fn(
    hBCryptKey: *c_void,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = fn(
    dwCertEncodingType: u32,
    pInfo: *CERT_PUBLIC_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    phKey: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PRIV_KEY_FUNC = fn(
    hCryptProv: usize,
    pPrivateKeyInfo: *CRYPT_PRIVATE_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_EXPORT_PRIV_KEY_FUNC = fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 6?
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    pcbPrivateKeyInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_GET_SIGNER_CERTIFICATE = fn(
    pvGetArg: ?*c_void,
    dwCertEncodingType: u32,
    pSignerId: *CERT_INFO,
    hMsgCertStore: *c_void,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

pub const CRYPT_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    pSigningCert: *CERT_CONTEXT,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: *c_void,
    cMsgCert: u32,
    rgpMsgCert: **CERT_CONTEXT,
    cMsgCrl: u32,
    rgpMsgCrl: **CRL_CONTEXT,
    cAuthAttr: u32,
    rgAuthAttr: *CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: *CRYPT_ATTRIBUTE,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    hCryptProv: usize,
    pfnGetSignerCertificate: PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pvGetArg: *c_void,
};

pub const CRYPT_ENCRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: *c_void,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_DECRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    cCertStore: u32,
    rghCertStore: **c_void,
};

pub const CRYPT_HASH_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: *c_void,
};

pub const CRYPT_KEY_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    Anonymous: _Anonymous_e__Union,
    dwKeySpec: CERT_KEY_SPEC,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: *c_void,
    PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPT_KEY_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
};

pub const CERT_CHAIN = extern struct {
    cCerts: u32,
    certs: *CRYPTOAPI_BLOB,
    keyLocatorInfo: CRYPT_KEY_PROV_INFO,
};

pub const PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = fn(
    pszParamOid: PSTR,
    pvParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_BLOB_ARRAY = extern struct {
    cBlob: u32,
    rgBlob: *CRYPTOAPI_BLOB,
};

pub const CRYPT_CREDENTIALS = extern struct {
    cbSize: u32,
    pszCredentialsOid: [*:0]const u8,
    pvCredentials: *c_void,
};

pub const CRYPT_PASSWORD_CREDENTIALSA = extern struct {
    cbSize: u32,
    pszUsername: PSTR,
    pszPassword: PSTR,
};

pub const CRYPT_PASSWORD_CREDENTIALSW = extern struct {
    cbSize: u32,
    pszUsername: PWSTR,
    pszPassword: PWSTR,
};

pub const PFN_FREE_ENCODED_OBJECT_FUNC = fn(
    pszObjectOid: ?[*:0]const u8,
    pObject: *CRYPT_BLOB_ARRAY,
    pvFreeContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPTNET_URL_CACHE_PRE_FETCH_INFO = extern struct {
    cbSize: u32,
    dwObjectType: u32,
    dwError: u32,
    dwReserved: u32,
    ThisUpdateTime: FILETIME,
    NextUpdateTime: FILETIME,
    PublishTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_FLUSH_INFO = extern struct {
    cbSize: u32,
    dwExemptSeconds: u32,
    ExpireTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_RESPONSE_INFO = extern struct {
    cbSize: u32,
    wResponseType: u16,
    wResponseFlags: u16,
    LastModifiedTime: FILETIME,
    dwMaxAge: u32,
    pwszETag: [*:0]const u16,
    dwProxyId: u32,
};

pub const CRYPT_RETRIEVE_AUX_INFO = extern struct {
    cbSize: u32,
    pLastSyncTime: *FILETIME,
    dwMaxUrlRetrievalByteCount: u32,
    pPreFetchInfo: *CRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pFlushInfo: *CRYPTNET_URL_CACHE_FLUSH_INFO,
    ppResponseInfo: **CRYPTNET_URL_CACHE_RESPONSE_INFO,
    pwszCacheFileNamePrefix: PWSTR,
    pftCacheResync: *FILETIME,
    fProxyCacheRetrieval: BOOL,
    dwHttpStatusCode: u32,
    ppwszErrorResponseHeaders: *PWSTR,
    ppErrorContentBlob: **CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_CANCEL_RETRIEVAL = fn(
    dwFlags: u32,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = fn(
    pvCompletion: ?*c_void,
    dwCompletionCode: u32,
    pszUrl: [*:0]const u8,
    pszObjectOid: ?PSTR,
    pvObject: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ASYNC_RETRIEVAL_COMPLETION = extern struct {
    pfnCompletion: PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pvCompletion: *c_void,
};

pub const PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = fn(
    hAsyncRetrieve: HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_URL_ARRAY = extern struct {
    cUrl: u32,
    rgwszUrl: *PWSTR,
};

pub const CRYPT_URL_INFO = extern struct {
    cbSize: u32,
    dwSyncDeltaTime: u32,
    cGroup: u32,
    rgcGroupEntry: *u32,
};

pub const CERT_CRL_CONTEXT_PAIR = extern struct {
    pCertContext: *CERT_CONTEXT,
    pCrlContext: *CRL_CONTEXT,
};

pub const CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = extern struct {
    cbSize: u32,
    iDeltaCrlIndicator: i32,
    pftCacheResync: *FILETIME,
    pLastSyncTime: *FILETIME,
    pMaxAgeTime: *FILETIME,
    pChainPara: *CERT_REVOCATION_CHAIN_PARA,
    pDeltaCrlIndicator: *CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_KEYID_PROP = fn(
    pKeyIdentifier: *const CRYPTOAPI_BLOB,
    dwFlags: u32,
    pvReserved: *c_void,
    pvArg: ?*c_void,
    cProp: u32,
    rgdwPropId: [*]u32,
    rgpvData: [*]*c_void,
    rgcbData: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_ENGINE_CONFIG = extern struct {
    cbSize: u32,
    hRestrictedRoot: *c_void,
    hRestrictedTrust: *c_void,
    hRestrictedOther: *c_void,
    cAdditionalStore: u32,
    rghAdditionalStore: **c_void,
    dwFlags: u32,
    dwUrlRetrievalTimeout: u32,
    MaximumCachedCertificates: u32,
    CycleDetectionModulus: u32,
    hExclusiveRoot: *c_void,
    hExclusiveTrustedPeople: *c_void,
    dwExclusiveFlags: u32,
};

pub const CERT_TRUST_STATUS = extern struct {
    dwErrorStatus: u32,
    dwInfoStatus: u32,
};

pub const CERT_REVOCATION_INFO = extern struct {
    cbSize: u32,
    dwRevocationResult: u32,
    pszRevocationOid: [*:0]const u8,
    pvOidSpecificInfo: *c_void,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
    pCrlInfo: *CERT_REVOCATION_CRL_INFO,
};

pub const CERT_TRUST_LIST_INFO = extern struct {
    cbSize: u32,
    pCtlEntry: *CTL_ENTRY,
    pCtlContext: *CTL_CONTEXT,
};

pub const CERT_CHAIN_ELEMENT = extern struct {
    cbSize: u32,
    pCertContext: *CERT_CONTEXT,
    TrustStatus: CERT_TRUST_STATUS,
    pRevocationInfo: *CERT_REVOCATION_INFO,
    pIssuanceUsage: *CTL_USAGE,
    pApplicationUsage: *CTL_USAGE,
    pwszExtendedErrorInfo: [*:0]const u16,
};

pub const CERT_SIMPLE_CHAIN = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cElement: u32,
    rgpElement: **CERT_CHAIN_ELEMENT,
    pTrustListInfo: *CERT_TRUST_LIST_INFO,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
};

pub const CERT_CHAIN_CONTEXT = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cChain: u32,
    rgpChain: **CERT_SIMPLE_CHAIN,
    cLowerQualityChainContext: u32,
    rgpLowerQualityChainContext: **CERT_CHAIN_CONTEXT,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
    dwCreateFlags: u32,
    ChainId: Guid,
};

pub const CERT_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CTL_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CERT_CHAIN_PARA = extern struct {
    cbSize: u32,
    RequestedUsage: CERT_USAGE_MATCH,
};

pub const CERT_REVOCATION_CHAIN_PARA = extern struct {
    cbSize: u32,
    hChainEngine: HCERTCHAINENGINE,
    hAdditionalStore: *c_void,
    dwChainFlags: u32,
    dwUrlRetrievalTimeout: u32,
    pftCurrentTime: *FILETIME,
    pftCacheResync: *FILETIME,
    cbMaxUrlRetrievalByteCount: u32,
};

pub const CRL_REVOCATION_INFO = extern struct {
    pCrlEntry: *CRL_ENTRY,
    pCrlContext: *CRL_CONTEXT,
    pCrlIssuerChain: *CERT_CHAIN_CONTEXT,
};

pub const PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = fn(
    pCert: *CERT_CONTEXT,
    pvFindArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_FIND_BY_ISSUER_PARA = extern struct {
    cbSize: u32,
    pszUsageIdentifier: [*:0]const u8,
    dwKeySpec: u32,
    dwAcquirePrivateKeyFlags: u32,
    cIssuer: u32,
    rgIssuer: *CRYPTOAPI_BLOB,
    pfnFindCallback: PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pvFindArg: *c_void,
};

pub const CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwFlags: CERT_CHAIN_POLICY_FLAGS,
    pvExtraPolicyPara: *c_void,
};

pub const CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    lChainIndex: i32,
    lElementIndex: i32,
    pvExtraPolicyStatus: *c_void,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    pSignerInfo: *CMSG_SIGNER_INFO,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    fCommercial: BOOL,
};

pub const AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    fCommercial: BOOL,
};

pub const HTTPSPolicyCallbackData = extern struct {
    Anonymous: _Anonymous_e__Union,
    dwAuthType: HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE,
    fdwChecks: u32,
    pwszServerName: PWSTR,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRootProgramQualifierFlags: CERT_ROOT_PROGRAM_FLAGS,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwQualifiers: u32,
    dwIssuanceUsageIndex: u32,
};

pub const SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwErrorLevel: u32,
    dwErrorCategory: u32,
    dwReserved: u32,
    wszErrorText: [256]u16,
};

pub const SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: PWSTR,
    rgpszHpkpValue: [2]*i8,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: [*:0]const u16,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    lError: i32,
    wszErrorText: [512]u16,
};

pub const CRYPT_PKCS12_PBE_PARAMS = extern struct {
    iIterations: i32,
    cbSalt: u32,
};

pub const PKCS12_PBES2_EXPORT_PARAMS = extern struct {
    dwSize: u32,
    hNcryptDescriptor: *c_void,
    pwszPbes2Alg: PWSTR,
};

pub const CERT_SERVER_OCSP_RESPONSE_CONTEXT = extern struct {
    cbSize: u32,
    pbEncodedOcspResponse: *u8,
    cbEncodedOcspResponse: u32,
};

pub const PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = fn(
    pChainContext: *CERT_CHAIN_CONTEXT,
    pServerOcspResponseContext: *CERT_SERVER_OCSP_RESPONSE_CONTEXT,
    pNewCrlContext: *CRL_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pvArg: ?*c_void,
    dwWriteOcspFileError: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pcbUsedSize: *u32,
    pwszOcspDirectory: PWSTR,
    pfnUpdateCallback: PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pvUpdateCallbackArg: *c_void,
};

pub const CERT_SELECT_CHAIN_PARA = extern struct {
    hChainEngine: HCERTCHAINENGINE,
    pTime: *FILETIME,
    hAdditionalStore: *c_void,
    pChainPara: *CERT_CHAIN_PARA,
    dwFlags: u32,
};

pub const CERT_SELECT_CRITERIA = extern struct {
    dwType: CERT_SELECT_CRITERIA_TYPE,
    cPara: u32,
    ppPara: **c_void,
};

pub const CRYPT_TIMESTAMP_REQUEST = extern struct {
    dwVersion: CRYPT_TIMESTAMP_VERSION,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    pszTSAPolicyId: PSTR,
    Nonce: CRYPTOAPI_BLOB,
    fCertReq: BOOL,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_RESPONSE = extern struct {
    dwStatus: CRYPT_TIMESTAMP_RESPONSE_STATUS,
    cFreeText: u32,
    rgFreeText: *PWSTR,
    FailureInfo: CRYPT_BIT_BLOB,
    ContentInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_TIMESTAMP_ACCURACY = extern struct {
    dwSeconds: u32,
    dwMillis: u32,
    dwMicros: u32,
};

pub const CRYPT_TIMESTAMP_INFO = extern struct {
    dwVersion: u32,
    pszTSAPolicyId: PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    ftTime: FILETIME,
    pvAccuracy: *CRYPT_TIMESTAMP_ACCURACY,
    fOrdering: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    Tsa: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_CONTEXT = extern struct {
    cbEncoded: u32,
    pbEncoded: *u8,
    pTimeStamp: *CRYPT_TIMESTAMP_INFO,
};

pub const CRYPT_TIMESTAMP_PARA = extern struct {
    pszTSAPolicyId: [*:0]const u8,
    fRequestCerts: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: *CERT_EXTENSION,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = fn(
    pContext: *c_void,
    rgIdentifierOrNameList: [*]*CRYPTOAPI_BLOB,
    dwIdentifierOrNameListCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = fn(
    pPluginContext: ?*c_void,
    pIdentifier: ?*CRYPTOAPI_BLOB,
    dwNameType: u32,
    pNameBlob: *CRYPTOAPI_BLOB,
    ppbContent: **u8,
    pcbContent: *u32,
    ppwszPassword: ?*?PWSTR,
    ppIdentifier: ?*?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE = fn(
    dwReason: CRYPT_OBJECT_LOCATOR_RELEASE_REASON,
    pPluginContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD = fn(
    pPluginContext: ?*c_void,
    pwszPassword: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE = fn(
    pPluginContext: ?*c_void,
    pbData: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = fn(
    pPluginContext: ?*c_void,
    pIdentifier: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = extern struct {
    cbSize: u32,
    pfnGet: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pfnRelease: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pfnFreePassword: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pfnFree: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pfnFreeIdentifier: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = fn(
    pfnFlush: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
    pContext: *c_void,
    pdwExpectedObjectCount: *u32,
    ppFuncTable: **CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
    ppPluginContext: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_IS_WEAK_HASH = fn(
    dwHashUseType: u32,
    pwszCNGHashAlgid: [*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: u32,
    dwPromptFlags: u32,
    hwndApp: HWND,
    szPrompt: [*:0]const u16,
};

pub const eTlsSignatureAlgorithm = extern enum(i32) {
    Anonymous = 0,
    Rsa = 1,
    Dsa = 2,
    Ecdsa = 3,
};
pub const TlsSignatureAlgorithm_Anonymous = eTlsSignatureAlgorithm.Anonymous;
pub const TlsSignatureAlgorithm_Rsa = eTlsSignatureAlgorithm.Rsa;
pub const TlsSignatureAlgorithm_Dsa = eTlsSignatureAlgorithm.Dsa;
pub const TlsSignatureAlgorithm_Ecdsa = eTlsSignatureAlgorithm.Ecdsa;

pub const eTlsHashAlgorithm = extern enum(i32) {
    None = 0,
    Md5 = 1,
    Sha1 = 2,
    Sha224 = 3,
    Sha256 = 4,
    Sha384 = 5,
    Sha512 = 6,
};
pub const TlsHashAlgorithm_None = eTlsHashAlgorithm.None;
pub const TlsHashAlgorithm_Md5 = eTlsHashAlgorithm.Md5;
pub const TlsHashAlgorithm_Sha1 = eTlsHashAlgorithm.Sha1;
pub const TlsHashAlgorithm_Sha224 = eTlsHashAlgorithm.Sha224;
pub const TlsHashAlgorithm_Sha256 = eTlsHashAlgorithm.Sha256;
pub const TlsHashAlgorithm_Sha384 = eTlsHashAlgorithm.Sha384;
pub const TlsHashAlgorithm_Sha512 = eTlsHashAlgorithm.Sha512;

pub const SecPkgContext_RemoteCredentialInfo = extern struct {
    cbCertificateChain: u32,
    pbCertificateChain: *u8,
    cCertificates: u32,
    fFlags: u32,
    dwBits: u32,
};

pub const SecPkgContext_LocalCredentialInfo = extern struct {
    cbCertificateChain: u32,
    pbCertificateChain: *u8,
    cCertificates: u32,
    fFlags: u32,
    dwBits: u32,
};

pub const SecPkgContext_ClientCertPolicyResult = extern struct {
    dwPolicyResult: HRESULT,
    guidPolicyId: Guid,
};

pub const SecPkgContext_IssuerListInfoEx = extern struct {
    aIssuers: *CRYPTOAPI_BLOB,
    cIssuers: u32,
};

pub const SecPkgContext_ConnectionInfo = extern struct {
    dwProtocol: u32,
    aiCipher: u32,
    dwCipherStrength: u32,
    aiHash: u32,
    dwHashStrength: u32,
    aiExch: u32,
    dwExchStrength: u32,
};

pub const SecPkgContext_ConnectionInfoEx = extern struct {
    dwVersion: u32,
    dwProtocol: u32,
    szCipher: [64]u16,
    dwCipherStrength: u32,
    szHash: [64]u16,
    dwHashStrength: u32,
    szExchange: [64]u16,
    dwExchStrength: u32,
};

pub const SecPkgContext_CipherInfo = extern struct {
    dwVersion: u32,
    dwProtocol: u32,
    dwCipherSuite: u32,
    dwBaseCipherSuite: u32,
    szCipherSuite: [64]u16,
    szCipher: [64]u16,
    dwCipherLen: u32,
    dwCipherBlockLen: u32,
    szHash: [64]u16,
    dwHashLen: u32,
    szExchange: [64]u16,
    dwMinExchangeLen: u32,
    dwMaxExchangeLen: u32,
    szCertificate: [64]u16,
    dwKeyType: u32,
};

pub const SecPkgContext_EapKeyBlock = extern struct {
    rgbKeys: [128]u8,
    rgbIVs: [64]u8,
};

pub const SecPkgContext_MappedCredAttr = extern struct {
    dwAttribute: u32,
    pvBuffer: *c_void,
};

pub const SecPkgContext_SessionInfo = extern struct {
    dwFlags: u32,
    cbSessionId: u32,
    rgbSessionId: [32]u8,
};

pub const SecPkgContext_SessionAppData = extern struct {
    dwFlags: u32,
    cbAppData: u32,
    pbAppData: *u8,
};

pub const SecPkgContext_EapPrfInfo = extern struct {
    dwVersion: u32,
    cbPrfData: u32,
    pbPrfData: *u8,
};

pub const SecPkgContext_SupportedSignatures = extern struct {
    cSignatureAndHashAlgorithms: u16,
    pSignatureAndHashAlgorithms: *u16,
};

pub const SecPkgContext_Certificates = extern struct {
    cCertificates: u32,
    cbCertificateChain: u32,
    pbCertificateChain: *u8,
};

pub const SecPkgContext_CertInfo = extern struct {
    dwVersion: u32,
    cbSubjectName: u32,
    pwszSubjectName: PWSTR,
    cbIssuerName: u32,
    pwszIssuerName: PWSTR,
    dwKeySize: u32,
};

pub const SecPkgContext_UiInfo = extern struct {
    hParentWindow: HWND,
};

pub const SecPkgContext_EarlyStart = extern struct {
    dwEarlyStartFlags: u32,
};

pub const SecPkgContext_KeyingMaterialInfo = extern struct {
    cbLabel: u16,
    pszLabel: PSTR,
    cbContextValue: u16,
    pbContextValue: *u8,
    cbKeyingMaterial: u32,
};

pub const SecPkgContext_KeyingMaterial = extern struct {
    cbKeyingMaterial: u32,
    pbKeyingMaterial: *u8,
};

pub const SecPkgContext_KeyingMaterial_Inproc = extern struct {
    cbLabel: u16,
    pszLabel: PSTR,
    cbContextValue: u16,
    pbContextValue: *u8,
    cbKeyingMaterial: u32,
    pbKeyingMaterial: *u8,
};

pub const SecPkgContext_SrtpParameters = extern struct {
    ProtectionProfile: u16,
    MasterKeyIdentifierSize: u8,
    MasterKeyIdentifier: *u8,
};

pub const SecPkgContext_TokenBinding = extern struct {
    MajorVersion: u8,
    MinorVersion: u8,
    KeyParametersSize: u16,
    KeyParameters: *u8,
};

pub const SCHANNEL_CRED = extern struct {
    dwVersion: u32,
    cCreds: u32,
    paCred: **CERT_CONTEXT,
    hRootStore: *c_void,
    cMappers: u32,
    aphMappers: **_HMAPPER,
    cSupportedAlgs: u32,
    palgSupportedAlgs: *u32,
    grbitEnabledProtocols: u32,
    dwMinimumCipherStrength: u32,
    dwMaximumCipherStrength: u32,
    dwSessionLifespan: u32,
    dwFlags: SCHANNEL_CRED_FLAGS,
    dwCredFormat: u32,
};

pub const SEND_GENERIC_TLS_EXTENSION = extern struct {
    ExtensionType: u16,
    HandshakeType: u16,
    Flags: u32,
    BufferSize: u16,
    Buffer: [1]u8,
};

pub const TLS_EXTENSION_SUBSCRIPTION = extern struct {
    ExtensionType: u16,
    HandshakeType: u16,
};

pub const SUBSCRIBE_GENERIC_TLS_EXTENSION = extern struct {
    Flags: u32,
    SubscriptionsCount: u32,
    Subscriptions: [1]TLS_EXTENSION_SUBSCRIPTION,
};

pub const SCHANNEL_CERT_HASH = extern struct {
    dwLength: u32,
    dwFlags: u32,
    hProv: usize,
    ShaHash: [20]u8,
};

pub const SCHANNEL_CERT_HASH_STORE = extern struct {
    dwLength: u32,
    dwFlags: u32,
    hProv: usize,
    ShaHash: [20]u8,
    pwszStoreName: [128]u16,
};

pub const SCHANNEL_ALERT_TOKEN = extern struct {
    dwTokenType: u32,
    dwAlertType: SCHANNEL_ALERT_TOKEN_ALERT_TYPE,
    dwAlertNumber: u32,
};

pub const SCHANNEL_SESSION_TOKEN = extern struct {
    dwTokenType: u32,
    dwFlags: SCHANNEL_SESSION_TOKEN_FLAGS,
};

pub const SCHANNEL_CLIENT_SIGNATURE = extern struct {
    cbLength: u32,
    aiHash: u32,
    cbHash: u32,
    HashValue: [36]u8,
    CertThumbprint: [20]u8,
};

pub const SSL_EMPTY_CACHE_FN_A = fn(
    pszTargetName: PSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SSL_EMPTY_CACHE_FN_W = fn(
    pszTargetName: PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SSL_CREDENTIAL_CERTIFICATE = extern struct {
    cbPrivateKey: u32,
    pPrivateKey: *u8,
    cbCertificate: u32,
    pCertificate: *u8,
    pszPassword: PSTR,
};

pub const SCH_CRED = extern struct {
    dwVersion: u32,
    cCreds: u32,
    paSecret: **c_void,
    paPublic: **c_void,
    cMappers: u32,
    aphMappers: **_HMAPPER,
};

pub const SCH_CRED_SECRET_CAPI = extern struct {
    dwType: u32,
    hProv: usize,
};

pub const SCH_CRED_SECRET_PRIVKEY = extern struct {
    dwType: u32,
    pPrivateKey: *u8,
    cbPrivateKey: u32,
    pszPassword: PSTR,
};

pub const SCH_CRED_PUBLIC_CERTCHAIN = extern struct {
    dwType: u32,
    cbCertChain: u32,
    pCertChain: *u8,
};

pub const PctPublicKey = extern struct {
    Type: u32,
    cbKey: u32,
    pKey: [1]u8,
};

pub const X509Certificate = extern struct {
    Version: u32,
    SerialNumber: [4]u32,
    SignatureAlgorithm: u32,
    ValidFrom: FILETIME,
    ValidUntil: FILETIME,
    pszIssuer: PSTR,
    pszSubject: PSTR,
    pPublicKey: *PctPublicKey,
};

pub const SSL_CRACK_CERTIFICATE_FN = fn(
    pbCertificate: *u8,
    cbCertificate: u32,
    VerifySignature: BOOL,
    ppCertificate: **X509Certificate,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SSL_FREE_CERTIFICATE_FN = fn(
    pCertificate: *X509Certificate,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SslGetServerIdentityFn = fn(
    // TODO: what to do with BytesParamIndex 1?
    ClientHello: *u8,
    ClientHelloSize: u32,
    ServerIdentity: **u8,
    ServerIdentitySize: *u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SCH_EXTENSION_DATA = extern struct {
    ExtensionType: u16,
    pExtData: *const u8,
    cbExtData: u32,
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SchGetExtensionsOptions = extern enum(u32) {
    EXTENSIONS_OPTIONS_NONE = 0,
    NO_RECORD_HEADER = 1,
    _,
};
pub const SCH_EXTENSIONS_OPTIONS_NONE = SchGetExtensionsOptions.EXTENSIONS_OPTIONS_NONE;
pub const SCH_NO_RECORD_HEADER = SchGetExtensionsOptions.NO_RECORD_HEADER;

pub const SslGetExtensionsFn = fn(
    clientHello: [*:0]const u8,
    clientHelloByteSize: u32,
    genericExtensions: [*]SCH_EXTENSION_DATA,
    genericExtensionsCount: u8,
    bytesToRead: *u32,
    flags: SchGetExtensionsOptions,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const SE_OBJECT_TYPE = extern enum(i32) {
    UNKNOWN_OBJECT_TYPE = 0,
    FILE_OBJECT = 1,
    SERVICE = 2,
    PRINTER = 3,
    REGISTRY_KEY = 4,
    LMSHARE = 5,
    KERNEL_OBJECT = 6,
    WINDOW_OBJECT = 7,
    DS_OBJECT = 8,
    DS_OBJECT_ALL = 9,
    PROVIDER_DEFINED_OBJECT = 10,
    WMIGUID_OBJECT = 11,
    REGISTRY_WOW64_32KEY = 12,
    REGISTRY_WOW64_64KEY = 13,
};
pub const SE_UNKNOWN_OBJECT_TYPE = SE_OBJECT_TYPE.UNKNOWN_OBJECT_TYPE;
pub const SE_FILE_OBJECT = SE_OBJECT_TYPE.FILE_OBJECT;
pub const SE_SERVICE = SE_OBJECT_TYPE.SERVICE;
pub const SE_PRINTER = SE_OBJECT_TYPE.PRINTER;
pub const SE_REGISTRY_KEY = SE_OBJECT_TYPE.REGISTRY_KEY;
pub const SE_LMSHARE = SE_OBJECT_TYPE.LMSHARE;
pub const SE_KERNEL_OBJECT = SE_OBJECT_TYPE.KERNEL_OBJECT;
pub const SE_WINDOW_OBJECT = SE_OBJECT_TYPE.WINDOW_OBJECT;
pub const SE_DS_OBJECT = SE_OBJECT_TYPE.DS_OBJECT;
pub const SE_DS_OBJECT_ALL = SE_OBJECT_TYPE.DS_OBJECT_ALL;
pub const SE_PROVIDER_DEFINED_OBJECT = SE_OBJECT_TYPE.PROVIDER_DEFINED_OBJECT;
pub const SE_WMIGUID_OBJECT = SE_OBJECT_TYPE.WMIGUID_OBJECT;
pub const SE_REGISTRY_WOW64_32KEY = SE_OBJECT_TYPE.REGISTRY_WOW64_32KEY;
pub const SE_REGISTRY_WOW64_64KEY = SE_OBJECT_TYPE.REGISTRY_WOW64_64KEY;

pub const TRUSTEE_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    USER = 1,
    GROUP = 2,
    DOMAIN = 3,
    ALIAS = 4,
    WELL_KNOWN_GROUP = 5,
    DELETED = 6,
    INVALID = 7,
    COMPUTER = 8,
};
pub const TRUSTEE_IS_UNKNOWN = TRUSTEE_TYPE.UNKNOWN;
pub const TRUSTEE_IS_USER = TRUSTEE_TYPE.USER;
pub const TRUSTEE_IS_GROUP = TRUSTEE_TYPE.GROUP;
pub const TRUSTEE_IS_DOMAIN = TRUSTEE_TYPE.DOMAIN;
pub const TRUSTEE_IS_ALIAS = TRUSTEE_TYPE.ALIAS;
pub const TRUSTEE_IS_WELL_KNOWN_GROUP = TRUSTEE_TYPE.WELL_KNOWN_GROUP;
pub const TRUSTEE_IS_DELETED = TRUSTEE_TYPE.DELETED;
pub const TRUSTEE_IS_INVALID = TRUSTEE_TYPE.INVALID;
pub const TRUSTEE_IS_COMPUTER = TRUSTEE_TYPE.COMPUTER;

pub const TRUSTEE_FORM = extern enum(i32) {
    IS_SID = 0,
    IS_NAME = 1,
    BAD_FORM = 2,
    IS_OBJECTS_AND_SID = 3,
    IS_OBJECTS_AND_NAME = 4,
};
pub const TRUSTEE_IS_SID = TRUSTEE_FORM.IS_SID;
pub const TRUSTEE_IS_NAME = TRUSTEE_FORM.IS_NAME;
pub const TRUSTEE_BAD_FORM = TRUSTEE_FORM.BAD_FORM;
pub const TRUSTEE_IS_OBJECTS_AND_SID = TRUSTEE_FORM.IS_OBJECTS_AND_SID;
pub const TRUSTEE_IS_OBJECTS_AND_NAME = TRUSTEE_FORM.IS_OBJECTS_AND_NAME;

pub const MULTIPLE_TRUSTEE_OPERATION = extern enum(i32) {
    NO_MULTIPLE_TRUSTEE = 0,
    TRUSTEE_IS_IMPERSONATE = 1,
};
pub const NO_MULTIPLE_TRUSTEE = MULTIPLE_TRUSTEE_OPERATION.NO_MULTIPLE_TRUSTEE;
pub const TRUSTEE_IS_IMPERSONATE = MULTIPLE_TRUSTEE_OPERATION.TRUSTEE_IS_IMPERSONATE;

pub const OBJECTS_AND_SID = extern struct {
    ObjectsPresent: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectTypeGuid: Guid,
    InheritedObjectTypeGuid: Guid,
    pSid: *SID,
};

pub const OBJECTS_AND_NAME_A = extern struct {
    ObjectsPresent: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: SE_OBJECT_TYPE,
    ObjectTypeName: PSTR,
    InheritedObjectTypeName: PSTR,
    ptstrName: PSTR,
};

pub const OBJECTS_AND_NAME_W = extern struct {
    ObjectsPresent: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: SE_OBJECT_TYPE,
    ObjectTypeName: PWSTR,
    InheritedObjectTypeName: PWSTR,
    ptstrName: PWSTR,
};

pub const TRUSTEE_A = extern struct {
    pMultipleTrustee: *TRUSTEE_A,
    MultipleTrusteeOperation: MULTIPLE_TRUSTEE_OPERATION,
    TrusteeForm: TRUSTEE_FORM,
    TrusteeType: TRUSTEE_TYPE,
    ptstrName: [*]u8,
};

pub const TRUSTEE_W = extern struct {
    pMultipleTrustee: *TRUSTEE_W,
    MultipleTrusteeOperation: MULTIPLE_TRUSTEE_OPERATION,
    TrusteeForm: TRUSTEE_FORM,
    TrusteeType: TRUSTEE_TYPE,
    ptstrName: [*]u16,
};

pub const ACCESS_MODE = extern enum(i32) {
    NOT_USED_ACCESS = 0,
    GRANT_ACCESS = 1,
    SET_ACCESS = 2,
    DENY_ACCESS = 3,
    REVOKE_ACCESS = 4,
    SET_AUDIT_SUCCESS = 5,
    SET_AUDIT_FAILURE = 6,
};
pub const NOT_USED_ACCESS = ACCESS_MODE.NOT_USED_ACCESS;
pub const GRANT_ACCESS = ACCESS_MODE.GRANT_ACCESS;
pub const SET_ACCESS = ACCESS_MODE.SET_ACCESS;
pub const DENY_ACCESS = ACCESS_MODE.DENY_ACCESS;
pub const REVOKE_ACCESS = ACCESS_MODE.REVOKE_ACCESS;
pub const SET_AUDIT_SUCCESS = ACCESS_MODE.SET_AUDIT_SUCCESS;
pub const SET_AUDIT_FAILURE = ACCESS_MODE.SET_AUDIT_FAILURE;

pub const EXPLICIT_ACCESS_A = extern struct {
    grfAccessPermissions: u32,
    grfAccessMode: ACCESS_MODE,
    grfInheritance: ACE_FLAGS,
    Trustee: TRUSTEE_A,
};

pub const EXPLICIT_ACCESS_W = extern struct {
    grfAccessPermissions: u32,
    grfAccessMode: ACCESS_MODE,
    grfInheritance: ACE_FLAGS,
    Trustee: TRUSTEE_W,
};

pub const TRUSTEE_ACCESSA = extern struct {
    lpProperty: PSTR,
    Access: u32,
    fAccessFlags: u32,
    fReturnedAccess: u32,
};

pub const TRUSTEE_ACCESSW = extern struct {
    lpProperty: PWSTR,
    Access: u32,
    fAccessFlags: u32,
    fReturnedAccess: u32,
};

pub const ACTRL_OVERLAPPED = extern struct {
    Anonymous: _Anonymous_e__Union,
    Reserved2: u32,
    hEvent: HANDLE,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ACTRL_ACCESS_INFOA = extern struct {
    fAccessPermission: u32,
    lpAccessPermissionName: PSTR,
};

pub const ACTRL_ACCESS_INFOW = extern struct {
    fAccessPermission: u32,
    lpAccessPermissionName: PWSTR,
};

pub const ACTRL_CONTROL_INFOA = extern struct {
    lpControlId: PSTR,
    lpControlName: PSTR,
};

pub const ACTRL_CONTROL_INFOW = extern struct {
    lpControlId: PWSTR,
    lpControlName: PWSTR,
};

pub const PROG_INVOKE_SETTING = extern enum(i32) {
    InvokeNever = 1,
    InvokeEveryObject = 2,
    InvokeOnError = 3,
    CancelOperation = 4,
    RetryOperation = 5,
    InvokePrePostError = 6,
};
pub const ProgressInvokeNever = PROG_INVOKE_SETTING.InvokeNever;
pub const ProgressInvokeEveryObject = PROG_INVOKE_SETTING.InvokeEveryObject;
pub const ProgressInvokeOnError = PROG_INVOKE_SETTING.InvokeOnError;
pub const ProgressCancelOperation = PROG_INVOKE_SETTING.CancelOperation;
pub const ProgressRetryOperation = PROG_INVOKE_SETTING.RetryOperation;
pub const ProgressInvokePrePostError = PROG_INVOKE_SETTING.InvokePrePostError;

pub const FN_OBJECT_MGR_FUNCTIONS = extern struct {
    Placeholder: u32,
};

pub const INHERITED_FROMA = extern struct {
    GenerationGap: i32,
    AncestorName: PSTR,
};

pub const INHERITED_FROMW = extern struct {
    GenerationGap: i32,
    AncestorName: PWSTR,
};

pub const WLX_SC_NOTIFICATION_INFO = extern struct {
    pszCard: PWSTR,
    pszReader: PWSTR,
    pszContainer: PWSTR,
    pszCryptoProvider: PWSTR,
};

pub const WLX_PROFILE_V1_0 = extern struct {
    dwType: u32,
    pszProfile: PWSTR,
};

pub const WLX_PROFILE_V2_0 = extern struct {
    dwType: u32,
    pszProfile: PWSTR,
    pszPolicy: PWSTR,
    pszNetworkDefaultUserProfile: PWSTR,
    pszServerName: PWSTR,
    pszEnvironment: PWSTR,
};

pub const WLX_MPR_NOTIFY_INFO = extern struct {
    pszUserName: PWSTR,
    pszDomain: PWSTR,
    pszPassword: PWSTR,
    pszOldPassword: PWSTR,
};

pub const WLX_TERMINAL_SERVICES_DATA = extern struct {
    ProfilePath: [257]u16,
    HomeDir: [257]u16,
    HomeDirDrive: [4]u16,
};

pub const WLX_CLIENT_CREDENTIALS_INFO_V1_0 = extern struct {
    dwType: u32,
    pszUserName: PWSTR,
    pszDomain: PWSTR,
    pszPassword: PWSTR,
    fPromptForPassword: BOOL,
};

pub const WLX_CLIENT_CREDENTIALS_INFO_V2_0 = extern struct {
    dwType: u32,
    pszUserName: PWSTR,
    pszDomain: PWSTR,
    pszPassword: PWSTR,
    fPromptForPassword: BOOL,
    fDisconnectOnLogonFailure: BOOL,
};

pub const WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 = extern struct {
    dwType: u32,
    UserToken: HANDLE,
    LogonId: LUID,
    Quotas: QUOTA_LIMITS,
    UserName: PWSTR,
    Domain: PWSTR,
    LogonTime: LARGE_INTEGER,
    SmartCardLogon: BOOL,
    ProfileLength: u32,
    MessageType: u32,
    LogonCount: u16,
    BadPasswordCount: u16,
    ProfileLogonTime: LARGE_INTEGER,
    LogoffTime: LARGE_INTEGER,
    KickOffTime: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
    LogonScript: PWSTR,
    HomeDirectory: PWSTR,
    FullName: PWSTR,
    ProfilePath: PWSTR,
    HomeDirectoryDrive: PWSTR,
    LogonServer: PWSTR,
    UserFlags: u32,
    PrivateDataLen: u32,
    PrivateData: *u8,
};

pub const WLX_DESKTOP = extern struct {
    Size: u32,
    Flags: u32,
    hDesktop: HDESK,
    pszDesktopName: PWSTR,
};

pub const PWLX_USE_CTRL_ALT_DEL = fn(
    hWlx: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SET_CONTEXT_POINTER = fn(
    hWlx: HANDLE,
    pWlxContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SAS_NOTIFY = fn(
    hWlx: HANDLE,
    dwSasType: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SET_TIMEOUT = fn(
    hWlx: HANDLE,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_ASSIGN_SHELL_PROTECTION = fn(
    hWlx: HANDLE,
    hToken: HANDLE,
    hProcess: HANDLE,
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_MESSAGE_BOX = fn(
    hWlx: HANDLE,
    hwndOwner: HWND,
    lpszText: PWSTR,
    lpszTitle: PWSTR,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX = fn(
    hWlx: HANDLE,
    hInst: HANDLE,
    lpszTemplate: PWSTR,
    hwndOwner: HWND,
    dlgprc: DLGPROC,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_INDIRECT = fn(
    hWlx: HANDLE,
    hInst: HANDLE,
    hDialogTemplate: *DLGTEMPLATE,
    hwndOwner: HWND,
    dlgprc: DLGPROC,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_PARAM = fn(
    hWlx: HANDLE,
    hInst: HANDLE,
    lpszTemplate: PWSTR,
    hwndOwner: HWND,
    dlgprc: DLGPROC,
    dwInitParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_INDIRECT_PARAM = fn(
    hWlx: HANDLE,
    hInst: HANDLE,
    hDialogTemplate: *DLGTEMPLATE,
    hwndOwner: HWND,
    dlgprc: DLGPROC,
    dwInitParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_SWITCH_DESKTOP_TO_USER = fn(
    hWlx: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_SWITCH_DESKTOP_TO_WINLOGON = fn(
    hWlx: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_CHANGE_PASSWORD_NOTIFY = fn(
    hWlx: HANDLE,
    pMprInfo: *WLX_MPR_NOTIFY_INFO,
    dwChangeInfo: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_GET_SOURCE_DESKTOP = fn(
    hWlx: HANDLE,
    ppDesktop: **WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_SET_RETURN_DESKTOP = fn(
    hWlx: HANDLE,
    pDesktop: *WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_CREATE_USER_DESKTOP = fn(
    hWlx: HANDLE,
    hToken: HANDLE,
    Flags: u32,
    pszDesktopName: PWSTR,
    ppDesktop: **WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_CHANGE_PASSWORD_NOTIFY_EX = fn(
    hWlx: HANDLE,
    pMprInfo: *WLX_MPR_NOTIFY_INFO,
    dwChangeInfo: u32,
    ProviderName: PWSTR,
    Reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_CLOSE_USER_DESKTOP = fn(
    hWlx: HANDLE,
    pDesktop: *WLX_DESKTOP,
    hToken: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_SET_OPTION = fn(
    hWlx: HANDLE,
    Option: u32,
    Value: usize,
    OldValue: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_GET_OPTION = fn(
    hWlx: HANDLE,
    Option: u32,
    Value: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_WIN31_MIGRATE = fn(
    hWlx: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_QUERY_CLIENT_CREDENTIALS = fn(
    pCred: *WLX_CLIENT_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_IC_CREDENTIALS = fn(
    pCred: *WLX_CLIENT_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_TS_LOGON_CREDENTIALS = fn(
    pCred: *WLX_CLIENT_CREDENTIALS_INFO_V2_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_DISCONNECT = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_TERMINAL_SERVICES_DATA = fn(
    hWlx: HANDLE,
    pTSData: *WLX_TERMINAL_SERVICES_DATA,
    UserName: PWSTR,
    Domain: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWLX_QUERY_CONSOLESWITCH_CREDENTIALS = fn(
    pCred: *WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WLX_DISPATCH_VERSION_1_0 = extern struct {
    WlxUseCtrlAltDel: PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: PWLX_SAS_NOTIFY,
    WlxSetTimeout: PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: PWLX_MESSAGE_BOX,
    WlxDialogBox: PWLX_DIALOG_BOX,
    WlxDialogBoxParam: PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: PWLX_CHANGE_PASSWORD_NOTIFY,
};

pub const WLX_DISPATCH_VERSION_1_1 = extern struct {
    WlxUseCtrlAltDel: PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: PWLX_SAS_NOTIFY,
    WlxSetTimeout: PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: PWLX_MESSAGE_BOX,
    WlxDialogBox: PWLX_DIALOG_BOX,
    WlxDialogBoxParam: PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: PWLX_CHANGE_PASSWORD_NOTIFY_EX,
};

pub const WLX_DISPATCH_VERSION_1_2 = extern struct {
    WlxUseCtrlAltDel: PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: PWLX_SAS_NOTIFY,
    WlxSetTimeout: PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: PWLX_MESSAGE_BOX,
    WlxDialogBox: PWLX_DIALOG_BOX,
    WlxDialogBoxParam: PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: PWLX_CLOSE_USER_DESKTOP,
};

pub const WLX_DISPATCH_VERSION_1_3 = extern struct {
    WlxUseCtrlAltDel: PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: PWLX_SAS_NOTIFY,
    WlxSetTimeout: PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: PWLX_MESSAGE_BOX,
    WlxDialogBox: PWLX_DIALOG_BOX,
    WlxDialogBoxParam: PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: PWLX_CLOSE_USER_DESKTOP,
    WlxSetOption: PWLX_SET_OPTION,
    WlxGetOption: PWLX_GET_OPTION,
    WlxWin31Migrate: PWLX_WIN31_MIGRATE,
    WlxQueryClientCredentials: PWLX_QUERY_CLIENT_CREDENTIALS,
    WlxQueryInetConnectorCredentials: PWLX_QUERY_IC_CREDENTIALS,
    WlxDisconnect: PWLX_DISCONNECT,
    WlxQueryTerminalServicesData: PWLX_QUERY_TERMINAL_SERVICES_DATA,
};

pub const WLX_DISPATCH_VERSION_1_4 = extern struct {
    WlxUseCtrlAltDel: PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: PWLX_SAS_NOTIFY,
    WlxSetTimeout: PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: PWLX_MESSAGE_BOX,
    WlxDialogBox: PWLX_DIALOG_BOX,
    WlxDialogBoxParam: PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: PWLX_CLOSE_USER_DESKTOP,
    WlxSetOption: PWLX_SET_OPTION,
    WlxGetOption: PWLX_GET_OPTION,
    WlxWin31Migrate: PWLX_WIN31_MIGRATE,
    WlxQueryClientCredentials: PWLX_QUERY_CLIENT_CREDENTIALS,
    WlxQueryInetConnectorCredentials: PWLX_QUERY_IC_CREDENTIALS,
    WlxDisconnect: PWLX_DISCONNECT,
    WlxQueryTerminalServicesData: PWLX_QUERY_TERMINAL_SERVICES_DATA,
    WlxQueryConsoleSwitchCredentials: PWLX_QUERY_CONSOLESWITCH_CREDENTIALS,
    WlxQueryTsLogonCredentials: PWLX_QUERY_TS_LOGON_CREDENTIALS,
};

pub const PFNMSGECALLBACK = fn(
    bVerbose: BOOL,
    lpMessage: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WLX_NOTIFICATION_INFO = extern struct {
    Size: u32,
    Flags: u32,
    UserName: PWSTR,
    Domain: PWSTR,
    WindowStation: PWSTR,
    hToken: HANDLE,
    hDesktop: HDESK,
    pStatusCallback: PFNMSGECALLBACK,
};

const CLSID_TpmVirtualSmartCardManager_Value = @import("../zig.zig").Guid.initString("16a18e86-7f6e-4c20-ad89-4ffc0db7a96a");
pub const CLSID_TpmVirtualSmartCardManager = &CLSID_TpmVirtualSmartCardManager_Value;

const CLSID_RemoteTpmVirtualSmartCardManager_Value = @import("../zig.zig").Guid.initString("152ea2a8-70dc-4c59-8b2a-32aa3ca0dcac");
pub const CLSID_RemoteTpmVirtualSmartCardManager = &CLSID_RemoteTpmVirtualSmartCardManager_Value;

pub const TPMVSC_ATTESTATION_TYPE = extern enum(i32) {
    NONE = 0,
    AIK_ONLY = 1,
    AIK_AND_CERTIFICATE = 2,
};
pub const TPMVSC_ATTESTATION_NONE = TPMVSC_ATTESTATION_TYPE.NONE;
pub const TPMVSC_ATTESTATION_AIK_ONLY = TPMVSC_ATTESTATION_TYPE.AIK_ONLY;
pub const TPMVSC_ATTESTATION_AIK_AND_CERTIFICATE = TPMVSC_ATTESTATION_TYPE.AIK_AND_CERTIFICATE;

pub const TPMVSCMGR_STATUS = extern enum(i32) {
    VTPMSMARTCARD_INITIALIZING = 0,
    VTPMSMARTCARD_CREATING = 1,
    VTPMSMARTCARD_DESTROYING = 2,
    VGIDSSIMULATOR_INITIALIZING = 3,
    VGIDSSIMULATOR_CREATING = 4,
    VGIDSSIMULATOR_DESTROYING = 5,
    VREADER_INITIALIZING = 6,
    VREADER_CREATING = 7,
    VREADER_DESTROYING = 8,
    GENERATE_WAITING = 9,
    GENERATE_AUTHENTICATING = 10,
    GENERATE_RUNNING = 11,
    CARD_CREATED = 12,
    CARD_DESTROYED = 13,
};
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_INITIALIZING = TPMVSCMGR_STATUS.VTPMSMARTCARD_INITIALIZING;
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_CREATING = TPMVSCMGR_STATUS.VTPMSMARTCARD_CREATING;
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_DESTROYING = TPMVSCMGR_STATUS.VTPMSMARTCARD_DESTROYING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_INITIALIZING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_INITIALIZING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_CREATING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_CREATING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_DESTROYING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_DESTROYING;
pub const TPMVSCMGR_STATUS_VREADER_INITIALIZING = TPMVSCMGR_STATUS.VREADER_INITIALIZING;
pub const TPMVSCMGR_STATUS_VREADER_CREATING = TPMVSCMGR_STATUS.VREADER_CREATING;
pub const TPMVSCMGR_STATUS_VREADER_DESTROYING = TPMVSCMGR_STATUS.VREADER_DESTROYING;
pub const TPMVSCMGR_STATUS_GENERATE_WAITING = TPMVSCMGR_STATUS.GENERATE_WAITING;
pub const TPMVSCMGR_STATUS_GENERATE_AUTHENTICATING = TPMVSCMGR_STATUS.GENERATE_AUTHENTICATING;
pub const TPMVSCMGR_STATUS_GENERATE_RUNNING = TPMVSCMGR_STATUS.GENERATE_RUNNING;
pub const TPMVSCMGR_STATUS_CARD_CREATED = TPMVSCMGR_STATUS.CARD_CREATED;
pub const TPMVSCMGR_STATUS_CARD_DESTROYED = TPMVSCMGR_STATUS.CARD_DESTROYED;

pub const TPMVSCMGR_ERROR = extern enum(i32) {
    IMPERSONATION = 0,
    PIN_COMPLEXITY = 1,
    READER_COUNT_LIMIT = 2,
    TERMINAL_SERVICES_SESSION = 3,
    VTPMSMARTCARD_INITIALIZE = 4,
    VTPMSMARTCARD_CREATE = 5,
    VTPMSMARTCARD_DESTROY = 6,
    VGIDSSIMULATOR_INITIALIZE = 7,
    VGIDSSIMULATOR_CREATE = 8,
    VGIDSSIMULATOR_DESTROY = 9,
    VGIDSSIMULATOR_WRITE_PROPERTY = 10,
    VGIDSSIMULATOR_READ_PROPERTY = 11,
    VREADER_INITIALIZE = 12,
    VREADER_CREATE = 13,
    VREADER_DESTROY = 14,
    GENERATE_LOCATE_READER = 15,
    GENERATE_FILESYSTEM = 16,
    CARD_CREATE = 17,
    CARD_DESTROY = 18,
};
pub const TPMVSCMGR_ERROR_IMPERSONATION = TPMVSCMGR_ERROR.IMPERSONATION;
pub const TPMVSCMGR_ERROR_PIN_COMPLEXITY = TPMVSCMGR_ERROR.PIN_COMPLEXITY;
pub const TPMVSCMGR_ERROR_READER_COUNT_LIMIT = TPMVSCMGR_ERROR.READER_COUNT_LIMIT;
pub const TPMVSCMGR_ERROR_TERMINAL_SERVICES_SESSION = TPMVSCMGR_ERROR.TERMINAL_SERVICES_SESSION;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_INITIALIZE = TPMVSCMGR_ERROR.VTPMSMARTCARD_INITIALIZE;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_CREATE = TPMVSCMGR_ERROR.VTPMSMARTCARD_CREATE;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_DESTROY = TPMVSCMGR_ERROR.VTPMSMARTCARD_DESTROY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_INITIALIZE = TPMVSCMGR_ERROR.VGIDSSIMULATOR_INITIALIZE;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_CREATE = TPMVSCMGR_ERROR.VGIDSSIMULATOR_CREATE;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_DESTROY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_DESTROY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_WRITE_PROPERTY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_WRITE_PROPERTY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_READ_PROPERTY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_READ_PROPERTY;
pub const TPMVSCMGR_ERROR_VREADER_INITIALIZE = TPMVSCMGR_ERROR.VREADER_INITIALIZE;
pub const TPMVSCMGR_ERROR_VREADER_CREATE = TPMVSCMGR_ERROR.VREADER_CREATE;
pub const TPMVSCMGR_ERROR_VREADER_DESTROY = TPMVSCMGR_ERROR.VREADER_DESTROY;
pub const TPMVSCMGR_ERROR_GENERATE_LOCATE_READER = TPMVSCMGR_ERROR.GENERATE_LOCATE_READER;
pub const TPMVSCMGR_ERROR_GENERATE_FILESYSTEM = TPMVSCMGR_ERROR.GENERATE_FILESYSTEM;
pub const TPMVSCMGR_ERROR_CARD_CREATE = TPMVSCMGR_ERROR.CARD_CREATE;
pub const TPMVSCMGR_ERROR_CARD_DESTROY = TPMVSCMGR_ERROR.CARD_DESTROY;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITpmVirtualSmartCardManagerStatusCallback_Value = @import("../zig.zig").Guid.initString("1a1bb35f-abb8-451c-a1ae-33d98f1bef4a");
pub const IID_ITpmVirtualSmartCardManagerStatusCallback = &IID_ITpmVirtualSmartCardManagerStatusCallback_Value;
pub const ITpmVirtualSmartCardManagerStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportProgress: fn(
            self: *const ITpmVirtualSmartCardManagerStatusCallback,
            Status: TPMVSCMGR_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportError: fn(
            self: *const ITpmVirtualSmartCardManagerStatusCallback,
            Error: TPMVSCMGR_ERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManagerStatusCallback_ReportProgress(self: *const T, Status: TPMVSCMGR_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback.VTable, self.vtable).ReportProgress(@ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManagerStatusCallback_ReportError(self: *const T, Error: TPMVSCMGR_ERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback.VTable, self.vtable).ReportError(@ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback, self), Error);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITpmVirtualSmartCardManager_Value = @import("../zig.zig").Guid.initString("112b1dff-d9dc-41f7-869f-d67fee7cb591");
pub const IID_ITpmVirtualSmartCardManager = &IID_ITpmVirtualSmartCardManager_Value;
pub const ITpmVirtualSmartCardManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateVirtualSmartCard: fn(
            self: *const ITpmVirtualSmartCardManager,
            pszFriendlyName: [*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            fGenerate: BOOL,
            pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: *PWSTR,
            pfNeedReboot: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyVirtualSmartCard: fn(
            self: *const ITpmVirtualSmartCardManager,
            pszInstanceId: [*:0]const u16,
            pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback,
            pfNeedReboot: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager_CreateVirtualSmartCard(self: *const T, pszFriendlyName: [*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, fGenerate: BOOL, pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: *PWSTR, pfNeedReboot: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager.VTable, self.vtable).CreateVirtualSmartCard(@ptrCast(*const ITpmVirtualSmartCardManager, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, fGenerate, pStatusCallback, ppszInstanceId, pfNeedReboot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager_DestroyVirtualSmartCard(self: *const T, pszInstanceId: [*:0]const u16, pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback, pfNeedReboot: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager.VTable, self.vtable).DestroyVirtualSmartCard(@ptrCast(*const ITpmVirtualSmartCardManager, self), pszInstanceId, pStatusCallback, pfNeedReboot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITpmVirtualSmartCardManager2_Value = @import("../zig.zig").Guid.initString("fdf8a2b9-02de-47f4-bc26-aa85ab5e5267");
pub const IID_ITpmVirtualSmartCardManager2 = &IID_ITpmVirtualSmartCardManager2_Value;
pub const ITpmVirtualSmartCardManager2 = extern struct {
    pub const VTable = extern struct {
        base: ITpmVirtualSmartCardManager.VTable,
        CreateVirtualSmartCardWithPinPolicy: fn(
            self: *const ITpmVirtualSmartCardManager2,
            pszFriendlyName: [*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            pbPinPolicy: [*:0]const u8,
            cbPinPolicy: u32,
            fGenerate: BOOL,
            pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: *PWSTR,
            pfNeedReboot: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITpmVirtualSmartCardManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager2_CreateVirtualSmartCardWithPinPolicy(self: *const T, pszFriendlyName: [*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, pbPinPolicy: [*:0]const u8, cbPinPolicy: u32, fGenerate: BOOL, pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: *PWSTR, pfNeedReboot: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager2.VTable, self.vtable).CreateVirtualSmartCardWithPinPolicy(@ptrCast(*const ITpmVirtualSmartCardManager2, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, pbPinPolicy, cbPinPolicy, fGenerate, pStatusCallback, ppszInstanceId, pfNeedReboot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITpmVirtualSmartCardManager3_Value = @import("../zig.zig").Guid.initString("3c745a97-f375-4150-be17-5950f694c699");
pub const IID_ITpmVirtualSmartCardManager3 = &IID_ITpmVirtualSmartCardManager3_Value;
pub const ITpmVirtualSmartCardManager3 = extern struct {
    pub const VTable = extern struct {
        base: ITpmVirtualSmartCardManager2.VTable,
        CreateVirtualSmartCardWithAttestation: fn(
            self: *const ITpmVirtualSmartCardManager3,
            pszFriendlyName: [*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            pbPinPolicy: [*:0]const u8,
            cbPinPolicy: u32,
            attestationType: TPMVSC_ATTESTATION_TYPE,
            fGenerate: BOOL,
            pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITpmVirtualSmartCardManager2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager3_CreateVirtualSmartCardWithAttestation(self: *const T, pszFriendlyName: [*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, pbPinPolicy: [*:0]const u8, cbPinPolicy: u32, attestationType: TPMVSC_ATTESTATION_TYPE, fGenerate: BOOL, pStatusCallback: *ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager3.VTable, self.vtable).CreateVirtualSmartCardWithAttestation(@ptrCast(*const ITpmVirtualSmartCardManager3, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, pbPinPolicy, cbPinPolicy, attestationType, fGenerate, pStatusCallback, ppszInstanceId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const KeyCredentialManagerOperationErrorStates = extern enum(u32) {
    None = 0,
    DeviceJoinFailure = 1,
    TokenFailure = 2,
    CertificateFailure = 4,
    RemoteSessionFailure = 8,
    PolicyFailure = 16,
    HardwareFailure = 32,
    PinExistsFailure = 64,
    _,
};
pub const KeyCredentialManagerOperationErrorStateNone = KeyCredentialManagerOperationErrorStates.None;
pub const KeyCredentialManagerOperationErrorStateDeviceJoinFailure = KeyCredentialManagerOperationErrorStates.DeviceJoinFailure;
pub const KeyCredentialManagerOperationErrorStateTokenFailure = KeyCredentialManagerOperationErrorStates.TokenFailure;
pub const KeyCredentialManagerOperationErrorStateCertificateFailure = KeyCredentialManagerOperationErrorStates.CertificateFailure;
pub const KeyCredentialManagerOperationErrorStateRemoteSessionFailure = KeyCredentialManagerOperationErrorStates.RemoteSessionFailure;
pub const KeyCredentialManagerOperationErrorStatePolicyFailure = KeyCredentialManagerOperationErrorStates.PolicyFailure;
pub const KeyCredentialManagerOperationErrorStateHardwareFailure = KeyCredentialManagerOperationErrorStates.HardwareFailure;
pub const KeyCredentialManagerOperationErrorStatePinExistsFailure = KeyCredentialManagerOperationErrorStates.PinExistsFailure;

pub const KeyCredentialManagerOperationType = extern enum(i32) {
    rovisioning = 0,
    inChange = 1,
    inReset = 2,
};
pub const KeyCredentialManagerProvisioning = KeyCredentialManagerOperationType.rovisioning;
pub const KeyCredentialManagerPinChange = KeyCredentialManagerOperationType.inChange;
pub const KeyCredentialManagerPinReset = KeyCredentialManagerOperationType.inReset;

pub const KeyCredentialManagerInfo = extern struct {
    containerId: Guid,
};

pub const IDENTITY_TYPE = extern enum(i32) {
    ALL = 0,
    ME_ONLY = 1,
};
pub const IDENTITIES_ALL = IDENTITY_TYPE.ALL;
pub const IDENTITIES_ME_ONLY = IDENTITY_TYPE.ME_ONLY;

pub const PF_NPAddConnection = fn(
    lpNetResource: *NETRESOURCEW,
    lpPassword: ?PWSTR,
    lpUserName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPAddConnection3 = fn(
    hwndOwner: HWND,
    lpNetResource: *NETRESOURCEW,
    lpPassword: ?PWSTR,
    lpUserName: ?PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPAddConnection4 = fn(
    hwndOwner: HWND,
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 3?
    lpAuthBuffer: ?*c_void,
    cbAuthBuffer: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpUseOptions: ?*u8,
    cbUseOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPCancelConnection = fn(
    lpName: PWSTR,
    fForce: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetConnection = fn(
    lpLocalName: PWSTR,
    lpRemoteName: ?[*:0]u16,
    lpnBufferLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetConnection3 = fn(
    lpLocalName: [*:0]const u16,
    dwLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetUniversalName = fn(
    lpLocalPath: [*:0]const u16,
    dwInfoLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    lpnBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetConnectionPerformance = fn(
    lpRemoteName: [*:0]const u16,
    lpNetConnectInfo: *NETCONNECTINFOSTRUCT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPOpenEnum = fn(
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    lpNetResource: ?*NETRESOURCEW,
    lphEnum: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPEnumResource = fn(
    hEnum: HANDLE,
    lpcCount: *u32,
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPCloseEnum = fn(
    hEnum: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetCaps = fn(
    ndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetUser = fn(
    lpName: PWSTR,
    lpUserName: [*:0]u16,
    lpnBufferLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetPersistentUseOptionsForConnection = fn(
    lpRemotePath: PWSTR,
    // TODO: what to do with BytesParamIndex 2?
    lpReadUseOptions: *u8,
    cbReadUseOptions: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpWriteUseOptions: *u8,
    lpSizeWriteUseOptions: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPDeviceMode = fn(
    hParent: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPSearchDialog = fn(
    hwndParent: HWND,
    lpNetResource: ?*NETRESOURCEW,
    lpBuffer: [*]u8,
    cbBuffer: u32,
    lpnFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetResourceParent = fn(
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetResourceInformation = fn(
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
    lplpSystem: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPFormatNetworkName = fn(
    lpRemoteName: PWSTR,
    lpFormattedName: [*:0]u16,
    lpnLength: *u32,
    dwFlags: u32,
    dwAveCharPerLine: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetPropertyText = fn(
    iButton: u32,
    nPropSel: u32,
    lpName: PWSTR,
    lpButtonName: [*:0]u16,
    nButtonNameLen: u32,
    nType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPPropertyDialog = fn(
    hwndParent: HWND,
    iButtonDlg: u32,
    nPropSel: u32,
    lpFileName: PWSTR,
    nType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPGetDirectoryType = fn(
    lpName: PWSTR,
    lpType: *i32,
    bFlushCache: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPDirectoryNotify = fn(
    hwnd: HWND,
    lpDir: PWSTR,
    dwOper: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPLogonNotify = fn(
    lpLogonId: *LUID,
    lpAuthentInfoType: [*:0]const u16,
    lpAuthentInfo: *c_void,
    lpPreviousAuthentInfoType: ?[*:0]const u16,
    lpPreviousAuthentInfo: ?*c_void,
    lpStationName: PWSTR,
    StationHandle: ?*c_void,
    lpLogonScript: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPPasswordChangeNotify = fn(
    lpAuthentInfoType: [*:0]const u16,
    lpAuthentInfo: *c_void,
    lpPreviousAuthentInfoType: [*:0]const u16,
    lpPreviousAuthentInfo: *c_void,
    lpStationName: PWSTR,
    StationHandle: ?*c_void,
    dwChangeInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const NOTIFYINFO = extern struct {
    dwNotifyStatus: u32,
    dwOperationStatus: u32,
    lpContext: *c_void,
};

pub const NOTIFYADD = extern struct {
    hwndOwner: HWND,
    NetResource: NETRESOURCEA,
    dwAddFlags: NET_USE_CONNECT_FLAGS,
};

pub const NOTIFYCANCEL = extern struct {
    lpName: PWSTR,
    lpProvider: PWSTR,
    dwFlags: u32,
    fForce: BOOL,
};

pub const PF_AddConnectNotify = fn(
    lpNotifyInfo: *NOTIFYINFO,
    lpAddInfo: *NOTIFYADD,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_CancelConnectNotify = fn(
    lpNotifyInfo: *NOTIFYINFO,
    lpCancelInfo: *NOTIFYCANCEL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPFMXGetPermCaps = fn(
    lpDriveName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPFMXEditPerm = fn(
    lpDriveName: PWSTR,
    hwndFMX: HWND,
    nDialogType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_NPFMXGetPermHelp = fn(
    lpDriveName: PWSTR,
    nDialogType: u32,
    fDirectory: BOOL,
    lpFileNameBuffer: [*]u8,
    lpBufferSize: *u32,
    lpnHelpContext: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const SCARD_READERSTATEA = extern struct {
    szReader: [*:0]const u8,
    pvUserData: *c_void,
    dwCurrentState: SCARD_STATE,
    dwEventState: SCARD_STATE,
    cbAtr: u32,
    rgbAtr: [36]u8,
};

pub const SCARD_READERSTATEW = extern struct {
    szReader: [*:0]const u16,
    pvUserData: *c_void,
    dwCurrentState: SCARD_STATE,
    dwEventState: SCARD_STATE,
    cbAtr: u32,
    rgbAtr: [36]u8,
};

pub const SCARD_ATRMASK = extern struct {
    cbAtr: u32,
    rgbAtr: [36]u8,
    rgbMask: [36]u8,
};

pub const LPOCNCONNPROCA = fn(
    param0: usize,
    param1: PSTR,
    param2: PSTR,
    param3: *c_void,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPOCNCONNPROCW = fn(
    param0: usize,
    param1: PWSTR,
    param2: PWSTR,
    param3: *c_void,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPOCNCHKPROC = fn(
    param0: usize,
    param1: usize,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPOCNDSCPROC = fn(
    param0: usize,
    param1: usize,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const OPENCARD_SEARCH_CRITERIAA = extern struct {
    dwStructSize: u32,
    lpstrGroupNames: PSTR,
    nMaxGroupNames: u32,
    rgguidInterfaces: *Guid,
    cguidInterfaces: u32,
    lpstrCardNames: PSTR,
    nMaxCardNames: u32,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
};

pub const OPENCARD_SEARCH_CRITERIAW = extern struct {
    dwStructSize: u32,
    lpstrGroupNames: PWSTR,
    nMaxGroupNames: u32,
    rgguidInterfaces: *Guid,
    cguidInterfaces: u32,
    lpstrCardNames: PWSTR,
    nMaxCardNames: u32,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
};

pub const OPENCARDNAME_EXA = extern struct {
    dwStructSize: u32,
    hSCardContext: usize,
    hwndOwner: HWND,
    dwFlags: u32,
    lpstrTitle: [*:0]const u8,
    lpstrSearchDesc: [*:0]const u8,
    hIcon: HICON,
    pOpenCardSearchCriteria: *OPENCARD_SEARCH_CRITERIAA,
    lpfnConnect: LPOCNCONNPROCA,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    lpstrRdr: PSTR,
    nMaxRdr: u32,
    lpstrCard: PSTR,
    nMaxCard: u32,
    dwActiveProtocol: u32,
    hCardHandle: usize,
};

pub const OPENCARDNAME_EXW = extern struct {
    dwStructSize: u32,
    hSCardContext: usize,
    hwndOwner: HWND,
    dwFlags: u32,
    lpstrTitle: [*:0]const u16,
    lpstrSearchDesc: [*:0]const u16,
    hIcon: HICON,
    pOpenCardSearchCriteria: *OPENCARD_SEARCH_CRITERIAW,
    lpfnConnect: LPOCNCONNPROCW,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    lpstrRdr: PWSTR,
    nMaxRdr: u32,
    lpstrCard: PWSTR,
    nMaxCard: u32,
    dwActiveProtocol: u32,
    hCardHandle: usize,
};

pub const READER_SEL_REQUEST_MATCH_TYPE = extern enum(i32) {
    READER_AND_CONTAINER = 1,
    SERIAL_NUMBER = 2,
    ALL_CARDS = 3,
};
pub const RSR_MATCH_TYPE_READER_AND_CONTAINER = READER_SEL_REQUEST_MATCH_TYPE.READER_AND_CONTAINER;
pub const RSR_MATCH_TYPE_SERIAL_NUMBER = READER_SEL_REQUEST_MATCH_TYPE.SERIAL_NUMBER;
pub const RSR_MATCH_TYPE_ALL_CARDS = READER_SEL_REQUEST_MATCH_TYPE.ALL_CARDS;

pub const READER_SEL_REQUEST = extern struct {
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    MatchType: READER_SEL_REQUEST_MATCH_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const READER_SEL_RESPONSE = extern struct {
    cbReaderNameOffset: u32,
    cchReaderNameLength: u32,
    cbCardNameOffset: u32,
    cchCardNameLength: u32,
};

pub const OPENCARDNAMEA = extern struct {
    dwStructSize: u32,
    hwndOwner: HWND,
    hSCardContext: usize,
    lpstrGroupNames: PSTR,
    nMaxGroupNames: u32,
    lpstrCardNames: PSTR,
    nMaxCardNames: u32,
    rgguidInterfaces: *Guid,
    cguidInterfaces: u32,
    lpstrRdr: PSTR,
    nMaxRdr: u32,
    lpstrCard: PSTR,
    nMaxCard: u32,
    lpstrTitle: [*:0]const u8,
    dwFlags: u32,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    dwActiveProtocol: u32,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: usize,
};

pub const OPENCARDNAMEW = extern struct {
    dwStructSize: u32,
    hwndOwner: HWND,
    hSCardContext: usize,
    lpstrGroupNames: PWSTR,
    nMaxGroupNames: u32,
    lpstrCardNames: PWSTR,
    nMaxCardNames: u32,
    rgguidInterfaces: *Guid,
    cguidInterfaces: u32,
    lpstrRdr: PWSTR,
    nMaxRdr: u32,
    lpstrCard: PWSTR,
    nMaxCard: u32,
    lpstrTitle: [*:0]const u16,
    dwFlags: u32,
    pvUserData: *c_void,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    dwActiveProtocol: u32,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: usize,
};

pub const LOGON_HOURS = extern struct {
    UnitsPerWeek: u16,
    LogonHours: *u8,
};

pub const SR_SECURITY_DESCRIPTOR = extern struct {
    Length: u32,
    SecurityDescriptor: *u8,
};

pub const USER_ALL_INFORMATION = extern struct {
    LastLogon: LARGE_INTEGER,
    LastLogoff: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    AccountExpires: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
    UserName: UNICODE_STRING,
    FullName: UNICODE_STRING,
    HomeDirectory: UNICODE_STRING,
    HomeDirectoryDrive: UNICODE_STRING,
    ScriptPath: UNICODE_STRING,
    ProfilePath: UNICODE_STRING,
    AdminComment: UNICODE_STRING,
    WorkStations: UNICODE_STRING,
    UserComment: UNICODE_STRING,
    Parameters: UNICODE_STRING,
    LmPassword: UNICODE_STRING,
    NtPassword: UNICODE_STRING,
    PrivateData: UNICODE_STRING,
    SecurityDescriptor: SR_SECURITY_DESCRIPTOR,
    UserId: u32,
    PrimaryGroupId: u32,
    UserAccountControl: u32,
    WhichFields: u32,
    LogonHours: LOGON_HOURS,
    BadPasswordCount: u16,
    LogonCount: u16,
    CountryCode: u16,
    CodePage: u16,
    LmPasswordPresent: u8,
    NtPasswordPresent: u8,
    PasswordExpired: u8,
    PrivateDataSensitive: u8,
};

pub const CLEAR_BLOCK = extern struct {
    data: [8]CHAR,
};

pub const USER_SESSION_KEY = extern struct {
    data: [2]CYPHER_BLOCK,
};

pub const NETLOGON_LOGON_INFO_CLASS = extern enum(i32) {
    InteractiveInformation = 1,
    NetworkInformation = 2,
    ServiceInformation = 3,
    GenericInformation = 4,
    InteractiveTransitiveInformation = 5,
    NetworkTransitiveInformation = 6,
    ServiceTransitiveInformation = 7,
};
pub const NetlogonInteractiveInformation = NETLOGON_LOGON_INFO_CLASS.InteractiveInformation;
pub const NetlogonNetworkInformation = NETLOGON_LOGON_INFO_CLASS.NetworkInformation;
pub const NetlogonServiceInformation = NETLOGON_LOGON_INFO_CLASS.ServiceInformation;
pub const NetlogonGenericInformation = NETLOGON_LOGON_INFO_CLASS.GenericInformation;
pub const NetlogonInteractiveTransitiveInformation = NETLOGON_LOGON_INFO_CLASS.InteractiveTransitiveInformation;
pub const NetlogonNetworkTransitiveInformation = NETLOGON_LOGON_INFO_CLASS.NetworkTransitiveInformation;
pub const NetlogonServiceTransitiveInformation = NETLOGON_LOGON_INFO_CLASS.ServiceTransitiveInformation;

pub const NETLOGON_LOGON_IDENTITY_INFO = extern struct {
    LogonDomainName: UNICODE_STRING,
    ParameterControl: u32,
    LogonId: LARGE_INTEGER,
    UserName: UNICODE_STRING,
    Workstation: UNICODE_STRING,
};

pub const NETLOGON_INTERACTIVE_INFO = extern struct {
    Identity: NETLOGON_LOGON_IDENTITY_INFO,
    LmOwfPassword: LM_OWF_PASSWORD,
    NtOwfPassword: LM_OWF_PASSWORD,
};

pub const NETLOGON_SERVICE_INFO = extern struct {
    Identity: NETLOGON_LOGON_IDENTITY_INFO,
    LmOwfPassword: LM_OWF_PASSWORD,
    NtOwfPassword: LM_OWF_PASSWORD,
};

pub const NETLOGON_NETWORK_INFO = extern struct {
    Identity: NETLOGON_LOGON_IDENTITY_INFO,
    LmChallenge: CLEAR_BLOCK,
    NtChallengeResponse: STRING,
    LmChallengeResponse: STRING,
};

pub const NETLOGON_GENERIC_INFO = extern struct {
    Identity: NETLOGON_LOGON_IDENTITY_INFO,
    PackageName: UNICODE_STRING,
    DataLength: u32,
    LogonData: *u8,
};

pub const MSV1_0_VALIDATION_INFO = extern struct {
    LogoffTime: LARGE_INTEGER,
    KickoffTime: LARGE_INTEGER,
    LogonServer: UNICODE_STRING,
    LogonDomainName: UNICODE_STRING,
    SessionKey: USER_SESSION_KEY,
    Authoritative: u8,
    UserFlags: u32,
    WhichFields: u32,
    UserId: u32,
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const IdentityUpdateEvent = extern enum(u32) {
    ASSOCIATED = 1,
    DISASSOCIATED = 2,
    CREATED = 4,
    IMPORTED = 8,
    DELETED = 16,
    PROPCHANGED = 32,
    CONNECTED = 64,
    DISCONNECTED = 128,
    _,
};
pub const IDENTITY_ASSOCIATED = IdentityUpdateEvent.ASSOCIATED;
pub const IDENTITY_DISASSOCIATED = IdentityUpdateEvent.DISASSOCIATED;
pub const IDENTITY_CREATED = IdentityUpdateEvent.CREATED;
pub const IDENTITY_IMPORTED = IdentityUpdateEvent.IMPORTED;
pub const IDENTITY_DELETED = IdentityUpdateEvent.DELETED;
pub const IDENTITY_PROPCHANGED = IdentityUpdateEvent.PROPCHANGED;
pub const IDENTITY_CONNECTED = IdentityUpdateEvent.CONNECTED;
pub const IDENTITY_DISCONNECTED = IdentityUpdateEvent.DISCONNECTED;

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityAdvise_Value = @import("../zig.zig").Guid.initString("4e982fed-d14b-440c-b8d6-bb386453d386");
pub const IID_IIdentityAdvise = &IID_IIdentityAdvise_Value;
pub const IIdentityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IdentityUpdated: fn(
            self: *const IIdentityAdvise,
            dwIdentityUpdateEvents: IdentityUpdateEvent,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAdvise_IdentityUpdated(self: *const T, dwIdentityUpdateEvents: IdentityUpdateEvent, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAdvise.VTable, self.vtable).IdentityUpdated(@ptrCast(*const IIdentityAdvise, self), dwIdentityUpdateEvents, lpszUniqueID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityAdvise_Value = @import("../zig.zig").Guid.initString("3ab4c8da-d038-4830-8dd9-3253c55a127f");
pub const IID_AsyncIIdentityAdvise = &IID_AsyncIIdentityAdvise_Value;
pub const AsyncIIdentityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_IdentityUpdated: fn(
            self: *const AsyncIIdentityAdvise,
            dwIdentityUpdateEvents: u32,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_IdentityUpdated: fn(
            self: *const AsyncIIdentityAdvise,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAdvise_Begin_IdentityUpdated(self: *const T, dwIdentityUpdateEvents: u32, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAdvise.VTable, self.vtable).Begin_IdentityUpdated(@ptrCast(*const AsyncIIdentityAdvise, self), dwIdentityUpdateEvents, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAdvise_Finish_IdentityUpdated(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAdvise.VTable, self.vtable).Finish_IdentityUpdated(@ptrCast(*const AsyncIIdentityAdvise, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityProvider_Value = @import("../zig.zig").Guid.initString("0d1b9e0c-e8ba-4f55-a81b-bce934b948f5");
pub const IID_IIdentityProvider = &IID_IIdentityProvider_Value;
pub const IIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentityEnum: fn(
            self: *const IIdentityProvider,
            eIdentityType: IDENTITY_TYPE,
            pFilterkey: ?*const PROPERTYKEY,
            pFilterPropVarValue: ?*const PROPVARIANT,
            ppIdentityEnum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IIdentityProvider,
            lpszUserName: [*:0]const u16,
            ppPropertyStore: ?*?*IPropertyStore,
            pKeywordsToAdd: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IIdentityProvider,
            pPropertyStore: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IIdentityProvider,
            lpszUniqueID: [*:0]const u16,
            pKeywordsToDelete: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindByUniqueID: fn(
            self: *const IIdentityProvider,
            lpszUniqueID: [*:0]const u16,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderPropertyStore: fn(
            self: *const IIdentityProvider,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IIdentityProvider,
            pIdentityAdvise: ?*IIdentityAdvise,
            dwIdentityUpdateEvents: IdentityUpdateEvent,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: fn(
            self: *const IIdentityProvider,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_GetIdentityEnum(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).GetIdentityEnum(@ptrCast(*const IIdentityProvider, self), eIdentityType, pFilterkey, pFilterPropVarValue, ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Create(self: *const T, lpszUserName: [*:0]const u16, ppPropertyStore: ?*?*IPropertyStore, pKeywordsToAdd: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Create(@ptrCast(*const IIdentityProvider, self), lpszUserName, ppPropertyStore, pKeywordsToAdd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Import(self: *const T, pPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Import(@ptrCast(*const IIdentityProvider, self), pPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Delete(self: *const T, lpszUniqueID: [*:0]const u16, pKeywordsToDelete: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Delete(@ptrCast(*const IIdentityProvider, self), lpszUniqueID, pKeywordsToDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_FindByUniqueID(self: *const T, lpszUniqueID: [*:0]const u16, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).FindByUniqueID(@ptrCast(*const IIdentityProvider, self), lpszUniqueID, ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_GetProviderPropertyStore(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).GetProviderPropertyStore(@ptrCast(*const IIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_Advise(self: *const T, pIdentityAdvise: ?*IIdentityAdvise, dwIdentityUpdateEvents: IdentityUpdateEvent, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).Advise(@ptrCast(*const IIdentityProvider, self), pIdentityAdvise, dwIdentityUpdateEvents, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityProvider_UnAdvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityProvider.VTable, self.vtable).UnAdvise(@ptrCast(*const IIdentityProvider, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityProvider_Value = @import("../zig.zig").Guid.initString("c6fc9901-c433-4646-8f48-4e4687aae2a0");
pub const IID_AsyncIIdentityProvider = &IID_AsyncIIdentityProvider_Value;
pub const AsyncIIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_GetIdentityEnum: fn(
            self: *const AsyncIIdentityProvider,
            eIdentityType: IDENTITY_TYPE,
            pFilterkey: ?*const PROPERTYKEY,
            pFilterPropVarValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetIdentityEnum: fn(
            self: *const AsyncIIdentityProvider,
            ppIdentityEnum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Create: fn(
            self: *const AsyncIIdentityProvider,
            lpszUserName: [*:0]const u16,
            pKeywordsToAdd: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Create: fn(
            self: *const AsyncIIdentityProvider,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Import: fn(
            self: *const AsyncIIdentityProvider,
            pPropertyStore: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Import: fn(
            self: *const AsyncIIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Delete: fn(
            self: *const AsyncIIdentityProvider,
            lpszUniqueID: [*:0]const u16,
            pKeywordsToDelete: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Delete: fn(
            self: *const AsyncIIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_FindByUniqueID: fn(
            self: *const AsyncIIdentityProvider,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_FindByUniqueID: fn(
            self: *const AsyncIIdentityProvider,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_GetProviderPropertyStore: fn(
            self: *const AsyncIIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetProviderPropertyStore: fn(
            self: *const AsyncIIdentityProvider,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Advise: fn(
            self: *const AsyncIIdentityProvider,
            pIdentityAdvise: ?*IIdentityAdvise,
            dwIdentityUpdateEvents: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Advise: fn(
            self: *const AsyncIIdentityProvider,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_UnAdvise: fn(
            self: *const AsyncIIdentityProvider,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_UnAdvise: fn(
            self: *const AsyncIIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_GetIdentityEnum(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_GetIdentityEnum(@ptrCast(*const AsyncIIdentityProvider, self), eIdentityType, pFilterkey, pFilterPropVarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_GetIdentityEnum(self: *const T, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_GetIdentityEnum(@ptrCast(*const AsyncIIdentityProvider, self), ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Create(self: *const T, lpszUserName: [*:0]const u16, pKeywordsToAdd: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Create(@ptrCast(*const AsyncIIdentityProvider, self), lpszUserName, pKeywordsToAdd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Create(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Create(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Import(self: *const T, pPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Import(@ptrCast(*const AsyncIIdentityProvider, self), pPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Import(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Import(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Delete(self: *const T, lpszUniqueID: [*:0]const u16, pKeywordsToDelete: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Delete(@ptrCast(*const AsyncIIdentityProvider, self), lpszUniqueID, pKeywordsToDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Delete(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_FindByUniqueID(self: *const T, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_FindByUniqueID(@ptrCast(*const AsyncIIdentityProvider, self), lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_FindByUniqueID(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_FindByUniqueID(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_GetProviderPropertyStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_GetProviderPropertyStore(@ptrCast(*const AsyncIIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_GetProviderPropertyStore(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_GetProviderPropertyStore(@ptrCast(*const AsyncIIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_Advise(self: *const T, pIdentityAdvise: ?*IIdentityAdvise, dwIdentityUpdateEvents: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_Advise(@ptrCast(*const AsyncIIdentityProvider, self), pIdentityAdvise, dwIdentityUpdateEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_Advise(self: *const T, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_Advise(@ptrCast(*const AsyncIIdentityProvider, self), pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Begin_UnAdvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Begin_UnAdvise(@ptrCast(*const AsyncIIdentityProvider, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityProvider_Finish_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityProvider.VTable, self.vtable).Finish_UnAdvise(@ptrCast(*const AsyncIIdentityProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAssociatedIdentityProvider_Value = @import("../zig.zig").Guid.initString("2af066b3-4cbb-4cba-a798-204b6af68cc0");
pub const IID_IAssociatedIdentityProvider = &IID_IAssociatedIdentityProvider_Value;
pub const IAssociatedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateIdentity: fn(
            self: *const IAssociatedIdentityProvider,
            hwndParent: HWND,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisassociateIdentity: fn(
            self: *const IAssociatedIdentityProvider,
            hwndParent: HWND,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCredential: fn(
            self: *const IAssociatedIdentityProvider,
            hwndParent: HWND,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_AssociateIdentity(self: *const T, hwndParent: HWND, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).AssociateIdentity(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_DisassociateIdentity(self: *const T, hwndParent: HWND, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).DisassociateIdentity(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssociatedIdentityProvider_ChangeCredential(self: *const T, hwndParent: HWND, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssociatedIdentityProvider.VTable, self.vtable).ChangeCredential(@ptrCast(*const IAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAssociatedIdentityProvider_Value = @import("../zig.zig").Guid.initString("2834d6ed-297e-4e72-8a51-961e86f05152");
pub const IID_AsyncIAssociatedIdentityProvider = &IID_AsyncIAssociatedIdentityProvider_Value;
pub const AsyncIAssociatedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_AssociateIdentity: fn(
            self: *const AsyncIAssociatedIdentityProvider,
            hwndParent: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_AssociateIdentity: fn(
            self: *const AsyncIAssociatedIdentityProvider,
            ppPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_DisassociateIdentity: fn(
            self: *const AsyncIAssociatedIdentityProvider,
            hwndParent: HWND,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_DisassociateIdentity: fn(
            self: *const AsyncIAssociatedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_ChangeCredential: fn(
            self: *const AsyncIAssociatedIdentityProvider,
            hwndParent: HWND,
            lpszUniqueID: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_ChangeCredential: fn(
            self: *const AsyncIAssociatedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_AssociateIdentity(self: *const T, hwndParent: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_AssociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_AssociateIdentity(self: *const T, ppPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_AssociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), ppPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_DisassociateIdentity(self: *const T, hwndParent: HWND, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_DisassociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_DisassociateIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_DisassociateIdentity(@ptrCast(*const AsyncIAssociatedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Begin_ChangeCredential(self: *const T, hwndParent: HWND, lpszUniqueID: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Begin_ChangeCredential(@ptrCast(*const AsyncIAssociatedIdentityProvider, self), hwndParent, lpszUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAssociatedIdentityProvider_Finish_ChangeCredential(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIAssociatedIdentityProvider.VTable, self.vtable).Finish_ChangeCredential(@ptrCast(*const AsyncIAssociatedIdentityProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IDENTITY_URL = extern enum(i32) {
    CREATE_ACCOUNT_WIZARD = 0,
    SIGN_IN_WIZARD = 1,
    CHANGE_PASSWORD_WIZARD = 2,
    IFEXISTS_WIZARD = 3,
    ACCOUNT_SETTINGS = 4,
    RESTORE_WIZARD = 5,
    CONNECT_WIZARD = 6,
};
pub const IDENTITY_URL_CREATE_ACCOUNT_WIZARD = IDENTITY_URL.CREATE_ACCOUNT_WIZARD;
pub const IDENTITY_URL_SIGN_IN_WIZARD = IDENTITY_URL.SIGN_IN_WIZARD;
pub const IDENTITY_URL_CHANGE_PASSWORD_WIZARD = IDENTITY_URL.CHANGE_PASSWORD_WIZARD;
pub const IDENTITY_URL_IFEXISTS_WIZARD = IDENTITY_URL.IFEXISTS_WIZARD;
pub const IDENTITY_URL_ACCOUNT_SETTINGS = IDENTITY_URL.ACCOUNT_SETTINGS;
pub const IDENTITY_URL_RESTORE_WIZARD = IDENTITY_URL.RESTORE_WIZARD;
pub const IDENTITY_URL_CONNECT_WIZARD = IDENTITY_URL.CONNECT_WIZARD;

pub const ACCOUNT_STATE = extern enum(i32) {
    NOT_CONNECTED = 0,
    CONNECTING = 1,
    CONNECT_COMPLETED = 2,
};
pub const NOT_CONNECTED = ACCOUNT_STATE.NOT_CONNECTED;
pub const CONNECTING = ACCOUNT_STATE.CONNECTING;
pub const CONNECT_COMPLETED = ACCOUNT_STATE.CONNECT_COMPLETED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IConnectedIdentityProvider_Value = @import("../zig.zig").Guid.initString("b7417b54-e08c-429b-96c8-678d1369ecb1");
pub const IID_IConnectedIdentityProvider = &IID_IConnectedIdentityProvider_Value;
pub const IConnectedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectIdentity: fn(
            self: *const IConnectedIdentityProvider,
            AuthBuffer: [*:0]u8,
            AuthBufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectIdentity: fn(
            self: *const IConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const IConnectedIdentityProvider,
            Connected: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUrl: fn(
            self: *const IConnectedIdentityProvider,
            Identifier: IDENTITY_URL,
            Context: ?*IBindCtx,
            PostData: *VARIANT,
            Url: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccountState: fn(
            self: *const IConnectedIdentityProvider,
            pState: *ACCOUNT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_ConnectIdentity(self: *const T, AuthBuffer: [*:0]u8, AuthBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).ConnectIdentity(@ptrCast(*const IConnectedIdentityProvider, self), AuthBuffer, AuthBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).DisconnectIdentity(@ptrCast(*const IConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_IsConnected(self: *const T, Connected: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).IsConnected(@ptrCast(*const IConnectedIdentityProvider, self), Connected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_GetUrl(self: *const T, Identifier: IDENTITY_URL, Context: ?*IBindCtx, PostData: *VARIANT, Url: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).GetUrl(@ptrCast(*const IConnectedIdentityProvider, self), Identifier, Context, PostData, Url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectedIdentityProvider_GetAccountState(self: *const T, pState: *ACCOUNT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectedIdentityProvider.VTable, self.vtable).GetAccountState(@ptrCast(*const IConnectedIdentityProvider, self), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIConnectedIdentityProvider_Value = @import("../zig.zig").Guid.initString("9ce55141-bce9-4e15-824d-43d79f512f93");
pub const IID_AsyncIConnectedIdentityProvider = &IID_AsyncIConnectedIdentityProvider_Value;
pub const AsyncIConnectedIdentityProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_ConnectIdentity: fn(
            self: *const AsyncIConnectedIdentityProvider,
            AuthBuffer: [*:0]u8,
            AuthBufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_ConnectIdentity: fn(
            self: *const AsyncIConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_DisconnectIdentity: fn(
            self: *const AsyncIConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_DisconnectIdentity: fn(
            self: *const AsyncIConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_IsConnected: fn(
            self: *const AsyncIConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_IsConnected: fn(
            self: *const AsyncIConnectedIdentityProvider,
            Connected: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_GetUrl: fn(
            self: *const AsyncIConnectedIdentityProvider,
            Identifier: IDENTITY_URL,
            Context: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetUrl: fn(
            self: *const AsyncIConnectedIdentityProvider,
            PostData: *VARIANT,
            Url: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_GetAccountState: fn(
            self: *const AsyncIConnectedIdentityProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetAccountState: fn(
            self: *const AsyncIConnectedIdentityProvider,
            pState: *ACCOUNT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_ConnectIdentity(self: *const T, AuthBuffer: [*:0]u8, AuthBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_ConnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self), AuthBuffer, AuthBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_ConnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_ConnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_DisconnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_DisconnectIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_DisconnectIdentity(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_IsConnected(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_IsConnected(self: *const T, Connected: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_IsConnected(@ptrCast(*const AsyncIConnectedIdentityProvider, self), Connected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_GetUrl(self: *const T, Identifier: IDENTITY_URL, Context: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_GetUrl(@ptrCast(*const AsyncIConnectedIdentityProvider, self), Identifier, Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_GetUrl(self: *const T, PostData: *VARIANT, Url: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_GetUrl(@ptrCast(*const AsyncIConnectedIdentityProvider, self), PostData, Url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Begin_GetAccountState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Begin_GetAccountState(@ptrCast(*const AsyncIConnectedIdentityProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIConnectedIdentityProvider_Finish_GetAccountState(self: *const T, pState: *ACCOUNT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIConnectedIdentityProvider.VTable, self.vtable).Finish_GetAccountState(@ptrCast(*const AsyncIConnectedIdentityProvider, self), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIdentityAuthentication_Value = @import("../zig.zig").Guid.initString("5e7ef254-979f-43b5-b74e-06e4eb7df0f9");
pub const IID_IIdentityAuthentication = &IID_IIdentityAuthentication_Value;
pub const IIdentityAuthentication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIdentityCredential: fn(
            self: *const IIdentityAuthentication,
            CredBuffer: ?[*:0]u8,
            CredBufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateIdentityCredential: fn(
            self: *const IIdentityAuthentication,
            CredBuffer: [*:0]u8,
            CredBufferLength: u32,
            ppIdentityProperties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAuthentication_SetIdentityCredential(self: *const T, CredBuffer: ?[*:0]u8, CredBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAuthentication.VTable, self.vtable).SetIdentityCredential(@ptrCast(*const IIdentityAuthentication, self), CredBuffer, CredBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityAuthentication_ValidateIdentityCredential(self: *const T, CredBuffer: [*:0]u8, CredBufferLength: u32, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityAuthentication.VTable, self.vtable).ValidateIdentityCredential(@ptrCast(*const IIdentityAuthentication, self), CredBuffer, CredBufferLength, ppIdentityProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityAuthentication_Value = @import("../zig.zig").Guid.initString("f9a2f918-feca-4e9c-9633-61cbf13ed34d");
pub const IID_AsyncIIdentityAuthentication = &IID_AsyncIIdentityAuthentication_Value;
pub const AsyncIIdentityAuthentication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_SetIdentityCredential: fn(
            self: *const AsyncIIdentityAuthentication,
            CredBuffer: ?[*:0]u8,
            CredBufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_SetIdentityCredential: fn(
            self: *const AsyncIIdentityAuthentication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_ValidateIdentityCredential: fn(
            self: *const AsyncIIdentityAuthentication,
            CredBuffer: [*:0]u8,
            CredBufferLength: u32,
            ppIdentityProperties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_ValidateIdentityCredential: fn(
            self: *const AsyncIIdentityAuthentication,
            ppIdentityProperties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Begin_SetIdentityCredential(self: *const T, CredBuffer: ?[*:0]u8, CredBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Begin_SetIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), CredBuffer, CredBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Finish_SetIdentityCredential(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Finish_SetIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Begin_ValidateIdentityCredential(self: *const T, CredBuffer: [*:0]u8, CredBufferLength: u32, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Begin_ValidateIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), CredBuffer, CredBufferLength, ppIdentityProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityAuthentication_Finish_ValidateIdentityCredential(self: *const T, ppIdentityProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityAuthentication.VTable, self.vtable).Finish_ValidateIdentityCredential(@ptrCast(*const AsyncIIdentityAuthentication, self), ppIdentityProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CoClassIdentityStore_Value = @import("../zig.zig").Guid.initString("30d49246-d217-465f-b00b-ac9ddd652eb7");
pub const CLSID_CoClassIdentityStore = &CLSID_CoClassIdentityStore_Value;

const CLSID_CIdentityProfileHandler_Value = @import("../zig.zig").Guid.initString("ecf5bf46-e3b6-449a-b56b-43f58f867814");
pub const CLSID_CIdentityProfileHandler = &CLSID_CIdentityProfileHandler_Value;

// TODO: this type is limited to platform 'windows6.1'
const IID_IIdentityStore_Value = @import("../zig.zig").Guid.initString("df586fa5-6f35-44f1-b209-b38e169772eb");
pub const IID_IIdentityStore = &IID_IIdentityStore_Value;
pub const IIdentityStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IIdentityStore,
            pdwProviders: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAt: fn(
            self: *const IIdentityStore,
            dwProvider: u32,
            pProvGuid: ?*Guid,
            ppIdentityProvider: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToCache: fn(
            self: *const IIdentityStore,
            lpszUniqueID: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertToSid: fn(
            self: *const IIdentityStore,
            lpszUniqueID: [*:0]const u16,
            ProviderGUID: *const Guid,
            cbSid: u16,
            pSid: ?[*:0]u8,
            pcbRequiredSid: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateIdentities: fn(
            self: *const IIdentityStore,
            eIdentityType: IDENTITY_TYPE,
            pFilterkey: ?*const PROPERTYKEY,
            pFilterPropVarValue: ?*const PROPVARIANT,
            ppIdentityEnum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IIdentityStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_GetCount(self: *const T, pdwProviders: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).GetCount(@ptrCast(*const IIdentityStore, self), pdwProviders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_GetAt(self: *const T, dwProvider: u32, pProvGuid: ?*Guid, ppIdentityProvider: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).GetAt(@ptrCast(*const IIdentityStore, self), dwProvider, pProvGuid, ppIdentityProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_AddToCache(self: *const T, lpszUniqueID: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).AddToCache(@ptrCast(*const IIdentityStore, self), lpszUniqueID, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_ConvertToSid(self: *const T, lpszUniqueID: [*:0]const u16, ProviderGUID: *const Guid, cbSid: u16, pSid: ?[*:0]u8, pcbRequiredSid: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).ConvertToSid(@ptrCast(*const IIdentityStore, self), lpszUniqueID, ProviderGUID, cbSid, pSid, pcbRequiredSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_EnumerateIdentities(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).EnumerateIdentities(@ptrCast(*const IIdentityStore, self), eIdentityType, pFilterkey, pFilterPropVarValue, ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStore_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStore.VTable, self.vtable).Reset(@ptrCast(*const IIdentityStore, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityStore_Value = @import("../zig.zig").Guid.initString("eefa1616-48de-4872-aa64-6e6206535a51");
pub const IID_AsyncIIdentityStore = &IID_AsyncIIdentityStore_Value;
pub const AsyncIIdentityStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_GetCount: fn(
            self: *const AsyncIIdentityStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetCount: fn(
            self: *const AsyncIIdentityStore,
            pdwProviders: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_GetAt: fn(
            self: *const AsyncIIdentityStore,
            dwProvider: u32,
            pProvGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_GetAt: fn(
            self: *const AsyncIIdentityStore,
            pProvGuid: ?*Guid,
            ppIdentityProvider: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_AddToCache: fn(
            self: *const AsyncIIdentityStore,
            lpszUniqueID: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_AddToCache: fn(
            self: *const AsyncIIdentityStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_ConvertToSid: fn(
            self: *const AsyncIIdentityStore,
            lpszUniqueID: [*:0]const u16,
            ProviderGUID: *const Guid,
            cbSid: u16,
            pSid: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_ConvertToSid: fn(
            self: *const AsyncIIdentityStore,
            pSid: ?*u8,
            pcbRequiredSid: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_EnumerateIdentities: fn(
            self: *const AsyncIIdentityStore,
            eIdentityType: IDENTITY_TYPE,
            pFilterkey: ?*const PROPERTYKEY,
            pFilterPropVarValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_EnumerateIdentities: fn(
            self: *const AsyncIIdentityStore,
            ppIdentityEnum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Reset: fn(
            self: *const AsyncIIdentityStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Reset: fn(
            self: *const AsyncIIdentityStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_GetCount(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_GetCount(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_GetCount(self: *const T, pdwProviders: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_GetCount(@ptrCast(*const AsyncIIdentityStore, self), pdwProviders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_GetAt(self: *const T, dwProvider: u32, pProvGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_GetAt(@ptrCast(*const AsyncIIdentityStore, self), dwProvider, pProvGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_GetAt(self: *const T, pProvGuid: ?*Guid, ppIdentityProvider: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_GetAt(@ptrCast(*const AsyncIIdentityStore, self), pProvGuid, ppIdentityProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_AddToCache(self: *const T, lpszUniqueID: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_AddToCache(@ptrCast(*const AsyncIIdentityStore, self), lpszUniqueID, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_AddToCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_AddToCache(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_ConvertToSid(self: *const T, lpszUniqueID: [*:0]const u16, ProviderGUID: *const Guid, cbSid: u16, pSid: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_ConvertToSid(@ptrCast(*const AsyncIIdentityStore, self), lpszUniqueID, ProviderGUID, cbSid, pSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_ConvertToSid(self: *const T, pSid: ?*u8, pcbRequiredSid: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_ConvertToSid(@ptrCast(*const AsyncIIdentityStore, self), pSid, pcbRequiredSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_EnumerateIdentities(self: *const T, eIdentityType: IDENTITY_TYPE, pFilterkey: ?*const PROPERTYKEY, pFilterPropVarValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_EnumerateIdentities(@ptrCast(*const AsyncIIdentityStore, self), eIdentityType, pFilterkey, pFilterPropVarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_EnumerateIdentities(self: *const T, ppIdentityEnum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_EnumerateIdentities(@ptrCast(*const AsyncIIdentityStore, self), ppIdentityEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Begin_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Begin_Reset(@ptrCast(*const AsyncIIdentityStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStore_Finish_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStore.VTable, self.vtable).Finish_Reset(@ptrCast(*const AsyncIIdentityStore, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIdentityStoreEx_Value = @import("../zig.zig").Guid.initString("f9f9eb98-8f7f-4e38-9577-6980114ce32b");
pub const IID_IIdentityStoreEx = &IID_IIdentityStoreEx_Value;
pub const IIdentityStoreEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateConnectedIdentity: fn(
            self: *const IIdentityStoreEx,
            LocalName: ?[*:0]const u16,
            ConnectedName: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteConnectedIdentity: fn(
            self: *const IIdentityStoreEx,
            ConnectedName: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStoreEx_CreateConnectedIdentity(self: *const T, LocalName: ?[*:0]const u16, ConnectedName: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStoreEx.VTable, self.vtable).CreateConnectedIdentity(@ptrCast(*const IIdentityStoreEx, self), LocalName, ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdentityStoreEx_DeleteConnectedIdentity(self: *const T, ConnectedName: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdentityStoreEx.VTable, self.vtable).DeleteConnectedIdentity(@ptrCast(*const IIdentityStoreEx, self), ConnectedName, ProviderGUID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIIdentityStoreEx_Value = @import("../zig.zig").Guid.initString("fca3af9a-8a07-4eae-8632-ec3de658a36a");
pub const IID_AsyncIIdentityStoreEx = &IID_AsyncIIdentityStoreEx_Value;
pub const AsyncIIdentityStoreEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_CreateConnectedIdentity: fn(
            self: *const AsyncIIdentityStoreEx,
            LocalName: ?[*:0]const u16,
            ConnectedName: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_CreateConnectedIdentity: fn(
            self: *const AsyncIIdentityStoreEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_DeleteConnectedIdentity: fn(
            self: *const AsyncIIdentityStoreEx,
            ConnectedName: [*:0]const u16,
            ProviderGUID: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_DeleteConnectedIdentity: fn(
            self: *const AsyncIIdentityStoreEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Begin_CreateConnectedIdentity(self: *const T, LocalName: ?[*:0]const u16, ConnectedName: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Begin_CreateConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self), LocalName, ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Finish_CreateConnectedIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Finish_CreateConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Begin_DeleteConnectedIdentity(self: *const T, ConnectedName: [*:0]const u16, ProviderGUID: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Begin_DeleteConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self), ConnectedName, ProviderGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIIdentityStoreEx_Finish_DeleteConnectedIdentity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIIdentityStoreEx.VTable, self.vtable).Finish_DeleteConnectedIdentity(@ptrCast(*const AsyncIIdentityStoreEx, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIT_PARAM_TYPE = extern enum(i32) {
    None = 1,
    String = 2,
    Ulong = 3,
    Pointer = 4,
    Sid = 5,
    LogonId = 6,
    ObjectTypeList = 7,
    Luid = 8,
    Guid = 9,
    Time = 10,
    Int64 = 11,
    IpAddress = 12,
    LogonIdWithSid = 13,
};
pub const APT_None = AUDIT_PARAM_TYPE.None;
pub const APT_String = AUDIT_PARAM_TYPE.String;
pub const APT_Ulong = AUDIT_PARAM_TYPE.Ulong;
pub const APT_Pointer = AUDIT_PARAM_TYPE.Pointer;
pub const APT_Sid = AUDIT_PARAM_TYPE.Sid;
pub const APT_LogonId = AUDIT_PARAM_TYPE.LogonId;
pub const APT_ObjectTypeList = AUDIT_PARAM_TYPE.ObjectTypeList;
pub const APT_Luid = AUDIT_PARAM_TYPE.Luid;
pub const APT_Guid = AUDIT_PARAM_TYPE.Guid;
pub const APT_Time = AUDIT_PARAM_TYPE.Time;
pub const APT_Int64 = AUDIT_PARAM_TYPE.Int64;
pub const APT_IpAddress = AUDIT_PARAM_TYPE.IpAddress;
pub const APT_LogonIdWithSid = AUDIT_PARAM_TYPE.LogonIdWithSid;

pub const AUDIT_OBJECT_TYPE = extern struct {
    ObjectType: Guid,
    Flags: u16,
    Level: u16,
    AccessMask: u32,
};

pub const AUDIT_OBJECT_TYPES = extern struct {
    Count: u16,
    Flags: u16,
    pObjectTypes: *AUDIT_OBJECT_TYPE,
};

pub const AUDIT_IP_ADDRESS = extern struct {
    pIpAddress: [128]u8,
};

pub const AUDIT_PARAM = extern struct {
    Type: AUDIT_PARAM_TYPE,
    Length: u32,
    Flags: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const AUDIT_PARAMS = extern struct {
    Length: u32,
    Flags: u32,
    Count: u16,
    Parameters: *AUDIT_PARAM,
};

pub const AUTHZ_AUDIT_EVENT_TYPE_LEGACY = extern struct {
    CategoryId: u16,
    AuditId: u16,
    ParameterCount: u16,
};

pub const AUTHZ_AUDIT_EVENT_TYPE_UNION = extern union {
    Legacy: AUTHZ_AUDIT_EVENT_TYPE_LEGACY,
};

pub const AUTHZ_AUDIT_EVENT_TYPE_OLD = extern struct {
    Version: u32,
    dwFlags: u32,
    RefCount: i32,
    hAudit: usize,
    LinkId: LUID,
    u: AUTHZ_AUDIT_EVENT_TYPE_UNION,
};

pub const AUTHZ_CAP_CHANGE_SUBSCRIPTION_HANDLE__ = extern struct {
    unused: i32,
};

pub const AUTHZ_ACCESS_REQUEST = extern struct {
    DesiredAccess: u32,
    PrincipalSelfSid: PSID,
    ObjectTypeList: *OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    OptionalArguments: *c_void,
};

pub const AUTHZ_ACCESS_REPLY = extern struct {
    ResultListLength: u32,
    GrantedAccessMask: *u32,
    SaclEvaluationResults: *AUTHZ_GENERATE_RESULTS,
    Error: *u32,
};

pub const PFN_AUTHZ_DYNAMIC_ACCESS_CHECK = fn(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pAce: *ACE_HEADER,
    pArgs: ?*c_void,
    pbAceApplicable: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS = fn(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    Args: *c_void,
    pSidAttrArray: **SID_AND_ATTRIBUTES,
    pSidCount: *u32,
    pRestrictedSidAttrArray: **SID_AND_ATTRIBUTES,
    pRestrictedSidCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_AUTHZ_FREE_DYNAMIC_GROUPS = fn(
    pSidAttrArray: *SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_AUTHZ_GET_CENTRAL_ACCESS_POLICY = fn(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    capid: PSID,
    pArgs: ?*c_void,
    pCentralAccessPolicyApplicable: *BOOL,
    ppCentralAccessPolicy: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_AUTHZ_FREE_CENTRAL_ACCESS_POLICY = fn(
    pCentralAccessPolicy: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const AUTHZ_SECURITY_ATTRIBUTE_FQBN_VALUE = extern struct {
    Version: u64,
    pName: PWSTR,
};

pub const AUTHZ_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = extern struct {
    pValue: *c_void,
    ValueLength: u32,
};

pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION = extern enum(i32) {
    NONE = 0,
    REPLACE_ALL = 1,
    ADD = 2,
    DELETE = 3,
    REPLACE = 4,
};
pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION_NONE = AUTHZ_SECURITY_ATTRIBUTE_OPERATION.NONE;
pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION_REPLACE_ALL = AUTHZ_SECURITY_ATTRIBUTE_OPERATION.REPLACE_ALL;
pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION_ADD = AUTHZ_SECURITY_ATTRIBUTE_OPERATION.ADD;
pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION_DELETE = AUTHZ_SECURITY_ATTRIBUTE_OPERATION.DELETE;
pub const AUTHZ_SECURITY_ATTRIBUTE_OPERATION_REPLACE = AUTHZ_SECURITY_ATTRIBUTE_OPERATION.REPLACE;

pub const AUTHZ_SID_OPERATION = extern enum(i32) {
    NONE = 0,
    REPLACE_ALL = 1,
    ADD = 2,
    DELETE = 3,
    REPLACE = 4,
};
pub const AUTHZ_SID_OPERATION_NONE = AUTHZ_SID_OPERATION.NONE;
pub const AUTHZ_SID_OPERATION_REPLACE_ALL = AUTHZ_SID_OPERATION.REPLACE_ALL;
pub const AUTHZ_SID_OPERATION_ADD = AUTHZ_SID_OPERATION.ADD;
pub const AUTHZ_SID_OPERATION_DELETE = AUTHZ_SID_OPERATION.DELETE;
pub const AUTHZ_SID_OPERATION_REPLACE = AUTHZ_SID_OPERATION.REPLACE;

pub const AUTHZ_SECURITY_ATTRIBUTE_V1 = extern struct {
    pName: PWSTR,
    ValueType: u16,
    Reserved: u16,
    Flags: AUTHZ_SECURITY_ATTRIBUTE_FLAGS,
    ValueCount: u32,
    Values: _Values_e__Union,
    const _Values_e__Union = u32; // TODO: generate this nested type!
};

pub const AUTHZ_SECURITY_ATTRIBUTES_INFORMATION = extern struct {
    Version: u16,
    Reserved: u16,
    AttributeCount: u32,
    Attribute: _Attribute_e__Union,
    const _Attribute_e__Union = u32; // TODO: generate this nested type!
};

pub const AUTHZ_RPC_INIT_INFO_CLIENT = extern struct {
    version: u16,
    ObjectUuid: PWSTR,
    ProtSeq: PWSTR,
    NetworkAddr: PWSTR,
    Endpoint: PWSTR,
    Options: PWSTR,
    ServerSpn: PWSTR,
};

pub const AUTHZ_INIT_INFO = extern struct {
    version: u16,
    szResourceManagerName: [*:0]const u16,
    pfnDynamicAccessCheck: PFN_AUTHZ_DYNAMIC_ACCESS_CHECK,
    pfnComputeDynamicGroups: PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS,
    pfnFreeDynamicGroups: PFN_AUTHZ_FREE_DYNAMIC_GROUPS,
    pfnGetCentralAccessPolicy: PFN_AUTHZ_GET_CENTRAL_ACCESS_POLICY,
    pfnFreeCentralAccessPolicy: PFN_AUTHZ_FREE_CENTRAL_ACCESS_POLICY,
};

pub const AUTHZ_CONTEXT_INFORMATION_CLASS = extern enum(i32) {
    UserSid = 1,
    GroupsSids = 2,
    RestrictedSids = 3,
    Privileges = 4,
    ExpirationTime = 5,
    ServerContext = 6,
    Identifier = 7,
    Source = 8,
    All = 9,
    AuthenticationId = 10,
    SecurityAttributes = 11,
    DeviceSids = 12,
    UserClaims = 13,
    DeviceClaims = 14,
    AppContainerSid = 15,
    CapabilitySids = 16,
};
pub const AuthzContextInfoUserSid = AUTHZ_CONTEXT_INFORMATION_CLASS.UserSid;
pub const AuthzContextInfoGroupsSids = AUTHZ_CONTEXT_INFORMATION_CLASS.GroupsSids;
pub const AuthzContextInfoRestrictedSids = AUTHZ_CONTEXT_INFORMATION_CLASS.RestrictedSids;
pub const AuthzContextInfoPrivileges = AUTHZ_CONTEXT_INFORMATION_CLASS.Privileges;
pub const AuthzContextInfoExpirationTime = AUTHZ_CONTEXT_INFORMATION_CLASS.ExpirationTime;
pub const AuthzContextInfoServerContext = AUTHZ_CONTEXT_INFORMATION_CLASS.ServerContext;
pub const AuthzContextInfoIdentifier = AUTHZ_CONTEXT_INFORMATION_CLASS.Identifier;
pub const AuthzContextInfoSource = AUTHZ_CONTEXT_INFORMATION_CLASS.Source;
pub const AuthzContextInfoAll = AUTHZ_CONTEXT_INFORMATION_CLASS.All;
pub const AuthzContextInfoAuthenticationId = AUTHZ_CONTEXT_INFORMATION_CLASS.AuthenticationId;
pub const AuthzContextInfoSecurityAttributes = AUTHZ_CONTEXT_INFORMATION_CLASS.SecurityAttributes;
pub const AuthzContextInfoDeviceSids = AUTHZ_CONTEXT_INFORMATION_CLASS.DeviceSids;
pub const AuthzContextInfoUserClaims = AUTHZ_CONTEXT_INFORMATION_CLASS.UserClaims;
pub const AuthzContextInfoDeviceClaims = AUTHZ_CONTEXT_INFORMATION_CLASS.DeviceClaims;
pub const AuthzContextInfoAppContainerSid = AUTHZ_CONTEXT_INFORMATION_CLASS.AppContainerSid;
pub const AuthzContextInfoCapabilitySids = AUTHZ_CONTEXT_INFORMATION_CLASS.CapabilitySids;

pub const AUTHZ_AUDIT_EVENT_INFORMATION_CLASS = extern enum(i32) {
    Flags = 1,
    OperationType = 2,
    ObjectType = 3,
    ObjectName = 4,
    AdditionalInfo = 5,
};
pub const AuthzAuditEventInfoFlags = AUTHZ_AUDIT_EVENT_INFORMATION_CLASS.Flags;
pub const AuthzAuditEventInfoOperationType = AUTHZ_AUDIT_EVENT_INFORMATION_CLASS.OperationType;
pub const AuthzAuditEventInfoObjectType = AUTHZ_AUDIT_EVENT_INFORMATION_CLASS.ObjectType;
pub const AuthzAuditEventInfoObjectName = AUTHZ_AUDIT_EVENT_INFORMATION_CLASS.ObjectName;
pub const AuthzAuditEventInfoAdditionalInfo = AUTHZ_AUDIT_EVENT_INFORMATION_CLASS.AdditionalInfo;

pub const AUTHZ_REGISTRATION_OBJECT_TYPE_NAME_OFFSET = extern struct {
    szObjectTypeName: PWSTR,
    dwOffset: u32,
};

pub const AUTHZ_SOURCE_SCHEMA_REGISTRATION = extern struct {
    dwFlags: u32,
    szEventSourceName: PWSTR,
    szEventMessageFile: PWSTR,
    szEventSourceXmlSchemaFile: PWSTR,
    szEventAccessStringsFile: PWSTR,
    szExecutableImagePath: PWSTR,
    Anonymous: _Anonymous_e__Union,
    dwObjectTypeNameCount: u32,
    ObjectTypeNames: [1]AUTHZ_REGISTRATION_OBJECT_TYPE_NAME_OFFSET,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const CLSID_AzAuthorizationStore_Value = @import("../zig.zig").Guid.initString("b2bcff59-a757-4b0b-a1bc-ea69981da69e");
pub const CLSID_AzAuthorizationStore = &CLSID_AzAuthorizationStore_Value;

const CLSID_AzBizRuleContext_Value = @import("../zig.zig").Guid.initString("5c2dc96f-8d51-434b-b33c-379bccae77c3");
pub const CLSID_AzBizRuleContext = &CLSID_AzBizRuleContext_Value;

const CLSID_AzPrincipalLocator_Value = @import("../zig.zig").Guid.initString("483afb5d-70df-4e16-abdc-a1de4d015a3e");
pub const CLSID_AzPrincipalLocator = &CLSID_AzPrincipalLocator_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzAuthorizationStore_Value = @import("../zig.zig").Guid.initString("edbd9ca9-9b82-4f6a-9e8b-98301e450f14");
pub const IID_IAzAuthorizationStore = &IID_IAzAuthorizationStore_Value;
pub const IAzAuthorizationStore = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzAuthorizationStore,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzAuthorizationStore,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzAuthorizationStore,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzAuthorizationStore,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DomainTimeout: fn(
            self: *const IAzAuthorizationStore,
            plProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DomainTimeout: fn(
            self: *const IAzAuthorizationStore,
            lProp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScriptEngineTimeout: fn(
            self: *const IAzAuthorizationStore,
            plProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScriptEngineTimeout: fn(
            self: *const IAzAuthorizationStore,
            lProp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxScriptEngines: fn(
            self: *const IAzAuthorizationStore,
            plProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxScriptEngines: fn(
            self: *const IAzAuthorizationStore,
            lProp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenerateAudits: fn(
            self: *const IAzAuthorizationStore,
            pbProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GenerateAudits: fn(
            self: *const IAzAuthorizationStore,
            bProp: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzAuthorizationStore,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzAuthorizationStore,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzAuthorizationStore,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzAuthorizationStore,
            lPropId: AZ_PROP_CONSTANTS,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzAuthorizationStore,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministrators: fn(
            self: *const IAzAuthorizationStore,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReaders: fn(
            self: *const IAzAuthorizationStore,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministrator: fn(
            self: *const IAzAuthorizationStore,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministrator: fn(
            self: *const IAzAuthorizationStore,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReader: fn(
            self: *const IAzAuthorizationStore,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReader: fn(
            self: *const IAzAuthorizationStore,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IAzAuthorizationStore,
            lFlags: AZ_PROP_CONSTANTS,
            bstrPolicyURL: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateCache: fn(
            self: *const IAzAuthorizationStore,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IAzAuthorizationStore,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Applications: fn(
            self: *const IAzAuthorizationStore,
            ppAppCollection: ?*?*IAzApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenApplication: fn(
            self: *const IAzAuthorizationStore,
            bstrApplicationName: BSTR,
            varReserved: VARIANT,
            ppApplication: ?*?*IAzApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplication: fn(
            self: *const IAzAuthorizationStore,
            bstrApplicationName: BSTR,
            varReserved: VARIANT,
            ppApplication: ?*?*IAzApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteApplication: fn(
            self: *const IAzAuthorizationStore,
            bstrApplicationName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationGroups: fn(
            self: *const IAzAuthorizationStore,
            ppGroupCollection: ?*?*IAzApplicationGroups,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationGroup: fn(
            self: *const IAzAuthorizationStore,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenApplicationGroup: fn(
            self: *const IAzAuthorizationStore,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteApplicationGroup: fn(
            self: *const IAzAuthorizationStore,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzAuthorizationStore,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DelegatedPolicyUsers: fn(
            self: *const IAzAuthorizationStore,
            pvarDelegatedPolicyUsers: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDelegatedPolicyUser: fn(
            self: *const IAzAuthorizationStore,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDelegatedPolicyUser: fn(
            self: *const IAzAuthorizationStore,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetMachine: fn(
            self: *const IAzAuthorizationStore,
            pbstrTargetMachine: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplyStoreSacl: fn(
            self: *const IAzAuthorizationStore,
            pbApplyStoreSacl: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplyStoreSacl: fn(
            self: *const IAzAuthorizationStore,
            bApplyStoreSacl: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministratorsName: fn(
            self: *const IAzAuthorizationStore,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReadersName: fn(
            self: *const IAzAuthorizationStore,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministratorName: fn(
            self: *const IAzAuthorizationStore,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministratorName: fn(
            self: *const IAzAuthorizationStore,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReaderName: fn(
            self: *const IAzAuthorizationStore,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReaderName: fn(
            self: *const IAzAuthorizationStore,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DelegatedPolicyUsersName: fn(
            self: *const IAzAuthorizationStore,
            pvarDelegatedPolicyUsers: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDelegatedPolicyUserName: fn(
            self: *const IAzAuthorizationStore,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDelegatedPolicyUserName: fn(
            self: *const IAzAuthorizationStore,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseApplication: fn(
            self: *const IAzAuthorizationStore,
            bstrApplicationName: BSTR,
            lFlag: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_Description(@ptrCast(*const IAzAuthorizationStore, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_Description(@ptrCast(*const IAzAuthorizationStore, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzAuthorizationStore, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzAuthorizationStore, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_DomainTimeout(self: *const T, plProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_DomainTimeout(@ptrCast(*const IAzAuthorizationStore, self), plProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_DomainTimeout(self: *const T, lProp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_DomainTimeout(@ptrCast(*const IAzAuthorizationStore, self), lProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_ScriptEngineTimeout(self: *const T, plProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_ScriptEngineTimeout(@ptrCast(*const IAzAuthorizationStore, self), plProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_ScriptEngineTimeout(self: *const T, lProp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_ScriptEngineTimeout(@ptrCast(*const IAzAuthorizationStore, self), lProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_MaxScriptEngines(self: *const T, plProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_MaxScriptEngines(@ptrCast(*const IAzAuthorizationStore, self), plProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_MaxScriptEngines(self: *const T, lProp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_MaxScriptEngines(@ptrCast(*const IAzAuthorizationStore, self), lProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_GenerateAudits(self: *const T, pbProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_GenerateAudits(@ptrCast(*const IAzAuthorizationStore, self), pbProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_GenerateAudits(self: *const T, bProp: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_GenerateAudits(@ptrCast(*const IAzAuthorizationStore, self), bProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_Writable(@ptrCast(*const IAzAuthorizationStore, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).GetProperty(@ptrCast(*const IAzAuthorizationStore, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).SetProperty(@ptrCast(*const IAzAuthorizationStore, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddPropertyItem(self: *const T, lPropId: AZ_PROP_CONSTANTS, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzAuthorizationStore, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzAuthorizationStore, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_PolicyAdministrators(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_PolicyAdministrators(@ptrCast(*const IAzAuthorizationStore, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_PolicyReaders(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_PolicyReaders(@ptrCast(*const IAzAuthorizationStore, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddPolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddPolicyAdministrator(@ptrCast(*const IAzAuthorizationStore, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeletePolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeletePolicyAdministrator(@ptrCast(*const IAzAuthorizationStore, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddPolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddPolicyReader(@ptrCast(*const IAzAuthorizationStore, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeletePolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeletePolicyReader(@ptrCast(*const IAzAuthorizationStore, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_Initialize(self: *const T, lFlags: AZ_PROP_CONSTANTS, bstrPolicyURL: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).Initialize(@ptrCast(*const IAzAuthorizationStore, self), lFlags, bstrPolicyURL, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_UpdateCache(self: *const T, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).UpdateCache(@ptrCast(*const IAzAuthorizationStore, self), varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_Delete(self: *const T, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).Delete(@ptrCast(*const IAzAuthorizationStore, self), varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_Applications(self: *const T, ppAppCollection: ?*?*IAzApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_Applications(@ptrCast(*const IAzAuthorizationStore, self), ppAppCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_OpenApplication(self: *const T, bstrApplicationName: BSTR, varReserved: VARIANT, ppApplication: ?*?*IAzApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).OpenApplication(@ptrCast(*const IAzAuthorizationStore, self), bstrApplicationName, varReserved, ppApplication);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_CreateApplication(self: *const T, bstrApplicationName: BSTR, varReserved: VARIANT, ppApplication: ?*?*IAzApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).CreateApplication(@ptrCast(*const IAzAuthorizationStore, self), bstrApplicationName, varReserved, ppApplication);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeleteApplication(self: *const T, bstrApplicationName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeleteApplication(@ptrCast(*const IAzAuthorizationStore, self), bstrApplicationName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_ApplicationGroups(self: *const T, ppGroupCollection: ?*?*IAzApplicationGroups) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_ApplicationGroups(@ptrCast(*const IAzAuthorizationStore, self), ppGroupCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_CreateApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).CreateApplicationGroup(@ptrCast(*const IAzAuthorizationStore, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_OpenApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).OpenApplicationGroup(@ptrCast(*const IAzAuthorizationStore, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeleteApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeleteApplicationGroup(@ptrCast(*const IAzAuthorizationStore, self), bstrGroupName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).Submit(@ptrCast(*const IAzAuthorizationStore, self), lFlags, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_DelegatedPolicyUsers(self: *const T, pvarDelegatedPolicyUsers: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_DelegatedPolicyUsers(@ptrCast(*const IAzAuthorizationStore, self), pvarDelegatedPolicyUsers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddDelegatedPolicyUser(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddDelegatedPolicyUser(@ptrCast(*const IAzAuthorizationStore, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeleteDelegatedPolicyUser(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeleteDelegatedPolicyUser(@ptrCast(*const IAzAuthorizationStore, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_TargetMachine(self: *const T, pbstrTargetMachine: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_TargetMachine(@ptrCast(*const IAzAuthorizationStore, self), pbstrTargetMachine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_ApplyStoreSacl(self: *const T, pbApplyStoreSacl: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_ApplyStoreSacl(@ptrCast(*const IAzAuthorizationStore, self), pbApplyStoreSacl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_put_ApplyStoreSacl(self: *const T, bApplyStoreSacl: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).put_ApplyStoreSacl(@ptrCast(*const IAzAuthorizationStore, self), bApplyStoreSacl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_PolicyAdministratorsName(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_PolicyAdministratorsName(@ptrCast(*const IAzAuthorizationStore, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_PolicyReadersName(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_PolicyReadersName(@ptrCast(*const IAzAuthorizationStore, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddPolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddPolicyAdministratorName(@ptrCast(*const IAzAuthorizationStore, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeletePolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeletePolicyAdministratorName(@ptrCast(*const IAzAuthorizationStore, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddPolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddPolicyReaderName(@ptrCast(*const IAzAuthorizationStore, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeletePolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeletePolicyReaderName(@ptrCast(*const IAzAuthorizationStore, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_get_DelegatedPolicyUsersName(self: *const T, pvarDelegatedPolicyUsers: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).get_DelegatedPolicyUsersName(@ptrCast(*const IAzAuthorizationStore, self), pvarDelegatedPolicyUsers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_AddDelegatedPolicyUserName(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).AddDelegatedPolicyUserName(@ptrCast(*const IAzAuthorizationStore, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_DeleteDelegatedPolicyUserName(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).DeleteDelegatedPolicyUserName(@ptrCast(*const IAzAuthorizationStore, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore_CloseApplication(self: *const T, bstrApplicationName: BSTR, lFlag: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore.VTable, self.vtable).CloseApplication(@ptrCast(*const IAzAuthorizationStore, self), bstrApplicationName, lFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IAzAuthorizationStore2_Value = @import("../zig.zig").Guid.initString("b11e5584-d577-4273-b6c5-0973e0f8e80d");
pub const IID_IAzAuthorizationStore2 = &IID_IAzAuthorizationStore2_Value;
pub const IAzAuthorizationStore2 = extern struct {
    pub const VTable = extern struct {
        base: IAzAuthorizationStore.VTable,
        OpenApplication2: fn(
            self: *const IAzAuthorizationStore2,
            bstrApplicationName: BSTR,
            varReserved: VARIANT,
            ppApplication: ?*?*IAzApplication2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplication2: fn(
            self: *const IAzAuthorizationStore2,
            bstrApplicationName: BSTR,
            varReserved: VARIANT,
            ppApplication: ?*?*IAzApplication2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzAuthorizationStore.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore2_OpenApplication2(self: *const T, bstrApplicationName: BSTR, varReserved: VARIANT, ppApplication: ?*?*IAzApplication2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore2.VTable, self.vtable).OpenApplication2(@ptrCast(*const IAzAuthorizationStore2, self), bstrApplicationName, varReserved, ppApplication);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore2_CreateApplication2(self: *const T, bstrApplicationName: BSTR, varReserved: VARIANT, ppApplication: ?*?*IAzApplication2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore2.VTable, self.vtable).CreateApplication2(@ptrCast(*const IAzAuthorizationStore2, self), bstrApplicationName, varReserved, ppApplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzAuthorizationStore3_Value = @import("../zig.zig").Guid.initString("abc08425-0c86-4fa0-9be3-7189956c926e");
pub const IID_IAzAuthorizationStore3 = &IID_IAzAuthorizationStore3_Value;
pub const IAzAuthorizationStore3 = extern struct {
    pub const VTable = extern struct {
        base: IAzAuthorizationStore2.VTable,
        IsUpdateNeeded: fn(
            self: *const IAzAuthorizationStore3,
            pbIsUpdateNeeded: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BizruleGroupSupported: fn(
            self: *const IAzAuthorizationStore3,
            pbSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpgradeStoresFunctionalLevel: fn(
            self: *const IAzAuthorizationStore3,
            lFunctionalLevel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFunctionalLevelUpgradeSupported: fn(
            self: *const IAzAuthorizationStore3,
            lFunctionalLevel: i32,
            pbSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemaVersion: fn(
            self: *const IAzAuthorizationStore3,
            plMajorVersion: *i32,
            plMinorVersion: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzAuthorizationStore2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore3_IsUpdateNeeded(self: *const T, pbIsUpdateNeeded: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore3.VTable, self.vtable).IsUpdateNeeded(@ptrCast(*const IAzAuthorizationStore3, self), pbIsUpdateNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore3_BizruleGroupSupported(self: *const T, pbSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore3.VTable, self.vtable).BizruleGroupSupported(@ptrCast(*const IAzAuthorizationStore3, self), pbSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore3_UpgradeStoresFunctionalLevel(self: *const T, lFunctionalLevel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore3.VTable, self.vtable).UpgradeStoresFunctionalLevel(@ptrCast(*const IAzAuthorizationStore3, self), lFunctionalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore3_IsFunctionalLevelUpgradeSupported(self: *const T, lFunctionalLevel: i32, pbSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore3.VTable, self.vtable).IsFunctionalLevelUpgradeSupported(@ptrCast(*const IAzAuthorizationStore3, self), lFunctionalLevel, pbSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzAuthorizationStore3_GetSchemaVersion(self: *const T, plMajorVersion: *i32, plMinorVersion: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzAuthorizationStore3.VTable, self.vtable).GetSchemaVersion(@ptrCast(*const IAzAuthorizationStore3, self), plMajorVersion, plMinorVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplication_Value = @import("../zig.zig").Guid.initString("987bc7c7-b813-4d27-bede-6ba5ae867e95");
pub const IID_IAzApplication = &IID_IAzApplication_Value;
pub const IAzApplication = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzApplication,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzApplication,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzApplication,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzApplication,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzApplication,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzApplication,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthzInterfaceClsid: fn(
            self: *const IAzApplication,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AuthzInterfaceClsid: fn(
            self: *const IAzApplication,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IAzApplication,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Version: fn(
            self: *const IAzApplication,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenerateAudits: fn(
            self: *const IAzApplication,
            pbProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GenerateAudits: fn(
            self: *const IAzApplication,
            bProp: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplyStoreSacl: fn(
            self: *const IAzApplication,
            pbProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplyStoreSacl: fn(
            self: *const IAzApplication,
            bProp: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzApplication,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzApplication,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzApplication,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministrators: fn(
            self: *const IAzApplication,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReaders: fn(
            self: *const IAzApplication,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministrator: fn(
            self: *const IAzApplication,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministrator: fn(
            self: *const IAzApplication,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReader: fn(
            self: *const IAzApplication,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReader: fn(
            self: *const IAzApplication,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scopes: fn(
            self: *const IAzApplication,
            ppScopeCollection: ?*?*IAzScopes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenScope: fn(
            self: *const IAzApplication,
            bstrScopeName: BSTR,
            varReserved: VARIANT,
            ppScope: ?*?*IAzScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateScope: fn(
            self: *const IAzApplication,
            bstrScopeName: BSTR,
            varReserved: VARIANT,
            ppScope: ?*?*IAzScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteScope: fn(
            self: *const IAzApplication,
            bstrScopeName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operations: fn(
            self: *const IAzApplication,
            ppOperationCollection: ?*?*IAzOperations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenOperation: fn(
            self: *const IAzApplication,
            bstrOperationName: BSTR,
            varReserved: VARIANT,
            ppOperation: ?*?*IAzOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOperation: fn(
            self: *const IAzApplication,
            bstrOperationName: BSTR,
            varReserved: VARIANT,
            ppOperation: ?*?*IAzOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteOperation: fn(
            self: *const IAzApplication,
            bstrOperationName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tasks: fn(
            self: *const IAzApplication,
            ppTaskCollection: ?*?*IAzTasks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenTask: fn(
            self: *const IAzApplication,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
            ppTask: ?*?*IAzTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTask: fn(
            self: *const IAzApplication,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
            ppTask: ?*?*IAzTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTask: fn(
            self: *const IAzApplication,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationGroups: fn(
            self: *const IAzApplication,
            ppGroupCollection: ?*?*IAzApplicationGroups,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenApplicationGroup: fn(
            self: *const IAzApplication,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationGroup: fn(
            self: *const IAzApplication,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteApplicationGroup: fn(
            self: *const IAzApplication,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Roles: fn(
            self: *const IAzApplication,
            ppRoleCollection: ?*?*IAzRoles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRole: fn(
            self: *const IAzApplication,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
            ppRole: ?*?*IAzRole,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRole: fn(
            self: *const IAzApplication,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
            ppRole: ?*?*IAzRole,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRole: fn(
            self: *const IAzApplication,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeClientContextFromToken: fn(
            self: *const IAzApplication,
            ullTokenHandle: u64,
            varReserved: VARIANT,
            ppClientContext: ?*?*IAzClientContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzApplication,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzApplication,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzApplication,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeClientContextFromName: fn(
            self: *const IAzApplication,
            ClientName: BSTR,
            DomainName: BSTR,
            varReserved: VARIANT,
            ppClientContext: ?*?*IAzClientContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DelegatedPolicyUsers: fn(
            self: *const IAzApplication,
            pvarDelegatedPolicyUsers: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDelegatedPolicyUser: fn(
            self: *const IAzApplication,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDelegatedPolicyUser: fn(
            self: *const IAzApplication,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeClientContextFromStringSid: fn(
            self: *const IAzApplication,
            SidString: BSTR,
            lOptions: i32,
            varReserved: VARIANT,
            ppClientContext: ?*?*IAzClientContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministratorsName: fn(
            self: *const IAzApplication,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReadersName: fn(
            self: *const IAzApplication,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministratorName: fn(
            self: *const IAzApplication,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministratorName: fn(
            self: *const IAzApplication,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReaderName: fn(
            self: *const IAzApplication,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReaderName: fn(
            self: *const IAzApplication,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DelegatedPolicyUsersName: fn(
            self: *const IAzApplication,
            pvarDelegatedPolicyUsers: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDelegatedPolicyUserName: fn(
            self: *const IAzApplication,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDelegatedPolicyUserName: fn(
            self: *const IAzApplication,
            bstrDelegatedPolicyUser: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Name(@ptrCast(*const IAzApplication, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_Name(@ptrCast(*const IAzApplication, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Description(@ptrCast(*const IAzApplication, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_Description(@ptrCast(*const IAzApplication, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzApplication, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzApplication, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_AuthzInterfaceClsid(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_AuthzInterfaceClsid(@ptrCast(*const IAzApplication, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_AuthzInterfaceClsid(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_AuthzInterfaceClsid(@ptrCast(*const IAzApplication, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Version(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Version(@ptrCast(*const IAzApplication, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_Version(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_Version(@ptrCast(*const IAzApplication, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_GenerateAudits(self: *const T, pbProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_GenerateAudits(@ptrCast(*const IAzApplication, self), pbProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_GenerateAudits(self: *const T, bProp: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_GenerateAudits(@ptrCast(*const IAzApplication, self), bProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_ApplyStoreSacl(self: *const T, pbProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_ApplyStoreSacl(@ptrCast(*const IAzApplication, self), pbProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_put_ApplyStoreSacl(self: *const T, bProp: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).put_ApplyStoreSacl(@ptrCast(*const IAzApplication, self), bProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Writable(@ptrCast(*const IAzApplication, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).GetProperty(@ptrCast(*const IAzApplication, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).SetProperty(@ptrCast(*const IAzApplication, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_PolicyAdministrators(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_PolicyAdministrators(@ptrCast(*const IAzApplication, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_PolicyReaders(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_PolicyReaders(@ptrCast(*const IAzApplication, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddPolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddPolicyAdministrator(@ptrCast(*const IAzApplication, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeletePolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeletePolicyAdministrator(@ptrCast(*const IAzApplication, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddPolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddPolicyReader(@ptrCast(*const IAzApplication, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeletePolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeletePolicyReader(@ptrCast(*const IAzApplication, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Scopes(self: *const T, ppScopeCollection: ?*?*IAzScopes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Scopes(@ptrCast(*const IAzApplication, self), ppScopeCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_OpenScope(self: *const T, bstrScopeName: BSTR, varReserved: VARIANT, ppScope: ?*?*IAzScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).OpenScope(@ptrCast(*const IAzApplication, self), bstrScopeName, varReserved, ppScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_CreateScope(self: *const T, bstrScopeName: BSTR, varReserved: VARIANT, ppScope: ?*?*IAzScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).CreateScope(@ptrCast(*const IAzApplication, self), bstrScopeName, varReserved, ppScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteScope(self: *const T, bstrScopeName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteScope(@ptrCast(*const IAzApplication, self), bstrScopeName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Operations(self: *const T, ppOperationCollection: ?*?*IAzOperations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Operations(@ptrCast(*const IAzApplication, self), ppOperationCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_OpenOperation(self: *const T, bstrOperationName: BSTR, varReserved: VARIANT, ppOperation: ?*?*IAzOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).OpenOperation(@ptrCast(*const IAzApplication, self), bstrOperationName, varReserved, ppOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_CreateOperation(self: *const T, bstrOperationName: BSTR, varReserved: VARIANT, ppOperation: ?*?*IAzOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).CreateOperation(@ptrCast(*const IAzApplication, self), bstrOperationName, varReserved, ppOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteOperation(self: *const T, bstrOperationName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteOperation(@ptrCast(*const IAzApplication, self), bstrOperationName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Tasks(self: *const T, ppTaskCollection: ?*?*IAzTasks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Tasks(@ptrCast(*const IAzApplication, self), ppTaskCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_OpenTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT, ppTask: ?*?*IAzTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).OpenTask(@ptrCast(*const IAzApplication, self), bstrTaskName, varReserved, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_CreateTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT, ppTask: ?*?*IAzTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).CreateTask(@ptrCast(*const IAzApplication, self), bstrTaskName, varReserved, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteTask(@ptrCast(*const IAzApplication, self), bstrTaskName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_ApplicationGroups(self: *const T, ppGroupCollection: ?*?*IAzApplicationGroups) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_ApplicationGroups(@ptrCast(*const IAzApplication, self), ppGroupCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_OpenApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).OpenApplicationGroup(@ptrCast(*const IAzApplication, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_CreateApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).CreateApplicationGroup(@ptrCast(*const IAzApplication, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteApplicationGroup(@ptrCast(*const IAzApplication, self), bstrGroupName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_Roles(self: *const T, ppRoleCollection: ?*?*IAzRoles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_Roles(@ptrCast(*const IAzApplication, self), ppRoleCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_OpenRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT, ppRole: ?*?*IAzRole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).OpenRole(@ptrCast(*const IAzApplication, self), bstrRoleName, varReserved, ppRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_CreateRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT, ppRole: ?*?*IAzRole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).CreateRole(@ptrCast(*const IAzApplication, self), bstrRoleName, varReserved, ppRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteRole(@ptrCast(*const IAzApplication, self), bstrRoleName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_InitializeClientContextFromToken(self: *const T, ullTokenHandle: u64, varReserved: VARIANT, ppClientContext: ?*?*IAzClientContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).InitializeClientContextFromToken(@ptrCast(*const IAzApplication, self), ullTokenHandle, varReserved, ppClientContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddPropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzApplication, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzApplication, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).Submit(@ptrCast(*const IAzApplication, self), lFlags, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_InitializeClientContextFromName(self: *const T, ClientName: BSTR, DomainName: BSTR, varReserved: VARIANT, ppClientContext: ?*?*IAzClientContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).InitializeClientContextFromName(@ptrCast(*const IAzApplication, self), ClientName, DomainName, varReserved, ppClientContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_DelegatedPolicyUsers(self: *const T, pvarDelegatedPolicyUsers: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_DelegatedPolicyUsers(@ptrCast(*const IAzApplication, self), pvarDelegatedPolicyUsers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddDelegatedPolicyUser(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddDelegatedPolicyUser(@ptrCast(*const IAzApplication, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteDelegatedPolicyUser(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteDelegatedPolicyUser(@ptrCast(*const IAzApplication, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_InitializeClientContextFromStringSid(self: *const T, SidString: BSTR, lOptions: i32, varReserved: VARIANT, ppClientContext: ?*?*IAzClientContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).InitializeClientContextFromStringSid(@ptrCast(*const IAzApplication, self), SidString, lOptions, varReserved, ppClientContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_PolicyAdministratorsName(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_PolicyAdministratorsName(@ptrCast(*const IAzApplication, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_PolicyReadersName(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_PolicyReadersName(@ptrCast(*const IAzApplication, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddPolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddPolicyAdministratorName(@ptrCast(*const IAzApplication, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeletePolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeletePolicyAdministratorName(@ptrCast(*const IAzApplication, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddPolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddPolicyReaderName(@ptrCast(*const IAzApplication, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeletePolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeletePolicyReaderName(@ptrCast(*const IAzApplication, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_get_DelegatedPolicyUsersName(self: *const T, pvarDelegatedPolicyUsers: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).get_DelegatedPolicyUsersName(@ptrCast(*const IAzApplication, self), pvarDelegatedPolicyUsers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_AddDelegatedPolicyUserName(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).AddDelegatedPolicyUserName(@ptrCast(*const IAzApplication, self), bstrDelegatedPolicyUser, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication_DeleteDelegatedPolicyUserName(self: *const T, bstrDelegatedPolicyUser: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication.VTable, self.vtable).DeleteDelegatedPolicyUserName(@ptrCast(*const IAzApplication, self), bstrDelegatedPolicyUser, varReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplication2_Value = @import("../zig.zig").Guid.initString("086a68af-a249-437c-b18d-d4d86d6a9660");
pub const IID_IAzApplication2 = &IID_IAzApplication2_Value;
pub const IAzApplication2 = extern struct {
    pub const VTable = extern struct {
        base: IAzApplication.VTable,
        InitializeClientContextFromToken2: fn(
            self: *const IAzApplication2,
            ulTokenHandleLowPart: u32,
            ulTokenHandleHighPart: u32,
            varReserved: VARIANT,
            ppClientContext: ?*?*IAzClientContext2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeClientContext2: fn(
            self: *const IAzApplication2,
            IdentifyingString: BSTR,
            varReserved: VARIANT,
            ppClientContext: ?*?*IAzClientContext2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication2_InitializeClientContextFromToken2(self: *const T, ulTokenHandleLowPart: u32, ulTokenHandleHighPart: u32, varReserved: VARIANT, ppClientContext: ?*?*IAzClientContext2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication2.VTable, self.vtable).InitializeClientContextFromToken2(@ptrCast(*const IAzApplication2, self), ulTokenHandleLowPart, ulTokenHandleHighPart, varReserved, ppClientContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication2_InitializeClientContext2(self: *const T, IdentifyingString: BSTR, varReserved: VARIANT, ppClientContext: ?*?*IAzClientContext2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication2.VTable, self.vtable).InitializeClientContext2(@ptrCast(*const IAzApplication2, self), IdentifyingString, varReserved, ppClientContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplications_Value = @import("../zig.zig").Guid.initString("929b11a9-95c5-4a84-a29a-20ad42c2f16c");
pub const IID_IAzApplications = &IID_IAzApplications_Value;
pub const IAzApplications = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzApplications,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzApplications,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzApplications,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplications_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplications.VTable, self.vtable).get_Item(@ptrCast(*const IAzApplications, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplications_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplications.VTable, self.vtable).get_Count(@ptrCast(*const IAzApplications, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplications_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplications.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzApplications, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzOperation_Value = @import("../zig.zig").Guid.initString("5e56b24f-ea01-4d61-be44-c49b5e4eaf74");
pub const IID_IAzOperation = &IID_IAzOperation_Value;
pub const IAzOperation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzOperation,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzOperation,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzOperation,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzOperation,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzOperation,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzOperation,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OperationID: fn(
            self: *const IAzOperation,
            plProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OperationID: fn(
            self: *const IAzOperation,
            lProp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzOperation,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzOperation,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzOperation,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzOperation,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).get_Name(@ptrCast(*const IAzOperation, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).put_Name(@ptrCast(*const IAzOperation, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).get_Description(@ptrCast(*const IAzOperation, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).put_Description(@ptrCast(*const IAzOperation, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzOperation, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzOperation, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_get_OperationID(self: *const T, plProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).get_OperationID(@ptrCast(*const IAzOperation, self), plProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_put_OperationID(self: *const T, lProp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).put_OperationID(@ptrCast(*const IAzOperation, self), lProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).get_Writable(@ptrCast(*const IAzOperation, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).GetProperty(@ptrCast(*const IAzOperation, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).SetProperty(@ptrCast(*const IAzOperation, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation.VTable, self.vtable).Submit(@ptrCast(*const IAzOperation, self), lFlags, varReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzOperations_Value = @import("../zig.zig").Guid.initString("90ef9c07-9706-49d9-af80-0438a5f3ec35");
pub const IID_IAzOperations = &IID_IAzOperations_Value;
pub const IAzOperations = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzOperations,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzOperations,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzOperations,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperations_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperations.VTable, self.vtable).get_Item(@ptrCast(*const IAzOperations, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperations_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperations.VTable, self.vtable).get_Count(@ptrCast(*const IAzOperations, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperations_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperations.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzOperations, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzTask_Value = @import("../zig.zig").Guid.initString("cb94e592-2e0e-4a6c-a336-b89a6dc1e388");
pub const IID_IAzTask = &IID_IAzTask_Value;
pub const IAzTask = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzTask,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzTask,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzTask,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzTask,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzTask,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzTask,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRule: fn(
            self: *const IAzTask,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRule: fn(
            self: *const IAzTask,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleLanguage: fn(
            self: *const IAzTask,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRuleLanguage: fn(
            self: *const IAzTask,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleImportedPath: fn(
            self: *const IAzTask,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRuleImportedPath: fn(
            self: *const IAzTask,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRoleDefinition: fn(
            self: *const IAzTask,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsRoleDefinition: fn(
            self: *const IAzTask,
            fProp: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operations: fn(
            self: *const IAzTask,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tasks: fn(
            self: *const IAzTask,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOperation: fn(
            self: *const IAzTask,
            bstrOp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteOperation: fn(
            self: *const IAzTask,
            bstrOp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTask: fn(
            self: *const IAzTask,
            bstrTask: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTask: fn(
            self: *const IAzTask,
            bstrTask: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzTask,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzTask,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzTask,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzTask,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzTask,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzTask,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_Name(@ptrCast(*const IAzTask, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_Name(@ptrCast(*const IAzTask, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_Description(@ptrCast(*const IAzTask, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_Description(@ptrCast(*const IAzTask, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzTask, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzTask, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_BizRule(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_BizRule(@ptrCast(*const IAzTask, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_BizRule(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_BizRule(@ptrCast(*const IAzTask, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_BizRuleLanguage(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_BizRuleLanguage(@ptrCast(*const IAzTask, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_BizRuleLanguage(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_BizRuleLanguage(@ptrCast(*const IAzTask, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_BizRuleImportedPath(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_BizRuleImportedPath(@ptrCast(*const IAzTask, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_BizRuleImportedPath(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_BizRuleImportedPath(@ptrCast(*const IAzTask, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_IsRoleDefinition(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_IsRoleDefinition(@ptrCast(*const IAzTask, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_put_IsRoleDefinition(self: *const T, fProp: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).put_IsRoleDefinition(@ptrCast(*const IAzTask, self), fProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_Operations(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_Operations(@ptrCast(*const IAzTask, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_Tasks(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_Tasks(@ptrCast(*const IAzTask, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_AddOperation(self: *const T, bstrOp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).AddOperation(@ptrCast(*const IAzTask, self), bstrOp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_DeleteOperation(self: *const T, bstrOp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).DeleteOperation(@ptrCast(*const IAzTask, self), bstrOp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_AddTask(self: *const T, bstrTask: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).AddTask(@ptrCast(*const IAzTask, self), bstrTask, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_DeleteTask(self: *const T, bstrTask: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).DeleteTask(@ptrCast(*const IAzTask, self), bstrTask, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).get_Writable(@ptrCast(*const IAzTask, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).GetProperty(@ptrCast(*const IAzTask, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).SetProperty(@ptrCast(*const IAzTask, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_AddPropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzTask, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzTask, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask.VTable, self.vtable).Submit(@ptrCast(*const IAzTask, self), lFlags, varReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzTasks_Value = @import("../zig.zig").Guid.initString("b338ccab-4c85-4388-8c0a-c58592bad398");
pub const IID_IAzTasks = &IID_IAzTasks_Value;
pub const IAzTasks = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzTasks,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzTasks,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzTasks,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTasks_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTasks.VTable, self.vtable).get_Item(@ptrCast(*const IAzTasks, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTasks_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTasks.VTable, self.vtable).get_Count(@ptrCast(*const IAzTasks, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTasks_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTasks.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzTasks, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzScope_Value = @import("../zig.zig").Guid.initString("00e52487-e08d-4514-b62e-877d5645f5ab");
pub const IID_IAzScope = &IID_IAzScope_Value;
pub const IAzScope = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzScope,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzScope,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzScope,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzScope,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzScope,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzScope,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzScope,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzScope,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzScope,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzScope,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzScope,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministrators: fn(
            self: *const IAzScope,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReaders: fn(
            self: *const IAzScope,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministrator: fn(
            self: *const IAzScope,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministrator: fn(
            self: *const IAzScope,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReader: fn(
            self: *const IAzScope,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReader: fn(
            self: *const IAzScope,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationGroups: fn(
            self: *const IAzScope,
            ppGroupCollection: ?*?*IAzApplicationGroups,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenApplicationGroup: fn(
            self: *const IAzScope,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationGroup: fn(
            self: *const IAzScope,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
            ppGroup: ?*?*IAzApplicationGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteApplicationGroup: fn(
            self: *const IAzScope,
            bstrGroupName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Roles: fn(
            self: *const IAzScope,
            ppRoleCollection: ?*?*IAzRoles,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRole: fn(
            self: *const IAzScope,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
            ppRole: ?*?*IAzRole,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRole: fn(
            self: *const IAzScope,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
            ppRole: ?*?*IAzRole,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRole: fn(
            self: *const IAzScope,
            bstrRoleName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tasks: fn(
            self: *const IAzScope,
            ppTaskCollection: ?*?*IAzTasks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenTask: fn(
            self: *const IAzScope,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
            ppTask: ?*?*IAzTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTask: fn(
            self: *const IAzScope,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
            ppTask: ?*?*IAzTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTask: fn(
            self: *const IAzScope,
            bstrTaskName: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzScope,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanBeDelegated: fn(
            self: *const IAzScope,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizrulesWritable: fn(
            self: *const IAzScope,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyAdministratorsName: fn(
            self: *const IAzScope,
            pvarAdmins: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyReadersName: fn(
            self: *const IAzScope,
            pvarReaders: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyAdministratorName: fn(
            self: *const IAzScope,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyAdministratorName: fn(
            self: *const IAzScope,
            bstrAdmin: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPolicyReaderName: fn(
            self: *const IAzScope,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePolicyReaderName: fn(
            self: *const IAzScope,
            bstrReader: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_Name(@ptrCast(*const IAzScope, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).put_Name(@ptrCast(*const IAzScope, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_Description(@ptrCast(*const IAzScope, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).put_Description(@ptrCast(*const IAzScope, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzScope, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzScope, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_Writable(@ptrCast(*const IAzScope, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).GetProperty(@ptrCast(*const IAzScope, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).SetProperty(@ptrCast(*const IAzScope, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_AddPropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzScope, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzScope, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_PolicyAdministrators(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_PolicyAdministrators(@ptrCast(*const IAzScope, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_PolicyReaders(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_PolicyReaders(@ptrCast(*const IAzScope, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_AddPolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).AddPolicyAdministrator(@ptrCast(*const IAzScope, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeletePolicyAdministrator(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeletePolicyAdministrator(@ptrCast(*const IAzScope, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_AddPolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).AddPolicyReader(@ptrCast(*const IAzScope, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeletePolicyReader(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeletePolicyReader(@ptrCast(*const IAzScope, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_ApplicationGroups(self: *const T, ppGroupCollection: ?*?*IAzApplicationGroups) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_ApplicationGroups(@ptrCast(*const IAzScope, self), ppGroupCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_OpenApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).OpenApplicationGroup(@ptrCast(*const IAzScope, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_CreateApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT, ppGroup: ?*?*IAzApplicationGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).CreateApplicationGroup(@ptrCast(*const IAzScope, self), bstrGroupName, varReserved, ppGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeleteApplicationGroup(self: *const T, bstrGroupName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeleteApplicationGroup(@ptrCast(*const IAzScope, self), bstrGroupName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_Roles(self: *const T, ppRoleCollection: ?*?*IAzRoles) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_Roles(@ptrCast(*const IAzScope, self), ppRoleCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_OpenRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT, ppRole: ?*?*IAzRole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).OpenRole(@ptrCast(*const IAzScope, self), bstrRoleName, varReserved, ppRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_CreateRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT, ppRole: ?*?*IAzRole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).CreateRole(@ptrCast(*const IAzScope, self), bstrRoleName, varReserved, ppRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeleteRole(self: *const T, bstrRoleName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeleteRole(@ptrCast(*const IAzScope, self), bstrRoleName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_Tasks(self: *const T, ppTaskCollection: ?*?*IAzTasks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_Tasks(@ptrCast(*const IAzScope, self), ppTaskCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_OpenTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT, ppTask: ?*?*IAzTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).OpenTask(@ptrCast(*const IAzScope, self), bstrTaskName, varReserved, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_CreateTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT, ppTask: ?*?*IAzTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).CreateTask(@ptrCast(*const IAzScope, self), bstrTaskName, varReserved, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeleteTask(self: *const T, bstrTaskName: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeleteTask(@ptrCast(*const IAzScope, self), bstrTaskName, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).Submit(@ptrCast(*const IAzScope, self), lFlags, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_CanBeDelegated(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_CanBeDelegated(@ptrCast(*const IAzScope, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_BizrulesWritable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_BizrulesWritable(@ptrCast(*const IAzScope, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_PolicyAdministratorsName(self: *const T, pvarAdmins: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_PolicyAdministratorsName(@ptrCast(*const IAzScope, self), pvarAdmins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_get_PolicyReadersName(self: *const T, pvarReaders: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).get_PolicyReadersName(@ptrCast(*const IAzScope, self), pvarReaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_AddPolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).AddPolicyAdministratorName(@ptrCast(*const IAzScope, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeletePolicyAdministratorName(self: *const T, bstrAdmin: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeletePolicyAdministratorName(@ptrCast(*const IAzScope, self), bstrAdmin, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_AddPolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).AddPolicyReaderName(@ptrCast(*const IAzScope, self), bstrReader, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope_DeletePolicyReaderName(self: *const T, bstrReader: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope.VTable, self.vtable).DeletePolicyReaderName(@ptrCast(*const IAzScope, self), bstrReader, varReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzScopes_Value = @import("../zig.zig").Guid.initString("78e14853-9f5e-406d-9b91-6bdba6973510");
pub const IID_IAzScopes = &IID_IAzScopes_Value;
pub const IAzScopes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzScopes,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzScopes,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzScopes,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScopes_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScopes.VTable, self.vtable).get_Item(@ptrCast(*const IAzScopes, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScopes_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScopes.VTable, self.vtable).get_Count(@ptrCast(*const IAzScopes, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScopes_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScopes.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzScopes, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplicationGroup_Value = @import("../zig.zig").Guid.initString("f1b744cd-58a6-4e06-9fbf-36f6d779e21e");
pub const IID_IAzApplicationGroup = &IID_IAzApplicationGroup_Value;
pub const IAzApplicationGroup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzApplicationGroup,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzApplicationGroup,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IAzApplicationGroup,
            plProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: fn(
            self: *const IAzApplicationGroup,
            lProp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LdapQuery: fn(
            self: *const IAzApplicationGroup,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LdapQuery: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppMembers: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppNonMembers: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Members: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonMembers: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzApplicationGroup,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzApplicationGroup,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAppMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAppMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAppNonMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAppNonMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNonMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteNonMember: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzApplicationGroup,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzApplicationGroup,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzApplicationGroup,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzApplicationGroup,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzApplicationGroup,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzApplicationGroup,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMemberName: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMemberName: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNonMemberName: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteNonMemberName: fn(
            self: *const IAzApplicationGroup,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MembersName: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonMembersName: fn(
            self: *const IAzApplicationGroup,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_Name(@ptrCast(*const IAzApplicationGroup, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).put_Name(@ptrCast(*const IAzApplicationGroup, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_Type(self: *const T, plProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_Type(@ptrCast(*const IAzApplicationGroup, self), plProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_put_Type(self: *const T, lProp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).put_Type(@ptrCast(*const IAzApplicationGroup, self), lProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_LdapQuery(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_LdapQuery(@ptrCast(*const IAzApplicationGroup, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_put_LdapQuery(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).put_LdapQuery(@ptrCast(*const IAzApplicationGroup, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_AppMembers(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_AppMembers(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_AppNonMembers(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_AppNonMembers(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_Members(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_Members(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_NonMembers(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_NonMembers(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_Description(@ptrCast(*const IAzApplicationGroup, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).put_Description(@ptrCast(*const IAzApplicationGroup, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddAppMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddAppMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteAppMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteAppMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddAppNonMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddAppNonMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteAppNonMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteAppNonMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddNonMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddNonMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteNonMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteNonMember(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_Writable(@ptrCast(*const IAzApplicationGroup, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).GetProperty(@ptrCast(*const IAzApplicationGroup, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).SetProperty(@ptrCast(*const IAzApplicationGroup, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddPropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzApplicationGroup, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzApplicationGroup, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).Submit(@ptrCast(*const IAzApplicationGroup, self), lFlags, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddMemberName(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteMemberName(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_AddNonMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).AddNonMemberName(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_DeleteNonMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).DeleteNonMemberName(@ptrCast(*const IAzApplicationGroup, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_MembersName(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_MembersName(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup_get_NonMembersName(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup.VTable, self.vtable).get_NonMembersName(@ptrCast(*const IAzApplicationGroup, self), pvarProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplicationGroups_Value = @import("../zig.zig").Guid.initString("4ce66ad5-9f3c-469d-a911-b99887a7e685");
pub const IID_IAzApplicationGroups = &IID_IAzApplicationGroups_Value;
pub const IAzApplicationGroups = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzApplicationGroups,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzApplicationGroups,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzApplicationGroups,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroups_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroups.VTable, self.vtable).get_Item(@ptrCast(*const IAzApplicationGroups, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroups_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroups.VTable, self.vtable).get_Count(@ptrCast(*const IAzApplicationGroups, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroups_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroups.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzApplicationGroups, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRole_Value = @import("../zig.zig").Guid.initString("859e0d8d-62d7-41d8-a034-c0cd5d43fdfa");
pub const IID_IAzRole = &IID_IAzRole_Value;
pub const IAzRole = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzRole,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IAzRole,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAzRole,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IAzRole,
            bstrDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationData: fn(
            self: *const IAzRole,
            pbstrApplicationData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationData: fn(
            self: *const IAzRole,
            bstrApplicationData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAppMember: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAppMember: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTask: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTask: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOperation: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteOperation: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMember: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMember: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Writable: fn(
            self: *const IAzRole,
            pfProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzRole,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IAzRole,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppMembers: fn(
            self: *const IAzRole,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Members: fn(
            self: *const IAzRole,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operations: fn(
            self: *const IAzRole,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tasks: fn(
            self: *const IAzRole,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyItem: fn(
            self: *const IAzRole,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyItem: fn(
            self: *const IAzRole,
            lPropId: i32,
            varProp: VARIANT,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Submit: fn(
            self: *const IAzRole,
            lFlags: i32,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMemberName: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMemberName: fn(
            self: *const IAzRole,
            bstrProp: BSTR,
            varReserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MembersName: fn(
            self: *const IAzRole,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Name(@ptrCast(*const IAzRole, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_put_Name(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).put_Name(@ptrCast(*const IAzRole, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Description(self: *const T, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Description(@ptrCast(*const IAzRole, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_put_Description(self: *const T, bstrDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).put_Description(@ptrCast(*const IAzRole, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_ApplicationData(self: *const T, pbstrApplicationData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_ApplicationData(@ptrCast(*const IAzRole, self), pbstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_put_ApplicationData(self: *const T, bstrApplicationData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).put_ApplicationData(@ptrCast(*const IAzRole, self), bstrApplicationData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddAppMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddAppMember(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeleteAppMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeleteAppMember(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddTask(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddTask(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeleteTask(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeleteTask(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddOperation(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddOperation(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeleteOperation(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeleteOperation(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddMember(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeleteMember(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeleteMember(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Writable(self: *const T, pfProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Writable(@ptrCast(*const IAzRole, self), pfProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).GetProperty(@ptrCast(*const IAzRole, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_SetProperty(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).SetProperty(@ptrCast(*const IAzRole, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_AppMembers(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_AppMembers(@ptrCast(*const IAzRole, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Members(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Members(@ptrCast(*const IAzRole, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Operations(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Operations(@ptrCast(*const IAzRole, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_Tasks(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_Tasks(@ptrCast(*const IAzRole, self), pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddPropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddPropertyItem(@ptrCast(*const IAzRole, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeletePropertyItem(self: *const T, lPropId: i32, varProp: VARIANT, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeletePropertyItem(@ptrCast(*const IAzRole, self), lPropId, varProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_Submit(self: *const T, lFlags: i32, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).Submit(@ptrCast(*const IAzRole, self), lFlags, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_AddMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).AddMemberName(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_DeleteMemberName(self: *const T, bstrProp: BSTR, varReserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).DeleteMemberName(@ptrCast(*const IAzRole, self), bstrProp, varReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRole_get_MembersName(self: *const T, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRole.VTable, self.vtable).get_MembersName(@ptrCast(*const IAzRole, self), pvarProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRoles_Value = @import("../zig.zig").Guid.initString("95e0f119-13b4-4dae-b65f-2f7d60d822e4");
pub const IID_IAzRoles = &IID_IAzRoles_Value;
pub const IAzRoles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzRoles,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzRoles,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzRoles,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoles_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoles.VTable, self.vtable).get_Item(@ptrCast(*const IAzRoles, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoles_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoles.VTable, self.vtable).get_Count(@ptrCast(*const IAzRoles, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoles_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoles.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzRoles, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzClientContext_Value = @import("../zig.zig").Guid.initString("eff1f00b-488a-466d-afd9-a401c5f9eef5");
pub const IID_IAzClientContext = &IID_IAzClientContext_Value;
pub const IAzClientContext = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AccessCheck: fn(
            self: *const IAzClientContext,
            bstrObjectName: BSTR,
            varScopeNames: VARIANT,
            varOperations: VARIANT,
            varParameterNames: VARIANT,
            varParameterValues: VARIANT,
            varInterfaceNames: VARIANT,
            varInterfaceFlags: VARIANT,
            varInterfaces: VARIANT,
            pvarResults: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBusinessRuleString: fn(
            self: *const IAzClientContext,
            pbstrBusinessRuleString: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserDn: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserSamCompat: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserDisplay: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserGuid: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserCanonical: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserUpn: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserDnsSamCompat: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAzClientContext,
            lPropId: i32,
            varReserved: VARIANT,
            pvarProp: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRoles: fn(
            self: *const IAzClientContext,
            bstrScopeName: BSTR,
            pvarRoleNames: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleForAccessCheck: fn(
            self: *const IAzClientContext,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RoleForAccessCheck: fn(
            self: *const IAzClientContext,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_AccessCheck(self: *const T, bstrObjectName: BSTR, varScopeNames: VARIANT, varOperations: VARIANT, varParameterNames: VARIANT, varParameterValues: VARIANT, varInterfaceNames: VARIANT, varInterfaceFlags: VARIANT, varInterfaces: VARIANT, pvarResults: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).AccessCheck(@ptrCast(*const IAzClientContext, self), bstrObjectName, varScopeNames, varOperations, varParameterNames, varParameterValues, varInterfaceNames, varInterfaceFlags, varInterfaces, pvarResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_GetBusinessRuleString(self: *const T, pbstrBusinessRuleString: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).GetBusinessRuleString(@ptrCast(*const IAzClientContext, self), pbstrBusinessRuleString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserDn(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserDn(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserSamCompat(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserSamCompat(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserDisplay(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserDisplay(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserGuid(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserGuid(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserCanonical(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserCanonical(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserUpn(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserUpn(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_UserDnsSamCompat(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_UserDnsSamCompat(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_GetProperty(self: *const T, lPropId: i32, varReserved: VARIANT, pvarProp: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).GetProperty(@ptrCast(*const IAzClientContext, self), lPropId, varReserved, pvarProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_GetRoles(self: *const T, bstrScopeName: BSTR, pvarRoleNames: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).GetRoles(@ptrCast(*const IAzClientContext, self), bstrScopeName, pvarRoleNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_get_RoleForAccessCheck(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).get_RoleForAccessCheck(@ptrCast(*const IAzClientContext, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext_put_RoleForAccessCheck(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext.VTable, self.vtable).put_RoleForAccessCheck(@ptrCast(*const IAzClientContext, self), bstrProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IAzClientContext2_Value = @import("../zig.zig").Guid.initString("2b0c92b8-208a-488a-8f81-e4edb22111cd");
pub const IID_IAzClientContext2 = &IID_IAzClientContext2_Value;
pub const IAzClientContext2 = extern struct {
    pub const VTable = extern struct {
        base: IAzClientContext.VTable,
        GetAssignedScopesPage: fn(
            self: *const IAzClientContext2,
            lOptions: i32,
            PageSize: i32,
            pvarCursor: *VARIANT,
            pvarScopeNames: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRoles: fn(
            self: *const IAzClientContext2,
            varRoles: VARIANT,
            bstrScopeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplicationGroups: fn(
            self: *const IAzClientContext2,
            varApplicationGroups: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStringSids: fn(
            self: *const IAzClientContext2,
            varStringSids: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LDAPQueryDN: fn(
            self: *const IAzClientContext2,
            bstrLDAPQueryDN: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LDAPQueryDN: fn(
            self: *const IAzClientContext2,
            pbstrLDAPQueryDN: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzClientContext.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_GetAssignedScopesPage(self: *const T, lOptions: i32, PageSize: i32, pvarCursor: *VARIANT, pvarScopeNames: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).GetAssignedScopesPage(@ptrCast(*const IAzClientContext2, self), lOptions, PageSize, pvarCursor, pvarScopeNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_AddRoles(self: *const T, varRoles: VARIANT, bstrScopeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).AddRoles(@ptrCast(*const IAzClientContext2, self), varRoles, bstrScopeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_AddApplicationGroups(self: *const T, varApplicationGroups: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).AddApplicationGroups(@ptrCast(*const IAzClientContext2, self), varApplicationGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_AddStringSids(self: *const T, varStringSids: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).AddStringSids(@ptrCast(*const IAzClientContext2, self), varStringSids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_put_LDAPQueryDN(self: *const T, bstrLDAPQueryDN: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).put_LDAPQueryDN(@ptrCast(*const IAzClientContext2, self), bstrLDAPQueryDN);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext2_get_LDAPQueryDN(self: *const T, pbstrLDAPQueryDN: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext2.VTable, self.vtable).get_LDAPQueryDN(@ptrCast(*const IAzClientContext2, self), pbstrLDAPQueryDN);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzBizRuleContext_Value = @import("../zig.zig").Guid.initString("e192f17d-d59f-455e-a152-940316cd77b2");
pub const IID_IAzBizRuleContext = &IID_IAzBizRuleContext_Value;
pub const IAzBizRuleContext = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BusinessRuleResult: fn(
            self: *const IAzBizRuleContext,
            bResult: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BusinessRuleString: fn(
            self: *const IAzBizRuleContext,
            bstrBusinessRuleString: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BusinessRuleString: fn(
            self: *const IAzBizRuleContext,
            pbstrBusinessRuleString: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: fn(
            self: *const IAzBizRuleContext,
            bstrParameterName: BSTR,
            pvarParameterValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleContext_put_BusinessRuleResult(self: *const T, bResult: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleContext.VTable, self.vtable).put_BusinessRuleResult(@ptrCast(*const IAzBizRuleContext, self), bResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleContext_put_BusinessRuleString(self: *const T, bstrBusinessRuleString: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleContext.VTable, self.vtable).put_BusinessRuleString(@ptrCast(*const IAzBizRuleContext, self), bstrBusinessRuleString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleContext_get_BusinessRuleString(self: *const T, pbstrBusinessRuleString: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleContext.VTable, self.vtable).get_BusinessRuleString(@ptrCast(*const IAzBizRuleContext, self), pbstrBusinessRuleString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleContext_GetParameter(self: *const T, bstrParameterName: BSTR, pvarParameterValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleContext.VTable, self.vtable).GetParameter(@ptrCast(*const IAzBizRuleContext, self), bstrParameterName, pvarParameterValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzBizRuleParameters_Value = @import("../zig.zig").Guid.initString("fc17685f-e25d-4dcd-bae1-276ec9533cb5");
pub const IID_IAzBizRuleParameters = &IID_IAzBizRuleParameters_Value;
pub const IAzBizRuleParameters = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddParameter: fn(
            self: *const IAzBizRuleParameters,
            bstrParameterName: BSTR,
            varParameterValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddParameters: fn(
            self: *const IAzBizRuleParameters,
            varParameterNames: VARIANT,
            varParameterValues: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterValue: fn(
            self: *const IAzBizRuleParameters,
            bstrParameterName: BSTR,
            pvarParameterValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IAzBizRuleParameters,
            varParameterName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: fn(
            self: *const IAzBizRuleParameters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzBizRuleParameters,
            plCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_AddParameter(self: *const T, bstrParameterName: BSTR, varParameterValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).AddParameter(@ptrCast(*const IAzBizRuleParameters, self), bstrParameterName, varParameterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_AddParameters(self: *const T, varParameterNames: VARIANT, varParameterValues: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).AddParameters(@ptrCast(*const IAzBizRuleParameters, self), varParameterNames, varParameterValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_GetParameterValue(self: *const T, bstrParameterName: BSTR, pvarParameterValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).GetParameterValue(@ptrCast(*const IAzBizRuleParameters, self), bstrParameterName, pvarParameterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_Remove(self: *const T, varParameterName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).Remove(@ptrCast(*const IAzBizRuleParameters, self), varParameterName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_RemoveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).RemoveAll(@ptrCast(*const IAzBizRuleParameters, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleParameters_get_Count(self: *const T, plCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleParameters.VTable, self.vtable).get_Count(@ptrCast(*const IAzBizRuleParameters, self), plCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzBizRuleInterfaces_Value = @import("../zig.zig").Guid.initString("e94128c7-e9da-44cc-b0bd-53036f3aab3d");
pub const IID_IAzBizRuleInterfaces = &IID_IAzBizRuleInterfaces_Value;
pub const IAzBizRuleInterfaces = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddInterface: fn(
            self: *const IAzBizRuleInterfaces,
            bstrInterfaceName: BSTR,
            lInterfaceFlag: i32,
            varInterface: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddInterfaces: fn(
            self: *const IAzBizRuleInterfaces,
            varInterfaceNames: VARIANT,
            varInterfaceFlags: VARIANT,
            varInterfaces: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterfaceValue: fn(
            self: *const IAzBizRuleInterfaces,
            bstrInterfaceName: BSTR,
            lInterfaceFlag: *i32,
            varInterface: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IAzBizRuleInterfaces,
            bstrInterfaceName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: fn(
            self: *const IAzBizRuleInterfaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzBizRuleInterfaces,
            plCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_AddInterface(self: *const T, bstrInterfaceName: BSTR, lInterfaceFlag: i32, varInterface: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).AddInterface(@ptrCast(*const IAzBizRuleInterfaces, self), bstrInterfaceName, lInterfaceFlag, varInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_AddInterfaces(self: *const T, varInterfaceNames: VARIANT, varInterfaceFlags: VARIANT, varInterfaces: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).AddInterfaces(@ptrCast(*const IAzBizRuleInterfaces, self), varInterfaceNames, varInterfaceFlags, varInterfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_GetInterfaceValue(self: *const T, bstrInterfaceName: BSTR, lInterfaceFlag: *i32, varInterface: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).GetInterfaceValue(@ptrCast(*const IAzBizRuleInterfaces, self), bstrInterfaceName, lInterfaceFlag, varInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_Remove(self: *const T, bstrInterfaceName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).Remove(@ptrCast(*const IAzBizRuleInterfaces, self), bstrInterfaceName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_RemoveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).RemoveAll(@ptrCast(*const IAzBizRuleInterfaces, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzBizRuleInterfaces_get_Count(self: *const T, plCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzBizRuleInterfaces.VTable, self.vtable).get_Count(@ptrCast(*const IAzBizRuleInterfaces, self), plCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzClientContext3_Value = @import("../zig.zig").Guid.initString("11894fde-1deb-4b4b-8907-6d1cda1f5d4f");
pub const IID_IAzClientContext3 = &IID_IAzClientContext3_Value;
pub const IAzClientContext3 = extern struct {
    pub const VTable = extern struct {
        base: IAzClientContext2.VTable,
        AccessCheck2: fn(
            self: *const IAzClientContext3,
            bstrObjectName: BSTR,
            bstrScopeName: BSTR,
            lOperation: i32,
            plResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInRoleAssignment: fn(
            self: *const IAzClientContext3,
            bstrScopeName: BSTR,
            bstrRoleName: BSTR,
            pbIsInRole: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOperations: fn(
            self: *const IAzClientContext3,
            bstrScopeName: BSTR,
            ppOperationCollection: ?*?*IAzOperations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTasks: fn(
            self: *const IAzClientContext3,
            bstrScopeName: BSTR,
            ppTaskCollection: ?*?*IAzTasks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleParameters: fn(
            self: *const IAzClientContext3,
            ppBizRuleParam: ?*?*IAzBizRuleParameters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleInterfaces: fn(
            self: *const IAzClientContext3,
            ppBizRuleInterfaces: ?*?*IAzBizRuleInterfaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroups: fn(
            self: *const IAzClientContext3,
            bstrScopeName: BSTR,
            ulOptions: AZ_PROP_CONSTANTS,
            pGroupArray: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Sids: fn(
            self: *const IAzClientContext3,
            pStringSidArray: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzClientContext2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_AccessCheck2(self: *const T, bstrObjectName: BSTR, bstrScopeName: BSTR, lOperation: i32, plResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).AccessCheck2(@ptrCast(*const IAzClientContext3, self), bstrObjectName, bstrScopeName, lOperation, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_IsInRoleAssignment(self: *const T, bstrScopeName: BSTR, bstrRoleName: BSTR, pbIsInRole: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).IsInRoleAssignment(@ptrCast(*const IAzClientContext3, self), bstrScopeName, bstrRoleName, pbIsInRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_GetOperations(self: *const T, bstrScopeName: BSTR, ppOperationCollection: ?*?*IAzOperations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).GetOperations(@ptrCast(*const IAzClientContext3, self), bstrScopeName, ppOperationCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_GetTasks(self: *const T, bstrScopeName: BSTR, ppTaskCollection: ?*?*IAzTasks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).GetTasks(@ptrCast(*const IAzClientContext3, self), bstrScopeName, ppTaskCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_get_BizRuleParameters(self: *const T, ppBizRuleParam: ?*?*IAzBizRuleParameters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).get_BizRuleParameters(@ptrCast(*const IAzClientContext3, self), ppBizRuleParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_get_BizRuleInterfaces(self: *const T, ppBizRuleInterfaces: ?*?*IAzBizRuleInterfaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).get_BizRuleInterfaces(@ptrCast(*const IAzClientContext3, self), ppBizRuleInterfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_GetGroups(self: *const T, bstrScopeName: BSTR, ulOptions: AZ_PROP_CONSTANTS, pGroupArray: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).GetGroups(@ptrCast(*const IAzClientContext3, self), bstrScopeName, ulOptions, pGroupArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzClientContext3_get_Sids(self: *const T, pStringSidArray: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzClientContext3.VTable, self.vtable).get_Sids(@ptrCast(*const IAzClientContext3, self), pStringSidArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzScope2_Value = @import("../zig.zig").Guid.initString("ee9fe8c9-c9f3-40e2-aa12-d1d8599727fd");
pub const IID_IAzScope2 = &IID_IAzScope2_Value;
pub const IAzScope2 = extern struct {
    pub const VTable = extern struct {
        base: IAzScope.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleDefinitions: fn(
            self: *const IAzScope2,
            ppRoleDefinitions: ?*?*IAzRoleDefinitions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRoleDefinition: fn(
            self: *const IAzScope2,
            bstrRoleDefinitionName: BSTR,
            ppRoleDefinitions: ?*?*IAzRoleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRoleDefinition: fn(
            self: *const IAzScope2,
            bstrRoleDefinitionName: BSTR,
            ppRoleDefinitions: ?*?*IAzRoleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleDefinition: fn(
            self: *const IAzScope2,
            bstrRoleDefinitionName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleAssignments: fn(
            self: *const IAzScope2,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRoleAssignment: fn(
            self: *const IAzScope2,
            bstrRoleAssignmentName: BSTR,
            ppRoleAssignment: ?*?*IAzRoleAssignment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRoleAssignment: fn(
            self: *const IAzScope2,
            bstrRoleAssignmentName: BSTR,
            ppRoleAssignment: ?*?*IAzRoleAssignment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleAssignment: fn(
            self: *const IAzScope2,
            bstrRoleAssignmentName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzScope.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_get_RoleDefinitions(self: *const T, ppRoleDefinitions: ?*?*IAzRoleDefinitions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).get_RoleDefinitions(@ptrCast(*const IAzScope2, self), ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_CreateRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR, ppRoleDefinitions: ?*?*IAzRoleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).CreateRoleDefinition(@ptrCast(*const IAzScope2, self), bstrRoleDefinitionName, ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_OpenRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR, ppRoleDefinitions: ?*?*IAzRoleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).OpenRoleDefinition(@ptrCast(*const IAzScope2, self), bstrRoleDefinitionName, ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_DeleteRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).DeleteRoleDefinition(@ptrCast(*const IAzScope2, self), bstrRoleDefinitionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_get_RoleAssignments(self: *const T, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).get_RoleAssignments(@ptrCast(*const IAzScope2, self), ppRoleAssignments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_CreateRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR, ppRoleAssignment: ?*?*IAzRoleAssignment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).CreateRoleAssignment(@ptrCast(*const IAzScope2, self), bstrRoleAssignmentName, ppRoleAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_OpenRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR, ppRoleAssignment: ?*?*IAzRoleAssignment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).OpenRoleAssignment(@ptrCast(*const IAzScope2, self), bstrRoleAssignmentName, ppRoleAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzScope2_DeleteRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzScope2.VTable, self.vtable).DeleteRoleAssignment(@ptrCast(*const IAzScope2, self), bstrRoleAssignmentName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplication3_Value = @import("../zig.zig").Guid.initString("181c845e-7196-4a7d-ac2e-020c0bb7a303");
pub const IID_IAzApplication3 = &IID_IAzApplication3_Value;
pub const IAzApplication3 = extern struct {
    pub const VTable = extern struct {
        base: IAzApplication2.VTable,
        ScopeExists: fn(
            self: *const IAzApplication3,
            bstrScopeName: BSTR,
            pbExist: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenScope2: fn(
            self: *const IAzApplication3,
            bstrScopeName: BSTR,
            ppScope2: ?*?*IAzScope2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateScope2: fn(
            self: *const IAzApplication3,
            bstrScopeName: BSTR,
            ppScope2: ?*?*IAzScope2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteScope2: fn(
            self: *const IAzApplication3,
            bstrScopeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleDefinitions: fn(
            self: *const IAzApplication3,
            ppRoleDefinitions: ?*?*IAzRoleDefinitions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRoleDefinition: fn(
            self: *const IAzApplication3,
            bstrRoleDefinitionName: BSTR,
            ppRoleDefinitions: ?*?*IAzRoleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRoleDefinition: fn(
            self: *const IAzApplication3,
            bstrRoleDefinitionName: BSTR,
            ppRoleDefinitions: ?*?*IAzRoleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleDefinition: fn(
            self: *const IAzApplication3,
            bstrRoleDefinitionName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleAssignments: fn(
            self: *const IAzApplication3,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRoleAssignment: fn(
            self: *const IAzApplication3,
            bstrRoleAssignmentName: BSTR,
            ppRoleAssignment: ?*?*IAzRoleAssignment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRoleAssignment: fn(
            self: *const IAzApplication3,
            bstrRoleAssignmentName: BSTR,
            ppRoleAssignment: ?*?*IAzRoleAssignment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleAssignment: fn(
            self: *const IAzApplication3,
            bstrRoleAssignmentName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRulesEnabled: fn(
            self: *const IAzApplication3,
            pbEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRulesEnabled: fn(
            self: *const IAzApplication3,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzApplication2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_ScopeExists(self: *const T, bstrScopeName: BSTR, pbExist: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).ScopeExists(@ptrCast(*const IAzApplication3, self), bstrScopeName, pbExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_OpenScope2(self: *const T, bstrScopeName: BSTR, ppScope2: ?*?*IAzScope2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).OpenScope2(@ptrCast(*const IAzApplication3, self), bstrScopeName, ppScope2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_CreateScope2(self: *const T, bstrScopeName: BSTR, ppScope2: ?*?*IAzScope2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).CreateScope2(@ptrCast(*const IAzApplication3, self), bstrScopeName, ppScope2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_DeleteScope2(self: *const T, bstrScopeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).DeleteScope2(@ptrCast(*const IAzApplication3, self), bstrScopeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_get_RoleDefinitions(self: *const T, ppRoleDefinitions: ?*?*IAzRoleDefinitions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).get_RoleDefinitions(@ptrCast(*const IAzApplication3, self), ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_CreateRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR, ppRoleDefinitions: ?*?*IAzRoleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).CreateRoleDefinition(@ptrCast(*const IAzApplication3, self), bstrRoleDefinitionName, ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_OpenRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR, ppRoleDefinitions: ?*?*IAzRoleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).OpenRoleDefinition(@ptrCast(*const IAzApplication3, self), bstrRoleDefinitionName, ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_DeleteRoleDefinition(self: *const T, bstrRoleDefinitionName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).DeleteRoleDefinition(@ptrCast(*const IAzApplication3, self), bstrRoleDefinitionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_get_RoleAssignments(self: *const T, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).get_RoleAssignments(@ptrCast(*const IAzApplication3, self), ppRoleAssignments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_CreateRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR, ppRoleAssignment: ?*?*IAzRoleAssignment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).CreateRoleAssignment(@ptrCast(*const IAzApplication3, self), bstrRoleAssignmentName, ppRoleAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_OpenRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR, ppRoleAssignment: ?*?*IAzRoleAssignment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).OpenRoleAssignment(@ptrCast(*const IAzApplication3, self), bstrRoleAssignmentName, ppRoleAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_DeleteRoleAssignment(self: *const T, bstrRoleAssignmentName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).DeleteRoleAssignment(@ptrCast(*const IAzApplication3, self), bstrRoleAssignmentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_get_BizRulesEnabled(self: *const T, pbEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).get_BizRulesEnabled(@ptrCast(*const IAzApplication3, self), pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplication3_put_BizRulesEnabled(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplication3.VTable, self.vtable).put_BizRulesEnabled(@ptrCast(*const IAzApplication3, self), bEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzOperation2_Value = @import("../zig.zig").Guid.initString("1f5ea01f-44a2-4184-9c48-a75b4dcc8ccc");
pub const IID_IAzOperation2 = &IID_IAzOperation2_Value;
pub const IAzOperation2 = extern struct {
    pub const VTable = extern struct {
        base: IAzOperation.VTable,
        RoleAssignments: fn(
            self: *const IAzOperation2,
            bstrScopeName: BSTR,
            bRecursive: i16,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzOperation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzOperation2_RoleAssignments(self: *const T, bstrScopeName: BSTR, bRecursive: i16, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzOperation2.VTable, self.vtable).RoleAssignments(@ptrCast(*const IAzOperation2, self), bstrScopeName, bRecursive, ppRoleAssignments);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRoleDefinitions_Value = @import("../zig.zig").Guid.initString("881f25a5-d755-4550-957a-d503a3b34001");
pub const IID_IAzRoleDefinitions = &IID_IAzRoleDefinitions_Value;
pub const IAzRoleDefinitions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzRoleDefinitions,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzRoleDefinitions,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzRoleDefinitions,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinitions_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinitions.VTable, self.vtable).get_Item(@ptrCast(*const IAzRoleDefinitions, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinitions_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinitions.VTable, self.vtable).get_Count(@ptrCast(*const IAzRoleDefinitions, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinitions_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinitions.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzRoleDefinitions, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRoleDefinition_Value = @import("../zig.zig").Guid.initString("d97fcea1-2599-44f1-9fc3-58e9fbe09466");
pub const IID_IAzRoleDefinition = &IID_IAzRoleDefinition_Value;
pub const IAzRoleDefinition = extern struct {
    pub const VTable = extern struct {
        base: IAzTask.VTable,
        RoleAssignments: fn(
            self: *const IAzRoleDefinition,
            bstrScopeName: BSTR,
            bRecursive: i16,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRoleDefinition: fn(
            self: *const IAzRoleDefinition,
            bstrRoleDefinition: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleDefinition: fn(
            self: *const IAzRoleDefinition,
            bstrRoleDefinition: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleDefinitions: fn(
            self: *const IAzRoleDefinition,
            ppRoleDefinitions: ?*?*IAzRoleDefinitions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzTask.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinition_RoleAssignments(self: *const T, bstrScopeName: BSTR, bRecursive: i16, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinition.VTable, self.vtable).RoleAssignments(@ptrCast(*const IAzRoleDefinition, self), bstrScopeName, bRecursive, ppRoleAssignments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinition_AddRoleDefinition(self: *const T, bstrRoleDefinition: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinition.VTable, self.vtable).AddRoleDefinition(@ptrCast(*const IAzRoleDefinition, self), bstrRoleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinition_DeleteRoleDefinition(self: *const T, bstrRoleDefinition: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinition.VTable, self.vtable).DeleteRoleDefinition(@ptrCast(*const IAzRoleDefinition, self), bstrRoleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleDefinition_get_RoleDefinitions(self: *const T, ppRoleDefinitions: ?*?*IAzRoleDefinitions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleDefinition.VTable, self.vtable).get_RoleDefinitions(@ptrCast(*const IAzRoleDefinition, self), ppRoleDefinitions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRoleAssignment_Value = @import("../zig.zig").Guid.initString("55647d31-0d5a-4fa3-b4ac-2b5f9ad5ab76");
pub const IID_IAzRoleAssignment = &IID_IAzRoleAssignment_Value;
pub const IAzRoleAssignment = extern struct {
    pub const VTable = extern struct {
        base: IAzRole.VTable,
        AddRoleDefinition: fn(
            self: *const IAzRoleAssignment,
            bstrRoleDefinition: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRoleDefinition: fn(
            self: *const IAzRoleAssignment,
            bstrRoleDefinition: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RoleDefinitions: fn(
            self: *const IAzRoleAssignment,
            ppRoleDefinitions: ?*?*IAzRoleDefinitions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const IAzRoleAssignment,
            ppScope: ?*?*IAzScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzRole.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignment_AddRoleDefinition(self: *const T, bstrRoleDefinition: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignment.VTable, self.vtable).AddRoleDefinition(@ptrCast(*const IAzRoleAssignment, self), bstrRoleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignment_DeleteRoleDefinition(self: *const T, bstrRoleDefinition: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignment.VTable, self.vtable).DeleteRoleDefinition(@ptrCast(*const IAzRoleAssignment, self), bstrRoleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignment_get_RoleDefinitions(self: *const T, ppRoleDefinitions: ?*?*IAzRoleDefinitions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignment.VTable, self.vtable).get_RoleDefinitions(@ptrCast(*const IAzRoleAssignment, self), ppRoleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignment_get_Scope(self: *const T, ppScope: ?*?*IAzScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignment.VTable, self.vtable).get_Scope(@ptrCast(*const IAzRoleAssignment, self), ppScope);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzRoleAssignments_Value = @import("../zig.zig").Guid.initString("9c80b900-fceb-4d73-a0f4-c83b0bbf2481");
pub const IID_IAzRoleAssignments = &IID_IAzRoleAssignments_Value;
pub const IAzRoleAssignments = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IAzRoleAssignments,
            Index: i32,
            pvarObtPtr: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAzRoleAssignments,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAzRoleAssignments,
            ppEnumPtr: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignments_get_Item(self: *const T, Index: i32, pvarObtPtr: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignments.VTable, self.vtable).get_Item(@ptrCast(*const IAzRoleAssignments, self), Index, pvarObtPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignments_get_Count(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignments.VTable, self.vtable).get_Count(@ptrCast(*const IAzRoleAssignments, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzRoleAssignments_get__NewEnum(self: *const T, ppEnumPtr: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzRoleAssignments.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAzRoleAssignments, self), ppEnumPtr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzPrincipalLocator_Value = @import("../zig.zig").Guid.initString("e5c3507d-ad6a-4992-9c7f-74ab480b44cc");
pub const IID_IAzPrincipalLocator = &IID_IAzPrincipalLocator_Value;
pub const IAzPrincipalLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NameResolver: fn(
            self: *const IAzPrincipalLocator,
            ppNameResolver: ?*?*IAzNameResolver,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectPicker: fn(
            self: *const IAzPrincipalLocator,
            ppObjectPicker: ?*?*IAzObjectPicker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzPrincipalLocator_get_NameResolver(self: *const T, ppNameResolver: ?*?*IAzNameResolver) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzPrincipalLocator.VTable, self.vtable).get_NameResolver(@ptrCast(*const IAzPrincipalLocator, self), ppNameResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzPrincipalLocator_get_ObjectPicker(self: *const T, ppObjectPicker: ?*?*IAzObjectPicker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzPrincipalLocator.VTable, self.vtable).get_ObjectPicker(@ptrCast(*const IAzPrincipalLocator, self), ppObjectPicker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzNameResolver_Value = @import("../zig.zig").Guid.initString("504d0f15-73e2-43df-a870-a64f40714f53");
pub const IID_IAzNameResolver = &IID_IAzNameResolver_Value;
pub const IAzNameResolver = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        NameFromSid: fn(
            self: *const IAzNameResolver,
            bstrSid: BSTR,
            pSidType: *i32,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NamesFromSids: fn(
            self: *const IAzNameResolver,
            vSids: VARIANT,
            pvSidTypes: *VARIANT,
            pvNames: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzNameResolver_NameFromSid(self: *const T, bstrSid: BSTR, pSidType: *i32, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzNameResolver.VTable, self.vtable).NameFromSid(@ptrCast(*const IAzNameResolver, self), bstrSid, pSidType, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzNameResolver_NamesFromSids(self: *const T, vSids: VARIANT, pvSidTypes: *VARIANT, pvNames: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzNameResolver.VTable, self.vtable).NamesFromSids(@ptrCast(*const IAzNameResolver, self), vSids, pvSidTypes, pvNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzObjectPicker_Value = @import("../zig.zig").Guid.initString("63130a48-699a-42d8-bf01-c62ac3fb79f9");
pub const IID_IAzObjectPicker = &IID_IAzObjectPicker_Value;
pub const IAzObjectPicker = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetPrincipals: fn(
            self: *const IAzObjectPicker,
            hParentWnd: HWND,
            bstrTitle: BSTR,
            pvSidTypes: *VARIANT,
            pvNames: *VARIANT,
            pvSids: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IAzObjectPicker,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzObjectPicker_GetPrincipals(self: *const T, hParentWnd: HWND, bstrTitle: BSTR, pvSidTypes: *VARIANT, pvNames: *VARIANT, pvSids: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzObjectPicker.VTable, self.vtable).GetPrincipals(@ptrCast(*const IAzObjectPicker, self), hParentWnd, bstrTitle, pvSidTypes, pvNames, pvSids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzObjectPicker_get_Name(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzObjectPicker.VTable, self.vtable).get_Name(@ptrCast(*const IAzObjectPicker, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzApplicationGroup2_Value = @import("../zig.zig").Guid.initString("3f0613fc-b71a-464e-a11d-5b881a56cefa");
pub const IID_IAzApplicationGroup2 = &IID_IAzApplicationGroup2_Value;
pub const IAzApplicationGroup2 = extern struct {
    pub const VTable = extern struct {
        base: IAzApplicationGroup.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRule: fn(
            self: *const IAzApplicationGroup2,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRule: fn(
            self: *const IAzApplicationGroup2,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleLanguage: fn(
            self: *const IAzApplicationGroup2,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRuleLanguage: fn(
            self: *const IAzApplicationGroup2,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BizRuleImportedPath: fn(
            self: *const IAzApplicationGroup2,
            pbstrProp: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BizRuleImportedPath: fn(
            self: *const IAzApplicationGroup2,
            bstrProp: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RoleAssignments: fn(
            self: *const IAzApplicationGroup2,
            bstrScopeName: BSTR,
            bRecursive: i16,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzApplicationGroup.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_get_BizRule(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).get_BizRule(@ptrCast(*const IAzApplicationGroup2, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_put_BizRule(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).put_BizRule(@ptrCast(*const IAzApplicationGroup2, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_get_BizRuleLanguage(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).get_BizRuleLanguage(@ptrCast(*const IAzApplicationGroup2, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_put_BizRuleLanguage(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).put_BizRuleLanguage(@ptrCast(*const IAzApplicationGroup2, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_get_BizRuleImportedPath(self: *const T, pbstrProp: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).get_BizRuleImportedPath(@ptrCast(*const IAzApplicationGroup2, self), pbstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_put_BizRuleImportedPath(self: *const T, bstrProp: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).put_BizRuleImportedPath(@ptrCast(*const IAzApplicationGroup2, self), bstrProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzApplicationGroup2_RoleAssignments(self: *const T, bstrScopeName: BSTR, bRecursive: i16, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzApplicationGroup2.VTable, self.vtable).RoleAssignments(@ptrCast(*const IAzApplicationGroup2, self), bstrScopeName, bRecursive, ppRoleAssignments);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAzTask2_Value = @import("../zig.zig").Guid.initString("03a9a5ee-48c8-4832-9025-aad503c46526");
pub const IID_IAzTask2 = &IID_IAzTask2_Value;
pub const IAzTask2 = extern struct {
    pub const VTable = extern struct {
        base: IAzTask.VTable,
        RoleAssignments: fn(
            self: *const IAzTask2,
            bstrScopeName: BSTR,
            bRecursive: i16,
            ppRoleAssignments: ?*?*IAzRoleAssignments,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAzTask.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAzTask2_RoleAssignments(self: *const T, bstrScopeName: BSTR, bRecursive: i16, ppRoleAssignments: ?*?*IAzRoleAssignments) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAzTask2.VTable, self.vtable).RoleAssignments(@ptrCast(*const IAzTask2, self), bstrScopeName, bRecursive, ppRoleAssignments);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AZ_PROP_CONSTANTS = extern enum(i32) {
    PROP_NAME = 1,
    PROP_DESCRIPTION = 2,
    PROP_WRITABLE = 3,
    PROP_APPLICATION_DATA = 4,
    PROP_CHILD_CREATE = 5,
    MAX_APPLICATION_NAME_LENGTH = 512,
    MAX_OPERATION_NAME_LENGTH = 64,
    MAX_TASK_NAME_LENGTH = 64,
    MAX_SCOPE_NAME_LENGTH = 65536,
    MAX_GROUP_NAME_LENGTH = 64,
    MAX_ROLE_NAME_LENGTH = 64,
    MAX_NAME_LENGTH = 65536,
    MAX_DESCRIPTION_LENGTH = 1024,
    MAX_APPLICATION_DATA_LENGTH = 4096,
    SUBMIT_FLAG_ABORT = 1,
    SUBMIT_FLAG_FLUSH = 2,
    MAX_POLICY_URL_LENGTH = 65536,
    AZSTORE_FLAG_CREATE = 1,
    AZSTORE_FLAG_MANAGE_STORE_ONLY = 2,
    AZSTORE_FLAG_BATCH_UPDATE = 4,
    AZSTORE_FLAG_AUDIT_IS_CRITICAL = 8,
    AZSTORE_FORCE_APPLICATION_CLOSE = 16,
    AZSTORE_NT6_FUNCTION_LEVEL = 32,
    AZSTORE_FLAG_MANAGE_ONLY_PASSIVE_SUBMIT = 32768,
    PROP_AZSTORE_DOMAIN_TIMEOUT = 100,
    AZSTORE_DEFAULT_DOMAIN_TIMEOUT = 15000,
    PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT = 101,
    AZSTORE_MIN_DOMAIN_TIMEOUT = 500,
    AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT = 5000,
    AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT = 45000,
    PROP_AZSTORE_MAX_SCRIPT_ENGINES = 102,
    AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES = 120,
    PROP_AZSTORE_MAJOR_VERSION = 103,
    PROP_AZSTORE_MINOR_VERSION = 104,
    PROP_AZSTORE_TARGET_MACHINE = 105,
    PROP_AZTORE_IS_ADAM_INSTANCE = 106,
    PROP_OPERATION_ID = 200,
    PROP_TASK_OPERATIONS = 300,
    PROP_TASK_BIZRULE = 301,
    PROP_TASK_BIZRULE_LANGUAGE = 302,
    PROP_TASK_TASKS = 303,
    PROP_TASK_BIZRULE_IMPORTED_PATH = 304,
    PROP_TASK_IS_ROLE_DEFINITION = 305,
    MAX_TASK_BIZRULE_LENGTH = 65536,
    MAX_TASK_BIZRULE_LANGUAGE_LENGTH = 64,
    MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH = 512,
    MAX_BIZRULE_STRING = 65536,
    PROP_GROUP_TYPE = 400,
    GROUPTYPE_LDAP_QUERY = 1,
    GROUPTYPE_BASIC = 2,
    GROUPTYPE_BIZRULE = 3,
    PROP_GROUP_APP_MEMBERS = 401,
    PROP_GROUP_APP_NON_MEMBERS = 402,
    PROP_GROUP_LDAP_QUERY = 403,
    MAX_GROUP_LDAP_QUERY_LENGTH = 4096,
    PROP_GROUP_MEMBERS = 404,
    PROP_GROUP_NON_MEMBERS = 405,
    PROP_GROUP_MEMBERS_NAME = 406,
    PROP_GROUP_NON_MEMBERS_NAME = 407,
    PROP_GROUP_BIZRULE = 408,
    PROP_GROUP_BIZRULE_LANGUAGE = 409,
    PROP_GROUP_BIZRULE_IMPORTED_PATH = 410,
    MAX_GROUP_BIZRULE_LENGTH = 65536,
    MAX_GROUP_BIZRULE_LANGUAGE_LENGTH = 64,
    MAX_GROUP_BIZRULE_IMPORTED_PATH_LENGTH = 512,
    PROP_ROLE_APP_MEMBERS = 500,
    PROP_ROLE_MEMBERS = 501,
    PROP_ROLE_OPERATIONS = 502,
    PROP_ROLE_TASKS = 504,
    PROP_ROLE_MEMBERS_NAME = 505,
    PROP_SCOPE_BIZRULES_WRITABLE = 600,
    PROP_SCOPE_CAN_BE_DELEGATED = 601,
    PROP_CLIENT_CONTEXT_USER_DN = 700,
    PROP_CLIENT_CONTEXT_USER_SAM_COMPAT = 701,
    PROP_CLIENT_CONTEXT_USER_DISPLAY = 702,
    PROP_CLIENT_CONTEXT_USER_GUID = 703,
    PROP_CLIENT_CONTEXT_USER_CANONICAL = 704,
    PROP_CLIENT_CONTEXT_USER_UPN = 705,
    PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT = 707,
    PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK = 708,
    PROP_CLIENT_CONTEXT_LDAP_QUERY_DN = 709,
    PROP_APPLICATION_AUTHZ_INTERFACE_CLSID = 800,
    PROP_APPLICATION_VERSION = 801,
    MAX_APPLICATION_VERSION_LENGTH = 512,
    PROP_APPLICATION_NAME = 802,
    PROP_APPLICATION_BIZRULE_ENABLED = 803,
    PROP_APPLY_STORE_SACL = 900,
    PROP_GENERATE_AUDITS = 901,
    PROP_POLICY_ADMINS = 902,
    PROP_POLICY_READERS = 903,
    PROP_DELEGATED_POLICY_USERS = 904,
    PROP_POLICY_ADMINS_NAME = 905,
    PROP_POLICY_READERS_NAME = 906,
    PROP_DELEGATED_POLICY_USERS_NAME = 907,
    CLIENT_CONTEXT_SKIP_GROUP = 1,
    CLIENT_CONTEXT_SKIP_LDAP_QUERY = 1,
    CLIENT_CONTEXT_GET_GROUP_RECURSIVE = 2,
    CLIENT_CONTEXT_GET_GROUPS_STORE_LEVEL_ONLY = 2,
};
pub const AZ_PROP_NAME = AZ_PROP_CONSTANTS.PROP_NAME;
pub const AZ_PROP_DESCRIPTION = AZ_PROP_CONSTANTS.PROP_DESCRIPTION;
pub const AZ_PROP_WRITABLE = AZ_PROP_CONSTANTS.PROP_WRITABLE;
pub const AZ_PROP_APPLICATION_DATA = AZ_PROP_CONSTANTS.PROP_APPLICATION_DATA;
pub const AZ_PROP_CHILD_CREATE = AZ_PROP_CONSTANTS.PROP_CHILD_CREATE;
pub const AZ_MAX_APPLICATION_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_APPLICATION_NAME_LENGTH;
pub const AZ_MAX_OPERATION_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_OPERATION_NAME_LENGTH;
pub const AZ_MAX_TASK_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_TASK_NAME_LENGTH;
pub const AZ_MAX_SCOPE_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_SCOPE_NAME_LENGTH;
pub const AZ_MAX_GROUP_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_GROUP_NAME_LENGTH;
pub const AZ_MAX_ROLE_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_ROLE_NAME_LENGTH;
pub const AZ_MAX_NAME_LENGTH = AZ_PROP_CONSTANTS.MAX_NAME_LENGTH;
pub const AZ_MAX_DESCRIPTION_LENGTH = AZ_PROP_CONSTANTS.MAX_DESCRIPTION_LENGTH;
pub const AZ_MAX_APPLICATION_DATA_LENGTH = AZ_PROP_CONSTANTS.MAX_APPLICATION_DATA_LENGTH;
pub const AZ_SUBMIT_FLAG_ABORT = AZ_PROP_CONSTANTS.SUBMIT_FLAG_ABORT;
pub const AZ_SUBMIT_FLAG_FLUSH = AZ_PROP_CONSTANTS.SUBMIT_FLAG_FLUSH;
pub const AZ_MAX_POLICY_URL_LENGTH = AZ_PROP_CONSTANTS.MAX_POLICY_URL_LENGTH;
pub const AZ_AZSTORE_FLAG_CREATE = AZ_PROP_CONSTANTS.AZSTORE_FLAG_CREATE;
pub const AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY = AZ_PROP_CONSTANTS.AZSTORE_FLAG_MANAGE_STORE_ONLY;
pub const AZ_AZSTORE_FLAG_BATCH_UPDATE = AZ_PROP_CONSTANTS.AZSTORE_FLAG_BATCH_UPDATE;
pub const AZ_AZSTORE_FLAG_AUDIT_IS_CRITICAL = AZ_PROP_CONSTANTS.AZSTORE_FLAG_AUDIT_IS_CRITICAL;
pub const AZ_AZSTORE_FORCE_APPLICATION_CLOSE = AZ_PROP_CONSTANTS.AZSTORE_FORCE_APPLICATION_CLOSE;
pub const AZ_AZSTORE_NT6_FUNCTION_LEVEL = AZ_PROP_CONSTANTS.AZSTORE_NT6_FUNCTION_LEVEL;
pub const AZ_AZSTORE_FLAG_MANAGE_ONLY_PASSIVE_SUBMIT = AZ_PROP_CONSTANTS.AZSTORE_FLAG_MANAGE_ONLY_PASSIVE_SUBMIT;
pub const AZ_PROP_AZSTORE_DOMAIN_TIMEOUT = AZ_PROP_CONSTANTS.PROP_AZSTORE_DOMAIN_TIMEOUT;
pub const AZ_AZSTORE_DEFAULT_DOMAIN_TIMEOUT = AZ_PROP_CONSTANTS.AZSTORE_DEFAULT_DOMAIN_TIMEOUT;
pub const AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT = AZ_PROP_CONSTANTS.PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT;
pub const AZ_AZSTORE_MIN_DOMAIN_TIMEOUT = AZ_PROP_CONSTANTS.AZSTORE_MIN_DOMAIN_TIMEOUT;
pub const AZ_AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT = AZ_PROP_CONSTANTS.AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT;
pub const AZ_AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT = AZ_PROP_CONSTANTS.AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT;
pub const AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES = AZ_PROP_CONSTANTS.PROP_AZSTORE_MAX_SCRIPT_ENGINES;
pub const AZ_AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES = AZ_PROP_CONSTANTS.AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES;
pub const AZ_PROP_AZSTORE_MAJOR_VERSION = AZ_PROP_CONSTANTS.PROP_AZSTORE_MAJOR_VERSION;
pub const AZ_PROP_AZSTORE_MINOR_VERSION = AZ_PROP_CONSTANTS.PROP_AZSTORE_MINOR_VERSION;
pub const AZ_PROP_AZSTORE_TARGET_MACHINE = AZ_PROP_CONSTANTS.PROP_AZSTORE_TARGET_MACHINE;
pub const AZ_PROP_AZTORE_IS_ADAM_INSTANCE = AZ_PROP_CONSTANTS.PROP_AZTORE_IS_ADAM_INSTANCE;
pub const AZ_PROP_OPERATION_ID = AZ_PROP_CONSTANTS.PROP_OPERATION_ID;
pub const AZ_PROP_TASK_OPERATIONS = AZ_PROP_CONSTANTS.PROP_TASK_OPERATIONS;
pub const AZ_PROP_TASK_BIZRULE = AZ_PROP_CONSTANTS.PROP_TASK_BIZRULE;
pub const AZ_PROP_TASK_BIZRULE_LANGUAGE = AZ_PROP_CONSTANTS.PROP_TASK_BIZRULE_LANGUAGE;
pub const AZ_PROP_TASK_TASKS = AZ_PROP_CONSTANTS.PROP_TASK_TASKS;
pub const AZ_PROP_TASK_BIZRULE_IMPORTED_PATH = AZ_PROP_CONSTANTS.PROP_TASK_BIZRULE_IMPORTED_PATH;
pub const AZ_PROP_TASK_IS_ROLE_DEFINITION = AZ_PROP_CONSTANTS.PROP_TASK_IS_ROLE_DEFINITION;
pub const AZ_MAX_TASK_BIZRULE_LENGTH = AZ_PROP_CONSTANTS.MAX_TASK_BIZRULE_LENGTH;
pub const AZ_MAX_TASK_BIZRULE_LANGUAGE_LENGTH = AZ_PROP_CONSTANTS.MAX_TASK_BIZRULE_LANGUAGE_LENGTH;
pub const AZ_MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH = AZ_PROP_CONSTANTS.MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH;
pub const AZ_MAX_BIZRULE_STRING = AZ_PROP_CONSTANTS.MAX_BIZRULE_STRING;
pub const AZ_PROP_GROUP_TYPE = AZ_PROP_CONSTANTS.PROP_GROUP_TYPE;
pub const AZ_GROUPTYPE_LDAP_QUERY = AZ_PROP_CONSTANTS.GROUPTYPE_LDAP_QUERY;
pub const AZ_GROUPTYPE_BASIC = AZ_PROP_CONSTANTS.GROUPTYPE_BASIC;
pub const AZ_GROUPTYPE_BIZRULE = AZ_PROP_CONSTANTS.GROUPTYPE_BIZRULE;
pub const AZ_PROP_GROUP_APP_MEMBERS = AZ_PROP_CONSTANTS.PROP_GROUP_APP_MEMBERS;
pub const AZ_PROP_GROUP_APP_NON_MEMBERS = AZ_PROP_CONSTANTS.PROP_GROUP_APP_NON_MEMBERS;
pub const AZ_PROP_GROUP_LDAP_QUERY = AZ_PROP_CONSTANTS.PROP_GROUP_LDAP_QUERY;
pub const AZ_MAX_GROUP_LDAP_QUERY_LENGTH = AZ_PROP_CONSTANTS.MAX_GROUP_LDAP_QUERY_LENGTH;
pub const AZ_PROP_GROUP_MEMBERS = AZ_PROP_CONSTANTS.PROP_GROUP_MEMBERS;
pub const AZ_PROP_GROUP_NON_MEMBERS = AZ_PROP_CONSTANTS.PROP_GROUP_NON_MEMBERS;
pub const AZ_PROP_GROUP_MEMBERS_NAME = AZ_PROP_CONSTANTS.PROP_GROUP_MEMBERS_NAME;
pub const AZ_PROP_GROUP_NON_MEMBERS_NAME = AZ_PROP_CONSTANTS.PROP_GROUP_NON_MEMBERS_NAME;
pub const AZ_PROP_GROUP_BIZRULE = AZ_PROP_CONSTANTS.PROP_GROUP_BIZRULE;
pub const AZ_PROP_GROUP_BIZRULE_LANGUAGE = AZ_PROP_CONSTANTS.PROP_GROUP_BIZRULE_LANGUAGE;
pub const AZ_PROP_GROUP_BIZRULE_IMPORTED_PATH = AZ_PROP_CONSTANTS.PROP_GROUP_BIZRULE_IMPORTED_PATH;
pub const AZ_MAX_GROUP_BIZRULE_LENGTH = AZ_PROP_CONSTANTS.MAX_GROUP_BIZRULE_LENGTH;
pub const AZ_MAX_GROUP_BIZRULE_LANGUAGE_LENGTH = AZ_PROP_CONSTANTS.MAX_GROUP_BIZRULE_LANGUAGE_LENGTH;
pub const AZ_MAX_GROUP_BIZRULE_IMPORTED_PATH_LENGTH = AZ_PROP_CONSTANTS.MAX_GROUP_BIZRULE_IMPORTED_PATH_LENGTH;
pub const AZ_PROP_ROLE_APP_MEMBERS = AZ_PROP_CONSTANTS.PROP_ROLE_APP_MEMBERS;
pub const AZ_PROP_ROLE_MEMBERS = AZ_PROP_CONSTANTS.PROP_ROLE_MEMBERS;
pub const AZ_PROP_ROLE_OPERATIONS = AZ_PROP_CONSTANTS.PROP_ROLE_OPERATIONS;
pub const AZ_PROP_ROLE_TASKS = AZ_PROP_CONSTANTS.PROP_ROLE_TASKS;
pub const AZ_PROP_ROLE_MEMBERS_NAME = AZ_PROP_CONSTANTS.PROP_ROLE_MEMBERS_NAME;
pub const AZ_PROP_SCOPE_BIZRULES_WRITABLE = AZ_PROP_CONSTANTS.PROP_SCOPE_BIZRULES_WRITABLE;
pub const AZ_PROP_SCOPE_CAN_BE_DELEGATED = AZ_PROP_CONSTANTS.PROP_SCOPE_CAN_BE_DELEGATED;
pub const AZ_PROP_CLIENT_CONTEXT_USER_DN = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_DN;
pub const AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_SAM_COMPAT;
pub const AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_DISPLAY;
pub const AZ_PROP_CLIENT_CONTEXT_USER_GUID = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_GUID;
pub const AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_CANONICAL;
pub const AZ_PROP_CLIENT_CONTEXT_USER_UPN = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_UPN;
pub const AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT;
pub const AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK;
pub const AZ_PROP_CLIENT_CONTEXT_LDAP_QUERY_DN = AZ_PROP_CONSTANTS.PROP_CLIENT_CONTEXT_LDAP_QUERY_DN;
pub const AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID = AZ_PROP_CONSTANTS.PROP_APPLICATION_AUTHZ_INTERFACE_CLSID;
pub const AZ_PROP_APPLICATION_VERSION = AZ_PROP_CONSTANTS.PROP_APPLICATION_VERSION;
pub const AZ_MAX_APPLICATION_VERSION_LENGTH = AZ_PROP_CONSTANTS.MAX_APPLICATION_VERSION_LENGTH;
pub const AZ_PROP_APPLICATION_NAME = AZ_PROP_CONSTANTS.PROP_APPLICATION_NAME;
pub const AZ_PROP_APPLICATION_BIZRULE_ENABLED = AZ_PROP_CONSTANTS.PROP_APPLICATION_BIZRULE_ENABLED;
pub const AZ_PROP_APPLY_STORE_SACL = AZ_PROP_CONSTANTS.PROP_APPLY_STORE_SACL;
pub const AZ_PROP_GENERATE_AUDITS = AZ_PROP_CONSTANTS.PROP_GENERATE_AUDITS;
pub const AZ_PROP_POLICY_ADMINS = AZ_PROP_CONSTANTS.PROP_POLICY_ADMINS;
pub const AZ_PROP_POLICY_READERS = AZ_PROP_CONSTANTS.PROP_POLICY_READERS;
pub const AZ_PROP_DELEGATED_POLICY_USERS = AZ_PROP_CONSTANTS.PROP_DELEGATED_POLICY_USERS;
pub const AZ_PROP_POLICY_ADMINS_NAME = AZ_PROP_CONSTANTS.PROP_POLICY_ADMINS_NAME;
pub const AZ_PROP_POLICY_READERS_NAME = AZ_PROP_CONSTANTS.PROP_POLICY_READERS_NAME;
pub const AZ_PROP_DELEGATED_POLICY_USERS_NAME = AZ_PROP_CONSTANTS.PROP_DELEGATED_POLICY_USERS_NAME;
pub const AZ_CLIENT_CONTEXT_SKIP_GROUP = AZ_PROP_CONSTANTS.CLIENT_CONTEXT_SKIP_GROUP;
pub const AZ_CLIENT_CONTEXT_SKIP_LDAP_QUERY = AZ_PROP_CONSTANTS.CLIENT_CONTEXT_SKIP_LDAP_QUERY;
pub const AZ_CLIENT_CONTEXT_GET_GROUP_RECURSIVE = AZ_PROP_CONSTANTS.CLIENT_CONTEXT_GET_GROUP_RECURSIVE;
pub const AZ_CLIENT_CONTEXT_GET_GROUPS_STORE_LEVEL_ONLY = AZ_PROP_CONSTANTS.CLIENT_CONTEXT_GET_GROUPS_STORE_LEVEL_ONLY;

pub const SI_OBJECT_INFO = extern struct {
    dwFlags: SI_OBJECT_INFO_FLAGS,
    hInstance: HINSTANCE,
    pszServerName: PWSTR,
    pszObjectName: PWSTR,
    pszPageTitle: PWSTR,
    guidObjectType: Guid,
};

pub const SI_ACCESS = extern struct {
    pguid: *const Guid,
    mask: u32,
    pszName: [*:0]const u16,
    dwFlags: u32,
};

pub const SI_INHERIT_TYPE = extern struct {
    pguid: *const Guid,
    dwFlags: ACE_FLAGS,
    pszName: [*:0]const u16,
};

pub const SI_PAGE_TYPE = extern enum(i32) {
    PERM = 0,
    ADVPERM = 1,
    AUDIT = 2,
    OWNER = 3,
    EFFECTIVE = 4,
    TAKEOWNERSHIP = 5,
    SHARE = 6,
};
pub const SI_PAGE_PERM = SI_PAGE_TYPE.PERM;
pub const SI_PAGE_ADVPERM = SI_PAGE_TYPE.ADVPERM;
pub const SI_PAGE_AUDIT = SI_PAGE_TYPE.AUDIT;
pub const SI_PAGE_OWNER = SI_PAGE_TYPE.OWNER;
pub const SI_PAGE_EFFECTIVE = SI_PAGE_TYPE.EFFECTIVE;
pub const SI_PAGE_TAKEOWNERSHIP = SI_PAGE_TYPE.TAKEOWNERSHIP;
pub const SI_PAGE_SHARE = SI_PAGE_TYPE.SHARE;

pub const SI_PAGE_ACTIVATED = extern enum(i32) {
    DEFAULT = 0,
    PERM_ACTIVATED = 1,
    AUDIT_ACTIVATED = 2,
    OWNER_ACTIVATED = 3,
    EFFECTIVE_ACTIVATED = 4,
    SHARE_ACTIVATED = 5,
    CENTRAL_POLICY_ACTIVATED = 6,
};
pub const SI_SHOW_DEFAULT = SI_PAGE_ACTIVATED.DEFAULT;
pub const SI_SHOW_PERM_ACTIVATED = SI_PAGE_ACTIVATED.PERM_ACTIVATED;
pub const SI_SHOW_AUDIT_ACTIVATED = SI_PAGE_ACTIVATED.AUDIT_ACTIVATED;
pub const SI_SHOW_OWNER_ACTIVATED = SI_PAGE_ACTIVATED.OWNER_ACTIVATED;
pub const SI_SHOW_EFFECTIVE_ACTIVATED = SI_PAGE_ACTIVATED.EFFECTIVE_ACTIVATED;
pub const SI_SHOW_SHARE_ACTIVATED = SI_PAGE_ACTIVATED.SHARE_ACTIVATED;
pub const SI_SHOW_CENTRAL_POLICY_ACTIVATED = SI_PAGE_ACTIVATED.CENTRAL_POLICY_ACTIVATED;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISecurityInformation_Value = @import("../zig.zig").Guid.initString("965fc360-16ff-11d0-91cb-00aa00bbb723");
pub const IID_ISecurityInformation = &IID_ISecurityInformation_Value;
pub const ISecurityInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectInformation: fn(
            self: *const ISecurityInformation,
            pObjectInfo: *SI_OBJECT_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurity: fn(
            self: *const ISecurityInformation,
            RequestedInformation: OBJECT_SECURITY_INFORMATION,
            ppSecurityDescriptor: **SECURITY_DESCRIPTOR,
            fDefault: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSecurity: fn(
            self: *const ISecurityInformation,
            SecurityInformation: OBJECT_SECURITY_INFORMATION,
            pSecurityDescriptor: *SECURITY_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccessRights: fn(
            self: *const ISecurityInformation,
            pguidObjectType: *const Guid,
            dwFlags: SECURITY_INFO_PAGE_FLAGS,
            ppAccess: **SI_ACCESS,
            pcAccesses: *u32,
            piDefaultAccess: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapGeneric: fn(
            self: *const ISecurityInformation,
            pguidObjectType: *const Guid,
            pAceFlags: *u8,
            pMask: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInheritTypes: fn(
            self: *const ISecurityInformation,
            ppInheritTypes: **SI_INHERIT_TYPE,
            pcInheritTypes: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PropertySheetPageCallback: fn(
            self: *const ISecurityInformation,
            hwnd: HWND,
            uMsg: PSPCB_MESSAGE,
            uPage: SI_PAGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_GetObjectInformation(self: *const T, pObjectInfo: *SI_OBJECT_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).GetObjectInformation(@ptrCast(*const ISecurityInformation, self), pObjectInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_GetSecurity(self: *const T, RequestedInformation: OBJECT_SECURITY_INFORMATION, ppSecurityDescriptor: **SECURITY_DESCRIPTOR, fDefault: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).GetSecurity(@ptrCast(*const ISecurityInformation, self), RequestedInformation, ppSecurityDescriptor, fDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_SetSecurity(self: *const T, SecurityInformation: OBJECT_SECURITY_INFORMATION, pSecurityDescriptor: *SECURITY_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).SetSecurity(@ptrCast(*const ISecurityInformation, self), SecurityInformation, pSecurityDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_GetAccessRights(self: *const T, pguidObjectType: *const Guid, dwFlags: SECURITY_INFO_PAGE_FLAGS, ppAccess: **SI_ACCESS, pcAccesses: *u32, piDefaultAccess: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).GetAccessRights(@ptrCast(*const ISecurityInformation, self), pguidObjectType, dwFlags, ppAccess, pcAccesses, piDefaultAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_MapGeneric(self: *const T, pguidObjectType: *const Guid, pAceFlags: *u8, pMask: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).MapGeneric(@ptrCast(*const ISecurityInformation, self), pguidObjectType, pAceFlags, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_GetInheritTypes(self: *const T, ppInheritTypes: **SI_INHERIT_TYPE, pcInheritTypes: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).GetInheritTypes(@ptrCast(*const ISecurityInformation, self), ppInheritTypes, pcInheritTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation_PropertySheetPageCallback(self: *const T, hwnd: HWND, uMsg: PSPCB_MESSAGE, uPage: SI_PAGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation.VTable, self.vtable).PropertySheetPageCallback(@ptrCast(*const ISecurityInformation, self), hwnd, uMsg, uPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISecurityInformation2_Value = @import("../zig.zig").Guid.initString("c3ccfdb4-6f88-11d2-a3ce-00c04fb1782a");
pub const IID_ISecurityInformation2 = &IID_ISecurityInformation2_Value;
pub const ISecurityInformation2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDaclCanonical: fn(
            self: *const ISecurityInformation2,
            pDacl: *ACL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        LookupSids: fn(
            self: *const ISecurityInformation2,
            cSids: u32,
            rgpSids: *PSID,
            ppdo: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation2_IsDaclCanonical(self: *const T, pDacl: *ACL) callconv(.Inline) BOOL {
            return @ptrCast(*const ISecurityInformation2.VTable, self.vtable).IsDaclCanonical(@ptrCast(*const ISecurityInformation2, self), pDacl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation2_LookupSids(self: *const T, cSids: u32, rgpSids: *PSID, ppdo: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation2.VTable, self.vtable).LookupSids(@ptrCast(*const ISecurityInformation2, self), cSids, rgpSids, ppdo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SID_INFO = extern struct {
    pSid: PSID,
    pwzCommonName: PWSTR,
    pwzClass: PWSTR,
    pwzUPN: PWSTR,
};

pub const SID_INFO_LIST = extern struct {
    cItems: u32,
    aSidInfo: [1]SID_INFO,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEffectivePermission_Value = @import("../zig.zig").Guid.initString("3853dc76-9f35-407c-88a1-d19344365fbc");
pub const IID_IEffectivePermission = &IID_IEffectivePermission_Value;
pub const IEffectivePermission = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEffectivePermission: fn(
            self: *const IEffectivePermission,
            pguidObjectType: *const Guid,
            pUserSid: PSID,
            pszServerName: [*:0]const u16,
            pSD: *SECURITY_DESCRIPTOR,
            ppObjectTypeList: **OBJECT_TYPE_LIST,
            pcObjectTypeListLength: *u32,
            ppGrantedAccessList: **u32,
            pcGrantedAccessListLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEffectivePermission_GetEffectivePermission(self: *const T, pguidObjectType: *const Guid, pUserSid: PSID, pszServerName: [*:0]const u16, pSD: *SECURITY_DESCRIPTOR, ppObjectTypeList: **OBJECT_TYPE_LIST, pcObjectTypeListLength: *u32, ppGrantedAccessList: **u32, pcGrantedAccessListLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEffectivePermission.VTable, self.vtable).GetEffectivePermission(@ptrCast(*const IEffectivePermission, self), pguidObjectType, pUserSid, pszServerName, pSD, ppObjectTypeList, pcObjectTypeListLength, ppGrantedAccessList, pcGrantedAccessListLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISecurityObjectTypeInfo_Value = @import("../zig.zig").Guid.initString("fc3066eb-79ef-444b-9111-d18a75ebf2fa");
pub const IID_ISecurityObjectTypeInfo = &IID_ISecurityObjectTypeInfo_Value;
pub const ISecurityObjectTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInheritSource: fn(
            self: *const ISecurityObjectTypeInfo,
            si: u32,
            pACL: *ACL,
            ppInheritArray: **INHERITED_FROMA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityObjectTypeInfo_GetInheritSource(self: *const T, si: u32, pACL: *ACL, ppInheritArray: **INHERITED_FROMA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityObjectTypeInfo.VTable, self.vtable).GetInheritSource(@ptrCast(*const ISecurityObjectTypeInfo, self), si, pACL, ppInheritArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISecurityInformation3_Value = @import("../zig.zig").Guid.initString("e2cdc9cc-31bd-4f8f-8c8b-b641af516a1a");
pub const IID_ISecurityInformation3 = &IID_ISecurityInformation3_Value;
pub const ISecurityInformation3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFullResourceName: fn(
            self: *const ISecurityInformation3,
            ppszResourceName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenElevatedEditor: fn(
            self: *const ISecurityInformation3,
            hWnd: HWND,
            uPage: SI_PAGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation3_GetFullResourceName(self: *const T, ppszResourceName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation3.VTable, self.vtable).GetFullResourceName(@ptrCast(*const ISecurityInformation3, self), ppszResourceName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation3_OpenElevatedEditor(self: *const T, hWnd: HWND, uPage: SI_PAGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation3.VTable, self.vtable).OpenElevatedEditor(@ptrCast(*const ISecurityInformation3, self), hWnd, uPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SECURITY_OBJECT = extern struct {
    pwszName: PWSTR,
    pData: *c_void,
    cbData: u32,
    pData2: *c_void,
    cbData2: u32,
    Id: u32,
    fWellKnown: u8,
};

pub const EFFPERM_RESULT_LIST = extern struct {
    fEvaluated: u8,
    cObjectTypeListLength: u32,
    pObjectTypeList: *OBJECT_TYPE_LIST,
    pGrantedAccessList: *u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ISecurityInformation4_Value = @import("../zig.zig").Guid.initString("ea961070-cd14-4621-ace4-f63c03e583e4");
pub const IID_ISecurityInformation4 = &IID_ISecurityInformation4_Value;
pub const ISecurityInformation4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecondarySecurity: fn(
            self: *const ISecurityInformation4,
            pSecurityObjects: **SECURITY_OBJECT,
            pSecurityObjectCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInformation4_GetSecondarySecurity(self: *const T, pSecurityObjects: **SECURITY_OBJECT, pSecurityObjectCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInformation4.VTable, self.vtable).GetSecondarySecurity(@ptrCast(*const ISecurityInformation4, self), pSecurityObjects, pSecurityObjectCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IEffectivePermission2_Value = @import("../zig.zig").Guid.initString("941fabca-dd47-4fca-90bb-b0e10255f20d");
pub const IID_IEffectivePermission2 = &IID_IEffectivePermission2_Value;
pub const IEffectivePermission2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ComputeEffectivePermissionWithSecondarySecurity: fn(
            self: *const IEffectivePermission2,
            pSid: PSID,
            pDeviceSid: PSID,
            pszServerName: [*:0]const u16,
            pSecurityObjects: [*]SECURITY_OBJECT,
            dwSecurityObjectCount: u32,
            pUserGroups: ?*TOKEN_GROUPS,
            pAuthzUserGroupsOperations: ?*AUTHZ_SID_OPERATION,
            pDeviceGroups: ?*TOKEN_GROUPS,
            pAuthzDeviceGroupsOperations: ?*AUTHZ_SID_OPERATION,
            pAuthzUserClaims: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION,
            pAuthzUserClaimsOperations: ?*AUTHZ_SECURITY_ATTRIBUTE_OPERATION,
            pAuthzDeviceClaims: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION,
            pAuthzDeviceClaimsOperations: ?*AUTHZ_SECURITY_ATTRIBUTE_OPERATION,
            pEffpermResultLists: [*]EFFPERM_RESULT_LIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEffectivePermission2_ComputeEffectivePermissionWithSecondarySecurity(self: *const T, pSid: PSID, pDeviceSid: PSID, pszServerName: [*:0]const u16, pSecurityObjects: [*]SECURITY_OBJECT, dwSecurityObjectCount: u32, pUserGroups: ?*TOKEN_GROUPS, pAuthzUserGroupsOperations: ?*AUTHZ_SID_OPERATION, pDeviceGroups: ?*TOKEN_GROUPS, pAuthzDeviceGroupsOperations: ?*AUTHZ_SID_OPERATION, pAuthzUserClaims: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION, pAuthzUserClaimsOperations: ?*AUTHZ_SECURITY_ATTRIBUTE_OPERATION, pAuthzDeviceClaims: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION, pAuthzDeviceClaimsOperations: ?*AUTHZ_SECURITY_ATTRIBUTE_OPERATION, pEffpermResultLists: [*]EFFPERM_RESULT_LIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEffectivePermission2.VTable, self.vtable).ComputeEffectivePermissionWithSecondarySecurity(@ptrCast(*const IEffectivePermission2, self), pSid, pDeviceSid, pszServerName, pSecurityObjects, dwSecurityObjectCount, pUserGroups, pAuthzUserGroupsOperations, pDeviceGroups, pAuthzDeviceGroupsOperations, pAuthzUserClaims, pAuthzUserClaimsOperations, pAuthzDeviceClaims, pAuthzDeviceClaimsOperations, pEffpermResultLists);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FN_PROGRESS = fn(
    pObjectName: PWSTR,
    Status: u32,
    pInvokeSetting: *PROG_INVOKE_SETTING,
    Args: *c_void,
    SecuritySet: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNREADOBJECTSECURITY = fn(
    param0: [*:0]const u16,
    param1: u32,
    param2: **SECURITY_DESCRIPTOR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNWRITEOBJECTSECURITY = fn(
    param0: [*:0]const u16,
    param1: u32,
    param2: *SECURITY_DESCRIPTOR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATEISECINFO = fn(
    param0: [*:0]const u16,
    param1: [*:0]const u16,
    param2: u32,
    param3: **ISecurityInformation,
    param4: PFNREADOBJECTSECURITY,
    param5: PFNWRITEOBJECTSECURITY,
    param6: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATEISECINFOEX = fn(
    param0: [*:0]const u16,
    param1: [*:0]const u16,
    param2: [*:0]const u16,
    param3: [*:0]const u16,
    param4: [*:0]const u16,
    param5: u32,
    param6: **ISecurityInformation,
    param7: PFNREADOBJECTSECURITY,
    param8: PFNWRITEOBJECTSECURITY,
    param9: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATESECPAGE = fn(
    param0: [*:0]const u16,
    param1: [*:0]const u16,
    param2: u32,
    param3: *HPROPSHEETPAGE,
    param4: PFNREADOBJECTSECURITY,
    param5: PFNWRITEOBJECTSECURITY,
    param6: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSEDITSECURITY = fn(
    param0: HWND,
    param1: [*:0]const u16,
    param2: [*:0]const u16,
    param3: u32,
    param4: [*:0]const u16,
    param5: PFNREADOBJECTSECURITY,
    param6: PFNWRITEOBJECTSECURITY,
    param7: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

const CLSID_CObjectId_Value = @import("../zig.zig").Guid.initString("884e2000-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CObjectId = &CLSID_CObjectId_Value;

const CLSID_CObjectIds_Value = @import("../zig.zig").Guid.initString("884e2001-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CObjectIds = &CLSID_CObjectIds_Value;

const CLSID_CBinaryConverter_Value = @import("../zig.zig").Guid.initString("884e2002-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CBinaryConverter = &CLSID_CBinaryConverter_Value;

const CLSID_CX500DistinguishedName_Value = @import("../zig.zig").Guid.initString("884e2003-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX500DistinguishedName = &CLSID_CX500DistinguishedName_Value;

const CLSID_CCspInformation_Value = @import("../zig.zig").Guid.initString("884e2007-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCspInformation = &CLSID_CCspInformation_Value;

const CLSID_CCspInformations_Value = @import("../zig.zig").Guid.initString("884e2008-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCspInformations = &CLSID_CCspInformations_Value;

const CLSID_CCspStatus_Value = @import("../zig.zig").Guid.initString("884e2009-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCspStatus = &CLSID_CCspStatus_Value;

const CLSID_CX509PublicKey_Value = @import("../zig.zig").Guid.initString("884e200b-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509PublicKey = &CLSID_CX509PublicKey_Value;

const CLSID_CX509PrivateKey_Value = @import("../zig.zig").Guid.initString("884e200c-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509PrivateKey = &CLSID_CX509PrivateKey_Value;

const CLSID_CX509EndorsementKey_Value = @import("../zig.zig").Guid.initString("11a25a1d-b9a3-4edd-af83-3b59adbed361");
pub const CLSID_CX509EndorsementKey = &CLSID_CX509EndorsementKey_Value;

const CLSID_CX509Extension_Value = @import("../zig.zig").Guid.initString("884e200d-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509Extension = &CLSID_CX509Extension_Value;

const CLSID_CX509Extensions_Value = @import("../zig.zig").Guid.initString("884e200e-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509Extensions = &CLSID_CX509Extensions_Value;

const CLSID_CX509ExtensionKeyUsage_Value = @import("../zig.zig").Guid.initString("884e200f-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionKeyUsage = &CLSID_CX509ExtensionKeyUsage_Value;

const CLSID_CX509ExtensionEnhancedKeyUsage_Value = @import("../zig.zig").Guid.initString("884e2010-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionEnhancedKeyUsage = &CLSID_CX509ExtensionEnhancedKeyUsage_Value;

const CLSID_CX509ExtensionTemplateName_Value = @import("../zig.zig").Guid.initString("884e2011-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionTemplateName = &CLSID_CX509ExtensionTemplateName_Value;

const CLSID_CX509ExtensionTemplate_Value = @import("../zig.zig").Guid.initString("884e2012-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionTemplate = &CLSID_CX509ExtensionTemplate_Value;

const CLSID_CAlternativeName_Value = @import("../zig.zig").Guid.initString("884e2013-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CAlternativeName = &CLSID_CAlternativeName_Value;

const CLSID_CAlternativeNames_Value = @import("../zig.zig").Guid.initString("884e2014-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CAlternativeNames = &CLSID_CAlternativeNames_Value;

const CLSID_CX509ExtensionAlternativeNames_Value = @import("../zig.zig").Guid.initString("884e2015-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionAlternativeNames = &CLSID_CX509ExtensionAlternativeNames_Value;

const CLSID_CX509ExtensionBasicConstraints_Value = @import("../zig.zig").Guid.initString("884e2016-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionBasicConstraints = &CLSID_CX509ExtensionBasicConstraints_Value;

const CLSID_CX509ExtensionSubjectKeyIdentifier_Value = @import("../zig.zig").Guid.initString("884e2017-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionSubjectKeyIdentifier = &CLSID_CX509ExtensionSubjectKeyIdentifier_Value;

const CLSID_CX509ExtensionAuthorityKeyIdentifier_Value = @import("../zig.zig").Guid.initString("884e2018-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionAuthorityKeyIdentifier = &CLSID_CX509ExtensionAuthorityKeyIdentifier_Value;

const CLSID_CSmimeCapability_Value = @import("../zig.zig").Guid.initString("884e2019-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CSmimeCapability = &CLSID_CSmimeCapability_Value;

const CLSID_CSmimeCapabilities_Value = @import("../zig.zig").Guid.initString("884e201a-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CSmimeCapabilities = &CLSID_CSmimeCapabilities_Value;

const CLSID_CX509ExtensionSmimeCapabilities_Value = @import("../zig.zig").Guid.initString("884e201b-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionSmimeCapabilities = &CLSID_CX509ExtensionSmimeCapabilities_Value;

const CLSID_CPolicyQualifier_Value = @import("../zig.zig").Guid.initString("884e201c-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CPolicyQualifier = &CLSID_CPolicyQualifier_Value;

const CLSID_CPolicyQualifiers_Value = @import("../zig.zig").Guid.initString("884e201d-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CPolicyQualifiers = &CLSID_CPolicyQualifiers_Value;

const CLSID_CCertificatePolicy_Value = @import("../zig.zig").Guid.initString("884e201e-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertificatePolicy = &CLSID_CCertificatePolicy_Value;

const CLSID_CCertificatePolicies_Value = @import("../zig.zig").Guid.initString("884e201f-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertificatePolicies = &CLSID_CCertificatePolicies_Value;

const CLSID_CX509ExtensionCertificatePolicies_Value = @import("../zig.zig").Guid.initString("884e2020-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionCertificatePolicies = &CLSID_CX509ExtensionCertificatePolicies_Value;

const CLSID_CX509ExtensionMSApplicationPolicies_Value = @import("../zig.zig").Guid.initString("884e2021-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509ExtensionMSApplicationPolicies = &CLSID_CX509ExtensionMSApplicationPolicies_Value;

const CLSID_CX509Attribute_Value = @import("../zig.zig").Guid.initString("884e2022-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509Attribute = &CLSID_CX509Attribute_Value;

const CLSID_CX509Attributes_Value = @import("../zig.zig").Guid.initString("884e2023-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509Attributes = &CLSID_CX509Attributes_Value;

const CLSID_CX509AttributeExtensions_Value = @import("../zig.zig").Guid.initString("884e2024-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeExtensions = &CLSID_CX509AttributeExtensions_Value;

const CLSID_CX509AttributeClientId_Value = @import("../zig.zig").Guid.initString("884e2025-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeClientId = &CLSID_CX509AttributeClientId_Value;

const CLSID_CX509AttributeRenewalCertificate_Value = @import("../zig.zig").Guid.initString("884e2026-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeRenewalCertificate = &CLSID_CX509AttributeRenewalCertificate_Value;

const CLSID_CX509AttributeArchiveKey_Value = @import("../zig.zig").Guid.initString("884e2027-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeArchiveKey = &CLSID_CX509AttributeArchiveKey_Value;

const CLSID_CX509AttributeArchiveKeyHash_Value = @import("../zig.zig").Guid.initString("884e2028-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeArchiveKeyHash = &CLSID_CX509AttributeArchiveKeyHash_Value;

const CLSID_CX509AttributeOSVersion_Value = @import("../zig.zig").Guid.initString("884e202a-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeOSVersion = &CLSID_CX509AttributeOSVersion_Value;

const CLSID_CX509AttributeCspProvider_Value = @import("../zig.zig").Guid.initString("884e202b-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509AttributeCspProvider = &CLSID_CX509AttributeCspProvider_Value;

const CLSID_CCryptAttribute_Value = @import("../zig.zig").Guid.initString("884e202c-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCryptAttribute = &CLSID_CCryptAttribute_Value;

const CLSID_CCryptAttributes_Value = @import("../zig.zig").Guid.initString("884e202d-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCryptAttributes = &CLSID_CCryptAttributes_Value;

const CLSID_CCertProperty_Value = @import("../zig.zig").Guid.initString("884e202e-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertProperty = &CLSID_CCertProperty_Value;

const CLSID_CCertProperties_Value = @import("../zig.zig").Guid.initString("884e202f-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertProperties = &CLSID_CCertProperties_Value;

const CLSID_CCertPropertyFriendlyName_Value = @import("../zig.zig").Guid.initString("884e2030-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyFriendlyName = &CLSID_CCertPropertyFriendlyName_Value;

const CLSID_CCertPropertyDescription_Value = @import("../zig.zig").Guid.initString("884e2031-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyDescription = &CLSID_CCertPropertyDescription_Value;

const CLSID_CCertPropertyAutoEnroll_Value = @import("../zig.zig").Guid.initString("884e2032-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyAutoEnroll = &CLSID_CCertPropertyAutoEnroll_Value;

const CLSID_CCertPropertyRequestOriginator_Value = @import("../zig.zig").Guid.initString("884e2033-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyRequestOriginator = &CLSID_CCertPropertyRequestOriginator_Value;

const CLSID_CCertPropertySHA1Hash_Value = @import("../zig.zig").Guid.initString("884e2034-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertySHA1Hash = &CLSID_CCertPropertySHA1Hash_Value;

const CLSID_CCertPropertyKeyProvInfo_Value = @import("../zig.zig").Guid.initString("884e2036-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyKeyProvInfo = &CLSID_CCertPropertyKeyProvInfo_Value;

const CLSID_CCertPropertyArchived_Value = @import("../zig.zig").Guid.initString("884e2037-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyArchived = &CLSID_CCertPropertyArchived_Value;

const CLSID_CCertPropertyBackedUp_Value = @import("../zig.zig").Guid.initString("884e2038-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyBackedUp = &CLSID_CCertPropertyBackedUp_Value;

const CLSID_CCertPropertyEnrollment_Value = @import("../zig.zig").Guid.initString("884e2039-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyEnrollment = &CLSID_CCertPropertyEnrollment_Value;

const CLSID_CCertPropertyRenewal_Value = @import("../zig.zig").Guid.initString("884e203a-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyRenewal = &CLSID_CCertPropertyRenewal_Value;

const CLSID_CCertPropertyArchivedKeyHash_Value = @import("../zig.zig").Guid.initString("884e203b-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyArchivedKeyHash = &CLSID_CCertPropertyArchivedKeyHash_Value;

const CLSID_CCertPropertyEnrollmentPolicyServer_Value = @import("../zig.zig").Guid.initString("884e204c-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CCertPropertyEnrollmentPolicyServer = &CLSID_CCertPropertyEnrollmentPolicyServer_Value;

const CLSID_CSignerCertificate_Value = @import("../zig.zig").Guid.initString("884e203d-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CSignerCertificate = &CLSID_CSignerCertificate_Value;

const CLSID_CX509NameValuePair_Value = @import("../zig.zig").Guid.initString("884e203f-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509NameValuePair = &CLSID_CX509NameValuePair_Value;

const CLSID_CCertificateAttestationChallenge_Value = @import("../zig.zig").Guid.initString("1362ada1-eb60-456a-b6e1-118050db741b");
pub const CLSID_CCertificateAttestationChallenge = &CLSID_CCertificateAttestationChallenge_Value;

const CLSID_CX509CertificateRequestPkcs10_Value = @import("../zig.zig").Guid.initString("884e2042-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRequestPkcs10 = &CLSID_CX509CertificateRequestPkcs10_Value;

const CLSID_CX509CertificateRequestCertificate_Value = @import("../zig.zig").Guid.initString("884e2043-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRequestCertificate = &CLSID_CX509CertificateRequestCertificate_Value;

const CLSID_CX509CertificateRequestPkcs7_Value = @import("../zig.zig").Guid.initString("884e2044-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRequestPkcs7 = &CLSID_CX509CertificateRequestPkcs7_Value;

const CLSID_CX509CertificateRequestCmc_Value = @import("../zig.zig").Guid.initString("884e2045-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRequestCmc = &CLSID_CX509CertificateRequestCmc_Value;

const CLSID_CX509Enrollment_Value = @import("../zig.zig").Guid.initString("884e2046-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509Enrollment = &CLSID_CX509Enrollment_Value;

const CLSID_CX509EnrollmentWebClassFactory_Value = @import("../zig.zig").Guid.initString("884e2049-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509EnrollmentWebClassFactory = &CLSID_CX509EnrollmentWebClassFactory_Value;

const CLSID_CX509EnrollmentHelper_Value = @import("../zig.zig").Guid.initString("884e2050-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509EnrollmentHelper = &CLSID_CX509EnrollmentHelper_Value;

const CLSID_CX509MachineEnrollmentFactory_Value = @import("../zig.zig").Guid.initString("884e2051-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509MachineEnrollmentFactory = &CLSID_CX509MachineEnrollmentFactory_Value;

const CLSID_CX509EnrollmentPolicyActiveDirectory_Value = @import("../zig.zig").Guid.initString("91f39027-217f-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509EnrollmentPolicyActiveDirectory = &CLSID_CX509EnrollmentPolicyActiveDirectory_Value;

const CLSID_CX509EnrollmentPolicyWebService_Value = @import("../zig.zig").Guid.initString("91f39028-217f-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509EnrollmentPolicyWebService = &CLSID_CX509EnrollmentPolicyWebService_Value;

const CLSID_CX509PolicyServerListManager_Value = @import("../zig.zig").Guid.initString("91f39029-217f-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509PolicyServerListManager = &CLSID_CX509PolicyServerListManager_Value;

const CLSID_CX509PolicyServerUrl_Value = @import("../zig.zig").Guid.initString("91f3902a-217f-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509PolicyServerUrl = &CLSID_CX509PolicyServerUrl_Value;

const CLSID_CX509CertificateTemplateADWritable_Value = @import("../zig.zig").Guid.initString("8336e323-2e6a-4a04-937c-548f681839b3");
pub const CLSID_CX509CertificateTemplateADWritable = &CLSID_CX509CertificateTemplateADWritable_Value;

const CLSID_CX509CertificateRevocationListEntry_Value = @import("../zig.zig").Guid.initString("884e205e-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRevocationListEntry = &CLSID_CX509CertificateRevocationListEntry_Value;

const CLSID_CX509CertificateRevocationListEntries_Value = @import("../zig.zig").Guid.initString("884e205f-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRevocationListEntries = &CLSID_CX509CertificateRevocationListEntries_Value;

const CLSID_CX509CertificateRevocationList_Value = @import("../zig.zig").Guid.initString("884e2060-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509CertificateRevocationList = &CLSID_CX509CertificateRevocationList_Value;

const CLSID_CX509SCEPEnrollment_Value = @import("../zig.zig").Guid.initString("884e2061-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509SCEPEnrollment = &CLSID_CX509SCEPEnrollment_Value;

const CLSID_CX509SCEPEnrollmentHelper_Value = @import("../zig.zig").Guid.initString("884e2062-217d-11da-b2a4-000e7bbb2b09");
pub const CLSID_CX509SCEPEnrollmentHelper = &CLSID_CX509SCEPEnrollmentHelper_Value;

const CLSID_CCertGetConfig_Value = @import("../zig.zig").Guid.initString("c6cc49b0-ce17-11d0-8833-00a0c903b83c");
pub const CLSID_CCertGetConfig = &CLSID_CCertGetConfig_Value;

const CLSID_CCertConfig_Value = @import("../zig.zig").Guid.initString("372fce38-4324-11d0-8810-00a0c903b83c");
pub const CLSID_CCertConfig = &CLSID_CCertConfig_Value;

const CLSID_CCertRequest_Value = @import("../zig.zig").Guid.initString("98aff3f0-5524-11d0-8812-00a0c903b83c");
pub const CLSID_CCertRequest = &CLSID_CCertRequest_Value;

const CLSID_CCertServerPolicy_Value = @import("../zig.zig").Guid.initString("aa000926-ffbe-11cf-8800-00a0c903b83c");
pub const CLSID_CCertServerPolicy = &CLSID_CCertServerPolicy_Value;

const CLSID_CCertServerExit_Value = @import("../zig.zig").Guid.initString("4c4a5e40-732c-11d0-8816-00a0c903b83c");
pub const CLSID_CCertServerExit = &CLSID_CCertServerExit_Value;

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertServerPolicy_Value = @import("../zig.zig").Guid.initString("aa000922-ffbe-11cf-8800-00a0c903b83c");
pub const IID_ICertServerPolicy = &IID_ICertServerPolicy_Value;
pub const ICertServerPolicy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetContext: fn(
            self: *const ICertServerPolicy,
            Context: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestProperty: fn(
            self: *const ICertServerPolicy,
            strPropertyName: BSTR,
            PropertyType: i32,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestAttribute: fn(
            self: *const ICertServerPolicy,
            strAttributeName: BSTR,
            pstrAttributeValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateProperty: fn(
            self: *const ICertServerPolicy,
            strPropertyName: BSTR,
            PropertyType: CERT_PROPERTY_TYPE,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCertificateProperty: fn(
            self: *const ICertServerPolicy,
            strPropertyName: BSTR,
            PropertyType: i32,
            pvarPropertyValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateExtension: fn(
            self: *const ICertServerPolicy,
            strExtensionName: BSTR,
            Type: CERT_PROPERTY_TYPE,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateExtensionFlags: fn(
            self: *const ICertServerPolicy,
            pExtFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCertificateExtension: fn(
            self: *const ICertServerPolicy,
            strExtensionName: BSTR,
            Type: i32,
            ExtFlags: i32,
            pvarValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensionsSetup: fn(
            self: *const ICertServerPolicy,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensions: fn(
            self: *const ICertServerPolicy,
            pstrExtensionName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensionsClose: fn(
            self: *const ICertServerPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributesSetup: fn(
            self: *const ICertServerPolicy,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributes: fn(
            self: *const ICertServerPolicy,
            pstrAttributeName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributesClose: fn(
            self: *const ICertServerPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_SetContext(self: *const T, Context: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).SetContext(@ptrCast(*const ICertServerPolicy, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_GetRequestProperty(self: *const T, strPropertyName: BSTR, PropertyType: i32, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).GetRequestProperty(@ptrCast(*const ICertServerPolicy, self), strPropertyName, PropertyType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_GetRequestAttribute(self: *const T, strAttributeName: BSTR, pstrAttributeValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).GetRequestAttribute(@ptrCast(*const ICertServerPolicy, self), strAttributeName, pstrAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_GetCertificateProperty(self: *const T, strPropertyName: BSTR, PropertyType: CERT_PROPERTY_TYPE, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).GetCertificateProperty(@ptrCast(*const ICertServerPolicy, self), strPropertyName, PropertyType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_SetCertificateProperty(self: *const T, strPropertyName: BSTR, PropertyType: i32, pvarPropertyValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).SetCertificateProperty(@ptrCast(*const ICertServerPolicy, self), strPropertyName, PropertyType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_GetCertificateExtension(self: *const T, strExtensionName: BSTR, Type: CERT_PROPERTY_TYPE, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).GetCertificateExtension(@ptrCast(*const ICertServerPolicy, self), strExtensionName, Type, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_GetCertificateExtensionFlags(self: *const T, pExtFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).GetCertificateExtensionFlags(@ptrCast(*const ICertServerPolicy, self), pExtFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_SetCertificateExtension(self: *const T, strExtensionName: BSTR, Type: i32, ExtFlags: i32, pvarValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).SetCertificateExtension(@ptrCast(*const ICertServerPolicy, self), strExtensionName, Type, ExtFlags, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateExtensionsSetup(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateExtensionsSetup(@ptrCast(*const ICertServerPolicy, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateExtensions(self: *const T, pstrExtensionName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateExtensions(@ptrCast(*const ICertServerPolicy, self), pstrExtensionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateExtensionsClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateExtensionsClose(@ptrCast(*const ICertServerPolicy, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateAttributesSetup(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateAttributesSetup(@ptrCast(*const ICertServerPolicy, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateAttributes(self: *const T, pstrAttributeName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateAttributes(@ptrCast(*const ICertServerPolicy, self), pstrAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerPolicy_EnumerateAttributesClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerPolicy.VTable, self.vtable).EnumerateAttributesClose(@ptrCast(*const ICertServerPolicy, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertServerExit_Value = @import("../zig.zig").Guid.initString("4ba9eb90-732c-11d0-8816-00a0c903b83c");
pub const IID_ICertServerExit = &IID_ICertServerExit_Value;
pub const ICertServerExit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetContext: fn(
            self: *const ICertServerExit,
            Context: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestProperty: fn(
            self: *const ICertServerExit,
            strPropertyName: BSTR,
            PropertyType: i32,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestAttribute: fn(
            self: *const ICertServerExit,
            strAttributeName: BSTR,
            pstrAttributeValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateProperty: fn(
            self: *const ICertServerExit,
            strPropertyName: BSTR,
            PropertyType: i32,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateExtension: fn(
            self: *const ICertServerExit,
            strExtensionName: BSTR,
            Type: i32,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateExtensionFlags: fn(
            self: *const ICertServerExit,
            pExtFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensionsSetup: fn(
            self: *const ICertServerExit,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensions: fn(
            self: *const ICertServerExit,
            pstrExtensionName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExtensionsClose: fn(
            self: *const ICertServerExit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributesSetup: fn(
            self: *const ICertServerExit,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributes: fn(
            self: *const ICertServerExit,
            pstrAttributeName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateAttributesClose: fn(
            self: *const ICertServerExit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_SetContext(self: *const T, Context: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).SetContext(@ptrCast(*const ICertServerExit, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_GetRequestProperty(self: *const T, strPropertyName: BSTR, PropertyType: i32, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).GetRequestProperty(@ptrCast(*const ICertServerExit, self), strPropertyName, PropertyType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_GetRequestAttribute(self: *const T, strAttributeName: BSTR, pstrAttributeValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).GetRequestAttribute(@ptrCast(*const ICertServerExit, self), strAttributeName, pstrAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_GetCertificateProperty(self: *const T, strPropertyName: BSTR, PropertyType: i32, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).GetCertificateProperty(@ptrCast(*const ICertServerExit, self), strPropertyName, PropertyType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_GetCertificateExtension(self: *const T, strExtensionName: BSTR, Type: i32, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).GetCertificateExtension(@ptrCast(*const ICertServerExit, self), strExtensionName, Type, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_GetCertificateExtensionFlags(self: *const T, pExtFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).GetCertificateExtensionFlags(@ptrCast(*const ICertServerExit, self), pExtFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateExtensionsSetup(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateExtensionsSetup(@ptrCast(*const ICertServerExit, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateExtensions(self: *const T, pstrExtensionName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateExtensions(@ptrCast(*const ICertServerExit, self), pstrExtensionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateExtensionsClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateExtensionsClose(@ptrCast(*const ICertServerExit, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateAttributesSetup(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateAttributesSetup(@ptrCast(*const ICertServerExit, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateAttributes(self: *const T, pstrAttributeName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateAttributes(@ptrCast(*const ICertServerExit, self), pstrAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertServerExit_EnumerateAttributesClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertServerExit.VTable, self.vtable).EnumerateAttributesClose(@ptrCast(*const ICertServerExit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertGetConfig_Value = @import("../zig.zig").Guid.initString("c7ea09c0-ce17-11d0-8833-00a0c903b83c");
pub const IID_ICertGetConfig = &IID_ICertGetConfig_Value;
pub const ICertGetConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetConfig: fn(
            self: *const ICertGetConfig,
            Flags: CERT_GET_CONFIG_FLAGS,
            pstrOut: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertGetConfig_GetConfig(self: *const T, Flags: CERT_GET_CONFIG_FLAGS, pstrOut: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertGetConfig.VTable, self.vtable).GetConfig(@ptrCast(*const ICertGetConfig, self), Flags, pstrOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertConfig_Value = @import("../zig.zig").Guid.initString("372fce34-4324-11d0-8810-00a0c903b83c");
pub const IID_ICertConfig = &IID_ICertConfig_Value;
pub const ICertConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Reset: fn(
            self: *const ICertConfig,
            Index: i32,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const ICertConfig,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetField: fn(
            self: *const ICertConfig,
            strFieldName: BSTR,
            pstrOut: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfig: fn(
            self: *const ICertConfig,
            Flags: i32,
            pstrOut: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertConfig_Reset(self: *const T, Index: i32, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertConfig.VTable, self.vtable).Reset(@ptrCast(*const ICertConfig, self), Index, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertConfig_Next(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertConfig.VTable, self.vtable).Next(@ptrCast(*const ICertConfig, self), pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertConfig_GetField(self: *const T, strFieldName: BSTR, pstrOut: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertConfig.VTable, self.vtable).GetField(@ptrCast(*const ICertConfig, self), strFieldName, pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertConfig_GetConfig(self: *const T, Flags: i32, pstrOut: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertConfig.VTable, self.vtable).GetConfig(@ptrCast(*const ICertConfig, self), Flags, pstrOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertConfig2_Value = @import("../zig.zig").Guid.initString("7a18edde-7e78-4163-8ded-78e2c9cee924");
pub const IID_ICertConfig2 = &IID_ICertConfig2_Value;
pub const ICertConfig2 = extern struct {
    pub const VTable = extern struct {
        base: ICertConfig.VTable,
        SetSharedFolder: fn(
            self: *const ICertConfig2,
            strSharedFolder: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertConfig2_SetSharedFolder(self: *const T, strSharedFolder: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertConfig2.VTable, self.vtable).SetSharedFolder(@ptrCast(*const ICertConfig2, self), strSharedFolder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICertRequest_Value = @import("../zig.zig").Guid.initString("014e4840-5523-11d0-8812-00a0c903b83c");
pub const IID_ICertRequest = &IID_ICertRequest_Value;
pub const ICertRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Submit: fn(
            self: *const ICertRequest,
            Flags: i32,
            strRequest: BSTR,
            strAttributes: BSTR,
            strConfig: BSTR,
            pDisposition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RetrievePending: fn(
            self: *const ICertRequest,
            RequestId: i32,
            strConfig: BSTR,
            pDisposition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastStatus: fn(
            self: *const ICertRequest,
            pStatus: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestId: fn(
            self: *const ICertRequest,
            pRequestId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDispositionMessage: fn(
            self: *const ICertRequest,
            pstrDispositionMessage: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCACertificate: fn(
            self: *const ICertRequest,
            fExchangeCertificate: i32,
            strConfig: BSTR,
            Flags: i32,
            pstrCertificate: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificate: fn(
            self: *const ICertRequest,
            Flags: i32,
            pstrCertificate: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_Submit(self: *const T, Flags: i32, strRequest: BSTR, strAttributes: BSTR, strConfig: BSTR, pDisposition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).Submit(@ptrCast(*const ICertRequest, self), Flags, strRequest, strAttributes, strConfig, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_RetrievePending(self: *const T, RequestId: i32, strConfig: BSTR, pDisposition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).RetrievePending(@ptrCast(*const ICertRequest, self), RequestId, strConfig, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_GetLastStatus(self: *const T, pStatus: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).GetLastStatus(@ptrCast(*const ICertRequest, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_GetRequestId(self: *const T, pRequestId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).GetRequestId(@ptrCast(*const ICertRequest, self), pRequestId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_GetDispositionMessage(self: *const T, pstrDispositionMessage: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).GetDispositionMessage(@ptrCast(*const ICertRequest, self), pstrDispositionMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_GetCACertificate(self: *const T, fExchangeCertificate: i32, strConfig: BSTR, Flags: i32, pstrCertificate: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).GetCACertificate(@ptrCast(*const ICertRequest, self), fExchangeCertificate, strConfig, Flags, pstrCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest_GetCertificate(self: *const T, Flags: i32, pstrCertificate: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest.VTable, self.vtable).GetCertificate(@ptrCast(*const ICertRequest, self), Flags, pstrCertificate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICertRequest2_Value = @import("../zig.zig").Guid.initString("a4772988-4a85-4fa9-824e-b5cf5c16405a");
pub const IID_ICertRequest2 = &IID_ICertRequest2_Value;
pub const ICertRequest2 = extern struct {
    pub const VTable = extern struct {
        base: ICertRequest.VTable,
        GetIssuedCertificate: fn(
            self: *const ICertRequest2,
            strConfig: BSTR,
            RequestId: i32,
            strSerialNumber: BSTR,
            pDisposition: *CR_DISP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorMessageText: fn(
            self: *const ICertRequest2,
            hrMessage: i32,
            Flags: i32,
            pstrErrorMessageText: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAProperty: fn(
            self: *const ICertRequest2,
            strConfig: BSTR,
            PropId: i32,
            PropIndex: i32,
            PropType: i32,
            Flags: i32,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPropertyFlags: fn(
            self: *const ICertRequest2,
            strConfig: BSTR,
            PropId: i32,
            pPropFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPropertyDisplayName: fn(
            self: *const ICertRequest2,
            strConfig: BSTR,
            PropId: i32,
            pstrDisplayName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullResponseProperty: fn(
            self: *const ICertRequest2,
            PropId: FULL_RESPONSE_PROPERTY_ID,
            PropIndex: i32,
            PropType: CERT_PROPERTY_TYPE,
            Flags: CERT_REQUEST_OUT_TYPE,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetIssuedCertificate(self: *const T, strConfig: BSTR, RequestId: i32, strSerialNumber: BSTR, pDisposition: *CR_DISP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetIssuedCertificate(@ptrCast(*const ICertRequest2, self), strConfig, RequestId, strSerialNumber, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetErrorMessageText(self: *const T, hrMessage: i32, Flags: i32, pstrErrorMessageText: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetErrorMessageText(@ptrCast(*const ICertRequest2, self), hrMessage, Flags, pstrErrorMessageText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetCAProperty(self: *const T, strConfig: BSTR, PropId: i32, PropIndex: i32, PropType: i32, Flags: i32, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetCAProperty(@ptrCast(*const ICertRequest2, self), strConfig, PropId, PropIndex, PropType, Flags, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetCAPropertyFlags(self: *const T, strConfig: BSTR, PropId: i32, pPropFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetCAPropertyFlags(@ptrCast(*const ICertRequest2, self), strConfig, PropId, pPropFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetCAPropertyDisplayName(self: *const T, strConfig: BSTR, PropId: i32, pstrDisplayName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetCAPropertyDisplayName(@ptrCast(*const ICertRequest2, self), strConfig, PropId, pstrDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest2_GetFullResponseProperty(self: *const T, PropId: FULL_RESPONSE_PROPERTY_ID, PropIndex: i32, PropType: CERT_PROPERTY_TYPE, Flags: CERT_REQUEST_OUT_TYPE, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest2.VTable, self.vtable).GetFullResponseProperty(@ptrCast(*const ICertRequest2, self), PropId, PropIndex, PropType, Flags, pvarPropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509EnrollmentAuthFlags = extern enum(i32) {
    None = 0,
    Anonymous = 1,
    Kerberos = 2,
    Username = 4,
    Certificate = 8,
};
pub const X509AuthNone = X509EnrollmentAuthFlags.None;
pub const X509AuthAnonymous = X509EnrollmentAuthFlags.Anonymous;
pub const X509AuthKerberos = X509EnrollmentAuthFlags.Kerberos;
pub const X509AuthUsername = X509EnrollmentAuthFlags.Username;
pub const X509AuthCertificate = X509EnrollmentAuthFlags.Certificate;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertRequest3_Value = @import("../zig.zig").Guid.initString("afc8f92b-33a2-4861-bf36-2933b7cd67b3");
pub const IID_ICertRequest3 = &IID_ICertRequest3_Value;
pub const ICertRequest3 = extern struct {
    pub const VTable = extern struct {
        base: ICertRequest2.VTable,
        SetCredential: fn(
            self: *const ICertRequest3,
            hWnd: i32,
            AuthType: X509EnrollmentAuthFlags,
            strCredential: BSTR,
            strPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestIdString: fn(
            self: *const ICertRequest3,
            pstrRequestId: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIssuedCertificate2: fn(
            self: *const ICertRequest3,
            strConfig: BSTR,
            strRequestId: BSTR,
            strSerialNumber: BSTR,
            pDisposition: *CR_DISP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefreshPolicy: fn(
            self: *const ICertRequest3,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertRequest2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest3_SetCredential(self: *const T, hWnd: i32, AuthType: X509EnrollmentAuthFlags, strCredential: BSTR, strPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest3.VTable, self.vtable).SetCredential(@ptrCast(*const ICertRequest3, self), hWnd, AuthType, strCredential, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest3_GetRequestIdString(self: *const T, pstrRequestId: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest3.VTable, self.vtable).GetRequestIdString(@ptrCast(*const ICertRequest3, self), pstrRequestId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest3_GetIssuedCertificate2(self: *const T, strConfig: BSTR, strRequestId: BSTR, strSerialNumber: BSTR, pDisposition: *CR_DISP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest3.VTable, self.vtable).GetIssuedCertificate2(@ptrCast(*const ICertRequest3, self), strConfig, strRequestId, strSerialNumber, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertRequest3_GetRefreshPolicy(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertRequest3.VTable, self.vtable).GetRefreshPolicy(@ptrCast(*const ICertRequest3, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertManageModule_Value = @import("../zig.zig").Guid.initString("e7d7ad42-bd3d-11d1-9a4d-00c04fc297eb");
pub const IID_ICertManageModule = &IID_ICertManageModule_Value;
pub const ICertManageModule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetProperty: fn(
            self: *const ICertManageModule,
            strConfig: BSTR,
            strStorageLocation: BSTR,
            strPropertyName: BSTR,
            Flags: i32,
            pvarProperty: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertManageModule,
            strConfig: BSTR,
            strStorageLocation: BSTR,
            strPropertyName: BSTR,
            Flags: i32,
            pvarProperty: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: fn(
            self: *const ICertManageModule,
            strConfig: BSTR,
            strStorageLocation: BSTR,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertManageModule_GetProperty(self: *const T, strConfig: BSTR, strStorageLocation: BSTR, strPropertyName: BSTR, Flags: i32, pvarProperty: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertManageModule.VTable, self.vtable).GetProperty(@ptrCast(*const ICertManageModule, self), strConfig, strStorageLocation, strPropertyName, Flags, pvarProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertManageModule_SetProperty(self: *const T, strConfig: BSTR, strStorageLocation: BSTR, strPropertyName: BSTR, Flags: i32, pvarProperty: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertManageModule.VTable, self.vtable).SetProperty(@ptrCast(*const ICertManageModule, self), strConfig, strStorageLocation, strPropertyName, Flags, pvarProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertManageModule_Configure(self: *const T, strConfig: BSTR, strStorageLocation: BSTR, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertManageModule.VTable, self.vtable).Configure(@ptrCast(*const ICertManageModule, self), strConfig, strStorageLocation, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CERTTRANSBLOB = extern struct {
    cb: u32,
    pb: *u8,
};

pub const CERTVIEWRESTRICTION = extern struct {
    ColumnIndex: u32,
    SeekOperator: i32,
    SortOrder: i32,
    pbValue: *u8,
    cbValue: u32,
};

pub const CSEDB_RSTMAPW = extern struct {
    pwszDatabaseName: PWSTR,
    pwszNewDatabaseName: PWSTR,
};

pub const FNCERTSRVISSERVERONLINEW = fn(
    pwszServerName: [*:0]const u16,
    pfServerOnline: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPGETDYNAMICFILELISTW = fn(
    hbc: *c_void,
    ppwszzFileList: **u16,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPPREPAREW = fn(
    pwszServerName: [*:0]const u16,
    grbitJet: u32,
    dwBackupFlags: u32,
    phbc: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPGETDATABASENAMESW = fn(
    hbc: *c_void,
    ppwszzAttachmentInformation: **u16,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPOPENFILEW = fn(
    hbc: *c_void,
    pwszAttachmentName: [*:0]const u16,
    cbReadHintSize: u32,
    pliFileSize: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPREAD = fn(
    hbc: *c_void,
    pvBuffer: *c_void,
    cbBuffer: u32,
    pcbRead: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPCLOSE = fn(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPGETBACKUPLOGSW = fn(
    hbc: *c_void,
    ppwszzBackupLogFiles: **u16,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPTRUNCATELOGS = fn(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPEND = fn(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVBACKUPFREE = fn(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const FNCERTSRVRESTOREGETDATABASELOCATIONSW = fn(
    hbc: *c_void,
    ppwszzDatabaseLocationList: **u16,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVRESTOREPREPAREW = fn(
    pwszServerName: [*:0]const u16,
    dwRestoreFlags: u32,
    phbc: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVRESTOREREGISTERW = fn(
    hbc: *c_void,
    pwszCheckPointFilePath: [*:0]const u16,
    pwszLogPath: [*:0]const u16,
    rgrstmap: *CSEDB_RSTMAPW,
    crstmap: i32,
    pwszBackupLogPath: [*:0]const u16,
    genLow: u32,
    genHigh: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVRESTOREREGISTERCOMPLETE = fn(
    hbc: *c_void,
    hrRestoreState: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVRESTOREEND = fn(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNCERTSRVSERVERCONTROLW = fn(
    pwszServerName: [*:0]const u16,
    dwControlFlags: u32,
    pcbOut: *u32,
    ppbOut: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertPolicy_Value = @import("../zig.zig").Guid.initString("38bb5a00-7636-11d0-b413-00a0c91bbf8c");
pub const IID_ICertPolicy = &IID_ICertPolicy_Value;
pub const ICertPolicy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ICertPolicy,
            strConfig: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VerifyRequest: fn(
            self: *const ICertPolicy,
            strConfig: BSTR,
            Context: i32,
            bNewRequest: i32,
            Flags: i32,
            pDisposition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const ICertPolicy,
            pstrDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutDown: fn(
            self: *const ICertPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPolicy_Initialize(self: *const T, strConfig: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPolicy.VTable, self.vtable).Initialize(@ptrCast(*const ICertPolicy, self), strConfig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPolicy_VerifyRequest(self: *const T, strConfig: BSTR, Context: i32, bNewRequest: i32, Flags: i32, pDisposition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPolicy.VTable, self.vtable).VerifyRequest(@ptrCast(*const ICertPolicy, self), strConfig, Context, bNewRequest, Flags, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPolicy_GetDescription(self: *const T, pstrDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPolicy.VTable, self.vtable).GetDescription(@ptrCast(*const ICertPolicy, self), pstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPolicy_ShutDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPolicy.VTable, self.vtable).ShutDown(@ptrCast(*const ICertPolicy, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertPolicy2_Value = @import("../zig.zig").Guid.initString("3db4910e-8001-4bf1-aa1b-f43a808317a0");
pub const IID_ICertPolicy2 = &IID_ICertPolicy2_Value;
pub const ICertPolicy2 = extern struct {
    pub const VTable = extern struct {
        base: ICertPolicy.VTable,
        GetManageModule: fn(
            self: *const ICertPolicy2,
            ppManageModule: **ICertManageModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertPolicy.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPolicy2_GetManageModule(self: *const T, ppManageModule: **ICertManageModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPolicy2.VTable, self.vtable).GetManageModule(@ptrCast(*const ICertPolicy2, self), ppManageModule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509SCEPMessageType = extern enum(i32) {
    Unknown = -1,
    CertResponse = 3,
    PKCSRequest = 19,
    GetCertInitial = 20,
    GetCert = 21,
    GetCRL = 22,
    ClaimChallengeAnswer = 41,
};
pub const SCEPMessageUnknown = X509SCEPMessageType.Unknown;
pub const SCEPMessageCertResponse = X509SCEPMessageType.CertResponse;
pub const SCEPMessagePKCSRequest = X509SCEPMessageType.PKCSRequest;
pub const SCEPMessageGetCertInitial = X509SCEPMessageType.GetCertInitial;
pub const SCEPMessageGetCert = X509SCEPMessageType.GetCert;
pub const SCEPMessageGetCRL = X509SCEPMessageType.GetCRL;
pub const SCEPMessageClaimChallengeAnswer = X509SCEPMessageType.ClaimChallengeAnswer;

pub const X509SCEPDisposition = extern enum(i32) {
    Unknown = -1,
    Success = 0,
    Failure = 2,
    Pending = 3,
    PendingChallenge = 11,
};
pub const SCEPDispositionUnknown = X509SCEPDisposition.Unknown;
pub const SCEPDispositionSuccess = X509SCEPDisposition.Success;
pub const SCEPDispositionFailure = X509SCEPDisposition.Failure;
pub const SCEPDispositionPending = X509SCEPDisposition.Pending;
pub const SCEPDispositionPendingChallenge = X509SCEPDisposition.PendingChallenge;

pub const X509SCEPFailInfo = extern enum(i32) {
    Unknown = -1,
    BadAlgorithm = 0,
    BadMessageCheck = 1,
    BadRequest = 2,
    BadTime = 3,
    BadCertId = 4,
};
pub const SCEPFailUnknown = X509SCEPFailInfo.Unknown;
pub const SCEPFailBadAlgorithm = X509SCEPFailInfo.BadAlgorithm;
pub const SCEPFailBadMessageCheck = X509SCEPFailInfo.BadMessageCheck;
pub const SCEPFailBadRequest = X509SCEPFailInfo.BadRequest;
pub const SCEPFailBadTime = X509SCEPFailInfo.BadTime;
pub const SCEPFailBadCertId = X509SCEPFailInfo.BadCertId;

const IID_INDESPolicy_Value = @import("../zig.zig").Guid.initString("13ca515d-431d-46cc-8c2e-1da269bbd625");
pub const IID_INDESPolicy = &IID_INDESPolicy_Value;
pub const INDESPolicy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const INDESPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: fn(
            self: *const INDESPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateChallenge: fn(
            self: *const INDESPolicy,
            pwszTemplate: [*:0]const u16,
            pwszParams: [*:0]const u16,
            ppwszResponse: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VerifyRequest: fn(
            self: *const INDESPolicy,
            pctbRequest: *CERTTRANSBLOB,
            pctbSigningCertEncoded: *CERTTRANSBLOB,
            pwszTemplate: [*:0]const u16,
            pwszTransactionId: [*:0]const u16,
            pfVerified: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const INDESPolicy,
            pwszChallenge: [*:0]const u16,
            pwszTransactionId: [*:0]const u16,
            disposition: X509SCEPDisposition,
            lastHResult: i32,
            pctbIssuedCertEncoded: *CERTTRANSBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INDESPolicy_Initialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INDESPolicy.VTable, self.vtable).Initialize(@ptrCast(*const INDESPolicy, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INDESPolicy_Uninitialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INDESPolicy.VTable, self.vtable).Uninitialize(@ptrCast(*const INDESPolicy, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INDESPolicy_GenerateChallenge(self: *const T, pwszTemplate: [*:0]const u16, pwszParams: [*:0]const u16, ppwszResponse: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INDESPolicy.VTable, self.vtable).GenerateChallenge(@ptrCast(*const INDESPolicy, self), pwszTemplate, pwszParams, ppwszResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INDESPolicy_VerifyRequest(self: *const T, pctbRequest: *CERTTRANSBLOB, pctbSigningCertEncoded: *CERTTRANSBLOB, pwszTemplate: [*:0]const u16, pwszTransactionId: [*:0]const u16, pfVerified: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INDESPolicy.VTable, self.vtable).VerifyRequest(@ptrCast(*const INDESPolicy, self), pctbRequest, pctbSigningCertEncoded, pwszTemplate, pwszTransactionId, pfVerified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INDESPolicy_Notify(self: *const T, pwszChallenge: [*:0]const u16, pwszTransactionId: [*:0]const u16, disposition: X509SCEPDisposition, lastHResult: i32, pctbIssuedCertEncoded: *CERTTRANSBLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const INDESPolicy.VTable, self.vtable).Notify(@ptrCast(*const INDESPolicy, self), pwszChallenge, pwszTransactionId, disposition, lastHResult, pctbIssuedCertEncoded);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CERTENROLL_OBJECTID = extern enum(i32) {
    _NONE = 0,
    _RSA = 1,
    _PKCS = 2,
    _RSA_HASH = 3,
    _RSA_ENCRYPT = 4,
    _PKCS_1 = 5,
    _PKCS_2 = 6,
    _PKCS_3 = 7,
    _PKCS_4 = 8,
    _PKCS_5 = 9,
    _PKCS_6 = 10,
    _PKCS_7 = 11,
    _PKCS_8 = 12,
    _PKCS_9 = 13,
    _PKCS_10 = 14,
    _PKCS_12 = 15,
    _RSA_RSA = 16,
    _RSA_MD2RSA = 17,
    _RSA_MD4RSA = 18,
    _RSA_MD5RSA = 19,
    _RSA_SHA1RSA = 20,
    _RSA_SETOAEP_RSA = 21,
    _RSA_DH = 22,
    _RSA_data = 23,
    _RSA_signedData = 24,
    _RSA_envelopedData = 25,
    _RSA_signEnvData = 26,
    _RSA_digestedData = 27,
    _RSA_hashedData = 28,
    _RSA_encryptedData = 29,
    _RSA_emailAddr = 30,
    _RSA_unstructName = 31,
    _RSA_contentType = 32,
    _RSA_messageDigest = 33,
    _RSA_signingTime = 34,
    _RSA_counterSign = 35,
    _RSA_challengePwd = 36,
    _RSA_unstructAddr = 37,
    _RSA_extCertAttrs = 38,
    _RSA_certExtensions = 39,
    _RSA_SMIMECapabilities = 40,
    _RSA_preferSignedData = 41,
    _RSA_SMIMEalg = 42,
    _RSA_SMIMEalgESDH = 43,
    _RSA_SMIMEalgCMS3DESwrap = 44,
    _RSA_SMIMEalgCMSRC2wrap = 45,
    _RSA_MD2 = 46,
    _RSA_MD4 = 47,
    _RSA_MD5 = 48,
    _RSA_RC2CBC = 49,
    _RSA_RC4 = 50,
    _RSA_DES_EDE3_CBC = 51,
    _RSA_RC5_CBCPad = 52,
    _ANSI_X942 = 53,
    _ANSI_X942_DH = 54,
    _X957 = 55,
    _X957_DSA = 56,
    _X957_SHA1DSA = 57,
    _DS = 58,
    _DSALG = 59,
    _DSALG_CRPT = 60,
    _DSALG_HASH = 61,
    _DSALG_SIGN = 62,
    _DSALG_RSA = 63,
    _OIW = 64,
    _OIWSEC = 65,
    _OIWSEC_md4RSA = 66,
    _OIWSEC_md5RSA = 67,
    _OIWSEC_md4RSA2 = 68,
    _OIWSEC_desECB = 69,
    _OIWSEC_desCBC = 70,
    _OIWSEC_desOFB = 71,
    _OIWSEC_desCFB = 72,
    _OIWSEC_desMAC = 73,
    _OIWSEC_rsaSign = 74,
    _OIWSEC_dsa = 75,
    _OIWSEC_shaDSA = 76,
    _OIWSEC_mdc2RSA = 77,
    _OIWSEC_shaRSA = 78,
    _OIWSEC_dhCommMod = 79,
    _OIWSEC_desEDE = 80,
    _OIWSEC_sha = 81,
    _OIWSEC_mdc2 = 82,
    _OIWSEC_dsaComm = 83,
    _OIWSEC_dsaCommSHA = 84,
    _OIWSEC_rsaXchg = 85,
    _OIWSEC_keyHashSeal = 86,
    _OIWSEC_md2RSASign = 87,
    _OIWSEC_md5RSASign = 88,
    _OIWSEC_sha1 = 89,
    _OIWSEC_dsaSHA1 = 90,
    _OIWSEC_dsaCommSHA1 = 91,
    _OIWSEC_sha1RSASign = 92,
    _OIWDIR = 93,
    _OIWDIR_CRPT = 94,
    _OIWDIR_HASH = 95,
    _OIWDIR_SIGN = 96,
    _OIWDIR_md2 = 97,
    _OIWDIR_md2RSA = 98,
    _INFOSEC = 99,
    _INFOSEC_sdnsSignature = 100,
    _INFOSEC_mosaicSignature = 101,
    _INFOSEC_sdnsConfidentiality = 102,
    _INFOSEC_mosaicConfidentiality = 103,
    _INFOSEC_sdnsIntegrity = 104,
    _INFOSEC_mosaicIntegrity = 105,
    _INFOSEC_sdnsTokenProtection = 106,
    _INFOSEC_mosaicTokenProtection = 107,
    _INFOSEC_sdnsKeyManagement = 108,
    _INFOSEC_mosaicKeyManagement = 109,
    _INFOSEC_sdnsKMandSig = 110,
    _INFOSEC_mosaicKMandSig = 111,
    _INFOSEC_SuiteASignature = 112,
    _INFOSEC_SuiteAConfidentiality = 113,
    _INFOSEC_SuiteAIntegrity = 114,
    _INFOSEC_SuiteATokenProtection = 115,
    _INFOSEC_SuiteAKeyManagement = 116,
    _INFOSEC_SuiteAKMandSig = 117,
    _INFOSEC_mosaicUpdatedSig = 118,
    _INFOSEC_mosaicKMandUpdSig = 119,
    _INFOSEC_mosaicUpdatedInteg = 120,
    _COMMON_NAME = 121,
    _SUR_NAME = 122,
    _DEVICE_SERIAL_NUMBER = 123,
    _COUNTRY_NAME = 124,
    _LOCALITY_NAME = 125,
    _STATE_OR_PROVINCE_NAME = 126,
    _STREET_ADDRESS = 127,
    _ORGANIZATION_NAME = 128,
    _ORGANIZATIONAL_UNIT_NAME = 129,
    _TITLE = 130,
    _DESCRIPTION = 131,
    _SEARCH_GUIDE = 132,
    _BUSINESS_CATEGORY = 133,
    _POSTAL_ADDRESS = 134,
    _POSTAL_CODE = 135,
    _POST_OFFICE_BOX = 136,
    _PHYSICAL_DELIVERY_OFFICE_NAME = 137,
    _TELEPHONE_NUMBER = 138,
    _TELEX_NUMBER = 139,
    _TELETEXT_TERMINAL_IDENTIFIER = 140,
    _FACSIMILE_TELEPHONE_NUMBER = 141,
    _X21_ADDRESS = 142,
    _INTERNATIONAL_ISDN_NUMBER = 143,
    _REGISTERED_ADDRESS = 144,
    _DESTINATION_INDICATOR = 145,
    _PREFERRED_DELIVERY_METHOD = 146,
    _PRESENTATION_ADDRESS = 147,
    _SUPPORTED_APPLICATION_CONTEXT = 148,
    _MEMBER = 149,
    _OWNER = 150,
    _ROLE_OCCUPANT = 151,
    _SEE_ALSO = 152,
    _USER_PASSWORD = 153,
    _USER_CERTIFICATE = 154,
    _CA_CERTIFICATE = 155,
    _AUTHORITY_REVOCATION_LIST = 156,
    _CERTIFICATE_REVOCATION_LIST = 157,
    _CROSS_CERTIFICATE_PAIR = 158,
    _GIVEN_NAME = 159,
    _INITIALS = 160,
    _DN_QUALIFIER = 161,
    _DOMAIN_COMPONENT = 162,
    _PKCS_12_FRIENDLY_NAME_ATTR = 163,
    _PKCS_12_LOCAL_KEY_ID = 164,
    _PKCS_12_KEY_PROVIDER_NAME_ATTR = 165,
    _LOCAL_MACHINE_KEYSET = 166,
    _PKCS_12_EXTENDED_ATTRIBUTES = 167,
    _KEYID_RDN = 168,
    _AUTHORITY_KEY_IDENTIFIER = 169,
    _KEY_ATTRIBUTES = 170,
    _CERT_POLICIES_95 = 171,
    _KEY_USAGE_RESTRICTION = 172,
    _SUBJECT_ALT_NAME = 173,
    _ISSUER_ALT_NAME = 174,
    _BASIC_CONSTRAINTS = 175,
    _KEY_USAGE = 176,
    _PRIVATEKEY_USAGE_PERIOD = 177,
    _BASIC_CONSTRAINTS2 = 178,
    _CERT_POLICIES = 179,
    _ANY_CERT_POLICY = 180,
    _AUTHORITY_KEY_IDENTIFIER2 = 181,
    _SUBJECT_KEY_IDENTIFIER = 182,
    _SUBJECT_ALT_NAME2 = 183,
    _ISSUER_ALT_NAME2 = 184,
    _CRL_REASON_CODE = 185,
    _REASON_CODE_HOLD = 186,
    _CRL_DIST_POINTS = 187,
    _ENHANCED_KEY_USAGE = 188,
    _CRL_NUMBER = 189,
    _DELTA_CRL_INDICATOR = 190,
    _ISSUING_DIST_POINT = 191,
    _FRESHEST_CRL = 192,
    _NAME_CONSTRAINTS = 193,
    _POLICY_MAPPINGS = 194,
    _LEGACY_POLICY_MAPPINGS = 195,
    _POLICY_CONSTRAINTS = 196,
    _RENEWAL_CERTIFICATE = 197,
    _ENROLLMENT_NAME_VALUE_PAIR = 198,
    _ENROLLMENT_CSP_PROVIDER = 199,
    _OS_VERSION = 200,
    _ENROLLMENT_AGENT = 201,
    _PKIX = 202,
    _PKIX_PE = 203,
    _AUTHORITY_INFO_ACCESS = 204,
    _BIOMETRIC_EXT = 205,
    _LOGOTYPE_EXT = 206,
    _CERT_EXTENSIONS = 207,
    _NEXT_UPDATE_LOCATION = 208,
    _REMOVE_CERTIFICATE = 209,
    _CROSS_CERT_DIST_POINTS = 210,
    _CTL = 211,
    _SORTED_CTL = 212,
    _SERIALIZED = 213,
    _NT_PRINCIPAL_NAME = 214,
    _PRODUCT_UPDATE = 215,
    _ANY_APPLICATION_POLICY = 216,
    _AUTO_ENROLL_CTL_USAGE = 217,
    _ENROLL_CERTTYPE_EXTENSION = 218,
    _CERT_MANIFOLD = 219,
    _CERTSRV_CA_VERSION = 220,
    _CERTSRV_PREVIOUS_CERT_HASH = 221,
    _CRL_VIRTUAL_BASE = 222,
    _CRL_NEXT_PUBLISH = 223,
    _KP_CA_EXCHANGE = 224,
    _KP_KEY_RECOVERY_AGENT = 225,
    _CERTIFICATE_TEMPLATE = 226,
    _ENTERPRISE_OID_ROOT = 227,
    _RDN_DUMMY_SIGNER = 228,
    _APPLICATION_CERT_POLICIES = 229,
    _APPLICATION_POLICY_MAPPINGS = 230,
    _APPLICATION_POLICY_CONSTRAINTS = 231,
    _ARCHIVED_KEY_ATTR = 232,
    _CRL_SELF_CDP = 233,
    _REQUIRE_CERT_CHAIN_POLICY = 234,
    _ARCHIVED_KEY_CERT_HASH = 235,
    _ISSUED_CERT_HASH = 236,
    _DS_EMAIL_REPLICATION = 237,
    _REQUEST_CLIENT_INFO = 238,
    _ENCRYPTED_KEY_HASH = 239,
    _CERTSRV_CROSSCA_VERSION = 240,
    _NTDS_REPLICATION = 241,
    _SUBJECT_DIR_ATTRS = 242,
    _PKIX_KP = 243,
    _PKIX_KP_SERVER_AUTH = 244,
    _PKIX_KP_CLIENT_AUTH = 245,
    _PKIX_KP_CODE_SIGNING = 246,
    _PKIX_KP_EMAIL_PROTECTION = 247,
    _PKIX_KP_IPSEC_END_SYSTEM = 248,
    _PKIX_KP_IPSEC_TUNNEL = 249,
    _PKIX_KP_IPSEC_USER = 250,
    _PKIX_KP_TIMESTAMP_SIGNING = 251,
    _PKIX_KP_OCSP_SIGNING = 252,
    _PKIX_OCSP_NOCHECK = 253,
    _IPSEC_KP_IKE_INTERMEDIATE = 254,
    _KP_CTL_USAGE_SIGNING = 255,
    _KP_TIME_STAMP_SIGNING = 256,
    _SERVER_GATED_CRYPTO = 257,
    _SGC_NETSCAPE = 258,
    _KP_EFS = 259,
    _EFS_RECOVERY = 260,
    _WHQL_CRYPTO = 261,
    _NT5_CRYPTO = 262,
    _OEM_WHQL_CRYPTO = 263,
    _EMBEDDED_NT_CRYPTO = 264,
    _ROOT_LIST_SIGNER = 265,
    _KP_QUALIFIED_SUBORDINATION = 266,
    _KP_KEY_RECOVERY = 267,
    _KP_DOCUMENT_SIGNING = 268,
    _KP_LIFETIME_SIGNING = 269,
    _KP_MOBILE_DEVICE_SOFTWARE = 270,
    _KP_SMART_DISPLAY = 271,
    _KP_CSP_SIGNATURE = 272,
    _DRM = 273,
    _DRM_INDIVIDUALIZATION = 274,
    _LICENSES = 275,
    _LICENSE_SERVER = 276,
    _KP_SMARTCARD_LOGON = 277,
    _YESNO_TRUST_ATTR = 278,
    _PKIX_POLICY_QUALIFIER_CPS = 279,
    _PKIX_POLICY_QUALIFIER_USERNOTICE = 280,
    _CERT_POLICIES_95_QUALIFIER1 = 281,
    _PKIX_ACC_DESCR = 282,
    _PKIX_OCSP = 283,
    _PKIX_CA_ISSUERS = 284,
    _VERISIGN_PRIVATE_6_9 = 285,
    _VERISIGN_ONSITE_JURISDICTION_HASH = 286,
    _VERISIGN_BITSTRING_6_13 = 287,
    _VERISIGN_ISS_STRONG_CRYPTO = 288,
    _NETSCAPE = 289,
    _NETSCAPE_CERT_EXTENSION = 290,
    _NETSCAPE_CERT_TYPE = 291,
    _NETSCAPE_BASE_URL = 292,
    _NETSCAPE_REVOCATION_URL = 293,
    _NETSCAPE_CA_REVOCATION_URL = 294,
    _NETSCAPE_CERT_RENEWAL_URL = 295,
    _NETSCAPE_CA_POLICY_URL = 296,
    _NETSCAPE_SSL_SERVER_NAME = 297,
    _NETSCAPE_COMMENT = 298,
    _NETSCAPE_DATA_TYPE = 299,
    _NETSCAPE_CERT_SEQUENCE = 300,
    _CT_PKI_DATA = 301,
    _CT_PKI_RESPONSE = 302,
    _PKIX_NO_SIGNATURE = 303,
    _CMC = 304,
    _CMC_STATUS_INFO = 305,
    _CMC_IDENTIFICATION = 306,
    _CMC_IDENTITY_PROOF = 307,
    _CMC_DATA_RETURN = 308,
    _CMC_TRANSACTION_ID = 309,
    _CMC_SENDER_NONCE = 310,
    _CMC_RECIPIENT_NONCE = 311,
    _CMC_ADD_EXTENSIONS = 312,
    _CMC_ENCRYPTED_POP = 313,
    _CMC_DECRYPTED_POP = 314,
    _CMC_LRA_POP_WITNESS = 315,
    _CMC_GET_CERT = 316,
    _CMC_GET_CRL = 317,
    _CMC_REVOKE_REQUEST = 318,
    _CMC_REG_INFO = 319,
    _CMC_RESPONSE_INFO = 320,
    _CMC_QUERY_PENDING = 321,
    _CMC_ID_POP_LINK_RANDOM = 322,
    _CMC_ID_POP_LINK_WITNESS = 323,
    _CMC_ID_CONFIRM_CERT_ACCEPTANCE = 324,
    _CMC_ADD_ATTRIBUTES = 325,
    _LOYALTY_OTHER_LOGOTYPE = 326,
    _BACKGROUND_OTHER_LOGOTYPE = 327,
    _PKIX_OCSP_BASIC_SIGNED_RESPONSE = 328,
    _PKCS_7_DATA = 329,
    _PKCS_7_SIGNED = 330,
    _PKCS_7_ENVELOPED = 331,
    _PKCS_7_SIGNEDANDENVELOPED = 332,
    _PKCS_7_DIGESTED = 333,
    _PKCS_7_ENCRYPTED = 334,
    _PKCS_9_CONTENT_TYPE = 335,
    _PKCS_9_MESSAGE_DIGEST = 336,
    _CERT_PROP_ID_PREFIX = 337,
    _CERT_KEY_IDENTIFIER_PROP_ID = 338,
    _CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 339,
    _CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 340,
    _CERT_MD5_HASH_PROP_ID = 341,
    _RSA_SHA256RSA = 342,
    _RSA_SHA384RSA = 343,
    _RSA_SHA512RSA = 344,
    _NIST_sha256 = 345,
    _NIST_sha384 = 346,
    _NIST_sha512 = 347,
    _RSA_MGF1 = 348,
    _ECC_PUBLIC_KEY = 349,
    _ECDSA_SHA1 = 350,
    _ECDSA_SPECIFIED = 351,
    _ANY_ENHANCED_KEY_USAGE = 352,
    _RSA_SSA_PSS = 353,
    _ATTR_SUPPORTED_ALGORITHMS = 355,
    _ATTR_TPM_SECURITY_ASSERTIONS = 356,
    _ATTR_TPM_SPECIFICATION = 357,
    _CERT_DISALLOWED_FILETIME_PROP_ID = 358,
    _CERT_SIGNATURE_HASH_PROP_ID = 359,
    _CERT_STRONG_KEY_OS_1 = 360,
    _CERT_STRONG_KEY_OS_CURRENT = 361,
    _CERT_STRONG_KEY_OS_PREFIX = 362,
    _CERT_STRONG_SIGN_OS_1 = 363,
    _CERT_STRONG_SIGN_OS_CURRENT = 364,
    _CERT_STRONG_SIGN_OS_PREFIX = 365,
    _DH_SINGLE_PASS_STDDH_SHA1_KDF = 366,
    _DH_SINGLE_PASS_STDDH_SHA256_KDF = 367,
    _DH_SINGLE_PASS_STDDH_SHA384_KDF = 368,
    _DISALLOWED_HASH = 369,
    _DISALLOWED_LIST = 370,
    _ECC_CURVE_P256 = 371,
    _ECC_CURVE_P384 = 372,
    _ECC_CURVE_P521 = 373,
    _ECDSA_SHA256 = 374,
    _ECDSA_SHA384 = 375,
    _ECDSA_SHA512 = 376,
    _ENROLL_CAXCHGCERT_HASH = 377,
    _ENROLL_EK_INFO = 378,
    _ENROLL_EKPUB_CHALLENGE = 379,
    _ENROLL_EKVERIFYCERT = 380,
    _ENROLL_EKVERIFYCREDS = 381,
    _ENROLL_EKVERIFYKEY = 382,
    _EV_RDN_COUNTRY = 383,
    _EV_RDN_LOCALE = 384,
    _EV_RDN_STATE_OR_PROVINCE = 385,
    _INHIBIT_ANY_POLICY = 386,
    _INTERNATIONALIZED_EMAIL_ADDRESS = 387,
    _KP_KERNEL_MODE_CODE_SIGNING = 388,
    _KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = 389,
    _KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = 390,
    _KP_TPM_AIK_CERTIFICATE = 391,
    _KP_TPM_EK_CERTIFICATE = 392,
    _KP_TPM_PLATFORM_CERTIFICATE = 393,
    _NIST_AES128_CBC = 394,
    _NIST_AES128_WRAP = 395,
    _NIST_AES192_CBC = 396,
    _NIST_AES192_WRAP = 397,
    _NIST_AES256_CBC = 398,
    _NIST_AES256_WRAP = 399,
    _PKCS_12_PbeIds = 400,
    _PKCS_12_pbeWithSHA1And128BitRC2 = 401,
    _PKCS_12_pbeWithSHA1And128BitRC4 = 402,
    _PKCS_12_pbeWithSHA1And2KeyTripleDES = 403,
    _PKCS_12_pbeWithSHA1And3KeyTripleDES = 404,
    _PKCS_12_pbeWithSHA1And40BitRC2 = 405,
    _PKCS_12_pbeWithSHA1And40BitRC4 = 406,
    _PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = 407,
    _PKINIT_KP_KDC = 408,
    _PKIX_CA_REPOSITORY = 409,
    _PKIX_OCSP_NONCE = 410,
    _PKIX_TIME_STAMPING = 411,
    _QC_EU_COMPLIANCE = 412,
    _QC_SSCD = 413,
    _QC_STATEMENTS_EXT = 414,
    _RDN_TPM_MANUFACTURER = 415,
    _RDN_TPM_MODEL = 416,
    _RDN_TPM_VERSION = 417,
    _REVOKED_LIST_SIGNER = 418,
    _RFC3161_counterSign = 419,
    _ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = 420,
    _ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = 421,
    _ROOT_PROGRAM_FLAGS = 422,
    _ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = 423,
    _RSA_PSPECIFIED = 424,
    _RSAES_OAEP = 425,
    _SUBJECT_INFO_ACCESS = 426,
    _TIMESTAMP_TOKEN = 427,
    _ENROLL_SCEP_ERROR = 428,
    Verisign_MessageType = 429,
    Verisign_PkiStatus = 430,
    Verisign_FailInfo = 431,
    Verisign_SenderNonce = 432,
    Verisign_RecipientNonce = 433,
    Verisign_TransactionID = 434,
    _ENROLL_ATTESTATION_CHALLENGE = 435,
    _ENROLL_ATTESTATION_STATEMENT = 436,
    _ENROLL_ENCRYPTION_ALGORITHM = 437,
    _ENROLL_KSP_NAME = 438,
};
pub const XCN_OID_NONE = CERTENROLL_OBJECTID._NONE;
pub const XCN_OID_RSA = CERTENROLL_OBJECTID._RSA;
pub const XCN_OID_PKCS = CERTENROLL_OBJECTID._PKCS;
pub const XCN_OID_RSA_HASH = CERTENROLL_OBJECTID._RSA_HASH;
pub const XCN_OID_RSA_ENCRYPT = CERTENROLL_OBJECTID._RSA_ENCRYPT;
pub const XCN_OID_PKCS_1 = CERTENROLL_OBJECTID._PKCS_1;
pub const XCN_OID_PKCS_2 = CERTENROLL_OBJECTID._PKCS_2;
pub const XCN_OID_PKCS_3 = CERTENROLL_OBJECTID._PKCS_3;
pub const XCN_OID_PKCS_4 = CERTENROLL_OBJECTID._PKCS_4;
pub const XCN_OID_PKCS_5 = CERTENROLL_OBJECTID._PKCS_5;
pub const XCN_OID_PKCS_6 = CERTENROLL_OBJECTID._PKCS_6;
pub const XCN_OID_PKCS_7 = CERTENROLL_OBJECTID._PKCS_7;
pub const XCN_OID_PKCS_8 = CERTENROLL_OBJECTID._PKCS_8;
pub const XCN_OID_PKCS_9 = CERTENROLL_OBJECTID._PKCS_9;
pub const XCN_OID_PKCS_10 = CERTENROLL_OBJECTID._PKCS_10;
pub const XCN_OID_PKCS_12 = CERTENROLL_OBJECTID._PKCS_12;
pub const XCN_OID_RSA_RSA = CERTENROLL_OBJECTID._RSA_RSA;
pub const XCN_OID_RSA_MD2RSA = CERTENROLL_OBJECTID._RSA_MD2RSA;
pub const XCN_OID_RSA_MD4RSA = CERTENROLL_OBJECTID._RSA_MD4RSA;
pub const XCN_OID_RSA_MD5RSA = CERTENROLL_OBJECTID._RSA_MD5RSA;
pub const XCN_OID_RSA_SHA1RSA = CERTENROLL_OBJECTID._RSA_SHA1RSA;
pub const XCN_OID_RSA_SETOAEP_RSA = CERTENROLL_OBJECTID._RSA_SETOAEP_RSA;
pub const XCN_OID_RSA_DH = CERTENROLL_OBJECTID._RSA_DH;
pub const XCN_OID_RSA_data = CERTENROLL_OBJECTID._RSA_data;
pub const XCN_OID_RSA_signedData = CERTENROLL_OBJECTID._RSA_signedData;
pub const XCN_OID_RSA_envelopedData = CERTENROLL_OBJECTID._RSA_envelopedData;
pub const XCN_OID_RSA_signEnvData = CERTENROLL_OBJECTID._RSA_signEnvData;
pub const XCN_OID_RSA_digestedData = CERTENROLL_OBJECTID._RSA_digestedData;
pub const XCN_OID_RSA_hashedData = CERTENROLL_OBJECTID._RSA_hashedData;
pub const XCN_OID_RSA_encryptedData = CERTENROLL_OBJECTID._RSA_encryptedData;
pub const XCN_OID_RSA_emailAddr = CERTENROLL_OBJECTID._RSA_emailAddr;
pub const XCN_OID_RSA_unstructName = CERTENROLL_OBJECTID._RSA_unstructName;
pub const XCN_OID_RSA_contentType = CERTENROLL_OBJECTID._RSA_contentType;
pub const XCN_OID_RSA_messageDigest = CERTENROLL_OBJECTID._RSA_messageDigest;
pub const XCN_OID_RSA_signingTime = CERTENROLL_OBJECTID._RSA_signingTime;
pub const XCN_OID_RSA_counterSign = CERTENROLL_OBJECTID._RSA_counterSign;
pub const XCN_OID_RSA_challengePwd = CERTENROLL_OBJECTID._RSA_challengePwd;
pub const XCN_OID_RSA_unstructAddr = CERTENROLL_OBJECTID._RSA_unstructAddr;
pub const XCN_OID_RSA_extCertAttrs = CERTENROLL_OBJECTID._RSA_extCertAttrs;
pub const XCN_OID_RSA_certExtensions = CERTENROLL_OBJECTID._RSA_certExtensions;
pub const XCN_OID_RSA_SMIMECapabilities = CERTENROLL_OBJECTID._RSA_SMIMECapabilities;
pub const XCN_OID_RSA_preferSignedData = CERTENROLL_OBJECTID._RSA_preferSignedData;
pub const XCN_OID_RSA_SMIMEalg = CERTENROLL_OBJECTID._RSA_SMIMEalg;
pub const XCN_OID_RSA_SMIMEalgESDH = CERTENROLL_OBJECTID._RSA_SMIMEalgESDH;
pub const XCN_OID_RSA_SMIMEalgCMS3DESwrap = CERTENROLL_OBJECTID._RSA_SMIMEalgCMS3DESwrap;
pub const XCN_OID_RSA_SMIMEalgCMSRC2wrap = CERTENROLL_OBJECTID._RSA_SMIMEalgCMSRC2wrap;
pub const XCN_OID_RSA_MD2 = CERTENROLL_OBJECTID._RSA_MD2;
pub const XCN_OID_RSA_MD4 = CERTENROLL_OBJECTID._RSA_MD4;
pub const XCN_OID_RSA_MD5 = CERTENROLL_OBJECTID._RSA_MD5;
pub const XCN_OID_RSA_RC2CBC = CERTENROLL_OBJECTID._RSA_RC2CBC;
pub const XCN_OID_RSA_RC4 = CERTENROLL_OBJECTID._RSA_RC4;
pub const XCN_OID_RSA_DES_EDE3_CBC = CERTENROLL_OBJECTID._RSA_DES_EDE3_CBC;
pub const XCN_OID_RSA_RC5_CBCPad = CERTENROLL_OBJECTID._RSA_RC5_CBCPad;
pub const XCN_OID_ANSI_X942 = CERTENROLL_OBJECTID._ANSI_X942;
pub const XCN_OID_ANSI_X942_DH = CERTENROLL_OBJECTID._ANSI_X942_DH;
pub const XCN_OID_X957 = CERTENROLL_OBJECTID._X957;
pub const XCN_OID_X957_DSA = CERTENROLL_OBJECTID._X957_DSA;
pub const XCN_OID_X957_SHA1DSA = CERTENROLL_OBJECTID._X957_SHA1DSA;
pub const XCN_OID_DS = CERTENROLL_OBJECTID._DS;
pub const XCN_OID_DSALG = CERTENROLL_OBJECTID._DSALG;
pub const XCN_OID_DSALG_CRPT = CERTENROLL_OBJECTID._DSALG_CRPT;
pub const XCN_OID_DSALG_HASH = CERTENROLL_OBJECTID._DSALG_HASH;
pub const XCN_OID_DSALG_SIGN = CERTENROLL_OBJECTID._DSALG_SIGN;
pub const XCN_OID_DSALG_RSA = CERTENROLL_OBJECTID._DSALG_RSA;
pub const XCN_OID_OIW = CERTENROLL_OBJECTID._OIW;
pub const XCN_OID_OIWSEC = CERTENROLL_OBJECTID._OIWSEC;
pub const XCN_OID_OIWSEC_md4RSA = CERTENROLL_OBJECTID._OIWSEC_md4RSA;
pub const XCN_OID_OIWSEC_md5RSA = CERTENROLL_OBJECTID._OIWSEC_md5RSA;
pub const XCN_OID_OIWSEC_md4RSA2 = CERTENROLL_OBJECTID._OIWSEC_md4RSA2;
pub const XCN_OID_OIWSEC_desECB = CERTENROLL_OBJECTID._OIWSEC_desECB;
pub const XCN_OID_OIWSEC_desCBC = CERTENROLL_OBJECTID._OIWSEC_desCBC;
pub const XCN_OID_OIWSEC_desOFB = CERTENROLL_OBJECTID._OIWSEC_desOFB;
pub const XCN_OID_OIWSEC_desCFB = CERTENROLL_OBJECTID._OIWSEC_desCFB;
pub const XCN_OID_OIWSEC_desMAC = CERTENROLL_OBJECTID._OIWSEC_desMAC;
pub const XCN_OID_OIWSEC_rsaSign = CERTENROLL_OBJECTID._OIWSEC_rsaSign;
pub const XCN_OID_OIWSEC_dsa = CERTENROLL_OBJECTID._OIWSEC_dsa;
pub const XCN_OID_OIWSEC_shaDSA = CERTENROLL_OBJECTID._OIWSEC_shaDSA;
pub const XCN_OID_OIWSEC_mdc2RSA = CERTENROLL_OBJECTID._OIWSEC_mdc2RSA;
pub const XCN_OID_OIWSEC_shaRSA = CERTENROLL_OBJECTID._OIWSEC_shaRSA;
pub const XCN_OID_OIWSEC_dhCommMod = CERTENROLL_OBJECTID._OIWSEC_dhCommMod;
pub const XCN_OID_OIWSEC_desEDE = CERTENROLL_OBJECTID._OIWSEC_desEDE;
pub const XCN_OID_OIWSEC_sha = CERTENROLL_OBJECTID._OIWSEC_sha;
pub const XCN_OID_OIWSEC_mdc2 = CERTENROLL_OBJECTID._OIWSEC_mdc2;
pub const XCN_OID_OIWSEC_dsaComm = CERTENROLL_OBJECTID._OIWSEC_dsaComm;
pub const XCN_OID_OIWSEC_dsaCommSHA = CERTENROLL_OBJECTID._OIWSEC_dsaCommSHA;
pub const XCN_OID_OIWSEC_rsaXchg = CERTENROLL_OBJECTID._OIWSEC_rsaXchg;
pub const XCN_OID_OIWSEC_keyHashSeal = CERTENROLL_OBJECTID._OIWSEC_keyHashSeal;
pub const XCN_OID_OIWSEC_md2RSASign = CERTENROLL_OBJECTID._OIWSEC_md2RSASign;
pub const XCN_OID_OIWSEC_md5RSASign = CERTENROLL_OBJECTID._OIWSEC_md5RSASign;
pub const XCN_OID_OIWSEC_sha1 = CERTENROLL_OBJECTID._OIWSEC_sha1;
pub const XCN_OID_OIWSEC_dsaSHA1 = CERTENROLL_OBJECTID._OIWSEC_dsaSHA1;
pub const XCN_OID_OIWSEC_dsaCommSHA1 = CERTENROLL_OBJECTID._OIWSEC_dsaCommSHA1;
pub const XCN_OID_OIWSEC_sha1RSASign = CERTENROLL_OBJECTID._OIWSEC_sha1RSASign;
pub const XCN_OID_OIWDIR = CERTENROLL_OBJECTID._OIWDIR;
pub const XCN_OID_OIWDIR_CRPT = CERTENROLL_OBJECTID._OIWDIR_CRPT;
pub const XCN_OID_OIWDIR_HASH = CERTENROLL_OBJECTID._OIWDIR_HASH;
pub const XCN_OID_OIWDIR_SIGN = CERTENROLL_OBJECTID._OIWDIR_SIGN;
pub const XCN_OID_OIWDIR_md2 = CERTENROLL_OBJECTID._OIWDIR_md2;
pub const XCN_OID_OIWDIR_md2RSA = CERTENROLL_OBJECTID._OIWDIR_md2RSA;
pub const XCN_OID_INFOSEC = CERTENROLL_OBJECTID._INFOSEC;
pub const XCN_OID_INFOSEC_sdnsSignature = CERTENROLL_OBJECTID._INFOSEC_sdnsSignature;
pub const XCN_OID_INFOSEC_mosaicSignature = CERTENROLL_OBJECTID._INFOSEC_mosaicSignature;
pub const XCN_OID_INFOSEC_sdnsConfidentiality = CERTENROLL_OBJECTID._INFOSEC_sdnsConfidentiality;
pub const XCN_OID_INFOSEC_mosaicConfidentiality = CERTENROLL_OBJECTID._INFOSEC_mosaicConfidentiality;
pub const XCN_OID_INFOSEC_sdnsIntegrity = CERTENROLL_OBJECTID._INFOSEC_sdnsIntegrity;
pub const XCN_OID_INFOSEC_mosaicIntegrity = CERTENROLL_OBJECTID._INFOSEC_mosaicIntegrity;
pub const XCN_OID_INFOSEC_sdnsTokenProtection = CERTENROLL_OBJECTID._INFOSEC_sdnsTokenProtection;
pub const XCN_OID_INFOSEC_mosaicTokenProtection = CERTENROLL_OBJECTID._INFOSEC_mosaicTokenProtection;
pub const XCN_OID_INFOSEC_sdnsKeyManagement = CERTENROLL_OBJECTID._INFOSEC_sdnsKeyManagement;
pub const XCN_OID_INFOSEC_mosaicKeyManagement = CERTENROLL_OBJECTID._INFOSEC_mosaicKeyManagement;
pub const XCN_OID_INFOSEC_sdnsKMandSig = CERTENROLL_OBJECTID._INFOSEC_sdnsKMandSig;
pub const XCN_OID_INFOSEC_mosaicKMandSig = CERTENROLL_OBJECTID._INFOSEC_mosaicKMandSig;
pub const XCN_OID_INFOSEC_SuiteASignature = CERTENROLL_OBJECTID._INFOSEC_SuiteASignature;
pub const XCN_OID_INFOSEC_SuiteAConfidentiality = CERTENROLL_OBJECTID._INFOSEC_SuiteAConfidentiality;
pub const XCN_OID_INFOSEC_SuiteAIntegrity = CERTENROLL_OBJECTID._INFOSEC_SuiteAIntegrity;
pub const XCN_OID_INFOSEC_SuiteATokenProtection = CERTENROLL_OBJECTID._INFOSEC_SuiteATokenProtection;
pub const XCN_OID_INFOSEC_SuiteAKeyManagement = CERTENROLL_OBJECTID._INFOSEC_SuiteAKeyManagement;
pub const XCN_OID_INFOSEC_SuiteAKMandSig = CERTENROLL_OBJECTID._INFOSEC_SuiteAKMandSig;
pub const XCN_OID_INFOSEC_mosaicUpdatedSig = CERTENROLL_OBJECTID._INFOSEC_mosaicUpdatedSig;
pub const XCN_OID_INFOSEC_mosaicKMandUpdSig = CERTENROLL_OBJECTID._INFOSEC_mosaicKMandUpdSig;
pub const XCN_OID_INFOSEC_mosaicUpdatedInteg = CERTENROLL_OBJECTID._INFOSEC_mosaicUpdatedInteg;
pub const XCN_OID_COMMON_NAME = CERTENROLL_OBJECTID._COMMON_NAME;
pub const XCN_OID_SUR_NAME = CERTENROLL_OBJECTID._SUR_NAME;
pub const XCN_OID_DEVICE_SERIAL_NUMBER = CERTENROLL_OBJECTID._DEVICE_SERIAL_NUMBER;
pub const XCN_OID_COUNTRY_NAME = CERTENROLL_OBJECTID._COUNTRY_NAME;
pub const XCN_OID_LOCALITY_NAME = CERTENROLL_OBJECTID._LOCALITY_NAME;
pub const XCN_OID_STATE_OR_PROVINCE_NAME = CERTENROLL_OBJECTID._STATE_OR_PROVINCE_NAME;
pub const XCN_OID_STREET_ADDRESS = CERTENROLL_OBJECTID._STREET_ADDRESS;
pub const XCN_OID_ORGANIZATION_NAME = CERTENROLL_OBJECTID._ORGANIZATION_NAME;
pub const XCN_OID_ORGANIZATIONAL_UNIT_NAME = CERTENROLL_OBJECTID._ORGANIZATIONAL_UNIT_NAME;
pub const XCN_OID_TITLE = CERTENROLL_OBJECTID._TITLE;
pub const XCN_OID_DESCRIPTION = CERTENROLL_OBJECTID._DESCRIPTION;
pub const XCN_OID_SEARCH_GUIDE = CERTENROLL_OBJECTID._SEARCH_GUIDE;
pub const XCN_OID_BUSINESS_CATEGORY = CERTENROLL_OBJECTID._BUSINESS_CATEGORY;
pub const XCN_OID_POSTAL_ADDRESS = CERTENROLL_OBJECTID._POSTAL_ADDRESS;
pub const XCN_OID_POSTAL_CODE = CERTENROLL_OBJECTID._POSTAL_CODE;
pub const XCN_OID_POST_OFFICE_BOX = CERTENROLL_OBJECTID._POST_OFFICE_BOX;
pub const XCN_OID_PHYSICAL_DELIVERY_OFFICE_NAME = CERTENROLL_OBJECTID._PHYSICAL_DELIVERY_OFFICE_NAME;
pub const XCN_OID_TELEPHONE_NUMBER = CERTENROLL_OBJECTID._TELEPHONE_NUMBER;
pub const XCN_OID_TELEX_NUMBER = CERTENROLL_OBJECTID._TELEX_NUMBER;
pub const XCN_OID_TELETEXT_TERMINAL_IDENTIFIER = CERTENROLL_OBJECTID._TELETEXT_TERMINAL_IDENTIFIER;
pub const XCN_OID_FACSIMILE_TELEPHONE_NUMBER = CERTENROLL_OBJECTID._FACSIMILE_TELEPHONE_NUMBER;
pub const XCN_OID_X21_ADDRESS = CERTENROLL_OBJECTID._X21_ADDRESS;
pub const XCN_OID_INTERNATIONAL_ISDN_NUMBER = CERTENROLL_OBJECTID._INTERNATIONAL_ISDN_NUMBER;
pub const XCN_OID_REGISTERED_ADDRESS = CERTENROLL_OBJECTID._REGISTERED_ADDRESS;
pub const XCN_OID_DESTINATION_INDICATOR = CERTENROLL_OBJECTID._DESTINATION_INDICATOR;
pub const XCN_OID_PREFERRED_DELIVERY_METHOD = CERTENROLL_OBJECTID._PREFERRED_DELIVERY_METHOD;
pub const XCN_OID_PRESENTATION_ADDRESS = CERTENROLL_OBJECTID._PRESENTATION_ADDRESS;
pub const XCN_OID_SUPPORTED_APPLICATION_CONTEXT = CERTENROLL_OBJECTID._SUPPORTED_APPLICATION_CONTEXT;
pub const XCN_OID_MEMBER = CERTENROLL_OBJECTID._MEMBER;
pub const XCN_OID_OWNER = CERTENROLL_OBJECTID._OWNER;
pub const XCN_OID_ROLE_OCCUPANT = CERTENROLL_OBJECTID._ROLE_OCCUPANT;
pub const XCN_OID_SEE_ALSO = CERTENROLL_OBJECTID._SEE_ALSO;
pub const XCN_OID_USER_PASSWORD = CERTENROLL_OBJECTID._USER_PASSWORD;
pub const XCN_OID_USER_CERTIFICATE = CERTENROLL_OBJECTID._USER_CERTIFICATE;
pub const XCN_OID_CA_CERTIFICATE = CERTENROLL_OBJECTID._CA_CERTIFICATE;
pub const XCN_OID_AUTHORITY_REVOCATION_LIST = CERTENROLL_OBJECTID._AUTHORITY_REVOCATION_LIST;
pub const XCN_OID_CERTIFICATE_REVOCATION_LIST = CERTENROLL_OBJECTID._CERTIFICATE_REVOCATION_LIST;
pub const XCN_OID_CROSS_CERTIFICATE_PAIR = CERTENROLL_OBJECTID._CROSS_CERTIFICATE_PAIR;
pub const XCN_OID_GIVEN_NAME = CERTENROLL_OBJECTID._GIVEN_NAME;
pub const XCN_OID_INITIALS = CERTENROLL_OBJECTID._INITIALS;
pub const XCN_OID_DN_QUALIFIER = CERTENROLL_OBJECTID._DN_QUALIFIER;
pub const XCN_OID_DOMAIN_COMPONENT = CERTENROLL_OBJECTID._DOMAIN_COMPONENT;
pub const XCN_OID_PKCS_12_FRIENDLY_NAME_ATTR = CERTENROLL_OBJECTID._PKCS_12_FRIENDLY_NAME_ATTR;
pub const XCN_OID_PKCS_12_LOCAL_KEY_ID = CERTENROLL_OBJECTID._PKCS_12_LOCAL_KEY_ID;
pub const XCN_OID_PKCS_12_KEY_PROVIDER_NAME_ATTR = CERTENROLL_OBJECTID._PKCS_12_KEY_PROVIDER_NAME_ATTR;
pub const XCN_OID_LOCAL_MACHINE_KEYSET = CERTENROLL_OBJECTID._LOCAL_MACHINE_KEYSET;
pub const XCN_OID_PKCS_12_EXTENDED_ATTRIBUTES = CERTENROLL_OBJECTID._PKCS_12_EXTENDED_ATTRIBUTES;
pub const XCN_OID_KEYID_RDN = CERTENROLL_OBJECTID._KEYID_RDN;
pub const XCN_OID_AUTHORITY_KEY_IDENTIFIER = CERTENROLL_OBJECTID._AUTHORITY_KEY_IDENTIFIER;
pub const XCN_OID_KEY_ATTRIBUTES = CERTENROLL_OBJECTID._KEY_ATTRIBUTES;
pub const XCN_OID_CERT_POLICIES_95 = CERTENROLL_OBJECTID._CERT_POLICIES_95;
pub const XCN_OID_KEY_USAGE_RESTRICTION = CERTENROLL_OBJECTID._KEY_USAGE_RESTRICTION;
pub const XCN_OID_SUBJECT_ALT_NAME = CERTENROLL_OBJECTID._SUBJECT_ALT_NAME;
pub const XCN_OID_ISSUER_ALT_NAME = CERTENROLL_OBJECTID._ISSUER_ALT_NAME;
pub const XCN_OID_BASIC_CONSTRAINTS = CERTENROLL_OBJECTID._BASIC_CONSTRAINTS;
pub const XCN_OID_KEY_USAGE = CERTENROLL_OBJECTID._KEY_USAGE;
pub const XCN_OID_PRIVATEKEY_USAGE_PERIOD = CERTENROLL_OBJECTID._PRIVATEKEY_USAGE_PERIOD;
pub const XCN_OID_BASIC_CONSTRAINTS2 = CERTENROLL_OBJECTID._BASIC_CONSTRAINTS2;
pub const XCN_OID_CERT_POLICIES = CERTENROLL_OBJECTID._CERT_POLICIES;
pub const XCN_OID_ANY_CERT_POLICY = CERTENROLL_OBJECTID._ANY_CERT_POLICY;
pub const XCN_OID_AUTHORITY_KEY_IDENTIFIER2 = CERTENROLL_OBJECTID._AUTHORITY_KEY_IDENTIFIER2;
pub const XCN_OID_SUBJECT_KEY_IDENTIFIER = CERTENROLL_OBJECTID._SUBJECT_KEY_IDENTIFIER;
pub const XCN_OID_SUBJECT_ALT_NAME2 = CERTENROLL_OBJECTID._SUBJECT_ALT_NAME2;
pub const XCN_OID_ISSUER_ALT_NAME2 = CERTENROLL_OBJECTID._ISSUER_ALT_NAME2;
pub const XCN_OID_CRL_REASON_CODE = CERTENROLL_OBJECTID._CRL_REASON_CODE;
pub const XCN_OID_REASON_CODE_HOLD = CERTENROLL_OBJECTID._REASON_CODE_HOLD;
pub const XCN_OID_CRL_DIST_POINTS = CERTENROLL_OBJECTID._CRL_DIST_POINTS;
pub const XCN_OID_ENHANCED_KEY_USAGE = CERTENROLL_OBJECTID._ENHANCED_KEY_USAGE;
pub const XCN_OID_CRL_NUMBER = CERTENROLL_OBJECTID._CRL_NUMBER;
pub const XCN_OID_DELTA_CRL_INDICATOR = CERTENROLL_OBJECTID._DELTA_CRL_INDICATOR;
pub const XCN_OID_ISSUING_DIST_POINT = CERTENROLL_OBJECTID._ISSUING_DIST_POINT;
pub const XCN_OID_FRESHEST_CRL = CERTENROLL_OBJECTID._FRESHEST_CRL;
pub const XCN_OID_NAME_CONSTRAINTS = CERTENROLL_OBJECTID._NAME_CONSTRAINTS;
pub const XCN_OID_POLICY_MAPPINGS = CERTENROLL_OBJECTID._POLICY_MAPPINGS;
pub const XCN_OID_LEGACY_POLICY_MAPPINGS = CERTENROLL_OBJECTID._LEGACY_POLICY_MAPPINGS;
pub const XCN_OID_POLICY_CONSTRAINTS = CERTENROLL_OBJECTID._POLICY_CONSTRAINTS;
pub const XCN_OID_RENEWAL_CERTIFICATE = CERTENROLL_OBJECTID._RENEWAL_CERTIFICATE;
pub const XCN_OID_ENROLLMENT_NAME_VALUE_PAIR = CERTENROLL_OBJECTID._ENROLLMENT_NAME_VALUE_PAIR;
pub const XCN_OID_ENROLLMENT_CSP_PROVIDER = CERTENROLL_OBJECTID._ENROLLMENT_CSP_PROVIDER;
pub const XCN_OID_OS_VERSION = CERTENROLL_OBJECTID._OS_VERSION;
pub const XCN_OID_ENROLLMENT_AGENT = CERTENROLL_OBJECTID._ENROLLMENT_AGENT;
pub const XCN_OID_PKIX = CERTENROLL_OBJECTID._PKIX;
pub const XCN_OID_PKIX_PE = CERTENROLL_OBJECTID._PKIX_PE;
pub const XCN_OID_AUTHORITY_INFO_ACCESS = CERTENROLL_OBJECTID._AUTHORITY_INFO_ACCESS;
pub const XCN_OID_BIOMETRIC_EXT = CERTENROLL_OBJECTID._BIOMETRIC_EXT;
pub const XCN_OID_LOGOTYPE_EXT = CERTENROLL_OBJECTID._LOGOTYPE_EXT;
pub const XCN_OID_CERT_EXTENSIONS = CERTENROLL_OBJECTID._CERT_EXTENSIONS;
pub const XCN_OID_NEXT_UPDATE_LOCATION = CERTENROLL_OBJECTID._NEXT_UPDATE_LOCATION;
pub const XCN_OID_REMOVE_CERTIFICATE = CERTENROLL_OBJECTID._REMOVE_CERTIFICATE;
pub const XCN_OID_CROSS_CERT_DIST_POINTS = CERTENROLL_OBJECTID._CROSS_CERT_DIST_POINTS;
pub const XCN_OID_CTL = CERTENROLL_OBJECTID._CTL;
pub const XCN_OID_SORTED_CTL = CERTENROLL_OBJECTID._SORTED_CTL;
pub const XCN_OID_SERIALIZED = CERTENROLL_OBJECTID._SERIALIZED;
pub const XCN_OID_NT_PRINCIPAL_NAME = CERTENROLL_OBJECTID._NT_PRINCIPAL_NAME;
pub const XCN_OID_PRODUCT_UPDATE = CERTENROLL_OBJECTID._PRODUCT_UPDATE;
pub const XCN_OID_ANY_APPLICATION_POLICY = CERTENROLL_OBJECTID._ANY_APPLICATION_POLICY;
pub const XCN_OID_AUTO_ENROLL_CTL_USAGE = CERTENROLL_OBJECTID._AUTO_ENROLL_CTL_USAGE;
pub const XCN_OID_ENROLL_CERTTYPE_EXTENSION = CERTENROLL_OBJECTID._ENROLL_CERTTYPE_EXTENSION;
pub const XCN_OID_CERT_MANIFOLD = CERTENROLL_OBJECTID._CERT_MANIFOLD;
pub const XCN_OID_CERTSRV_CA_VERSION = CERTENROLL_OBJECTID._CERTSRV_CA_VERSION;
pub const XCN_OID_CERTSRV_PREVIOUS_CERT_HASH = CERTENROLL_OBJECTID._CERTSRV_PREVIOUS_CERT_HASH;
pub const XCN_OID_CRL_VIRTUAL_BASE = CERTENROLL_OBJECTID._CRL_VIRTUAL_BASE;
pub const XCN_OID_CRL_NEXT_PUBLISH = CERTENROLL_OBJECTID._CRL_NEXT_PUBLISH;
pub const XCN_OID_KP_CA_EXCHANGE = CERTENROLL_OBJECTID._KP_CA_EXCHANGE;
pub const XCN_OID_KP_KEY_RECOVERY_AGENT = CERTENROLL_OBJECTID._KP_KEY_RECOVERY_AGENT;
pub const XCN_OID_CERTIFICATE_TEMPLATE = CERTENROLL_OBJECTID._CERTIFICATE_TEMPLATE;
pub const XCN_OID_ENTERPRISE_OID_ROOT = CERTENROLL_OBJECTID._ENTERPRISE_OID_ROOT;
pub const XCN_OID_RDN_DUMMY_SIGNER = CERTENROLL_OBJECTID._RDN_DUMMY_SIGNER;
pub const XCN_OID_APPLICATION_CERT_POLICIES = CERTENROLL_OBJECTID._APPLICATION_CERT_POLICIES;
pub const XCN_OID_APPLICATION_POLICY_MAPPINGS = CERTENROLL_OBJECTID._APPLICATION_POLICY_MAPPINGS;
pub const XCN_OID_APPLICATION_POLICY_CONSTRAINTS = CERTENROLL_OBJECTID._APPLICATION_POLICY_CONSTRAINTS;
pub const XCN_OID_ARCHIVED_KEY_ATTR = CERTENROLL_OBJECTID._ARCHIVED_KEY_ATTR;
pub const XCN_OID_CRL_SELF_CDP = CERTENROLL_OBJECTID._CRL_SELF_CDP;
pub const XCN_OID_REQUIRE_CERT_CHAIN_POLICY = CERTENROLL_OBJECTID._REQUIRE_CERT_CHAIN_POLICY;
pub const XCN_OID_ARCHIVED_KEY_CERT_HASH = CERTENROLL_OBJECTID._ARCHIVED_KEY_CERT_HASH;
pub const XCN_OID_ISSUED_CERT_HASH = CERTENROLL_OBJECTID._ISSUED_CERT_HASH;
pub const XCN_OID_DS_EMAIL_REPLICATION = CERTENROLL_OBJECTID._DS_EMAIL_REPLICATION;
pub const XCN_OID_REQUEST_CLIENT_INFO = CERTENROLL_OBJECTID._REQUEST_CLIENT_INFO;
pub const XCN_OID_ENCRYPTED_KEY_HASH = CERTENROLL_OBJECTID._ENCRYPTED_KEY_HASH;
pub const XCN_OID_CERTSRV_CROSSCA_VERSION = CERTENROLL_OBJECTID._CERTSRV_CROSSCA_VERSION;
pub const XCN_OID_NTDS_REPLICATION = CERTENROLL_OBJECTID._NTDS_REPLICATION;
pub const XCN_OID_SUBJECT_DIR_ATTRS = CERTENROLL_OBJECTID._SUBJECT_DIR_ATTRS;
pub const XCN_OID_PKIX_KP = CERTENROLL_OBJECTID._PKIX_KP;
pub const XCN_OID_PKIX_KP_SERVER_AUTH = CERTENROLL_OBJECTID._PKIX_KP_SERVER_AUTH;
pub const XCN_OID_PKIX_KP_CLIENT_AUTH = CERTENROLL_OBJECTID._PKIX_KP_CLIENT_AUTH;
pub const XCN_OID_PKIX_KP_CODE_SIGNING = CERTENROLL_OBJECTID._PKIX_KP_CODE_SIGNING;
pub const XCN_OID_PKIX_KP_EMAIL_PROTECTION = CERTENROLL_OBJECTID._PKIX_KP_EMAIL_PROTECTION;
pub const XCN_OID_PKIX_KP_IPSEC_END_SYSTEM = CERTENROLL_OBJECTID._PKIX_KP_IPSEC_END_SYSTEM;
pub const XCN_OID_PKIX_KP_IPSEC_TUNNEL = CERTENROLL_OBJECTID._PKIX_KP_IPSEC_TUNNEL;
pub const XCN_OID_PKIX_KP_IPSEC_USER = CERTENROLL_OBJECTID._PKIX_KP_IPSEC_USER;
pub const XCN_OID_PKIX_KP_TIMESTAMP_SIGNING = CERTENROLL_OBJECTID._PKIX_KP_TIMESTAMP_SIGNING;
pub const XCN_OID_PKIX_KP_OCSP_SIGNING = CERTENROLL_OBJECTID._PKIX_KP_OCSP_SIGNING;
pub const XCN_OID_PKIX_OCSP_NOCHECK = CERTENROLL_OBJECTID._PKIX_OCSP_NOCHECK;
pub const XCN_OID_IPSEC_KP_IKE_INTERMEDIATE = CERTENROLL_OBJECTID._IPSEC_KP_IKE_INTERMEDIATE;
pub const XCN_OID_KP_CTL_USAGE_SIGNING = CERTENROLL_OBJECTID._KP_CTL_USAGE_SIGNING;
pub const XCN_OID_KP_TIME_STAMP_SIGNING = CERTENROLL_OBJECTID._KP_TIME_STAMP_SIGNING;
pub const XCN_OID_SERVER_GATED_CRYPTO = CERTENROLL_OBJECTID._SERVER_GATED_CRYPTO;
pub const XCN_OID_SGC_NETSCAPE = CERTENROLL_OBJECTID._SGC_NETSCAPE;
pub const XCN_OID_KP_EFS = CERTENROLL_OBJECTID._KP_EFS;
pub const XCN_OID_EFS_RECOVERY = CERTENROLL_OBJECTID._EFS_RECOVERY;
pub const XCN_OID_WHQL_CRYPTO = CERTENROLL_OBJECTID._WHQL_CRYPTO;
pub const XCN_OID_NT5_CRYPTO = CERTENROLL_OBJECTID._NT5_CRYPTO;
pub const XCN_OID_OEM_WHQL_CRYPTO = CERTENROLL_OBJECTID._OEM_WHQL_CRYPTO;
pub const XCN_OID_EMBEDDED_NT_CRYPTO = CERTENROLL_OBJECTID._EMBEDDED_NT_CRYPTO;
pub const XCN_OID_ROOT_LIST_SIGNER = CERTENROLL_OBJECTID._ROOT_LIST_SIGNER;
pub const XCN_OID_KP_QUALIFIED_SUBORDINATION = CERTENROLL_OBJECTID._KP_QUALIFIED_SUBORDINATION;
pub const XCN_OID_KP_KEY_RECOVERY = CERTENROLL_OBJECTID._KP_KEY_RECOVERY;
pub const XCN_OID_KP_DOCUMENT_SIGNING = CERTENROLL_OBJECTID._KP_DOCUMENT_SIGNING;
pub const XCN_OID_KP_LIFETIME_SIGNING = CERTENROLL_OBJECTID._KP_LIFETIME_SIGNING;
pub const XCN_OID_KP_MOBILE_DEVICE_SOFTWARE = CERTENROLL_OBJECTID._KP_MOBILE_DEVICE_SOFTWARE;
pub const XCN_OID_KP_SMART_DISPLAY = CERTENROLL_OBJECTID._KP_SMART_DISPLAY;
pub const XCN_OID_KP_CSP_SIGNATURE = CERTENROLL_OBJECTID._KP_CSP_SIGNATURE;
pub const XCN_OID_DRM = CERTENROLL_OBJECTID._DRM;
pub const XCN_OID_DRM_INDIVIDUALIZATION = CERTENROLL_OBJECTID._DRM_INDIVIDUALIZATION;
pub const XCN_OID_LICENSES = CERTENROLL_OBJECTID._LICENSES;
pub const XCN_OID_LICENSE_SERVER = CERTENROLL_OBJECTID._LICENSE_SERVER;
pub const XCN_OID_KP_SMARTCARD_LOGON = CERTENROLL_OBJECTID._KP_SMARTCARD_LOGON;
pub const XCN_OID_YESNO_TRUST_ATTR = CERTENROLL_OBJECTID._YESNO_TRUST_ATTR;
pub const XCN_OID_PKIX_POLICY_QUALIFIER_CPS = CERTENROLL_OBJECTID._PKIX_POLICY_QUALIFIER_CPS;
pub const XCN_OID_PKIX_POLICY_QUALIFIER_USERNOTICE = CERTENROLL_OBJECTID._PKIX_POLICY_QUALIFIER_USERNOTICE;
pub const XCN_OID_CERT_POLICIES_95_QUALIFIER1 = CERTENROLL_OBJECTID._CERT_POLICIES_95_QUALIFIER1;
pub const XCN_OID_PKIX_ACC_DESCR = CERTENROLL_OBJECTID._PKIX_ACC_DESCR;
pub const XCN_OID_PKIX_OCSP = CERTENROLL_OBJECTID._PKIX_OCSP;
pub const XCN_OID_PKIX_CA_ISSUERS = CERTENROLL_OBJECTID._PKIX_CA_ISSUERS;
pub const XCN_OID_VERISIGN_PRIVATE_6_9 = CERTENROLL_OBJECTID._VERISIGN_PRIVATE_6_9;
pub const XCN_OID_VERISIGN_ONSITE_JURISDICTION_HASH = CERTENROLL_OBJECTID._VERISIGN_ONSITE_JURISDICTION_HASH;
pub const XCN_OID_VERISIGN_BITSTRING_6_13 = CERTENROLL_OBJECTID._VERISIGN_BITSTRING_6_13;
pub const XCN_OID_VERISIGN_ISS_STRONG_CRYPTO = CERTENROLL_OBJECTID._VERISIGN_ISS_STRONG_CRYPTO;
pub const XCN_OID_NETSCAPE = CERTENROLL_OBJECTID._NETSCAPE;
pub const XCN_OID_NETSCAPE_CERT_EXTENSION = CERTENROLL_OBJECTID._NETSCAPE_CERT_EXTENSION;
pub const XCN_OID_NETSCAPE_CERT_TYPE = CERTENROLL_OBJECTID._NETSCAPE_CERT_TYPE;
pub const XCN_OID_NETSCAPE_BASE_URL = CERTENROLL_OBJECTID._NETSCAPE_BASE_URL;
pub const XCN_OID_NETSCAPE_REVOCATION_URL = CERTENROLL_OBJECTID._NETSCAPE_REVOCATION_URL;
pub const XCN_OID_NETSCAPE_CA_REVOCATION_URL = CERTENROLL_OBJECTID._NETSCAPE_CA_REVOCATION_URL;
pub const XCN_OID_NETSCAPE_CERT_RENEWAL_URL = CERTENROLL_OBJECTID._NETSCAPE_CERT_RENEWAL_URL;
pub const XCN_OID_NETSCAPE_CA_POLICY_URL = CERTENROLL_OBJECTID._NETSCAPE_CA_POLICY_URL;
pub const XCN_OID_NETSCAPE_SSL_SERVER_NAME = CERTENROLL_OBJECTID._NETSCAPE_SSL_SERVER_NAME;
pub const XCN_OID_NETSCAPE_COMMENT = CERTENROLL_OBJECTID._NETSCAPE_COMMENT;
pub const XCN_OID_NETSCAPE_DATA_TYPE = CERTENROLL_OBJECTID._NETSCAPE_DATA_TYPE;
pub const XCN_OID_NETSCAPE_CERT_SEQUENCE = CERTENROLL_OBJECTID._NETSCAPE_CERT_SEQUENCE;
pub const XCN_OID_CT_PKI_DATA = CERTENROLL_OBJECTID._CT_PKI_DATA;
pub const XCN_OID_CT_PKI_RESPONSE = CERTENROLL_OBJECTID._CT_PKI_RESPONSE;
pub const XCN_OID_PKIX_NO_SIGNATURE = CERTENROLL_OBJECTID._PKIX_NO_SIGNATURE;
pub const XCN_OID_CMC = CERTENROLL_OBJECTID._CMC;
pub const XCN_OID_CMC_STATUS_INFO = CERTENROLL_OBJECTID._CMC_STATUS_INFO;
pub const XCN_OID_CMC_IDENTIFICATION = CERTENROLL_OBJECTID._CMC_IDENTIFICATION;
pub const XCN_OID_CMC_IDENTITY_PROOF = CERTENROLL_OBJECTID._CMC_IDENTITY_PROOF;
pub const XCN_OID_CMC_DATA_RETURN = CERTENROLL_OBJECTID._CMC_DATA_RETURN;
pub const XCN_OID_CMC_TRANSACTION_ID = CERTENROLL_OBJECTID._CMC_TRANSACTION_ID;
pub const XCN_OID_CMC_SENDER_NONCE = CERTENROLL_OBJECTID._CMC_SENDER_NONCE;
pub const XCN_OID_CMC_RECIPIENT_NONCE = CERTENROLL_OBJECTID._CMC_RECIPIENT_NONCE;
pub const XCN_OID_CMC_ADD_EXTENSIONS = CERTENROLL_OBJECTID._CMC_ADD_EXTENSIONS;
pub const XCN_OID_CMC_ENCRYPTED_POP = CERTENROLL_OBJECTID._CMC_ENCRYPTED_POP;
pub const XCN_OID_CMC_DECRYPTED_POP = CERTENROLL_OBJECTID._CMC_DECRYPTED_POP;
pub const XCN_OID_CMC_LRA_POP_WITNESS = CERTENROLL_OBJECTID._CMC_LRA_POP_WITNESS;
pub const XCN_OID_CMC_GET_CERT = CERTENROLL_OBJECTID._CMC_GET_CERT;
pub const XCN_OID_CMC_GET_CRL = CERTENROLL_OBJECTID._CMC_GET_CRL;
pub const XCN_OID_CMC_REVOKE_REQUEST = CERTENROLL_OBJECTID._CMC_REVOKE_REQUEST;
pub const XCN_OID_CMC_REG_INFO = CERTENROLL_OBJECTID._CMC_REG_INFO;
pub const XCN_OID_CMC_RESPONSE_INFO = CERTENROLL_OBJECTID._CMC_RESPONSE_INFO;
pub const XCN_OID_CMC_QUERY_PENDING = CERTENROLL_OBJECTID._CMC_QUERY_PENDING;
pub const XCN_OID_CMC_ID_POP_LINK_RANDOM = CERTENROLL_OBJECTID._CMC_ID_POP_LINK_RANDOM;
pub const XCN_OID_CMC_ID_POP_LINK_WITNESS = CERTENROLL_OBJECTID._CMC_ID_POP_LINK_WITNESS;
pub const XCN_OID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = CERTENROLL_OBJECTID._CMC_ID_CONFIRM_CERT_ACCEPTANCE;
pub const XCN_OID_CMC_ADD_ATTRIBUTES = CERTENROLL_OBJECTID._CMC_ADD_ATTRIBUTES;
pub const XCN_OID_LOYALTY_OTHER_LOGOTYPE = CERTENROLL_OBJECTID._LOYALTY_OTHER_LOGOTYPE;
pub const XCN_OID_BACKGROUND_OTHER_LOGOTYPE = CERTENROLL_OBJECTID._BACKGROUND_OTHER_LOGOTYPE;
pub const XCN_OID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = CERTENROLL_OBJECTID._PKIX_OCSP_BASIC_SIGNED_RESPONSE;
pub const XCN_OID_PKCS_7_DATA = CERTENROLL_OBJECTID._PKCS_7_DATA;
pub const XCN_OID_PKCS_7_SIGNED = CERTENROLL_OBJECTID._PKCS_7_SIGNED;
pub const XCN_OID_PKCS_7_ENVELOPED = CERTENROLL_OBJECTID._PKCS_7_ENVELOPED;
pub const XCN_OID_PKCS_7_SIGNEDANDENVELOPED = CERTENROLL_OBJECTID._PKCS_7_SIGNEDANDENVELOPED;
pub const XCN_OID_PKCS_7_DIGESTED = CERTENROLL_OBJECTID._PKCS_7_DIGESTED;
pub const XCN_OID_PKCS_7_ENCRYPTED = CERTENROLL_OBJECTID._PKCS_7_ENCRYPTED;
pub const XCN_OID_PKCS_9_CONTENT_TYPE = CERTENROLL_OBJECTID._PKCS_9_CONTENT_TYPE;
pub const XCN_OID_PKCS_9_MESSAGE_DIGEST = CERTENROLL_OBJECTID._PKCS_9_MESSAGE_DIGEST;
pub const XCN_OID_CERT_PROP_ID_PREFIX = CERTENROLL_OBJECTID._CERT_PROP_ID_PREFIX;
pub const XCN_OID_CERT_KEY_IDENTIFIER_PROP_ID = CERTENROLL_OBJECTID._CERT_KEY_IDENTIFIER_PROP_ID;
pub const XCN_OID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = CERTENROLL_OBJECTID._CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID;
pub const XCN_OID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = CERTENROLL_OBJECTID._CERT_SUBJECT_NAME_MD5_HASH_PROP_ID;
pub const XCN_OID_CERT_MD5_HASH_PROP_ID = CERTENROLL_OBJECTID._CERT_MD5_HASH_PROP_ID;
pub const XCN_OID_RSA_SHA256RSA = CERTENROLL_OBJECTID._RSA_SHA256RSA;
pub const XCN_OID_RSA_SHA384RSA = CERTENROLL_OBJECTID._RSA_SHA384RSA;
pub const XCN_OID_RSA_SHA512RSA = CERTENROLL_OBJECTID._RSA_SHA512RSA;
pub const XCN_OID_NIST_sha256 = CERTENROLL_OBJECTID._NIST_sha256;
pub const XCN_OID_NIST_sha384 = CERTENROLL_OBJECTID._NIST_sha384;
pub const XCN_OID_NIST_sha512 = CERTENROLL_OBJECTID._NIST_sha512;
pub const XCN_OID_RSA_MGF1 = CERTENROLL_OBJECTID._RSA_MGF1;
pub const XCN_OID_ECC_PUBLIC_KEY = CERTENROLL_OBJECTID._ECC_PUBLIC_KEY;
pub const XCN_OID_ECDSA_SHA1 = CERTENROLL_OBJECTID._ECDSA_SHA1;
pub const XCN_OID_ECDSA_SPECIFIED = CERTENROLL_OBJECTID._ECDSA_SPECIFIED;
pub const XCN_OID_ANY_ENHANCED_KEY_USAGE = CERTENROLL_OBJECTID._ANY_ENHANCED_KEY_USAGE;
pub const XCN_OID_RSA_SSA_PSS = CERTENROLL_OBJECTID._RSA_SSA_PSS;
pub const XCN_OID_ATTR_SUPPORTED_ALGORITHMS = CERTENROLL_OBJECTID._ATTR_SUPPORTED_ALGORITHMS;
pub const XCN_OID_ATTR_TPM_SECURITY_ASSERTIONS = CERTENROLL_OBJECTID._ATTR_TPM_SECURITY_ASSERTIONS;
pub const XCN_OID_ATTR_TPM_SPECIFICATION = CERTENROLL_OBJECTID._ATTR_TPM_SPECIFICATION;
pub const XCN_OID_CERT_DISALLOWED_FILETIME_PROP_ID = CERTENROLL_OBJECTID._CERT_DISALLOWED_FILETIME_PROP_ID;
pub const XCN_OID_CERT_SIGNATURE_HASH_PROP_ID = CERTENROLL_OBJECTID._CERT_SIGNATURE_HASH_PROP_ID;
pub const XCN_OID_CERT_STRONG_KEY_OS_1 = CERTENROLL_OBJECTID._CERT_STRONG_KEY_OS_1;
pub const XCN_OID_CERT_STRONG_KEY_OS_CURRENT = CERTENROLL_OBJECTID._CERT_STRONG_KEY_OS_CURRENT;
pub const XCN_OID_CERT_STRONG_KEY_OS_PREFIX = CERTENROLL_OBJECTID._CERT_STRONG_KEY_OS_PREFIX;
pub const XCN_OID_CERT_STRONG_SIGN_OS_1 = CERTENROLL_OBJECTID._CERT_STRONG_SIGN_OS_1;
pub const XCN_OID_CERT_STRONG_SIGN_OS_CURRENT = CERTENROLL_OBJECTID._CERT_STRONG_SIGN_OS_CURRENT;
pub const XCN_OID_CERT_STRONG_SIGN_OS_PREFIX = CERTENROLL_OBJECTID._CERT_STRONG_SIGN_OS_PREFIX;
pub const XCN_OID_DH_SINGLE_PASS_STDDH_SHA1_KDF = CERTENROLL_OBJECTID._DH_SINGLE_PASS_STDDH_SHA1_KDF;
pub const XCN_OID_DH_SINGLE_PASS_STDDH_SHA256_KDF = CERTENROLL_OBJECTID._DH_SINGLE_PASS_STDDH_SHA256_KDF;
pub const XCN_OID_DH_SINGLE_PASS_STDDH_SHA384_KDF = CERTENROLL_OBJECTID._DH_SINGLE_PASS_STDDH_SHA384_KDF;
pub const XCN_OID_DISALLOWED_HASH = CERTENROLL_OBJECTID._DISALLOWED_HASH;
pub const XCN_OID_DISALLOWED_LIST = CERTENROLL_OBJECTID._DISALLOWED_LIST;
pub const XCN_OID_ECC_CURVE_P256 = CERTENROLL_OBJECTID._ECC_CURVE_P256;
pub const XCN_OID_ECC_CURVE_P384 = CERTENROLL_OBJECTID._ECC_CURVE_P384;
pub const XCN_OID_ECC_CURVE_P521 = CERTENROLL_OBJECTID._ECC_CURVE_P521;
pub const XCN_OID_ECDSA_SHA256 = CERTENROLL_OBJECTID._ECDSA_SHA256;
pub const XCN_OID_ECDSA_SHA384 = CERTENROLL_OBJECTID._ECDSA_SHA384;
pub const XCN_OID_ECDSA_SHA512 = CERTENROLL_OBJECTID._ECDSA_SHA512;
pub const XCN_OID_ENROLL_CAXCHGCERT_HASH = CERTENROLL_OBJECTID._ENROLL_CAXCHGCERT_HASH;
pub const XCN_OID_ENROLL_EK_INFO = CERTENROLL_OBJECTID._ENROLL_EK_INFO;
pub const XCN_OID_ENROLL_EKPUB_CHALLENGE = CERTENROLL_OBJECTID._ENROLL_EKPUB_CHALLENGE;
pub const XCN_OID_ENROLL_EKVERIFYCERT = CERTENROLL_OBJECTID._ENROLL_EKVERIFYCERT;
pub const XCN_OID_ENROLL_EKVERIFYCREDS = CERTENROLL_OBJECTID._ENROLL_EKVERIFYCREDS;
pub const XCN_OID_ENROLL_EKVERIFYKEY = CERTENROLL_OBJECTID._ENROLL_EKVERIFYKEY;
pub const XCN_OID_EV_RDN_COUNTRY = CERTENROLL_OBJECTID._EV_RDN_COUNTRY;
pub const XCN_OID_EV_RDN_LOCALE = CERTENROLL_OBJECTID._EV_RDN_LOCALE;
pub const XCN_OID_EV_RDN_STATE_OR_PROVINCE = CERTENROLL_OBJECTID._EV_RDN_STATE_OR_PROVINCE;
pub const XCN_OID_INHIBIT_ANY_POLICY = CERTENROLL_OBJECTID._INHIBIT_ANY_POLICY;
pub const XCN_OID_INTERNATIONALIZED_EMAIL_ADDRESS = CERTENROLL_OBJECTID._INTERNATIONALIZED_EMAIL_ADDRESS;
pub const XCN_OID_KP_KERNEL_MODE_CODE_SIGNING = CERTENROLL_OBJECTID._KP_KERNEL_MODE_CODE_SIGNING;
pub const XCN_OID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = CERTENROLL_OBJECTID._KP_KERNEL_MODE_HAL_EXTENSION_SIGNING;
pub const XCN_OID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = CERTENROLL_OBJECTID._KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING;
pub const XCN_OID_KP_TPM_AIK_CERTIFICATE = CERTENROLL_OBJECTID._KP_TPM_AIK_CERTIFICATE;
pub const XCN_OID_KP_TPM_EK_CERTIFICATE = CERTENROLL_OBJECTID._KP_TPM_EK_CERTIFICATE;
pub const XCN_OID_KP_TPM_PLATFORM_CERTIFICATE = CERTENROLL_OBJECTID._KP_TPM_PLATFORM_CERTIFICATE;
pub const XCN_OID_NIST_AES128_CBC = CERTENROLL_OBJECTID._NIST_AES128_CBC;
pub const XCN_OID_NIST_AES128_WRAP = CERTENROLL_OBJECTID._NIST_AES128_WRAP;
pub const XCN_OID_NIST_AES192_CBC = CERTENROLL_OBJECTID._NIST_AES192_CBC;
pub const XCN_OID_NIST_AES192_WRAP = CERTENROLL_OBJECTID._NIST_AES192_WRAP;
pub const XCN_OID_NIST_AES256_CBC = CERTENROLL_OBJECTID._NIST_AES256_CBC;
pub const XCN_OID_NIST_AES256_WRAP = CERTENROLL_OBJECTID._NIST_AES256_WRAP;
pub const XCN_OID_PKCS_12_PbeIds = CERTENROLL_OBJECTID._PKCS_12_PbeIds;
pub const XCN_OID_PKCS_12_pbeWithSHA1And128BitRC2 = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And128BitRC2;
pub const XCN_OID_PKCS_12_pbeWithSHA1And128BitRC4 = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And128BitRC4;
pub const XCN_OID_PKCS_12_pbeWithSHA1And2KeyTripleDES = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And2KeyTripleDES;
pub const XCN_OID_PKCS_12_pbeWithSHA1And3KeyTripleDES = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And3KeyTripleDES;
pub const XCN_OID_PKCS_12_pbeWithSHA1And40BitRC2 = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And40BitRC2;
pub const XCN_OID_PKCS_12_pbeWithSHA1And40BitRC4 = CERTENROLL_OBJECTID._PKCS_12_pbeWithSHA1And40BitRC4;
pub const XCN_OID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = CERTENROLL_OBJECTID._PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID;
pub const XCN_OID_PKINIT_KP_KDC = CERTENROLL_OBJECTID._PKINIT_KP_KDC;
pub const XCN_OID_PKIX_CA_REPOSITORY = CERTENROLL_OBJECTID._PKIX_CA_REPOSITORY;
pub const XCN_OID_PKIX_OCSP_NONCE = CERTENROLL_OBJECTID._PKIX_OCSP_NONCE;
pub const XCN_OID_PKIX_TIME_STAMPING = CERTENROLL_OBJECTID._PKIX_TIME_STAMPING;
pub const XCN_OID_QC_EU_COMPLIANCE = CERTENROLL_OBJECTID._QC_EU_COMPLIANCE;
pub const XCN_OID_QC_SSCD = CERTENROLL_OBJECTID._QC_SSCD;
pub const XCN_OID_QC_STATEMENTS_EXT = CERTENROLL_OBJECTID._QC_STATEMENTS_EXT;
pub const XCN_OID_RDN_TPM_MANUFACTURER = CERTENROLL_OBJECTID._RDN_TPM_MANUFACTURER;
pub const XCN_OID_RDN_TPM_MODEL = CERTENROLL_OBJECTID._RDN_TPM_MODEL;
pub const XCN_OID_RDN_TPM_VERSION = CERTENROLL_OBJECTID._RDN_TPM_VERSION;
pub const XCN_OID_REVOKED_LIST_SIGNER = CERTENROLL_OBJECTID._REVOKED_LIST_SIGNER;
pub const XCN_OID_RFC3161_counterSign = CERTENROLL_OBJECTID._RFC3161_counterSign;
pub const XCN_OID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = CERTENROLL_OBJECTID._ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION;
pub const XCN_OID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = CERTENROLL_OBJECTID._ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION;
pub const XCN_OID_ROOT_PROGRAM_FLAGS = CERTENROLL_OBJECTID._ROOT_PROGRAM_FLAGS;
pub const XCN_OID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = CERTENROLL_OBJECTID._ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL;
pub const XCN_OID_RSA_PSPECIFIED = CERTENROLL_OBJECTID._RSA_PSPECIFIED;
pub const XCN_OID_RSAES_OAEP = CERTENROLL_OBJECTID._RSAES_OAEP;
pub const XCN_OID_SUBJECT_INFO_ACCESS = CERTENROLL_OBJECTID._SUBJECT_INFO_ACCESS;
pub const XCN_OID_TIMESTAMP_TOKEN = CERTENROLL_OBJECTID._TIMESTAMP_TOKEN;
pub const XCN_OID_ENROLL_SCEP_ERROR = CERTENROLL_OBJECTID._ENROLL_SCEP_ERROR;
pub const XCN_OIDVerisign_MessageType = CERTENROLL_OBJECTID.Verisign_MessageType;
pub const XCN_OIDVerisign_PkiStatus = CERTENROLL_OBJECTID.Verisign_PkiStatus;
pub const XCN_OIDVerisign_FailInfo = CERTENROLL_OBJECTID.Verisign_FailInfo;
pub const XCN_OIDVerisign_SenderNonce = CERTENROLL_OBJECTID.Verisign_SenderNonce;
pub const XCN_OIDVerisign_RecipientNonce = CERTENROLL_OBJECTID.Verisign_RecipientNonce;
pub const XCN_OIDVerisign_TransactionID = CERTENROLL_OBJECTID.Verisign_TransactionID;
pub const XCN_OID_ENROLL_ATTESTATION_CHALLENGE = CERTENROLL_OBJECTID._ENROLL_ATTESTATION_CHALLENGE;
pub const XCN_OID_ENROLL_ATTESTATION_STATEMENT = CERTENROLL_OBJECTID._ENROLL_ATTESTATION_STATEMENT;
pub const XCN_OID_ENROLL_ENCRYPTION_ALGORITHM = CERTENROLL_OBJECTID._ENROLL_ENCRYPTION_ALGORITHM;
pub const XCN_OID_ENROLL_KSP_NAME = CERTENROLL_OBJECTID._ENROLL_KSP_NAME;

pub const WebSecurityLevel = extern enum(i32) {
    Unsafe = 0,
    Safe = 1,
};
pub const LevelUnsafe = WebSecurityLevel.Unsafe;
pub const LevelSafe = WebSecurityLevel.Safe;

pub const EncodingType = extern enum(i32) {
    BASE64HEADER = 0,
    BASE64 = 1,
    BINARY = 2,
    BASE64REQUESTHEADER = 3,
    HEX = 4,
    HEXASCII = 5,
    BASE64_ANY = 6,
    ANY = 7,
    HEX_ANY = 8,
    BASE64X509CRLHEADER = 9,
    HEXADDR = 10,
    HEXASCIIADDR = 11,
    HEXRAW = 12,
    BASE64URI = 13,
    ENCODEMASK = 255,
    CHAIN = 256,
    TEXT = 512,
    PERCENTESCAPE = 134217728,
    HASHDATA = 268435456,
    STRICT = 536870912,
    NOCRLF = 1073741824,
    NOCR = -2147483648,
};
pub const XCN_CRYPT_STRING_BASE64HEADER = EncodingType.BASE64HEADER;
pub const XCN_CRYPT_STRING_BASE64 = EncodingType.BASE64;
pub const XCN_CRYPT_STRING_BINARY = EncodingType.BINARY;
pub const XCN_CRYPT_STRING_BASE64REQUESTHEADER = EncodingType.BASE64REQUESTHEADER;
pub const XCN_CRYPT_STRING_HEX = EncodingType.HEX;
pub const XCN_CRYPT_STRING_HEXASCII = EncodingType.HEXASCII;
pub const XCN_CRYPT_STRING_BASE64_ANY = EncodingType.BASE64_ANY;
pub const XCN_CRYPT_STRING_ANY = EncodingType.ANY;
pub const XCN_CRYPT_STRING_HEX_ANY = EncodingType.HEX_ANY;
pub const XCN_CRYPT_STRING_BASE64X509CRLHEADER = EncodingType.BASE64X509CRLHEADER;
pub const XCN_CRYPT_STRING_HEXADDR = EncodingType.HEXADDR;
pub const XCN_CRYPT_STRING_HEXASCIIADDR = EncodingType.HEXASCIIADDR;
pub const XCN_CRYPT_STRING_HEXRAW = EncodingType.HEXRAW;
pub const XCN_CRYPT_STRING_BASE64URI = EncodingType.BASE64URI;
pub const XCN_CRYPT_STRING_ENCODEMASK = EncodingType.ENCODEMASK;
pub const XCN_CRYPT_STRING_CHAIN = EncodingType.CHAIN;
pub const XCN_CRYPT_STRING_TEXT = EncodingType.TEXT;
pub const XCN_CRYPT_STRING_PERCENTESCAPE = EncodingType.PERCENTESCAPE;
pub const XCN_CRYPT_STRING_HASHDATA = EncodingType.HASHDATA;
pub const XCN_CRYPT_STRING_STRICT = EncodingType.STRICT;
pub const XCN_CRYPT_STRING_NOCRLF = EncodingType.NOCRLF;
pub const XCN_CRYPT_STRING_NOCR = EncodingType.NOCR;

pub const PFXExportOptions = extern enum(i32) {
    EEOnly = 0,
    ChainNoRoot = 1,
    ChainWithRoot = 2,
};
pub const PFXExportEEOnly = PFXExportOptions.EEOnly;
pub const PFXExportChainNoRoot = PFXExportOptions.ChainNoRoot;
pub const PFXExportChainWithRoot = PFXExportOptions.ChainWithRoot;

pub const ObjectIdGroupId = extern enum(i32) {
    ANY_GROUP_ID = 0,
    HASH_ALG_OID_GROUP_ID = 1,
    ENCRYPT_ALG_OID_GROUP_ID = 2,
    PUBKEY_ALG_OID_GROUP_ID = 3,
    SIGN_ALG_OID_GROUP_ID = 4,
    RDN_ATTR_OID_GROUP_ID = 5,
    EXT_OR_ATTR_OID_GROUP_ID = 6,
    ENHKEY_USAGE_OID_GROUP_ID = 7,
    POLICY_OID_GROUP_ID = 8,
    TEMPLATE_OID_GROUP_ID = 9,
    KDF_OID_GROUP_ID = 10,
    LAST_OID_GROUP_ID = 10,
    FIRST_ALG_OID_GROUP_ID = 1,
    LAST_ALG_OID_GROUP_ID = 4,
    GROUP_ID_MASK = 65535,
    OID_PREFER_CNG_ALGID_FLAG = 1073741824,
    OID_DISABLE_SEARCH_DS_FLAG = -2147483648,
    OID_INFO_OID_GROUP_BIT_LEN_MASK = 268369920,
    OID_INFO_OID_GROUP_BIT_LEN_SHIFT = 16,
    KEY_LENGTH_MASK = 268369920,
};
pub const XCN_CRYPT_ANY_GROUP_ID = ObjectIdGroupId.ANY_GROUP_ID;
pub const XCN_CRYPT_HASH_ALG_OID_GROUP_ID = ObjectIdGroupId.HASH_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_ENCRYPT_ALG_OID_GROUP_ID = ObjectIdGroupId.ENCRYPT_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_PUBKEY_ALG_OID_GROUP_ID = ObjectIdGroupId.PUBKEY_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_SIGN_ALG_OID_GROUP_ID = ObjectIdGroupId.SIGN_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_RDN_ATTR_OID_GROUP_ID = ObjectIdGroupId.RDN_ATTR_OID_GROUP_ID;
pub const XCN_CRYPT_EXT_OR_ATTR_OID_GROUP_ID = ObjectIdGroupId.EXT_OR_ATTR_OID_GROUP_ID;
pub const XCN_CRYPT_ENHKEY_USAGE_OID_GROUP_ID = ObjectIdGroupId.ENHKEY_USAGE_OID_GROUP_ID;
pub const XCN_CRYPT_POLICY_OID_GROUP_ID = ObjectIdGroupId.POLICY_OID_GROUP_ID;
pub const XCN_CRYPT_TEMPLATE_OID_GROUP_ID = ObjectIdGroupId.TEMPLATE_OID_GROUP_ID;
pub const XCN_CRYPT_KDF_OID_GROUP_ID = ObjectIdGroupId.KDF_OID_GROUP_ID;
pub const XCN_CRYPT_LAST_OID_GROUP_ID = ObjectIdGroupId.LAST_OID_GROUP_ID;
pub const XCN_CRYPT_FIRST_ALG_OID_GROUP_ID = ObjectIdGroupId.FIRST_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_LAST_ALG_OID_GROUP_ID = ObjectIdGroupId.LAST_ALG_OID_GROUP_ID;
pub const XCN_CRYPT_GROUP_ID_MASK = ObjectIdGroupId.GROUP_ID_MASK;
pub const XCN_CRYPT_OID_PREFER_CNG_ALGID_FLAG = ObjectIdGroupId.OID_PREFER_CNG_ALGID_FLAG;
pub const XCN_CRYPT_OID_DISABLE_SEARCH_DS_FLAG = ObjectIdGroupId.OID_DISABLE_SEARCH_DS_FLAG;
pub const XCN_CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = ObjectIdGroupId.OID_INFO_OID_GROUP_BIT_LEN_MASK;
pub const XCN_CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = ObjectIdGroupId.OID_INFO_OID_GROUP_BIT_LEN_SHIFT;
pub const XCN_CRYPT_KEY_LENGTH_MASK = ObjectIdGroupId.KEY_LENGTH_MASK;

pub const ObjectIdPublicKeyFlags = extern enum(i32) {
    ANY = 0,
    SIGN_KEY_FLAG = -2147483648,
    ENCRYPT_KEY_FLAG = 1073741824,
};
pub const XCN_CRYPT_OID_INFO_PUBKEY_ANY = ObjectIdPublicKeyFlags.ANY;
pub const XCN_CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = ObjectIdPublicKeyFlags.SIGN_KEY_FLAG;
pub const XCN_CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = ObjectIdPublicKeyFlags.ENCRYPT_KEY_FLAG;

pub const AlgorithmFlags = extern enum(i32) {
    None = 0,
    Wrap = 1,
};
pub const AlgorithmFlagsNone = AlgorithmFlags.None;
pub const AlgorithmFlagsWrap = AlgorithmFlags.Wrap;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectId_Value = @import("../zig.zig").Guid.initString("728ab300-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IObjectId = &IID_IObjectId_Value;
pub const IObjectId = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeFromName: fn(
            self: *const IObjectId,
            Name: CERTENROLL_OBJECTID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromValue: fn(
            self: *const IObjectId,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromAlgorithmName: fn(
            self: *const IObjectId,
            GroupId: ObjectIdGroupId,
            KeyFlags: ObjectIdPublicKeyFlags,
            AlgFlags: AlgorithmFlags,
            strAlgorithmName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IObjectId,
            pValue: *CERTENROLL_OBJECTID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: fn(
            self: *const IObjectId,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FriendlyName: fn(
            self: *const IObjectId,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IObjectId,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlgorithmName: fn(
            self: *const IObjectId,
            GroupId: ObjectIdGroupId,
            KeyFlags: ObjectIdPublicKeyFlags,
            pstrAlgorithmName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_InitializeFromName(self: *const T, Name: CERTENROLL_OBJECTID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).InitializeFromName(@ptrCast(*const IObjectId, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_InitializeFromValue(self: *const T, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).InitializeFromValue(@ptrCast(*const IObjectId, self), strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_InitializeFromAlgorithmName(self: *const T, GroupId: ObjectIdGroupId, KeyFlags: ObjectIdPublicKeyFlags, AlgFlags: AlgorithmFlags, strAlgorithmName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).InitializeFromAlgorithmName(@ptrCast(*const IObjectId, self), GroupId, KeyFlags, AlgFlags, strAlgorithmName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_get_Name(self: *const T, pValue: *CERTENROLL_OBJECTID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).get_Name(@ptrCast(*const IObjectId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_get_FriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).get_FriendlyName(@ptrCast(*const IObjectId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_put_FriendlyName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).put_FriendlyName(@ptrCast(*const IObjectId, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_get_Value(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).get_Value(@ptrCast(*const IObjectId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectId_GetAlgorithmName(self: *const T, GroupId: ObjectIdGroupId, KeyFlags: ObjectIdPublicKeyFlags, pstrAlgorithmName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectId.VTable, self.vtable).GetAlgorithmName(@ptrCast(*const IObjectId, self), GroupId, KeyFlags, pstrAlgorithmName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectIds_Value = @import("../zig.zig").Guid.initString("728ab301-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IObjectIds = &IID_IObjectIds_Value;
pub const IObjectIds = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IObjectIds,
            Index: i32,
            pVal: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IObjectIds,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IObjectIds,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IObjectIds,
            pVal: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IObjectIds,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IObjectIds,
            pValue: ?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IObjectIds, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).get_Count(@ptrCast(*const IObjectIds, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).get__NewEnum(@ptrCast(*const IObjectIds, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_Add(self: *const T, pVal: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).Add(@ptrCast(*const IObjectIds, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).Remove(@ptrCast(*const IObjectIds, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).Clear(@ptrCast(*const IObjectIds, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectIds_AddRange(self: *const T, pValue: ?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectIds.VTable, self.vtable).AddRange(@ptrCast(*const IObjectIds, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBinaryConverter_Value = @import("../zig.zig").Guid.initString("728ab302-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IBinaryConverter = &IID_IBinaryConverter_Value;
pub const IBinaryConverter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StringToString: fn(
            self: *const IBinaryConverter,
            strEncodedIn: BSTR,
            EncodingIn: EncodingType,
            Encoding: EncodingType,
            pstrEncoded: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VariantByteArrayToString: fn(
            self: *const IBinaryConverter,
            pvarByteArray: *VARIANT,
            Encoding: EncodingType,
            pstrEncoded: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StringToVariantByteArray: fn(
            self: *const IBinaryConverter,
            strEncoded: BSTR,
            Encoding: EncodingType,
            pvarByteArray: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinaryConverter_StringToString(self: *const T, strEncodedIn: BSTR, EncodingIn: EncodingType, Encoding: EncodingType, pstrEncoded: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinaryConverter.VTable, self.vtable).StringToString(@ptrCast(*const IBinaryConverter, self), strEncodedIn, EncodingIn, Encoding, pstrEncoded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinaryConverter_VariantByteArrayToString(self: *const T, pvarByteArray: *VARIANT, Encoding: EncodingType, pstrEncoded: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinaryConverter.VTable, self.vtable).VariantByteArrayToString(@ptrCast(*const IBinaryConverter, self), pvarByteArray, Encoding, pstrEncoded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinaryConverter_StringToVariantByteArray(self: *const T, strEncoded: BSTR, Encoding: EncodingType, pvarByteArray: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinaryConverter.VTable, self.vtable).StringToVariantByteArray(@ptrCast(*const IBinaryConverter, self), strEncoded, Encoding, pvarByteArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBinaryConverter2_Value = @import("../zig.zig").Guid.initString("8d7928b4-4e17-428d-9a17-728df00d1b2b");
pub const IID_IBinaryConverter2 = &IID_IBinaryConverter2_Value;
pub const IBinaryConverter2 = extern struct {
    pub const VTable = extern struct {
        base: IBinaryConverter.VTable,
        StringArrayToVariantArray: fn(
            self: *const IBinaryConverter2,
            pvarStringArray: *VARIANT,
            pvarVariantArray: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VariantArrayToStringArray: fn(
            self: *const IBinaryConverter2,
            pvarVariantArray: *VARIANT,
            pvarStringArray: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBinaryConverter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinaryConverter2_StringArrayToVariantArray(self: *const T, pvarStringArray: *VARIANT, pvarVariantArray: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinaryConverter2.VTable, self.vtable).StringArrayToVariantArray(@ptrCast(*const IBinaryConverter2, self), pvarStringArray, pvarVariantArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinaryConverter2_VariantArrayToStringArray(self: *const T, pvarVariantArray: *VARIANT, pvarStringArray: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinaryConverter2.VTable, self.vtable).VariantArrayToStringArray(@ptrCast(*const IBinaryConverter2, self), pvarVariantArray, pvarStringArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X500NameFlags = extern enum(i32) {
    NAME_STR_NONE = 0,
    SIMPLE_NAME_STR = 1,
    OID_NAME_STR = 2,
    X500_NAME_STR = 3,
    XML_NAME_STR = 4,
    NAME_STR_SEMICOLON_FLAG = 1073741824,
    NAME_STR_NO_PLUS_FLAG = 536870912,
    NAME_STR_NO_QUOTING_FLAG = 268435456,
    NAME_STR_CRLF_FLAG = 134217728,
    NAME_STR_COMMA_FLAG = 67108864,
    NAME_STR_REVERSE_FLAG = 33554432,
    NAME_STR_FORWARD_FLAG = 16777216,
    NAME_STR_AMBIGUOUS_SEPARATOR_FLAGS = 1275068416,
    NAME_STR_DISABLE_IE4_UTF8_FLAG = 65536,
    NAME_STR_ENABLE_T61_UNICODE_FLAG = 131072,
    NAME_STR_ENABLE_UTF8_UNICODE_FLAG = 262144,
    NAME_STR_FORCE_UTF8_DIR_STR_FLAG = 524288,
    NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = 1048576,
    NAME_STR_ENABLE_PUNYCODE_FLAG = 2097152,
    NAME_STR_DS_ESCAPED = 8388608,
};
pub const XCN_CERT_NAME_STR_NONE = X500NameFlags.NAME_STR_NONE;
pub const XCN_CERT_SIMPLE_NAME_STR = X500NameFlags.SIMPLE_NAME_STR;
pub const XCN_CERT_OID_NAME_STR = X500NameFlags.OID_NAME_STR;
pub const XCN_CERT_X500_NAME_STR = X500NameFlags.X500_NAME_STR;
pub const XCN_CERT_XML_NAME_STR = X500NameFlags.XML_NAME_STR;
pub const XCN_CERT_NAME_STR_SEMICOLON_FLAG = X500NameFlags.NAME_STR_SEMICOLON_FLAG;
pub const XCN_CERT_NAME_STR_NO_PLUS_FLAG = X500NameFlags.NAME_STR_NO_PLUS_FLAG;
pub const XCN_CERT_NAME_STR_NO_QUOTING_FLAG = X500NameFlags.NAME_STR_NO_QUOTING_FLAG;
pub const XCN_CERT_NAME_STR_CRLF_FLAG = X500NameFlags.NAME_STR_CRLF_FLAG;
pub const XCN_CERT_NAME_STR_COMMA_FLAG = X500NameFlags.NAME_STR_COMMA_FLAG;
pub const XCN_CERT_NAME_STR_REVERSE_FLAG = X500NameFlags.NAME_STR_REVERSE_FLAG;
pub const XCN_CERT_NAME_STR_FORWARD_FLAG = X500NameFlags.NAME_STR_FORWARD_FLAG;
pub const XCN_CERT_NAME_STR_AMBIGUOUS_SEPARATOR_FLAGS = X500NameFlags.NAME_STR_AMBIGUOUS_SEPARATOR_FLAGS;
pub const XCN_CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = X500NameFlags.NAME_STR_DISABLE_IE4_UTF8_FLAG;
pub const XCN_CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = X500NameFlags.NAME_STR_ENABLE_T61_UNICODE_FLAG;
pub const XCN_CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = X500NameFlags.NAME_STR_ENABLE_UTF8_UNICODE_FLAG;
pub const XCN_CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = X500NameFlags.NAME_STR_FORCE_UTF8_DIR_STR_FLAG;
pub const XCN_CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = X500NameFlags.NAME_STR_DISABLE_UTF8_DIR_STR_FLAG;
pub const XCN_CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = X500NameFlags.NAME_STR_ENABLE_PUNYCODE_FLAG;
pub const XCN_CERT_NAME_STR_DS_ESCAPED = X500NameFlags.NAME_STR_DS_ESCAPED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX500DistinguishedName_Value = @import("../zig.zig").Guid.initString("728ab303-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX500DistinguishedName = &IID_IX500DistinguishedName_Value;
pub const IX500DistinguishedName = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const IX500DistinguishedName,
            strEncodedName: BSTR,
            Encoding: EncodingType,
            NameFlags: X500NameFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const IX500DistinguishedName,
            strName: BSTR,
            NameFlags: X500NameFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IX500DistinguishedName,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncodedName: fn(
            self: *const IX500DistinguishedName,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX500DistinguishedName_Decode(self: *const T, strEncodedName: BSTR, Encoding: EncodingType, NameFlags: X500NameFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX500DistinguishedName.VTable, self.vtable).Decode(@ptrCast(*const IX500DistinguishedName, self), strEncodedName, Encoding, NameFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX500DistinguishedName_Encode(self: *const T, strName: BSTR, NameFlags: X500NameFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX500DistinguishedName.VTable, self.vtable).Encode(@ptrCast(*const IX500DistinguishedName, self), strName, NameFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX500DistinguishedName_get_Name(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX500DistinguishedName.VTable, self.vtable).get_Name(@ptrCast(*const IX500DistinguishedName, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX500DistinguishedName_get_EncodedName(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX500DistinguishedName.VTable, self.vtable).get_EncodedName(@ptrCast(*const IX500DistinguishedName, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509CertificateEnrollmentContext = extern enum(i32) {
    None = 0,
    User = 1,
    Machine = 2,
    AdministratorForceMachine = 3,
};
pub const ContextNone = X509CertificateEnrollmentContext.None;
pub const ContextUser = X509CertificateEnrollmentContext.User;
pub const ContextMachine = X509CertificateEnrollmentContext.Machine;
pub const ContextAdministratorForceMachine = X509CertificateEnrollmentContext.AdministratorForceMachine;

pub const EnrollmentEnrollStatus = extern enum(i32) {
    ed = 1,
    Pended = 2,
    UIDeferredEnrollmentRequired = 4,
    Error = 16,
    Unknown = 32,
    Skipped = 64,
    Denied = 256,
};
pub const Enrolled = EnrollmentEnrollStatus.ed;
pub const EnrollPended = EnrollmentEnrollStatus.Pended;
pub const EnrollUIDeferredEnrollmentRequired = EnrollmentEnrollStatus.UIDeferredEnrollmentRequired;
pub const EnrollError = EnrollmentEnrollStatus.Error;
pub const EnrollUnknown = EnrollmentEnrollStatus.Unknown;
pub const EnrollSkipped = EnrollmentEnrollStatus.Skipped;
pub const EnrollDenied = EnrollmentEnrollStatus.Denied;

pub const EnrollmentSelectionStatus = extern enum(i32) {
    No = 0,
    Yes = 1,
};
pub const SelectedNo = EnrollmentSelectionStatus.No;
pub const SelectedYes = EnrollmentSelectionStatus.Yes;

pub const EnrollmentDisplayStatus = extern enum(i32) {
    No = 0,
    Yes = 1,
};
pub const DisplayNo = EnrollmentDisplayStatus.No;
pub const DisplayYes = EnrollmentDisplayStatus.Yes;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509EnrollmentStatus_Value = @import("../zig.zig").Guid.initString("728ab304-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509EnrollmentStatus = &IID_IX509EnrollmentStatus_Value;
pub const IX509EnrollmentStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AppendText: fn(
            self: *const IX509EnrollmentStatus,
            strText: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Text: fn(
            self: *const IX509EnrollmentStatus,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Text: fn(
            self: *const IX509EnrollmentStatus,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selected: fn(
            self: *const IX509EnrollmentStatus,
            pValue: *EnrollmentSelectionStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Selected: fn(
            self: *const IX509EnrollmentStatus,
            Value: EnrollmentSelectionStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Display: fn(
            self: *const IX509EnrollmentStatus,
            pValue: *EnrollmentDisplayStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Display: fn(
            self: *const IX509EnrollmentStatus,
            Value: EnrollmentDisplayStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IX509EnrollmentStatus,
            pValue: *EnrollmentEnrollStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Status: fn(
            self: *const IX509EnrollmentStatus,
            Value: EnrollmentEnrollStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: fn(
            self: *const IX509EnrollmentStatus,
            pValue: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Error: fn(
            self: *const IX509EnrollmentStatus,
            Value: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorText: fn(
            self: *const IX509EnrollmentStatus,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_AppendText(self: *const T, strText: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).AppendText(@ptrCast(*const IX509EnrollmentStatus, self), strText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_Text(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_Text(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_put_Text(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).put_Text(@ptrCast(*const IX509EnrollmentStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_Selected(self: *const T, pValue: *EnrollmentSelectionStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_Selected(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_put_Selected(self: *const T, Value: EnrollmentSelectionStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).put_Selected(@ptrCast(*const IX509EnrollmentStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_Display(self: *const T, pValue: *EnrollmentDisplayStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_Display(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_put_Display(self: *const T, Value: EnrollmentDisplayStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).put_Display(@ptrCast(*const IX509EnrollmentStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_Status(self: *const T, pValue: *EnrollmentEnrollStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_Status(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_put_Status(self: *const T, Value: EnrollmentEnrollStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).put_Status(@ptrCast(*const IX509EnrollmentStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_Error(self: *const T, pValue: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_Error(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_put_Error(self: *const T, Value: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).put_Error(@ptrCast(*const IX509EnrollmentStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentStatus_get_ErrorText(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentStatus.VTable, self.vtable).get_ErrorText(@ptrCast(*const IX509EnrollmentStatus, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509ProviderType = extern enum(i32) {
    NONE = 0,
    RSA_FULL = 1,
    RSA_SIG = 2,
    DSS = 3,
    FORTEZZA = 4,
    MS_EXCHANGE = 5,
    SSL = 6,
    RSA_SCHANNEL = 12,
    DSS_DH = 13,
    EC_ECDSA_SIG = 14,
    EC_ECNRA_SIG = 15,
    EC_ECDSA_FULL = 16,
    EC_ECNRA_FULL = 17,
    DH_SCHANNEL = 18,
    SPYRUS_LYNKS = 20,
    RNG = 21,
    INTEL_SEC = 22,
    REPLACE_OWF = 23,
    RSA_AES = 24,
};
pub const XCN_PROV_NONE = X509ProviderType.NONE;
pub const XCN_PROV_RSA_FULL = X509ProviderType.RSA_FULL;
pub const XCN_PROV_RSA_SIG = X509ProviderType.RSA_SIG;
pub const XCN_PROV_DSS = X509ProviderType.DSS;
pub const XCN_PROV_FORTEZZA = X509ProviderType.FORTEZZA;
pub const XCN_PROV_MS_EXCHANGE = X509ProviderType.MS_EXCHANGE;
pub const XCN_PROV_SSL = X509ProviderType.SSL;
pub const XCN_PROV_RSA_SCHANNEL = X509ProviderType.RSA_SCHANNEL;
pub const XCN_PROV_DSS_DH = X509ProviderType.DSS_DH;
pub const XCN_PROV_EC_ECDSA_SIG = X509ProviderType.EC_ECDSA_SIG;
pub const XCN_PROV_EC_ECNRA_SIG = X509ProviderType.EC_ECNRA_SIG;
pub const XCN_PROV_EC_ECDSA_FULL = X509ProviderType.EC_ECDSA_FULL;
pub const XCN_PROV_EC_ECNRA_FULL = X509ProviderType.EC_ECNRA_FULL;
pub const XCN_PROV_DH_SCHANNEL = X509ProviderType.DH_SCHANNEL;
pub const XCN_PROV_SPYRUS_LYNKS = X509ProviderType.SPYRUS_LYNKS;
pub const XCN_PROV_RNG = X509ProviderType.RNG;
pub const XCN_PROV_INTEL_SEC = X509ProviderType.INTEL_SEC;
pub const XCN_PROV_REPLACE_OWF = X509ProviderType.REPLACE_OWF;
pub const XCN_PROV_RSA_AES = X509ProviderType.RSA_AES;

pub const AlgorithmType = extern enum(i32) {
    UNKNOWN_INTERFACE = 0,
    CIPHER_INTERFACE = 1,
    HASH_INTERFACE = 2,
    ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    SIGNATURE_INTERFACE = 5,
    SECRET_AGREEMENT_INTERFACE = 4,
    RNG_INTERFACE = 6,
    KEY_DERIVATION_INTERFACE = 7,
};
pub const XCN_BCRYPT_UNKNOWN_INTERFACE = AlgorithmType.UNKNOWN_INTERFACE;
pub const XCN_BCRYPT_CIPHER_INTERFACE = AlgorithmType.CIPHER_INTERFACE;
pub const XCN_BCRYPT_HASH_INTERFACE = AlgorithmType.HASH_INTERFACE;
pub const XCN_BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = AlgorithmType.ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const XCN_BCRYPT_SIGNATURE_INTERFACE = AlgorithmType.SIGNATURE_INTERFACE;
pub const XCN_BCRYPT_SECRET_AGREEMENT_INTERFACE = AlgorithmType.SECRET_AGREEMENT_INTERFACE;
pub const XCN_BCRYPT_RNG_INTERFACE = AlgorithmType.RNG_INTERFACE;
pub const XCN_BCRYPT_KEY_DERIVATION_INTERFACE = AlgorithmType.KEY_DERIVATION_INTERFACE;

pub const AlgorithmOperationFlags = extern enum(i32) {
    NO_OPERATION = 0,
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    RNG_OPERATION = 32,
    KEY_DERIVATION_OPERATION = 64,
    ANY_ASYMMETRIC_OPERATION = 28,
    PREFER_SIGNATURE_ONLY_OPERATION = 2097152,
    PREFER_NON_SIGNATURE_OPERATION = 4194304,
    EXACT_MATCH_OPERATION = 8388608,
    PREFERENCE_MASK_OPERATION = 14680064,
};
pub const XCN_NCRYPT_NO_OPERATION = AlgorithmOperationFlags.NO_OPERATION;
pub const XCN_NCRYPT_CIPHER_OPERATION = AlgorithmOperationFlags.CIPHER_OPERATION;
pub const XCN_NCRYPT_HASH_OPERATION = AlgorithmOperationFlags.HASH_OPERATION;
pub const XCN_NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = AlgorithmOperationFlags.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const XCN_NCRYPT_SECRET_AGREEMENT_OPERATION = AlgorithmOperationFlags.SECRET_AGREEMENT_OPERATION;
pub const XCN_NCRYPT_SIGNATURE_OPERATION = AlgorithmOperationFlags.SIGNATURE_OPERATION;
pub const XCN_NCRYPT_RNG_OPERATION = AlgorithmOperationFlags.RNG_OPERATION;
pub const XCN_NCRYPT_KEY_DERIVATION_OPERATION = AlgorithmOperationFlags.KEY_DERIVATION_OPERATION;
pub const XCN_NCRYPT_ANY_ASYMMETRIC_OPERATION = AlgorithmOperationFlags.ANY_ASYMMETRIC_OPERATION;
pub const XCN_NCRYPT_PREFER_SIGNATURE_ONLY_OPERATION = AlgorithmOperationFlags.PREFER_SIGNATURE_ONLY_OPERATION;
pub const XCN_NCRYPT_PREFER_NON_SIGNATURE_OPERATION = AlgorithmOperationFlags.PREFER_NON_SIGNATURE_OPERATION;
pub const XCN_NCRYPT_EXACT_MATCH_OPERATION = AlgorithmOperationFlags.EXACT_MATCH_OPERATION;
pub const XCN_NCRYPT_PREFERENCE_MASK_OPERATION = AlgorithmOperationFlags.PREFERENCE_MASK_OPERATION;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspAlgorithm_Value = @import("../zig.zig").Guid.initString("728ab305-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspAlgorithm = &IID_ICspAlgorithm_Value;
pub const ICspAlgorithm = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlgorithmOid: fn(
            self: *const ICspAlgorithm,
            Length: i32,
            AlgFlags: AlgorithmFlags,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultLength: fn(
            self: *const ICspAlgorithm,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncrementLength: fn(
            self: *const ICspAlgorithm,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LongName: fn(
            self: *const ICspAlgorithm,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Valid: fn(
            self: *const ICspAlgorithm,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxLength: fn(
            self: *const ICspAlgorithm,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinLength: fn(
            self: *const ICspAlgorithm,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const ICspAlgorithm,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const ICspAlgorithm,
            pValue: *AlgorithmType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operations: fn(
            self: *const ICspAlgorithm,
            pValue: *AlgorithmOperationFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_GetAlgorithmOid(self: *const T, Length: i32, AlgFlags: AlgorithmFlags, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).GetAlgorithmOid(@ptrCast(*const ICspAlgorithm, self), Length, AlgFlags, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_DefaultLength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_DefaultLength(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_IncrementLength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_IncrementLength(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_LongName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_LongName(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_Valid(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_Valid(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_MaxLength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_MaxLength(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_MinLength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_MinLength(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_Name(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_Name(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_Type(self: *const T, pValue: *AlgorithmType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_Type(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithm_get_Operations(self: *const T, pValue: *AlgorithmOperationFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithm.VTable, self.vtable).get_Operations(@ptrCast(*const ICspAlgorithm, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspAlgorithms_Value = @import("../zig.zig").Guid.initString("728ab306-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspAlgorithms = &IID_ICspAlgorithms_Value;
pub const ICspAlgorithms = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICspAlgorithms,
            Index: i32,
            pVal: ?*?*ICspAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICspAlgorithms,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICspAlgorithms,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICspAlgorithms,
            pVal: ?*ICspAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICspAlgorithms,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICspAlgorithms,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const ICspAlgorithms,
            strName: BSTR,
            ppValue: ?*?*ICspAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IndexByObjectId: fn(
            self: *const ICspAlgorithms,
            pObjectId: ?*IObjectId,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICspAlgorithm) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICspAlgorithms, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).get_Count(@ptrCast(*const ICspAlgorithms, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICspAlgorithms, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_Add(self: *const T, pVal: ?*ICspAlgorithm) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).Add(@ptrCast(*const ICspAlgorithms, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).Remove(@ptrCast(*const ICspAlgorithms, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).Clear(@ptrCast(*const ICspAlgorithms, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_get_ItemByName(self: *const T, strName: BSTR, ppValue: ?*?*ICspAlgorithm) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).get_ItemByName(@ptrCast(*const ICspAlgorithms, self), strName, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspAlgorithms_get_IndexByObjectId(self: *const T, pObjectId: ?*IObjectId, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspAlgorithms.VTable, self.vtable).get_IndexByObjectId(@ptrCast(*const ICspAlgorithms, self), pObjectId, pIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509KeySpec = extern enum(i32) {
    NONE = 0,
    KEYEXCHANGE = 1,
    SIGNATURE = 2,
};
pub const XCN_AT_NONE = X509KeySpec.NONE;
pub const XCN_AT_KEYEXCHANGE = X509KeySpec.KEYEXCHANGE;
pub const XCN_AT_SIGNATURE = X509KeySpec.SIGNATURE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspInformation_Value = @import("../zig.zig").Guid.initString("728ab307-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspInformation = &IID_ICspInformation_Value;
pub const ICspInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeFromName: fn(
            self: *const ICspInformation,
            strName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromType: fn(
            self: *const ICspInformation,
            Type: X509ProviderType,
            pAlgorithm: ?*IObjectId,
            MachineContext: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspAlgorithms: fn(
            self: *const ICspInformation,
            ppValue: ?*?*ICspAlgorithms,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HasHardwareRandomNumberGenerator: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHardwareDevice: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRemovable: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSoftwareDevice: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Valid: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxKeyContainerNameLength: fn(
            self: *const ICspInformation,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const ICspInformation,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const ICspInformation,
            pValue: *X509ProviderType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const ICspInformation,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const ICspInformation,
            pValue: *X509KeySpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSmartCard: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSecurityDescriptor: fn(
            self: *const ICspInformation,
            MachineContext: i16,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LegacyCsp: fn(
            self: *const ICspInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCspStatusFromOperations: fn(
            self: *const ICspInformation,
            pAlgorithm: ?*IObjectId,
            Operations: AlgorithmOperationFlags,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_InitializeFromName(self: *const T, strName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).InitializeFromName(@ptrCast(*const ICspInformation, self), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_InitializeFromType(self: *const T, Type: X509ProviderType, pAlgorithm: ?*IObjectId, MachineContext: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).InitializeFromType(@ptrCast(*const ICspInformation, self), Type, pAlgorithm, MachineContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_CspAlgorithms(self: *const T, ppValue: ?*?*ICspAlgorithms) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_CspAlgorithms(@ptrCast(*const ICspInformation, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_HasHardwareRandomNumberGenerator(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_HasHardwareRandomNumberGenerator(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_IsHardwareDevice(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_IsHardwareDevice(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_IsRemovable(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_IsRemovable(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_IsSoftwareDevice(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_IsSoftwareDevice(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_Valid(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_Valid(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_MaxKeyContainerNameLength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_MaxKeyContainerNameLength(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_Name(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_Name(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_Type(self: *const T, pValue: *X509ProviderType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_Type(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_Version(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_Version(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_KeySpec(self: *const T, pValue: *X509KeySpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_KeySpec(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_IsSmartCard(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_IsSmartCard(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_GetDefaultSecurityDescriptor(self: *const T, MachineContext: i16, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).GetDefaultSecurityDescriptor(@ptrCast(*const ICspInformation, self), MachineContext, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_get_LegacyCsp(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).get_LegacyCsp(@ptrCast(*const ICspInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformation_GetCspStatusFromOperations(self: *const T, pAlgorithm: ?*IObjectId, Operations: AlgorithmOperationFlags, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformation.VTable, self.vtable).GetCspStatusFromOperations(@ptrCast(*const ICspInformation, self), pAlgorithm, Operations, ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspInformations_Value = @import("../zig.zig").Guid.initString("728ab308-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspInformations = &IID_ICspInformations_Value;
pub const ICspInformations = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICspInformations,
            Index: i32,
            pVal: ?*?*ICspInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICspInformations,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICspInformations,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICspInformations,
            pVal: ?*ICspInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICspInformations,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAvailableCsps: fn(
            self: *const ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const ICspInformations,
            strName: BSTR,
            ppCspInformation: ?*?*ICspInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCspStatusFromProviderName: fn(
            self: *const ICspInformations,
            strProviderName: BSTR,
            LegacyKeySpec: X509KeySpec,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCspStatusesFromOperations: fn(
            self: *const ICspInformations,
            Operations: AlgorithmOperationFlags,
            pCspInformation: ?*ICspInformation,
            ppValue: ?*?*ICspStatuses,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncryptionCspAlgorithms: fn(
            self: *const ICspInformations,
            pCspInformation: ?*ICspInformation,
            ppValue: ?*?*ICspAlgorithms,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithms: fn(
            self: *const ICspInformations,
            pCspInformation: ?*ICspInformation,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICspInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICspInformations, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).get_Count(@ptrCast(*const ICspInformations, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICspInformations, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_Add(self: *const T, pVal: ?*ICspInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).Add(@ptrCast(*const ICspInformations, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).Remove(@ptrCast(*const ICspInformations, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).Clear(@ptrCast(*const ICspInformations, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_AddAvailableCsps(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).AddAvailableCsps(@ptrCast(*const ICspInformations, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_get_ItemByName(self: *const T, strName: BSTR, ppCspInformation: ?*?*ICspInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).get_ItemByName(@ptrCast(*const ICspInformations, self), strName, ppCspInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_GetCspStatusFromProviderName(self: *const T, strProviderName: BSTR, LegacyKeySpec: X509KeySpec, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).GetCspStatusFromProviderName(@ptrCast(*const ICspInformations, self), strProviderName, LegacyKeySpec, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_GetCspStatusesFromOperations(self: *const T, Operations: AlgorithmOperationFlags, pCspInformation: ?*ICspInformation, ppValue: ?*?*ICspStatuses) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).GetCspStatusesFromOperations(@ptrCast(*const ICspInformations, self), Operations, pCspInformation, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_GetEncryptionCspAlgorithms(self: *const T, pCspInformation: ?*ICspInformation, ppValue: ?*?*ICspAlgorithms) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).GetEncryptionCspAlgorithms(@ptrCast(*const ICspInformations, self), pCspInformation, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspInformations_GetHashAlgorithms(self: *const T, pCspInformation: ?*ICspInformation, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspInformations.VTable, self.vtable).GetHashAlgorithms(@ptrCast(*const ICspInformations, self), pCspInformation, ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspStatus_Value = @import("../zig.zig").Guid.initString("728ab309-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspStatus = &IID_ICspStatus_Value;
pub const ICspStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ICspStatus,
            pCsp: ?*ICspInformation,
            pAlgorithm: ?*ICspAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ordinal: fn(
            self: *const ICspStatus,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Ordinal: fn(
            self: *const ICspStatus,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspAlgorithm: fn(
            self: *const ICspStatus,
            ppValue: ?*?*ICspAlgorithm,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspInformation: fn(
            self: *const ICspStatus,
            ppValue: ?*?*ICspInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnrollmentStatus: fn(
            self: *const ICspStatus,
            ppValue: ?*?*IX509EnrollmentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const ICspStatus,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_Initialize(self: *const T, pCsp: ?*ICspInformation, pAlgorithm: ?*ICspAlgorithm) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).Initialize(@ptrCast(*const ICspStatus, self), pCsp, pAlgorithm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_get_Ordinal(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).get_Ordinal(@ptrCast(*const ICspStatus, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_put_Ordinal(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).put_Ordinal(@ptrCast(*const ICspStatus, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_get_CspAlgorithm(self: *const T, ppValue: ?*?*ICspAlgorithm) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).get_CspAlgorithm(@ptrCast(*const ICspStatus, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_get_CspInformation(self: *const T, ppValue: ?*?*ICspInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).get_CspInformation(@ptrCast(*const ICspStatus, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_get_EnrollmentStatus(self: *const T, ppValue: ?*?*IX509EnrollmentStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).get_EnrollmentStatus(@ptrCast(*const ICspStatus, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatus_get_DisplayName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatus.VTable, self.vtable).get_DisplayName(@ptrCast(*const ICspStatus, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICspStatuses_Value = @import("../zig.zig").Guid.initString("728ab30a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICspStatuses = &IID_ICspStatuses_Value;
pub const ICspStatuses = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICspStatuses,
            Index: i32,
            pVal: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICspStatuses,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICspStatuses,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICspStatuses,
            pVal: ?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICspStatuses,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICspStatuses,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const ICspStatuses,
            strCspName: BSTR,
            strAlgorithmName: BSTR,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByOrdinal: fn(
            self: *const ICspStatuses,
            Ordinal: i32,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByOperations: fn(
            self: *const ICspStatuses,
            strCspName: BSTR,
            strAlgorithmName: BSTR,
            Operations: AlgorithmOperationFlags,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByProvider: fn(
            self: *const ICspStatuses,
            pCspStatus: ?*ICspStatus,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICspStatuses, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_Count(@ptrCast(*const ICspStatuses, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICspStatuses, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_Add(self: *const T, pVal: ?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).Add(@ptrCast(*const ICspStatuses, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).Remove(@ptrCast(*const ICspStatuses, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).Clear(@ptrCast(*const ICspStatuses, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_ItemByName(self: *const T, strCspName: BSTR, strAlgorithmName: BSTR, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_ItemByName(@ptrCast(*const ICspStatuses, self), strCspName, strAlgorithmName, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_ItemByOrdinal(self: *const T, Ordinal: i32, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_ItemByOrdinal(@ptrCast(*const ICspStatuses, self), Ordinal, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_ItemByOperations(self: *const T, strCspName: BSTR, strAlgorithmName: BSTR, Operations: AlgorithmOperationFlags, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_ItemByOperations(@ptrCast(*const ICspStatuses, self), strCspName, strAlgorithmName, Operations, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICspStatuses_get_ItemByProvider(self: *const T, pCspStatus: ?*ICspStatus, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICspStatuses.VTable, self.vtable).get_ItemByProvider(@ptrCast(*const ICspStatuses, self), pCspStatus, ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KeyIdentifierHashAlgorithm = extern enum(i32) {
    Default = 0,
    Sha1 = 1,
    CapiSha1 = 2,
    Sha256 = 3,
    HPKP = 5,
};
pub const SKIHashDefault = KeyIdentifierHashAlgorithm.Default;
pub const SKIHashSha1 = KeyIdentifierHashAlgorithm.Sha1;
pub const SKIHashCapiSha1 = KeyIdentifierHashAlgorithm.CapiSha1;
pub const SKIHashSha256 = KeyIdentifierHashAlgorithm.Sha256;
pub const SKIHashHPKP = KeyIdentifierHashAlgorithm.HPKP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509PublicKey_Value = @import("../zig.zig").Guid.initString("728ab30b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509PublicKey = &IID_IX509PublicKey_Value;
pub const IX509PublicKey = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509PublicKey,
            pObjectId: ?*IObjectId,
            strEncodedKey: BSTR,
            strEncodedParameters: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromEncodedPublicKeyInfo: fn(
            self: *const IX509PublicKey,
            strEncodedPublicKeyInfo: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Algorithm: fn(
            self: *const IX509PublicKey,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const IX509PublicKey,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncodedKey: fn(
            self: *const IX509PublicKey,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncodedParameters: fn(
            self: *const IX509PublicKey,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComputeKeyIdentifier: fn(
            self: *const IX509PublicKey,
            Algorithm: KeyIdentifierHashAlgorithm,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_Initialize(self: *const T, pObjectId: ?*IObjectId, strEncodedKey: BSTR, strEncodedParameters: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).Initialize(@ptrCast(*const IX509PublicKey, self), pObjectId, strEncodedKey, strEncodedParameters, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_InitializeFromEncodedPublicKeyInfo(self: *const T, strEncodedPublicKeyInfo: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).InitializeFromEncodedPublicKeyInfo(@ptrCast(*const IX509PublicKey, self), strEncodedPublicKeyInfo, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_get_Algorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).get_Algorithm(@ptrCast(*const IX509PublicKey, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_get_Length(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).get_Length(@ptrCast(*const IX509PublicKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_get_EncodedKey(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).get_EncodedKey(@ptrCast(*const IX509PublicKey, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_get_EncodedParameters(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).get_EncodedParameters(@ptrCast(*const IX509PublicKey, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PublicKey_ComputeKeyIdentifier(self: *const T, Algorithm: KeyIdentifierHashAlgorithm, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PublicKey.VTable, self.vtable).ComputeKeyIdentifier(@ptrCast(*const IX509PublicKey, self), Algorithm, Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509PrivateKeyExportFlags = extern enum(i32) {
    EXPORT_NONE = 0,
    EXPORT_FLAG = 1,
    PLAINTEXT_EXPORT_FLAG = 2,
    ARCHIVING_FLAG = 4,
    PLAINTEXT_ARCHIVING_FLAG = 8,
};
pub const XCN_NCRYPT_ALLOW_EXPORT_NONE = X509PrivateKeyExportFlags.EXPORT_NONE;
pub const XCN_NCRYPT_ALLOW_EXPORT_FLAG = X509PrivateKeyExportFlags.EXPORT_FLAG;
pub const XCN_NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = X509PrivateKeyExportFlags.PLAINTEXT_EXPORT_FLAG;
pub const XCN_NCRYPT_ALLOW_ARCHIVING_FLAG = X509PrivateKeyExportFlags.ARCHIVING_FLAG;
pub const XCN_NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = X509PrivateKeyExportFlags.PLAINTEXT_ARCHIVING_FLAG;

pub const X509PrivateKeyUsageFlags = extern enum(i32) {
    USAGES_NONE = 0,
    DECRYPT_FLAG = 1,
    SIGNING_FLAG = 2,
    KEY_AGREEMENT_FLAG = 4,
    KEY_IMPORT_FLAG = 8,
    ALL_USAGES = 16777215,
};
pub const XCN_NCRYPT_ALLOW_USAGES_NONE = X509PrivateKeyUsageFlags.USAGES_NONE;
pub const XCN_NCRYPT_ALLOW_DECRYPT_FLAG = X509PrivateKeyUsageFlags.DECRYPT_FLAG;
pub const XCN_NCRYPT_ALLOW_SIGNING_FLAG = X509PrivateKeyUsageFlags.SIGNING_FLAG;
pub const XCN_NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = X509PrivateKeyUsageFlags.KEY_AGREEMENT_FLAG;
pub const XCN_NCRYPT_ALLOW_KEY_IMPORT_FLAG = X509PrivateKeyUsageFlags.KEY_IMPORT_FLAG;
pub const XCN_NCRYPT_ALLOW_ALL_USAGES = X509PrivateKeyUsageFlags.ALL_USAGES;

pub const X509PrivateKeyProtection = extern enum(i32) {
    NO_PROTECTION_FLAG = 0,
    PROTECT_KEY_FLAG = 1,
    FORCE_HIGH_PROTECTION_FLAG = 2,
    FINGERPRINT_PROTECTION_FLAG = 4,
    APPCONTAINER_ACCESS_MEDIUM_FLAG = 8,
};
pub const XCN_NCRYPT_UI_NO_PROTECTION_FLAG = X509PrivateKeyProtection.NO_PROTECTION_FLAG;
pub const XCN_NCRYPT_UI_PROTECT_KEY_FLAG = X509PrivateKeyProtection.PROTECT_KEY_FLAG;
pub const XCN_NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = X509PrivateKeyProtection.FORCE_HIGH_PROTECTION_FLAG;
pub const XCN_NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = X509PrivateKeyProtection.FINGERPRINT_PROTECTION_FLAG;
pub const XCN_NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = X509PrivateKeyProtection.APPCONTAINER_ACCESS_MEDIUM_FLAG;

pub const X509PrivateKeyVerify = extern enum(i32) {
    None = 0,
    Silent = 1,
    SmartCardNone = 2,
    SmartCardSilent = 3,
    AllowUI = 4,
};
pub const VerifyNone = X509PrivateKeyVerify.None;
pub const VerifySilent = X509PrivateKeyVerify.Silent;
pub const VerifySmartCardNone = X509PrivateKeyVerify.SmartCardNone;
pub const VerifySmartCardSilent = X509PrivateKeyVerify.SmartCardSilent;
pub const VerifyAllowUI = X509PrivateKeyVerify.AllowUI;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509PrivateKey_Value = @import("../zig.zig").Guid.initString("728ab30c-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509PrivateKey = &IID_IX509PrivateKey_Value;
pub const IX509PrivateKey = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Open: fn(
            self: *const IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Verify: fn(
            self: *const IX509PrivateKey,
            VerifyType: X509PrivateKeyVerify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IX509PrivateKey,
            strExportType: BSTR,
            strEncodedKey: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Export: fn(
            self: *const IX509PrivateKey,
            strExportType: BSTR,
            Encoding: EncodingType,
            pstrEncodedKey: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportPublicKey: fn(
            self: *const IX509PrivateKey,
            ppPublicKey: ?*?*IX509PublicKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerNamePrefix: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerNamePrefix: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReaderName: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReaderName: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspInformations: fn(
            self: *const IX509PrivateKey,
            ppValue: ?*?*ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CspInformations: fn(
            self: *const IX509PrivateKey,
            pValue: ?*ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspStatus: fn(
            self: *const IX509PrivateKey,
            ppValue: ?*?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CspStatus: fn(
            self: *const IX509PrivateKey,
            pValue: ?*ICspStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderType: fn(
            self: *const IX509PrivateKey,
            pValue: *X509ProviderType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderType: fn(
            self: *const IX509PrivateKey,
            Value: X509ProviderType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LegacyCsp: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LegacyCsp: fn(
            self: *const IX509PrivateKey,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Algorithm: fn(
            self: *const IX509PrivateKey,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Algorithm: fn(
            self: *const IX509PrivateKey,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const IX509PrivateKey,
            pValue: *X509KeySpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeySpec: fn(
            self: *const IX509PrivateKey,
            Value: X509KeySpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const IX509PrivateKey,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: fn(
            self: *const IX509PrivateKey,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExportPolicy: fn(
            self: *const IX509PrivateKey,
            pValue: *X509PrivateKeyExportFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExportPolicy: fn(
            self: *const IX509PrivateKey,
            Value: X509PrivateKeyExportFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyUsage: fn(
            self: *const IX509PrivateKey,
            pValue: *X509PrivateKeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyUsage: fn(
            self: *const IX509PrivateKey,
            Value: X509PrivateKeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyProtection: fn(
            self: *const IX509PrivateKey,
            pValue: *X509PrivateKeyProtection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyProtection: fn(
            self: *const IX509PrivateKey,
            Value: X509PrivateKeyProtection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MachineContext: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MachineContext: fn(
            self: *const IX509PrivateKey,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecurityDescriptor: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SecurityDescriptor: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Certificate: fn(
            self: *const IX509PrivateKey,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Certificate: fn(
            self: *const IX509PrivateKey,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueContainerName: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Opened: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultContainer: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: fn(
            self: *const IX509PrivateKey,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IX509PrivateKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IX509PrivateKey,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentWindow: fn(
            self: *const IX509PrivateKey,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentWindow: fn(
            self: *const IX509PrivateKey,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UIContextMessage: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UIContextMessage: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pin: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FriendlyName: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IX509PrivateKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IX509PrivateKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Open(@ptrCast(*const IX509PrivateKey, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Create(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Create(@ptrCast(*const IX509PrivateKey, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Close(@ptrCast(*const IX509PrivateKey, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Delete(@ptrCast(*const IX509PrivateKey, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Verify(self: *const T, VerifyType: X509PrivateKeyVerify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Verify(@ptrCast(*const IX509PrivateKey, self), VerifyType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Import(self: *const T, strExportType: BSTR, strEncodedKey: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Import(@ptrCast(*const IX509PrivateKey, self), strExportType, strEncodedKey, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_Export(self: *const T, strExportType: BSTR, Encoding: EncodingType, pstrEncodedKey: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).Export(@ptrCast(*const IX509PrivateKey, self), strExportType, Encoding, pstrEncodedKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_ExportPublicKey(self: *const T, ppPublicKey: ?*?*IX509PublicKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).ExportPublicKey(@ptrCast(*const IX509PrivateKey, self), ppPublicKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ContainerName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ContainerName(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ContainerName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ContainerName(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ContainerNamePrefix(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ContainerNamePrefix(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ContainerNamePrefix(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ContainerNamePrefix(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ReaderName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ReaderName(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ReaderName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ReaderName(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_CspInformations(self: *const T, ppValue: ?*?*ICspInformations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_CspInformations(@ptrCast(*const IX509PrivateKey, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_CspInformations(self: *const T, pValue: ?*ICspInformations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_CspInformations(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_CspStatus(self: *const T, ppValue: ?*?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_CspStatus(@ptrCast(*const IX509PrivateKey, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_CspStatus(self: *const T, pValue: ?*ICspStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_CspStatus(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ProviderName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ProviderName(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ProviderName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ProviderName(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ProviderType(self: *const T, pValue: *X509ProviderType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ProviderType(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ProviderType(self: *const T, Value: X509ProviderType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ProviderType(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_LegacyCsp(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_LegacyCsp(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_LegacyCsp(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_LegacyCsp(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Algorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Algorithm(@ptrCast(*const IX509PrivateKey, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Algorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Algorithm(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_KeySpec(self: *const T, pValue: *X509KeySpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_KeySpec(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_KeySpec(self: *const T, Value: X509KeySpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_KeySpec(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Length(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Length(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Length(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Length(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ExportPolicy(self: *const T, pValue: *X509PrivateKeyExportFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ExportPolicy(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ExportPolicy(self: *const T, Value: X509PrivateKeyExportFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ExportPolicy(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_KeyUsage(self: *const T, pValue: *X509PrivateKeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_KeyUsage(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_KeyUsage(self: *const T, Value: X509PrivateKeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_KeyUsage(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_KeyProtection(self: *const T, pValue: *X509PrivateKeyProtection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_KeyProtection(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_KeyProtection(self: *const T, Value: X509PrivateKeyProtection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_KeyProtection(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_MachineContext(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_MachineContext(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_MachineContext(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_MachineContext(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_SecurityDescriptor(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_SecurityDescriptor(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_SecurityDescriptor(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_SecurityDescriptor(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Certificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Certificate(@ptrCast(*const IX509PrivateKey, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Certificate(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Certificate(@ptrCast(*const IX509PrivateKey, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_UniqueContainerName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_UniqueContainerName(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Opened(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Opened(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_DefaultContainer(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_DefaultContainer(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Existing(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Existing(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Existing(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Existing(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Silent(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Silent(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Silent(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Silent(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_ParentWindow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_ParentWindow(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_ParentWindow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_ParentWindow(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_UIContextMessage(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_UIContextMessage(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_UIContextMessage(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_UIContextMessage(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Pin(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Pin(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_FriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_FriendlyName(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_FriendlyName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_FriendlyName(@ptrCast(*const IX509PrivateKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_get_Description(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).get_Description(@ptrCast(*const IX509PrivateKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey_put_Description(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey.VTable, self.vtable).put_Description(@ptrCast(*const IX509PrivateKey, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509HardwareKeyUsageFlags = extern enum(i32) {
    PCP_NONE = 0,
    TPM12_PROVIDER = 65536,
    PCP_SIGNATURE_KEY = 1,
    PCP_ENCRYPTION_KEY = 2,
    PCP_GENERIC_KEY = 3,
    PCP_STORAGE_KEY = 4,
    PCP_IDENTITY_KEY = 8,
};
pub const XCN_NCRYPT_PCP_NONE = X509HardwareKeyUsageFlags.PCP_NONE;
pub const XCN_NCRYPT_TPM12_PROVIDER = X509HardwareKeyUsageFlags.TPM12_PROVIDER;
pub const XCN_NCRYPT_PCP_SIGNATURE_KEY = X509HardwareKeyUsageFlags.PCP_SIGNATURE_KEY;
pub const XCN_NCRYPT_PCP_ENCRYPTION_KEY = X509HardwareKeyUsageFlags.PCP_ENCRYPTION_KEY;
pub const XCN_NCRYPT_PCP_GENERIC_KEY = X509HardwareKeyUsageFlags.PCP_GENERIC_KEY;
pub const XCN_NCRYPT_PCP_STORAGE_KEY = X509HardwareKeyUsageFlags.PCP_STORAGE_KEY;
pub const XCN_NCRYPT_PCP_IDENTITY_KEY = X509HardwareKeyUsageFlags.PCP_IDENTITY_KEY;

pub const X509KeyParametersExportType = extern enum(i32) {
    NONE = 0,
    NAME_FOR_ENCODE_FLAG = 536870912,
    PARAMETERS_FOR_ENCODE_FLAG = 268435456,
};
pub const XCN_CRYPT_OID_USE_CURVE_NONE = X509KeyParametersExportType.NONE;
pub const XCN_CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = X509KeyParametersExportType.NAME_FOR_ENCODE_FLAG;
pub const XCN_CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = X509KeyParametersExportType.PARAMETERS_FOR_ENCODE_FLAG;

const IID_IX509PrivateKey2_Value = @import("../zig.zig").Guid.initString("728ab362-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509PrivateKey2 = &IID_IX509PrivateKey2_Value;
pub const IX509PrivateKey2 = extern struct {
    pub const VTable = extern struct {
        base: IX509PrivateKey.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HardwareKeyUsage: fn(
            self: *const IX509PrivateKey2,
            pValue: *X509HardwareKeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HardwareKeyUsage: fn(
            self: *const IX509PrivateKey2,
            Value: X509HardwareKeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternateStorageLocation: fn(
            self: *const IX509PrivateKey2,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlternateStorageLocation: fn(
            self: *const IX509PrivateKey2,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlgorithmName: fn(
            self: *const IX509PrivateKey2,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlgorithmName: fn(
            self: *const IX509PrivateKey2,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlgorithmParameters: fn(
            self: *const IX509PrivateKey2,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlgorithmParameters: fn(
            self: *const IX509PrivateKey2,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParametersExportType: fn(
            self: *const IX509PrivateKey2,
            pValue: *X509KeyParametersExportType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParametersExportType: fn(
            self: *const IX509PrivateKey2,
            Value: X509KeyParametersExportType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509PrivateKey.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_get_HardwareKeyUsage(self: *const T, pValue: *X509HardwareKeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).get_HardwareKeyUsage(@ptrCast(*const IX509PrivateKey2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_put_HardwareKeyUsage(self: *const T, Value: X509HardwareKeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).put_HardwareKeyUsage(@ptrCast(*const IX509PrivateKey2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_get_AlternateStorageLocation(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).get_AlternateStorageLocation(@ptrCast(*const IX509PrivateKey2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_put_AlternateStorageLocation(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).put_AlternateStorageLocation(@ptrCast(*const IX509PrivateKey2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_get_AlgorithmName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).get_AlgorithmName(@ptrCast(*const IX509PrivateKey2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_put_AlgorithmName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).put_AlgorithmName(@ptrCast(*const IX509PrivateKey2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_get_AlgorithmParameters(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).get_AlgorithmParameters(@ptrCast(*const IX509PrivateKey2, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_put_AlgorithmParameters(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).put_AlgorithmParameters(@ptrCast(*const IX509PrivateKey2, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_get_ParametersExportType(self: *const T, pValue: *X509KeyParametersExportType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).get_ParametersExportType(@ptrCast(*const IX509PrivateKey2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PrivateKey2_put_ParametersExportType(self: *const T, Value: X509KeyParametersExportType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PrivateKey2.VTable, self.vtable).put_ParametersExportType(@ptrCast(*const IX509PrivateKey2, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509EndorsementKey_Value = @import("../zig.zig").Guid.initString("b11cd855-f4c4-4fc6-b710-4422237f09e9");
pub const IID_IX509EndorsementKey = &IID_IX509EndorsementKey_Value;
pub const IX509EndorsementKey = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const IX509EndorsementKey,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const IX509EndorsementKey,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const IX509EndorsementKey,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Opened: fn(
            self: *const IX509EndorsementKey,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddCertificate: fn(
            self: *const IX509EndorsementKey,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveCertificate: fn(
            self: *const IX509EndorsementKey,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateByIndex: fn(
            self: *const IX509EndorsementKey,
            ManufacturerOnly: i16,
            dwIndex: i32,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateCount: fn(
            self: *const IX509EndorsementKey,
            ManufacturerOnly: i16,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportPublicKey: fn(
            self: *const IX509EndorsementKey,
            ppPublicKey: ?*?*IX509PublicKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const IX509EndorsementKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IX509EndorsementKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_get_ProviderName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).get_ProviderName(@ptrCast(*const IX509EndorsementKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_put_ProviderName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).put_ProviderName(@ptrCast(*const IX509EndorsementKey, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_get_Length(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).get_Length(@ptrCast(*const IX509EndorsementKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_get_Opened(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).get_Opened(@ptrCast(*const IX509EndorsementKey, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_AddCertificate(self: *const T, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).AddCertificate(@ptrCast(*const IX509EndorsementKey, self), Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_RemoveCertificate(self: *const T, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).RemoveCertificate(@ptrCast(*const IX509EndorsementKey, self), Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_GetCertificateByIndex(self: *const T, ManufacturerOnly: i16, dwIndex: i32, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).GetCertificateByIndex(@ptrCast(*const IX509EndorsementKey, self), ManufacturerOnly, dwIndex, Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_GetCertificateCount(self: *const T, ManufacturerOnly: i16, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).GetCertificateCount(@ptrCast(*const IX509EndorsementKey, self), ManufacturerOnly, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_ExportPublicKey(self: *const T, ppPublicKey: ?*?*IX509PublicKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).ExportPublicKey(@ptrCast(*const IX509EndorsementKey, self), ppPublicKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).Open(@ptrCast(*const IX509EndorsementKey, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EndorsementKey_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EndorsementKey.VTable, self.vtable).Close(@ptrCast(*const IX509EndorsementKey, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509Extension_Value = @import("../zig.zig").Guid.initString("728ab30d-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Extension = &IID_IX509Extension_Value;
pub const IX509Extension = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509Extension,
            pObjectId: ?*IObjectId,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const IX509Extension,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IX509Extension,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Critical: fn(
            self: *const IX509Extension,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Critical: fn(
            self: *const IX509Extension,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extension_Initialize(self: *const T, pObjectId: ?*IObjectId, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extension.VTable, self.vtable).Initialize(@ptrCast(*const IX509Extension, self), pObjectId, Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extension_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extension.VTable, self.vtable).get_ObjectId(@ptrCast(*const IX509Extension, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extension_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extension.VTable, self.vtable).get_RawData(@ptrCast(*const IX509Extension, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extension_get_Critical(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extension.VTable, self.vtable).get_Critical(@ptrCast(*const IX509Extension, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extension_put_Critical(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extension.VTable, self.vtable).put_Critical(@ptrCast(*const IX509Extension, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509Extensions_Value = @import("../zig.zig").Guid.initString("728ab30e-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Extensions = &IID_IX509Extensions_Value;
pub const IX509Extensions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509Extensions,
            Index: i32,
            pVal: ?*?*IX509Extension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509Extensions,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509Extensions,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509Extensions,
            pVal: ?*IX509Extension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509Extensions,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IndexByObjectId: fn(
            self: *const IX509Extensions,
            pObjectId: ?*IObjectId,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IX509Extensions,
            pValue: ?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509Extension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509Extensions, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).get_Count(@ptrCast(*const IX509Extensions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509Extensions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_Add(self: *const T, pVal: ?*IX509Extension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).Add(@ptrCast(*const IX509Extensions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).Remove(@ptrCast(*const IX509Extensions, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).Clear(@ptrCast(*const IX509Extensions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_get_IndexByObjectId(self: *const T, pObjectId: ?*IObjectId, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).get_IndexByObjectId(@ptrCast(*const IX509Extensions, self), pObjectId, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Extensions_AddRange(self: *const T, pValue: ?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Extensions.VTable, self.vtable).AddRange(@ptrCast(*const IX509Extensions, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509KeyUsageFlags = extern enum(i32) {
    NO_KEY_USAGE = 0,
    DIGITAL_SIGNATURE_KEY_USAGE = 128,
    NON_REPUDIATION_KEY_USAGE = 64,
    KEY_ENCIPHERMENT_KEY_USAGE = 32,
    DATA_ENCIPHERMENT_KEY_USAGE = 16,
    KEY_AGREEMENT_KEY_USAGE = 8,
    KEY_CERT_SIGN_KEY_USAGE = 4,
    OFFLINE_CRL_SIGN_KEY_USAGE = 2,
    CRL_SIGN_KEY_USAGE = 2,
    ENCIPHER_ONLY_KEY_USAGE = 1,
    DECIPHER_ONLY_KEY_USAGE = 32768,
};
pub const XCN_CERT_NO_KEY_USAGE = X509KeyUsageFlags.NO_KEY_USAGE;
pub const XCN_CERT_DIGITAL_SIGNATURE_KEY_USAGE = X509KeyUsageFlags.DIGITAL_SIGNATURE_KEY_USAGE;
pub const XCN_CERT_NON_REPUDIATION_KEY_USAGE = X509KeyUsageFlags.NON_REPUDIATION_KEY_USAGE;
pub const XCN_CERT_KEY_ENCIPHERMENT_KEY_USAGE = X509KeyUsageFlags.KEY_ENCIPHERMENT_KEY_USAGE;
pub const XCN_CERT_DATA_ENCIPHERMENT_KEY_USAGE = X509KeyUsageFlags.DATA_ENCIPHERMENT_KEY_USAGE;
pub const XCN_CERT_KEY_AGREEMENT_KEY_USAGE = X509KeyUsageFlags.KEY_AGREEMENT_KEY_USAGE;
pub const XCN_CERT_KEY_CERT_SIGN_KEY_USAGE = X509KeyUsageFlags.KEY_CERT_SIGN_KEY_USAGE;
pub const XCN_CERT_OFFLINE_CRL_SIGN_KEY_USAGE = X509KeyUsageFlags.OFFLINE_CRL_SIGN_KEY_USAGE;
pub const XCN_CERT_CRL_SIGN_KEY_USAGE = X509KeyUsageFlags.CRL_SIGN_KEY_USAGE;
pub const XCN_CERT_ENCIPHER_ONLY_KEY_USAGE = X509KeyUsageFlags.ENCIPHER_ONLY_KEY_USAGE;
pub const XCN_CERT_DECIPHER_ONLY_KEY_USAGE = X509KeyUsageFlags.DECIPHER_ONLY_KEY_USAGE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionKeyUsage_Value = @import("../zig.zig").Guid.initString("728ab30f-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionKeyUsage = &IID_IX509ExtensionKeyUsage_Value;
pub const IX509ExtensionKeyUsage = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionKeyUsage,
            UsageFlags: X509KeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionKeyUsage,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyUsage: fn(
            self: *const IX509ExtensionKeyUsage,
            pValue: *X509KeyUsageFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionKeyUsage_InitializeEncode(self: *const T, UsageFlags: X509KeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionKeyUsage.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionKeyUsage, self), UsageFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionKeyUsage_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionKeyUsage.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionKeyUsage, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionKeyUsage_get_KeyUsage(self: *const T, pValue: *X509KeyUsageFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionKeyUsage.VTable, self.vtable).get_KeyUsage(@ptrCast(*const IX509ExtensionKeyUsage, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionEnhancedKeyUsage_Value = @import("../zig.zig").Guid.initString("728ab310-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionEnhancedKeyUsage = &IID_IX509ExtensionEnhancedKeyUsage_Value;
pub const IX509ExtensionEnhancedKeyUsage = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionEnhancedKeyUsage,
            pValue: ?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionEnhancedKeyUsage,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnhancedKeyUsage: fn(
            self: *const IX509ExtensionEnhancedKeyUsage,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionEnhancedKeyUsage_InitializeEncode(self: *const T, pValue: ?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionEnhancedKeyUsage.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionEnhancedKeyUsage, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionEnhancedKeyUsage_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionEnhancedKeyUsage.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionEnhancedKeyUsage, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionEnhancedKeyUsage_get_EnhancedKeyUsage(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionEnhancedKeyUsage.VTable, self.vtable).get_EnhancedKeyUsage(@ptrCast(*const IX509ExtensionEnhancedKeyUsage, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionTemplateName_Value = @import("../zig.zig").Guid.initString("728ab311-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionTemplateName = &IID_IX509ExtensionTemplateName_Value;
pub const IX509ExtensionTemplateName = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionTemplateName,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionTemplateName,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateName: fn(
            self: *const IX509ExtensionTemplateName,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplateName_InitializeEncode(self: *const T, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplateName.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionTemplateName, self), strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplateName_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplateName.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionTemplateName, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplateName_get_TemplateName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplateName.VTable, self.vtable).get_TemplateName(@ptrCast(*const IX509ExtensionTemplateName, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionTemplate_Value = @import("../zig.zig").Guid.initString("728ab312-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionTemplate = &IID_IX509ExtensionTemplate_Value;
pub const IX509ExtensionTemplate = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionTemplate,
            pTemplateOid: ?*IObjectId,
            MajorVersion: i32,
            MinorVersion: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionTemplate,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateOid: fn(
            self: *const IX509ExtensionTemplate,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MajorVersion: fn(
            self: *const IX509ExtensionTemplate,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinorVersion: fn(
            self: *const IX509ExtensionTemplate,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplate_InitializeEncode(self: *const T, pTemplateOid: ?*IObjectId, MajorVersion: i32, MinorVersion: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplate.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionTemplate, self), pTemplateOid, MajorVersion, MinorVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplate_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplate.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionTemplate, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplate_get_TemplateOid(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplate.VTable, self.vtable).get_TemplateOid(@ptrCast(*const IX509ExtensionTemplate, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplate_get_MajorVersion(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplate.VTable, self.vtable).get_MajorVersion(@ptrCast(*const IX509ExtensionTemplate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionTemplate_get_MinorVersion(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionTemplate.VTable, self.vtable).get_MinorVersion(@ptrCast(*const IX509ExtensionTemplate, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AlternativeNameType = extern enum(i32) {
    UNKNOWN = 0,
    OTHER_NAME = 1,
    RFC822_NAME = 2,
    DNS_NAME = 3,
    X400_ADDRESS = 4,
    DIRECTORY_NAME = 5,
    EDI_PARTY_NAME = 6,
    URL = 7,
    IP_ADDRESS = 8,
    REGISTERED_ID = 9,
    GUID = 10,
    USER_PRINCIPLE_NAME = 11,
};
pub const XCN_CERT_ALT_NAME_UNKNOWN = AlternativeNameType.UNKNOWN;
pub const XCN_CERT_ALT_NAME_OTHER_NAME = AlternativeNameType.OTHER_NAME;
pub const XCN_CERT_ALT_NAME_RFC822_NAME = AlternativeNameType.RFC822_NAME;
pub const XCN_CERT_ALT_NAME_DNS_NAME = AlternativeNameType.DNS_NAME;
pub const XCN_CERT_ALT_NAME_X400_ADDRESS = AlternativeNameType.X400_ADDRESS;
pub const XCN_CERT_ALT_NAME_DIRECTORY_NAME = AlternativeNameType.DIRECTORY_NAME;
pub const XCN_CERT_ALT_NAME_EDI_PARTY_NAME = AlternativeNameType.EDI_PARTY_NAME;
pub const XCN_CERT_ALT_NAME_URL = AlternativeNameType.URL;
pub const XCN_CERT_ALT_NAME_IP_ADDRESS = AlternativeNameType.IP_ADDRESS;
pub const XCN_CERT_ALT_NAME_REGISTERED_ID = AlternativeNameType.REGISTERED_ID;
pub const XCN_CERT_ALT_NAME_GUID = AlternativeNameType.GUID;
pub const XCN_CERT_ALT_NAME_USER_PRINCIPLE_NAME = AlternativeNameType.USER_PRINCIPLE_NAME;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAlternativeName_Value = @import("../zig.zig").Guid.initString("728ab313-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IAlternativeName = &IID_IAlternativeName_Value;
pub const IAlternativeName = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeFromString: fn(
            self: *const IAlternativeName,
            Type: AlternativeNameType,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromRawData: fn(
            self: *const IAlternativeName,
            Type: AlternativeNameType,
            Encoding: EncodingType,
            strRawData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromOtherName: fn(
            self: *const IAlternativeName,
            pObjectId: ?*IObjectId,
            Encoding: EncodingType,
            strRawData: BSTR,
            ToBeWrapped: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IAlternativeName,
            pValue: *AlternativeNameType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StrValue: fn(
            self: *const IAlternativeName,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const IAlternativeName,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IAlternativeName,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_InitializeFromString(self: *const T, Type: AlternativeNameType, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).InitializeFromString(@ptrCast(*const IAlternativeName, self), Type, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_InitializeFromRawData(self: *const T, Type: AlternativeNameType, Encoding: EncodingType, strRawData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).InitializeFromRawData(@ptrCast(*const IAlternativeName, self), Type, Encoding, strRawData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_InitializeFromOtherName(self: *const T, pObjectId: ?*IObjectId, Encoding: EncodingType, strRawData: BSTR, ToBeWrapped: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).InitializeFromOtherName(@ptrCast(*const IAlternativeName, self), pObjectId, Encoding, strRawData, ToBeWrapped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_get_Type(self: *const T, pValue: *AlternativeNameType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).get_Type(@ptrCast(*const IAlternativeName, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_get_StrValue(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).get_StrValue(@ptrCast(*const IAlternativeName, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).get_ObjectId(@ptrCast(*const IAlternativeName, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeName_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeName.VTable, self.vtable).get_RawData(@ptrCast(*const IAlternativeName, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAlternativeNames_Value = @import("../zig.zig").Guid.initString("728ab314-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IAlternativeNames = &IID_IAlternativeNames_Value;
pub const IAlternativeNames = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IAlternativeNames,
            Index: i32,
            pVal: ?*?*IAlternativeName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAlternativeNames,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAlternativeNames,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IAlternativeNames,
            pVal: ?*IAlternativeName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IAlternativeNames,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IAlternativeNames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IAlternativeName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IAlternativeNames, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).get_Count(@ptrCast(*const IAlternativeNames, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAlternativeNames, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_Add(self: *const T, pVal: ?*IAlternativeName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).Add(@ptrCast(*const IAlternativeNames, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).Remove(@ptrCast(*const IAlternativeNames, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlternativeNames_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlternativeNames.VTable, self.vtable).Clear(@ptrCast(*const IAlternativeNames, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionAlternativeNames_Value = @import("../zig.zig").Guid.initString("728ab315-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionAlternativeNames = &IID_IX509ExtensionAlternativeNames_Value;
pub const IX509ExtensionAlternativeNames = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionAlternativeNames,
            pValue: ?*IAlternativeNames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionAlternativeNames,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternativeNames: fn(
            self: *const IX509ExtensionAlternativeNames,
            ppValue: ?*?*IAlternativeNames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAlternativeNames_InitializeEncode(self: *const T, pValue: ?*IAlternativeNames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAlternativeNames.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionAlternativeNames, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAlternativeNames_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAlternativeNames.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionAlternativeNames, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAlternativeNames_get_AlternativeNames(self: *const T, ppValue: ?*?*IAlternativeNames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAlternativeNames.VTable, self.vtable).get_AlternativeNames(@ptrCast(*const IX509ExtensionAlternativeNames, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionBasicConstraints_Value = @import("../zig.zig").Guid.initString("728ab316-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionBasicConstraints = &IID_IX509ExtensionBasicConstraints_Value;
pub const IX509ExtensionBasicConstraints = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionBasicConstraints,
            IsCA: i16,
            PathLenConstraint: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionBasicConstraints,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsCA: fn(
            self: *const IX509ExtensionBasicConstraints,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PathLenConstraint: fn(
            self: *const IX509ExtensionBasicConstraints,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionBasicConstraints_InitializeEncode(self: *const T, IsCA: i16, PathLenConstraint: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionBasicConstraints.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionBasicConstraints, self), IsCA, PathLenConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionBasicConstraints_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionBasicConstraints.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionBasicConstraints, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionBasicConstraints_get_IsCA(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionBasicConstraints.VTable, self.vtable).get_IsCA(@ptrCast(*const IX509ExtensionBasicConstraints, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionBasicConstraints_get_PathLenConstraint(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionBasicConstraints.VTable, self.vtable).get_PathLenConstraint(@ptrCast(*const IX509ExtensionBasicConstraints, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionSubjectKeyIdentifier_Value = @import("../zig.zig").Guid.initString("728ab317-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionSubjectKeyIdentifier = &IID_IX509ExtensionSubjectKeyIdentifier_Value;
pub const IX509ExtensionSubjectKeyIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionSubjectKeyIdentifier,
            Encoding: EncodingType,
            strKeyIdentifier: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionSubjectKeyIdentifier,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubjectKeyIdentifier: fn(
            self: *const IX509ExtensionSubjectKeyIdentifier,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSubjectKeyIdentifier_InitializeEncode(self: *const T, Encoding: EncodingType, strKeyIdentifier: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSubjectKeyIdentifier.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionSubjectKeyIdentifier, self), Encoding, strKeyIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSubjectKeyIdentifier_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSubjectKeyIdentifier.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionSubjectKeyIdentifier, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSubjectKeyIdentifier_get_SubjectKeyIdentifier(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSubjectKeyIdentifier.VTable, self.vtable).get_SubjectKeyIdentifier(@ptrCast(*const IX509ExtensionSubjectKeyIdentifier, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionAuthorityKeyIdentifier_Value = @import("../zig.zig").Guid.initString("728ab318-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionAuthorityKeyIdentifier = &IID_IX509ExtensionAuthorityKeyIdentifier_Value;
pub const IX509ExtensionAuthorityKeyIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionAuthorityKeyIdentifier,
            Encoding: EncodingType,
            strKeyIdentifier: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionAuthorityKeyIdentifier,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorityKeyIdentifier: fn(
            self: *const IX509ExtensionAuthorityKeyIdentifier,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAuthorityKeyIdentifier_InitializeEncode(self: *const T, Encoding: EncodingType, strKeyIdentifier: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAuthorityKeyIdentifier.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionAuthorityKeyIdentifier, self), Encoding, strKeyIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAuthorityKeyIdentifier_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAuthorityKeyIdentifier.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionAuthorityKeyIdentifier, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionAuthorityKeyIdentifier_get_AuthorityKeyIdentifier(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionAuthorityKeyIdentifier.VTable, self.vtable).get_AuthorityKeyIdentifier(@ptrCast(*const IX509ExtensionAuthorityKeyIdentifier, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISmimeCapability_Value = @import("../zig.zig").Guid.initString("728ab319-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ISmimeCapability = &IID_ISmimeCapability_Value;
pub const ISmimeCapability = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ISmimeCapability,
            pObjectId: ?*IObjectId,
            BitCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const ISmimeCapability,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitCount: fn(
            self: *const ISmimeCapability,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapability_Initialize(self: *const T, pObjectId: ?*IObjectId, BitCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapability.VTable, self.vtable).Initialize(@ptrCast(*const ISmimeCapability, self), pObjectId, BitCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapability_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapability.VTable, self.vtable).get_ObjectId(@ptrCast(*const ISmimeCapability, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapability_get_BitCount(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapability.VTable, self.vtable).get_BitCount(@ptrCast(*const ISmimeCapability, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISmimeCapabilities_Value = @import("../zig.zig").Guid.initString("728ab31a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ISmimeCapabilities = &IID_ISmimeCapabilities_Value;
pub const ISmimeCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ISmimeCapabilities,
            Index: i32,
            pVal: ?*?*ISmimeCapability,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ISmimeCapabilities,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ISmimeCapabilities,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISmimeCapabilities,
            pVal: ?*ISmimeCapability,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ISmimeCapabilities,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ISmimeCapabilities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFromCsp: fn(
            self: *const ISmimeCapabilities,
            pValue: ?*ICspInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAvailableSmimeCapabilities: fn(
            self: *const ISmimeCapabilities,
            MachineContext: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ISmimeCapability) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ISmimeCapabilities, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).get_Count(@ptrCast(*const ISmimeCapabilities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISmimeCapabilities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_Add(self: *const T, pVal: ?*ISmimeCapability) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).Add(@ptrCast(*const ISmimeCapabilities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).Remove(@ptrCast(*const ISmimeCapabilities, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).Clear(@ptrCast(*const ISmimeCapabilities, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_AddFromCsp(self: *const T, pValue: ?*ICspInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).AddFromCsp(@ptrCast(*const ISmimeCapabilities, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISmimeCapabilities_AddAvailableSmimeCapabilities(self: *const T, MachineContext: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISmimeCapabilities.VTable, self.vtable).AddAvailableSmimeCapabilities(@ptrCast(*const ISmimeCapabilities, self), MachineContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionSmimeCapabilities_Value = @import("../zig.zig").Guid.initString("728ab31b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionSmimeCapabilities = &IID_IX509ExtensionSmimeCapabilities_Value;
pub const IX509ExtensionSmimeCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionSmimeCapabilities,
            pValue: ?*ISmimeCapabilities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionSmimeCapabilities,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmimeCapabilities: fn(
            self: *const IX509ExtensionSmimeCapabilities,
            ppValue: ?*?*ISmimeCapabilities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSmimeCapabilities_InitializeEncode(self: *const T, pValue: ?*ISmimeCapabilities) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSmimeCapabilities.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionSmimeCapabilities, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSmimeCapabilities_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSmimeCapabilities.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionSmimeCapabilities, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionSmimeCapabilities_get_SmimeCapabilities(self: *const T, ppValue: ?*?*ISmimeCapabilities) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionSmimeCapabilities.VTable, self.vtable).get_SmimeCapabilities(@ptrCast(*const IX509ExtensionSmimeCapabilities, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PolicyQualifierType = extern enum(i32) {
    Unknown = 0,
    Url = 1,
    UserNotice = 2,
    Flags = 3,
};
pub const PolicyQualifierTypeUnknown = PolicyQualifierType.Unknown;
pub const PolicyQualifierTypeUrl = PolicyQualifierType.Url;
pub const PolicyQualifierTypeUserNotice = PolicyQualifierType.UserNotice;
pub const PolicyQualifierTypeFlags = PolicyQualifierType.Flags;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPolicyQualifier_Value = @import("../zig.zig").Guid.initString("728ab31c-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IPolicyQualifier = &IID_IPolicyQualifier_Value;
pub const IPolicyQualifier = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeEncode: fn(
            self: *const IPolicyQualifier,
            strQualifier: BSTR,
            Type: PolicyQualifierType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const IPolicyQualifier,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Qualifier: fn(
            self: *const IPolicyQualifier,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IPolicyQualifier,
            pValue: *PolicyQualifierType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IPolicyQualifier,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifier_InitializeEncode(self: *const T, strQualifier: BSTR, Type: PolicyQualifierType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifier.VTable, self.vtable).InitializeEncode(@ptrCast(*const IPolicyQualifier, self), strQualifier, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifier_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifier.VTable, self.vtable).get_ObjectId(@ptrCast(*const IPolicyQualifier, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifier_get_Qualifier(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifier.VTable, self.vtable).get_Qualifier(@ptrCast(*const IPolicyQualifier, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifier_get_Type(self: *const T, pValue: *PolicyQualifierType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifier.VTable, self.vtable).get_Type(@ptrCast(*const IPolicyQualifier, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifier_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifier.VTable, self.vtable).get_RawData(@ptrCast(*const IPolicyQualifier, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPolicyQualifiers_Value = @import("../zig.zig").Guid.initString("728ab31d-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IPolicyQualifiers = &IID_IPolicyQualifiers_Value;
pub const IPolicyQualifiers = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IPolicyQualifiers,
            Index: i32,
            pVal: ?*?*IPolicyQualifier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IPolicyQualifiers,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IPolicyQualifiers,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IPolicyQualifiers,
            pVal: ?*IPolicyQualifier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IPolicyQualifiers,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IPolicyQualifiers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IPolicyQualifier) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IPolicyQualifiers, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).get_Count(@ptrCast(*const IPolicyQualifiers, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).get__NewEnum(@ptrCast(*const IPolicyQualifiers, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_Add(self: *const T, pVal: ?*IPolicyQualifier) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).Add(@ptrCast(*const IPolicyQualifiers, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).Remove(@ptrCast(*const IPolicyQualifiers, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPolicyQualifiers_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPolicyQualifiers.VTable, self.vtable).Clear(@ptrCast(*const IPolicyQualifiers, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertificatePolicy_Value = @import("../zig.zig").Guid.initString("728ab31e-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertificatePolicy = &IID_ICertificatePolicy_Value;
pub const ICertificatePolicy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ICertificatePolicy,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const ICertificatePolicy,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyQualifiers: fn(
            self: *const ICertificatePolicy,
            ppValue: ?*?*IPolicyQualifiers,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicy_Initialize(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicy.VTable, self.vtable).Initialize(@ptrCast(*const ICertificatePolicy, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicy_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicy.VTable, self.vtable).get_ObjectId(@ptrCast(*const ICertificatePolicy, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicy_get_PolicyQualifiers(self: *const T, ppValue: ?*?*IPolicyQualifiers) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicy.VTable, self.vtable).get_PolicyQualifiers(@ptrCast(*const ICertificatePolicy, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertificatePolicies_Value = @import("../zig.zig").Guid.initString("728ab31f-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertificatePolicies = &IID_ICertificatePolicies_Value;
pub const ICertificatePolicies = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICertificatePolicies,
            Index: i32,
            pVal: ?*?*ICertificatePolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertificatePolicies,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertificatePolicies,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertificatePolicies,
            pVal: ?*ICertificatePolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICertificatePolicies,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICertificatePolicies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICertificatePolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICertificatePolicies, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).get_Count(@ptrCast(*const ICertificatePolicies, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertificatePolicies, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_Add(self: *const T, pVal: ?*ICertificatePolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).Add(@ptrCast(*const ICertificatePolicies, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).Remove(@ptrCast(*const ICertificatePolicies, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificatePolicies_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificatePolicies.VTable, self.vtable).Clear(@ptrCast(*const ICertificatePolicies, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionCertificatePolicies_Value = @import("../zig.zig").Guid.initString("728ab320-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionCertificatePolicies = &IID_IX509ExtensionCertificatePolicies_Value;
pub const IX509ExtensionCertificatePolicies = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionCertificatePolicies,
            pValue: ?*ICertificatePolicies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionCertificatePolicies,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Policies: fn(
            self: *const IX509ExtensionCertificatePolicies,
            ppValue: ?*?*ICertificatePolicies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionCertificatePolicies_InitializeEncode(self: *const T, pValue: ?*ICertificatePolicies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionCertificatePolicies.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionCertificatePolicies, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionCertificatePolicies_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionCertificatePolicies.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionCertificatePolicies, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionCertificatePolicies_get_Policies(self: *const T, ppValue: ?*?*ICertificatePolicies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionCertificatePolicies.VTable, self.vtable).get_Policies(@ptrCast(*const IX509ExtensionCertificatePolicies, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509ExtensionMSApplicationPolicies_Value = @import("../zig.zig").Guid.initString("728ab321-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509ExtensionMSApplicationPolicies = &IID_IX509ExtensionMSApplicationPolicies_Value;
pub const IX509ExtensionMSApplicationPolicies = extern struct {
    pub const VTable = extern struct {
        base: IX509Extension.VTable,
        InitializeEncode: fn(
            self: *const IX509ExtensionMSApplicationPolicies,
            pValue: ?*ICertificatePolicies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509ExtensionMSApplicationPolicies,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Policies: fn(
            self: *const IX509ExtensionMSApplicationPolicies,
            ppValue: ?*?*ICertificatePolicies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Extension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionMSApplicationPolicies_InitializeEncode(self: *const T, pValue: ?*ICertificatePolicies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionMSApplicationPolicies.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509ExtensionMSApplicationPolicies, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionMSApplicationPolicies_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionMSApplicationPolicies.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509ExtensionMSApplicationPolicies, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509ExtensionMSApplicationPolicies_get_Policies(self: *const T, ppValue: ?*?*ICertificatePolicies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509ExtensionMSApplicationPolicies.VTable, self.vtable).get_Policies(@ptrCast(*const IX509ExtensionMSApplicationPolicies, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509Attribute_Value = @import("../zig.zig").Guid.initString("728ab322-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Attribute = &IID_IX509Attribute_Value;
pub const IX509Attribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509Attribute,
            pObjectId: ?*IObjectId,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const IX509Attribute,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IX509Attribute,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attribute_Initialize(self: *const T, pObjectId: ?*IObjectId, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attribute.VTable, self.vtable).Initialize(@ptrCast(*const IX509Attribute, self), pObjectId, Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attribute_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attribute.VTable, self.vtable).get_ObjectId(@ptrCast(*const IX509Attribute, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attribute_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attribute.VTable, self.vtable).get_RawData(@ptrCast(*const IX509Attribute, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509Attributes_Value = @import("../zig.zig").Guid.initString("728ab323-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Attributes = &IID_IX509Attributes_Value;
pub const IX509Attributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509Attributes,
            Index: i32,
            pVal: ?*?*IX509Attribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509Attributes,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509Attributes,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509Attributes,
            pVal: ?*IX509Attribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509Attributes,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509Attributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509Attribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509Attributes, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).get_Count(@ptrCast(*const IX509Attributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509Attributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_Add(self: *const T, pVal: ?*IX509Attribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).Add(@ptrCast(*const IX509Attributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).Remove(@ptrCast(*const IX509Attributes, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Attributes_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Attributes.VTable, self.vtable).Clear(@ptrCast(*const IX509Attributes, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeExtensions_Value = @import("../zig.zig").Guid.initString("728ab324-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeExtensions = &IID_IX509AttributeExtensions_Value;
pub const IX509AttributeExtensions = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeExtensions,
            pExtensions: ?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeExtensions,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509Extensions: fn(
            self: *const IX509AttributeExtensions,
            ppValue: ?*?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeExtensions_InitializeEncode(self: *const T, pExtensions: ?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeExtensions.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeExtensions, self), pExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeExtensions_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeExtensions.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeExtensions, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeExtensions_get_X509Extensions(self: *const T, ppValue: ?*?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeExtensions.VTable, self.vtable).get_X509Extensions(@ptrCast(*const IX509AttributeExtensions, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RequestClientInfoClientId = extern enum(i32) {
    None = 0,
    XEnroll2003 = 1,
    AutoEnroll2003 = 2,
    Wizard2003 = 3,
    CertReq2003 = 4,
    DefaultRequest = 5,
    AutoEnroll = 6,
    RequestWizard = 7,
    EOBO = 8,
    CertReq = 9,
    Test = 10,
    WinRT = 11,
    UserStart = 1000,
};
pub const ClientIdNone = RequestClientInfoClientId.None;
pub const ClientIdXEnroll2003 = RequestClientInfoClientId.XEnroll2003;
pub const ClientIdAutoEnroll2003 = RequestClientInfoClientId.AutoEnroll2003;
pub const ClientIdWizard2003 = RequestClientInfoClientId.Wizard2003;
pub const ClientIdCertReq2003 = RequestClientInfoClientId.CertReq2003;
pub const ClientIdDefaultRequest = RequestClientInfoClientId.DefaultRequest;
pub const ClientIdAutoEnroll = RequestClientInfoClientId.AutoEnroll;
pub const ClientIdRequestWizard = RequestClientInfoClientId.RequestWizard;
pub const ClientIdEOBO = RequestClientInfoClientId.EOBO;
pub const ClientIdCertReq = RequestClientInfoClientId.CertReq;
pub const ClientIdTest = RequestClientInfoClientId.Test;
pub const ClientIdWinRT = RequestClientInfoClientId.WinRT;
pub const ClientIdUserStart = RequestClientInfoClientId.UserStart;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeClientId_Value = @import("../zig.zig").Guid.initString("728ab325-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeClientId = &IID_IX509AttributeClientId_Value;
pub const IX509AttributeClientId = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeClientId,
            ClientId: RequestClientInfoClientId,
            strMachineDnsName: BSTR,
            strUserSamName: BSTR,
            strProcessName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeClientId,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientId: fn(
            self: *const IX509AttributeClientId,
            pValue: *RequestClientInfoClientId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MachineDnsName: fn(
            self: *const IX509AttributeClientId,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserSamName: fn(
            self: *const IX509AttributeClientId,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProcessName: fn(
            self: *const IX509AttributeClientId,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_InitializeEncode(self: *const T, ClientId: RequestClientInfoClientId, strMachineDnsName: BSTR, strUserSamName: BSTR, strProcessName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeClientId, self), ClientId, strMachineDnsName, strUserSamName, strProcessName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeClientId, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_get_ClientId(self: *const T, pValue: *RequestClientInfoClientId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).get_ClientId(@ptrCast(*const IX509AttributeClientId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_get_MachineDnsName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).get_MachineDnsName(@ptrCast(*const IX509AttributeClientId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_get_UserSamName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).get_UserSamName(@ptrCast(*const IX509AttributeClientId, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeClientId_get_ProcessName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeClientId.VTable, self.vtable).get_ProcessName(@ptrCast(*const IX509AttributeClientId, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeRenewalCertificate_Value = @import("../zig.zig").Guid.initString("728ab326-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeRenewalCertificate = &IID_IX509AttributeRenewalCertificate_Value;
pub const IX509AttributeRenewalCertificate = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeRenewalCertificate,
            Encoding: EncodingType,
            strCert: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeRenewalCertificate,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RenewalCertificate: fn(
            self: *const IX509AttributeRenewalCertificate,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeRenewalCertificate_InitializeEncode(self: *const T, Encoding: EncodingType, strCert: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeRenewalCertificate.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeRenewalCertificate, self), Encoding, strCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeRenewalCertificate_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeRenewalCertificate.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeRenewalCertificate, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeRenewalCertificate_get_RenewalCertificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeRenewalCertificate.VTable, self.vtable).get_RenewalCertificate(@ptrCast(*const IX509AttributeRenewalCertificate, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeArchiveKey_Value = @import("../zig.zig").Guid.initString("728ab327-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeArchiveKey = &IID_IX509AttributeArchiveKey_Value;
pub const IX509AttributeArchiveKey = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeArchiveKey,
            pKey: ?*IX509PrivateKey,
            Encoding: EncodingType,
            strCAXCert: BSTR,
            pAlgorithm: ?*IObjectId,
            EncryptionStrength: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeArchiveKey,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptedKeyBlob: fn(
            self: *const IX509AttributeArchiveKey,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionAlgorithm: fn(
            self: *const IX509AttributeArchiveKey,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionStrength: fn(
            self: *const IX509AttributeArchiveKey,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKey_InitializeEncode(self: *const T, pKey: ?*IX509PrivateKey, Encoding: EncodingType, strCAXCert: BSTR, pAlgorithm: ?*IObjectId, EncryptionStrength: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKey.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeArchiveKey, self), pKey, Encoding, strCAXCert, pAlgorithm, EncryptionStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKey_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKey.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeArchiveKey, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKey_get_EncryptedKeyBlob(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKey.VTable, self.vtable).get_EncryptedKeyBlob(@ptrCast(*const IX509AttributeArchiveKey, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKey_get_EncryptionAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKey.VTable, self.vtable).get_EncryptionAlgorithm(@ptrCast(*const IX509AttributeArchiveKey, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKey_get_EncryptionStrength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKey.VTable, self.vtable).get_EncryptionStrength(@ptrCast(*const IX509AttributeArchiveKey, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeArchiveKeyHash_Value = @import("../zig.zig").Guid.initString("728ab328-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeArchiveKeyHash = &IID_IX509AttributeArchiveKeyHash_Value;
pub const IX509AttributeArchiveKeyHash = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncodeFromEncryptedKeyBlob: fn(
            self: *const IX509AttributeArchiveKeyHash,
            Encoding: EncodingType,
            strEncryptedKeyBlob: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeArchiveKeyHash,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptedKeyHashBlob: fn(
            self: *const IX509AttributeArchiveKeyHash,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKeyHash_InitializeEncodeFromEncryptedKeyBlob(self: *const T, Encoding: EncodingType, strEncryptedKeyBlob: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKeyHash.VTable, self.vtable).InitializeEncodeFromEncryptedKeyBlob(@ptrCast(*const IX509AttributeArchiveKeyHash, self), Encoding, strEncryptedKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKeyHash_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKeyHash.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeArchiveKeyHash, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeArchiveKeyHash_get_EncryptedKeyHashBlob(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeArchiveKeyHash.VTable, self.vtable).get_EncryptedKeyHashBlob(@ptrCast(*const IX509AttributeArchiveKeyHash, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeOSVersion_Value = @import("../zig.zig").Guid.initString("728ab32a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeOSVersion = &IID_IX509AttributeOSVersion_Value;
pub const IX509AttributeOSVersion = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeOSVersion,
            strOSVersion: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeOSVersion,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OSVersion: fn(
            self: *const IX509AttributeOSVersion,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeOSVersion_InitializeEncode(self: *const T, strOSVersion: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeOSVersion.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeOSVersion, self), strOSVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeOSVersion_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeOSVersion.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeOSVersion, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeOSVersion_get_OSVersion(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeOSVersion.VTable, self.vtable).get_OSVersion(@ptrCast(*const IX509AttributeOSVersion, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509AttributeCspProvider_Value = @import("../zig.zig").Guid.initString("728ab32b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509AttributeCspProvider = &IID_IX509AttributeCspProvider_Value;
pub const IX509AttributeCspProvider = extern struct {
    pub const VTable = extern struct {
        base: IX509Attribute.VTable,
        InitializeEncode: fn(
            self: *const IX509AttributeCspProvider,
            KeySpec: X509KeySpec,
            strProviderName: BSTR,
            Encoding: EncodingType,
            strSignature: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509AttributeCspProvider,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const IX509AttributeCspProvider,
            pValue: *X509KeySpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const IX509AttributeCspProvider,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Signature: fn(
            self: *const IX509AttributeCspProvider,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Attribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeCspProvider_InitializeEncode(self: *const T, KeySpec: X509KeySpec, strProviderName: BSTR, Encoding: EncodingType, strSignature: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeCspProvider.VTable, self.vtable).InitializeEncode(@ptrCast(*const IX509AttributeCspProvider, self), KeySpec, strProviderName, Encoding, strSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeCspProvider_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeCspProvider.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509AttributeCspProvider, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeCspProvider_get_KeySpec(self: *const T, pValue: *X509KeySpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeCspProvider.VTable, self.vtable).get_KeySpec(@ptrCast(*const IX509AttributeCspProvider, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeCspProvider_get_ProviderName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeCspProvider.VTable, self.vtable).get_ProviderName(@ptrCast(*const IX509AttributeCspProvider, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509AttributeCspProvider_get_Signature(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509AttributeCspProvider.VTable, self.vtable).get_Signature(@ptrCast(*const IX509AttributeCspProvider, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICryptAttribute_Value = @import("../zig.zig").Guid.initString("728ab32c-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICryptAttribute = &IID_ICryptAttribute_Value;
pub const ICryptAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeFromObjectId: fn(
            self: *const ICryptAttribute,
            pObjectId: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromValues: fn(
            self: *const ICryptAttribute,
            pAttributes: ?*IX509Attributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ObjectId: fn(
            self: *const ICryptAttribute,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Values: fn(
            self: *const ICryptAttribute,
            ppValue: ?*?*IX509Attributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttribute_InitializeFromObjectId(self: *const T, pObjectId: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttribute.VTable, self.vtable).InitializeFromObjectId(@ptrCast(*const ICryptAttribute, self), pObjectId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttribute_InitializeFromValues(self: *const T, pAttributes: ?*IX509Attributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttribute.VTable, self.vtable).InitializeFromValues(@ptrCast(*const ICryptAttribute, self), pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttribute_get_ObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttribute.VTable, self.vtable).get_ObjectId(@ptrCast(*const ICryptAttribute, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttribute_get_Values(self: *const T, ppValue: ?*?*IX509Attributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttribute.VTable, self.vtable).get_Values(@ptrCast(*const ICryptAttribute, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICryptAttributes_Value = @import("../zig.zig").Guid.initString("728ab32d-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICryptAttributes = &IID_ICryptAttributes_Value;
pub const ICryptAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICryptAttributes,
            Index: i32,
            pVal: ?*?*ICryptAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICryptAttributes,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICryptAttributes,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICryptAttributes,
            pVal: ?*ICryptAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICryptAttributes,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICryptAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IndexByObjectId: fn(
            self: *const ICryptAttributes,
            pObjectId: ?*IObjectId,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const ICryptAttributes,
            pValue: ?*ICryptAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICryptAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICryptAttributes, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).get_Count(@ptrCast(*const ICryptAttributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICryptAttributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_Add(self: *const T, pVal: ?*ICryptAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).Add(@ptrCast(*const ICryptAttributes, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).Remove(@ptrCast(*const ICryptAttributes, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).Clear(@ptrCast(*const ICryptAttributes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_get_IndexByObjectId(self: *const T, pObjectId: ?*IObjectId, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).get_IndexByObjectId(@ptrCast(*const ICryptAttributes, self), pObjectId, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICryptAttributes_AddRange(self: *const T, pValue: ?*ICryptAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICryptAttributes.VTable, self.vtable).AddRange(@ptrCast(*const ICryptAttributes, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CERTENROLL_PROPERTYID = extern enum(i32) {
    PROPERTYID_NONE = 0,
    CERT_KEY_PROV_HANDLE_PROP_ID = 1,
    CERT_KEY_PROV_INFO_PROP_ID = 2,
    CERT_SHA1_HASH_PROP_ID = 3,
    CERT_MD5_HASH_PROP_ID = 4,
    CERT_HASH_PROP_ID = 3,
    CERT_KEY_CONTEXT_PROP_ID = 5,
    CERT_KEY_SPEC_PROP_ID = 6,
    CERT_IE30_RESERVED_PROP_ID = 7,
    CERT_PUBKEY_HASH_RESERVED_PROP_ID = 8,
    CERT_ENHKEY_USAGE_PROP_ID = 9,
    CERT_CTL_USAGE_PROP_ID = 9,
    CERT_NEXT_UPDATE_LOCATION_PROP_ID = 10,
    CERT_FRIENDLY_NAME_PROP_ID = 11,
    CERT_PVK_FILE_PROP_ID = 12,
    CERT_DESCRIPTION_PROP_ID = 13,
    CERT_ACCESS_STATE_PROP_ID = 14,
    CERT_SIGNATURE_HASH_PROP_ID = 15,
    CERT_SMART_CARD_DATA_PROP_ID = 16,
    CERT_EFS_PROP_ID = 17,
    CERT_FORTEZZA_DATA_PROP_ID = 18,
    CERT_ARCHIVED_PROP_ID = 19,
    CERT_KEY_IDENTIFIER_PROP_ID = 20,
    CERT_AUTO_ENROLL_PROP_ID = 21,
    CERT_PUBKEY_ALG_PARA_PROP_ID = 22,
    CERT_CROSS_CERT_DIST_POINTS_PROP_ID = 23,
    CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = 24,
    CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = 25,
    CERT_ENROLLMENT_PROP_ID = 26,
    CERT_DATE_STAMP_PROP_ID = 27,
    CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 28,
    CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 29,
    CERT_EXTENDED_ERROR_INFO_PROP_ID = 30,
    CERT_RENEWAL_PROP_ID = 64,
    CERT_ARCHIVED_KEY_HASH_PROP_ID = 65,
    CERT_AUTO_ENROLL_RETRY_PROP_ID = 66,
    CERT_AIA_URL_RETRIEVED_PROP_ID = 67,
    CERT_AUTHORITY_INFO_ACCESS_PROP_ID = 68,
    CERT_BACKED_UP_PROP_ID = 69,
    CERT_OCSP_RESPONSE_PROP_ID = 70,
    CERT_REQUEST_ORIGINATOR_PROP_ID = 71,
    CERT_SOURCE_LOCATION_PROP_ID = 72,
    CERT_SOURCE_URL_PROP_ID = 73,
    CERT_NEW_KEY_PROP_ID = 74,
    CERT_OCSP_CACHE_PREFIX_PROP_ID = 75,
    CERT_SMART_CARD_ROOT_INFO_PROP_ID = 76,
    CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = 77,
    CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78,
    CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = 79,
    CERT_SUBJECT_INFO_ACCESS_PROP_ID = 80,
    CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 81,
    CERT_CA_DISABLE_CRL_PROP_ID = 82,
    CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = 83,
    CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = 84,
    CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 85,
    CERT_SUBJECT_DISABLE_CRL_PROP_ID = 86,
    CERT_CEP_PROP_ID = 87,
    CERT_SIGN_HASH_CNG_ALG_PROP_ID = 89,
    CERT_SCARD_PIN_ID_PROP_ID = 90,
    CERT_SCARD_PIN_INFO_PROP_ID = 91,
    CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = 92,
    CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 93,
    CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = 94,
    CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = 95,
    CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 96,
    CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = 97,
    CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = 98,
    CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = 99,
    CERT_HCRYPTPROV_TRANSFER_PROP_ID = 100,
    CERT_SMART_CARD_READER_PROP_ID = 101,
    CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = 102,
    CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = 103,
    CERT_DISALLOWED_FILETIME_PROP_ID = 104,
    CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = 105,
    CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = 106,
    CERT_SHA256_HASH_PROP_ID = 107,
    CERT_SCEP_SERVER_CERTS_PROP_ID = 108,
    CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = 109,
    CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = 110,
    CERT_SCEP_CA_CERT_PROP_ID = 111,
    CERT_SCEP_SIGNER_CERT_PROP_ID = 112,
    CERT_SCEP_NONCE_PROP_ID = 113,
    CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = 114,
    CERT_SCEP_FLAGS_PROP_ID = 115,
    CERT_SCEP_GUID_PROP_ID = 116,
    CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = 117,
    CERT_ISOLATED_KEY_PROP_ID = 118,
    CERT_SERIAL_CHAIN_PROP_ID = 119,
    CERT_KEY_CLASSIFICATION_PROP_ID = 120,
    CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = 122,
    CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = 123,
    CERT_PIN_SHA256_HASH_PROP_ID = 124,
    CERT_CLR_DELETE_KEY_PROP_ID = 125,
    CERT_NOT_BEFORE_FILETIME_PROP_ID = 126,
    CERT_CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = 127,
    CERT_FIRST_RESERVED_PROP_ID = 128,
    CERT_LAST_RESERVED_PROP_ID = 32767,
    CERT_FIRST_USER_PROP_ID = 32768,
    CERT_LAST_USER_PROP_ID = 65535,
    CERT_STORE_LOCALIZED_NAME_PROP_ID = 4096,
};
pub const XCN_PROPERTYID_NONE = CERTENROLL_PROPERTYID.PROPERTYID_NONE;
pub const XCN_CERT_KEY_PROV_HANDLE_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_PROV_HANDLE_PROP_ID;
pub const XCN_CERT_KEY_PROV_INFO_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_PROV_INFO_PROP_ID;
pub const XCN_CERT_SHA1_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SHA1_HASH_PROP_ID;
pub const XCN_CERT_MD5_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_MD5_HASH_PROP_ID;
pub const XCN_CERT_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_HASH_PROP_ID;
pub const XCN_CERT_KEY_CONTEXT_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_CONTEXT_PROP_ID;
pub const XCN_CERT_KEY_SPEC_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_SPEC_PROP_ID;
pub const XCN_CERT_IE30_RESERVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_IE30_RESERVED_PROP_ID;
pub const XCN_CERT_PUBKEY_HASH_RESERVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_PUBKEY_HASH_RESERVED_PROP_ID;
pub const XCN_CERT_ENHKEY_USAGE_PROP_ID = CERTENROLL_PROPERTYID.CERT_ENHKEY_USAGE_PROP_ID;
pub const XCN_CERT_CTL_USAGE_PROP_ID = CERTENROLL_PROPERTYID.CERT_CTL_USAGE_PROP_ID;
pub const XCN_CERT_NEXT_UPDATE_LOCATION_PROP_ID = CERTENROLL_PROPERTYID.CERT_NEXT_UPDATE_LOCATION_PROP_ID;
pub const XCN_CERT_FRIENDLY_NAME_PROP_ID = CERTENROLL_PROPERTYID.CERT_FRIENDLY_NAME_PROP_ID;
pub const XCN_CERT_PVK_FILE_PROP_ID = CERTENROLL_PROPERTYID.CERT_PVK_FILE_PROP_ID;
pub const XCN_CERT_DESCRIPTION_PROP_ID = CERTENROLL_PROPERTYID.CERT_DESCRIPTION_PROP_ID;
pub const XCN_CERT_ACCESS_STATE_PROP_ID = CERTENROLL_PROPERTYID.CERT_ACCESS_STATE_PROP_ID;
pub const XCN_CERT_SIGNATURE_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SIGNATURE_HASH_PROP_ID;
pub const XCN_CERT_SMART_CARD_DATA_PROP_ID = CERTENROLL_PROPERTYID.CERT_SMART_CARD_DATA_PROP_ID;
pub const XCN_CERT_EFS_PROP_ID = CERTENROLL_PROPERTYID.CERT_EFS_PROP_ID;
pub const XCN_CERT_FORTEZZA_DATA_PROP_ID = CERTENROLL_PROPERTYID.CERT_FORTEZZA_DATA_PROP_ID;
pub const XCN_CERT_ARCHIVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_ARCHIVED_PROP_ID;
pub const XCN_CERT_KEY_IDENTIFIER_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_IDENTIFIER_PROP_ID;
pub const XCN_CERT_AUTO_ENROLL_PROP_ID = CERTENROLL_PROPERTYID.CERT_AUTO_ENROLL_PROP_ID;
pub const XCN_CERT_PUBKEY_ALG_PARA_PROP_ID = CERTENROLL_PROPERTYID.CERT_PUBKEY_ALG_PARA_PROP_ID;
pub const XCN_CERT_CROSS_CERT_DIST_POINTS_PROP_ID = CERTENROLL_PROPERTYID.CERT_CROSS_CERT_DIST_POINTS_PROP_ID;
pub const XCN_CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID;
pub const XCN_CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID;
pub const XCN_CERT_ENROLLMENT_PROP_ID = CERTENROLL_PROPERTYID.CERT_ENROLLMENT_PROP_ID;
pub const XCN_CERT_DATE_STAMP_PROP_ID = CERTENROLL_PROPERTYID.CERT_DATE_STAMP_PROP_ID;
pub const XCN_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID;
pub const XCN_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_NAME_MD5_HASH_PROP_ID;
pub const XCN_CERT_EXTENDED_ERROR_INFO_PROP_ID = CERTENROLL_PROPERTYID.CERT_EXTENDED_ERROR_INFO_PROP_ID;
pub const XCN_CERT_RENEWAL_PROP_ID = CERTENROLL_PROPERTYID.CERT_RENEWAL_PROP_ID;
pub const XCN_CERT_ARCHIVED_KEY_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_ARCHIVED_KEY_HASH_PROP_ID;
pub const XCN_CERT_AUTO_ENROLL_RETRY_PROP_ID = CERTENROLL_PROPERTYID.CERT_AUTO_ENROLL_RETRY_PROP_ID;
pub const XCN_CERT_AIA_URL_RETRIEVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_AIA_URL_RETRIEVED_PROP_ID;
pub const XCN_CERT_AUTHORITY_INFO_ACCESS_PROP_ID = CERTENROLL_PROPERTYID.CERT_AUTHORITY_INFO_ACCESS_PROP_ID;
pub const XCN_CERT_BACKED_UP_PROP_ID = CERTENROLL_PROPERTYID.CERT_BACKED_UP_PROP_ID;
pub const XCN_CERT_OCSP_RESPONSE_PROP_ID = CERTENROLL_PROPERTYID.CERT_OCSP_RESPONSE_PROP_ID;
pub const XCN_CERT_REQUEST_ORIGINATOR_PROP_ID = CERTENROLL_PROPERTYID.CERT_REQUEST_ORIGINATOR_PROP_ID;
pub const XCN_CERT_SOURCE_LOCATION_PROP_ID = CERTENROLL_PROPERTYID.CERT_SOURCE_LOCATION_PROP_ID;
pub const XCN_CERT_SOURCE_URL_PROP_ID = CERTENROLL_PROPERTYID.CERT_SOURCE_URL_PROP_ID;
pub const XCN_CERT_NEW_KEY_PROP_ID = CERTENROLL_PROPERTYID.CERT_NEW_KEY_PROP_ID;
pub const XCN_CERT_OCSP_CACHE_PREFIX_PROP_ID = CERTENROLL_PROPERTYID.CERT_OCSP_CACHE_PREFIX_PROP_ID;
pub const XCN_CERT_SMART_CARD_ROOT_INFO_PROP_ID = CERTENROLL_PROPERTYID.CERT_SMART_CARD_ROOT_INFO_PROP_ID;
pub const XCN_CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = CERTENROLL_PROPERTYID.CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID;
pub const XCN_CERT_NCRYPT_KEY_HANDLE_PROP_ID = CERTENROLL_PROPERTYID.CERT_NCRYPT_KEY_HANDLE_PROP_ID;
pub const XCN_CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = CERTENROLL_PROPERTYID.CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID;
pub const XCN_CERT_SUBJECT_INFO_ACCESS_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_INFO_ACCESS_PROP_ID;
pub const XCN_CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = CERTENROLL_PROPERTYID.CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID;
pub const XCN_CERT_CA_DISABLE_CRL_PROP_ID = CERTENROLL_PROPERTYID.CERT_CA_DISABLE_CRL_PROP_ID;
pub const XCN_CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = CERTENROLL_PROPERTYID.CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID;
pub const XCN_CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = CERTENROLL_PROPERTYID.CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID;
pub const XCN_CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID;
pub const XCN_CERT_SUBJECT_DISABLE_CRL_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_DISABLE_CRL_PROP_ID;
pub const XCN_CERT_CEP_PROP_ID = CERTENROLL_PROPERTYID.CERT_CEP_PROP_ID;
pub const XCN_CERT_SIGN_HASH_CNG_ALG_PROP_ID = CERTENROLL_PROPERTYID.CERT_SIGN_HASH_CNG_ALG_PROP_ID;
pub const XCN_CERT_SCARD_PIN_ID_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCARD_PIN_ID_PROP_ID;
pub const XCN_CERT_SCARD_PIN_INFO_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCARD_PIN_INFO_PROP_ID;
pub const XCN_CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID;
pub const XCN_CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = CERTENROLL_PROPERTYID.CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID;
pub const XCN_CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID;
pub const XCN_CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID;
pub const XCN_CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID;
pub const XCN_CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = CERTENROLL_PROPERTYID.CERT_NO_EXPIRE_NOTIFICATION_PROP_ID;
pub const XCN_CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_AUTH_ROOT_SHA256_HASH_PROP_ID;
pub const XCN_CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = CERTENROLL_PROPERTYID.CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID;
pub const XCN_CERT_HCRYPTPROV_TRANSFER_PROP_ID = CERTENROLL_PROPERTYID.CERT_HCRYPTPROV_TRANSFER_PROP_ID;
pub const XCN_CERT_SMART_CARD_READER_PROP_ID = CERTENROLL_PROPERTYID.CERT_SMART_CARD_READER_PROP_ID;
pub const XCN_CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = CERTENROLL_PROPERTYID.CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID;
pub const XCN_CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_REPAIR_ATTEMPTED_PROP_ID;
pub const XCN_CERT_DISALLOWED_FILETIME_PROP_ID = CERTENROLL_PROPERTYID.CERT_DISALLOWED_FILETIME_PROP_ID;
pub const XCN_CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = CERTENROLL_PROPERTYID.CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID;
pub const XCN_CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = CERTENROLL_PROPERTYID.CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID;
pub const XCN_CERT_SHA256_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_SHA256_HASH_PROP_ID;
pub const XCN_CERT_SCEP_SERVER_CERTS_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_SERVER_CERTS_PROP_ID;
pub const XCN_CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID;
pub const XCN_CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID;
pub const XCN_CERT_SCEP_CA_CERT_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_CA_CERT_PROP_ID;
pub const XCN_CERT_SCEP_SIGNER_CERT_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_SIGNER_CERT_PROP_ID;
pub const XCN_CERT_SCEP_NONCE_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_NONCE_PROP_ID;
pub const XCN_CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID;
pub const XCN_CERT_SCEP_FLAGS_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_FLAGS_PROP_ID;
pub const XCN_CERT_SCEP_GUID_PROP_ID = CERTENROLL_PROPERTYID.CERT_SCEP_GUID_PROP_ID;
pub const XCN_CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = CERTENROLL_PROPERTYID.CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID;
pub const XCN_CERT_ISOLATED_KEY_PROP_ID = CERTENROLL_PROPERTYID.CERT_ISOLATED_KEY_PROP_ID;
pub const XCN_CERT_SERIAL_CHAIN_PROP_ID = CERTENROLL_PROPERTYID.CERT_SERIAL_CHAIN_PROP_ID;
pub const XCN_CERT_KEY_CLASSIFICATION_PROP_ID = CERTENROLL_PROPERTYID.CERT_KEY_CLASSIFICATION_PROP_ID;
pub const XCN_CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = CERTENROLL_PROPERTYID.CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID;
pub const XCN_CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = CERTENROLL_PROPERTYID.CERT_NONCOMPLIANT_ROOT_URL_PROP_ID;
pub const XCN_CERT_PIN_SHA256_HASH_PROP_ID = CERTENROLL_PROPERTYID.CERT_PIN_SHA256_HASH_PROP_ID;
pub const XCN_CERT_CLR_DELETE_KEY_PROP_ID = CERTENROLL_PROPERTYID.CERT_CLR_DELETE_KEY_PROP_ID;
pub const XCN_CERT_NOT_BEFORE_FILETIME_PROP_ID = CERTENROLL_PROPERTYID.CERT_NOT_BEFORE_FILETIME_PROP_ID;
pub const XCN_CERT_CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = CERTENROLL_PROPERTYID.CERT_CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID;
pub const XCN_CERT_FIRST_RESERVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_FIRST_RESERVED_PROP_ID;
pub const XCN_CERT_LAST_RESERVED_PROP_ID = CERTENROLL_PROPERTYID.CERT_LAST_RESERVED_PROP_ID;
pub const XCN_CERT_FIRST_USER_PROP_ID = CERTENROLL_PROPERTYID.CERT_FIRST_USER_PROP_ID;
pub const XCN_CERT_LAST_USER_PROP_ID = CERTENROLL_PROPERTYID.CERT_LAST_USER_PROP_ID;
pub const XCN_CERT_STORE_LOCALIZED_NAME_PROP_ID = CERTENROLL_PROPERTYID.CERT_STORE_LOCALIZED_NAME_PROP_ID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertProperty_Value = @import("../zig.zig").Guid.initString("728ab32e-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertProperty = &IID_ICertProperty_Value;
pub const ICertProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        InitializeFromCertificate: fn(
            self: *const ICertProperty,
            MachineContext: i16,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const ICertProperty,
            Encoding: EncodingType,
            strEncodedData: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyId: fn(
            self: *const ICertProperty,
            pValue: *CERTENROLL_PROPERTYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertyId: fn(
            self: *const ICertProperty,
            Value: CERTENROLL_PROPERTYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const ICertProperty,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromCertificate: fn(
            self: *const ICertProperty,
            MachineContext: i16,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueOnCertificate: fn(
            self: *const ICertProperty,
            MachineContext: i16,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_InitializeFromCertificate(self: *const T, MachineContext: i16, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).InitializeFromCertificate(@ptrCast(*const ICertProperty, self), MachineContext, Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_InitializeDecode(self: *const T, Encoding: EncodingType, strEncodedData: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).InitializeDecode(@ptrCast(*const ICertProperty, self), Encoding, strEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_get_PropertyId(self: *const T, pValue: *CERTENROLL_PROPERTYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).get_PropertyId(@ptrCast(*const ICertProperty, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_put_PropertyId(self: *const T, Value: CERTENROLL_PROPERTYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).put_PropertyId(@ptrCast(*const ICertProperty, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).get_RawData(@ptrCast(*const ICertProperty, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_RemoveFromCertificate(self: *const T, MachineContext: i16, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).RemoveFromCertificate(@ptrCast(*const ICertProperty, self), MachineContext, Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperty_SetValueOnCertificate(self: *const T, MachineContext: i16, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperty.VTable, self.vtable).SetValueOnCertificate(@ptrCast(*const ICertProperty, self), MachineContext, Encoding, strCertificate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertProperties_Value = @import("../zig.zig").Guid.initString("728ab32f-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertProperties = &IID_ICertProperties_Value;
pub const ICertProperties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICertProperties,
            Index: i32,
            pVal: ?*?*ICertProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertProperties,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertProperties,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertProperties,
            pVal: ?*ICertProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICertProperties,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICertProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromCertificate: fn(
            self: *const ICertProperties,
            MachineContext: i16,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICertProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICertProperties, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).get_Count(@ptrCast(*const ICertProperties, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertProperties, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_Add(self: *const T, pVal: ?*ICertProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).Add(@ptrCast(*const ICertProperties, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).Remove(@ptrCast(*const ICertProperties, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).Clear(@ptrCast(*const ICertProperties, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertProperties_InitializeFromCertificate(self: *const T, MachineContext: i16, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertProperties.VTable, self.vtable).InitializeFromCertificate(@ptrCast(*const ICertProperties, self), MachineContext, Encoding, strCertificate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyFriendlyName_Value = @import("../zig.zig").Guid.initString("728ab330-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyFriendlyName = &IID_ICertPropertyFriendlyName_Value;
pub const ICertPropertyFriendlyName = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyFriendlyName,
            strFriendlyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: fn(
            self: *const ICertPropertyFriendlyName,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyFriendlyName_Initialize(self: *const T, strFriendlyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyFriendlyName.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyFriendlyName, self), strFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyFriendlyName_get_FriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyFriendlyName.VTable, self.vtable).get_FriendlyName(@ptrCast(*const ICertPropertyFriendlyName, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyDescription_Value = @import("../zig.zig").Guid.initString("728ab331-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyDescription = &IID_ICertPropertyDescription_Value;
pub const ICertPropertyDescription = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyDescription,
            strDescription: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const ICertPropertyDescription,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyDescription_Initialize(self: *const T, strDescription: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyDescription.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyDescription, self), strDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyDescription_get_Description(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyDescription.VTable, self.vtable).get_Description(@ptrCast(*const ICertPropertyDescription, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyAutoEnroll_Value = @import("../zig.zig").Guid.initString("728ab332-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyAutoEnroll = &IID_ICertPropertyAutoEnroll_Value;
pub const ICertPropertyAutoEnroll = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyAutoEnroll,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateName: fn(
            self: *const ICertPropertyAutoEnroll,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyAutoEnroll_Initialize(self: *const T, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyAutoEnroll.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyAutoEnroll, self), strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyAutoEnroll_get_TemplateName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyAutoEnroll.VTable, self.vtable).get_TemplateName(@ptrCast(*const ICertPropertyAutoEnroll, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyRequestOriginator_Value = @import("../zig.zig").Guid.initString("728ab333-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyRequestOriginator = &IID_ICertPropertyRequestOriginator_Value;
pub const ICertPropertyRequestOriginator = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyRequestOriginator,
            strRequestOriginator: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromLocalRequestOriginator: fn(
            self: *const ICertPropertyRequestOriginator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestOriginator: fn(
            self: *const ICertPropertyRequestOriginator,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRequestOriginator_Initialize(self: *const T, strRequestOriginator: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRequestOriginator.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyRequestOriginator, self), strRequestOriginator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRequestOriginator_InitializeFromLocalRequestOriginator(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRequestOriginator.VTable, self.vtable).InitializeFromLocalRequestOriginator(@ptrCast(*const ICertPropertyRequestOriginator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRequestOriginator_get_RequestOriginator(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRequestOriginator.VTable, self.vtable).get_RequestOriginator(@ptrCast(*const ICertPropertyRequestOriginator, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertySHA1Hash_Value = @import("../zig.zig").Guid.initString("728ab334-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertySHA1Hash = &IID_ICertPropertySHA1Hash_Value;
pub const ICertPropertySHA1Hash = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertySHA1Hash,
            Encoding: EncodingType,
            strRenewalValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SHA1Hash: fn(
            self: *const ICertPropertySHA1Hash,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertySHA1Hash_Initialize(self: *const T, Encoding: EncodingType, strRenewalValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertySHA1Hash.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertySHA1Hash, self), Encoding, strRenewalValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertySHA1Hash_get_SHA1Hash(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertySHA1Hash.VTable, self.vtable).get_SHA1Hash(@ptrCast(*const ICertPropertySHA1Hash, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyKeyProvInfo_Value = @import("../zig.zig").Guid.initString("728ab336-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyKeyProvInfo = &IID_ICertPropertyKeyProvInfo_Value;
pub const ICertPropertyKeyProvInfo = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyKeyProvInfo,
            pValue: ?*IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivateKey: fn(
            self: *const ICertPropertyKeyProvInfo,
            ppValue: ?*?*IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyKeyProvInfo_Initialize(self: *const T, pValue: ?*IX509PrivateKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyKeyProvInfo.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyKeyProvInfo, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyKeyProvInfo_get_PrivateKey(self: *const T, ppValue: ?*?*IX509PrivateKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyKeyProvInfo.VTable, self.vtable).get_PrivateKey(@ptrCast(*const ICertPropertyKeyProvInfo, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyArchived_Value = @import("../zig.zig").Guid.initString("728ab337-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyArchived = &IID_ICertPropertyArchived_Value;
pub const ICertPropertyArchived = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyArchived,
            ArchivedValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Archived: fn(
            self: *const ICertPropertyArchived,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyArchived_Initialize(self: *const T, ArchivedValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyArchived.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyArchived, self), ArchivedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyArchived_get_Archived(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyArchived.VTable, self.vtable).get_Archived(@ptrCast(*const ICertPropertyArchived, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyBackedUp_Value = @import("../zig.zig").Guid.initString("728ab338-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyBackedUp = &IID_ICertPropertyBackedUp_Value;
pub const ICertPropertyBackedUp = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        InitializeFromCurrentTime: fn(
            self: *const ICertPropertyBackedUp,
            BackedUpValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const ICertPropertyBackedUp,
            BackedUpValue: i16,
            Date: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackedUpValue: fn(
            self: *const ICertPropertyBackedUp,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackedUpTime: fn(
            self: *const ICertPropertyBackedUp,
            pDate: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyBackedUp_InitializeFromCurrentTime(self: *const T, BackedUpValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyBackedUp.VTable, self.vtable).InitializeFromCurrentTime(@ptrCast(*const ICertPropertyBackedUp, self), BackedUpValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyBackedUp_Initialize(self: *const T, BackedUpValue: i16, Date: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyBackedUp.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyBackedUp, self), BackedUpValue, Date);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyBackedUp_get_BackedUpValue(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyBackedUp.VTable, self.vtable).get_BackedUpValue(@ptrCast(*const ICertPropertyBackedUp, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyBackedUp_get_BackedUpTime(self: *const T, pDate: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyBackedUp.VTable, self.vtable).get_BackedUpTime(@ptrCast(*const ICertPropertyBackedUp, self), pDate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyEnrollment_Value = @import("../zig.zig").Guid.initString("728ab339-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyEnrollment = &IID_ICertPropertyEnrollment_Value;
pub const ICertPropertyEnrollment = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyEnrollment,
            RequestId: i32,
            strCADnsName: BSTR,
            strCAName: BSTR,
            strFriendlyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestId: fn(
            self: *const ICertPropertyEnrollment,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CADnsName: fn(
            self: *const ICertPropertyEnrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAName: fn(
            self: *const ICertPropertyEnrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: fn(
            self: *const ICertPropertyEnrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollment_Initialize(self: *const T, RequestId: i32, strCADnsName: BSTR, strCAName: BSTR, strFriendlyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollment.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyEnrollment, self), RequestId, strCADnsName, strCAName, strFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollment_get_RequestId(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollment.VTable, self.vtable).get_RequestId(@ptrCast(*const ICertPropertyEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollment_get_CADnsName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollment.VTable, self.vtable).get_CADnsName(@ptrCast(*const ICertPropertyEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollment_get_CAName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollment.VTable, self.vtable).get_CAName(@ptrCast(*const ICertPropertyEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollment_get_FriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollment.VTable, self.vtable).get_FriendlyName(@ptrCast(*const ICertPropertyEnrollment, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyRenewal_Value = @import("../zig.zig").Guid.initString("728ab33a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyRenewal = &IID_ICertPropertyRenewal_Value;
pub const ICertPropertyRenewal = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyRenewal,
            Encoding: EncodingType,
            strRenewalValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromCertificateHash: fn(
            self: *const ICertPropertyRenewal,
            MachineContext: i16,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Renewal: fn(
            self: *const ICertPropertyRenewal,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRenewal_Initialize(self: *const T, Encoding: EncodingType, strRenewalValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRenewal.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyRenewal, self), Encoding, strRenewalValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRenewal_InitializeFromCertificateHash(self: *const T, MachineContext: i16, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRenewal.VTable, self.vtable).InitializeFromCertificateHash(@ptrCast(*const ICertPropertyRenewal, self), MachineContext, Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyRenewal_get_Renewal(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyRenewal.VTable, self.vtable).get_Renewal(@ptrCast(*const ICertPropertyRenewal, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICertPropertyArchivedKeyHash_Value = @import("../zig.zig").Guid.initString("728ab33b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyArchivedKeyHash = &IID_ICertPropertyArchivedKeyHash_Value;
pub const ICertPropertyArchivedKeyHash = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyArchivedKeyHash,
            Encoding: EncodingType,
            strArchivedKeyHashValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ArchivedKeyHash: fn(
            self: *const ICertPropertyArchivedKeyHash,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyArchivedKeyHash_Initialize(self: *const T, Encoding: EncodingType, strArchivedKeyHashValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyArchivedKeyHash.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyArchivedKeyHash, self), Encoding, strArchivedKeyHashValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyArchivedKeyHash_get_ArchivedKeyHash(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyArchivedKeyHash.VTable, self.vtable).get_ArchivedKeyHash(@ptrCast(*const ICertPropertyArchivedKeyHash, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EnrollmentPolicyServerPropertyFlags = extern enum(i32) {
    None = 0,
    PolicyServer = 1,
};
pub const DefaultNone = EnrollmentPolicyServerPropertyFlags.None;
pub const DefaultPolicyServer = EnrollmentPolicyServerPropertyFlags.PolicyServer;

pub const PolicyServerUrlFlags = extern enum(i32) {
    None = 0,
    LocationGroupPolicy = 1,
    LocationRegistry = 2,
    UseClientId = 4,
    AutoEnrollmentEnabled = 16,
    AllowUnTrustedCA = 32,
};
pub const PsfNone = PolicyServerUrlFlags.None;
pub const PsfLocationGroupPolicy = PolicyServerUrlFlags.LocationGroupPolicy;
pub const PsfLocationRegistry = PolicyServerUrlFlags.LocationRegistry;
pub const PsfUseClientId = PolicyServerUrlFlags.UseClientId;
pub const PsfAutoEnrollmentEnabled = PolicyServerUrlFlags.AutoEnrollmentEnabled;
pub const PsfAllowUnTrustedCA = PolicyServerUrlFlags.AllowUnTrustedCA;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertPropertyEnrollmentPolicyServer_Value = @import("../zig.zig").Guid.initString("728ab34a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ICertPropertyEnrollmentPolicyServer = &IID_ICertPropertyEnrollmentPolicyServer_Value;
pub const ICertPropertyEnrollmentPolicyServer = extern struct {
    pub const VTable = extern struct {
        base: ICertProperty.VTable,
        Initialize: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            PropertyFlags: EnrollmentPolicyServerPropertyFlags,
            AuthFlags: X509EnrollmentAuthFlags,
            EnrollmentServerAuthFlags: X509EnrollmentAuthFlags,
            UrlFlags: PolicyServerUrlFlags,
            strRequestId: BSTR,
            strUrl: BSTR,
            strId: BSTR,
            strEnrollmentServerUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicyServerUrl: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicyServerId: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnrollmentServerUrl: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequestIdString: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyFlags: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: *EnrollmentPolicyServerPropertyFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUrlFlags: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: *PolicyServerUrlFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthentication: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: *X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnrollmentServerAuthentication: fn(
            self: *const ICertPropertyEnrollmentPolicyServer,
            pValue: *X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_Initialize(self: *const T, PropertyFlags: EnrollmentPolicyServerPropertyFlags, AuthFlags: X509EnrollmentAuthFlags, EnrollmentServerAuthFlags: X509EnrollmentAuthFlags, UrlFlags: PolicyServerUrlFlags, strRequestId: BSTR, strUrl: BSTR, strId: BSTR, strEnrollmentServerUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).Initialize(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), PropertyFlags, AuthFlags, EnrollmentServerAuthFlags, UrlFlags, strRequestId, strUrl, strId, strEnrollmentServerUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetPolicyServerUrl(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetPolicyServerUrl(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetPolicyServerId(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetPolicyServerId(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetEnrollmentServerUrl(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetEnrollmentServerUrl(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetRequestIdString(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetRequestIdString(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetPropertyFlags(self: *const T, pValue: *EnrollmentPolicyServerPropertyFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetPropertyFlags(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetUrlFlags(self: *const T, pValue: *PolicyServerUrlFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetUrlFlags(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetAuthentication(self: *const T, pValue: *X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetAuthentication(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertPropertyEnrollmentPolicyServer_GetEnrollmentServerAuthentication(self: *const T, pValue: *X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertPropertyEnrollmentPolicyServer.VTable, self.vtable).GetEnrollmentServerAuthentication(@ptrCast(*const ICertPropertyEnrollmentPolicyServer, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509SignatureInformation_Value = @import("../zig.zig").Guid.initString("728ab33c-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509SignatureInformation = &IID_IX509SignatureInformation_Value;
pub const IX509SignatureInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const IX509SignatureInformation,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const IX509SignatureInformation,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublicKeyAlgorithm: fn(
            self: *const IX509SignatureInformation,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PublicKeyAlgorithm: fn(
            self: *const IX509SignatureInformation,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parameters: fn(
            self: *const IX509SignatureInformation,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Parameters: fn(
            self: *const IX509SignatureInformation,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternateSignatureAlgorithm: fn(
            self: *const IX509SignatureInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlternateSignatureAlgorithm: fn(
            self: *const IX509SignatureInformation,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternateSignatureAlgorithmSet: fn(
            self: *const IX509SignatureInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NullSigned: fn(
            self: *const IX509SignatureInformation,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NullSigned: fn(
            self: *const IX509SignatureInformation,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureAlgorithm: fn(
            self: *const IX509SignatureInformation,
            Pkcs7Signature: i16,
            SignatureKey: i16,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultValues: fn(
            self: *const IX509SignatureInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_HashAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const IX509SignatureInformation, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_put_HashAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const IX509SignatureInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_PublicKeyAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_PublicKeyAlgorithm(@ptrCast(*const IX509SignatureInformation, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_put_PublicKeyAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).put_PublicKeyAlgorithm(@ptrCast(*const IX509SignatureInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_Parameters(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_Parameters(@ptrCast(*const IX509SignatureInformation, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_put_Parameters(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).put_Parameters(@ptrCast(*const IX509SignatureInformation, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_AlternateSignatureAlgorithm(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_AlternateSignatureAlgorithm(@ptrCast(*const IX509SignatureInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_put_AlternateSignatureAlgorithm(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).put_AlternateSignatureAlgorithm(@ptrCast(*const IX509SignatureInformation, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_AlternateSignatureAlgorithmSet(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_AlternateSignatureAlgorithmSet(@ptrCast(*const IX509SignatureInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_get_NullSigned(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).get_NullSigned(@ptrCast(*const IX509SignatureInformation, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_put_NullSigned(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).put_NullSigned(@ptrCast(*const IX509SignatureInformation, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_GetSignatureAlgorithm(self: *const T, Pkcs7Signature: i16, SignatureKey: i16, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).GetSignatureAlgorithm(@ptrCast(*const IX509SignatureInformation, self), Pkcs7Signature, SignatureKey, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SignatureInformation_SetDefaultValues(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SignatureInformation.VTable, self.vtable).SetDefaultValues(@ptrCast(*const IX509SignatureInformation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISignerCertificate_Value = @import("../zig.zig").Guid.initString("728ab33d-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ISignerCertificate = &IID_ISignerCertificate_Value;
pub const ISignerCertificate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ISignerCertificate,
            MachineContext: i16,
            VerifyType: X509PrivateKeyVerify,
            Encoding: EncodingType,
            strCertificate: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Certificate: fn(
            self: *const ISignerCertificate,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivateKey: fn(
            self: *const ISignerCertificate,
            ppValue: ?*?*IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const ISignerCertificate,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const ISignerCertificate,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentWindow: fn(
            self: *const ISignerCertificate,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentWindow: fn(
            self: *const ISignerCertificate,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UIContextMessage: fn(
            self: *const ISignerCertificate,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UIContextMessage: fn(
            self: *const ISignerCertificate,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pin: fn(
            self: *const ISignerCertificate,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignatureInformation: fn(
            self: *const ISignerCertificate,
            ppValue: ?*?*IX509SignatureInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_Initialize(self: *const T, MachineContext: i16, VerifyType: X509PrivateKeyVerify, Encoding: EncodingType, strCertificate: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).Initialize(@ptrCast(*const ISignerCertificate, self), MachineContext, VerifyType, Encoding, strCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_Certificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_Certificate(@ptrCast(*const ISignerCertificate, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_PrivateKey(self: *const T, ppValue: ?*?*IX509PrivateKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_PrivateKey(@ptrCast(*const ISignerCertificate, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_Silent(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_Silent(@ptrCast(*const ISignerCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_put_Silent(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).put_Silent(@ptrCast(*const ISignerCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_ParentWindow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_ParentWindow(@ptrCast(*const ISignerCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_put_ParentWindow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).put_ParentWindow(@ptrCast(*const ISignerCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_UIContextMessage(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_UIContextMessage(@ptrCast(*const ISignerCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_put_UIContextMessage(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).put_UIContextMessage(@ptrCast(*const ISignerCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_put_Pin(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).put_Pin(@ptrCast(*const ISignerCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificate_get_SignatureInformation(self: *const T, ppValue: ?*?*IX509SignatureInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificate.VTable, self.vtable).get_SignatureInformation(@ptrCast(*const ISignerCertificate, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISignerCertificates_Value = @import("../zig.zig").Guid.initString("728ab33e-217d-11da-b2a4-000e7bbb2b09");
pub const IID_ISignerCertificates = &IID_ISignerCertificates_Value;
pub const ISignerCertificates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ISignerCertificates,
            Index: i32,
            pVal: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ISignerCertificates,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ISignerCertificates,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISignerCertificates,
            pVal: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ISignerCertificates,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ISignerCertificates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const ISignerCertificates,
            pSignerCert: ?*ISignerCertificate,
            piSignerCert: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ISignerCertificates, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).get_Count(@ptrCast(*const ISignerCertificates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).get__NewEnum(@ptrCast(*const ISignerCertificates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_Add(self: *const T, pVal: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).Add(@ptrCast(*const ISignerCertificates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).Remove(@ptrCast(*const ISignerCertificates, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).Clear(@ptrCast(*const ISignerCertificates, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISignerCertificates_Find(self: *const T, pSignerCert: ?*ISignerCertificate, piSignerCert: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISignerCertificates.VTable, self.vtable).Find(@ptrCast(*const ISignerCertificates, self), pSignerCert, piSignerCert);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509NameValuePair_Value = @import("../zig.zig").Guid.initString("728ab33f-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509NameValuePair = &IID_IX509NameValuePair_Value;
pub const IX509NameValuePair = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509NameValuePair,
            strName: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IX509NameValuePair,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IX509NameValuePair,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePair_Initialize(self: *const T, strName: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePair.VTable, self.vtable).Initialize(@ptrCast(*const IX509NameValuePair, self), strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePair_get_Value(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePair.VTable, self.vtable).get_Value(@ptrCast(*const IX509NameValuePair, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePair_get_Name(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePair.VTable, self.vtable).get_Name(@ptrCast(*const IX509NameValuePair, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509NameValuePairs_Value = @import("../zig.zig").Guid.initString("728ab340-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509NameValuePairs = &IID_IX509NameValuePairs_Value;
pub const IX509NameValuePairs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509NameValuePairs,
            Index: i32,
            pVal: ?*?*IX509NameValuePair,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509NameValuePairs,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509NameValuePairs,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509NameValuePairs,
            pVal: ?*IX509NameValuePair,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509NameValuePairs,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509NameValuePairs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509NameValuePair) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509NameValuePairs, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).get_Count(@ptrCast(*const IX509NameValuePairs, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509NameValuePairs, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_Add(self: *const T, pVal: ?*IX509NameValuePair) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).Add(@ptrCast(*const IX509NameValuePairs, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).Remove(@ptrCast(*const IX509NameValuePairs, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509NameValuePairs_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509NameValuePairs.VTable, self.vtable).Clear(@ptrCast(*const IX509NameValuePairs, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EnrollmentTemplateProperty = extern enum(i32) {
    CommonName = 1,
    FriendlyName = 2,
    EKUs = 3,
    CryptoProviders = 4,
    MajorRevision = 5,
    Description = 6,
    KeySpec = 7,
    SchemaVersion = 8,
    MinorRevision = 9,
    RASignatureCount = 10,
    MinimumKeySize = 11,
    OID = 12,
    Supersede = 13,
    RACertificatePolicies = 14,
    RAEKUs = 15,
    CertificatePolicies = 16,
    V1ApplicationPolicy = 17,
    AsymmetricAlgorithm = 18,
    KeySecurityDescriptor = 19,
    SymmetricAlgorithm = 20,
    SymmetricKeyLength = 21,
    HashAlgorithm = 22,
    KeyUsage = 23,
    EnrollmentFlags = 24,
    SubjectNameFlags = 25,
    PrivateKeyFlags = 26,
    GeneralFlags = 27,
    SecurityDescriptor = 28,
    Extensions = 29,
    ValidityPeriod = 30,
    RenewalPeriod = 31,
};
pub const TemplatePropCommonName = EnrollmentTemplateProperty.CommonName;
pub const TemplatePropFriendlyName = EnrollmentTemplateProperty.FriendlyName;
pub const TemplatePropEKUs = EnrollmentTemplateProperty.EKUs;
pub const TemplatePropCryptoProviders = EnrollmentTemplateProperty.CryptoProviders;
pub const TemplatePropMajorRevision = EnrollmentTemplateProperty.MajorRevision;
pub const TemplatePropDescription = EnrollmentTemplateProperty.Description;
pub const TemplatePropKeySpec = EnrollmentTemplateProperty.KeySpec;
pub const TemplatePropSchemaVersion = EnrollmentTemplateProperty.SchemaVersion;
pub const TemplatePropMinorRevision = EnrollmentTemplateProperty.MinorRevision;
pub const TemplatePropRASignatureCount = EnrollmentTemplateProperty.RASignatureCount;
pub const TemplatePropMinimumKeySize = EnrollmentTemplateProperty.MinimumKeySize;
pub const TemplatePropOID = EnrollmentTemplateProperty.OID;
pub const TemplatePropSupersede = EnrollmentTemplateProperty.Supersede;
pub const TemplatePropRACertificatePolicies = EnrollmentTemplateProperty.RACertificatePolicies;
pub const TemplatePropRAEKUs = EnrollmentTemplateProperty.RAEKUs;
pub const TemplatePropCertificatePolicies = EnrollmentTemplateProperty.CertificatePolicies;
pub const TemplatePropV1ApplicationPolicy = EnrollmentTemplateProperty.V1ApplicationPolicy;
pub const TemplatePropAsymmetricAlgorithm = EnrollmentTemplateProperty.AsymmetricAlgorithm;
pub const TemplatePropKeySecurityDescriptor = EnrollmentTemplateProperty.KeySecurityDescriptor;
pub const TemplatePropSymmetricAlgorithm = EnrollmentTemplateProperty.SymmetricAlgorithm;
pub const TemplatePropSymmetricKeyLength = EnrollmentTemplateProperty.SymmetricKeyLength;
pub const TemplatePropHashAlgorithm = EnrollmentTemplateProperty.HashAlgorithm;
pub const TemplatePropKeyUsage = EnrollmentTemplateProperty.KeyUsage;
pub const TemplatePropEnrollmentFlags = EnrollmentTemplateProperty.EnrollmentFlags;
pub const TemplatePropSubjectNameFlags = EnrollmentTemplateProperty.SubjectNameFlags;
pub const TemplatePropPrivateKeyFlags = EnrollmentTemplateProperty.PrivateKeyFlags;
pub const TemplatePropGeneralFlags = EnrollmentTemplateProperty.GeneralFlags;
pub const TemplatePropSecurityDescriptor = EnrollmentTemplateProperty.SecurityDescriptor;
pub const TemplatePropExtensions = EnrollmentTemplateProperty.Extensions;
pub const TemplatePropValidityPeriod = EnrollmentTemplateProperty.ValidityPeriod;
pub const TemplatePropRenewalPeriod = EnrollmentTemplateProperty.RenewalPeriod;

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateTemplate_Value = @import("../zig.zig").Guid.initString("54244a13-555a-4e22-896d-1b0e52f76406");
pub const IID_IX509CertificateTemplate = &IID_IX509CertificateTemplate_Value;
pub const IX509CertificateTemplate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: fn(
            self: *const IX509CertificateTemplate,
            property: EnrollmentTemplateProperty,
            pValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplate_get_Property(self: *const T, property: EnrollmentTemplateProperty, pValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplate.VTable, self.vtable).get_Property(@ptrCast(*const IX509CertificateTemplate, self), property, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateTemplates_Value = @import("../zig.zig").Guid.initString("13b79003-2181-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateTemplates = &IID_IX509CertificateTemplates_Value;
pub const IX509CertificateTemplates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509CertificateTemplates,
            Index: i32,
            pVal: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509CertificateTemplates,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509CertificateTemplates,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509CertificateTemplates,
            pVal: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509CertificateTemplates,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509CertificateTemplates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const IX509CertificateTemplates,
            bstrName: BSTR,
            ppValue: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByOid: fn(
            self: *const IX509CertificateTemplates,
            pOid: ?*IObjectId,
            ppValue: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509CertificateTemplates, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).get_Count(@ptrCast(*const IX509CertificateTemplates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509CertificateTemplates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_Add(self: *const T, pVal: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).Add(@ptrCast(*const IX509CertificateTemplates, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).Remove(@ptrCast(*const IX509CertificateTemplates, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).Clear(@ptrCast(*const IX509CertificateTemplates, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_get_ItemByName(self: *const T, bstrName: BSTR, ppValue: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).get_ItemByName(@ptrCast(*const IX509CertificateTemplates, self), bstrName, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplates_get_ItemByOid(self: *const T, pOid: ?*IObjectId, ppValue: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplates.VTable, self.vtable).get_ItemByOid(@ptrCast(*const IX509CertificateTemplates, self), pOid, ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CommitTemplateFlags = extern enum(i32) {
    SaveTemplateGenerateOID = 1,
    SaveTemplateUseCurrentOID = 2,
    SaveTemplateOverwrite = 3,
    DeleteTemplate = 4,
};
pub const CommitFlagSaveTemplateGenerateOID = CommitTemplateFlags.SaveTemplateGenerateOID;
pub const CommitFlagSaveTemplateUseCurrentOID = CommitTemplateFlags.SaveTemplateUseCurrentOID;
pub const CommitFlagSaveTemplateOverwrite = CommitTemplateFlags.SaveTemplateOverwrite;
pub const CommitFlagDeleteTemplate = CommitTemplateFlags.DeleteTemplate;

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateTemplateWritable_Value = @import("../zig.zig").Guid.initString("f49466a7-395a-4e9e-b6e7-32b331600dc0");
pub const IID_IX509CertificateTemplateWritable = &IID_IX509CertificateTemplateWritable_Value;
pub const IX509CertificateTemplateWritable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509CertificateTemplateWritable,
            pValue: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IX509CertificateTemplateWritable,
            commitFlags: CommitTemplateFlags,
            strServerContext: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: fn(
            self: *const IX509CertificateTemplateWritable,
            property: EnrollmentTemplateProperty,
            pValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Property: fn(
            self: *const IX509CertificateTemplateWritable,
            property: EnrollmentTemplateProperty,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509CertificateTemplateWritable,
            ppValue: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplateWritable_Initialize(self: *const T, pValue: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplateWritable.VTable, self.vtable).Initialize(@ptrCast(*const IX509CertificateTemplateWritable, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplateWritable_Commit(self: *const T, commitFlags: CommitTemplateFlags, strServerContext: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplateWritable.VTable, self.vtable).Commit(@ptrCast(*const IX509CertificateTemplateWritable, self), commitFlags, strServerContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplateWritable_get_Property(self: *const T, property: EnrollmentTemplateProperty, pValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplateWritable.VTable, self.vtable).get_Property(@ptrCast(*const IX509CertificateTemplateWritable, self), property, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplateWritable_put_Property(self: *const T, property: EnrollmentTemplateProperty, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplateWritable.VTable, self.vtable).put_Property(@ptrCast(*const IX509CertificateTemplateWritable, self), property, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateTemplateWritable_get_Template(self: *const T, ppValue: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateTemplateWritable.VTable, self.vtable).get_Template(@ptrCast(*const IX509CertificateTemplateWritable, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EnrollmentCAProperty = extern enum(i32) {
    CommonName = 1,
    DistinguishedName = 2,
    SanitizedName = 3,
    SanitizedShortName = 4,
    DNSName = 5,
    CertificateTypes = 6,
    Certificate = 7,
    Description = 8,
    WebServers = 9,
    SiteName = 10,
    Security = 11,
    RenewalOnly = 12,
};
pub const CAPropCommonName = EnrollmentCAProperty.CommonName;
pub const CAPropDistinguishedName = EnrollmentCAProperty.DistinguishedName;
pub const CAPropSanitizedName = EnrollmentCAProperty.SanitizedName;
pub const CAPropSanitizedShortName = EnrollmentCAProperty.SanitizedShortName;
pub const CAPropDNSName = EnrollmentCAProperty.DNSName;
pub const CAPropCertificateTypes = EnrollmentCAProperty.CertificateTypes;
pub const CAPropCertificate = EnrollmentCAProperty.Certificate;
pub const CAPropDescription = EnrollmentCAProperty.Description;
pub const CAPropWebServers = EnrollmentCAProperty.WebServers;
pub const CAPropSiteName = EnrollmentCAProperty.SiteName;
pub const CAPropSecurity = EnrollmentCAProperty.Security;
pub const CAPropRenewalOnly = EnrollmentCAProperty.RenewalOnly;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificationAuthority_Value = @import("../zig.zig").Guid.initString("835d1f61-1e95-4bc8-b4d3-976c42b968f7");
pub const IID_ICertificationAuthority = &IID_ICertificationAuthority_Value;
pub const ICertificationAuthority = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: fn(
            self: *const ICertificationAuthority,
            property: EnrollmentCAProperty,
            pValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthority_get_Property(self: *const T, property: EnrollmentCAProperty, pValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthority.VTable, self.vtable).get_Property(@ptrCast(*const ICertificationAuthority, self), property, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificationAuthorities_Value = @import("../zig.zig").Guid.initString("13b79005-2181-11da-b2a4-000e7bbb2b09");
pub const IID_ICertificationAuthorities = &IID_ICertificationAuthorities_Value;
pub const ICertificationAuthorities = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const ICertificationAuthorities,
            Index: i32,
            pVal: ?*?*ICertificationAuthority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertificationAuthorities,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertificationAuthorities,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertificationAuthorities,
            pVal: ?*ICertificationAuthority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ICertificationAuthorities,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ICertificationAuthorities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComputeSiteCosts: fn(
            self: *const ICertificationAuthorities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const ICertificationAuthorities,
            strName: BSTR,
            ppValue: ?*?*ICertificationAuthority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*ICertificationAuthority) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const ICertificationAuthorities, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).get_Count(@ptrCast(*const ICertificationAuthorities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertificationAuthorities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_Add(self: *const T, pVal: ?*ICertificationAuthority) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).Add(@ptrCast(*const ICertificationAuthorities, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).Remove(@ptrCast(*const ICertificationAuthorities, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).Clear(@ptrCast(*const ICertificationAuthorities, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_ComputeSiteCosts(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).ComputeSiteCosts(@ptrCast(*const ICertificationAuthorities, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificationAuthorities_get_ItemByName(self: *const T, strName: BSTR, ppValue: ?*?*ICertificationAuthority) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificationAuthorities.VTable, self.vtable).get_ItemByName(@ptrCast(*const ICertificationAuthorities, self), strName, ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509EnrollmentPolicyLoadOption = extern enum(i32) {
    Default = 0,
    CacheOnly = 1,
    Reload = 2,
    RegisterForADChanges = 4,
};
pub const LoadOptionDefault = X509EnrollmentPolicyLoadOption.Default;
pub const LoadOptionCacheOnly = X509EnrollmentPolicyLoadOption.CacheOnly;
pub const LoadOptionReload = X509EnrollmentPolicyLoadOption.Reload;
pub const LoadOptionRegisterForADChanges = X509EnrollmentPolicyLoadOption.RegisterForADChanges;

pub const EnrollmentPolicyFlags = extern enum(i32) {
    GroupPolicyList = 2,
    UserServerList = 4,
};
pub const DisableGroupPolicyList = EnrollmentPolicyFlags.GroupPolicyList;
pub const DisableUserServerList = EnrollmentPolicyFlags.UserServerList;

pub const PolicyServerUrlPropertyID = extern enum(i32) {
    PolicyID = 0,
    FriendlyName = 1,
};
pub const PsPolicyID = PolicyServerUrlPropertyID.PolicyID;
pub const PsFriendlyName = PolicyServerUrlPropertyID.FriendlyName;

pub const X509EnrollmentPolicyExportFlags = extern enum(i32) {
    Templates = 1,
    OIDs = 2,
    CAs = 4,
};
pub const ExportTemplates = X509EnrollmentPolicyExportFlags.Templates;
pub const ExportOIDs = X509EnrollmentPolicyExportFlags.OIDs;
pub const ExportCAs = X509EnrollmentPolicyExportFlags.CAs;

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509EnrollmentPolicyServer_Value = @import("../zig.zig").Guid.initString("13b79026-2181-11da-b2a4-000e7bbb2b09");
pub const IID_IX509EnrollmentPolicyServer = &IID_IX509EnrollmentPolicyServer_Value;
pub const IX509EnrollmentPolicyServer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509EnrollmentPolicyServer,
            bstrPolicyServerUrl: BSTR,
            bstrPolicyServerId: BSTR,
            authFlags: X509EnrollmentAuthFlags,
            fIsUnTrusted: i16,
            context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadPolicy: fn(
            self: *const IX509EnrollmentPolicyServer,
            option: X509EnrollmentPolicyLoadOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTemplates: fn(
            self: *const IX509EnrollmentPolicyServer,
            pTemplates: ?*?*IX509CertificateTemplates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAsForTemplate: fn(
            self: *const IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
            ppCAs: ?*?*ICertificationAuthorities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAs: fn(
            self: *const IX509EnrollmentPolicyServer,
            ppCAs: ?*?*ICertificationAuthorities,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomOids: fn(
            self: *const IX509EnrollmentPolicyServer,
            ppObjectIds: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextUpdateTime: fn(
            self: *const IX509EnrollmentPolicyServer,
            pDate: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastUpdateTime: fn(
            self: *const IX509EnrollmentPolicyServer,
            pDate: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicyServerUrl: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicyServerId: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIsDefaultCEP: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUseClientId: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllowUnTrustedCA: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachePath: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCacheDir: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthFlags: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCredential: fn(
            self: *const IX509EnrollmentPolicyServer,
            hWndParent: i32,
            flag: X509EnrollmentAuthFlags,
            strCredential: BSTR,
            strPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryChanges: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeImport: fn(
            self: *const IX509EnrollmentPolicyServer,
            val: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Export: fn(
            self: *const IX509EnrollmentPolicyServer,
            exportFlags: X509EnrollmentPolicyExportFlags,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cost: fn(
            self: *const IX509EnrollmentPolicyServer,
            pValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Cost: fn(
            self: *const IX509EnrollmentPolicyServer,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_Initialize(self: *const T, bstrPolicyServerUrl: BSTR, bstrPolicyServerId: BSTR, authFlags: X509EnrollmentAuthFlags, fIsUnTrusted: i16, context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).Initialize(@ptrCast(*const IX509EnrollmentPolicyServer, self), bstrPolicyServerUrl, bstrPolicyServerId, authFlags, fIsUnTrusted, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_LoadPolicy(self: *const T, option: X509EnrollmentPolicyLoadOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).LoadPolicy(@ptrCast(*const IX509EnrollmentPolicyServer, self), option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetTemplates(self: *const T, pTemplates: ?*?*IX509CertificateTemplates) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetTemplates(@ptrCast(*const IX509EnrollmentPolicyServer, self), pTemplates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetCAsForTemplate(self: *const T, pTemplate: ?*IX509CertificateTemplate, ppCAs: ?*?*ICertificationAuthorities) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetCAsForTemplate(@ptrCast(*const IX509EnrollmentPolicyServer, self), pTemplate, ppCAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetCAs(self: *const T, ppCAs: ?*?*ICertificationAuthorities) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetCAs(@ptrCast(*const IX509EnrollmentPolicyServer, self), ppCAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_Validate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).Validate(@ptrCast(*const IX509EnrollmentPolicyServer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetCustomOids(self: *const T, ppObjectIds: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetCustomOids(@ptrCast(*const IX509EnrollmentPolicyServer, self), ppObjectIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetNextUpdateTime(self: *const T, pDate: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetNextUpdateTime(@ptrCast(*const IX509EnrollmentPolicyServer, self), pDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetLastUpdateTime(self: *const T, pDate: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetLastUpdateTime(@ptrCast(*const IX509EnrollmentPolicyServer, self), pDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetPolicyServerUrl(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetPolicyServerUrl(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetPolicyServerId(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetPolicyServerId(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetFriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetFriendlyName(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetIsDefaultCEP(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetIsDefaultCEP(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetUseClientId(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetUseClientId(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetAllowUnTrustedCA(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetAllowUnTrustedCA(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetCachePath(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetCachePath(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetCacheDir(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetCacheDir(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_GetAuthFlags(self: *const T, pValue: *X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).GetAuthFlags(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_SetCredential(self: *const T, hWndParent: i32, flag: X509EnrollmentAuthFlags, strCredential: BSTR, strPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).SetCredential(@ptrCast(*const IX509EnrollmentPolicyServer, self), hWndParent, flag, strCredential, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_QueryChanges(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).QueryChanges(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_InitializeImport(self: *const T, val: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).InitializeImport(@ptrCast(*const IX509EnrollmentPolicyServer, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_Export(self: *const T, exportFlags: X509EnrollmentPolicyExportFlags, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).Export(@ptrCast(*const IX509EnrollmentPolicyServer, self), exportFlags, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_get_Cost(self: *const T, pValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).get_Cost(@ptrCast(*const IX509EnrollmentPolicyServer, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentPolicyServer_put_Cost(self: *const T, value: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentPolicyServer.VTable, self.vtable).put_Cost(@ptrCast(*const IX509EnrollmentPolicyServer, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509PolicyServerUrl_Value = @import("../zig.zig").Guid.initString("884e204a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509PolicyServerUrl = &IID_IX509PolicyServerUrl_Value;
pub const IX509PolicyServerUrl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509PolicyServerUrl,
            context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Url: fn(
            self: *const IX509PolicyServerUrl,
            ppValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Url: fn(
            self: *const IX509PolicyServerUrl,
            pValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Default: fn(
            self: *const IX509PolicyServerUrl,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Default: fn(
            self: *const IX509PolicyServerUrl,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: fn(
            self: *const IX509PolicyServerUrl,
            pValue: *PolicyServerUrlFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: fn(
            self: *const IX509PolicyServerUrl,
            Flags: PolicyServerUrlFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthFlags: fn(
            self: *const IX509PolicyServerUrl,
            pValue: *X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AuthFlags: fn(
            self: *const IX509PolicyServerUrl,
            Flags: X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cost: fn(
            self: *const IX509PolicyServerUrl,
            pValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Cost: fn(
            self: *const IX509PolicyServerUrl,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringProperty: fn(
            self: *const IX509PolicyServerUrl,
            propertyId: PolicyServerUrlPropertyID,
            ppValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStringProperty: fn(
            self: *const IX509PolicyServerUrl,
            propertyId: PolicyServerUrlPropertyID,
            pValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateRegistry: fn(
            self: *const IX509PolicyServerUrl,
            context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromRegistry: fn(
            self: *const IX509PolicyServerUrl,
            context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_Initialize(self: *const T, context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).Initialize(@ptrCast(*const IX509PolicyServerUrl, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_get_Url(self: *const T, ppValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).get_Url(@ptrCast(*const IX509PolicyServerUrl, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_put_Url(self: *const T, pValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).put_Url(@ptrCast(*const IX509PolicyServerUrl, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_get_Default(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).get_Default(@ptrCast(*const IX509PolicyServerUrl, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_put_Default(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).put_Default(@ptrCast(*const IX509PolicyServerUrl, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_get_Flags(self: *const T, pValue: *PolicyServerUrlFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).get_Flags(@ptrCast(*const IX509PolicyServerUrl, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_put_Flags(self: *const T, Flags: PolicyServerUrlFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).put_Flags(@ptrCast(*const IX509PolicyServerUrl, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_get_AuthFlags(self: *const T, pValue: *X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).get_AuthFlags(@ptrCast(*const IX509PolicyServerUrl, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_put_AuthFlags(self: *const T, Flags: X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).put_AuthFlags(@ptrCast(*const IX509PolicyServerUrl, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_get_Cost(self: *const T, pValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).get_Cost(@ptrCast(*const IX509PolicyServerUrl, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_put_Cost(self: *const T, value: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).put_Cost(@ptrCast(*const IX509PolicyServerUrl, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_GetStringProperty(self: *const T, propertyId: PolicyServerUrlPropertyID, ppValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).GetStringProperty(@ptrCast(*const IX509PolicyServerUrl, self), propertyId, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_SetStringProperty(self: *const T, propertyId: PolicyServerUrlPropertyID, pValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).SetStringProperty(@ptrCast(*const IX509PolicyServerUrl, self), propertyId, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_UpdateRegistry(self: *const T, context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).UpdateRegistry(@ptrCast(*const IX509PolicyServerUrl, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerUrl_RemoveFromRegistry(self: *const T, context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerUrl.VTable, self.vtable).RemoveFromRegistry(@ptrCast(*const IX509PolicyServerUrl, self), context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509PolicyServerListManager_Value = @import("../zig.zig").Guid.initString("884e204b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509PolicyServerListManager = &IID_IX509PolicyServerListManager_Value;
pub const IX509PolicyServerListManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509PolicyServerListManager,
            Index: i32,
            pVal: ?*?*IX509PolicyServerUrl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509PolicyServerListManager,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509PolicyServerListManager,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509PolicyServerListManager,
            pVal: ?*IX509PolicyServerUrl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509PolicyServerListManager,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509PolicyServerListManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IX509PolicyServerListManager,
            context: X509CertificateEnrollmentContext,
            Flags: PolicyServerUrlFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509PolicyServerUrl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509PolicyServerListManager, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).get_Count(@ptrCast(*const IX509PolicyServerListManager, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509PolicyServerListManager, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_Add(self: *const T, pVal: ?*IX509PolicyServerUrl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).Add(@ptrCast(*const IX509PolicyServerListManager, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).Remove(@ptrCast(*const IX509PolicyServerListManager, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).Clear(@ptrCast(*const IX509PolicyServerListManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509PolicyServerListManager_Initialize(self: *const T, context: X509CertificateEnrollmentContext, Flags: PolicyServerUrlFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509PolicyServerListManager.VTable, self.vtable).Initialize(@ptrCast(*const IX509PolicyServerListManager, self), context, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509RequestType = extern enum(i32) {
    Any = 0,
    Pkcs10 = 1,
    Pkcs7 = 2,
    Cmc = 3,
    Certificate = 4,
};
pub const TypeAny = X509RequestType.Any;
pub const TypePkcs10 = X509RequestType.Pkcs10;
pub const TypePkcs7 = X509RequestType.Pkcs7;
pub const TypeCmc = X509RequestType.Cmc;
pub const TypeCertificate = X509RequestType.Certificate;

pub const X509RequestInheritOptions = extern enum(i32) {
    Default = 0,
    NewDefaultKey = 1,
    NewSimilarKey = 2,
    PrivateKey = 3,
    PublicKey = 4,
    KeyMask = 15,
    None = 16,
    RenewalCertificateFlag = 32,
    TemplateFlag = 64,
    SubjectFlag = 128,
    ExtensionsFlag = 256,
    SubjectAltNameFlag = 512,
    ValidityPeriodFlag = 1024,
    Reserved80000000 = -2147483648,
};
pub const InheritDefault = X509RequestInheritOptions.Default;
pub const InheritNewDefaultKey = X509RequestInheritOptions.NewDefaultKey;
pub const InheritNewSimilarKey = X509RequestInheritOptions.NewSimilarKey;
pub const InheritPrivateKey = X509RequestInheritOptions.PrivateKey;
pub const InheritPublicKey = X509RequestInheritOptions.PublicKey;
pub const InheritKeyMask = X509RequestInheritOptions.KeyMask;
pub const InheritNone = X509RequestInheritOptions.None;
pub const InheritRenewalCertificateFlag = X509RequestInheritOptions.RenewalCertificateFlag;
pub const InheritTemplateFlag = X509RequestInheritOptions.TemplateFlag;
pub const InheritSubjectFlag = X509RequestInheritOptions.SubjectFlag;
pub const InheritExtensionsFlag = X509RequestInheritOptions.ExtensionsFlag;
pub const InheritSubjectAltNameFlag = X509RequestInheritOptions.SubjectAltNameFlag;
pub const InheritValidityPeriodFlag = X509RequestInheritOptions.ValidityPeriodFlag;
pub const InheritReserved80000000 = X509RequestInheritOptions.Reserved80000000;

pub const InnerRequestLevel = extern enum(i32) {
    Innermost = 0,
    Next = 1,
};
pub const LevelInnermost = InnerRequestLevel.Innermost;
pub const LevelNext = InnerRequestLevel.Next;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509CertificateRequest_Value = @import("../zig.zig").Guid.initString("728ab341-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequest = &IID_IX509CertificateRequest_Value;
pub const IX509CertificateRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509CertificateRequest,
            Context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetForEncode: fn(
            self: *const IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInnerRequest: fn(
            self: *const IX509CertificateRequest,
            Level: InnerRequestLevel,
            ppValue: ?*?*IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IX509CertificateRequest,
            pValue: *X509RequestType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnrollmentContext: fn(
            self: *const IX509CertificateRequest,
            pValue: *X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IX509CertificateRequest,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IX509CertificateRequest,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentWindow: fn(
            self: *const IX509CertificateRequest,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentWindow: fn(
            self: *const IX509CertificateRequest,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UIContextMessage: fn(
            self: *const IX509CertificateRequest,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UIContextMessage: fn(
            self: *const IX509CertificateRequest,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressDefaults: fn(
            self: *const IX509CertificateRequest,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressDefaults: fn(
            self: *const IX509CertificateRequest,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RenewalCertificate: fn(
            self: *const IX509CertificateRequest,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RenewalCertificate: fn(
            self: *const IX509CertificateRequest,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientId: fn(
            self: *const IX509CertificateRequest,
            pValue: *RequestClientInfoClientId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientId: fn(
            self: *const IX509CertificateRequest,
            Value: RequestClientInfoClientId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspInformations: fn(
            self: *const IX509CertificateRequest,
            ppValue: ?*?*ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CspInformations: fn(
            self: *const IX509CertificateRequest,
            pValue: ?*ICspInformations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const IX509CertificateRequest,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const IX509CertificateRequest,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternateSignatureAlgorithm: fn(
            self: *const IX509CertificateRequest,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlternateSignatureAlgorithm: fn(
            self: *const IX509CertificateRequest,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IX509CertificateRequest,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_Initialize(self: *const T, Context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).Initialize(@ptrCast(*const IX509CertificateRequest, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_Encode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).Encode(@ptrCast(*const IX509CertificateRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_ResetForEncode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).ResetForEncode(@ptrCast(*const IX509CertificateRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_GetInnerRequest(self: *const T, Level: InnerRequestLevel, ppValue: ?*?*IX509CertificateRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).GetInnerRequest(@ptrCast(*const IX509CertificateRequest, self), Level, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_Type(self: *const T, pValue: *X509RequestType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_Type(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_EnrollmentContext(self: *const T, pValue: *X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_EnrollmentContext(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_Silent(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_Silent(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_Silent(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_Silent(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_ParentWindow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_ParentWindow(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_ParentWindow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_ParentWindow(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_UIContextMessage(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_UIContextMessage(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_UIContextMessage(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_UIContextMessage(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_SuppressDefaults(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_SuppressDefaults(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_SuppressDefaults(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_SuppressDefaults(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_RenewalCertificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_RenewalCertificate(@ptrCast(*const IX509CertificateRequest, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_RenewalCertificate(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_RenewalCertificate(@ptrCast(*const IX509CertificateRequest, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_ClientId(self: *const T, pValue: *RequestClientInfoClientId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_ClientId(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_ClientId(self: *const T, Value: RequestClientInfoClientId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_ClientId(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_CspInformations(self: *const T, ppValue: ?*?*ICspInformations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_CspInformations(@ptrCast(*const IX509CertificateRequest, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_CspInformations(self: *const T, pValue: ?*ICspInformations) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_CspInformations(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_HashAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const IX509CertificateRequest, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_HashAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_AlternateSignatureAlgorithm(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_AlternateSignatureAlgorithm(@ptrCast(*const IX509CertificateRequest, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_put_AlternateSignatureAlgorithm(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).put_AlternateSignatureAlgorithm(@ptrCast(*const IX509CertificateRequest, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequest_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequest.VTable, self.vtable).get_RawData(@ptrCast(*const IX509CertificateRequest, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Pkcs10AllowedSignatureTypes = extern enum(i32) {
    KeySignature = 1,
    NullSignature = 2,
};
pub const AllowedKeySignature = Pkcs10AllowedSignatureTypes.KeySignature;
pub const AllowedNullSignature = Pkcs10AllowedSignatureTypes.NullSignature;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509CertificateRequestPkcs10_Value = @import("../zig.zig").Guid.initString("728ab342-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestPkcs10 = &IID_IX509CertificateRequestPkcs10_Value;
pub const IX509CertificateRequestPkcs10 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequest.VTable,
        InitializeFromTemplateName: fn(
            self: *const IX509CertificateRequestPkcs10,
            Context: X509CertificateEnrollmentContext,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromPrivateKey: fn(
            self: *const IX509CertificateRequestPkcs10,
            Context: X509CertificateEnrollmentContext,
            pPrivateKey: ?*IX509PrivateKey,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromPublicKey: fn(
            self: *const IX509CertificateRequestPkcs10,
            Context: X509CertificateEnrollmentContext,
            pPublicKey: ?*IX509PublicKey,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromCertificate: fn(
            self: *const IX509CertificateRequestPkcs10,
            Context: X509CertificateEnrollmentContext,
            strCertificate: BSTR,
            Encoding: EncodingType,
            InheritOptions: X509RequestInheritOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509CertificateRequestPkcs10,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckSignature: fn(
            self: *const IX509CertificateRequestPkcs10,
            AllowedSignatureTypes: Pkcs10AllowedSignatureTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSmartCard: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateObjectId: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublicKey: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IX509PublicKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivateKey: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IX509PrivateKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NullSigned: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReuseKey: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OldCertificate: fn(
            self: *const IX509CertificateRequestPkcs10,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subject: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Subject: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: ?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CspStatuses: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*ICspStatuses,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmimeCapabilities: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SmimeCapabilities: fn(
            self: *const IX509CertificateRequestPkcs10,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignatureInformation: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IX509SignatureInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyContainerNamePrefix: fn(
            self: *const IX509CertificateRequestPkcs10,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyContainerNamePrefix: fn(
            self: *const IX509CertificateRequestPkcs10,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CryptAttributes: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*ICryptAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509Extensions: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CriticalExtensions: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressOids: fn(
            self: *const IX509CertificateRequestPkcs10,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawDataToBeSigned: fn(
            self: *const IX509CertificateRequestPkcs10,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Signature: fn(
            self: *const IX509CertificateRequestPkcs10,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCspStatuses: fn(
            self: *const IX509CertificateRequestPkcs10,
            KeySpec: X509KeySpec,
            ppCspStatuses: ?*?*ICspStatuses,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_InitializeFromTemplateName(self: *const T, Context: X509CertificateEnrollmentContext, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).InitializeFromTemplateName(@ptrCast(*const IX509CertificateRequestPkcs10, self), Context, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_InitializeFromPrivateKey(self: *const T, Context: X509CertificateEnrollmentContext, pPrivateKey: ?*IX509PrivateKey, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).InitializeFromPrivateKey(@ptrCast(*const IX509CertificateRequestPkcs10, self), Context, pPrivateKey, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_InitializeFromPublicKey(self: *const T, Context: X509CertificateEnrollmentContext, pPublicKey: ?*IX509PublicKey, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).InitializeFromPublicKey(@ptrCast(*const IX509CertificateRequestPkcs10, self), Context, pPublicKey, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_InitializeFromCertificate(self: *const T, Context: X509CertificateEnrollmentContext, strCertificate: BSTR, Encoding: EncodingType, InheritOptions: X509RequestInheritOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).InitializeFromCertificate(@ptrCast(*const IX509CertificateRequestPkcs10, self), Context, strCertificate, Encoding, InheritOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_InitializeDecode(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509CertificateRequestPkcs10, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_CheckSignature(self: *const T, AllowedSignatureTypes: Pkcs10AllowedSignatureTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).CheckSignature(@ptrCast(*const IX509CertificateRequestPkcs10, self), AllowedSignatureTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_IsSmartCard(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).IsSmartCard(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_TemplateObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_TemplateObjectId(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_PublicKey(self: *const T, ppValue: ?*?*IX509PublicKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_PublicKey(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_PrivateKey(self: *const T, ppValue: ?*?*IX509PrivateKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_PrivateKey(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_NullSigned(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_NullSigned(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_ReuseKey(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_ReuseKey(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_OldCertificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_OldCertificate(@ptrCast(*const IX509CertificateRequestPkcs10, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_Subject(self: *const T, ppValue: ?*?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_Subject(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_put_Subject(self: *const T, pValue: ?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).put_Subject(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_CspStatuses(self: *const T, ppValue: ?*?*ICspStatuses) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_CspStatuses(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_SmimeCapabilities(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_SmimeCapabilities(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_put_SmimeCapabilities(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).put_SmimeCapabilities(@ptrCast(*const IX509CertificateRequestPkcs10, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_SignatureInformation(self: *const T, ppValue: ?*?*IX509SignatureInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_SignatureInformation(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_KeyContainerNamePrefix(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_KeyContainerNamePrefix(@ptrCast(*const IX509CertificateRequestPkcs10, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_put_KeyContainerNamePrefix(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).put_KeyContainerNamePrefix(@ptrCast(*const IX509CertificateRequestPkcs10, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_CryptAttributes(self: *const T, ppValue: ?*?*ICryptAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_CryptAttributes(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_X509Extensions(self: *const T, ppValue: ?*?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_X509Extensions(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_CriticalExtensions(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_CriticalExtensions(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_SuppressOids(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_SuppressOids(@ptrCast(*const IX509CertificateRequestPkcs10, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_RawDataToBeSigned(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_RawDataToBeSigned(@ptrCast(*const IX509CertificateRequestPkcs10, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_get_Signature(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).get_Signature(@ptrCast(*const IX509CertificateRequestPkcs10, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10_GetCspStatuses(self: *const T, KeySpec: X509KeySpec, ppCspStatuses: ?*?*ICspStatuses) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10.VTable, self.vtable).GetCspStatuses(@ptrCast(*const IX509CertificateRequestPkcs10, self), KeySpec, ppCspStatuses);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateRequestPkcs10V2_Value = @import("../zig.zig").Guid.initString("728ab35b-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestPkcs10V2 = &IID_IX509CertificateRequestPkcs10V2_Value;
pub const IX509CertificateRequestPkcs10V2 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs10.VTable,
        InitializeFromTemplate: fn(
            self: *const IX509CertificateRequestPkcs10V2,
            context: X509CertificateEnrollmentContext,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromPrivateKeyTemplate: fn(
            self: *const IX509CertificateRequestPkcs10V2,
            Context: X509CertificateEnrollmentContext,
            pPrivateKey: ?*IX509PrivateKey,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromPublicKeyTemplate: fn(
            self: *const IX509CertificateRequestPkcs10V2,
            Context: X509CertificateEnrollmentContext,
            pPublicKey: ?*IX509PublicKey,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyServer: fn(
            self: *const IX509CertificateRequestPkcs10V2,
            ppPolicyServer: ?*?*IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509CertificateRequestPkcs10V2,
            ppTemplate: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs10.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V2_InitializeFromTemplate(self: *const T, context: X509CertificateEnrollmentContext, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V2.VTable, self.vtable).InitializeFromTemplate(@ptrCast(*const IX509CertificateRequestPkcs10V2, self), context, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V2_InitializeFromPrivateKeyTemplate(self: *const T, Context: X509CertificateEnrollmentContext, pPrivateKey: ?*IX509PrivateKey, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V2.VTable, self.vtable).InitializeFromPrivateKeyTemplate(@ptrCast(*const IX509CertificateRequestPkcs10V2, self), Context, pPrivateKey, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V2_InitializeFromPublicKeyTemplate(self: *const T, Context: X509CertificateEnrollmentContext, pPublicKey: ?*IX509PublicKey, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V2.VTable, self.vtable).InitializeFromPublicKeyTemplate(@ptrCast(*const IX509CertificateRequestPkcs10V2, self), Context, pPublicKey, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V2_get_PolicyServer(self: *const T, ppPolicyServer: ?*?*IX509EnrollmentPolicyServer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V2.VTable, self.vtable).get_PolicyServer(@ptrCast(*const IX509CertificateRequestPkcs10V2, self), ppPolicyServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V2_get_Template(self: *const T, ppTemplate: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V2.VTable, self.vtable).get_Template(@ptrCast(*const IX509CertificateRequestPkcs10V2, self), ppTemplate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509CertificateRequestPkcs10V3_Value = @import("../zig.zig").Guid.initString("54ea9942-3d66-4530-b76e-7c9170d3ec52");
pub const IID_IX509CertificateRequestPkcs10V3 = &IID_IX509CertificateRequestPkcs10V3_Value;
pub const IX509CertificateRequestPkcs10V3 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs10V2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttestPrivateKey: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttestPrivateKey: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttestationEncryptionCertificate: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttestationEncryptionCertificate: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionAlgorithm: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EncryptionAlgorithm: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionStrength: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EncryptionStrength: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChallengePassword: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ChallengePassword: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NameValuePairs: fn(
            self: *const IX509CertificateRequestPkcs10V3,
            ppValue: ?*?*IX509NameValuePairs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs10V2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_AttestPrivateKey(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_AttestPrivateKey(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_put_AttestPrivateKey(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).put_AttestPrivateKey(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_AttestationEncryptionCertificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_AttestationEncryptionCertificate(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_put_AttestationEncryptionCertificate(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).put_AttestationEncryptionCertificate(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_EncryptionAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_EncryptionAlgorithm(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_put_EncryptionAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).put_EncryptionAlgorithm(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_EncryptionStrength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_EncryptionStrength(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_put_EncryptionStrength(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).put_EncryptionStrength(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_ChallengePassword(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_ChallengePassword(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_put_ChallengePassword(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).put_ChallengePassword(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V3_get_NameValuePairs(self: *const T, ppValue: ?*?*IX509NameValuePairs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V3.VTable, self.vtable).get_NameValuePairs(@ptrCast(*const IX509CertificateRequestPkcs10V3, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KeyAttestationClaimType = extern enum(i32) {
    NONE = 0,
    AUTHORITY_AND_SUBJECT = 3,
    AUTHORITY_ONLY = 1,
    SUBJECT_ONLY = 2,
    UNKNOWN = 4096,
};
pub const XCN_NCRYPT_CLAIM_NONE = KeyAttestationClaimType.NONE;
pub const XCN_NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = KeyAttestationClaimType.AUTHORITY_AND_SUBJECT;
pub const XCN_NCRYPT_CLAIM_AUTHORITY_ONLY = KeyAttestationClaimType.AUTHORITY_ONLY;
pub const XCN_NCRYPT_CLAIM_SUBJECT_ONLY = KeyAttestationClaimType.SUBJECT_ONLY;
pub const XCN_NCRYPT_CLAIM_UNKNOWN = KeyAttestationClaimType.UNKNOWN;

const IID_IX509CertificateRequestPkcs10V4_Value = @import("../zig.zig").Guid.initString("728ab363-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestPkcs10V4 = &IID_IX509CertificateRequestPkcs10V4_Value;
pub const IX509CertificateRequestPkcs10V4 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs10V3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClaimType: fn(
            self: *const IX509CertificateRequestPkcs10V4,
            pValue: *KeyAttestationClaimType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClaimType: fn(
            self: *const IX509CertificateRequestPkcs10V4,
            Value: KeyAttestationClaimType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttestPrivateKeyPreferred: fn(
            self: *const IX509CertificateRequestPkcs10V4,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttestPrivateKeyPreferred: fn(
            self: *const IX509CertificateRequestPkcs10V4,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs10V3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V4_get_ClaimType(self: *const T, pValue: *KeyAttestationClaimType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V4.VTable, self.vtable).get_ClaimType(@ptrCast(*const IX509CertificateRequestPkcs10V4, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V4_put_ClaimType(self: *const T, Value: KeyAttestationClaimType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V4.VTable, self.vtable).put_ClaimType(@ptrCast(*const IX509CertificateRequestPkcs10V4, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V4_get_AttestPrivateKeyPreferred(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V4.VTable, self.vtable).get_AttestPrivateKeyPreferred(@ptrCast(*const IX509CertificateRequestPkcs10V4, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs10V4_put_AttestPrivateKeyPreferred(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs10V4.VTable, self.vtable).put_AttestPrivateKeyPreferred(@ptrCast(*const IX509CertificateRequestPkcs10V4, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509CertificateRequestCertificate_Value = @import("../zig.zig").Guid.initString("728ab343-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestCertificate = &IID_IX509CertificateRequestCertificate_Value;
pub const IX509CertificateRequestCertificate = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs10.VTable,
        CheckPublicKeySignature: fn(
            self: *const IX509CertificateRequestCertificate,
            pPublicKey: ?*IX509PublicKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Issuer: fn(
            self: *const IX509CertificateRequestCertificate,
            ppValue: ?*?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Issuer: fn(
            self: *const IX509CertificateRequestCertificate,
            pValue: ?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotBefore: fn(
            self: *const IX509CertificateRequestCertificate,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotBefore: fn(
            self: *const IX509CertificateRequestCertificate,
            Value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotAfter: fn(
            self: *const IX509CertificateRequestCertificate,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotAfter: fn(
            self: *const IX509CertificateRequestCertificate,
            Value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SerialNumber: fn(
            self: *const IX509CertificateRequestCertificate,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SerialNumber: fn(
            self: *const IX509CertificateRequestCertificate,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignerCertificate: fn(
            self: *const IX509CertificateRequestCertificate,
            ppValue: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignerCertificate: fn(
            self: *const IX509CertificateRequestCertificate,
            pValue: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs10.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_CheckPublicKeySignature(self: *const T, pPublicKey: ?*IX509PublicKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).CheckPublicKeySignature(@ptrCast(*const IX509CertificateRequestCertificate, self), pPublicKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_get_Issuer(self: *const T, ppValue: ?*?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).get_Issuer(@ptrCast(*const IX509CertificateRequestCertificate, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_put_Issuer(self: *const T, pValue: ?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).put_Issuer(@ptrCast(*const IX509CertificateRequestCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_get_NotBefore(self: *const T, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).get_NotBefore(@ptrCast(*const IX509CertificateRequestCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_put_NotBefore(self: *const T, Value: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).put_NotBefore(@ptrCast(*const IX509CertificateRequestCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_get_NotAfter(self: *const T, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).get_NotAfter(@ptrCast(*const IX509CertificateRequestCertificate, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_put_NotAfter(self: *const T, Value: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).put_NotAfter(@ptrCast(*const IX509CertificateRequestCertificate, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_get_SerialNumber(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).get_SerialNumber(@ptrCast(*const IX509CertificateRequestCertificate, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_put_SerialNumber(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).put_SerialNumber(@ptrCast(*const IX509CertificateRequestCertificate, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_get_SignerCertificate(self: *const T, ppValue: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).get_SignerCertificate(@ptrCast(*const IX509CertificateRequestCertificate, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate_put_SignerCertificate(self: *const T, pValue: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate.VTable, self.vtable).put_SignerCertificate(@ptrCast(*const IX509CertificateRequestCertificate, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateRequestCertificate2_Value = @import("../zig.zig").Guid.initString("728ab35a-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestCertificate2 = &IID_IX509CertificateRequestCertificate2_Value;
pub const IX509CertificateRequestCertificate2 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestCertificate.VTable,
        InitializeFromTemplate: fn(
            self: *const IX509CertificateRequestCertificate2,
            context: X509CertificateEnrollmentContext,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromPrivateKeyTemplate: fn(
            self: *const IX509CertificateRequestCertificate2,
            Context: X509CertificateEnrollmentContext,
            pPrivateKey: ?*IX509PrivateKey,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyServer: fn(
            self: *const IX509CertificateRequestCertificate2,
            ppPolicyServer: ?*?*IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509CertificateRequestCertificate2,
            ppTemplate: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestCertificate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate2_InitializeFromTemplate(self: *const T, context: X509CertificateEnrollmentContext, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate2.VTable, self.vtable).InitializeFromTemplate(@ptrCast(*const IX509CertificateRequestCertificate2, self), context, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate2_InitializeFromPrivateKeyTemplate(self: *const T, Context: X509CertificateEnrollmentContext, pPrivateKey: ?*IX509PrivateKey, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate2.VTable, self.vtable).InitializeFromPrivateKeyTemplate(@ptrCast(*const IX509CertificateRequestCertificate2, self), Context, pPrivateKey, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate2_get_PolicyServer(self: *const T, ppPolicyServer: ?*?*IX509EnrollmentPolicyServer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate2.VTable, self.vtable).get_PolicyServer(@ptrCast(*const IX509CertificateRequestCertificate2, self), ppPolicyServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCertificate2_get_Template(self: *const T, ppTemplate: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCertificate2.VTable, self.vtable).get_Template(@ptrCast(*const IX509CertificateRequestCertificate2, self), ppTemplate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509CertificateRequestPkcs7_Value = @import("../zig.zig").Guid.initString("728ab344-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestPkcs7 = &IID_IX509CertificateRequestPkcs7_Value;
pub const IX509CertificateRequestPkcs7 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequest.VTable,
        InitializeFromTemplateName: fn(
            self: *const IX509CertificateRequestPkcs7,
            Context: X509CertificateEnrollmentContext,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromCertificate: fn(
            self: *const IX509CertificateRequestPkcs7,
            Context: X509CertificateEnrollmentContext,
            RenewalRequest: i16,
            strCertificate: BSTR,
            Encoding: EncodingType,
            InheritOptions: X509RequestInheritOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromInnerRequest: fn(
            self: *const IX509CertificateRequestPkcs7,
            pInnerRequest: ?*IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509CertificateRequestPkcs7,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequesterName: fn(
            self: *const IX509CertificateRequestPkcs7,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequesterName: fn(
            self: *const IX509CertificateRequestPkcs7,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignerCertificate: fn(
            self: *const IX509CertificateRequestPkcs7,
            ppValue: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignerCertificate: fn(
            self: *const IX509CertificateRequestPkcs7,
            pValue: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_InitializeFromTemplateName(self: *const T, Context: X509CertificateEnrollmentContext, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).InitializeFromTemplateName(@ptrCast(*const IX509CertificateRequestPkcs7, self), Context, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_InitializeFromCertificate(self: *const T, Context: X509CertificateEnrollmentContext, RenewalRequest: i16, strCertificate: BSTR, Encoding: EncodingType, InheritOptions: X509RequestInheritOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).InitializeFromCertificate(@ptrCast(*const IX509CertificateRequestPkcs7, self), Context, RenewalRequest, strCertificate, Encoding, InheritOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_InitializeFromInnerRequest(self: *const T, pInnerRequest: ?*IX509CertificateRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).InitializeFromInnerRequest(@ptrCast(*const IX509CertificateRequestPkcs7, self), pInnerRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_InitializeDecode(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509CertificateRequestPkcs7, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_get_RequesterName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).get_RequesterName(@ptrCast(*const IX509CertificateRequestPkcs7, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_put_RequesterName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).put_RequesterName(@ptrCast(*const IX509CertificateRequestPkcs7, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_get_SignerCertificate(self: *const T, ppValue: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).get_SignerCertificate(@ptrCast(*const IX509CertificateRequestPkcs7, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7_put_SignerCertificate(self: *const T, pValue: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7.VTable, self.vtable).put_SignerCertificate(@ptrCast(*const IX509CertificateRequestPkcs7, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateRequestPkcs7V2_Value = @import("../zig.zig").Guid.initString("728ab35c-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestPkcs7V2 = &IID_IX509CertificateRequestPkcs7V2_Value;
pub const IX509CertificateRequestPkcs7V2 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs7.VTable,
        InitializeFromTemplate: fn(
            self: *const IX509CertificateRequestPkcs7V2,
            context: X509CertificateEnrollmentContext,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyServer: fn(
            self: *const IX509CertificateRequestPkcs7V2,
            ppPolicyServer: ?*?*IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509CertificateRequestPkcs7V2,
            ppTemplate: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCertificateSignature: fn(
            self: *const IX509CertificateRequestPkcs7V2,
            ValidateCertificateChain: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7V2_InitializeFromTemplate(self: *const T, context: X509CertificateEnrollmentContext, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7V2.VTable, self.vtable).InitializeFromTemplate(@ptrCast(*const IX509CertificateRequestPkcs7V2, self), context, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7V2_get_PolicyServer(self: *const T, ppPolicyServer: ?*?*IX509EnrollmentPolicyServer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7V2.VTable, self.vtable).get_PolicyServer(@ptrCast(*const IX509CertificateRequestPkcs7V2, self), ppPolicyServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7V2_get_Template(self: *const T, ppTemplate: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7V2.VTable, self.vtable).get_Template(@ptrCast(*const IX509CertificateRequestPkcs7V2, self), ppTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestPkcs7V2_CheckCertificateSignature(self: *const T, ValidateCertificateChain: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestPkcs7V2.VTable, self.vtable).CheckCertificateSignature(@ptrCast(*const IX509CertificateRequestPkcs7V2, self), ValidateCertificateChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509CertificateRequestCmc_Value = @import("../zig.zig").Guid.initString("728ab345-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestCmc = &IID_IX509CertificateRequestCmc_Value;
pub const IX509CertificateRequestCmc = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestPkcs7.VTable,
        InitializeFromInnerRequestTemplateName: fn(
            self: *const IX509CertificateRequestCmc,
            pInnerRequest: ?*IX509CertificateRequest,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateObjectId: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NullSigned: fn(
            self: *const IX509CertificateRequestCmc,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CryptAttributes: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*ICryptAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NameValuePairs: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IX509NameValuePairs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509Extensions: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CriticalExtensions: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressOids: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransactionId: fn(
            self: *const IX509CertificateRequestCmc,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransactionId: fn(
            self: *const IX509CertificateRequestCmc,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SenderNonce: fn(
            self: *const IX509CertificateRequestCmc,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SenderNonce: fn(
            self: *const IX509CertificateRequestCmc,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignatureInformation: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IX509SignatureInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ArchivePrivateKey: fn(
            self: *const IX509CertificateRequestCmc,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ArchivePrivateKey: fn(
            self: *const IX509CertificateRequestCmc,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyArchivalCertificate: fn(
            self: *const IX509CertificateRequestCmc,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyArchivalCertificate: fn(
            self: *const IX509CertificateRequestCmc,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionAlgorithm: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EncryptionAlgorithm: fn(
            self: *const IX509CertificateRequestCmc,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptionStrength: fn(
            self: *const IX509CertificateRequestCmc,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EncryptionStrength: fn(
            self: *const IX509CertificateRequestCmc,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EncryptedKeyHash: fn(
            self: *const IX509CertificateRequestCmc,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignerCertificates: fn(
            self: *const IX509CertificateRequestCmc,
            ppValue: ?*?*ISignerCertificates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestPkcs7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_InitializeFromInnerRequestTemplateName(self: *const T, pInnerRequest: ?*IX509CertificateRequest, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).InitializeFromInnerRequestTemplateName(@ptrCast(*const IX509CertificateRequestCmc, self), pInnerRequest, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_TemplateObjectId(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_TemplateObjectId(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_NullSigned(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_NullSigned(@ptrCast(*const IX509CertificateRequestCmc, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_CryptAttributes(self: *const T, ppValue: ?*?*ICryptAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_CryptAttributes(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_NameValuePairs(self: *const T, ppValue: ?*?*IX509NameValuePairs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_NameValuePairs(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_X509Extensions(self: *const T, ppValue: ?*?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_X509Extensions(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_CriticalExtensions(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_CriticalExtensions(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_SuppressOids(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_SuppressOids(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_TransactionId(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_TransactionId(@ptrCast(*const IX509CertificateRequestCmc, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_TransactionId(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_TransactionId(@ptrCast(*const IX509CertificateRequestCmc, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_SenderNonce(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_SenderNonce(@ptrCast(*const IX509CertificateRequestCmc, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_SenderNonce(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_SenderNonce(@ptrCast(*const IX509CertificateRequestCmc, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_SignatureInformation(self: *const T, ppValue: ?*?*IX509SignatureInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_SignatureInformation(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_ArchivePrivateKey(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_ArchivePrivateKey(@ptrCast(*const IX509CertificateRequestCmc, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_ArchivePrivateKey(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_ArchivePrivateKey(@ptrCast(*const IX509CertificateRequestCmc, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_KeyArchivalCertificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_KeyArchivalCertificate(@ptrCast(*const IX509CertificateRequestCmc, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_KeyArchivalCertificate(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_KeyArchivalCertificate(@ptrCast(*const IX509CertificateRequestCmc, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_EncryptionAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_EncryptionAlgorithm(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_EncryptionAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_EncryptionAlgorithm(@ptrCast(*const IX509CertificateRequestCmc, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_EncryptionStrength(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_EncryptionStrength(@ptrCast(*const IX509CertificateRequestCmc, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_put_EncryptionStrength(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).put_EncryptionStrength(@ptrCast(*const IX509CertificateRequestCmc, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_EncryptedKeyHash(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_EncryptedKeyHash(@ptrCast(*const IX509CertificateRequestCmc, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc_get_SignerCertificates(self: *const T, ppValue: ?*?*ISignerCertificates) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc.VTable, self.vtable).get_SignerCertificates(@ptrCast(*const IX509CertificateRequestCmc, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509CertificateRequestCmc2_Value = @import("../zig.zig").Guid.initString("728ab35d-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRequestCmc2 = &IID_IX509CertificateRequestCmc2_Value;
pub const IX509CertificateRequestCmc2 = extern struct {
    pub const VTable = extern struct {
        base: IX509CertificateRequestCmc.VTable,
        InitializeFromTemplate: fn(
            self: *const IX509CertificateRequestCmc2,
            context: X509CertificateEnrollmentContext,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromInnerRequestTemplate: fn(
            self: *const IX509CertificateRequestCmc2,
            pInnerRequest: ?*IX509CertificateRequest,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyServer: fn(
            self: *const IX509CertificateRequestCmc2,
            ppPolicyServer: ?*?*IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509CertificateRequestCmc2,
            ppTemplate: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckSignature: fn(
            self: *const IX509CertificateRequestCmc2,
            AllowedSignatureTypes: Pkcs10AllowedSignatureTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCertificateSignature: fn(
            self: *const IX509CertificateRequestCmc2,
            pSignerCertificate: ?*ISignerCertificate,
            ValidateCertificateChain: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509CertificateRequestCmc.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_InitializeFromTemplate(self: *const T, context: X509CertificateEnrollmentContext, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).InitializeFromTemplate(@ptrCast(*const IX509CertificateRequestCmc2, self), context, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_InitializeFromInnerRequestTemplate(self: *const T, pInnerRequest: ?*IX509CertificateRequest, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).InitializeFromInnerRequestTemplate(@ptrCast(*const IX509CertificateRequestCmc2, self), pInnerRequest, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_get_PolicyServer(self: *const T, ppPolicyServer: ?*?*IX509EnrollmentPolicyServer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).get_PolicyServer(@ptrCast(*const IX509CertificateRequestCmc2, self), ppPolicyServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_get_Template(self: *const T, ppTemplate: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).get_Template(@ptrCast(*const IX509CertificateRequestCmc2, self), ppTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_CheckSignature(self: *const T, AllowedSignatureTypes: Pkcs10AllowedSignatureTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).CheckSignature(@ptrCast(*const IX509CertificateRequestCmc2, self), AllowedSignatureTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRequestCmc2_CheckCertificateSignature(self: *const T, pSignerCertificate: ?*ISignerCertificate, ValidateCertificateChain: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRequestCmc2.VTable, self.vtable).CheckCertificateSignature(@ptrCast(*const IX509CertificateRequestCmc2, self), pSignerCertificate, ValidateCertificateChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const InstallResponseRestrictionFlags = extern enum(i32) {
    None = 0,
    NoOutstandingRequest = 1,
    UntrustedCertificate = 2,
    UntrustedRoot = 4,
};
pub const AllowNone = InstallResponseRestrictionFlags.None;
pub const AllowNoOutstandingRequest = InstallResponseRestrictionFlags.NoOutstandingRequest;
pub const AllowUntrustedCertificate = InstallResponseRestrictionFlags.UntrustedCertificate;
pub const AllowUntrustedRoot = InstallResponseRestrictionFlags.UntrustedRoot;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509Enrollment_Value = @import("../zig.zig").Guid.initString("728ab346-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Enrollment = &IID_IX509Enrollment_Value;
pub const IX509Enrollment = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509Enrollment,
            Context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromTemplateName: fn(
            self: *const IX509Enrollment,
            Context: X509CertificateEnrollmentContext,
            strTemplateName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromRequest: fn(
            self: *const IX509Enrollment,
            pRequest: ?*IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRequest: fn(
            self: *const IX509Enrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enroll: fn(
            self: *const IX509Enrollment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallResponse: fn(
            self: *const IX509Enrollment,
            Restrictions: InstallResponseRestrictionFlags,
            strResponse: BSTR,
            Encoding: EncodingType,
            strPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePFX: fn(
            self: *const IX509Enrollment,
            strPassword: BSTR,
            ExportOptions: PFXExportOptions,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Request: fn(
            self: *const IX509Enrollment,
            pValue: ?*?*IX509CertificateRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IX509Enrollment,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IX509Enrollment,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentWindow: fn(
            self: *const IX509Enrollment,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentWindow: fn(
            self: *const IX509Enrollment,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NameValuePairs: fn(
            self: *const IX509Enrollment,
            ppValue: ?*?*IX509NameValuePairs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnrollmentContext: fn(
            self: *const IX509Enrollment,
            pValue: *X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IX509Enrollment,
            ppValue: ?*?*IX509EnrollmentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Certificate: fn(
            self: *const IX509Enrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Response: fn(
            self: *const IX509Enrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateFriendlyName: fn(
            self: *const IX509Enrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateFriendlyName: fn(
            self: *const IX509Enrollment,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateDescription: fn(
            self: *const IX509Enrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateDescription: fn(
            self: *const IX509Enrollment,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestId: fn(
            self: *const IX509Enrollment,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAConfigString: fn(
            self: *const IX509Enrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_Initialize(self: *const T, Context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).Initialize(@ptrCast(*const IX509Enrollment, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_InitializeFromTemplateName(self: *const T, Context: X509CertificateEnrollmentContext, strTemplateName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).InitializeFromTemplateName(@ptrCast(*const IX509Enrollment, self), Context, strTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_InitializeFromRequest(self: *const T, pRequest: ?*IX509CertificateRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).InitializeFromRequest(@ptrCast(*const IX509Enrollment, self), pRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_CreateRequest(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).CreateRequest(@ptrCast(*const IX509Enrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_Enroll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).Enroll(@ptrCast(*const IX509Enrollment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_InstallResponse(self: *const T, Restrictions: InstallResponseRestrictionFlags, strResponse: BSTR, Encoding: EncodingType, strPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).InstallResponse(@ptrCast(*const IX509Enrollment, self), Restrictions, strResponse, Encoding, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_CreatePFX(self: *const T, strPassword: BSTR, ExportOptions: PFXExportOptions, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).CreatePFX(@ptrCast(*const IX509Enrollment, self), strPassword, ExportOptions, Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_Request(self: *const T, pValue: ?*?*IX509CertificateRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_Request(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_Silent(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_Silent(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_put_Silent(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).put_Silent(@ptrCast(*const IX509Enrollment, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_ParentWindow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_ParentWindow(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_put_ParentWindow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).put_ParentWindow(@ptrCast(*const IX509Enrollment, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_NameValuePairs(self: *const T, ppValue: ?*?*IX509NameValuePairs) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_NameValuePairs(@ptrCast(*const IX509Enrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_EnrollmentContext(self: *const T, pValue: *X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_EnrollmentContext(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_Status(self: *const T, ppValue: ?*?*IX509EnrollmentStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_Status(@ptrCast(*const IX509Enrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_Certificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_Certificate(@ptrCast(*const IX509Enrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_Response(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_Response(@ptrCast(*const IX509Enrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_CertificateFriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_CertificateFriendlyName(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_put_CertificateFriendlyName(self: *const T, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).put_CertificateFriendlyName(@ptrCast(*const IX509Enrollment, self), strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_CertificateDescription(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_CertificateDescription(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_put_CertificateDescription(self: *const T, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).put_CertificateDescription(@ptrCast(*const IX509Enrollment, self), strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_RequestId(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_RequestId(@ptrCast(*const IX509Enrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment_get_CAConfigString(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment.VTable, self.vtable).get_CAConfigString(@ptrCast(*const IX509Enrollment, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509Enrollment2_Value = @import("../zig.zig").Guid.initString("728ab350-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509Enrollment2 = &IID_IX509Enrollment2_Value;
pub const IX509Enrollment2 = extern struct {
    pub const VTable = extern struct {
        base: IX509Enrollment.VTable,
        InitializeFromTemplate: fn(
            self: *const IX509Enrollment2,
            context: X509CertificateEnrollmentContext,
            pPolicyServer: ?*IX509EnrollmentPolicyServer,
            pTemplate: ?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallResponse2: fn(
            self: *const IX509Enrollment2,
            Restrictions: InstallResponseRestrictionFlags,
            strResponse: BSTR,
            Encoding: EncodingType,
            strPassword: BSTR,
            strEnrollmentPolicyServerUrl: BSTR,
            strEnrollmentPolicyServerID: BSTR,
            EnrollmentPolicyServerFlags: PolicyServerUrlFlags,
            authFlags: X509EnrollmentAuthFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PolicyServer: fn(
            self: *const IX509Enrollment2,
            ppPolicyServer: ?*?*IX509EnrollmentPolicyServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Template: fn(
            self: *const IX509Enrollment2,
            ppTemplate: ?*?*IX509CertificateTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestIdString: fn(
            self: *const IX509Enrollment2,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509Enrollment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment2_InitializeFromTemplate(self: *const T, context: X509CertificateEnrollmentContext, pPolicyServer: ?*IX509EnrollmentPolicyServer, pTemplate: ?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment2.VTable, self.vtable).InitializeFromTemplate(@ptrCast(*const IX509Enrollment2, self), context, pPolicyServer, pTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment2_InstallResponse2(self: *const T, Restrictions: InstallResponseRestrictionFlags, strResponse: BSTR, Encoding: EncodingType, strPassword: BSTR, strEnrollmentPolicyServerUrl: BSTR, strEnrollmentPolicyServerID: BSTR, EnrollmentPolicyServerFlags: PolicyServerUrlFlags, authFlags: X509EnrollmentAuthFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment2.VTable, self.vtable).InstallResponse2(@ptrCast(*const IX509Enrollment2, self), Restrictions, strResponse, Encoding, strPassword, strEnrollmentPolicyServerUrl, strEnrollmentPolicyServerID, EnrollmentPolicyServerFlags, authFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment2_get_PolicyServer(self: *const T, ppPolicyServer: ?*?*IX509EnrollmentPolicyServer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment2.VTable, self.vtable).get_PolicyServer(@ptrCast(*const IX509Enrollment2, self), ppPolicyServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment2_get_Template(self: *const T, ppTemplate: ?*?*IX509CertificateTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment2.VTable, self.vtable).get_Template(@ptrCast(*const IX509Enrollment2, self), ppTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509Enrollment2_get_RequestIdString(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509Enrollment2.VTable, self.vtable).get_RequestIdString(@ptrCast(*const IX509Enrollment2, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WebEnrollmentFlags = extern enum(i32) {
    t = 1,
};
pub const EnrollPrompt = WebEnrollmentFlags.t;

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509EnrollmentHelper_Value = @import("../zig.zig").Guid.initString("728ab351-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509EnrollmentHelper = &IID_IX509EnrollmentHelper_Value;
pub const IX509EnrollmentHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddPolicyServer: fn(
            self: *const IX509EnrollmentHelper,
            strEnrollmentPolicyServerURI: BSTR,
            strEnrollmentPolicyID: BSTR,
            EnrollmentPolicyServerFlags: PolicyServerUrlFlags,
            authFlags: X509EnrollmentAuthFlags,
            strCredential: BSTR,
            strPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEnrollmentServer: fn(
            self: *const IX509EnrollmentHelper,
            strEnrollmentServerURI: BSTR,
            authFlags: X509EnrollmentAuthFlags,
            strCredential: BSTR,
            strPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enroll: fn(
            self: *const IX509EnrollmentHelper,
            strEnrollmentPolicyServerURI: BSTR,
            strTemplateName: BSTR,
            Encoding: EncodingType,
            enrollFlags: WebEnrollmentFlags,
            pstrCertificate: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IX509EnrollmentHelper,
            Context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentHelper_AddPolicyServer(self: *const T, strEnrollmentPolicyServerURI: BSTR, strEnrollmentPolicyID: BSTR, EnrollmentPolicyServerFlags: PolicyServerUrlFlags, authFlags: X509EnrollmentAuthFlags, strCredential: BSTR, strPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentHelper.VTable, self.vtable).AddPolicyServer(@ptrCast(*const IX509EnrollmentHelper, self), strEnrollmentPolicyServerURI, strEnrollmentPolicyID, EnrollmentPolicyServerFlags, authFlags, strCredential, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentHelper_AddEnrollmentServer(self: *const T, strEnrollmentServerURI: BSTR, authFlags: X509EnrollmentAuthFlags, strCredential: BSTR, strPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentHelper.VTable, self.vtable).AddEnrollmentServer(@ptrCast(*const IX509EnrollmentHelper, self), strEnrollmentServerURI, authFlags, strCredential, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentHelper_Enroll(self: *const T, strEnrollmentPolicyServerURI: BSTR, strTemplateName: BSTR, Encoding: EncodingType, enrollFlags: WebEnrollmentFlags, pstrCertificate: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentHelper.VTable, self.vtable).Enroll(@ptrCast(*const IX509EnrollmentHelper, self), strEnrollmentPolicyServerURI, strTemplateName, Encoding, enrollFlags, pstrCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentHelper_Initialize(self: *const T, Context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentHelper.VTable, self.vtable).Initialize(@ptrCast(*const IX509EnrollmentHelper, self), Context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IX509EnrollmentWebClassFactory_Value = @import("../zig.zig").Guid.initString("728ab349-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509EnrollmentWebClassFactory = &IID_IX509EnrollmentWebClassFactory_Value;
pub const IX509EnrollmentWebClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateObject: fn(
            self: *const IX509EnrollmentWebClassFactory,
            strProgID: BSTR,
            ppIUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509EnrollmentWebClassFactory_CreateObject(self: *const T, strProgID: BSTR, ppIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509EnrollmentWebClassFactory.VTable, self.vtable).CreateObject(@ptrCast(*const IX509EnrollmentWebClassFactory, self), strProgID, ppIUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IX509MachineEnrollmentFactory_Value = @import("../zig.zig").Guid.initString("728ab352-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509MachineEnrollmentFactory = &IID_IX509MachineEnrollmentFactory_Value;
pub const IX509MachineEnrollmentFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateObject: fn(
            self: *const IX509MachineEnrollmentFactory,
            strProgID: BSTR,
            ppIHelper: ?*?*IX509EnrollmentHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509MachineEnrollmentFactory_CreateObject(self: *const T, strProgID: BSTR, ppIHelper: ?*?*IX509EnrollmentHelper) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509MachineEnrollmentFactory.VTable, self.vtable).CreateObject(@ptrCast(*const IX509MachineEnrollmentFactory, self), strProgID, ppIHelper);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CRLRevocationReason = extern enum(i32) {
    UNSPECIFIED = 0,
    KEY_COMPROMISE = 1,
    CA_COMPROMISE = 2,
    AFFILIATION_CHANGED = 3,
    SUPERSEDED = 4,
    CESSATION_OF_OPERATION = 5,
    CERTIFICATE_HOLD = 6,
    REMOVE_FROM_CRL = 8,
    PRIVILEGE_WITHDRAWN = 9,
    AA_COMPROMISE = 10,
};
pub const XCN_CRL_REASON_UNSPECIFIED = CRLRevocationReason.UNSPECIFIED;
pub const XCN_CRL_REASON_KEY_COMPROMISE = CRLRevocationReason.KEY_COMPROMISE;
pub const XCN_CRL_REASON_CA_COMPROMISE = CRLRevocationReason.CA_COMPROMISE;
pub const XCN_CRL_REASON_AFFILIATION_CHANGED = CRLRevocationReason.AFFILIATION_CHANGED;
pub const XCN_CRL_REASON_SUPERSEDED = CRLRevocationReason.SUPERSEDED;
pub const XCN_CRL_REASON_CESSATION_OF_OPERATION = CRLRevocationReason.CESSATION_OF_OPERATION;
pub const XCN_CRL_REASON_CERTIFICATE_HOLD = CRLRevocationReason.CERTIFICATE_HOLD;
pub const XCN_CRL_REASON_REMOVE_FROM_CRL = CRLRevocationReason.REMOVE_FROM_CRL;
pub const XCN_CRL_REASON_PRIVILEGE_WITHDRAWN = CRLRevocationReason.PRIVILEGE_WITHDRAWN;
pub const XCN_CRL_REASON_AA_COMPROMISE = CRLRevocationReason.AA_COMPROMISE;

const IID_IX509CertificateRevocationListEntry_Value = @import("../zig.zig").Guid.initString("728ab35e-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRevocationListEntry = &IID_IX509CertificateRevocationListEntry_Value;
pub const IX509CertificateRevocationListEntry = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509CertificateRevocationListEntry,
            Encoding: EncodingType,
            SerialNumber: BSTR,
            RevocationDate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SerialNumber: fn(
            self: *const IX509CertificateRevocationListEntry,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RevocationDate: fn(
            self: *const IX509CertificateRevocationListEntry,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RevocationReason: fn(
            self: *const IX509CertificateRevocationListEntry,
            pValue: *CRLRevocationReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RevocationReason: fn(
            self: *const IX509CertificateRevocationListEntry,
            Value: CRLRevocationReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509Extensions: fn(
            self: *const IX509CertificateRevocationListEntry,
            ppValue: ?*?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CriticalExtensions: fn(
            self: *const IX509CertificateRevocationListEntry,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_Initialize(self: *const T, Encoding: EncodingType, SerialNumber: BSTR, RevocationDate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).Initialize(@ptrCast(*const IX509CertificateRevocationListEntry, self), Encoding, SerialNumber, RevocationDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_get_SerialNumber(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).get_SerialNumber(@ptrCast(*const IX509CertificateRevocationListEntry, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_get_RevocationDate(self: *const T, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).get_RevocationDate(@ptrCast(*const IX509CertificateRevocationListEntry, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_get_RevocationReason(self: *const T, pValue: *CRLRevocationReason) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).get_RevocationReason(@ptrCast(*const IX509CertificateRevocationListEntry, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_put_RevocationReason(self: *const T, Value: CRLRevocationReason) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).put_RevocationReason(@ptrCast(*const IX509CertificateRevocationListEntry, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_get_X509Extensions(self: *const T, ppValue: ?*?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).get_X509Extensions(@ptrCast(*const IX509CertificateRevocationListEntry, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntry_get_CriticalExtensions(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntry.VTable, self.vtable).get_CriticalExtensions(@ptrCast(*const IX509CertificateRevocationListEntry, self), ppValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509CertificateRevocationListEntries_Value = @import("../zig.zig").Guid.initString("728ab35f-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRevocationListEntries = &IID_IX509CertificateRevocationListEntries_Value;
pub const IX509CertificateRevocationListEntries = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByIndex: fn(
            self: *const IX509CertificateRevocationListEntries,
            Index: i32,
            pVal: ?*?*IX509CertificateRevocationListEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IX509CertificateRevocationListEntries,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IX509CertificateRevocationListEntries,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IX509CertificateRevocationListEntries,
            pVal: ?*IX509CertificateRevocationListEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IX509CertificateRevocationListEntries,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IX509CertificateRevocationListEntries,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IndexBySerialNumber: fn(
            self: *const IX509CertificateRevocationListEntries,
            Encoding: EncodingType,
            SerialNumber: BSTR,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IX509CertificateRevocationListEntries,
            pValue: ?*IX509CertificateRevocationListEntries,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_get_ItemByIndex(self: *const T, Index: i32, pVal: ?*?*IX509CertificateRevocationListEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).get_ItemByIndex(@ptrCast(*const IX509CertificateRevocationListEntries, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).get_Count(@ptrCast(*const IX509CertificateRevocationListEntries, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).get__NewEnum(@ptrCast(*const IX509CertificateRevocationListEntries, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_Add(self: *const T, pVal: ?*IX509CertificateRevocationListEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).Add(@ptrCast(*const IX509CertificateRevocationListEntries, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_Remove(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).Remove(@ptrCast(*const IX509CertificateRevocationListEntries, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).Clear(@ptrCast(*const IX509CertificateRevocationListEntries, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_get_IndexBySerialNumber(self: *const T, Encoding: EncodingType, SerialNumber: BSTR, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).get_IndexBySerialNumber(@ptrCast(*const IX509CertificateRevocationListEntries, self), Encoding, SerialNumber, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationListEntries_AddRange(self: *const T, pValue: ?*IX509CertificateRevocationListEntries) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationListEntries.VTable, self.vtable).AddRange(@ptrCast(*const IX509CertificateRevocationListEntries, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509CertificateRevocationList_Value = @import("../zig.zig").Guid.initString("728ab360-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509CertificateRevocationList = &IID_IX509CertificateRevocationList_Value;
pub const IX509CertificateRevocationList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509CertificateRevocationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDecode: fn(
            self: *const IX509CertificateRevocationList,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const IX509CertificateRevocationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetForEncode: fn(
            self: *const IX509CertificateRevocationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckPublicKeySignature: fn(
            self: *const IX509CertificateRevocationList,
            pPublicKey: ?*IX509PublicKey,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckSignature: fn(
            self: *const IX509CertificateRevocationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Issuer: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Issuer: fn(
            self: *const IX509CertificateRevocationList,
            pValue: ?*IX500DistinguishedName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ThisUpdate: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ThisUpdate: fn(
            self: *const IX509CertificateRevocationList,
            Value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextUpdate: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NextUpdate: fn(
            self: *const IX509CertificateRevocationList,
            Value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509CRLEntries: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IX509CertificateRevocationListEntries,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509Extensions: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IX509Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CriticalExtensions: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IObjectIds,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignerCertificate: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignerCertificate: fn(
            self: *const IX509CertificateRevocationList,
            pValue: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CRLNumber: fn(
            self: *const IX509CertificateRevocationList,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CRLNumber: fn(
            self: *const IX509CertificateRevocationList,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAVersion: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAVersion: fn(
            self: *const IX509CertificateRevocationList,
            pValue: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseCRL: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NullSigned: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const IX509CertificateRevocationList,
            pValue: ?*IObjectId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlternateSignatureAlgorithm: fn(
            self: *const IX509CertificateRevocationList,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlternateSignatureAlgorithm: fn(
            self: *const IX509CertificateRevocationList,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignatureInformation: fn(
            self: *const IX509CertificateRevocationList,
            ppValue: ?*?*IX509SignatureInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawData: fn(
            self: *const IX509CertificateRevocationList,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RawDataToBeSigned: fn(
            self: *const IX509CertificateRevocationList,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Signature: fn(
            self: *const IX509CertificateRevocationList,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_Initialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).Initialize(@ptrCast(*const IX509CertificateRevocationList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_InitializeDecode(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).InitializeDecode(@ptrCast(*const IX509CertificateRevocationList, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_Encode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).Encode(@ptrCast(*const IX509CertificateRevocationList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_ResetForEncode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).ResetForEncode(@ptrCast(*const IX509CertificateRevocationList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_CheckPublicKeySignature(self: *const T, pPublicKey: ?*IX509PublicKey) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).CheckPublicKeySignature(@ptrCast(*const IX509CertificateRevocationList, self), pPublicKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_CheckSignature(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).CheckSignature(@ptrCast(*const IX509CertificateRevocationList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_Issuer(self: *const T, ppValue: ?*?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_Issuer(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_Issuer(self: *const T, pValue: ?*IX500DistinguishedName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_Issuer(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_ThisUpdate(self: *const T, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_ThisUpdate(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_ThisUpdate(self: *const T, Value: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_ThisUpdate(@ptrCast(*const IX509CertificateRevocationList, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_NextUpdate(self: *const T, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_NextUpdate(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_NextUpdate(self: *const T, Value: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_NextUpdate(@ptrCast(*const IX509CertificateRevocationList, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_X509CRLEntries(self: *const T, ppValue: ?*?*IX509CertificateRevocationListEntries) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_X509CRLEntries(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_X509Extensions(self: *const T, ppValue: ?*?*IX509Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_X509Extensions(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_CriticalExtensions(self: *const T, ppValue: ?*?*IObjectIds) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_CriticalExtensions(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_SignerCertificate(self: *const T, ppValue: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_SignerCertificate(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_SignerCertificate(self: *const T, pValue: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_SignerCertificate(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_CRLNumber(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_CRLNumber(@ptrCast(*const IX509CertificateRevocationList, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_CRLNumber(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_CRLNumber(@ptrCast(*const IX509CertificateRevocationList, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_CAVersion(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_CAVersion(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_CAVersion(self: *const T, pValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_CAVersion(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_BaseCRL(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_BaseCRL(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_NullSigned(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_NullSigned(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_HashAlgorithm(self: *const T, ppValue: ?*?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_HashAlgorithm(self: *const T, pValue: ?*IObjectId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_AlternateSignatureAlgorithm(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_AlternateSignatureAlgorithm(@ptrCast(*const IX509CertificateRevocationList, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_put_AlternateSignatureAlgorithm(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).put_AlternateSignatureAlgorithm(@ptrCast(*const IX509CertificateRevocationList, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_SignatureInformation(self: *const T, ppValue: ?*?*IX509SignatureInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_SignatureInformation(@ptrCast(*const IX509CertificateRevocationList, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_RawData(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_RawData(@ptrCast(*const IX509CertificateRevocationList, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_RawDataToBeSigned(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_RawDataToBeSigned(@ptrCast(*const IX509CertificateRevocationList, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509CertificateRevocationList_get_Signature(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509CertificateRevocationList.VTable, self.vtable).get_Signature(@ptrCast(*const IX509CertificateRevocationList, self), Encoding, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertificateAttestationChallenge_Value = @import("../zig.zig").Guid.initString("6f175a7c-4a3a-40ae-9dba-592fd6bbf9b8");
pub const IID_ICertificateAttestationChallenge = &IID_ICertificateAttestationChallenge_Value;
pub const ICertificateAttestationChallenge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ICertificateAttestationChallenge,
            Encoding: EncodingType,
            strPendingFullCmcResponseWithChallenge: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptChallenge: fn(
            self: *const ICertificateAttestationChallenge,
            Encoding: EncodingType,
            pstrEnvelopedPkcs7ReencryptedToCA: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestID: fn(
            self: *const ICertificateAttestationChallenge,
            pstrRequestID: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateAttestationChallenge_Initialize(self: *const T, Encoding: EncodingType, strPendingFullCmcResponseWithChallenge: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateAttestationChallenge.VTable, self.vtable).Initialize(@ptrCast(*const ICertificateAttestationChallenge, self), Encoding, strPendingFullCmcResponseWithChallenge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateAttestationChallenge_DecryptChallenge(self: *const T, Encoding: EncodingType, pstrEnvelopedPkcs7ReencryptedToCA: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateAttestationChallenge.VTable, self.vtable).DecryptChallenge(@ptrCast(*const ICertificateAttestationChallenge, self), Encoding, pstrEnvelopedPkcs7ReencryptedToCA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateAttestationChallenge_get_RequestID(self: *const T, pstrRequestID: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateAttestationChallenge.VTable, self.vtable).get_RequestID(@ptrCast(*const ICertificateAttestationChallenge, self), pstrRequestID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertificateAttestationChallenge2_Value = @import("../zig.zig").Guid.initString("4631334d-e266-47d6-bd79-be53cb2e2753");
pub const IID_ICertificateAttestationChallenge2 = &IID_ICertificateAttestationChallenge2_Value;
pub const ICertificateAttestationChallenge2 = extern struct {
    pub const VTable = extern struct {
        base: ICertificateAttestationChallenge.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyContainerName: fn(
            self: *const ICertificateAttestationChallenge2,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyBlob: fn(
            self: *const ICertificateAttestationChallenge2,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertificateAttestationChallenge.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateAttestationChallenge2_put_KeyContainerName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateAttestationChallenge2.VTable, self.vtable).put_KeyContainerName(@ptrCast(*const ICertificateAttestationChallenge2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateAttestationChallenge2_put_KeyBlob(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateAttestationChallenge2.VTable, self.vtable).put_KeyBlob(@ptrCast(*const ICertificateAttestationChallenge2, self), Encoding, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509SCEPEnrollment_Value = @import("../zig.zig").Guid.initString("728ab361-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509SCEPEnrollment = &IID_IX509SCEPEnrollment_Value;
pub const IX509SCEPEnrollment = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509SCEPEnrollment,
            pRequest: ?*IX509CertificateRequestPkcs10,
            strThumbprint: BSTR,
            ThumprintEncoding: EncodingType,
            strServerCertificates: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeForPending: fn(
            self: *const IX509SCEPEnrollment,
            Context: X509CertificateEnrollmentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRequestMessage: fn(
            self: *const IX509SCEPEnrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRetrievePendingMessage: fn(
            self: *const IX509SCEPEnrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRetrieveCertificateMessage: fn(
            self: *const IX509SCEPEnrollment,
            Context: X509CertificateEnrollmentContext,
            strIssuer: BSTR,
            IssuerEncoding: EncodingType,
            strSerialNumber: BSTR,
            SerialNumberEncoding: EncodingType,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessResponseMessage: fn(
            self: *const IX509SCEPEnrollment,
            strResponse: BSTR,
            Encoding: EncodingType,
            pDisposition: *X509SCEPDisposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ServerCapabilities: fn(
            self: *const IX509SCEPEnrollment,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FailInfo: fn(
            self: *const IX509SCEPEnrollment,
            pValue: *X509SCEPFailInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignerCertificate: fn(
            self: *const IX509SCEPEnrollment,
            ppValue: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignerCertificate: fn(
            self: *const IX509SCEPEnrollment,
            pValue: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OldCertificate: fn(
            self: *const IX509SCEPEnrollment,
            ppValue: ?*?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OldCertificate: fn(
            self: *const IX509SCEPEnrollment,
            pValue: ?*ISignerCertificate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransactionId: fn(
            self: *const IX509SCEPEnrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransactionId: fn(
            self: *const IX509SCEPEnrollment,
            Encoding: EncodingType,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Request: fn(
            self: *const IX509SCEPEnrollment,
            ppValue: ?*?*IX509CertificateRequestPkcs10,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateFriendlyName: fn(
            self: *const IX509SCEPEnrollment,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateFriendlyName: fn(
            self: *const IX509SCEPEnrollment,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IX509SCEPEnrollment,
            ppValue: ?*?*IX509EnrollmentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Certificate: fn(
            self: *const IX509SCEPEnrollment,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IX509SCEPEnrollment,
            pValue: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IX509SCEPEnrollment,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRequest: fn(
            self: *const IX509SCEPEnrollment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_Initialize(self: *const T, pRequest: ?*IX509CertificateRequestPkcs10, strThumbprint: BSTR, ThumprintEncoding: EncodingType, strServerCertificates: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).Initialize(@ptrCast(*const IX509SCEPEnrollment, self), pRequest, strThumbprint, ThumprintEncoding, strServerCertificates, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_InitializeForPending(self: *const T, Context: X509CertificateEnrollmentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).InitializeForPending(@ptrCast(*const IX509SCEPEnrollment, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_CreateRequestMessage(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).CreateRequestMessage(@ptrCast(*const IX509SCEPEnrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_CreateRetrievePendingMessage(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).CreateRetrievePendingMessage(@ptrCast(*const IX509SCEPEnrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_CreateRetrieveCertificateMessage(self: *const T, Context: X509CertificateEnrollmentContext, strIssuer: BSTR, IssuerEncoding: EncodingType, strSerialNumber: BSTR, SerialNumberEncoding: EncodingType, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).CreateRetrieveCertificateMessage(@ptrCast(*const IX509SCEPEnrollment, self), Context, strIssuer, IssuerEncoding, strSerialNumber, SerialNumberEncoding, Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_ProcessResponseMessage(self: *const T, strResponse: BSTR, Encoding: EncodingType, pDisposition: *X509SCEPDisposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).ProcessResponseMessage(@ptrCast(*const IX509SCEPEnrollment, self), strResponse, Encoding, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_ServerCapabilities(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_ServerCapabilities(@ptrCast(*const IX509SCEPEnrollment, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_FailInfo(self: *const T, pValue: *X509SCEPFailInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_FailInfo(@ptrCast(*const IX509SCEPEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_SignerCertificate(self: *const T, ppValue: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_SignerCertificate(@ptrCast(*const IX509SCEPEnrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_SignerCertificate(self: *const T, pValue: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_SignerCertificate(@ptrCast(*const IX509SCEPEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_OldCertificate(self: *const T, ppValue: ?*?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_OldCertificate(@ptrCast(*const IX509SCEPEnrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_OldCertificate(self: *const T, pValue: ?*ISignerCertificate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_OldCertificate(@ptrCast(*const IX509SCEPEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_TransactionId(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_TransactionId(@ptrCast(*const IX509SCEPEnrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_TransactionId(self: *const T, Encoding: EncodingType, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_TransactionId(@ptrCast(*const IX509SCEPEnrollment, self), Encoding, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_Request(self: *const T, ppValue: ?*?*IX509CertificateRequestPkcs10) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_Request(@ptrCast(*const IX509SCEPEnrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_CertificateFriendlyName(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_CertificateFriendlyName(@ptrCast(*const IX509SCEPEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_CertificateFriendlyName(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_CertificateFriendlyName(@ptrCast(*const IX509SCEPEnrollment, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_Status(self: *const T, ppValue: ?*?*IX509EnrollmentStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_Status(@ptrCast(*const IX509SCEPEnrollment, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_Certificate(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_Certificate(@ptrCast(*const IX509SCEPEnrollment, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_get_Silent(self: *const T, pValue: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).get_Silent(@ptrCast(*const IX509SCEPEnrollment, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_put_Silent(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).put_Silent(@ptrCast(*const IX509SCEPEnrollment, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment_DeleteRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment.VTable, self.vtable).DeleteRequest(@ptrCast(*const IX509SCEPEnrollment, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509SCEPProcessMessageFlags = extern enum(i32) {
    Default = 0,
    SkipCertInstall = 1,
};
pub const SCEPProcessDefault = X509SCEPProcessMessageFlags.Default;
pub const SCEPProcessSkipCertInstall = X509SCEPProcessMessageFlags.SkipCertInstall;

pub const DelayRetryAction = extern enum(i32) {
    Unknown = 0,
    None = 1,
    Short = 2,
    Long = 3,
    Success = 4,
    PastSuccess = 5,
};
pub const DelayRetryUnknown = DelayRetryAction.Unknown;
pub const DelayRetryNone = DelayRetryAction.None;
pub const DelayRetryShort = DelayRetryAction.Short;
pub const DelayRetryLong = DelayRetryAction.Long;
pub const DelayRetrySuccess = DelayRetryAction.Success;
pub const DelayRetryPastSuccess = DelayRetryAction.PastSuccess;

const IID_IX509SCEPEnrollment2_Value = @import("../zig.zig").Guid.initString("728ab364-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509SCEPEnrollment2 = &IID_IX509SCEPEnrollment2_Value;
pub const IX509SCEPEnrollment2 = extern struct {
    pub const VTable = extern struct {
        base: IX509SCEPEnrollment.VTable,
        CreateChallengeAnswerMessage: fn(
            self: *const IX509SCEPEnrollment2,
            Encoding: EncodingType,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessResponseMessage2: fn(
            self: *const IX509SCEPEnrollment2,
            Flags: X509SCEPProcessMessageFlags,
            strResponse: BSTR,
            Encoding: EncodingType,
            pDisposition: *X509SCEPDisposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultMessageText: fn(
            self: *const IX509SCEPEnrollment2,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DelayRetry: fn(
            self: *const IX509SCEPEnrollment2,
            pValue: *DelayRetryAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActivityId: fn(
            self: *const IX509SCEPEnrollment2,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActivityId: fn(
            self: *const IX509SCEPEnrollment2,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IX509SCEPEnrollment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_CreateChallengeAnswerMessage(self: *const T, Encoding: EncodingType, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).CreateChallengeAnswerMessage(@ptrCast(*const IX509SCEPEnrollment2, self), Encoding, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_ProcessResponseMessage2(self: *const T, Flags: X509SCEPProcessMessageFlags, strResponse: BSTR, Encoding: EncodingType, pDisposition: *X509SCEPDisposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).ProcessResponseMessage2(@ptrCast(*const IX509SCEPEnrollment2, self), Flags, strResponse, Encoding, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_get_ResultMessageText(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).get_ResultMessageText(@ptrCast(*const IX509SCEPEnrollment2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_get_DelayRetry(self: *const T, pValue: *DelayRetryAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).get_DelayRetry(@ptrCast(*const IX509SCEPEnrollment2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_get_ActivityId(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).get_ActivityId(@ptrCast(*const IX509SCEPEnrollment2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollment2_put_ActivityId(self: *const T, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollment2.VTable, self.vtable).put_ActivityId(@ptrCast(*const IX509SCEPEnrollment2, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IX509SCEPEnrollmentHelper_Value = @import("../zig.zig").Guid.initString("728ab365-217d-11da-b2a4-000e7bbb2b09");
pub const IID_IX509SCEPEnrollmentHelper = &IID_IX509SCEPEnrollmentHelper_Value;
pub const IX509SCEPEnrollmentHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IX509SCEPEnrollmentHelper,
            strServerUrl: BSTR,
            strRequestHeaders: BSTR,
            pRequest: ?*IX509CertificateRequestPkcs10,
            strCACertificateThumbprint: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeForPending: fn(
            self: *const IX509SCEPEnrollmentHelper,
            strServerUrl: BSTR,
            strRequestHeaders: BSTR,
            Context: X509CertificateEnrollmentContext,
            strTransactionId: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enroll: fn(
            self: *const IX509SCEPEnrollmentHelper,
            ProcessFlags: X509SCEPProcessMessageFlags,
            pDisposition: *X509SCEPDisposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FetchPending: fn(
            self: *const IX509SCEPEnrollmentHelper,
            ProcessFlags: X509SCEPProcessMessageFlags,
            pDisposition: *X509SCEPDisposition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_X509SCEPEnrollment: fn(
            self: *const IX509SCEPEnrollmentHelper,
            ppValue: ?*?*IX509SCEPEnrollment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultMessageText: fn(
            self: *const IX509SCEPEnrollmentHelper,
            pValue: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_Initialize(self: *const T, strServerUrl: BSTR, strRequestHeaders: BSTR, pRequest: ?*IX509CertificateRequestPkcs10, strCACertificateThumbprint: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).Initialize(@ptrCast(*const IX509SCEPEnrollmentHelper, self), strServerUrl, strRequestHeaders, pRequest, strCACertificateThumbprint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_InitializeForPending(self: *const T, strServerUrl: BSTR, strRequestHeaders: BSTR, Context: X509CertificateEnrollmentContext, strTransactionId: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).InitializeForPending(@ptrCast(*const IX509SCEPEnrollmentHelper, self), strServerUrl, strRequestHeaders, Context, strTransactionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_Enroll(self: *const T, ProcessFlags: X509SCEPProcessMessageFlags, pDisposition: *X509SCEPDisposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).Enroll(@ptrCast(*const IX509SCEPEnrollmentHelper, self), ProcessFlags, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_FetchPending(self: *const T, ProcessFlags: X509SCEPProcessMessageFlags, pDisposition: *X509SCEPDisposition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).FetchPending(@ptrCast(*const IX509SCEPEnrollmentHelper, self), ProcessFlags, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_get_X509SCEPEnrollment(self: *const T, ppValue: ?*?*IX509SCEPEnrollment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).get_X509SCEPEnrollment(@ptrCast(*const IX509SCEPEnrollmentHelper, self), ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IX509SCEPEnrollmentHelper_get_ResultMessageText(self: *const T, pValue: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IX509SCEPEnrollmentHelper.VTable, self.vtable).get_ResultMessageText(@ptrCast(*const IX509SCEPEnrollmentHelper, self), pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const X509CertificateTemplateGeneralFlag = extern enum(i32) {
    MachineType = 64,
    CA = 128,
    CrossCA = 2048,
    Default = 65536,
    Modified = 131072,
    DonotPersist = 4096,
};
pub const GeneralMachineType = X509CertificateTemplateGeneralFlag.MachineType;
pub const GeneralCA = X509CertificateTemplateGeneralFlag.CA;
pub const GeneralCrossCA = X509CertificateTemplateGeneralFlag.CrossCA;
pub const GeneralDefault = X509CertificateTemplateGeneralFlag.Default;
pub const GeneralModified = X509CertificateTemplateGeneralFlag.Modified;
pub const GeneralDonotPersist = X509CertificateTemplateGeneralFlag.DonotPersist;

pub const X509CertificateTemplateEnrollmentFlag = extern enum(i32) {
    IncludeSymmetricAlgorithms = 1,
    PendAllRequests = 2,
    PublishToKRAContainer = 4,
    PublishToDS = 8,
    AutoEnrollmentCheckUserDSCertificate = 16,
    AutoEnrollment = 32,
    DomainAuthenticationNotRequired = 128,
    PreviousApprovalValidateReenrollment = 64,
    UserInteractionRequired = 256,
    AddTemplateName = 512,
    RemoveInvalidCertificateFromPersonalStore = 1024,
    AllowEnrollOnBehalfOf = 2048,
    AddOCSPNoCheck = 4096,
    ReuseKeyOnFullSmartCard = 8192,
    NoRevocationInfoInCerts = 16384,
    IncludeBasicConstraintsForEECerts = 32768,
    PreviousApprovalKeyBasedValidateReenrollment = 65536,
    CertificateIssuancePoliciesFromRequest = 131072,
    SkipAutoRenewal = 262144,
};
pub const EnrollmentIncludeSymmetricAlgorithms = X509CertificateTemplateEnrollmentFlag.IncludeSymmetricAlgorithms;
pub const EnrollmentPendAllRequests = X509CertificateTemplateEnrollmentFlag.PendAllRequests;
pub const EnrollmentPublishToKRAContainer = X509CertificateTemplateEnrollmentFlag.PublishToKRAContainer;
pub const EnrollmentPublishToDS = X509CertificateTemplateEnrollmentFlag.PublishToDS;
pub const EnrollmentAutoEnrollmentCheckUserDSCertificate = X509CertificateTemplateEnrollmentFlag.AutoEnrollmentCheckUserDSCertificate;
pub const EnrollmentAutoEnrollment = X509CertificateTemplateEnrollmentFlag.AutoEnrollment;
pub const EnrollmentDomainAuthenticationNotRequired = X509CertificateTemplateEnrollmentFlag.DomainAuthenticationNotRequired;
pub const EnrollmentPreviousApprovalValidateReenrollment = X509CertificateTemplateEnrollmentFlag.PreviousApprovalValidateReenrollment;
pub const EnrollmentUserInteractionRequired = X509CertificateTemplateEnrollmentFlag.UserInteractionRequired;
pub const EnrollmentAddTemplateName = X509CertificateTemplateEnrollmentFlag.AddTemplateName;
pub const EnrollmentRemoveInvalidCertificateFromPersonalStore = X509CertificateTemplateEnrollmentFlag.RemoveInvalidCertificateFromPersonalStore;
pub const EnrollmentAllowEnrollOnBehalfOf = X509CertificateTemplateEnrollmentFlag.AllowEnrollOnBehalfOf;
pub const EnrollmentAddOCSPNoCheck = X509CertificateTemplateEnrollmentFlag.AddOCSPNoCheck;
pub const EnrollmentReuseKeyOnFullSmartCard = X509CertificateTemplateEnrollmentFlag.ReuseKeyOnFullSmartCard;
pub const EnrollmentNoRevocationInfoInCerts = X509CertificateTemplateEnrollmentFlag.NoRevocationInfoInCerts;
pub const EnrollmentIncludeBasicConstraintsForEECerts = X509CertificateTemplateEnrollmentFlag.IncludeBasicConstraintsForEECerts;
pub const EnrollmentPreviousApprovalKeyBasedValidateReenrollment = X509CertificateTemplateEnrollmentFlag.PreviousApprovalKeyBasedValidateReenrollment;
pub const EnrollmentCertificateIssuancePoliciesFromRequest = X509CertificateTemplateEnrollmentFlag.CertificateIssuancePoliciesFromRequest;
pub const EnrollmentSkipAutoRenewal = X509CertificateTemplateEnrollmentFlag.SkipAutoRenewal;

pub const X509CertificateTemplateSubjectNameFlag = extern enum(i32) {
    NameEnrolleeSupplies = 1,
    NameRequireDirectoryPath = -2147483648,
    NameRequireCommonName = 1073741824,
    NameRequireEmail = 536870912,
    NameRequireDNS = 268435456,
    NameAndAlternativeNameOldCertSupplies = 8,
    AlternativeNameEnrolleeSupplies = 65536,
    AlternativeNameRequireDirectoryGUID = 16777216,
    AlternativeNameRequireUPN = 33554432,
    AlternativeNameRequireEmail = 67108864,
    AlternativeNameRequireSPN = 8388608,
    AlternativeNameRequireDNS = 134217728,
    AlternativeNameRequireDomainDNS = 4194304,
};
pub const SubjectNameEnrolleeSupplies = X509CertificateTemplateSubjectNameFlag.NameEnrolleeSupplies;
pub const SubjectNameRequireDirectoryPath = X509CertificateTemplateSubjectNameFlag.NameRequireDirectoryPath;
pub const SubjectNameRequireCommonName = X509CertificateTemplateSubjectNameFlag.NameRequireCommonName;
pub const SubjectNameRequireEmail = X509CertificateTemplateSubjectNameFlag.NameRequireEmail;
pub const SubjectNameRequireDNS = X509CertificateTemplateSubjectNameFlag.NameRequireDNS;
pub const SubjectNameAndAlternativeNameOldCertSupplies = X509CertificateTemplateSubjectNameFlag.NameAndAlternativeNameOldCertSupplies;
pub const SubjectAlternativeNameEnrolleeSupplies = X509CertificateTemplateSubjectNameFlag.AlternativeNameEnrolleeSupplies;
pub const SubjectAlternativeNameRequireDirectoryGUID = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireDirectoryGUID;
pub const SubjectAlternativeNameRequireUPN = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireUPN;
pub const SubjectAlternativeNameRequireEmail = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireEmail;
pub const SubjectAlternativeNameRequireSPN = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireSPN;
pub const SubjectAlternativeNameRequireDNS = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireDNS;
pub const SubjectAlternativeNameRequireDomainDNS = X509CertificateTemplateSubjectNameFlag.AlternativeNameRequireDomainDNS;

pub const X509CertificateTemplatePrivateKeyFlag = extern enum(i32) {
    RequireArchival = 1,
    Exportable = 16,
    RequireStrongKeyProtection = 32,
    RequireAlternateSignatureAlgorithm = 64,
    RequireSameKeyRenewal = 128,
    UseLegacyProvider = 256,
    EKTrustOnUse = 512,
    EKValidateCert = 1024,
    EKValidateKey = 2048,
    AttestNone = 0,
    AttestPreferred = 4096,
    AttestRequired = 8192,
    AttestMask = 12288,
    AttestWithoutPolicy = 16384,
    ServerVersionMask = 983040,
    ServerVersionShift = 16,
    HelloKspKey = 1048576,
    HelloLogonKey = 2097152,
    ClientVersionMask = 251658240,
    ClientVersionShift = 24,
};
pub const PrivateKeyRequireArchival = X509CertificateTemplatePrivateKeyFlag.RequireArchival;
pub const PrivateKeyExportable = X509CertificateTemplatePrivateKeyFlag.Exportable;
pub const PrivateKeyRequireStrongKeyProtection = X509CertificateTemplatePrivateKeyFlag.RequireStrongKeyProtection;
pub const PrivateKeyRequireAlternateSignatureAlgorithm = X509CertificateTemplatePrivateKeyFlag.RequireAlternateSignatureAlgorithm;
pub const PrivateKeyRequireSameKeyRenewal = X509CertificateTemplatePrivateKeyFlag.RequireSameKeyRenewal;
pub const PrivateKeyUseLegacyProvider = X509CertificateTemplatePrivateKeyFlag.UseLegacyProvider;
pub const PrivateKeyEKTrustOnUse = X509CertificateTemplatePrivateKeyFlag.EKTrustOnUse;
pub const PrivateKeyEKValidateCert = X509CertificateTemplatePrivateKeyFlag.EKValidateCert;
pub const PrivateKeyEKValidateKey = X509CertificateTemplatePrivateKeyFlag.EKValidateKey;
pub const PrivateKeyAttestNone = X509CertificateTemplatePrivateKeyFlag.AttestNone;
pub const PrivateKeyAttestPreferred = X509CertificateTemplatePrivateKeyFlag.AttestPreferred;
pub const PrivateKeyAttestRequired = X509CertificateTemplatePrivateKeyFlag.AttestRequired;
pub const PrivateKeyAttestMask = X509CertificateTemplatePrivateKeyFlag.AttestMask;
pub const PrivateKeyAttestWithoutPolicy = X509CertificateTemplatePrivateKeyFlag.AttestWithoutPolicy;
pub const PrivateKeyServerVersionMask = X509CertificateTemplatePrivateKeyFlag.ServerVersionMask;
pub const PrivateKeyServerVersionShift = X509CertificateTemplatePrivateKeyFlag.ServerVersionShift;
pub const PrivateKeyHelloKspKey = X509CertificateTemplatePrivateKeyFlag.HelloKspKey;
pub const PrivateKeyHelloLogonKey = X509CertificateTemplatePrivateKeyFlag.HelloLogonKey;
pub const PrivateKeyClientVersionMask = X509CertificateTemplatePrivateKeyFlag.ClientVersionMask;
pub const PrivateKeyClientVersionShift = X509CertificateTemplatePrivateKeyFlag.ClientVersionShift;

pub const ImportPFXFlags = extern enum(i32) {
    None = 0,
    MachineContext = 1,
    ForceOverwrite = 2,
    Silent = 4,
    SaveProperties = 8,
    Exportable = 16,
    ExportableEncrypted = 32,
    NoUserProtected = 64,
    UserProtected = 128,
    UserProtectedHigh = 256,
    InstallCertificate = 512,
    InstallChain = 1024,
    InstallChainAndRoot = 2048,
};
pub const ImportNone = ImportPFXFlags.None;
pub const ImportMachineContext = ImportPFXFlags.MachineContext;
pub const ImportForceOverwrite = ImportPFXFlags.ForceOverwrite;
pub const ImportSilent = ImportPFXFlags.Silent;
pub const ImportSaveProperties = ImportPFXFlags.SaveProperties;
pub const ImportExportable = ImportPFXFlags.Exportable;
pub const ImportExportableEncrypted = ImportPFXFlags.ExportableEncrypted;
pub const ImportNoUserProtected = ImportPFXFlags.NoUserProtected;
pub const ImportUserProtected = ImportPFXFlags.UserProtected;
pub const ImportUserProtectedHigh = ImportPFXFlags.UserProtectedHigh;
pub const ImportInstallCertificate = ImportPFXFlags.InstallCertificate;
pub const ImportInstallChain = ImportPFXFlags.InstallChain;
pub const ImportInstallChainAndRoot = ImportPFXFlags.InstallChainAndRoot;

pub const FNIMPORTPFXTOPROVIDER = fn(
    hWndParent: HWND,
    // TODO: what to do with BytesParamIndex 2?
    pbPFX: *const u8,
    cbPFX: u32,
    ImportFlags: ImportPFXFlags,
    pwszPassword: ?[*:0]const u16,
    pwszProviderName: ?[*:0]const u16,
    pwszReaderName: ?[*:0]const u16,
    pwszContainerNamePrefix: ?[*:0]const u16,
    pwszPin: ?[*:0]const u16,
    pwszFriendlyName: ?[*:0]const u16,
    pcCertOut: ?*u32,
    prgpCertOut: ?*?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const FNIMPORTPFXTOPROVIDERFREEDATA = fn(
    cCert: u32,
    rgpCert: ?[*]?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNCryptStreamOutputCallback = fn(
    pvCallbackCtxt: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NCRYPT_PROTECT_STREAM_INFO = extern struct {
    pfnStreamOutput: PFNCryptStreamOutputCallback,
    pvCallbackCtxt: *c_void,
};

pub const PFNCryptStreamOutputCallbackEx = fn(
    pvCallbackCtxt: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NCRYPT_PROTECT_STREAM_INFO_EX = extern struct {
    pfnStreamOutput: PFNCryptStreamOutputCallbackEx,
    pvCallbackCtxt: *c_void,
};

pub const TOKENBINDING_TYPE = extern enum(i32) {
    PROVIDED = 0,
    REFERRED = 1,
};
pub const TOKENBINDING_TYPE_PROVIDED = TOKENBINDING_TYPE.PROVIDED;
pub const TOKENBINDING_TYPE_REFERRED = TOKENBINDING_TYPE.REFERRED;

pub const TOKENBINDING_EXTENSION_FORMAT = extern enum(i32) {
    D = 0,
};
pub const TOKENBINDING_EXTENSION_FORMAT_UNDEFINED = TOKENBINDING_EXTENSION_FORMAT.D;

pub const TOKENBINDING_KEY_PARAMETERS_TYPE = extern enum(i32) {
    RSA2048_PKCS = 0,
    RSA2048_PSS = 1,
    ECDSAP256 = 2,
    ANYEXISTING = 255,
};
pub const TOKENBINDING_KEY_PARAMETERS_TYPE_RSA2048_PKCS = TOKENBINDING_KEY_PARAMETERS_TYPE.RSA2048_PKCS;
pub const TOKENBINDING_KEY_PARAMETERS_TYPE_RSA2048_PSS = TOKENBINDING_KEY_PARAMETERS_TYPE.RSA2048_PSS;
pub const TOKENBINDING_KEY_PARAMETERS_TYPE_ECDSAP256 = TOKENBINDING_KEY_PARAMETERS_TYPE.ECDSAP256;
pub const TOKENBINDING_KEY_PARAMETERS_TYPE_ANYEXISTING = TOKENBINDING_KEY_PARAMETERS_TYPE.ANYEXISTING;

pub const TOKENBINDING_IDENTIFIER = extern struct {
    keyType: u8,
};

pub const TOKENBINDING_RESULT_DATA = extern struct {
    bindingType: TOKENBINDING_TYPE,
    identifierSize: u32,
    identifierData: *TOKENBINDING_IDENTIFIER,
    extensionFormat: TOKENBINDING_EXTENSION_FORMAT,
    extensionSize: u32,
    extensionData: *c_void,
};

pub const TOKENBINDING_RESULT_LIST = extern struct {
    resultCount: u32,
    resultData: *TOKENBINDING_RESULT_DATA,
};

pub const TOKENBINDING_KEY_TYPES = extern struct {
    keyCount: u32,
    keyType: *TOKENBINDING_KEY_PARAMETERS_TYPE,
};

pub const CRYPT_XML_CHARSET = extern enum(i32) {
    AUTO = 0,
    UTF8 = 1,
    UTF16LE = 2,
    UTF16BE = 3,
};
pub const CRYPT_XML_CHARSET_AUTO = CRYPT_XML_CHARSET.AUTO;
pub const CRYPT_XML_CHARSET_UTF8 = CRYPT_XML_CHARSET.UTF8;
pub const CRYPT_XML_CHARSET_UTF16LE = CRYPT_XML_CHARSET.UTF16LE;
pub const CRYPT_XML_CHARSET_UTF16BE = CRYPT_XML_CHARSET.UTF16BE;

pub const CRYPT_XML_BLOB = extern struct {
    dwCharset: CRYPT_XML_CHARSET,
    cbData: u32,
    pbData: *u8,
};

pub const CRYPT_XML_DATA_BLOB = extern struct {
    cbData: u32,
    pbData: *u8,
};

pub const CRYPT_XML_PROPERTY_ID = extern enum(i32) {
    MAX_HEAP_SIZE = 1,
    SIGNATURE_LOCATION = 2,
    MAX_SIGNATURES = 3,
    DOC_DECLARATION = 4,
    XML_OUTPUT_CHARSET = 5,
};
pub const CRYPT_XML_PROPERTY_MAX_HEAP_SIZE = CRYPT_XML_PROPERTY_ID.MAX_HEAP_SIZE;
pub const CRYPT_XML_PROPERTY_SIGNATURE_LOCATION = CRYPT_XML_PROPERTY_ID.SIGNATURE_LOCATION;
pub const CRYPT_XML_PROPERTY_MAX_SIGNATURES = CRYPT_XML_PROPERTY_ID.MAX_SIGNATURES;
pub const CRYPT_XML_PROPERTY_DOC_DECLARATION = CRYPT_XML_PROPERTY_ID.DOC_DECLARATION;
pub const CRYPT_XML_PROPERTY_XML_OUTPUT_CHARSET = CRYPT_XML_PROPERTY_ID.XML_OUTPUT_CHARSET;

pub const CRYPT_XML_PROPERTY = extern struct {
    dwPropId: CRYPT_XML_PROPERTY_ID,
    pvValue: *const c_void,
    cbValue: u32,
};

pub const PFN_CRYPT_XML_WRITE_CALLBACK = fn(
    pvCallbackState: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_READ = fn(
    pvCallbackState: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *u8,
    cbData: u32,
    pcbRead: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_CLOSE = fn(
    pvCallbackState: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_DATA_PROVIDER = extern struct {
    pvCallbackState: *c_void,
    cbBufferSize: u32,
    pfnRead: PFN_CRYPT_XML_DATA_PROVIDER_READ,
    pfnClose: PFN_CRYPT_XML_DATA_PROVIDER_CLOSE,
};

pub const PFN_CRYPT_XML_CREATE_TRANSFORM = fn(
    pTransform: *const CRYPT_XML_ALGORITHM,
    pProviderIn: *CRYPT_XML_DATA_PROVIDER,
    pProviderOut: *CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_STATUS = extern struct {
    cbSize: u32,
    dwErrorStatus: CRYPT_XML_STATUS_ERROR_STATUS,
    dwInfoStatus: CRYPT_XML_STATUS_INFO_STATUS,
};

pub const CRYPT_XML_ALGORITHM = extern struct {
    cbSize: u32,
    wszAlgorithm: [*:0]const u16,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_TRANSFORM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithm: [*:0]const u16,
    cbBufferSize: u32,
    dwFlags: CRYPT_XML_TRANSFORM_FLAGS,
    pfnCreateTransform: PFN_CRYPT_XML_CREATE_TRANSFORM,
};

pub const CRYPT_XML_TRANSFORM_CHAIN_CONFIG = extern struct {
    cbSize: u32,
    cTransformInfo: u32,
    rgpTransformInfo: **CRYPT_XML_TRANSFORM_INFO,
};

pub const CRYPT_XML_KEY_DSA_KEY_VALUE = extern struct {
    P: CRYPT_XML_DATA_BLOB,
    Q: CRYPT_XML_DATA_BLOB,
    G: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    J: CRYPT_XML_DATA_BLOB,
    Seed: CRYPT_XML_DATA_BLOB,
    Counter: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_ECDSA_KEY_VALUE = extern struct {
    wszNamedCurve: [*:0]const u16,
    X: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    ExplicitPara: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_KEY_RSA_KEY_VALUE = extern struct {
    Modulus: CRYPT_XML_DATA_BLOB,
    Exponent: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_VALUE = extern struct {
    dwType: CRYPT_XML_KEY_VALUE_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPT_XML_ISSUER_SERIAL = extern struct {
    wszIssuer: [*:0]const u16,
    wszSerial: [*:0]const u16,
};

pub const CRYPT_XML_X509DATA_ITEM = extern struct {
    dwType: CRYPT_XML_X509DATA_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPT_XML_X509DATA = extern struct {
    cX509Data: u32,
    rgX509Data: *CRYPT_XML_X509DATA_ITEM,
};

pub const CRYPT_XML_KEY_INFO_ITEM = extern struct {
    dwType: CRYPT_XML_KEYINFO_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPT_XML_KEY_INFO = extern struct {
    cbSize: u32,
    wszId: [*:0]const u16,
    cKeyInfo: u32,
    rgKeyInfo: *CRYPT_XML_KEY_INFO_ITEM,
    hVerifyKey: *c_void,
};

pub const CRYPT_XML_REFERENCE = extern struct {
    cbSize: u32,
    hReference: *c_void,
    wszId: [*:0]const u16,
    wszUri: [*:0]const u16,
    wszType: [*:0]const u16,
    DigestMethod: CRYPT_XML_ALGORITHM,
    DigestValue: CRYPTOAPI_BLOB,
    cTransform: u32,
    rgTransform: *CRYPT_XML_ALGORITHM,
};

pub const CRYPT_XML_REFERENCES = extern struct {
    cReference: u32,
    rgpReference: **CRYPT_XML_REFERENCE,
};

pub const CRYPT_XML_SIGNED_INFO = extern struct {
    cbSize: u32,
    wszId: [*:0]const u16,
    Canonicalization: CRYPT_XML_ALGORITHM,
    SignatureMethod: CRYPT_XML_ALGORITHM,
    cReference: u32,
    rgpReference: **CRYPT_XML_REFERENCE,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_OBJECT = extern struct {
    cbSize: u32,
    hObject: *c_void,
    wszId: [*:0]const u16,
    wszMimeType: [*:0]const u16,
    wszEncoding: [*:0]const u16,
    Manifest: CRYPT_XML_REFERENCES,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_SIGNATURE = extern struct {
    cbSize: u32,
    hSignature: *c_void,
    wszId: [*:0]const u16,
    SignedInfo: CRYPT_XML_SIGNED_INFO,
    SignatureValue: CRYPTOAPI_BLOB,
    pKeyInfo: *CRYPT_XML_KEY_INFO,
    cObject: u32,
    rgpObject: **CRYPT_XML_OBJECT,
};

pub const CRYPT_XML_DOC_CTXT = extern struct {
    cbSize: u32,
    hDocCtxt: *c_void,
    pTransformsConfig: *CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    cSignature: u32,
    rgpSignature: **CRYPT_XML_SIGNATURE,
};

pub const CRYPT_XML_KEYINFO_PARAM = extern struct {
    wszId: [*:0]const u16,
    wszKeyName: [*:0]const u16,
    SKI: CRYPTOAPI_BLOB,
    wszSubjectName: [*:0]const u16,
    cCertificate: u32,
    rgCertificate: *CRYPTOAPI_BLOB,
    cCRL: u32,
    rgCRL: *CRYPTOAPI_BLOB,
};

pub const CRYPT_XML_KEYINFO_SPEC = extern enum(i32) {
    NONE = 0,
    ENCODED = 1,
    PARAM = 2,
};
pub const CRYPT_XML_KEYINFO_SPEC_NONE = CRYPT_XML_KEYINFO_SPEC.NONE;
pub const CRYPT_XML_KEYINFO_SPEC_ENCODED = CRYPT_XML_KEYINFO_SPEC.ENCODED;
pub const CRYPT_XML_KEYINFO_SPEC_PARAM = CRYPT_XML_KEYINFO_SPEC.PARAM;

pub const CRYPT_XML_ALGORITHM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithmURI: PWSTR,
    wszName: PWSTR,
    dwGroupId: CRYPT_XML_GROUP_ID,
    wszCNGAlgid: PWSTR,
    wszCNGExtraAlgid: PWSTR,
    dwSignFlags: u32,
    dwVerifyFlags: u32,
    pvPaddingInfo: *c_void,
    pvExtraInfo: *c_void,
};

pub const PFN_CRYPT_XML_ENUM_ALG_INFO = fn(
    pInfo: *const CRYPT_XML_ALGORITHM_INFO,
    pvArg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CryptXmlDllGetInterface = fn(
    dwFlags: u32,
    pMethod: *const CRYPT_XML_ALGORITHM_INFO,
    pInterface: *CRYPT_XML_CRYPTOGRAPHIC_INTERFACE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllEncodeAlgorithm = fn(
    pAlgInfo: *const CRYPT_XML_ALGORITHM_INFO,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: *c_void,
    pfnWrite: PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateDigest = fn(
    pDigestMethod: *const CRYPT_XML_ALGORITHM,
    pcbSize: *u32,
    phDigest: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllDigestData = fn(
    hDigest: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllFinalizeDigest = fn(
    hDigest: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbDigest: *u8,
    cbDigest: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCloseDigest = fn(
    hDigest: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllSignData = fn(
    pSignatureMethod: *const CRYPT_XML_ALGORITHM,
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: *const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllVerifySignature = fn(
    pSignatureMethod: *const CRYPT_XML_ALGORITHM,
    hKey: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: *const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: *const u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllGetAlgorithmInfo = fn(
    pXmlAlgorithm: *const CRYPT_XML_ALGORITHM,
    ppAlgInfo: **CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_CRYPTOGRAPHIC_INTERFACE = extern struct {
    cbSize: u32,
    fpCryptXmlEncodeAlgorithm: CryptXmlDllEncodeAlgorithm,
    fpCryptXmlCreateDigest: CryptXmlDllCreateDigest,
    fpCryptXmlDigestData: CryptXmlDllDigestData,
    fpCryptXmlFinalizeDigest: CryptXmlDllFinalizeDigest,
    fpCryptXmlCloseDigest: CryptXmlDllCloseDigest,
    fpCryptXmlSignData: CryptXmlDllSignData,
    fpCryptXmlVerifySignature: CryptXmlDllVerifySignature,
    fpCryptXmlGetAlgorithmInfo: CryptXmlDllGetAlgorithmInfo,
};

pub const CryptXmlDllEncodeKeyValue = fn(
    hKey: usize,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: *c_void,
    pfnWrite: PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateKey = fn(
    pEncoded: *const CRYPT_XML_BLOB,
    phKey: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

const CLSID_CCertSrvSetupKeyInformation_Value = @import("../zig.zig").Guid.initString("38373906-5433-4633-b0fb-29b7e78262e1");
pub const CLSID_CCertSrvSetupKeyInformation = &CLSID_CCertSrvSetupKeyInformation_Value;

const CLSID_CCertSrvSetup_Value = @import("../zig.zig").Guid.initString("961f180f-f55c-413d-a9b3-7d2af4d8e42f");
pub const CLSID_CCertSrvSetup = &CLSID_CCertSrvSetup_Value;

const CLSID_CMSCEPSetup_Value = @import("../zig.zig").Guid.initString("aa4f5c02-8e7c-49c4-94fa-67a5cc5eadb4");
pub const CLSID_CMSCEPSetup = &CLSID_CMSCEPSetup_Value;

const CLSID_CCertificateEnrollmentServerSetup_Value = @import("../zig.zig").Guid.initString("9902f3bc-88af-4cf8-ae62-7140531552b6");
pub const CLSID_CCertificateEnrollmentServerSetup = &CLSID_CCertificateEnrollmentServerSetup_Value;

const CLSID_CCertificateEnrollmentPolicyServerSetup_Value = @import("../zig.zig").Guid.initString("afe2fa32-41b1-459d-a5de-49add8a72182");
pub const CLSID_CCertificateEnrollmentPolicyServerSetup = &CLSID_CCertificateEnrollmentPolicyServerSetup_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformation_Value = @import("../zig.zig").Guid.initString("6ba73778-36da-4c39-8a85-bcfa7d000793");
pub const IID_ICertSrvSetupKeyInformation = &IID_ICertSrvSetupKeyInformation_Value;
pub const ICertSrvSetupKeyInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            bVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            varVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ProviderName(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ProviderName(self: *const T, bstrVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Length(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Length(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Existing(self: *const T, pVal: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Existing(self: *const T, bVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), bVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ContainerName(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ContainerName(self: *const T, bstrVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_HashAlgorithm(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_HashAlgorithm(self: *const T, bstrVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ExistingCACertificate(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ExistingCACertificate(self: *const T, varVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), varVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformationCollection_Value = @import("../zig.zig").Guid.initString("e65c8b00-e58f-41f9-a9ec-a28d7427c844");
pub const IID_ICertSrvSetupKeyInformationCollection = &IID_ICertSrvSetupKeyInformationCollection_Value;
pub const ICertSrvSetupKeyInformationCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            ppVal: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            Index: i32,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pIKeyInformation: *ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get__NewEnum(self: *const T, ppVal: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Item(self: *const T, Index: i32, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Item(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Count(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_Add(self: *const T, pIKeyInformation: *ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).Add(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pIKeyInformation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CASetupProperty = extern enum(i32) {
    INVALID = -1,
    CATYPE = 0,
    CAKEYINFORMATION = 1,
    INTERACTIVE = 2,
    CANAME = 3,
    CADSSUFFIX = 4,
    VALIDITYPERIOD = 5,
    VALIDITYPERIODUNIT = 6,
    EXPIRATIONDATE = 7,
    PRESERVEDATABASE = 8,
    DATABASEDIRECTORY = 9,
    LOGDIRECTORY = 10,
    SHAREDFOLDER = 11,
    PARENTCAMACHINE = 12,
    PARENTCANAME = 13,
    REQUESTFILE = 14,
    WEBCAMACHINE = 15,
    WEBCANAME = 16,
};
pub const ENUM_SETUPPROP_INVALID = CASetupProperty.INVALID;
pub const ENUM_SETUPPROP_CATYPE = CASetupProperty.CATYPE;
pub const ENUM_SETUPPROP_CAKEYINFORMATION = CASetupProperty.CAKEYINFORMATION;
pub const ENUM_SETUPPROP_INTERACTIVE = CASetupProperty.INTERACTIVE;
pub const ENUM_SETUPPROP_CANAME = CASetupProperty.CANAME;
pub const ENUM_SETUPPROP_CADSSUFFIX = CASetupProperty.CADSSUFFIX;
pub const ENUM_SETUPPROP_VALIDITYPERIOD = CASetupProperty.VALIDITYPERIOD;
pub const ENUM_SETUPPROP_VALIDITYPERIODUNIT = CASetupProperty.VALIDITYPERIODUNIT;
pub const ENUM_SETUPPROP_EXPIRATIONDATE = CASetupProperty.EXPIRATIONDATE;
pub const ENUM_SETUPPROP_PRESERVEDATABASE = CASetupProperty.PRESERVEDATABASE;
pub const ENUM_SETUPPROP_DATABASEDIRECTORY = CASetupProperty.DATABASEDIRECTORY;
pub const ENUM_SETUPPROP_LOGDIRECTORY = CASetupProperty.LOGDIRECTORY;
pub const ENUM_SETUPPROP_SHAREDFOLDER = CASetupProperty.SHAREDFOLDER;
pub const ENUM_SETUPPROP_PARENTCAMACHINE = CASetupProperty.PARENTCAMACHINE;
pub const ENUM_SETUPPROP_PARENTCANAME = CASetupProperty.PARENTCANAME;
pub const ENUM_SETUPPROP_REQUESTFILE = CASetupProperty.REQUESTFILE;
pub const ENUM_SETUPPROP_WEBCAMACHINE = CASetupProperty.WEBCAMACHINE;
pub const ENUM_SETUPPROP_WEBCANAME = CASetupProperty.WEBCANAME;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetup_Value = @import("../zig.zig").Guid.initString("b760a1bb-4784-44c0-8f12-555f0780ff25");
pub const IID_ICertSrvSetup = &IID_ICertSrvSetup_Value;
pub const ICertSrvSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorId: fn(
            self: *const ICertSrvSetup,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorString: fn(
            self: *const ICertSrvSetup,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const ICertSrvSetup,
            bServer: i16,
            bClient: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPropertyEditable: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pbEditable: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedCATypes: fn(
            self: *const ICertSrvSetup,
            pCATypes: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const ICertSrvSetup,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithmList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyContainerList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExistingCACertificates: fn(
            self: *const ICertSrvSetup,
            ppVal: **ICertSrvSetupKeyInformationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CAImportPFX: fn(
            self: *const ICertSrvSetup,
            bstrFileName: BSTR,
            bstrPasswd: BSTR,
            bOverwriteExistingKey: i16,
            ppVal: **ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCADistinguishedName: fn(
            self: *const ICertSrvSetup,
            bstrCADN: BSTR,
            bIgnoreUnicode: i16,
            bOverwriteExistingKey: i16,
            bOverwriteExistingCAInDS: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDatabaseInformation: fn(
            self: *const ICertSrvSetup,
            bstrDBDirectory: BSTR,
            bstrLogDirectory: BSTR,
            bstrSharedFolder: BSTR,
            bForceOverwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParentCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWebCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const ICertSrvSetup,
            bClientOnly: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorId(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorId(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorString(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorString(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_InitializeDefaults(self: *const T, bServer: i16, bClient: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const ICertSrvSetup, self), bServer, bClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_IsPropertyEditable(self: *const T, propertyId: CASetupProperty, pbEditable: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).IsPropertyEditable(@ptrCast(*const ICertSrvSetup, self), propertyId, pbEditable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetSupportedCATypes(self: *const T, pCATypes: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetSupportedCATypes(@ptrCast(*const ICertSrvSetup, self), pCATypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetProviderNameList(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetKeyLengthList(self: *const T, bstrProviderName: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetHashAlgorithmList(self: *const T, bstrProviderName: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetHashAlgorithmList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetPrivateKeyContainerList(self: *const T, bstrProviderName: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetPrivateKeyContainerList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetExistingCACertificates(self: *const T, ppVal: **ICertSrvSetupKeyInformationCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetExistingCACertificates(@ptrCast(*const ICertSrvSetup, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_CAImportPFX(self: *const T, bstrFileName: BSTR, bstrPasswd: BSTR, bOverwriteExistingKey: i16, ppVal: **ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).CAImportPFX(@ptrCast(*const ICertSrvSetup, self), bstrFileName, bstrPasswd, bOverwriteExistingKey, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCADistinguishedName(self: *const T, bstrCADN: BSTR, bIgnoreUnicode: i16, bOverwriteExistingKey: i16, bOverwriteExistingCAInDS: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCADistinguishedName(@ptrCast(*const ICertSrvSetup, self), bstrCADN, bIgnoreUnicode, bOverwriteExistingKey, bOverwriteExistingCAInDS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetDatabaseInformation(self: *const T, bstrDBDirectory: BSTR, bstrLogDirectory: BSTR, bstrSharedFolder: BSTR, bForceOverwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetDatabaseInformation(@ptrCast(*const ICertSrvSetup, self), bstrDBDirectory, bstrLogDirectory, bstrSharedFolder, bForceOverwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetParentCAInformation(self: *const T, bstrCAConfiguration: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetParentCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetWebCAInformation(self: *const T, bstrCAConfiguration: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetWebCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).Install(@ptrCast(*const ICertSrvSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PreUnInstall(self: *const T, bClientOnly: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const ICertSrvSetup, self), bClientOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const ICertSrvSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSCEPSetupProperty = extern enum(i32) {
    USELOCALSYSTEM = 0,
    USECHALLENGE = 1,
    RANAME_CN = 2,
    RANAME_EMAIL = 3,
    RANAME_COMPANY = 4,
    RANAME_DEPT = 5,
    RANAME_CITY = 6,
    RANAME_STATE = 7,
    RANAME_COUNTRY = 8,
    SIGNINGKEYINFORMATION = 9,
    EXCHANGEKEYINFORMATION = 10,
    CAINFORMATION = 11,
    MSCEPURL = 12,
    CHALLENGEURL = 13,
};
pub const ENUM_CEPSETUPPROP_USELOCALSYSTEM = MSCEPSetupProperty.USELOCALSYSTEM;
pub const ENUM_CEPSETUPPROP_USECHALLENGE = MSCEPSetupProperty.USECHALLENGE;
pub const ENUM_CEPSETUPPROP_RANAME_CN = MSCEPSetupProperty.RANAME_CN;
pub const ENUM_CEPSETUPPROP_RANAME_EMAIL = MSCEPSetupProperty.RANAME_EMAIL;
pub const ENUM_CEPSETUPPROP_RANAME_COMPANY = MSCEPSetupProperty.RANAME_COMPANY;
pub const ENUM_CEPSETUPPROP_RANAME_DEPT = MSCEPSetupProperty.RANAME_DEPT;
pub const ENUM_CEPSETUPPROP_RANAME_CITY = MSCEPSetupProperty.RANAME_CITY;
pub const ENUM_CEPSETUPPROP_RANAME_STATE = MSCEPSetupProperty.RANAME_STATE;
pub const ENUM_CEPSETUPPROP_RANAME_COUNTRY = MSCEPSetupProperty.RANAME_COUNTRY;
pub const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = MSCEPSetupProperty.SIGNINGKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = MSCEPSetupProperty.EXCHANGEKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_CAINFORMATION = MSCEPSetupProperty.CAINFORMATION;
pub const ENUM_CEPSETUPPROP_MSCEPURL = MSCEPSetupProperty.MSCEPURL;
pub const ENUM_CEPSETUPPROP_CHALLENGEURL = MSCEPSetupProperty.CHALLENGEURL;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IMSCEPSetup_Value = @import("../zig.zig").Guid.initString("4f7761bb-9f3b-4592-9ee0-9a73259c313e");
pub const IID_IMSCEPSetup = &IID_IMSCEPSetup_Value;
pub const IMSCEPSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorId: fn(
            self: *const IMSCEPSetup,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorString: fn(
            self: *const IMSCEPSetup,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: fn(
            self: *const IMSCEPSetup,
            bstrUserName: BSTR,
            bstrPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMSCEPStoreEmpty: fn(
            self: *const IMSCEPSetup,
            pbEmpty: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            bstrProviderName: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorId(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorId(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorString(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorString(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_InitializeDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetAccountInformation(self: *const T, bstrUserName: BSTR, bstrPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetAccountInformation(@ptrCast(*const IMSCEPSetup, self), bstrUserName, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_IsMSCEPStoreEmpty(self: *const T, pbEmpty: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).IsMSCEPStoreEmpty(@ptrCast(*const IMSCEPSetup, self), pbEmpty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetProviderNameList(self: *const T, bExchange: i16, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const IMSCEPSetup, self), bExchange, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetKeyLengthList(self: *const T, bExchange: i16, bstrProviderName: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const IMSCEPSetup, self), bExchange, bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).Install(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PreUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CESSetupProperty = extern enum(i32) {
    USE_IISAPPPOOLIDENTITY = 0,
    CACONFIG = 1,
    AUTHENTICATION = 2,
    SSLCERTHASH = 3,
    URL = 4,
    RENEWALONLY = 5,
    ALLOW_KEYBASED_RENEWAL = 6,
};
pub const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = CESSetupProperty.USE_IISAPPPOOLIDENTITY;
pub const ENUM_CESSETUPPROP_CACONFIG = CESSetupProperty.CACONFIG;
pub const ENUM_CESSETUPPROP_AUTHENTICATION = CESSetupProperty.AUTHENTICATION;
pub const ENUM_CESSETUPPROP_SSLCERTHASH = CESSetupProperty.SSLCERTHASH;
pub const ENUM_CESSETUPPROP_URL = CESSetupProperty.URL;
pub const ENUM_CESSETUPPROP_RENEWALONLY = CESSetupProperty.RENEWALONLY;
pub const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = CESSetupProperty.ALLOW_KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentServerSetup_Value = @import("../zig.zig").Guid.initString("70027fdb-9dd9-4921-8944-b35cb31bd2ec");
pub const IID_ICertificateEnrollmentServerSetup = &IID_ICertificateEnrollmentServerSetup_Value;
pub const ICertificateEnrollmentServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationPoolCredentials: fn(
            self: *const ICertificateEnrollmentServerSetup,
            bstrUsername: BSTR,
            bstrPassword: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pCAConfig: *VARIANT,
            pAuthentication: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_get_ErrorString(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_GetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetApplicationPoolCredentials(self: *const T, bstrUsername: BSTR, bstrPassword: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetApplicationPoolCredentials(@ptrCast(*const ICertificateEnrollmentServerSetup, self), bstrUsername, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_UnInstall(self: *const T, pCAConfig: *VARIANT, pAuthentication: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pCAConfig, pAuthentication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CEPSetupProperty = extern enum(i32) {
    AUTHENTICATION = 0,
    SSLCERTHASH = 1,
    URL = 2,
    KEYBASED_RENEWAL = 3,
};
pub const ENUM_CEPSETUPPROP_AUTHENTICATION = CEPSetupProperty.AUTHENTICATION;
pub const ENUM_CEPSETUPPROP_SSLCERTHASH = CEPSetupProperty.SSLCERTHASH;
pub const ENUM_CEPSETUPPROP_URL = CEPSetupProperty.URL;
pub const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = CEPSetupProperty.KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentPolicyServerSetup_Value = @import("../zig.zig").Guid.initString("859252cc-238c-4a88-b8fd-a37e7d04e68b");
pub const IID_ICertificateEnrollmentPolicyServerSetup = &IID_ICertificateEnrollmentPolicyServerSetup_Value;
pub const ICertificateEnrollmentPolicyServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pAuthKeyBasedRenewal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_get_ErrorString(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_GetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_SetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_UnInstall(self: *const T, pAuthKeyBasedRenewal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pAuthKeyBasedRenewal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CCertAdmin_Value = @import("../zig.zig").Guid.initString("37eabaf0-7fb6-11d0-8817-00a0c903b83c");
pub const CLSID_CCertAdmin = &CLSID_CCertAdmin_Value;

const CLSID_CCertView_Value = @import("../zig.zig").Guid.initString("a12d0f7a-1e84-11d1-9bd6-00c04fb683fa");
pub const CLSID_CCertView = &CLSID_CCertView_Value;

const CLSID_OCSPPropertyCollection_Value = @import("../zig.zig").Guid.initString("f935a528-ba8a-4dd9-ba79-f283275cb2de");
pub const CLSID_OCSPPropertyCollection = &CLSID_OCSPPropertyCollection_Value;

const CLSID_OCSPAdmin_Value = @import("../zig.zig").Guid.initString("d3f73511-92c9-47cb-8ff2-8d891a7c4de4");
pub const CLSID_OCSPAdmin = &CLSID_OCSPAdmin_Value;

// TODO: this type is limited to platform 'windowsServer2003'
const IID_IEnumCERTVIEWCOLUMN_Value = @import("../zig.zig").Guid.initString("9c735be2-57a5-11d1-9bdb-00c04fb683fa");
pub const IID_IEnumCERTVIEWCOLUMN = &IID_IEnumCERTVIEWCOLUMN_Value;
pub const IEnumCERTVIEWCOLUMN = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Next: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIndexed: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pIndexed: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxLength: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            pMaxLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            Flags: ENUM_CERT_COLUMN_VALUE_FLAGS,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            celt: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCERTVIEWCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCERTVIEWCOLUMN,
            ppenum: **IEnumCERTVIEWCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_Next(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).Next(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_GetName(self: *const T, pstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).GetName(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_GetDisplayName(self: *const T, pstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).GetDisplayName(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_GetType(self: *const T, pType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).GetType(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_IsIndexed(self: *const T, pIndexed: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).IsIndexed(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pIndexed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_GetMaxLength(self: *const T, pMaxLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).GetMaxLength(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), pMaxLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_GetValue(self: *const T, Flags: ENUM_CERT_COLUMN_VALUE_FLAGS, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).GetValue(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), Flags, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_Skip(self: *const T, celt: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).Skip(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).Reset(@ptrCast(*const IEnumCERTVIEWCOLUMN, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWCOLUMN_Clone(self: *const T, ppenum: **IEnumCERTVIEWCOLUMN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWCOLUMN.VTable, self.vtable).Clone(@ptrCast(*const IEnumCERTVIEWCOLUMN, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_IEnumCERTVIEWATTRIBUTE_Value = @import("../zig.zig").Guid.initString("e77db656-7653-11d1-9bde-00c04fb683fa");
pub const IID_IEnumCERTVIEWATTRIBUTE = &IID_IEnumCERTVIEWATTRIBUTE_Value;
pub const IEnumCERTVIEWATTRIBUTE = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Next: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
            pstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
            pstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
            celt: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCERTVIEWATTRIBUTE,
            ppenum: **IEnumCERTVIEWATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_Next(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).Next(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self), pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_GetName(self: *const T, pstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).GetName(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self), pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_GetValue(self: *const T, pstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).GetValue(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self), pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_Skip(self: *const T, celt: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).Skip(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).Reset(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWATTRIBUTE_Clone(self: *const T, ppenum: **IEnumCERTVIEWATTRIBUTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWATTRIBUTE.VTable, self.vtable).Clone(@ptrCast(*const IEnumCERTVIEWATTRIBUTE, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_IEnumCERTVIEWEXTENSION_Value = @import("../zig.zig").Guid.initString("e7dd1466-7653-11d1-9bde-00c04fb683fa");
pub const IID_IEnumCERTVIEWEXTENSION = &IID_IEnumCERTVIEWEXTENSION_Value;
pub const IEnumCERTVIEWEXTENSION = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Next: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            pstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            Type: CERT_PROPERTY_TYPE,
            Flags: ENUM_CERT_COLUMN_VALUE_FLAGS,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            celt: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCERTVIEWEXTENSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCERTVIEWEXTENSION,
            ppenum: **IEnumCERTVIEWEXTENSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_Next(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).Next(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_GetName(self: *const T, pstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).GetName(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), pstrOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_GetFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).GetFlags(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_GetValue(self: *const T, Type: CERT_PROPERTY_TYPE, Flags: ENUM_CERT_COLUMN_VALUE_FLAGS, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).GetValue(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), Type, Flags, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_Skip(self: *const T, celt: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).Skip(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).Reset(@ptrCast(*const IEnumCERTVIEWEXTENSION, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWEXTENSION_Clone(self: *const T, ppenum: **IEnumCERTVIEWEXTENSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWEXTENSION.VTable, self.vtable).Clone(@ptrCast(*const IEnumCERTVIEWEXTENSION, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_IEnumCERTVIEWROW_Value = @import("../zig.zig").Guid.initString("d1157f4c-5af2-11d1-9bdc-00c04fb683fa");
pub const IID_IEnumCERTVIEWROW = &IID_IEnumCERTVIEWROW_Value;
pub const IEnumCERTVIEWROW = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Next: fn(
            self: *const IEnumCERTVIEWROW,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCertViewColumn: fn(
            self: *const IEnumCERTVIEWROW,
            ppenum: **IEnumCERTVIEWCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCertViewAttribute: fn(
            self: *const IEnumCERTVIEWROW,
            Flags: i32,
            ppenum: **IEnumCERTVIEWATTRIBUTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCertViewExtension: fn(
            self: *const IEnumCERTVIEWROW,
            Flags: i32,
            ppenum: **IEnumCERTVIEWEXTENSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCERTVIEWROW,
            celt: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCERTVIEWROW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCERTVIEWROW,
            ppenum: **IEnumCERTVIEWROW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIndex: fn(
            self: *const IEnumCERTVIEWROW,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_Next(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).Next(@ptrCast(*const IEnumCERTVIEWROW, self), pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_EnumCertViewColumn(self: *const T, ppenum: **IEnumCERTVIEWCOLUMN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).EnumCertViewColumn(@ptrCast(*const IEnumCERTVIEWROW, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_EnumCertViewAttribute(self: *const T, Flags: i32, ppenum: **IEnumCERTVIEWATTRIBUTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).EnumCertViewAttribute(@ptrCast(*const IEnumCERTVIEWROW, self), Flags, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_EnumCertViewExtension(self: *const T, Flags: i32, ppenum: **IEnumCERTVIEWEXTENSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).EnumCertViewExtension(@ptrCast(*const IEnumCERTVIEWROW, self), Flags, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_Skip(self: *const T, celt: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).Skip(@ptrCast(*const IEnumCERTVIEWROW, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).Reset(@ptrCast(*const IEnumCERTVIEWROW, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_Clone(self: *const T, ppenum: **IEnumCERTVIEWROW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).Clone(@ptrCast(*const IEnumCERTVIEWROW, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCERTVIEWROW_GetMaxIndex(self: *const T, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCERTVIEWROW.VTable, self.vtable).GetMaxIndex(@ptrCast(*const IEnumCERTVIEWROW, self), pIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertView_Value = @import("../zig.zig").Guid.initString("c3fac344-1e84-11d1-9bd6-00c04fb683fa");
pub const IID_ICertView = &IID_ICertView_Value;
pub const ICertView = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OpenConnection: fn(
            self: *const ICertView,
            strConfig: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCertViewColumn: fn(
            self: *const ICertView,
            fResultColumn: CVRC_COLUMN,
            ppenum: **IEnumCERTVIEWCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnCount: fn(
            self: *const ICertView,
            fResultColumn: CVRC_COLUMN,
            pcColumn: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnIndex: fn(
            self: *const ICertView,
            fResultColumn: CVRC_COLUMN,
            strColumnName: BSTR,
            pColumnIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResultColumnCount: fn(
            self: *const ICertView,
            cResultColumn: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetResultColumn: fn(
            self: *const ICertView,
            ColumnIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestriction: fn(
            self: *const ICertView,
            ColumnIndex: CERT_VIEW_COLUMN_INDEX,
            SeekOperator: CERT_VIEW_SEEK_OPERATOR_FLAGS,
            SortOrder: i32,
            pvarValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenView: fn(
            self: *const ICertView,
            ppenum: **IEnumCERTVIEWROW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_OpenConnection(self: *const T, strConfig: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).OpenConnection(@ptrCast(*const ICertView, self), strConfig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_EnumCertViewColumn(self: *const T, fResultColumn: CVRC_COLUMN, ppenum: **IEnumCERTVIEWCOLUMN) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).EnumCertViewColumn(@ptrCast(*const ICertView, self), fResultColumn, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_GetColumnCount(self: *const T, fResultColumn: CVRC_COLUMN, pcColumn: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).GetColumnCount(@ptrCast(*const ICertView, self), fResultColumn, pcColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_GetColumnIndex(self: *const T, fResultColumn: CVRC_COLUMN, strColumnName: BSTR, pColumnIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).GetColumnIndex(@ptrCast(*const ICertView, self), fResultColumn, strColumnName, pColumnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_SetResultColumnCount(self: *const T, cResultColumn: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).SetResultColumnCount(@ptrCast(*const ICertView, self), cResultColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_SetResultColumn(self: *const T, ColumnIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).SetResultColumn(@ptrCast(*const ICertView, self), ColumnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_SetRestriction(self: *const T, ColumnIndex: CERT_VIEW_COLUMN_INDEX, SeekOperator: CERT_VIEW_SEEK_OPERATOR_FLAGS, SortOrder: i32, pvarValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).SetRestriction(@ptrCast(*const ICertView, self), ColumnIndex, SeekOperator, SortOrder, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView_OpenView(self: *const T, ppenum: **IEnumCERTVIEWROW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView.VTable, self.vtable).OpenView(@ptrCast(*const ICertView, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertView2_Value = @import("../zig.zig").Guid.initString("d594b282-8851-4b61-9c66-3edadf848863");
pub const IID_ICertView2 = &IID_ICertView2_Value;
pub const ICertView2 = extern struct {
    pub const VTable = extern struct {
        base: ICertView.VTable,
        SetTable: fn(
            self: *const ICertView2,
            Table: CVRC_TABLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertView.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertView2_SetTable(self: *const T, Table: CVRC_TABLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertView2.VTable, self.vtable).SetTable(@ptrCast(*const ICertView2, self), Table);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertAdmin_Value = @import("../zig.zig").Guid.initString("34df6950-7fb6-11d0-8817-00a0c903b83c");
pub const IID_ICertAdmin = &IID_ICertAdmin_Value;
pub const ICertAdmin = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        IsValidCertificate: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            strSerialNumber: BSTR,
            pDisposition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRevocationReason: fn(
            self: *const ICertAdmin,
            pReason: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeCertificate: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            strSerialNumber: BSTR,
            Reason: i32,
            Date: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRequestAttributes: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            RequestId: i32,
            strAttributes: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCertificateExtension: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            RequestId: i32,
            strExtensionName: BSTR,
            Type: CERT_PROPERTY_TYPE,
            Flags: i32,
            pvarValue: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DenyRequest: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            RequestId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResubmitRequest: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            RequestId: i32,
            pDisposition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PublishCRL: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            Date: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCRL: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            Flags: i32,
            pstrCRL: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportCertificate: fn(
            self: *const ICertAdmin,
            strConfig: BSTR,
            strCertificate: BSTR,
            Flags: CERT_IMPORT_FLAGS,
            pRequestId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_IsValidCertificate(self: *const T, strConfig: BSTR, strSerialNumber: BSTR, pDisposition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).IsValidCertificate(@ptrCast(*const ICertAdmin, self), strConfig, strSerialNumber, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_GetRevocationReason(self: *const T, pReason: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).GetRevocationReason(@ptrCast(*const ICertAdmin, self), pReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_RevokeCertificate(self: *const T, strConfig: BSTR, strSerialNumber: BSTR, Reason: i32, Date: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).RevokeCertificate(@ptrCast(*const ICertAdmin, self), strConfig, strSerialNumber, Reason, Date);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_SetRequestAttributes(self: *const T, strConfig: BSTR, RequestId: i32, strAttributes: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).SetRequestAttributes(@ptrCast(*const ICertAdmin, self), strConfig, RequestId, strAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_SetCertificateExtension(self: *const T, strConfig: BSTR, RequestId: i32, strExtensionName: BSTR, Type: CERT_PROPERTY_TYPE, Flags: i32, pvarValue: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).SetCertificateExtension(@ptrCast(*const ICertAdmin, self), strConfig, RequestId, strExtensionName, Type, Flags, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_DenyRequest(self: *const T, strConfig: BSTR, RequestId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).DenyRequest(@ptrCast(*const ICertAdmin, self), strConfig, RequestId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_ResubmitRequest(self: *const T, strConfig: BSTR, RequestId: i32, pDisposition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).ResubmitRequest(@ptrCast(*const ICertAdmin, self), strConfig, RequestId, pDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_PublishCRL(self: *const T, strConfig: BSTR, Date: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).PublishCRL(@ptrCast(*const ICertAdmin, self), strConfig, Date);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_GetCRL(self: *const T, strConfig: BSTR, Flags: i32, pstrCRL: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).GetCRL(@ptrCast(*const ICertAdmin, self), strConfig, Flags, pstrCRL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin_ImportCertificate(self: *const T, strConfig: BSTR, strCertificate: BSTR, Flags: CERT_IMPORT_FLAGS, pRequestId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin.VTable, self.vtable).ImportCertificate(@ptrCast(*const ICertAdmin, self), strConfig, strCertificate, Flags, pRequestId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertAdmin2_Value = @import("../zig.zig").Guid.initString("f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39");
pub const IID_ICertAdmin2 = &IID_ICertAdmin2_Value;
pub const ICertAdmin2 = extern struct {
    pub const VTable = extern struct {
        base: ICertAdmin.VTable,
        PublishCRLs: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            Date: f64,
            CRLFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAProperty: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            PropId: i32,
            PropIndex: i32,
            PropType: i32,
            Flags: i32,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCAProperty: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            PropId: i32,
            PropIndex: i32,
            PropType: CERT_PROPERTY_TYPE,
            pvarPropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPropertyFlags: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            PropId: i32,
            pPropFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPropertyDisplayName: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            PropId: i32,
            pstrDisplayName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArchivedKey: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            RequestId: i32,
            Flags: i32,
            pstrArchivedKey: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigEntry: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            strNodePath: BSTR,
            strEntryName: BSTR,
            pvarEntry: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConfigEntry: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            strNodePath: BSTR,
            strEntryName: BSTR,
            pvarEntry: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportKey: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            RequestId: i32,
            strCertHash: BSTR,
            Flags: CERT_IMPORT_FLAGS,
            strKey: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMyRoles: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            pRoles: *CERTADMIN_GET_ROLES_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRow: fn(
            self: *const ICertAdmin2,
            strConfig: BSTR,
            Flags: CERT_DELETE_ROW_FLAGS,
            Date: f64,
            Table: CVRC_TABLE,
            RowId: i32,
            pcDeleted: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertAdmin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_PublishCRLs(self: *const T, strConfig: BSTR, Date: f64, CRLFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).PublishCRLs(@ptrCast(*const ICertAdmin2, self), strConfig, Date, CRLFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetCAProperty(self: *const T, strConfig: BSTR, PropId: i32, PropIndex: i32, PropType: i32, Flags: i32, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetCAProperty(@ptrCast(*const ICertAdmin2, self), strConfig, PropId, PropIndex, PropType, Flags, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_SetCAProperty(self: *const T, strConfig: BSTR, PropId: i32, PropIndex: i32, PropType: CERT_PROPERTY_TYPE, pvarPropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).SetCAProperty(@ptrCast(*const ICertAdmin2, self), strConfig, PropId, PropIndex, PropType, pvarPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetCAPropertyFlags(self: *const T, strConfig: BSTR, PropId: i32, pPropFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetCAPropertyFlags(@ptrCast(*const ICertAdmin2, self), strConfig, PropId, pPropFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetCAPropertyDisplayName(self: *const T, strConfig: BSTR, PropId: i32, pstrDisplayName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetCAPropertyDisplayName(@ptrCast(*const ICertAdmin2, self), strConfig, PropId, pstrDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetArchivedKey(self: *const T, strConfig: BSTR, RequestId: i32, Flags: i32, pstrArchivedKey: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetArchivedKey(@ptrCast(*const ICertAdmin2, self), strConfig, RequestId, Flags, pstrArchivedKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetConfigEntry(self: *const T, strConfig: BSTR, strNodePath: BSTR, strEntryName: BSTR, pvarEntry: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetConfigEntry(@ptrCast(*const ICertAdmin2, self), strConfig, strNodePath, strEntryName, pvarEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_SetConfigEntry(self: *const T, strConfig: BSTR, strNodePath: BSTR, strEntryName: BSTR, pvarEntry: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).SetConfigEntry(@ptrCast(*const ICertAdmin2, self), strConfig, strNodePath, strEntryName, pvarEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_ImportKey(self: *const T, strConfig: BSTR, RequestId: i32, strCertHash: BSTR, Flags: CERT_IMPORT_FLAGS, strKey: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).ImportKey(@ptrCast(*const ICertAdmin2, self), strConfig, RequestId, strCertHash, Flags, strKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_GetMyRoles(self: *const T, strConfig: BSTR, pRoles: *CERTADMIN_GET_ROLES_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).GetMyRoles(@ptrCast(*const ICertAdmin2, self), strConfig, pRoles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertAdmin2_DeleteRow(self: *const T, strConfig: BSTR, Flags: CERT_DELETE_ROW_FLAGS, Date: f64, Table: CVRC_TABLE, RowId: i32, pcDeleted: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertAdmin2.VTable, self.vtable).DeleteRow(@ptrCast(*const ICertAdmin2, self), strConfig, Flags, Date, Table, RowId, pcDeleted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IOCSPProperty_Value = @import("../zig.zig").Guid.initString("66fb7839-5f04-4c25-ad18-9ff1a8376ee0");
pub const IID_IOCSPProperty = &IID_IOCSPProperty_Value;
pub const IOCSPProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IOCSPProperty,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IOCSPProperty,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IOCSPProperty,
            newVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modified: fn(
            self: *const IOCSPProperty,
            pVal: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPProperty_get_Name(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPProperty.VTable, self.vtable).get_Name(@ptrCast(*const IOCSPProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPProperty_get_Value(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPProperty.VTable, self.vtable).get_Value(@ptrCast(*const IOCSPProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPProperty_put_Value(self: *const T, newVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPProperty.VTable, self.vtable).put_Value(@ptrCast(*const IOCSPProperty, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPProperty_get_Modified(self: *const T, pVal: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPProperty.VTable, self.vtable).get_Modified(@ptrCast(*const IOCSPProperty, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IOCSPPropertyCollection_Value = @import("../zig.zig").Guid.initString("2597c18d-54e6-4b74-9fa9-a6bfda99cbbe");
pub const IID_IOCSPPropertyCollection = &IID_IOCSPPropertyCollection_Value;
pub const IOCSPPropertyCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IOCSPPropertyCollection,
            ppVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IOCSPPropertyCollection,
            Index: i32,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IOCSPPropertyCollection,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const IOCSPPropertyCollection,
            bstrPropName: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProperty: fn(
            self: *const IOCSPPropertyCollection,
            bstrPropName: BSTR,
            pVarPropValue: *const VARIANT,
            ppVal: ?*?*IOCSPProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProperty: fn(
            self: *const IOCSPPropertyCollection,
            bstrPropName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromProperties: fn(
            self: *const IOCSPPropertyCollection,
            pVarProperties: *const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllProperties: fn(
            self: *const IOCSPPropertyCollection,
            pVarProperties: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_get__NewEnum(self: *const T, ppVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IOCSPPropertyCollection, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_get_Item(self: *const T, Index: i32, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).get_Item(@ptrCast(*const IOCSPPropertyCollection, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).get_Count(@ptrCast(*const IOCSPPropertyCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_get_ItemByName(self: *const T, bstrPropName: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).get_ItemByName(@ptrCast(*const IOCSPPropertyCollection, self), bstrPropName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_CreateProperty(self: *const T, bstrPropName: BSTR, pVarPropValue: *const VARIANT, ppVal: ?*?*IOCSPProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).CreateProperty(@ptrCast(*const IOCSPPropertyCollection, self), bstrPropName, pVarPropValue, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_DeleteProperty(self: *const T, bstrPropName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).DeleteProperty(@ptrCast(*const IOCSPPropertyCollection, self), bstrPropName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_InitializeFromProperties(self: *const T, pVarProperties: *const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).InitializeFromProperties(@ptrCast(*const IOCSPPropertyCollection, self), pVarProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPPropertyCollection_GetAllProperties(self: *const T, pVarProperties: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPPropertyCollection.VTable, self.vtable).GetAllProperties(@ptrCast(*const IOCSPPropertyCollection, self), pVarProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IOCSPCAConfiguration_Value = @import("../zig.zig").Guid.initString("aec92b40-3d46-433f-87d1-b84d5c1e790d");
pub const IID_IOCSPCAConfiguration = &IID_IOCSPCAConfiguration_Value;
pub const IOCSPCAConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Identifier: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CACertificate: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const IOCSPCAConfiguration,
            newVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SigningFlags: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SigningFlags: fn(
            self: *const IOCSPCAConfiguration,
            newVal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SigningCertificate: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SigningCertificate: fn(
            self: *const IOCSPCAConfiguration,
            newVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReminderDuration: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReminderDuration: fn(
            self: *const IOCSPCAConfiguration,
            newVal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCode: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CSPName: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderCLSID: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderCLSID: fn(
            self: *const IOCSPCAConfiguration,
            newVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderProperties: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderProperties: fn(
            self: *const IOCSPCAConfiguration,
            newVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modified: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalRevocationInformation: fn(
            self: *const IOCSPCAConfiguration,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalRevocationInformation: fn(
            self: *const IOCSPCAConfiguration,
            newVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SigningCertificateTemplate: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SigningCertificateTemplate: fn(
            self: *const IOCSPCAConfiguration,
            newVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAConfig: fn(
            self: *const IOCSPCAConfiguration,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAConfig: fn(
            self: *const IOCSPCAConfiguration,
            newVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_Identifier(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_Identifier(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_CACertificate(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_CACertificate(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_HashAlgorithm(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_HashAlgorithm(self: *const T, newVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_SigningFlags(self: *const T, pVal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_SigningFlags(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_SigningFlags(self: *const T, newVal: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_SigningFlags(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_SigningCertificate(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_SigningCertificate(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_SigningCertificate(self: *const T, newVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_SigningCertificate(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_ReminderDuration(self: *const T, pVal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_ReminderDuration(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_ReminderDuration(self: *const T, newVal: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_ReminderDuration(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_ErrorCode(self: *const T, pVal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_ErrorCode(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_CSPName(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_CSPName(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_KeySpec(self: *const T, pVal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_KeySpec(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_ProviderCLSID(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_ProviderCLSID(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_ProviderCLSID(self: *const T, newVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_ProviderCLSID(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_ProviderProperties(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_ProviderProperties(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_ProviderProperties(self: *const T, newVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_ProviderProperties(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_Modified(self: *const T, pVal: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_Modified(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_LocalRevocationInformation(self: *const T, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_LocalRevocationInformation(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_LocalRevocationInformation(self: *const T, newVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_LocalRevocationInformation(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_SigningCertificateTemplate(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_SigningCertificateTemplate(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_SigningCertificateTemplate(self: *const T, newVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_SigningCertificateTemplate(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_get_CAConfig(self: *const T, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).get_CAConfig(@ptrCast(*const IOCSPCAConfiguration, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfiguration_put_CAConfig(self: *const T, newVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfiguration.VTable, self.vtable).put_CAConfig(@ptrCast(*const IOCSPCAConfiguration, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IOCSPCAConfigurationCollection_Value = @import("../zig.zig").Guid.initString("2bebea0b-5ece-4f28-a91c-86b4bb20f0d3");
pub const IID_IOCSPCAConfigurationCollection = &IID_IOCSPCAConfigurationCollection_Value;
pub const IOCSPCAConfigurationCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IOCSPCAConfigurationCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IOCSPCAConfigurationCollection,
            Index: i32,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IOCSPCAConfigurationCollection,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemByName: fn(
            self: *const IOCSPCAConfigurationCollection,
            bstrIdentifier: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCAConfiguration: fn(
            self: *const IOCSPCAConfigurationCollection,
            bstrIdentifier: BSTR,
            varCACert: VARIANT,
            ppVal: ?*?*IOCSPCAConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteCAConfiguration: fn(
            self: *const IOCSPCAConfigurationCollection,
            bstrIdentifier: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IOCSPCAConfigurationCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_get_Item(self: *const T, Index: i32, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).get_Item(@ptrCast(*const IOCSPCAConfigurationCollection, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).get_Count(@ptrCast(*const IOCSPCAConfigurationCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_get_ItemByName(self: *const T, bstrIdentifier: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).get_ItemByName(@ptrCast(*const IOCSPCAConfigurationCollection, self), bstrIdentifier, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_CreateCAConfiguration(self: *const T, bstrIdentifier: BSTR, varCACert: VARIANT, ppVal: ?*?*IOCSPCAConfiguration) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).CreateCAConfiguration(@ptrCast(*const IOCSPCAConfigurationCollection, self), bstrIdentifier, varCACert, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPCAConfigurationCollection_DeleteCAConfiguration(self: *const T, bstrIdentifier: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPCAConfigurationCollection.VTable, self.vtable).DeleteCAConfiguration(@ptrCast(*const IOCSPCAConfigurationCollection, self), bstrIdentifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IOCSPAdmin_Value = @import("../zig.zig").Guid.initString("322e830d-67db-4fe9-9577-4596d9f09294");
pub const IID_IOCSPAdmin = &IID_IOCSPAdmin_Value;
pub const IOCSPAdmin = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OCSPServiceProperties: fn(
            self: *const IOCSPAdmin,
            ppVal: ?*?*IOCSPPropertyCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OCSPCAConfigurationCollection: fn(
            self: *const IOCSPAdmin,
            pVal: ?*?*IOCSPCAConfigurationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfiguration: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            bForce: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConfiguration: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            bForce: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMyRoles: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            pRoles: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Ping: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSecurity: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            bstrVal: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurity: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            pVal: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSigningCertificates: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            pCACertVar: *const VARIANT,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithms: fn(
            self: *const IOCSPAdmin,
            bstrServerName: BSTR,
            bstrCAId: BSTR,
            pVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_get_OCSPServiceProperties(self: *const T, ppVal: ?*?*IOCSPPropertyCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).get_OCSPServiceProperties(@ptrCast(*const IOCSPAdmin, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_get_OCSPCAConfigurationCollection(self: *const T, pVal: ?*?*IOCSPCAConfigurationCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).get_OCSPCAConfigurationCollection(@ptrCast(*const IOCSPAdmin, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_GetConfiguration(self: *const T, bstrServerName: BSTR, bForce: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).GetConfiguration(@ptrCast(*const IOCSPAdmin, self), bstrServerName, bForce);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_SetConfiguration(self: *const T, bstrServerName: BSTR, bForce: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).SetConfiguration(@ptrCast(*const IOCSPAdmin, self), bstrServerName, bForce);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_GetMyRoles(self: *const T, bstrServerName: BSTR, pRoles: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).GetMyRoles(@ptrCast(*const IOCSPAdmin, self), bstrServerName, pRoles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_Ping(self: *const T, bstrServerName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).Ping(@ptrCast(*const IOCSPAdmin, self), bstrServerName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_SetSecurity(self: *const T, bstrServerName: BSTR, bstrVal: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).SetSecurity(@ptrCast(*const IOCSPAdmin, self), bstrServerName, bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_GetSecurity(self: *const T, bstrServerName: BSTR, pVal: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).GetSecurity(@ptrCast(*const IOCSPAdmin, self), bstrServerName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_GetSigningCertificates(self: *const T, bstrServerName: BSTR, pCACertVar: *const VARIANT, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).GetSigningCertificates(@ptrCast(*const IOCSPAdmin, self), bstrServerName, pCACertVar, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOCSPAdmin_GetHashAlgorithms(self: *const T, bstrServerName: BSTR, bstrCAId: BSTR, pVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOCSPAdmin.VTable, self.vtable).GetHashAlgorithms(@ptrCast(*const IOCSPAdmin, self), bstrServerName, bstrCAId, pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OCSPSigningFlag = extern enum(i32) {
    SILENT = 1,
    USE_CACERT = 2,
    ALLOW_SIGNINGCERT_AUTORENEWAL = 4,
    FORCE_SIGNINGCERT_ISSUER_ISCA = 8,
    AUTODISCOVER_SIGNINGCERT = 16,
    MANUAL_ASSIGN_SIGNINGCERT = 32,
    RESPONDER_ID_KEYHASH = 64,
    RESPONDER_ID_NAME = 128,
    ALLOW_NONCE_EXTENSION = 256,
    ALLOW_SIGNINGCERT_AUTOENROLLMENT = 512,
};
pub const OCSP_SF_SILENT = OCSPSigningFlag.SILENT;
pub const OCSP_SF_USE_CACERT = OCSPSigningFlag.USE_CACERT;
pub const OCSP_SF_ALLOW_SIGNINGCERT_AUTORENEWAL = OCSPSigningFlag.ALLOW_SIGNINGCERT_AUTORENEWAL;
pub const OCSP_SF_FORCE_SIGNINGCERT_ISSUER_ISCA = OCSPSigningFlag.FORCE_SIGNINGCERT_ISSUER_ISCA;
pub const OCSP_SF_AUTODISCOVER_SIGNINGCERT = OCSPSigningFlag.AUTODISCOVER_SIGNINGCERT;
pub const OCSP_SF_MANUAL_ASSIGN_SIGNINGCERT = OCSPSigningFlag.MANUAL_ASSIGN_SIGNINGCERT;
pub const OCSP_SF_RESPONDER_ID_KEYHASH = OCSPSigningFlag.RESPONDER_ID_KEYHASH;
pub const OCSP_SF_RESPONDER_ID_NAME = OCSPSigningFlag.RESPONDER_ID_NAME;
pub const OCSP_SF_ALLOW_NONCE_EXTENSION = OCSPSigningFlag.ALLOW_NONCE_EXTENSION;
pub const OCSP_SF_ALLOW_SIGNINGCERT_AUTOENROLLMENT = OCSPSigningFlag.ALLOW_SIGNINGCERT_AUTOENROLLMENT;

pub const OCSPRequestFlag = extern enum(i32) {
    S = 1,
};
pub const OCSP_RF_REJECT_SIGNED_REQUESTS = OCSPRequestFlag.S;

const CLSID_CCertEncodeStringArray_Value = @import("../zig.zig").Guid.initString("19a76fe0-7494-11d0-8816-00a0c903b83c");
pub const CLSID_CCertEncodeStringArray = &CLSID_CCertEncodeStringArray_Value;

const CLSID_CCertEncodeLongArray_Value = @import("../zig.zig").Guid.initString("4e0680a0-a0a2-11d0-8821-00a0c903b83c");
pub const CLSID_CCertEncodeLongArray = &CLSID_CCertEncodeLongArray_Value;

const CLSID_CCertEncodeDateArray_Value = @import("../zig.zig").Guid.initString("301f77b0-a470-11d0-8821-00a0c903b83c");
pub const CLSID_CCertEncodeDateArray = &CLSID_CCertEncodeDateArray_Value;

const CLSID_CCertEncodeCRLDistInfo_Value = @import("../zig.zig").Guid.initString("01fa60a0-bbff-11d0-8825-00a0c903b83c");
pub const CLSID_CCertEncodeCRLDistInfo = &CLSID_CCertEncodeCRLDistInfo_Value;

const CLSID_CCertEncodeAltName_Value = @import("../zig.zig").Guid.initString("1cfc4cda-1271-11d1-9bd4-00c04fb683fa");
pub const CLSID_CCertEncodeAltName = &CLSID_CCertEncodeAltName_Value;

const CLSID_CCertEncodeBitString_Value = @import("../zig.zig").Guid.initString("6d6b3cd8-1278-11d1-9bd4-00c04fb683fa");
pub const CLSID_CCertEncodeBitString = &CLSID_CCertEncodeBitString_Value;

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeStringArray_Value = @import("../zig.zig").Guid.initString("12a88820-7494-11d0-8816-00a0c903b83c");
pub const IID_ICertEncodeStringArray = &IID_ICertEncodeStringArray_Value;
pub const ICertEncodeStringArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeStringArray,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringType: fn(
            self: *const ICertEncodeStringArray,
            pStringType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ICertEncodeStringArray,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ICertEncodeStringArray,
            Index: i32,
            pstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICertEncodeStringArray,
            Count: i32,
            StringType: CERT_RDN_ATTR_VALUE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ICertEncodeStringArray,
            Index: i32,
            str: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeStringArray,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeStringArray, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_GetStringType(self: *const T, pStringType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).GetStringType(@ptrCast(*const ICertEncodeStringArray, self), pStringType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).GetCount(@ptrCast(*const ICertEncodeStringArray, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_GetValue(self: *const T, Index: i32, pstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).GetValue(@ptrCast(*const ICertEncodeStringArray, self), Index, pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_Reset(self: *const T, Count: i32, StringType: CERT_RDN_ATTR_VALUE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).Reset(@ptrCast(*const ICertEncodeStringArray, self), Count, StringType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_SetValue(self: *const T, Index: i32, str: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).SetValue(@ptrCast(*const ICertEncodeStringArray, self), Index, str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray_Encode(self: *const T, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeStringArray, self), pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeStringArray2_Value = @import("../zig.zig").Guid.initString("9c680d93-9b7d-4e95-9018-4ffe10ba5ada");
pub const IID_ICertEncodeStringArray2 = &IID_ICertEncodeStringArray2_Value;
pub const ICertEncodeStringArray2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeStringArray.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeStringArray2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeStringArray2,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeStringArray.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeStringArray2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeStringArray2_EncodeBlob(self: *const T, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeStringArray2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeStringArray2, self), Encoding, pstrEncodedData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeLongArray_Value = @import("../zig.zig").Guid.initString("15e2f230-a0a2-11d0-8821-00a0c903b83c");
pub const IID_ICertEncodeLongArray = &IID_ICertEncodeLongArray_Value;
pub const ICertEncodeLongArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeLongArray,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ICertEncodeLongArray,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ICertEncodeLongArray,
            Index: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICertEncodeLongArray,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ICertEncodeLongArray,
            Index: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeLongArray,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeLongArray, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).GetCount(@ptrCast(*const ICertEncodeLongArray, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_GetValue(self: *const T, Index: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).GetValue(@ptrCast(*const ICertEncodeLongArray, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_Reset(self: *const T, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).Reset(@ptrCast(*const ICertEncodeLongArray, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_SetValue(self: *const T, Index: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).SetValue(@ptrCast(*const ICertEncodeLongArray, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray_Encode(self: *const T, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeLongArray, self), pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeLongArray2_Value = @import("../zig.zig").Guid.initString("4efde84a-bd9b-4fc2-a108-c347d478840f");
pub const IID_ICertEncodeLongArray2 = &IID_ICertEncodeLongArray2_Value;
pub const ICertEncodeLongArray2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeLongArray.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeLongArray2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeLongArray2,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeLongArray.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeLongArray2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeLongArray2_EncodeBlob(self: *const T, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeLongArray2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeLongArray2, self), Encoding, pstrEncodedData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeDateArray_Value = @import("../zig.zig").Guid.initString("2f9469a0-a470-11d0-8821-00a0c903b83c");
pub const IID_ICertEncodeDateArray = &IID_ICertEncodeDateArray_Value;
pub const ICertEncodeDateArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeDateArray,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ICertEncodeDateArray,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ICertEncodeDateArray,
            Index: i32,
            pValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICertEncodeDateArray,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ICertEncodeDateArray,
            Index: i32,
            Value: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeDateArray,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeDateArray, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).GetCount(@ptrCast(*const ICertEncodeDateArray, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_GetValue(self: *const T, Index: i32, pValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).GetValue(@ptrCast(*const ICertEncodeDateArray, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_Reset(self: *const T, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).Reset(@ptrCast(*const ICertEncodeDateArray, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_SetValue(self: *const T, Index: i32, Value: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).SetValue(@ptrCast(*const ICertEncodeDateArray, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray_Encode(self: *const T, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeDateArray, self), pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeDateArray2_Value = @import("../zig.zig").Guid.initString("99a4edb5-2b8e-448d-bf95-bba8d7789dc8");
pub const IID_ICertEncodeDateArray2 = &IID_ICertEncodeDateArray2_Value;
pub const ICertEncodeDateArray2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeDateArray.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeDateArray2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeDateArray2,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeDateArray.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeDateArray2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeDateArray2_EncodeBlob(self: *const T, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeDateArray2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeDateArray2, self), Encoding, pstrEncodedData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeCRLDistInfo_Value = @import("../zig.zig").Guid.initString("01958640-bbff-11d0-8825-00a0c903b83c");
pub const IID_ICertEncodeCRLDistInfo = &IID_ICertEncodeCRLDistInfo_Value;
pub const ICertEncodeCRLDistInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeCRLDistInfo,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDistPointCount: fn(
            self: *const ICertEncodeCRLDistInfo,
            pDistPointCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameCount: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointIndex: i32,
            pNameCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameChoice: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointIndex: i32,
            NameIndex: i32,
            pNameChoice: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointIndex: i32,
            NameIndex: i32,
            pstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNameCount: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointIndex: i32,
            NameCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNameEntry: fn(
            self: *const ICertEncodeCRLDistInfo,
            DistPointIndex: i32,
            NameIndex: i32,
            NameChoice: CERT_ALT_NAME,
            strName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeCRLDistInfo,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeCRLDistInfo, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_GetDistPointCount(self: *const T, pDistPointCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).GetDistPointCount(@ptrCast(*const ICertEncodeCRLDistInfo, self), pDistPointCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_GetNameCount(self: *const T, DistPointIndex: i32, pNameCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).GetNameCount(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointIndex, pNameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_GetNameChoice(self: *const T, DistPointIndex: i32, NameIndex: i32, pNameChoice: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).GetNameChoice(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointIndex, NameIndex, pNameChoice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_GetName(self: *const T, DistPointIndex: i32, NameIndex: i32, pstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).GetName(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointIndex, NameIndex, pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_Reset(self: *const T, DistPointCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).Reset(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_SetNameCount(self: *const T, DistPointIndex: i32, NameCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).SetNameCount(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointIndex, NameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_SetNameEntry(self: *const T, DistPointIndex: i32, NameIndex: i32, NameChoice: CERT_ALT_NAME, strName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).SetNameEntry(@ptrCast(*const ICertEncodeCRLDistInfo, self), DistPointIndex, NameIndex, NameChoice, strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo_Encode(self: *const T, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeCRLDistInfo, self), pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeCRLDistInfo2_Value = @import("../zig.zig").Guid.initString("b4275d4b-3e30-446f-ad36-09d03120b078");
pub const IID_ICertEncodeCRLDistInfo2 = &IID_ICertEncodeCRLDistInfo2_Value;
pub const ICertEncodeCRLDistInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeCRLDistInfo.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeCRLDistInfo2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeCRLDistInfo2,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeCRLDistInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeCRLDistInfo2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeCRLDistInfo2_EncodeBlob(self: *const T, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeCRLDistInfo2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeCRLDistInfo2, self), Encoding, pstrEncodedData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeAltName_Value = @import("../zig.zig").Guid.initString("1c9a8c70-1271-11d1-9bd4-00c04fb683fa");
pub const IID_ICertEncodeAltName = &IID_ICertEncodeAltName_Value;
pub const ICertEncodeAltName = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeAltName,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameCount: fn(
            self: *const ICertEncodeAltName,
            pNameCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameChoice: fn(
            self: *const ICertEncodeAltName,
            NameIndex: i32,
            pNameChoice: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ICertEncodeAltName,
            NameIndex: i32,
            pstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICertEncodeAltName,
            NameCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNameEntry: fn(
            self: *const ICertEncodeAltName,
            NameIndex: i32,
            NameChoice: CERT_ALT_NAME,
            strName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeAltName,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeAltName, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_GetNameCount(self: *const T, pNameCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).GetNameCount(@ptrCast(*const ICertEncodeAltName, self), pNameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_GetNameChoice(self: *const T, NameIndex: i32, pNameChoice: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).GetNameChoice(@ptrCast(*const ICertEncodeAltName, self), NameIndex, pNameChoice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_GetName(self: *const T, NameIndex: i32, pstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).GetName(@ptrCast(*const ICertEncodeAltName, self), NameIndex, pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_Reset(self: *const T, NameCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).Reset(@ptrCast(*const ICertEncodeAltName, self), NameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_SetNameEntry(self: *const T, NameIndex: i32, NameChoice: CERT_ALT_NAME, strName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).SetNameEntry(@ptrCast(*const ICertEncodeAltName, self), NameIndex, NameChoice, strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName_Encode(self: *const T, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeAltName, self), pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeAltName2_Value = @import("../zig.zig").Guid.initString("f67fe177-5ef1-4535-b4ce-29df15e2e0c3");
pub const IID_ICertEncodeAltName2 = &IID_ICertEncodeAltName2_Value;
pub const ICertEncodeAltName2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeAltName.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeAltName2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeAltName2,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameBlob: fn(
            self: *const ICertEncodeAltName2,
            NameIndex: i32,
            Encoding: EncodingType,
            pstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNameEntryBlob: fn(
            self: *const ICertEncodeAltName2,
            NameIndex: i32,
            NameChoice: i32,
            strName: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeAltName.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeAltName2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName2_EncodeBlob(self: *const T, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeAltName2, self), Encoding, pstrEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName2_GetNameBlob(self: *const T, NameIndex: i32, Encoding: EncodingType, pstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName2.VTable, self.vtable).GetNameBlob(@ptrCast(*const ICertEncodeAltName2, self), NameIndex, Encoding, pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeAltName2_SetNameEntryBlob(self: *const T, NameIndex: i32, NameChoice: i32, strName: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeAltName2.VTable, self.vtable).SetNameEntryBlob(@ptrCast(*const ICertEncodeAltName2, self), NameIndex, NameChoice, strName, Encoding);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertEncodeBitString_Value = @import("../zig.zig").Guid.initString("6db525be-1278-11d1-9bd4-00c04fb683fa");
pub const IID_ICertEncodeBitString = &IID_ICertEncodeBitString_Value;
pub const ICertEncodeBitString = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Decode: fn(
            self: *const ICertEncodeBitString,
            strBinary: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitCount: fn(
            self: *const ICertEncodeBitString,
            pBitCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitString: fn(
            self: *const ICertEncodeBitString,
            pstrBitString: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Encode: fn(
            self: *const ICertEncodeBitString,
            BitCount: i32,
            strBitString: BSTR,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString_Decode(self: *const T, strBinary: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString.VTable, self.vtable).Decode(@ptrCast(*const ICertEncodeBitString, self), strBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString_GetBitCount(self: *const T, pBitCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString.VTable, self.vtable).GetBitCount(@ptrCast(*const ICertEncodeBitString, self), pBitCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString_GetBitString(self: *const T, pstrBitString: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString.VTable, self.vtable).GetBitString(@ptrCast(*const ICertEncodeBitString, self), pstrBitString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString_Encode(self: *const T, BitCount: i32, strBitString: BSTR, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString.VTable, self.vtable).Encode(@ptrCast(*const ICertEncodeBitString, self), BitCount, strBitString, pstrBinary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICertEncodeBitString2_Value = @import("../zig.zig").Guid.initString("e070d6e7-23ef-4dd2-8242-ebd9c928cb30");
pub const IID_ICertEncodeBitString2 = &IID_ICertEncodeBitString2_Value;
pub const ICertEncodeBitString2 = extern struct {
    pub const VTable = extern struct {
        base: ICertEncodeBitString.VTable,
        DecodeBlob: fn(
            self: *const ICertEncodeBitString2,
            strEncodedData: BSTR,
            Encoding: EncodingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeBlob: fn(
            self: *const ICertEncodeBitString2,
            BitCount: i32,
            strBitString: BSTR,
            EncodingIn: EncodingType,
            Encoding: EncodingType,
            pstrEncodedData: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitStringBlob: fn(
            self: *const ICertEncodeBitString2,
            Encoding: EncodingType,
            pstrBitString: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertEncodeBitString.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString2_DecodeBlob(self: *const T, strEncodedData: BSTR, Encoding: EncodingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString2.VTable, self.vtable).DecodeBlob(@ptrCast(*const ICertEncodeBitString2, self), strEncodedData, Encoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString2_EncodeBlob(self: *const T, BitCount: i32, strBitString: BSTR, EncodingIn: EncodingType, Encoding: EncodingType, pstrEncodedData: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString2.VTable, self.vtable).EncodeBlob(@ptrCast(*const ICertEncodeBitString2, self), BitCount, strBitString, EncodingIn, Encoding, pstrEncodedData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertEncodeBitString2_GetBitStringBlob(self: *const T, Encoding: EncodingType, pstrBitString: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertEncodeBitString2.VTable, self.vtable).GetBitStringBlob(@ptrCast(*const ICertEncodeBitString2, self), Encoding, pstrBitString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertExit_Value = @import("../zig.zig").Guid.initString("e19ae1a0-7364-11d0-8816-00a0c903b83c");
pub const IID_ICertExit = &IID_ICertExit_Value;
pub const ICertExit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const ICertExit,
            strConfig: BSTR,
            pEventMask: *CERT_EXIT_EVENT_MASK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ICertExit,
            ExitEvent: i32,
            Context: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const ICertExit,
            pstrDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertExit_Initialize(self: *const T, strConfig: BSTR, pEventMask: *CERT_EXIT_EVENT_MASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertExit.VTable, self.vtable).Initialize(@ptrCast(*const ICertExit, self), strConfig, pEventMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertExit_Notify(self: *const T, ExitEvent: i32, Context: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertExit.VTable, self.vtable).Notify(@ptrCast(*const ICertExit, self), ExitEvent, Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertExit_GetDescription(self: *const T, pstrDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertExit.VTable, self.vtable).GetDescription(@ptrCast(*const ICertExit, self), pstrDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_ICertExit2_Value = @import("../zig.zig").Guid.initString("0abf484b-d049-464d-a7ed-552e7529b0ff");
pub const IID_ICertExit2 = &IID_ICertExit2_Value;
pub const ICertExit2 = extern struct {
    pub const VTable = extern struct {
        base: ICertExit.VTable,
        GetManageModule: fn(
            self: *const ICertExit2,
            ppManageModule: **ICertManageModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICertExit.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertExit2_GetManageModule(self: *const T, ppManageModule: **ICertManageModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertExit2.VTable, self.vtable).GetManageModule(@ptrCast(*const ICertExit2, self), ppManageModule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ENUM_CATYPES = extern enum(i32) {
    ENTERPRISE_ROOTCA = 0,
    ENTERPRISE_SUBCA = 1,
    STANDALONE_ROOTCA = 3,
    STANDALONE_SUBCA = 4,
    UNKNOWN_CA = 5,
};
pub const ENUM_ENTERPRISE_ROOTCA = ENUM_CATYPES.ENTERPRISE_ROOTCA;
pub const ENUM_ENTERPRISE_SUBCA = ENUM_CATYPES.ENTERPRISE_SUBCA;
pub const ENUM_STANDALONE_ROOTCA = ENUM_CATYPES.STANDALONE_ROOTCA;
pub const ENUM_STANDALONE_SUBCA = ENUM_CATYPES.STANDALONE_SUBCA;
pub const ENUM_UNKNOWN_CA = ENUM_CATYPES.UNKNOWN_CA;

pub const CAINFO = extern struct {
    cbSize: u32,
    CAType: ENUM_CATYPES,
    cCASignatureCerts: u32,
    cCAExchangeCerts: u32,
    cExitModules: u32,
    lPropIdMax: i32,
    lRoleSeparationEnabled: i32,
    cKRACertUsedCount: u32,
    cKRACertCount: u32,
    fAdvancedServer: u32,
};

pub const ENUM_PERIOD = extern enum(i32) {
    INVALID = -1,
    SECONDS = 0,
    MINUTES = 1,
    HOURS = 2,
    DAYS = 3,
    WEEKS = 4,
    MONTHS = 5,
    YEARS = 6,
};
pub const ENUM_PERIOD_INVALID = ENUM_PERIOD.INVALID;
pub const ENUM_PERIOD_SECONDS = ENUM_PERIOD.SECONDS;
pub const ENUM_PERIOD_MINUTES = ENUM_PERIOD.MINUTES;
pub const ENUM_PERIOD_HOURS = ENUM_PERIOD.HOURS;
pub const ENUM_PERIOD_DAYS = ENUM_PERIOD.DAYS;
pub const ENUM_PERIOD_WEEKS = ENUM_PERIOD.WEEKS;
pub const ENUM_PERIOD_MONTHS = ENUM_PERIOD.MONTHS;
pub const ENUM_PERIOD_YEARS = ENUM_PERIOD.YEARS;

pub const LLFILETIME = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNCMFILTERPROC = fn(
    pCertContext: *CERT_CONTEXT,
    param1: LPARAM,
    param2: u32,
    param3: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFNCMHOOKPROC = fn(
    hwndDialog: HWND,
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CERT_SELECT_STRUCT_A = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    pTemplateName: [*:0]const u8,
    dwFlags: CERT_SELECT_STRUCT_FLAGS,
    szTitle: [*:0]const u8,
    cCertStore: u32,
    arrayCertStore: **c_void,
    szPurposeOid: [*:0]const u8,
    cCertContext: u32,
    arrayCertContext: **CERT_CONTEXT,
    lCustData: LPARAM,
    pfnHook: PFNCMHOOKPROC,
    pfnFilter: PFNCMFILTERPROC,
    szHelpFileName: [*:0]const u8,
    dwHelpId: u32,
    hprov: usize,
};

pub const CERT_SELECT_STRUCT_W = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    pTemplateName: [*:0]const u16,
    dwFlags: CERT_SELECT_STRUCT_FLAGS,
    szTitle: [*:0]const u16,
    cCertStore: u32,
    arrayCertStore: **c_void,
    szPurposeOid: [*:0]const u8,
    cCertContext: u32,
    arrayCertContext: **CERT_CONTEXT,
    lCustData: LPARAM,
    pfnHook: PFNCMHOOKPROC,
    pfnFilter: PFNCMFILTERPROC,
    szHelpFileName: [*:0]const u16,
    dwHelpId: u32,
    hprov: usize,
};

pub const CERT_VIEWPROPERTIES_STRUCT_A = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwFlags: CERT_VIEWPROPERTIES_STRUCT_FLAGS,
    szTitle: [*:0]const u8,
    pCertContext: *CERT_CONTEXT,
    arrayPurposes: *PSTR,
    cArrayPurposes: u32,
    cRootStores: u32,
    rghstoreRoots: **c_void,
    cStores: u32,
    rghstoreCAs: **c_void,
    cTrustStores: u32,
    rghstoreTrust: **c_void,
    hprov: usize,
    lCustData: LPARAM,
    dwPad: u32,
    szHelpFileName: [*:0]const u8,
    dwHelpId: u32,
    nStartPage: u32,
    cArrayPropSheetPages: u32,
    arrayPropSheetPages: *PROPSHEETPAGEA,
};

pub const CERT_VIEWPROPERTIES_STRUCT_W = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwFlags: CERT_VIEWPROPERTIES_STRUCT_FLAGS,
    szTitle: [*:0]const u16,
    pCertContext: *CERT_CONTEXT,
    arrayPurposes: *PSTR,
    cArrayPurposes: u32,
    cRootStores: u32,
    rghstoreRoots: **c_void,
    cStores: u32,
    rghstoreCAs: **c_void,
    cTrustStores: u32,
    rghstoreTrust: **c_void,
    hprov: usize,
    lCustData: LPARAM,
    dwPad: u32,
    szHelpFileName: [*:0]const u16,
    dwHelpId: u32,
    nStartPage: u32,
    cArrayPropSheetPages: u32,
    arrayPropSheetPages: *PROPSHEETPAGEA,
};

pub const CMOID = extern struct {
    szExtensionOID: [*:0]const u8,
    dwTestOperation: u32,
    pbTestData: *u8,
    cbTestData: u32,
};

pub const CMFLTR = extern struct {
    dwSize: u32,
    cExtensionChecks: u32,
    arrayExtensionChecks: *CMOID,
    dwCheckingFlags: u32,
};

pub const PFNTRUSTHELPER = fn(
    pCertContext: *CERT_CONTEXT,
    lCustData: LPARAM,
    fLeafCertificate: BOOL,
    pbTrustBlob: *u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CERT_VERIFY_CERTIFICATE_TRUST = extern struct {
    cbSize: u32,
    pccert: *CERT_CONTEXT,
    dwFlags: u32,
    dwIgnoreErr: u32,
    pdwErrors: *u32,
    pszUsageOid: PSTR,
    hprov: usize,
    cRootStores: u32,
    rghstoreRoots: **c_void,
    cStores: u32,
    rghstoreCAs: **c_void,
    cTrustStores: u32,
    rghstoreTrust: **c_void,
    lCustData: LPARAM,
    pfnTrustHelper: PFNTRUSTHELPER,
    pcChain: *u32,
    prgChain: ***CERT_CONTEXT,
    prgdwErrors: **u32,
    prgpbTrustInfo: **CRYPTOAPI_BLOB,
};

pub const CTL_MODIFY_REQUEST = extern struct {
    pccert: *CERT_CONTEXT,
    dwOperation: CTL_MODIFY_REQUEST_OPERATION,
    dwError: u32,
};

pub const WINTRUST_DATA = extern struct {
    cbStruct: u32,
    pPolicyCallbackData: *c_void,
    pSIPClientData: *c_void,
    dwUIChoice: WINTRUST_DATA_UICHOICE,
    fdwRevocationChecks: WINTRUST_DATA_REVOCATION_CHECKS,
    dwUnionChoice: WINTRUST_DATA_UNION_CHOICE,
    Anonymous: _Anonymous_e__Union,
    dwStateAction: WINTRUST_DATA_STATE_ACTION,
    hWVTStateData: HANDLE,
    pwszURLReference: PWSTR,
    dwProvFlags: u32,
    dwUIContext: WINTRUST_DATA_UICONTEXT,
    pSignatureSettings: *WINTRUST_SIGNATURE_SETTINGS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WINTRUST_SIGNATURE_SETTINGS = extern struct {
    cbStruct: u32,
    dwIndex: u32,
    dwFlags: WINTRUST_SIGNATURE_SETTINGS_FLAGS,
    cSecondarySigs: u32,
    dwVerifiedSigIndex: u32,
    pCryptoPolicy: *CERT_STRONG_SIGN_PARA,
};

pub const WINTRUST_FILE_INFO = extern struct {
    cbStruct: u32,
    pcwszFilePath: [*:0]const u16,
    hFile: HANDLE,
    pgKnownSubject: *Guid,
};

pub const WINTRUST_CATALOG_INFO = extern struct {
    cbStruct: u32,
    dwCatalogVersion: u32,
    pcwszCatalogFilePath: [*:0]const u16,
    pcwszMemberTag: [*:0]const u16,
    pcwszMemberFilePath: [*:0]const u16,
    hMemberFile: HANDLE,
    pbCalculatedFileHash: *u8,
    cbCalculatedFileHash: u32,
    pcCatalogContext: *CTL_CONTEXT,
    hCatAdmin: isize,
};

pub const WINTRUST_BLOB_INFO = extern struct {
    cbStruct: u32,
    gSubject: Guid,
    pcwszDisplayName: [*:0]const u16,
    cbMemObject: u32,
    pbMemObject: *u8,
    cbMemSignedMsg: u32,
    pbMemSignedMsg: *u8,
};

pub const WINTRUST_SGNR_INFO = extern struct {
    cbStruct: u32,
    pcwszDisplayName: [*:0]const u16,
    psSignerInfo: *CMSG_SIGNER_INFO,
    chStores: u32,
    pahStores: **c_void,
};

pub const WINTRUST_CERT_INFO = extern struct {
    cbStruct: u32,
    pcwszDisplayName: [*:0]const u16,
    psCertContext: *CERT_CONTEXT,
    chStores: u32,
    pahStores: **c_void,
    dwFlags: u32,
    psftVerifyAsOf: *FILETIME,
};

pub const PFN_CPD_MEM_ALLOC = fn(
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_CPD_MEM_FREE = fn(
    pvMem2Free: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CPD_ADD_STORE = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
    hStore2Add: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_SGNR = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
    fCounterSigner: BOOL,
    idxSigner: u32,
    pSgnr2Add: *CRYPT_PROVIDER_SGNR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_CERT = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
    pCert2Add: *CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_PRIVDATA = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
    pPrivData2Add: *CRYPT_PROVIDER_PRIVDATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_PROVIDER_INIT_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_OBJTRUST_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_SIGTRUST_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CERTTRUST_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_FINALPOLICY_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_TESTFINALPOLICY_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CLEANUP_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CERTCHKPOLICY_CALL = fn(
    pProvData: *CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSignerChain: BOOL,
    idxCounterSigner: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVIDER_DATA = extern struct {
    cbStruct: u32,
    pWintrustData: *WINTRUST_DATA,
    fOpenedFile: BOOL,
    hWndParent: HWND,
    pgActionID: *Guid,
    hProv: usize,
    dwError: u32,
    dwRegSecuritySettings: u32,
    dwRegPolicySettings: u32,
    psPfns: *CRYPT_PROVIDER_FUNCTIONS,
    cdwTrustStepErrors: u32,
    padwTrustStepErrors: *u32,
    chStores: u32,
    pahStores: **c_void,
    dwEncoding: u32,
    hMsg: *c_void,
    csSigners: u32,
    pasSigners: *CRYPT_PROVIDER_SGNR,
    csProvPrivData: u32,
    pasProvPrivData: *CRYPT_PROVIDER_PRIVDATA,
    dwSubjectChoice: u32,
    Anonymous: _Anonymous_e__Union,
    pszUsageOID: PSTR,
    fRecallWithState: BOOL,
    sftSystemTime: FILETIME,
    pszCTLSignerUsageOID: PSTR,
    dwProvFlags: u32,
    dwFinalError: u32,
    pRequestUsage: *CERT_USAGE_MATCH,
    dwTrustPubSettings: u32,
    dwUIStateFlags: u32,
    pSigState: *CRYPT_PROVIDER_SIGSTATE,
    pSigSettings: *WINTRUST_SIGNATURE_SETTINGS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPT_PROVIDER_SIGSTATE = extern struct {
    cbStruct: u32,
    rhSecondarySigs: **c_void,
    hPrimarySig: *c_void,
    fFirstAttemptMade: BOOL,
    fNoMoreSigs: BOOL,
    cSecondarySigs: u32,
    dwCurrentIndex: u32,
    fSupportMultiSig: BOOL,
    dwCryptoPolicySupport: u32,
    iAttemptCount: u32,
    fCheckedSealing: BOOL,
    pSealingSignature: *SEALING_SIGNATURE_ATTRIBUTE,
};

pub const CRYPT_PROVIDER_FUNCTIONS = extern struct {
    cbStruct: u32,
    pfnAlloc: PFN_CPD_MEM_ALLOC,
    pfnFree: PFN_CPD_MEM_FREE,
    pfnAddStore2Chain: PFN_CPD_ADD_STORE,
    pfnAddSgnr2Chain: PFN_CPD_ADD_SGNR,
    pfnAddCert2Chain: PFN_CPD_ADD_CERT,
    pfnAddPrivData2Chain: PFN_CPD_ADD_PRIVDATA,
    pfnInitialize: PFN_PROVIDER_INIT_CALL,
    pfnObjectTrust: PFN_PROVIDER_OBJTRUST_CALL,
    pfnSignatureTrust: PFN_PROVIDER_SIGTRUST_CALL,
    pfnCertificateTrust: PFN_PROVIDER_CERTTRUST_CALL,
    pfnFinalPolicy: PFN_PROVIDER_FINALPOLICY_CALL,
    pfnCertCheckPolicy: PFN_PROVIDER_CERTCHKPOLICY_CALL,
    pfnTestFinalPolicy: PFN_PROVIDER_TESTFINALPOLICY_CALL,
    psUIpfns: *CRYPT_PROVUI_FUNCS,
    pfnCleanupPolicy: PFN_PROVIDER_CLEANUP_CALL,
};

pub const PFN_PROVUI_CALL = fn(
    hWndSecurityDialog: HWND,
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVUI_FUNCS = extern struct {
    cbStruct: u32,
    psUIData: *CRYPT_PROVUI_DATA,
    pfnOnMoreInfoClick: PFN_PROVUI_CALL,
    pfnOnMoreInfoClickDefault: PFN_PROVUI_CALL,
    pfnOnAdvancedClick: PFN_PROVUI_CALL,
    pfnOnAdvancedClickDefault: PFN_PROVUI_CALL,
};

pub const CRYPT_PROVUI_DATA = extern struct {
    cbStruct: u32,
    dwFinalError: u32,
    pYesButtonText: PWSTR,
    pNoButtonText: PWSTR,
    pMoreInfoButtonText: PWSTR,
    pAdvancedLinkText: PWSTR,
    pCopyActionText: PWSTR,
    pCopyActionTextNoTS: PWSTR,
    pCopyActionTextNotSigned: PWSTR,
};

pub const CRYPT_PROVIDER_SGNR = extern struct {
    cbStruct: u32,
    sftVerifyAsOf: FILETIME,
    csCertChain: u32,
    pasCertChain: *CRYPT_PROVIDER_CERT,
    dwSignerType: u32,
    psSigner: *CMSG_SIGNER_INFO,
    dwError: u32,
    csCounterSigners: u32,
    pasCounterSigners: *CRYPT_PROVIDER_SGNR,
    pChainContext: *CERT_CHAIN_CONTEXT,
};

pub const CRYPT_PROVIDER_CERT = extern struct {
    cbStruct: u32,
    pCert: *CERT_CONTEXT,
    fCommercial: BOOL,
    fTrustedRoot: BOOL,
    fSelfSigned: BOOL,
    fTestCert: BOOL,
    dwRevokedReason: u32,
    dwConfidence: u32,
    dwError: u32,
    pTrustListContext: *CTL_CONTEXT,
    fTrustListSignerCert: BOOL,
    pCtlContext: *CTL_CONTEXT,
    dwCtlError: u32,
    fIsCyclic: BOOL,
    pChainElement: *CERT_CHAIN_ELEMENT,
};

pub const CRYPT_PROVIDER_PRIVDATA = extern struct {
    cbStruct: u32,
    gProviderID: Guid,
    cbProvData: u32,
    pvProvData: *c_void,
};

pub const PROVDATA_SIP = extern struct {
    cbStruct: u32,
    gSubject: Guid,
    pSip: *SIP_DISPATCH_INFO,
    pCATSip: *SIP_DISPATCH_INFO,
    psSipSubjectInfo: *SIP_SUBJECTINFO,
    psSipCATSubjectInfo: *SIP_SUBJECTINFO,
    psIndirectData: *SIP_INDIRECT_DATA,
};

pub const CRYPT_TRUST_REG_ENTRY = extern struct {
    cbStruct: u32,
    pwszDLLName: PWSTR,
    pwszFunctionName: PWSTR,
};

pub const CRYPT_REGISTER_ACTIONID = extern struct {
    cbStruct: u32,
    sInitProvider: CRYPT_TRUST_REG_ENTRY,
    sObjectProvider: CRYPT_TRUST_REG_ENTRY,
    sSignatureProvider: CRYPT_TRUST_REG_ENTRY,
    sCertificateProvider: CRYPT_TRUST_REG_ENTRY,
    sCertificatePolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sFinalPolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sTestPolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sCleanupProvider: CRYPT_TRUST_REG_ENTRY,
};

pub const PFN_ALLOCANDFILLDEFUSAGE = fn(
    pszUsageOID: [*:0]const u8,
    psDefUsage: *CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_FREEDEFUSAGE = fn(
    pszUsageOID: [*:0]const u8,
    psDefUsage: *CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVIDER_REGDEFUSAGE = extern struct {
    cbStruct: u32,
    pgActionID: *Guid,
    pwszDllName: PWSTR,
    pwszLoadCallbackDataFunctionName: PSTR,
    pwszFreeCallbackDataFunctionName: PSTR,
};

pub const CRYPT_PROVIDER_DEFUSAGE = extern struct {
    cbStruct: u32,
    gActionID: Guid,
    pDefPolicyCallbackData: *c_void,
    pDefSIPClientData: *c_void,
};

pub const SPC_SERIALIZED_OBJECT = extern struct {
    ClassId: [16]u8,
    SerializedData: CRYPTOAPI_BLOB,
};

pub const SPC_SIGINFO = extern struct {
    dwSipVersion: u32,
    gSIPGuid: Guid,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
    dwReserved5: u32,
};

pub const SPC_LINK = extern struct {
    dwLinkChoice: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SPC_PE_IMAGE_DATA = extern struct {
    Flags: CRYPT_BIT_BLOB,
    pFile: *SPC_LINK,
};

pub const SPC_INDIRECT_DATA_CONTENT = extern struct {
    Data: CRYPT_ATTRIBUTE_TYPE_VALUE,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Digest: CRYPTOAPI_BLOB,
};

pub const SPC_FINANCIAL_CRITERIA = extern struct {
    fFinancialInfoAvailable: BOOL,
    fMeetsCriteria: BOOL,
};

pub const SPC_IMAGE = extern struct {
    pImageLink: *SPC_LINK,
    Bitmap: CRYPTOAPI_BLOB,
    Metafile: CRYPTOAPI_BLOB,
    EnhancedMetafile: CRYPTOAPI_BLOB,
    GifFile: CRYPTOAPI_BLOB,
};

pub const SPC_SP_AGENCY_INFO = extern struct {
    pPolicyInformation: *SPC_LINK,
    pwszPolicyDisplayText: PWSTR,
    pLogoImage: *SPC_IMAGE,
    pLogoLink: *SPC_LINK,
};

pub const SPC_STATEMENT_TYPE = extern struct {
    cKeyPurposeId: u32,
    rgpszKeyPurposeId: *PSTR,
};

pub const SPC_SP_OPUS_INFO = extern struct {
    pwszProgramName: [*:0]const u16,
    pMoreInfo: *SPC_LINK,
    pPublisherInfo: *SPC_LINK,
};

pub const CAT_NAMEVALUE = extern struct {
    pwszTag: PWSTR,
    fdwFlags: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CAT_MEMBERINFO = extern struct {
    pwszSubjGuid: PWSTR,
    dwCertVersion: u32,
};

pub const CAT_MEMBERINFO2 = extern struct {
    SubjectGuid: Guid,
    dwCertVersion: u32,
};

pub const INTENT_TO_SEAL_ATTRIBUTE = extern struct {
    version: u32,
    seal: u8,
};

pub const SEALING_SIGNATURE_ATTRIBUTE = extern struct {
    version: u32,
    signerIndex: u32,
    signatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    encryptedDigest: CRYPTOAPI_BLOB,
};

pub const SEALING_TIMESTAMP_ATTRIBUTE = extern struct {
    version: u32,
    signerIndex: u32,
    sealTimeStampToken: CRYPTOAPI_BLOB,
};

pub const WIN_CERTIFICATE = extern struct {
    dwLength: u32,
    wRevision: u16,
    wCertificateType: u16,
    bCertificate: [1]u8,
};

pub const WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = extern struct {
    hClientToken: HANDLE,
    SubjectType: *Guid,
    Subject: *c_void,
};

pub const WIN_TRUST_ACTDATA_SUBJECT_ONLY = extern struct {
    SubjectType: *Guid,
    Subject: *c_void,
};

pub const WIN_TRUST_SUBJECT_FILE = extern struct {
    hFile: HANDLE,
    lpPath: [*:0]const u16,
};

pub const WIN_TRUST_SUBJECT_FILE_AND_DISPLAY = extern struct {
    hFile: HANDLE,
    lpPath: [*:0]const u16,
    lpDisplayName: [*:0]const u16,
};

pub const WIN_SPUB_TRUSTED_PUBLISHER_DATA = extern struct {
    hClientToken: HANDLE,
    lpCertificate: *WIN_CERTIFICATE,
};

pub const PFNCFILTERPROC = fn(
    pCertContext: *CERT_CONTEXT,
    pfInitialSelectedCert: *BOOL,
    pvCallbackData: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_SELECTUI_INPUT = extern struct {
    hStore: *c_void,
    prgpChain: **CERT_CHAIN_CONTEXT,
    cChain: u32,
};

pub const CRYPTUI_CERT_MGR_STRUCT = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    dwFlags: u32,
    pwszTitle: [*:0]const u16,
    pszInitUsageOID: [*:0]const u8,
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO = extern struct {
    dwSize: u32,
    pGuidSubject: *Guid,
    cbBlob: u32,
    pbBlob: *u8,
    pwszDisplayName: [*:0]const u16,
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO = extern struct {
    dwSize: u32,
    cCertStore: u32,
    rghCertStore: **c_void,
    pFilterCallback: PFNCFILTERPROC,
    pvCallbackData: *c_void,
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO = extern struct {
    dwSize: u32,
    pwszPvkFileName: PWSTR,
    pwszProvName: PWSTR,
    dwProvType: u32,
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO = extern struct {
    dwSize: u32,
    pwszSigningCertFileName: PWSTR,
    dwPvkChoice: CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO = extern struct {
    dwSize: u32,
    dwAttrFlags: CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE,
    pwszDescription: [*:0]const u16,
    pwszMoreInfoLocation: [*:0]const u16,
    pszHashAlg: [*:0]const u8,
    pwszSigningCertDisplayString: [*:0]const u16,
    hAdditionalCertStore: *c_void,
    psAuthenticated: *CRYPT_ATTRIBUTES,
    psUnauthenticated: *CRYPT_ATTRIBUTES,
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_INFO = extern struct {
    dwSize: u32,
    dwSubjectChoice: CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT,
    Anonymous1: _Anonymous1_e__Union,
    dwSigningCertChoice: CRYPTUI_WIZ_DIGITAL_SIGN,
    Anonymous2: _Anonymous2_e__Union,
    pwszTimestampURL: [*:0]const u16,
    dwAdditionalCertChoice: CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE,
    pSignExtInfo: *CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT = extern struct {
    dwSize: u32,
    cbBlob: u32,
    pbBlob: *u8,
};

pub const CRYPTUI_INITDIALOG_STRUCT = extern struct {
    lParam: LPARAM,
    pCertContext: *CERT_CONTEXT,
};

pub const CRYPTUI_VIEWCERTIFICATE_STRUCTW = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    dwFlags: CRYPTUI_VIEWCERTIFICATE_FLAGS,
    szTitle: [*:0]const u16,
    pCertContext: *CERT_CONTEXT,
    rgszPurposes: *PSTR,
    cPurposes: u32,
    Anonymous: _Anonymous_e__Union,
    fpCryptProviderDataTrustedUsage: BOOL,
    idxSigner: u32,
    idxCert: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
    cStores: u32,
    rghStores: **c_void,
    cPropSheetPages: u32,
    rgPropSheetPages: *PROPSHEETPAGEW,
    nStartPage: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPTUI_VIEWCERTIFICATE_STRUCTA = extern struct {
    dwSize: u32,
    hwndParent: HWND,
    dwFlags: CRYPTUI_VIEWCERTIFICATE_FLAGS,
    szTitle: [*:0]const u8,
    pCertContext: *CERT_CONTEXT,
    rgszPurposes: *PSTR,
    cPurposes: u32,
    Anonymous: _Anonymous_e__Union,
    fpCryptProviderDataTrustedUsage: BOOL,
    idxSigner: u32,
    idxCert: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
    cStores: u32,
    rghStores: **c_void,
    cPropSheetPages: u32,
    rgPropSheetPages: *PROPSHEETPAGEA,
    nStartPage: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPTUI_WIZ_EXPORT_INFO = extern struct {
    dwSize: u32,
    pwszExportFileName: [*:0]const u16,
    dwSubjectChoice: CRYPTUI_WIZ_EXPORT_SUBJECT,
    Anonymous: _Anonymous_e__Union,
    cStores: u32,
    rghStores: **c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO = extern struct {
    dwSize: u32,
    dwExportFormat: CRYPTUI_WIZ_EXPORT_FORMAT,
    fExportChain: BOOL,
    fExportPrivateKeys: BOOL,
    pwszPassword: [*:0]const u16,
    fStrongEncryption: BOOL,
};

pub const CRYPTUI_WIZ_IMPORT_SRC_INFO = extern struct {
    dwSize: u32,
    dwSubjectChoice: CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION,
    Anonymous: _Anonymous_e__Union,
    dwFlags: CRYPT_KEY_FLAGS,
    pwszPassword: [*:0]const u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SIP_SUBJECTINFO = extern struct {
    cbSize: u32,
    pgSubjectType: *Guid,
    hFile: HANDLE,
    pwsFileName: [*:0]const u16,
    pwsDisplayName: [*:0]const u16,
    dwReserved1: u32,
    dwIntVersion: u32,
    hProv: usize,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    dwFlags: u32,
    dwEncodingType: u32,
    dwReserved2: u32,
    fdwCAPISettings: u32,
    fdwSecuritySettings: u32,
    dwIndex: u32,
    dwUnionChoice: u32,
    Anonymous: _Anonymous_e__Union,
    pClientData: *c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MS_ADDINFO_FLAT = extern struct {
    cbStruct: u32,
    pIndirectData: *SIP_INDIRECT_DATA,
};

pub const MS_ADDINFO_CATALOGMEMBER = extern struct {
    cbStruct: u32,
    pStore: *CRYPTCATSTORE,
    pMember: *CRYPTCATMEMBER,
};

pub const MS_ADDINFO_BLOB = extern struct {
    cbStruct: u32,
    cbMemObject: u32,
    pbMemObject: *u8,
    cbMemSignedMsg: u32,
    pbMemSignedMsg: *u8,
};

pub const SIP_CAP_SET_V2 = extern struct {
    cbSize: u32,
    dwVersion: u32,
    isMultiSign: BOOL,
    dwReserved: u32,
};

pub const SIP_CAP_SET_V3 = extern struct {
    cbSize: u32,
    dwVersion: u32,
    isMultiSign: BOOL,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SIP_INDIRECT_DATA = extern struct {
    Data: CRYPT_ATTRIBUTE_TYPE_VALUE,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Digest: CRYPTOAPI_BLOB,
};

pub const pCryptSIPGetSignedDataMsg = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pdwEncodingType: *u32,
    dwIndex: u32,
    pcbSignedDataMsg: *u32,
    pbSignedDataMsg: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPPutSignedDataMsg = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    dwEncodingType: u32,
    pdwIndex: *u32,
    cbSignedDataMsg: u32,
    pbSignedDataMsg: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPCreateIndirectData = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pcbIndirectData: *u32,
    pIndirectData: *SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPVerifyIndirectData = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pIndirectData: *SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPRemoveSignedDataMsg = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SIP_DISPATCH_INFO = extern struct {
    cbSize: u32,
    hSIP: HANDLE,
    pfGet: pCryptSIPGetSignedDataMsg,
    pfPut: pCryptSIPPutSignedDataMsg,
    pfCreate: pCryptSIPCreateIndirectData,
    pfVerify: pCryptSIPVerifyIndirectData,
    pfRemove: pCryptSIPRemoveSignedDataMsg,
};

pub const pfnIsFileSupported = fn(
    hFile: HANDLE,
    pgSubject: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pfnIsFileSupportedName = fn(
    pwszFileName: PWSTR,
    pgSubject: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SIP_ADD_NEWPROVIDER = extern struct {
    cbStruct: u32,
    pgSubject: *Guid,
    pwszDLLFileName: PWSTR,
    pwszMagicNumber: PWSTR,
    pwszIsFunctionName: PWSTR,
    pwszGetFuncName: PWSTR,
    pwszPutFuncName: PWSTR,
    pwszCreateFuncName: PWSTR,
    pwszVerifyFuncName: PWSTR,
    pwszRemoveFuncName: PWSTR,
    pwszIsFunctionNameFmt2: PWSTR,
    pwszGetCapFuncName: PWSTR,
};

pub const pCryptSIPGetCaps = fn(
    pSubjInfo: *SIP_SUBJECTINFO,
    pCaps: *SIP_CAP_SET_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPGetSealedDigest = fn(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pSig: ?[*:0]const u8,
    dwSig: u32,
    pbDigest: ?[*:0]u8,
    pcbDigest: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTCATSTORE = extern struct {
    cbStruct: u32,
    dwPublicVersion: u32,
    pwszP7File: PWSTR,
    hProv: usize,
    dwEncodingType: u32,
    fdwStoreFlags: CRYPTCAT_OPEN_FLAGS,
    hReserved: HANDLE,
    hAttrs: HANDLE,
    hCryptMsg: *c_void,
    hSorted: HANDLE,
};

pub const CRYPTCATMEMBER = extern struct {
    cbStruct: u32,
    pwszReferenceTag: PWSTR,
    pwszFileName: PWSTR,
    gSubjectType: Guid,
    fdwMemberFlags: u32,
    pIndirectData: *SIP_INDIRECT_DATA,
    dwCertVersion: u32,
    dwReserved: u32,
    hReserved: HANDLE,
    sEncodedIndirectData: CRYPTOAPI_BLOB,
    sEncodedMemberInfo: CRYPTOAPI_BLOB,
};

pub const CRYPTCATATTRIBUTE = extern struct {
    cbStruct: u32,
    pwszReferenceTag: PWSTR,
    dwAttrTypeAndAction: u32,
    cbValue: u32,
    pbValue: *u8,
    dwReserved: u32,
};

pub const CRYPTCATCDF = extern struct {
    cbStruct: u32,
    hFile: HANDLE,
    dwCurFilePos: u32,
    dwLastMemberOffset: u32,
    fEOF: BOOL,
    pwszResultDir: PWSTR,
    hCATStore: HANDLE,
};

pub const CATALOG_INFO = extern struct {
    cbStruct: u32,
    wszCatalogFile: [260]u16,
};

pub const PFN_CDF_PARSE_ERROR_CALLBACK = fn(
    dwErrorArea: u32,
    dwLocalError: u32,
    pwszLine: PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_CEnroll2_Value = @import("../zig.zig").Guid.initString("127698e4-e730-4e5c-a2b1-21490a70c8a1");
pub const CLSID_CEnroll2 = &CLSID_CEnroll2_Value;

const CLSID_CEnroll_Value = @import("../zig.zig").Guid.initString("43f8f289-7a20-11d0-8f06-00c04fc295e1");
pub const CLSID_CEnroll = &CLSID_CEnroll_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICEnroll_Value = @import("../zig.zig").Guid.initString("43f8f288-7a20-11d0-8f06-00c04fc295e1");
pub const IID_ICEnroll = &IID_ICEnroll_Value;
pub const ICEnroll = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createFilePKCS10: fn(
            self: *const ICEnroll,
            DNName: BSTR,
            Usage: BSTR,
            wszPKCS10FileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptFilePKCS7: fn(
            self: *const ICEnroll,
            wszPKCS7FileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPKCS10: fn(
            self: *const ICEnroll,
            DNName: BSTR,
            Usage: BSTR,
            pPKCS10: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptPKCS7: fn(
            self: *const ICEnroll,
            PKCS7: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertFromPKCS7: fn(
            self: *const ICEnroll,
            wszPKCS7: BSTR,
            pbstrCert: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        enumProviders: fn(
            self: *const ICEnroll,
            dwIndex: i32,
            dwFlags: i32,
            pbstrProvName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        enumContainers: fn(
            self: *const ICEnroll,
            dwIndex: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        freeRequestInfo: fn(
            self: *const ICEnroll,
            PKCS7OrPKCS10: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreName: fn(
            self: *const ICEnroll,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreName: fn(
            self: *const ICEnroll,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreType: fn(
            self: *const ICEnroll,
            pbstrType: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreType: fn(
            self: *const ICEnroll,
            bstrType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreName: fn(
            self: *const ICEnroll,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreName: fn(
            self: *const ICEnroll,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreType: fn(
            self: *const ICEnroll,
            pbstrType: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreType: fn(
            self: *const ICEnroll,
            bstrType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreName: fn(
            self: *const ICEnroll,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreName: fn(
            self: *const ICEnroll,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreType: fn(
            self: *const ICEnroll,
            pbstrType: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreType: fn(
            self: *const ICEnroll,
            bstrType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreName: fn(
            self: *const ICEnroll,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreName: fn(
            self: *const ICEnroll,
            bstrName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreType: fn(
            self: *const ICEnroll,
            pbstrType: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreType: fn(
            self: *const ICEnroll,
            bstrType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: fn(
            self: *const ICEnroll,
            pbstrContainer: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: fn(
            self: *const ICEnroll,
            bstrContainer: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const ICEnroll,
            pbstrProvider: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const ICEnroll,
            bstrProvider: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderType: fn(
            self: *const ICEnroll,
            pdwType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderType: fn(
            self: *const ICEnroll,
            dwType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const ICEnroll,
            pdw: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeySpec: fn(
            self: *const ICEnroll,
            dw: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseExistingKeySet: fn(
            self: *const ICEnroll,
            fUseExistingKeys: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseExistingKeySet: fn(
            self: *const ICEnroll,
            fUseExistingKeys: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenKeyFlags: fn(
            self: *const ICEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GenKeyFlags: fn(
            self: *const ICEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeleteRequestCert: fn(
            self: *const ICEnroll,
            fDelete: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DeleteRequestCert: fn(
            self: *const ICEnroll,
            fDelete: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteCertToCSP: fn(
            self: *const ICEnroll,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WriteCertToCSP: fn(
            self: *const ICEnroll,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SPCFileName: fn(
            self: *const ICEnroll,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SPCFileName: fn(
            self: *const ICEnroll,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PVKFileName: fn(
            self: *const ICEnroll,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PVKFileName: fn(
            self: *const ICEnroll,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const ICEnroll,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const ICEnroll,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_createFilePKCS10(self: *const T, DNName: BSTR, Usage: BSTR, wszPKCS10FileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).createFilePKCS10(@ptrCast(*const ICEnroll, self), DNName, Usage, wszPKCS10FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_acceptFilePKCS7(self: *const T, wszPKCS7FileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).acceptFilePKCS7(@ptrCast(*const ICEnroll, self), wszPKCS7FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_createPKCS10(self: *const T, DNName: BSTR, Usage: BSTR, pPKCS10: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).createPKCS10(@ptrCast(*const ICEnroll, self), DNName, Usage, pPKCS10);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_acceptPKCS7(self: *const T, PKCS7: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).acceptPKCS7(@ptrCast(*const ICEnroll, self), PKCS7);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_getCertFromPKCS7(self: *const T, wszPKCS7: BSTR, pbstrCert: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).getCertFromPKCS7(@ptrCast(*const ICEnroll, self), wszPKCS7, pbstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_enumProviders(self: *const T, dwIndex: i32, dwFlags: i32, pbstrProvName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).enumProviders(@ptrCast(*const ICEnroll, self), dwIndex, dwFlags, pbstrProvName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_enumContainers(self: *const T, dwIndex: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).enumContainers(@ptrCast(*const ICEnroll, self), dwIndex, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_freeRequestInfo(self: *const T, PKCS7OrPKCS10: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).freeRequestInfo(@ptrCast(*const ICEnroll, self), PKCS7OrPKCS10);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_MyStoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_MyStoreName(@ptrCast(*const ICEnroll, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_MyStoreName(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_MyStoreName(@ptrCast(*const ICEnroll, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_MyStoreType(self: *const T, pbstrType: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_MyStoreType(@ptrCast(*const ICEnroll, self), pbstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_MyStoreType(self: *const T, bstrType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_MyStoreType(@ptrCast(*const ICEnroll, self), bstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_MyStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_MyStoreFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_MyStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_MyStoreFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_CAStoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_CAStoreName(@ptrCast(*const ICEnroll, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_CAStoreName(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_CAStoreName(@ptrCast(*const ICEnroll, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_CAStoreType(self: *const T, pbstrType: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_CAStoreType(@ptrCast(*const ICEnroll, self), pbstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_CAStoreType(self: *const T, bstrType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_CAStoreType(@ptrCast(*const ICEnroll, self), bstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_CAStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_CAStoreFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_CAStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_CAStoreFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RootStoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RootStoreName(@ptrCast(*const ICEnroll, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RootStoreName(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RootStoreName(@ptrCast(*const ICEnroll, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RootStoreType(self: *const T, pbstrType: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RootStoreType(@ptrCast(*const ICEnroll, self), pbstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RootStoreType(self: *const T, bstrType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RootStoreType(@ptrCast(*const ICEnroll, self), bstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RootStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RootStoreFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RootStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RootStoreFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RequestStoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RequestStoreName(@ptrCast(*const ICEnroll, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RequestStoreName(self: *const T, bstrName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RequestStoreName(@ptrCast(*const ICEnroll, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RequestStoreType(self: *const T, pbstrType: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RequestStoreType(@ptrCast(*const ICEnroll, self), pbstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RequestStoreType(self: *const T, bstrType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RequestStoreType(@ptrCast(*const ICEnroll, self), bstrType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_RequestStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_RequestStoreFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_RequestStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_RequestStoreFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_ContainerName(self: *const T, pbstrContainer: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_ContainerName(@ptrCast(*const ICEnroll, self), pbstrContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_ContainerName(self: *const T, bstrContainer: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_ContainerName(@ptrCast(*const ICEnroll, self), bstrContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_ProviderName(self: *const T, pbstrProvider: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_ProviderName(@ptrCast(*const ICEnroll, self), pbstrProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_ProviderName(self: *const T, bstrProvider: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_ProviderName(@ptrCast(*const ICEnroll, self), bstrProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_ProviderType(self: *const T, pdwType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_ProviderType(@ptrCast(*const ICEnroll, self), pdwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_ProviderType(self: *const T, dwType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_ProviderType(@ptrCast(*const ICEnroll, self), dwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_KeySpec(self: *const T, pdw: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_KeySpec(@ptrCast(*const ICEnroll, self), pdw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_KeySpec(self: *const T, dw: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_KeySpec(@ptrCast(*const ICEnroll, self), dw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_ProviderFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_ProviderFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_ProviderFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_ProviderFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_UseExistingKeySet(self: *const T, fUseExistingKeys: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_UseExistingKeySet(@ptrCast(*const ICEnroll, self), fUseExistingKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_UseExistingKeySet(self: *const T, fUseExistingKeys: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_UseExistingKeySet(@ptrCast(*const ICEnroll, self), fUseExistingKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_GenKeyFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_GenKeyFlags(@ptrCast(*const ICEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_GenKeyFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_GenKeyFlags(@ptrCast(*const ICEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_DeleteRequestCert(self: *const T, fDelete: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_DeleteRequestCert(@ptrCast(*const ICEnroll, self), fDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_DeleteRequestCert(self: *const T, fDelete: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_DeleteRequestCert(@ptrCast(*const ICEnroll, self), fDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_WriteCertToCSP(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_WriteCertToCSP(@ptrCast(*const ICEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_WriteCertToCSP(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_WriteCertToCSP(@ptrCast(*const ICEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_SPCFileName(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_SPCFileName(@ptrCast(*const ICEnroll, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_SPCFileName(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_SPCFileName(@ptrCast(*const ICEnroll, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_PVKFileName(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_PVKFileName(@ptrCast(*const ICEnroll, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_PVKFileName(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_PVKFileName(@ptrCast(*const ICEnroll, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_get_HashAlgorithm(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const ICEnroll, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll_put_HashAlgorithm(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const ICEnroll, self), bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICEnroll2_Value = @import("../zig.zig").Guid.initString("704ca730-c90b-11d1-9bec-00c04fc295e1");
pub const IID_ICEnroll2 = &IID_ICEnroll2_Value;
pub const ICEnroll2 = extern struct {
    pub const VTable = extern struct {
        base: ICEnroll.VTable,
        addCertTypeToRequest: fn(
            self: *const ICEnroll2,
            CertType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addNameValuePairToSignature: fn(
            self: *const ICEnroll2,
            Name: BSTR,
            Value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteCertToUserDS: fn(
            self: *const ICEnroll2,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WriteCertToUserDS: fn(
            self: *const ICEnroll2,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableT61DNEncoding: fn(
            self: *const ICEnroll2,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableT61DNEncoding: fn(
            self: *const ICEnroll2,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICEnroll.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_addCertTypeToRequest(self: *const T, CertType: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).addCertTypeToRequest(@ptrCast(*const ICEnroll2, self), CertType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_addNameValuePairToSignature(self: *const T, Name: BSTR, Value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).addNameValuePairToSignature(@ptrCast(*const ICEnroll2, self), Name, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_get_WriteCertToUserDS(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).get_WriteCertToUserDS(@ptrCast(*const ICEnroll2, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_put_WriteCertToUserDS(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).put_WriteCertToUserDS(@ptrCast(*const ICEnroll2, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_get_EnableT61DNEncoding(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).get_EnableT61DNEncoding(@ptrCast(*const ICEnroll2, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll2_put_EnableT61DNEncoding(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll2.VTable, self.vtable).put_EnableT61DNEncoding(@ptrCast(*const ICEnroll2, self), fBool);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICEnroll3_Value = @import("../zig.zig").Guid.initString("c28c2d95-b7de-11d2-a421-00c04f79fe8e");
pub const IID_ICEnroll3 = &IID_ICEnroll3_Value;
pub const ICEnroll3 = extern struct {
    pub const VTable = extern struct {
        base: ICEnroll2.VTable,
        InstallPKCS7: fn(
            self: *const ICEnroll3,
            PKCS7: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ICEnroll3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedKeySpec: fn(
            self: *const ICEnroll3,
            pdwKeySpec: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLen: fn(
            self: *const ICEnroll3,
            fMin: BOOL,
            fExchange: BOOL,
            pdwKeySize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAlgs: fn(
            self: *const ICEnroll3,
            dwIndex: i32,
            algClass: i32,
            pdwAlgID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlgName: fn(
            self: *const ICEnroll3,
            algID: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReuseHardwareKeyIfUnableToGenNew: fn(
            self: *const ICEnroll3,
            fReuseHardwareKeyIfUnableToGenNew: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReuseHardwareKeyIfUnableToGenNew: fn(
            self: *const ICEnroll3,
            fReuseHardwareKeyIfUnableToGenNew: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgID: fn(
            self: *const ICEnroll3,
            hashAlgID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgID: fn(
            self: *const ICEnroll3,
            hashAlgID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LimitExchangeKeyToEncipherment: fn(
            self: *const ICEnroll3,
            fLimitExchangeKeyToEncipherment: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LimitExchangeKeyToEncipherment: fn(
            self: *const ICEnroll3,
            fLimitExchangeKeyToEncipherment: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableSMIMECapabilities: fn(
            self: *const ICEnroll3,
            fEnableSMIMECapabilities: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableSMIMECapabilities: fn(
            self: *const ICEnroll3,
            fEnableSMIMECapabilities: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICEnroll2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_InstallPKCS7(self: *const T, PKCS7: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).InstallPKCS7(@ptrCast(*const ICEnroll3, self), PKCS7);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).Reset(@ptrCast(*const ICEnroll3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_GetSupportedKeySpec(self: *const T, pdwKeySpec: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).GetSupportedKeySpec(@ptrCast(*const ICEnroll3, self), pdwKeySpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_GetKeyLen(self: *const T, fMin: BOOL, fExchange: BOOL, pdwKeySize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).GetKeyLen(@ptrCast(*const ICEnroll3, self), fMin, fExchange, pdwKeySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_EnumAlgs(self: *const T, dwIndex: i32, algClass: i32, pdwAlgID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).EnumAlgs(@ptrCast(*const ICEnroll3, self), dwIndex, algClass, pdwAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_GetAlgName(self: *const T, algID: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).GetAlgName(@ptrCast(*const ICEnroll3, self), algID, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew(self: *const T, fReuseHardwareKeyIfUnableToGenNew: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).put_ReuseHardwareKeyIfUnableToGenNew(@ptrCast(*const ICEnroll3, self), fReuseHardwareKeyIfUnableToGenNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew(self: *const T, fReuseHardwareKeyIfUnableToGenNew: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).get_ReuseHardwareKeyIfUnableToGenNew(@ptrCast(*const ICEnroll3, self), fReuseHardwareKeyIfUnableToGenNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_put_HashAlgID(self: *const T, hashAlgID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).put_HashAlgID(@ptrCast(*const ICEnroll3, self), hashAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_get_HashAlgID(self: *const T, hashAlgID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).get_HashAlgID(@ptrCast(*const ICEnroll3, self), hashAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_put_LimitExchangeKeyToEncipherment(self: *const T, fLimitExchangeKeyToEncipherment: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).put_LimitExchangeKeyToEncipherment(@ptrCast(*const ICEnroll3, self), fLimitExchangeKeyToEncipherment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_get_LimitExchangeKeyToEncipherment(self: *const T, fLimitExchangeKeyToEncipherment: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).get_LimitExchangeKeyToEncipherment(@ptrCast(*const ICEnroll3, self), fLimitExchangeKeyToEncipherment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_put_EnableSMIMECapabilities(self: *const T, fEnableSMIMECapabilities: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).put_EnableSMIMECapabilities(@ptrCast(*const ICEnroll3, self), fEnableSMIMECapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll3_get_EnableSMIMECapabilities(self: *const T, fEnableSMIMECapabilities: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll3.VTable, self.vtable).get_EnableSMIMECapabilities(@ptrCast(*const ICEnroll3, self), fEnableSMIMECapabilities);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICEnroll4_Value = @import("../zig.zig").Guid.initString("c1f1188a-2eb5-4a80-841b-7e729a356d90");
pub const IID_ICEnroll4 = &IID_ICEnroll4_Value;
pub const ICEnroll4 = extern struct {
    pub const VTable = extern struct {
        base: ICEnroll3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrivateKeyArchiveCertificate: fn(
            self: *const ICEnroll4,
            bstrCert: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivateKeyArchiveCertificate: fn(
            self: *const ICEnroll4,
            pbstrCert: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ThumbPrint: fn(
            self: *const ICEnroll4,
            bstrThumbPrint: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ThumbPrint: fn(
            self: *const ICEnroll4,
            pbstrThumbPrint: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        binaryToString: fn(
            self: *const ICEnroll4,
            Flags: i32,
            strBinary: BSTR,
            pstrEncoded: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stringToBinary: fn(
            self: *const ICEnroll4,
            Flags: i32,
            strEncoded: BSTR,
            pstrBinary: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addExtensionToRequest: fn(
            self: *const ICEnroll4,
            Flags: i32,
            strName: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addAttributeToRequest: fn(
            self: *const ICEnroll4,
            Flags: i32,
            strName: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addNameValuePairToRequest: fn(
            self: *const ICEnroll4,
            Flags: i32,
            strName: BSTR,
            strValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resetExtensions: fn(
            self: *const ICEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resetAttributes: fn(
            self: *const ICEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRequest: fn(
            self: *const ICEnroll4,
            Flags: CERT_CREATE_REQUEST_FLAGS,
            strDNName: BSTR,
            Usage: BSTR,
            pstrRequest: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createFileRequest: fn(
            self: *const ICEnroll4,
            Flags: CERT_CREATE_REQUEST_FLAGS,
            strDNName: BSTR,
            strUsage: BSTR,
            strRequestFileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptResponse: fn(
            self: *const ICEnroll4,
            strResponse: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptFileResponse: fn(
            self: *const ICEnroll4,
            strResponseFileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertFromResponse: fn(
            self: *const ICEnroll4,
            strResponse: BSTR,
            pstrCert: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertFromFileResponse: fn(
            self: *const ICEnroll4,
            strResponseFileName: BSTR,
            pstrCert: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPFX: fn(
            self: *const ICEnroll4,
            strPassword: BSTR,
            pstrPFX: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createFilePFX: fn(
            self: *const ICEnroll4,
            strPassword: BSTR,
            strPFXFileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPendingRequestInfo: fn(
            self: *const ICEnroll4,
            lRequestID: i32,
            strCADNS: BSTR,
            strCAName: BSTR,
            strFriendlyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        enumPendingRequest: fn(
            self: *const ICEnroll4,
            lIndex: i32,
            lDesiredProperty: PENDING_REQUEST_DESIRED_PROPERTY,
            pvarProperty: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removePendingRequest: fn(
            self: *const ICEnroll4,
            strThumbprint: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLenEx: fn(
            self: *const ICEnroll4,
            lSizeSpec: XEKL_KEYSIZE,
            lKeySpec: XEKL_KEYSPEC,
            pdwKeySize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallPKCS7Ex: fn(
            self: *const ICEnroll4,
            PKCS7: BSTR,
            plCertInstalled: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addCertTypeToRequestEx: fn(
            self: *const ICEnroll4,
            lType: ADDED_CERT_TYPE,
            bstrOIDOrName: BSTR,
            lMajorVersion: i32,
            fMinorVersion: BOOL,
            lMinorVersion: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProviderType: fn(
            self: *const ICEnroll4,
            strProvName: BSTR,
            plProvType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignerCertificate: fn(
            self: *const ICEnroll4,
            bstrCert: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientId: fn(
            self: *const ICEnroll4,
            lClientId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientId: fn(
            self: *const ICEnroll4,
            plClientId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addBlobPropertyToCertificate: fn(
            self: *const ICEnroll4,
            lPropertyId: i32,
            lReserved: i32,
            bstrProperty: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resetBlobProperties: fn(
            self: *const ICEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludeSubjectKeyID: fn(
            self: *const ICEnroll4,
            fInclude: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludeSubjectKeyID: fn(
            self: *const ICEnroll4,
            pfInclude: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICEnroll3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_put_PrivateKeyArchiveCertificate(self: *const T, bstrCert: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).put_PrivateKeyArchiveCertificate(@ptrCast(*const ICEnroll4, self), bstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_get_PrivateKeyArchiveCertificate(self: *const T, pbstrCert: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).get_PrivateKeyArchiveCertificate(@ptrCast(*const ICEnroll4, self), pbstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_put_ThumbPrint(self: *const T, bstrThumbPrint: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).put_ThumbPrint(@ptrCast(*const ICEnroll4, self), bstrThumbPrint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_get_ThumbPrint(self: *const T, pbstrThumbPrint: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).get_ThumbPrint(@ptrCast(*const ICEnroll4, self), pbstrThumbPrint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_binaryToString(self: *const T, Flags: i32, strBinary: BSTR, pstrEncoded: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).binaryToString(@ptrCast(*const ICEnroll4, self), Flags, strBinary, pstrEncoded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_stringToBinary(self: *const T, Flags: i32, strEncoded: BSTR, pstrBinary: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).stringToBinary(@ptrCast(*const ICEnroll4, self), Flags, strEncoded, pstrBinary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_addExtensionToRequest(self: *const T, Flags: i32, strName: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).addExtensionToRequest(@ptrCast(*const ICEnroll4, self), Flags, strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_addAttributeToRequest(self: *const T, Flags: i32, strName: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).addAttributeToRequest(@ptrCast(*const ICEnroll4, self), Flags, strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_addNameValuePairToRequest(self: *const T, Flags: i32, strName: BSTR, strValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).addNameValuePairToRequest(@ptrCast(*const ICEnroll4, self), Flags, strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_resetExtensions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).resetExtensions(@ptrCast(*const ICEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_resetAttributes(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).resetAttributes(@ptrCast(*const ICEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_createRequest(self: *const T, Flags: CERT_CREATE_REQUEST_FLAGS, strDNName: BSTR, Usage: BSTR, pstrRequest: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).createRequest(@ptrCast(*const ICEnroll4, self), Flags, strDNName, Usage, pstrRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_createFileRequest(self: *const T, Flags: CERT_CREATE_REQUEST_FLAGS, strDNName: BSTR, strUsage: BSTR, strRequestFileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).createFileRequest(@ptrCast(*const ICEnroll4, self), Flags, strDNName, strUsage, strRequestFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_acceptResponse(self: *const T, strResponse: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).acceptResponse(@ptrCast(*const ICEnroll4, self), strResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_acceptFileResponse(self: *const T, strResponseFileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).acceptFileResponse(@ptrCast(*const ICEnroll4, self), strResponseFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_getCertFromResponse(self: *const T, strResponse: BSTR, pstrCert: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).getCertFromResponse(@ptrCast(*const ICEnroll4, self), strResponse, pstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_getCertFromFileResponse(self: *const T, strResponseFileName: BSTR, pstrCert: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).getCertFromFileResponse(@ptrCast(*const ICEnroll4, self), strResponseFileName, pstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_createPFX(self: *const T, strPassword: BSTR, pstrPFX: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).createPFX(@ptrCast(*const ICEnroll4, self), strPassword, pstrPFX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_createFilePFX(self: *const T, strPassword: BSTR, strPFXFileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).createFilePFX(@ptrCast(*const ICEnroll4, self), strPassword, strPFXFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_setPendingRequestInfo(self: *const T, lRequestID: i32, strCADNS: BSTR, strCAName: BSTR, strFriendlyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).setPendingRequestInfo(@ptrCast(*const ICEnroll4, self), lRequestID, strCADNS, strCAName, strFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_enumPendingRequest(self: *const T, lIndex: i32, lDesiredProperty: PENDING_REQUEST_DESIRED_PROPERTY, pvarProperty: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).enumPendingRequest(@ptrCast(*const ICEnroll4, self), lIndex, lDesiredProperty, pvarProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_removePendingRequest(self: *const T, strThumbprint: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).removePendingRequest(@ptrCast(*const ICEnroll4, self), strThumbprint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_GetKeyLenEx(self: *const T, lSizeSpec: XEKL_KEYSIZE, lKeySpec: XEKL_KEYSPEC, pdwKeySize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).GetKeyLenEx(@ptrCast(*const ICEnroll4, self), lSizeSpec, lKeySpec, pdwKeySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_InstallPKCS7Ex(self: *const T, PKCS7: BSTR, plCertInstalled: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).InstallPKCS7Ex(@ptrCast(*const ICEnroll4, self), PKCS7, plCertInstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_addCertTypeToRequestEx(self: *const T, lType: ADDED_CERT_TYPE, bstrOIDOrName: BSTR, lMajorVersion: i32, fMinorVersion: BOOL, lMinorVersion: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).addCertTypeToRequestEx(@ptrCast(*const ICEnroll4, self), lType, bstrOIDOrName, lMajorVersion, fMinorVersion, lMinorVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_getProviderType(self: *const T, strProvName: BSTR, plProvType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).getProviderType(@ptrCast(*const ICEnroll4, self), strProvName, plProvType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_put_SignerCertificate(self: *const T, bstrCert: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).put_SignerCertificate(@ptrCast(*const ICEnroll4, self), bstrCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_put_ClientId(self: *const T, lClientId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).put_ClientId(@ptrCast(*const ICEnroll4, self), lClientId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_get_ClientId(self: *const T, plClientId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).get_ClientId(@ptrCast(*const ICEnroll4, self), plClientId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_addBlobPropertyToCertificate(self: *const T, lPropertyId: i32, lReserved: i32, bstrProperty: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).addBlobPropertyToCertificate(@ptrCast(*const ICEnroll4, self), lPropertyId, lReserved, bstrProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_resetBlobProperties(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).resetBlobProperties(@ptrCast(*const ICEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_put_IncludeSubjectKeyID(self: *const T, fInclude: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).put_IncludeSubjectKeyID(@ptrCast(*const ICEnroll4, self), fInclude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICEnroll4_get_IncludeSubjectKeyID(self: *const T, pfInclude: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICEnroll4.VTable, self.vtable).get_IncludeSubjectKeyID(@ptrCast(*const ICEnroll4, self), pfInclude);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnroll_Value = @import("../zig.zig").Guid.initString("acaa7838-4585-11d1-ab57-00c04fc295e1");
pub const IID_IEnroll = &IID_IEnroll_Value;
pub const IEnroll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        createFilePKCS10WStr: fn(
            self: *const IEnroll,
            DNName: [*:0]const u16,
            Usage: [*:0]const u16,
            wszPKCS10FileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptFilePKCS7WStr: fn(
            self: *const IEnroll,
            wszPKCS7FileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPKCS10WStr: fn(
            self: *const IEnroll,
            DNName: [*:0]const u16,
            Usage: [*:0]const u16,
            pPkcs10Blob: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptPKCS7Blob: fn(
            self: *const IEnroll,
            pBlobPKCS7: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertContextFromPKCS7: fn(
            self: *const IEnroll,
            pBlobPKCS7: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT,
        getMyStore: fn(
            self: *const IEnroll,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        getCAStore: fn(
            self: *const IEnroll,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        getROOTHStore: fn(
            self: *const IEnroll,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        enumProvidersWStr: fn(
            self: *const IEnroll,
            dwIndex: i32,
            dwFlags: i32,
            pbstrProvName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        enumContainersWStr: fn(
            self: *const IEnroll,
            dwIndex: i32,
            pbstr: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        freeRequestInfoBlob: fn(
            self: *const IEnroll,
            pkcs7OrPkcs10: CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MyStoreFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MyStoreFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAStoreFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CAStoreFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootStoreFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootStoreFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreNameWStr: fn(
            self: *const IEnroll,
            szwName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreTypeWStr: fn(
            self: *const IEnroll,
            szwType: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestStoreFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestStoreFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerNameWStr: fn(
            self: *const IEnroll,
            szwContainer: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerNameWStr: fn(
            self: *const IEnroll,
            szwContainer: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderNameWStr: fn(
            self: *const IEnroll,
            szwProvider: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderNameWStr: fn(
            self: *const IEnroll,
            szwProvider: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderType: fn(
            self: *const IEnroll,
            pdwType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderType: fn(
            self: *const IEnroll,
            dwType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySpec: fn(
            self: *const IEnroll,
            pdw: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeySpec: fn(
            self: *const IEnroll,
            dw: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseExistingKeySet: fn(
            self: *const IEnroll,
            fUseExistingKeys: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseExistingKeySet: fn(
            self: *const IEnroll,
            fUseExistingKeys: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GenKeyFlags: fn(
            self: *const IEnroll,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GenKeyFlags: fn(
            self: *const IEnroll,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeleteRequestCert: fn(
            self: *const IEnroll,
            fDelete: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DeleteRequestCert: fn(
            self: *const IEnroll,
            fDelete: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteCertToUserDS: fn(
            self: *const IEnroll,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WriteCertToUserDS: fn(
            self: *const IEnroll,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableT61DNEncoding: fn(
            self: *const IEnroll,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableT61DNEncoding: fn(
            self: *const IEnroll,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteCertToCSP: fn(
            self: *const IEnroll,
            fBool: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WriteCertToCSP: fn(
            self: *const IEnroll,
            fBool: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SPCFileNameWStr: fn(
            self: *const IEnroll,
            szw: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SPCFileNameWStr: fn(
            self: *const IEnroll,
            szw: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PVKFileNameWStr: fn(
            self: *const IEnroll,
            szw: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PVKFileNameWStr: fn(
            self: *const IEnroll,
            szw: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithmWStr: fn(
            self: *const IEnroll,
            szw: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithmWStr: fn(
            self: *const IEnroll,
            szw: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RenewalCertificate: fn(
            self: *const IEnroll,
            ppCertContext: **CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RenewalCertificate: fn(
            self: *const IEnroll,
            pCertContext: *CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddCertTypeToRequestWStr: fn(
            self: *const IEnroll,
            szw: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNameValuePairToSignatureWStr: fn(
            self: *const IEnroll,
            Name: PWSTR,
            Value: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionsToRequest: fn(
            self: *const IEnroll,
            pCertExtensions: *CERT_EXTENSIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAuthenticatedAttributesToPKCS7Request: fn(
            self: *const IEnroll,
            pAttributes: *CRYPT_ATTRIBUTES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePKCS7RequestFromRequest: fn(
            self: *const IEnroll,
            pRequest: *CRYPTOAPI_BLOB,
            pSigningCertContext: *CERT_CONTEXT,
            pPkcs7Blob: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_createFilePKCS10WStr(self: *const T, DNName: [*:0]const u16, Usage: [*:0]const u16, wszPKCS10FileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).createFilePKCS10WStr(@ptrCast(*const IEnroll, self), DNName, Usage, wszPKCS10FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_acceptFilePKCS7WStr(self: *const T, wszPKCS7FileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).acceptFilePKCS7WStr(@ptrCast(*const IEnroll, self), wszPKCS7FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_createPKCS10WStr(self: *const T, DNName: [*:0]const u16, Usage: [*:0]const u16, pPkcs10Blob: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).createPKCS10WStr(@ptrCast(*const IEnroll, self), DNName, Usage, pPkcs10Blob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_acceptPKCS7Blob(self: *const T, pBlobPKCS7: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).acceptPKCS7Blob(@ptrCast(*const IEnroll, self), pBlobPKCS7);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_getCertContextFromPKCS7(self: *const T, pBlobPKCS7: *CRYPTOAPI_BLOB) callconv(.Inline) *CERT_CONTEXT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).getCertContextFromPKCS7(@ptrCast(*const IEnroll, self), pBlobPKCS7);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_getMyStore(self: *const T) callconv(.Inline) *c_void {
            return @ptrCast(*const IEnroll.VTable, self.vtable).getMyStore(@ptrCast(*const IEnroll, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_getCAStore(self: *const T) callconv(.Inline) *c_void {
            return @ptrCast(*const IEnroll.VTable, self.vtable).getCAStore(@ptrCast(*const IEnroll, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_getROOTHStore(self: *const T) callconv(.Inline) *c_void {
            return @ptrCast(*const IEnroll.VTable, self.vtable).getROOTHStore(@ptrCast(*const IEnroll, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_enumProvidersWStr(self: *const T, dwIndex: i32, dwFlags: i32, pbstrProvName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).enumProvidersWStr(@ptrCast(*const IEnroll, self), dwIndex, dwFlags, pbstrProvName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_enumContainersWStr(self: *const T, dwIndex: i32, pbstr: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).enumContainersWStr(@ptrCast(*const IEnroll, self), dwIndex, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_freeRequestInfoBlob(self: *const T, pkcs7OrPkcs10: CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).freeRequestInfoBlob(@ptrCast(*const IEnroll, self), pkcs7OrPkcs10);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_MyStoreNameWStr(self: *const T, szwName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_MyStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_MyStoreNameWStr(self: *const T, szwName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_MyStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_MyStoreTypeWStr(self: *const T, szwType: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_MyStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_MyStoreTypeWStr(self: *const T, szwType: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_MyStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_MyStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_MyStoreFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_MyStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_MyStoreFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_CAStoreNameWStr(self: *const T, szwName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_CAStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_CAStoreNameWStr(self: *const T, szwName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_CAStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_CAStoreTypeWStr(self: *const T, szwType: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_CAStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_CAStoreTypeWStr(self: *const T, szwType: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_CAStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_CAStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_CAStoreFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_CAStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_CAStoreFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RootStoreNameWStr(self: *const T, szwName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RootStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RootStoreNameWStr(self: *const T, szwName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RootStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RootStoreTypeWStr(self: *const T, szwType: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RootStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RootStoreTypeWStr(self: *const T, szwType: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RootStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RootStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RootStoreFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RootStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RootStoreFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RequestStoreNameWStr(self: *const T, szwName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RequestStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RequestStoreNameWStr(self: *const T, szwName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RequestStoreNameWStr(@ptrCast(*const IEnroll, self), szwName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RequestStoreTypeWStr(self: *const T, szwType: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RequestStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RequestStoreTypeWStr(self: *const T, szwType: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RequestStoreTypeWStr(@ptrCast(*const IEnroll, self), szwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RequestStoreFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RequestStoreFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RequestStoreFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RequestStoreFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_ContainerNameWStr(self: *const T, szwContainer: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_ContainerNameWStr(@ptrCast(*const IEnroll, self), szwContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_ContainerNameWStr(self: *const T, szwContainer: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_ContainerNameWStr(@ptrCast(*const IEnroll, self), szwContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_ProviderNameWStr(self: *const T, szwProvider: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_ProviderNameWStr(@ptrCast(*const IEnroll, self), szwProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_ProviderNameWStr(self: *const T, szwProvider: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_ProviderNameWStr(@ptrCast(*const IEnroll, self), szwProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_ProviderType(self: *const T, pdwType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_ProviderType(@ptrCast(*const IEnroll, self), pdwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_ProviderType(self: *const T, dwType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_ProviderType(@ptrCast(*const IEnroll, self), dwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_KeySpec(self: *const T, pdw: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_KeySpec(@ptrCast(*const IEnroll, self), pdw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_KeySpec(self: *const T, dw: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_KeySpec(@ptrCast(*const IEnroll, self), dw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_ProviderFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_ProviderFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_ProviderFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_ProviderFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_UseExistingKeySet(self: *const T, fUseExistingKeys: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_UseExistingKeySet(@ptrCast(*const IEnroll, self), fUseExistingKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_UseExistingKeySet(self: *const T, fUseExistingKeys: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_UseExistingKeySet(@ptrCast(*const IEnroll, self), fUseExistingKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_GenKeyFlags(self: *const T, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_GenKeyFlags(@ptrCast(*const IEnroll, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_GenKeyFlags(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_GenKeyFlags(@ptrCast(*const IEnroll, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_DeleteRequestCert(self: *const T, fDelete: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_DeleteRequestCert(@ptrCast(*const IEnroll, self), fDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_DeleteRequestCert(self: *const T, fDelete: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_DeleteRequestCert(@ptrCast(*const IEnroll, self), fDelete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_WriteCertToUserDS(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_WriteCertToUserDS(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_WriteCertToUserDS(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_WriteCertToUserDS(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_EnableT61DNEncoding(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_EnableT61DNEncoding(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_EnableT61DNEncoding(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_EnableT61DNEncoding(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_WriteCertToCSP(self: *const T, fBool: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_WriteCertToCSP(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_WriteCertToCSP(self: *const T, fBool: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_WriteCertToCSP(@ptrCast(*const IEnroll, self), fBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_SPCFileNameWStr(self: *const T, szw: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_SPCFileNameWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_SPCFileNameWStr(self: *const T, szw: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_SPCFileNameWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_PVKFileNameWStr(self: *const T, szw: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_PVKFileNameWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_PVKFileNameWStr(self: *const T, szw: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_PVKFileNameWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_HashAlgorithmWStr(self: *const T, szw: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_HashAlgorithmWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_HashAlgorithmWStr(self: *const T, szw: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_HashAlgorithmWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_get_RenewalCertificate(self: *const T, ppCertContext: **CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).get_RenewalCertificate(@ptrCast(*const IEnroll, self), ppCertContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_put_RenewalCertificate(self: *const T, pCertContext: *CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).put_RenewalCertificate(@ptrCast(*const IEnroll, self), pCertContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_AddCertTypeToRequestWStr(self: *const T, szw: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).AddCertTypeToRequestWStr(@ptrCast(*const IEnroll, self), szw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_AddNameValuePairToSignatureWStr(self: *const T, Name: PWSTR, Value: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).AddNameValuePairToSignatureWStr(@ptrCast(*const IEnroll, self), Name, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_AddExtensionsToRequest(self: *const T, pCertExtensions: *CERT_EXTENSIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).AddExtensionsToRequest(@ptrCast(*const IEnroll, self), pCertExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_AddAuthenticatedAttributesToPKCS7Request(self: *const T, pAttributes: *CRYPT_ATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).AddAuthenticatedAttributesToPKCS7Request(@ptrCast(*const IEnroll, self), pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll_CreatePKCS7RequestFromRequest(self: *const T, pRequest: *CRYPTOAPI_BLOB, pSigningCertContext: *CERT_CONTEXT, pPkcs7Blob: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll.VTable, self.vtable).CreatePKCS7RequestFromRequest(@ptrCast(*const IEnroll, self), pRequest, pSigningCertContext, pPkcs7Blob);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnroll2_Value = @import("../zig.zig").Guid.initString("c080e199-b7df-11d2-a421-00c04f79fe8e");
pub const IID_IEnroll2 = &IID_IEnroll2_Value;
pub const IEnroll2 = extern struct {
    pub const VTable = extern struct {
        base: IEnroll.VTable,
        InstallPKCS7Blob: fn(
            self: *const IEnroll2,
            pBlobPKCS7: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnroll2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedKeySpec: fn(
            self: *const IEnroll2,
            pdwKeySpec: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLen: fn(
            self: *const IEnroll2,
            fMin: BOOL,
            fExchange: BOOL,
            pdwKeySize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAlgs: fn(
            self: *const IEnroll2,
            dwIndex: i32,
            algClass: i32,
            pdwAlgID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlgNameWStr: fn(
            self: *const IEnroll2,
            algID: i32,
            ppwsz: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReuseHardwareKeyIfUnableToGenNew: fn(
            self: *const IEnroll2,
            fReuseHardwareKeyIfUnableToGenNew: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReuseHardwareKeyIfUnableToGenNew: fn(
            self: *const IEnroll2,
            fReuseHardwareKeyIfUnableToGenNew: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgID: fn(
            self: *const IEnroll2,
            hashAlgID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgID: fn(
            self: *const IEnroll2,
            hashAlgID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHStoreMy: fn(
            self: *const IEnroll2,
            hStore: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHStoreCA: fn(
            self: *const IEnroll2,
            hStore: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHStoreROOT: fn(
            self: *const IEnroll2,
            hStore: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHStoreRequest: fn(
            self: *const IEnroll2,
            hStore: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LimitExchangeKeyToEncipherment: fn(
            self: *const IEnroll2,
            fLimitExchangeKeyToEncipherment: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LimitExchangeKeyToEncipherment: fn(
            self: *const IEnroll2,
            fLimitExchangeKeyToEncipherment: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableSMIMECapabilities: fn(
            self: *const IEnroll2,
            fEnableSMIMECapabilities: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableSMIMECapabilities: fn(
            self: *const IEnroll2,
            fEnableSMIMECapabilities: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnroll.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_InstallPKCS7Blob(self: *const T, pBlobPKCS7: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).InstallPKCS7Blob(@ptrCast(*const IEnroll2, self), pBlobPKCS7);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).Reset(@ptrCast(*const IEnroll2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_GetSupportedKeySpec(self: *const T, pdwKeySpec: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).GetSupportedKeySpec(@ptrCast(*const IEnroll2, self), pdwKeySpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_GetKeyLen(self: *const T, fMin: BOOL, fExchange: BOOL, pdwKeySize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).GetKeyLen(@ptrCast(*const IEnroll2, self), fMin, fExchange, pdwKeySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_EnumAlgs(self: *const T, dwIndex: i32, algClass: i32, pdwAlgID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).EnumAlgs(@ptrCast(*const IEnroll2, self), dwIndex, algClass, pdwAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_GetAlgNameWStr(self: *const T, algID: i32, ppwsz: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).GetAlgNameWStr(@ptrCast(*const IEnroll2, self), algID, ppwsz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew(self: *const T, fReuseHardwareKeyIfUnableToGenNew: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).put_ReuseHardwareKeyIfUnableToGenNew(@ptrCast(*const IEnroll2, self), fReuseHardwareKeyIfUnableToGenNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew(self: *const T, fReuseHardwareKeyIfUnableToGenNew: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).get_ReuseHardwareKeyIfUnableToGenNew(@ptrCast(*const IEnroll2, self), fReuseHardwareKeyIfUnableToGenNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_put_HashAlgID(self: *const T, hashAlgID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).put_HashAlgID(@ptrCast(*const IEnroll2, self), hashAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_get_HashAlgID(self: *const T, hashAlgID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).get_HashAlgID(@ptrCast(*const IEnroll2, self), hashAlgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_SetHStoreMy(self: *const T, hStore: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).SetHStoreMy(@ptrCast(*const IEnroll2, self), hStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_SetHStoreCA(self: *const T, hStore: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).SetHStoreCA(@ptrCast(*const IEnroll2, self), hStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_SetHStoreROOT(self: *const T, hStore: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).SetHStoreROOT(@ptrCast(*const IEnroll2, self), hStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_SetHStoreRequest(self: *const T, hStore: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).SetHStoreRequest(@ptrCast(*const IEnroll2, self), hStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_put_LimitExchangeKeyToEncipherment(self: *const T, fLimitExchangeKeyToEncipherment: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).put_LimitExchangeKeyToEncipherment(@ptrCast(*const IEnroll2, self), fLimitExchangeKeyToEncipherment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_get_LimitExchangeKeyToEncipherment(self: *const T, fLimitExchangeKeyToEncipherment: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).get_LimitExchangeKeyToEncipherment(@ptrCast(*const IEnroll2, self), fLimitExchangeKeyToEncipherment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_put_EnableSMIMECapabilities(self: *const T, fEnableSMIMECapabilities: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).put_EnableSMIMECapabilities(@ptrCast(*const IEnroll2, self), fEnableSMIMECapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll2_get_EnableSMIMECapabilities(self: *const T, fEnableSMIMECapabilities: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll2.VTable, self.vtable).get_EnableSMIMECapabilities(@ptrCast(*const IEnroll2, self), fEnableSMIMECapabilities);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnroll4_Value = @import("../zig.zig").Guid.initString("f8053fe5-78f4-448f-a0db-41d61b73446b");
pub const IID_IEnroll4 = &IID_IEnroll4_Value;
pub const IEnroll4 = extern struct {
    pub const VTable = extern struct {
        base: IEnroll2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ThumbPrintWStr: fn(
            self: *const IEnroll4,
            thumbPrintBlob: CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ThumbPrintWStr: fn(
            self: *const IEnroll4,
            thumbPrintBlob: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrivateKeyArchiveCertificate: fn(
            self: *const IEnroll4,
            pPrivateKeyArchiveCert: *CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyArchiveCertificate: fn(
            self: *const IEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT,
        binaryBlobToString: fn(
            self: *const IEnroll4,
            Flags: i32,
            pblobBinary: *CRYPTOAPI_BLOB,
            ppwszString: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stringToBinaryBlob: fn(
            self: *const IEnroll4,
            Flags: i32,
            pwszString: [*:0]const u16,
            pblobBinary: *CRYPTOAPI_BLOB,
            pdwSkip: *i32,
            pdwFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addExtensionToRequestWStr: fn(
            self: *const IEnroll4,
            Flags: i32,
            pwszName: [*:0]const u16,
            pblobValue: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addAttributeToRequestWStr: fn(
            self: *const IEnroll4,
            Flags: i32,
            pwszName: [*:0]const u16,
            pblobValue: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addNameValuePairToRequestWStr: fn(
            self: *const IEnroll4,
            Flags: i32,
            pwszName: [*:0]const u16,
            pwszValue: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resetExtensions: fn(
            self: *const IEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resetAttributes: fn(
            self: *const IEnroll4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRequestWStr: fn(
            self: *const IEnroll4,
            Flags: CERT_CREATE_REQUEST_FLAGS,
            pwszDNName: [*:0]const u16,
            pwszUsage: [*:0]const u16,
            pblobRequest: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createFileRequestWStr: fn(
            self: *const IEnroll4,
            Flags: CERT_CREATE_REQUEST_FLAGS,
            pwszDNName: [*:0]const u16,
            pwszUsage: [*:0]const u16,
            pwszRequestFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptResponseBlob: fn(
            self: *const IEnroll4,
            pblobResponse: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        acceptFileResponseWStr: fn(
            self: *const IEnroll4,
            pwszResponseFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertContextFromResponseBlob: fn(
            self: *const IEnroll4,
            pblobResponse: *CRYPTOAPI_BLOB,
            ppCertContext: **CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCertContextFromFileResponseWStr: fn(
            self: *const IEnroll4,
            pwszResponseFileName: [*:0]const u16,
            ppCertContext: **CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPFXWStr: fn(
            self: *const IEnroll4,
            pwszPassword: [*:0]const u16,
            pblobPFX: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createFilePFXWStr: fn(
            self: *const IEnroll4,
            pwszPassword: [*:0]const u16,
            pwszPFXFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPendingRequestInfoWStr: fn(
            self: *const IEnroll4,
            lRequestID: i32,
            pwszCADNS: [*:0]const u16,
            pwszCAName: [*:0]const u16,
            pwszFriendlyName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        enumPendingRequestWStr: fn(
            self: *const IEnroll4,
            lIndex: i32,
            lDesiredProperty: PENDING_REQUEST_DESIRED_PROPERTY,
            ppProperty: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removePendingRequestWStr: fn(
            self: *const IEnroll4,
            thumbPrintBlob: CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLenEx: fn(
            self: *const IEnroll4,
            lSizeSpec: XEKL_KEYSIZE,
            lKeySpec: XEKL_KEYSPEC,
            pdwKeySize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallPKCS7BlobEx: fn(
            self: *const IEnroll4,
            pBlobPKCS7: *CRYPTOAPI_BLOB,
            plCertInstalled: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddCertTypeToRequestWStrEx: fn(
            self: *const IEnroll4,
            lType: ADDED_CERT_TYPE,
            pwszOIDOrName: [*:0]const u16,
            lMajorVersion: i32,
            fMinorVersion: BOOL,
            lMinorVersion: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getProviderTypeWStr: fn(
            self: *const IEnroll4,
            pwszProvName: [*:0]const u16,
            plProvType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addBlobPropertyToCertificateWStr: fn(
            self: *const IEnroll4,
            lPropertyId: i32,
            lReserved: i32,
            pBlobProperty: *CRYPTOAPI_BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSignerCertificate: fn(
            self: *const IEnroll4,
            pSignerCert: *CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientId: fn(
            self: *const IEnroll4,
            lClientId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientId: fn(
            self: *const IEnroll4,
            plClientId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludeSubjectKeyID: fn(
            self: *const IEnroll4,
            fInclude: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludeSubjectKeyID: fn(
            self: *const IEnroll4,
            pfInclude: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnroll2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_put_ThumbPrintWStr(self: *const T, thumbPrintBlob: CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).put_ThumbPrintWStr(@ptrCast(*const IEnroll4, self), thumbPrintBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_get_ThumbPrintWStr(self: *const T, thumbPrintBlob: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).get_ThumbPrintWStr(@ptrCast(*const IEnroll4, self), thumbPrintBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_SetPrivateKeyArchiveCertificate(self: *const T, pPrivateKeyArchiveCert: *CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).SetPrivateKeyArchiveCertificate(@ptrCast(*const IEnroll4, self), pPrivateKeyArchiveCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_GetPrivateKeyArchiveCertificate(self: *const T) callconv(.Inline) *CERT_CONTEXT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).GetPrivateKeyArchiveCertificate(@ptrCast(*const IEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_binaryBlobToString(self: *const T, Flags: i32, pblobBinary: *CRYPTOAPI_BLOB, ppwszString: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).binaryBlobToString(@ptrCast(*const IEnroll4, self), Flags, pblobBinary, ppwszString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_stringToBinaryBlob(self: *const T, Flags: i32, pwszString: [*:0]const u16, pblobBinary: *CRYPTOAPI_BLOB, pdwSkip: *i32, pdwFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).stringToBinaryBlob(@ptrCast(*const IEnroll4, self), Flags, pwszString, pblobBinary, pdwSkip, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_addExtensionToRequestWStr(self: *const T, Flags: i32, pwszName: [*:0]const u16, pblobValue: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).addExtensionToRequestWStr(@ptrCast(*const IEnroll4, self), Flags, pwszName, pblobValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_addAttributeToRequestWStr(self: *const T, Flags: i32, pwszName: [*:0]const u16, pblobValue: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).addAttributeToRequestWStr(@ptrCast(*const IEnroll4, self), Flags, pwszName, pblobValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_addNameValuePairToRequestWStr(self: *const T, Flags: i32, pwszName: [*:0]const u16, pwszValue: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).addNameValuePairToRequestWStr(@ptrCast(*const IEnroll4, self), Flags, pwszName, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_resetExtensions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).resetExtensions(@ptrCast(*const IEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_resetAttributes(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).resetAttributes(@ptrCast(*const IEnroll4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_createRequestWStr(self: *const T, Flags: CERT_CREATE_REQUEST_FLAGS, pwszDNName: [*:0]const u16, pwszUsage: [*:0]const u16, pblobRequest: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).createRequestWStr(@ptrCast(*const IEnroll4, self), Flags, pwszDNName, pwszUsage, pblobRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_createFileRequestWStr(self: *const T, Flags: CERT_CREATE_REQUEST_FLAGS, pwszDNName: [*:0]const u16, pwszUsage: [*:0]const u16, pwszRequestFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).createFileRequestWStr(@ptrCast(*const IEnroll4, self), Flags, pwszDNName, pwszUsage, pwszRequestFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_acceptResponseBlob(self: *const T, pblobResponse: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).acceptResponseBlob(@ptrCast(*const IEnroll4, self), pblobResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_acceptFileResponseWStr(self: *const T, pwszResponseFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).acceptFileResponseWStr(@ptrCast(*const IEnroll4, self), pwszResponseFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_getCertContextFromResponseBlob(self: *const T, pblobResponse: *CRYPTOAPI_BLOB, ppCertContext: **CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).getCertContextFromResponseBlob(@ptrCast(*const IEnroll4, self), pblobResponse, ppCertContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_getCertContextFromFileResponseWStr(self: *const T, pwszResponseFileName: [*:0]const u16, ppCertContext: **CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).getCertContextFromFileResponseWStr(@ptrCast(*const IEnroll4, self), pwszResponseFileName, ppCertContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_createPFXWStr(self: *const T, pwszPassword: [*:0]const u16, pblobPFX: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).createPFXWStr(@ptrCast(*const IEnroll4, self), pwszPassword, pblobPFX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_createFilePFXWStr(self: *const T, pwszPassword: [*:0]const u16, pwszPFXFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).createFilePFXWStr(@ptrCast(*const IEnroll4, self), pwszPassword, pwszPFXFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_setPendingRequestInfoWStr(self: *const T, lRequestID: i32, pwszCADNS: [*:0]const u16, pwszCAName: [*:0]const u16, pwszFriendlyName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).setPendingRequestInfoWStr(@ptrCast(*const IEnroll4, self), lRequestID, pwszCADNS, pwszCAName, pwszFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_enumPendingRequestWStr(self: *const T, lIndex: i32, lDesiredProperty: PENDING_REQUEST_DESIRED_PROPERTY, ppProperty: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).enumPendingRequestWStr(@ptrCast(*const IEnroll4, self), lIndex, lDesiredProperty, ppProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_removePendingRequestWStr(self: *const T, thumbPrintBlob: CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).removePendingRequestWStr(@ptrCast(*const IEnroll4, self), thumbPrintBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_GetKeyLenEx(self: *const T, lSizeSpec: XEKL_KEYSIZE, lKeySpec: XEKL_KEYSPEC, pdwKeySize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).GetKeyLenEx(@ptrCast(*const IEnroll4, self), lSizeSpec, lKeySpec, pdwKeySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_InstallPKCS7BlobEx(self: *const T, pBlobPKCS7: *CRYPTOAPI_BLOB, plCertInstalled: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).InstallPKCS7BlobEx(@ptrCast(*const IEnroll4, self), pBlobPKCS7, plCertInstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_AddCertTypeToRequestWStrEx(self: *const T, lType: ADDED_CERT_TYPE, pwszOIDOrName: [*:0]const u16, lMajorVersion: i32, fMinorVersion: BOOL, lMinorVersion: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).AddCertTypeToRequestWStrEx(@ptrCast(*const IEnroll4, self), lType, pwszOIDOrName, lMajorVersion, fMinorVersion, lMinorVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_getProviderTypeWStr(self: *const T, pwszProvName: [*:0]const u16, plProvType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).getProviderTypeWStr(@ptrCast(*const IEnroll4, self), pwszProvName, plProvType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_addBlobPropertyToCertificateWStr(self: *const T, lPropertyId: i32, lReserved: i32, pBlobProperty: *CRYPTOAPI_BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).addBlobPropertyToCertificateWStr(@ptrCast(*const IEnroll4, self), lPropertyId, lReserved, pBlobProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_SetSignerCertificate(self: *const T, pSignerCert: *CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).SetSignerCertificate(@ptrCast(*const IEnroll4, self), pSignerCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_put_ClientId(self: *const T, lClientId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).put_ClientId(@ptrCast(*const IEnroll4, self), lClientId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_get_ClientId(self: *const T, plClientId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).get_ClientId(@ptrCast(*const IEnroll4, self), plClientId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_put_IncludeSubjectKeyID(self: *const T, fInclude: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).put_IncludeSubjectKeyID(@ptrCast(*const IEnroll4, self), fInclude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnroll4_get_IncludeSubjectKeyID(self: *const T, pfInclude: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnroll4.VTable, self.vtable).get_IncludeSubjectKeyID(@ptrCast(*const IEnroll4, self), pfInclude);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCESVC_CONFIGURATION_LINE = extern struct {
    Key: *i8,
    Value: *i8,
    ValueLen: u32,
};

pub const SCESVC_CONFIGURATION_INFO = extern struct {
    Count: u32,
    Lines: *SCESVC_CONFIGURATION_LINE,
};

pub const SCESVC_INFO_TYPE = extern enum(i32) {
    ConfigurationInfo = 0,
    MergedPolicyInfo = 1,
    AnalysisInfo = 2,
    InternalUse = 3,
};
pub const SceSvcConfigurationInfo = SCESVC_INFO_TYPE.ConfigurationInfo;
pub const SceSvcMergedPolicyInfo = SCESVC_INFO_TYPE.MergedPolicyInfo;
pub const SceSvcAnalysisInfo = SCESVC_INFO_TYPE.AnalysisInfo;
pub const SceSvcInternalUse = SCESVC_INFO_TYPE.InternalUse;

pub const SCESVC_ANALYSIS_LINE = extern struct {
    Key: *i8,
    Value: *u8,
    ValueLen: u32,
};

pub const SCESVC_ANALYSIS_INFO = extern struct {
    Count: u32,
    Lines: *SCESVC_ANALYSIS_LINE,
};

pub const PFSCE_QUERY_INFO = fn(
    sceHandle: *c_void,
    sceType: SCESVC_INFO_TYPE,
    lpPrefix: *i8,
    bExact: BOOL,
    ppvInfo: **c_void,
    psceEnumHandle: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_SET_INFO = fn(
    sceHandle: *c_void,
    sceType: SCESVC_INFO_TYPE,
    lpPrefix: *i8,
    bExact: BOOL,
    pvInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_FREE_INFO = fn(
    pvServiceInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_LOG_INFO = fn(
    ErrLevel: SCE_LOG_ERR_LEVEL,
    Win32rc: u32,
    pErrFmt: *i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const SCESVC_CALLBACK_INFO = extern struct {
    sceHandle: *c_void,
    pfQueryInfo: PFSCE_QUERY_INFO,
    pfSetInfo: PFSCE_SET_INFO,
    pfFreeInfo: PFSCE_FREE_INFO,
    pfLogInfo: PFSCE_LOG_INFO,
};

pub const PF_ConfigAnalyzeService = fn(
    pSceCbInfo: *SCESVC_CALLBACK_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_UpdateService = fn(
    pSceCbInfo: *SCESVC_CALLBACK_INFO,
    ServiceInfo: *SCESVC_CONFIGURATION_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentPersistInfo_Value = @import("../zig.zig").Guid.initString("6d90e0d0-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentPersistInfo = &IID_ISceSvcAttachmentPersistInfo_Value;
pub const ISceSvcAttachmentPersistInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Save: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            lpTemplateName: *i8,
            scesvcHandle: **c_void,
            ppvData: **c_void,
            pbOverwriteAll: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirty: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            lpTemplateName: *i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            pvData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_Save(self: *const T, lpTemplateName: *i8, scesvcHandle: **c_void, ppvData: **c_void, pbOverwriteAll: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).Save(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName, scesvcHandle, ppvData, pbOverwriteAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_IsDirty(self: *const T, lpTemplateName: *i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).IsDirty(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_FreeBuffer(self: *const T, pvData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), pvData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentData_Value = @import("../zig.zig").Guid.initString("17c35fde-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentData = &IID_ISceSvcAttachmentData_Value;
pub const ISceSvcAttachmentData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const ISceSvcAttachmentData,
            scesvcHandle: *c_void,
            sceType: SCESVC_INFO_TYPE,
            ppvData: **c_void,
            psceEnumHandle: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const ISceSvcAttachmentData,
            lpServiceName: *i8,
            lpTemplateName: *i8,
            lpSceSvcPersistInfo: *ISceSvcAttachmentPersistInfo,
            pscesvcHandle: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const ISceSvcAttachmentData,
            pvData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseHandle: fn(
            self: *const ISceSvcAttachmentData,
            scesvcHandle: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_GetData(self: *const T, scesvcHandle: *c_void, sceType: SCESVC_INFO_TYPE, ppvData: **c_void, psceEnumHandle: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).GetData(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle, sceType, ppvData, psceEnumHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_Initialize(self: *const T, lpServiceName: *i8, lpTemplateName: *i8, lpSceSvcPersistInfo: *ISceSvcAttachmentPersistInfo, pscesvcHandle: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).Initialize(@ptrCast(*const ISceSvcAttachmentData, self), lpServiceName, lpTemplateName, lpSceSvcPersistInfo, pscesvcHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_FreeBuffer(self: *const T, pvData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentData, self), pvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_CloseHandle(self: *const T, scesvcHandle: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).CloseHandle(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SAFER_CODE_PROPERTIES_V1 = extern struct {
    cbSize: u32,
    dwCheckFlags: u32,
    ImagePath: [*:0]const u16,
    hImageFileHandle: HANDLE,
    UrlZoneId: u32,
    ImageHash: [64]u8,
    dwImageHashSize: u32,
    ImageSize: LARGE_INTEGER,
    HashAlgorithm: u32,
    pByteBlock: *u8,
    hWndParent: HWND,
    dwWVTUIChoice: u32,
};

pub const SAFER_CODE_PROPERTIES_V2 = extern struct {
    cbSize: u32,
    dwCheckFlags: u32,
    ImagePath: [*:0]const u16,
    hImageFileHandle: HANDLE,
    UrlZoneId: u32,
    ImageHash: [64]u8,
    dwImageHashSize: u32,
    ImageSize: LARGE_INTEGER,
    HashAlgorithm: u32,
    pByteBlock: *u8,
    hWndParent: HWND,
    dwWVTUIChoice: u32,
    PackageMoniker: [*:0]const u16,
    PackagePublisher: [*:0]const u16,
    PackageName: [*:0]const u16,
    PackageVersion: u64,
    PackageIsFramework: BOOL,
};

pub const SAFER_POLICY_INFO_CLASS = extern enum(i32) {
    LevelList = 1,
    EnableTransparentEnforcement = 2,
    DefaultLevel = 3,
    EvaluateUserScope = 4,
    ScopeFlags = 5,
    DefaultLevelFlags = 6,
    AuthenticodeEnabled = 7,
};
pub const SaferPolicyLevelList = SAFER_POLICY_INFO_CLASS.LevelList;
pub const SaferPolicyEnableTransparentEnforcement = SAFER_POLICY_INFO_CLASS.EnableTransparentEnforcement;
pub const SaferPolicyDefaultLevel = SAFER_POLICY_INFO_CLASS.DefaultLevel;
pub const SaferPolicyEvaluateUserScope = SAFER_POLICY_INFO_CLASS.EvaluateUserScope;
pub const SaferPolicyScopeFlags = SAFER_POLICY_INFO_CLASS.ScopeFlags;
pub const SaferPolicyDefaultLevelFlags = SAFER_POLICY_INFO_CLASS.DefaultLevelFlags;
pub const SaferPolicyAuthenticodeEnabled = SAFER_POLICY_INFO_CLASS.AuthenticodeEnabled;

pub const SAFER_OBJECT_INFO_CLASS = extern enum(i32) {
    LevelId = 1,
    ScopeId = 2,
    FriendlyName = 3,
    Description = 4,
    Builtin = 5,
    Disallowed = 6,
    DisableMaxPrivilege = 7,
    InvertDeletedPrivileges = 8,
    DeletedPrivileges = 9,
    DefaultOwner = 10,
    SidsToDisable = 11,
    RestrictedSidsInverted = 12,
    RestrictedSidsAdded = 13,
    AllIdentificationGuids = 14,
    SingleIdentification = 15,
    ExtendedError = 16,
};
pub const SaferObjectLevelId = SAFER_OBJECT_INFO_CLASS.LevelId;
pub const SaferObjectScopeId = SAFER_OBJECT_INFO_CLASS.ScopeId;
pub const SaferObjectFriendlyName = SAFER_OBJECT_INFO_CLASS.FriendlyName;
pub const SaferObjectDescription = SAFER_OBJECT_INFO_CLASS.Description;
pub const SaferObjectBuiltin = SAFER_OBJECT_INFO_CLASS.Builtin;
pub const SaferObjectDisallowed = SAFER_OBJECT_INFO_CLASS.Disallowed;
pub const SaferObjectDisableMaxPrivilege = SAFER_OBJECT_INFO_CLASS.DisableMaxPrivilege;
pub const SaferObjectInvertDeletedPrivileges = SAFER_OBJECT_INFO_CLASS.InvertDeletedPrivileges;
pub const SaferObjectDeletedPrivileges = SAFER_OBJECT_INFO_CLASS.DeletedPrivileges;
pub const SaferObjectDefaultOwner = SAFER_OBJECT_INFO_CLASS.DefaultOwner;
pub const SaferObjectSidsToDisable = SAFER_OBJECT_INFO_CLASS.SidsToDisable;
pub const SaferObjectRestrictedSidsInverted = SAFER_OBJECT_INFO_CLASS.RestrictedSidsInverted;
pub const SaferObjectRestrictedSidsAdded = SAFER_OBJECT_INFO_CLASS.RestrictedSidsAdded;
pub const SaferObjectAllIdentificationGuids = SAFER_OBJECT_INFO_CLASS.AllIdentificationGuids;
pub const SaferObjectSingleIdentification = SAFER_OBJECT_INFO_CLASS.SingleIdentification;
pub const SaferObjectExtendedError = SAFER_OBJECT_INFO_CLASS.ExtendedError;

pub const SAFER_IDENTIFICATION_TYPES = extern enum(i32) {
    Default = 0,
    TypeImageName = 1,
    TypeImageHash = 2,
    TypeUrlZone = 3,
    TypeCertificate = 4,
};
pub const SaferIdentityDefault = SAFER_IDENTIFICATION_TYPES.Default;
pub const SaferIdentityTypeImageName = SAFER_IDENTIFICATION_TYPES.TypeImageName;
pub const SaferIdentityTypeImageHash = SAFER_IDENTIFICATION_TYPES.TypeImageHash;
pub const SaferIdentityTypeUrlZone = SAFER_IDENTIFICATION_TYPES.TypeUrlZone;
pub const SaferIdentityTypeCertificate = SAFER_IDENTIFICATION_TYPES.TypeCertificate;

pub const SAFER_IDENTIFICATION_HEADER = extern struct {
    dwIdentificationType: SAFER_IDENTIFICATION_TYPES,
    cbStructSize: u32,
    IdentificationGuid: Guid,
    lastModified: FILETIME,
};

pub const SAFER_PATHNAME_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    Description: [256]u16,
    ImageName: [*]u16,
    dwSaferFlags: u32,
};

pub const SAFER_HASH_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    Description: [256]u16,
    FriendlyName: [256]u16,
    HashSize: u32,
    ImageHash: [64]u8,
    HashAlgorithm: u32,
    ImageSize: LARGE_INTEGER,
    dwSaferFlags: u32,
};

pub const SAFER_HASH_IDENTIFICATION2 = extern struct {
    hashIdentification: SAFER_HASH_IDENTIFICATION,
    HashSize: u32,
    ImageHash: [64]u8,
    HashAlgorithm: u32,
};

pub const SAFER_URLZONE_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    UrlZoneId: u32,
    dwSaferFlags: u32,
};

pub const SLDATATYPE = extern enum(u32) {
    NONE = 0,
    SZ = 1,
    DWORD = 4,
    BINARY = 3,
    MULTI_SZ = 7,
    SUM = 100,
};
pub const SL_DATA_NONE = SLDATATYPE.NONE;
pub const SL_DATA_SZ = SLDATATYPE.SZ;
pub const SL_DATA_DWORD = SLDATATYPE.DWORD;
pub const SL_DATA_BINARY = SLDATATYPE.BINARY;
pub const SL_DATA_MULTI_SZ = SLDATATYPE.MULTI_SZ;
pub const SL_DATA_SUM = SLDATATYPE.SUM;

pub const SLIDTYPE = extern enum(i32) {
    APPLICATION = 0,
    PRODUCT_SKU = 1,
    LICENSE_FILE = 2,
    LICENSE = 3,
    PKEY = 4,
    ALL_LICENSES = 5,
    ALL_LICENSE_FILES = 6,
    STORE_TOKEN = 7,
    LAST = 8,
};
pub const SL_ID_APPLICATION = SLIDTYPE.APPLICATION;
pub const SL_ID_PRODUCT_SKU = SLIDTYPE.PRODUCT_SKU;
pub const SL_ID_LICENSE_FILE = SLIDTYPE.LICENSE_FILE;
pub const SL_ID_LICENSE = SLIDTYPE.LICENSE;
pub const SL_ID_PKEY = SLIDTYPE.PKEY;
pub const SL_ID_ALL_LICENSES = SLIDTYPE.ALL_LICENSES;
pub const SL_ID_ALL_LICENSE_FILES = SLIDTYPE.ALL_LICENSE_FILES;
pub const SL_ID_STORE_TOKEN = SLIDTYPE.STORE_TOKEN;
pub const SL_ID_LAST = SLIDTYPE.LAST;

pub const SLLICENSINGSTATUS = extern enum(i32) {
    UNLICENSED = 0,
    LICENSED = 1,
    IN_GRACE_PERIOD = 2,
    NOTIFICATION = 3,
    LAST = 4,
};
pub const SL_LICENSING_STATUS_UNLICENSED = SLLICENSINGSTATUS.UNLICENSED;
pub const SL_LICENSING_STATUS_LICENSED = SLLICENSINGSTATUS.LICENSED;
pub const SL_LICENSING_STATUS_IN_GRACE_PERIOD = SLLICENSINGSTATUS.IN_GRACE_PERIOD;
pub const SL_LICENSING_STATUS_NOTIFICATION = SLLICENSINGSTATUS.NOTIFICATION;
pub const SL_LICENSING_STATUS_LAST = SLLICENSINGSTATUS.LAST;

pub const SL_LICENSING_STATUS = extern struct {
    SkuId: Guid,
    eStatus: SLLICENSINGSTATUS,
    dwGraceTime: u32,
    dwTotalGraceDays: u32,
    hrReason: HRESULT,
    qwValidityExpiration: u64,
};

pub const SL_ACTIVATION_TYPE = extern enum(i32) {
    DEFAULT = 0,
    ACTIVE_DIRECTORY = 1,
};
pub const SL_ACTIVATION_TYPE_DEFAULT = SL_ACTIVATION_TYPE.DEFAULT;
pub const SL_ACTIVATION_TYPE_ACTIVE_DIRECTORY = SL_ACTIVATION_TYPE.ACTIVE_DIRECTORY;

pub const SL_ACTIVATION_INFO_HEADER = extern struct {
    cbSize: u32,
    type: SL_ACTIVATION_TYPE,
};

pub const SL_AD_ACTIVATION_INFO = extern struct {
    header: SL_ACTIVATION_INFO_HEADER,
    pwszProductKey: [*:0]const u16,
    pwszActivationObjectName: [*:0]const u16,
};

pub const SLREFERRALTYPE = extern enum(i32) {
    SKUID = 0,
    APPID = 1,
    OVERRIDE_SKUID = 2,
    OVERRIDE_APPID = 3,
    BEST_MATCH = 4,
};
pub const SL_REFERRALTYPE_SKUID = SLREFERRALTYPE.SKUID;
pub const SL_REFERRALTYPE_APPID = SLREFERRALTYPE.APPID;
pub const SL_REFERRALTYPE_OVERRIDE_SKUID = SLREFERRALTYPE.OVERRIDE_SKUID;
pub const SL_REFERRALTYPE_OVERRIDE_APPID = SLREFERRALTYPE.OVERRIDE_APPID;
pub const SL_REFERRALTYPE_BEST_MATCH = SLREFERRALTYPE.BEST_MATCH;

pub const SL_GENUINE_STATE = extern enum(i32) {
    IS_GENUINE = 0,
    INVALID_LICENSE = 1,
    TAMPERED = 2,
    OFFLINE = 3,
    LAST = 4,
};
pub const SL_GEN_STATE_IS_GENUINE = SL_GENUINE_STATE.IS_GENUINE;
pub const SL_GEN_STATE_INVALID_LICENSE = SL_GENUINE_STATE.INVALID_LICENSE;
pub const SL_GEN_STATE_TAMPERED = SL_GENUINE_STATE.TAMPERED;
pub const SL_GEN_STATE_OFFLINE = SL_GENUINE_STATE.OFFLINE;
pub const SL_GEN_STATE_LAST = SL_GENUINE_STATE.LAST;

pub const SL_NONGENUINE_UI_OPTIONS = extern struct {
    cbSize: u32,
    pComponentId: *const Guid,
    hResultUI: HRESULT,
};

pub const SL_SYSTEM_POLICY_INFORMATION = extern struct {
    Reserved1: [2]*c_void,
    Reserved2: [3]u32,
};

pub const DdqAccessLevel = extern enum(i32) {
    NoData = 0,
    CurrentUserData = 1,
    AllUserData = 2,
};
pub const NoData = DdqAccessLevel.NoData;
pub const CurrentUserData = DdqAccessLevel.CurrentUserData;
pub const AllUserData = DdqAccessLevel.AllUserData;

pub const DIAGNOSTIC_DATA_RECORD = extern struct {
    rowId: i64,
    timestamp: u64,
    eventKeywords: u64,
    fullEventName: PWSTR,
    providerGroupGuid: PWSTR,
    producerName: PWSTR,
    privacyTags: *i32,
    privacyTagCount: u32,
    categoryIds: *i32,
    categoryIdCount: u32,
    isCoreData: BOOL,
    extra1: PWSTR,
    extra2: PWSTR,
    extra3: PWSTR,
};

pub const DIAGNOSTIC_DATA_SEARCH_CRITERIA = extern struct {
    producerNames: *PWSTR,
    producerNameCount: u32,
    textToMatch: [*:0]const u16,
    categoryIds: *const i32,
    categoryIdCount: u32,
    privacyTags: *const i32,
    privacyTagCount: u32,
    coreDataOnly: BOOL,
};

pub const DIAGNOSTIC_DATA_EVENT_TAG_DESCRIPTION = extern struct {
    privacyTag: i32,
    name: PWSTR,
    description: PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_PRODUCER_DESCRIPTION = extern struct {
    name: PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_CATEGORY_DESCRIPTION = extern struct {
    id: i32,
    name: PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_TAG_STATS = extern struct {
    privacyTag: i32,
    eventCount: u32,
};

pub const DIAGNOSTIC_DATA_EVENT_BINARY_STATS = extern struct {
    moduleName: PWSTR,
    friendlyModuleName: PWSTR,
    eventCount: u32,
    uploadSizeBytes: u64,
};

pub const DIAGNOSTIC_DATA_GENERAL_STATS = extern struct {
    optInLevel: u32,
    transcriptSizeBytes: u64,
    oldestEventTimestamp: u64,
    totalEventCountLast24Hours: u32,
    averageDailyEvents: f32,
};

pub const DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION = extern struct {
    hoursOfHistoryToKeep: u32,
    maxStoreMegabytes: u32,
    requestedMaxStoreMegabytes: u32,
};

pub const DIAGNOSTIC_REPORT_PARAMETER = extern struct {
    name: [129]u16,
    value: [260]u16,
};

pub const DIAGNOSTIC_REPORT_SIGNATURE = extern struct {
    eventName: [65]u16,
    parameters: [10]DIAGNOSTIC_REPORT_PARAMETER,
};

pub const DIAGNOSTIC_REPORT_DATA = extern struct {
    signature: DIAGNOSTIC_REPORT_SIGNATURE,
    bucketId: Guid,
    reportId: Guid,
    creationTime: FILETIME,
    sizeInBytes: u64,
    cabId: PWSTR,
    reportStatus: u32,
    reportIntegratorId: Guid,
    fileNames: *PWSTR,
    fileCount: u32,
    friendlyEventName: PWSTR,
    applicationName: PWSTR,
    applicationPath: PWSTR,
    description: PWSTR,
    bucketIdString: PWSTR,
    legacyBucketId: u64,
    reportKey: PWSTR,
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRED_FLAGS = extern enum(u32) {
    PASSWORD_FOR_CERT = 1,
    PROMPT_NOW = 2,
    USERNAME_TARGET = 4,
    OWF_CRED_BLOB = 8,
    REQUIRE_CONFIRMATION = 16,
    WILDCARD_MATCH = 32,
    VSM_PROTECTED = 64,
    NGC_CERT = 128,
    VALID_FLAGS = 61695,
    VALID_INPUT_FLAGS = 61599,
    _,
};
pub const CRED_FLAGS_PASSWORD_FOR_CERT = CRED_FLAGS.PASSWORD_FOR_CERT;
pub const CRED_FLAGS_PROMPT_NOW = CRED_FLAGS.PROMPT_NOW;
pub const CRED_FLAGS_USERNAME_TARGET = CRED_FLAGS.USERNAME_TARGET;
pub const CRED_FLAGS_OWF_CRED_BLOB = CRED_FLAGS.OWF_CRED_BLOB;
pub const CRED_FLAGS_REQUIRE_CONFIRMATION = CRED_FLAGS.REQUIRE_CONFIRMATION;
pub const CRED_FLAGS_WILDCARD_MATCH = CRED_FLAGS.WILDCARD_MATCH;
pub const CRED_FLAGS_VSM_PROTECTED = CRED_FLAGS.VSM_PROTECTED;
pub const CRED_FLAGS_NGC_CERT = CRED_FLAGS.NGC_CERT;
pub const CRED_FLAGS_VALID_FLAGS = CRED_FLAGS.VALID_FLAGS;
pub const CRED_FLAGS_VALID_INPUT_FLAGS = CRED_FLAGS.VALID_INPUT_FLAGS;

pub const CRED_TYPE = extern enum(u32) {
    GENERIC = 1,
    DOMAIN_PASSWORD = 2,
    DOMAIN_CERTIFICATE = 3,
    DOMAIN_VISIBLE_PASSWORD = 4,
    GENERIC_CERTIFICATE = 5,
    DOMAIN_EXTENDED = 6,
    MAXIMUM = 7,
    MAXIMUM_EX = 1007,
};
pub const CRED_TYPE_GENERIC = CRED_TYPE.GENERIC;
pub const CRED_TYPE_DOMAIN_PASSWORD = CRED_TYPE.DOMAIN_PASSWORD;
pub const CRED_TYPE_DOMAIN_CERTIFICATE = CRED_TYPE.DOMAIN_CERTIFICATE;
pub const CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = CRED_TYPE.DOMAIN_VISIBLE_PASSWORD;
pub const CRED_TYPE_GENERIC_CERTIFICATE = CRED_TYPE.GENERIC_CERTIFICATE;
pub const CRED_TYPE_DOMAIN_EXTENDED = CRED_TYPE.DOMAIN_EXTENDED;
pub const CRED_TYPE_MAXIMUM = CRED_TYPE.MAXIMUM;
pub const CRED_TYPE_MAXIMUM_EX = CRED_TYPE.MAXIMUM_EX;

pub const CRED_PERSIST = extern enum(u32) {
    NONE = 0,
    SESSION = 1,
    LOCAL_MACHINE = 2,
    ENTERPRISE = 3,
};
pub const CRED_PERSIST_NONE = CRED_PERSIST.NONE;
pub const CRED_PERSIST_SESSION = CRED_PERSIST.SESSION;
pub const CRED_PERSIST_LOCAL_MACHINE = CRED_PERSIST.LOCAL_MACHINE;
pub const CRED_PERSIST_ENTERPRISE = CRED_PERSIST.ENTERPRISE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const BCRYPT_OPERATION = extern enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    RNG_OPERATION = 32,
    _,
};
pub const BCRYPT_CIPHER_OPERATION = BCRYPT_OPERATION.CIPHER_OPERATION;
pub const BCRYPT_HASH_OPERATION = BCRYPT_OPERATION.HASH_OPERATION;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = BCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const BCRYPT_SECRET_AGREEMENT_OPERATION = BCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const BCRYPT_SIGNATURE_OPERATION = BCRYPT_OPERATION.SIGNATURE_OPERATION;
pub const BCRYPT_RNG_OPERATION = BCRYPT_OPERATION.RNG_OPERATION;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NCRYPT_OPERATION = extern enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    _,
};
pub const NCRYPT_CIPHER_OPERATION = NCRYPT_OPERATION.CIPHER_OPERATION;
pub const NCRYPT_HASH_OPERATION = NCRYPT_OPERATION.HASH_OPERATION;
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = NCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const NCRYPT_SECRET_AGREEMENT_OPERATION = NCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const NCRYPT_SIGNATURE_OPERATION = NCRYPT_OPERATION.SIGNATURE_OPERATION;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_FIND_FLAGS = extern enum(u32) {
    ANY = 0,
    CERT_ID = 1048576,
    CTL_USAGE = 655360,
    ENHKEY_USAGE = 655360,
    EXISTING = 851968,
    HASH = 65536,
    HAS_PRIVATE_KEY = 1376256,
    ISSUER_ATTR = 196612,
    ISSUER_NAME = 131076,
    ISSUER_OF = 786432,
    ISSUER_STR = 524292,
    KEY_IDENTIFIER = 983040,
    KEY_SPEC = 589824,
    MD5_HASH = 262144,
    PROPERTY = 327680,
    PUBLIC_KEY = 393216,
    SHA1_HASH = 65536,
    SIGNATURE_HASH = 917504,
    SUBJECT_ATTR = 196615,
    SUBJECT_CERT = 720896,
    SUBJECT_NAME = 131079,
    SUBJECT_STR = 524295,
    CROSS_CERT_DIST_POINTS = 1114112,
    PUBKEY_MD5_HASH = 1179648,
    SUBJECT_STR_A = 458759,
    SUBJECT_STR_W = 524295,
    ISSUER_STR_A = 458756,
    ISSUER_STR_W = 524292,
    SUBJECT_INFO_ACCESS = 1245184,
    HASH_STR = 1310720,
    OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    EXT_ONLY_ENHKEY_USAGE_FLAG = 2,
    PROP_ONLY_ENHKEY_USAGE_FLAG = 4,
    NO_ENHKEY_USAGE_FLAG = 8,
    OR_ENHKEY_USAGE_FLAG = 16,
    VALID_ENHKEY_USAGE_FLAG = 32,
    OPTIONAL_CTL_USAGE_FLAG = 1,
    EXT_ONLY_CTL_USAGE_FLAG = 2,
    PROP_ONLY_CTL_USAGE_FLAG = 4,
    NO_CTL_USAGE_FLAG = 8,
    OR_CTL_USAGE_FLAG = 16,
    VALID_CTL_USAGE_FLAG = 32,
    _,
};
pub const CERT_FIND_ANY = CERT_FIND_FLAGS.ANY;
pub const CERT_FIND_CERT_ID = CERT_FIND_FLAGS.CERT_ID;
pub const CERT_FIND_CTL_USAGE = CERT_FIND_FLAGS.CTL_USAGE;
pub const CERT_FIND_ENHKEY_USAGE = CERT_FIND_FLAGS.ENHKEY_USAGE;
pub const CERT_FIND_EXISTING = CERT_FIND_FLAGS.EXISTING;
pub const CERT_FIND_HASH = CERT_FIND_FLAGS.HASH;
pub const CERT_FIND_HAS_PRIVATE_KEY = CERT_FIND_FLAGS.HAS_PRIVATE_KEY;
pub const CERT_FIND_ISSUER_ATTR = CERT_FIND_FLAGS.ISSUER_ATTR;
pub const CERT_FIND_ISSUER_NAME = CERT_FIND_FLAGS.ISSUER_NAME;
pub const CERT_FIND_ISSUER_OF = CERT_FIND_FLAGS.ISSUER_OF;
pub const CERT_FIND_ISSUER_STR = CERT_FIND_FLAGS.ISSUER_STR;
pub const CERT_FIND_KEY_IDENTIFIER = CERT_FIND_FLAGS.KEY_IDENTIFIER;
pub const CERT_FIND_KEY_SPEC = CERT_FIND_FLAGS.KEY_SPEC;
pub const CERT_FIND_MD5_HASH = CERT_FIND_FLAGS.MD5_HASH;
pub const CERT_FIND_PROPERTY = CERT_FIND_FLAGS.PROPERTY;
pub const CERT_FIND_PUBLIC_KEY = CERT_FIND_FLAGS.PUBLIC_KEY;
pub const CERT_FIND_SHA1_HASH = CERT_FIND_FLAGS.SHA1_HASH;
pub const CERT_FIND_SIGNATURE_HASH = CERT_FIND_FLAGS.SIGNATURE_HASH;
pub const CERT_FIND_SUBJECT_ATTR = CERT_FIND_FLAGS.SUBJECT_ATTR;
pub const CERT_FIND_SUBJECT_CERT = CERT_FIND_FLAGS.SUBJECT_CERT;
pub const CERT_FIND_SUBJECT_NAME = CERT_FIND_FLAGS.SUBJECT_NAME;
pub const CERT_FIND_SUBJECT_STR = CERT_FIND_FLAGS.SUBJECT_STR;
pub const CERT_FIND_CROSS_CERT_DIST_POINTS = CERT_FIND_FLAGS.CROSS_CERT_DIST_POINTS;
pub const CERT_FIND_PUBKEY_MD5_HASH = CERT_FIND_FLAGS.PUBKEY_MD5_HASH;
pub const CERT_FIND_SUBJECT_STR_A = CERT_FIND_FLAGS.SUBJECT_STR_A;
pub const CERT_FIND_SUBJECT_STR_W = CERT_FIND_FLAGS.SUBJECT_STR_W;
pub const CERT_FIND_ISSUER_STR_A = CERT_FIND_FLAGS.ISSUER_STR_A;
pub const CERT_FIND_ISSUER_STR_W = CERT_FIND_FLAGS.ISSUER_STR_W;
pub const CERT_FIND_SUBJECT_INFO_ACCESS = CERT_FIND_FLAGS.SUBJECT_INFO_ACCESS;
pub const CERT_FIND_HASH_STR = CERT_FIND_FLAGS.HASH_STR;
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_CTL_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_CTL_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_CTL_USAGE_FLAG;
pub const CERT_FIND_NO_CTL_USAGE_FLAG = CERT_FIND_FLAGS.NO_CTL_USAGE_FLAG;
pub const CERT_FIND_OR_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OR_CTL_USAGE_FLAG;
pub const CERT_FIND_VALID_CTL_USAGE_FLAG = CERT_FIND_FLAGS.VALID_CTL_USAGE_FLAG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TOKEN_PRIVILEGES_ATTRIBUTES = extern enum(u32) {
    ENABLED = 2,
    ENABLED_BY_DEFAULT = 1,
    REMOVED = 4,
    USED_FOR_ACCESS = 2147483648,
    _,
};
pub const SE_PRIVILEGE_ENABLED = TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT = TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED_BY_DEFAULT;
pub const SE_PRIVILEGE_REMOVED = TOKEN_PRIVILEGES_ATTRIBUTES.REMOVED;
pub const SE_PRIVILEGE_USED_FOR_ACCESS = TOKEN_PRIVILEGES_ATTRIBUTES.USED_FOR_ACCESS;

pub const CERT_QUERY_OBJECT_TYPE = extern enum(u32) {
    FILE = 1,
    BLOB = 2,
};
pub const CERT_QUERY_OBJECT_FILE = CERT_QUERY_OBJECT_TYPE.FILE;
pub const CERT_QUERY_OBJECT_BLOB = CERT_QUERY_OBJECT_TYPE.BLOB;

pub const CERT_QUERY_CONTENT_TYPE = extern enum(u32) {
    CERT = 1,
    CTL = 2,
    CRL = 3,
    SERIALIZED_STORE = 4,
    SERIALIZED_CERT = 5,
    SERIALIZED_CTL = 6,
    SERIALIZED_CRL = 7,
    PKCS7_SIGNED = 8,
    PKCS7_UNSIGNED = 9,
    PKCS7_SIGNED_EMBED = 10,
    PKCS10 = 11,
    PFX = 12,
    CERT_PAIR = 13,
    PFX_AND_LOAD = 14,
};
pub const CERT_QUERY_CONTENT_CERT = CERT_QUERY_CONTENT_TYPE.CERT;
pub const CERT_QUERY_CONTENT_CTL = CERT_QUERY_CONTENT_TYPE.CTL;
pub const CERT_QUERY_CONTENT_CRL = CERT_QUERY_CONTENT_TYPE.CRL;
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_PKCS10 = CERT_QUERY_CONTENT_TYPE.PKCS10;
pub const CERT_QUERY_CONTENT_PFX = CERT_QUERY_CONTENT_TYPE.PFX;
pub const CERT_QUERY_CONTENT_CERT_PAIR = CERT_QUERY_CONTENT_TYPE.CERT_PAIR;
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE.PFX_AND_LOAD;

pub const CERT_QUERY_CONTENT_TYPE_FLAGS = extern enum(u32) {
    CERT = 2,
    CTL = 4,
    CRL = 8,
    SERIALIZED_STORE = 16,
    SERIALIZED_CERT = 32,
    SERIALIZED_CTL = 64,
    SERIALIZED_CRL = 128,
    PKCS7_SIGNED = 256,
    PKCS7_UNSIGNED = 512,
    PKCS7_SIGNED_EMBED = 1024,
    PKCS10 = 2048,
    PFX = 4096,
    CERT_PAIR = 8192,
    PFX_AND_LOAD = 16384,
    ALL = 16382,
    ALL_ISSUER_CERT = 818,
};
pub const CERT_QUERY_CONTENT_FLAG_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT;
pub const CERT_QUERY_CONTENT_FLAG_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.CTL;
pub const CERT_QUERY_CONTENT_FLAG_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.CRL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS10 = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS10;
pub const CERT_QUERY_CONTENT_FLAG_PFX = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX;
pub const CERT_QUERY_CONTENT_FLAG_CERT_PAIR = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT_PAIR;
pub const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX_AND_LOAD;
pub const CERT_QUERY_CONTENT_FLAG_ALL = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL;
pub const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL_ISSUER_CERT;

pub const CERT_QUERY_FORMAT_TYPE = extern enum(u32) {
    BINARY = 1,
    BASE64_ENCODED = 2,
    ASN_ASCII_HEX_ENCODED = 3,
};
pub const CERT_QUERY_FORMAT_BINARY = CERT_QUERY_FORMAT_TYPE.BINARY;
pub const CERT_QUERY_FORMAT_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE.ASN_ASCII_HEX_ENCODED;

pub const CERT_QUERY_FORMAT_TYPE_FLAGS = extern enum(u32) {
    BINARY = 2,
    BASE64_ENCODED = 4,
    ASN_ASCII_HEX_ENCODED = 8,
    ALL = 14,
};
pub const CERT_QUERY_FORMAT_FLAG_BINARY = CERT_QUERY_FORMAT_TYPE_FLAGS.BINARY;
pub const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.ASN_ASCII_HEX_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ALL = CERT_QUERY_FORMAT_TYPE_FLAGS.ALL;

pub const CERT_QUERY_ENCODING_TYPE = extern enum(u32) {
    X509_ASN_ENCODING = 1,
    PKCS_7_ASN_ENCODING = 65536,
};
pub const X509_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.X509_ASN_ENCODING;
pub const PKCS_7_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.PKCS_7_ASN_ENCODING;

pub const CERT_RDN_ATTR_VALUE_TYPE = extern enum(u32) {
    ANY_TYPE = 0,
    NUMERIC_STRING = 3,
    PRINTABLE_STRING = 4,
    T61_STRING = 5,
    VIDEOTEX_STRING = 6,
    IA5_STRING = 7,
    GRAPHIC_STRING = 8,
    ISO646_STRING = 9,
    GENERAL_STRING = 10,
    INT4_STRING = 11,
    UNICODE_STRING = 12,
    BMP_STRING = 12,
    ENCODED_BLOB = 1,
    OCTET_STRING = 2,
    TELETEX_STRING = 5,
    UNIVERSAL_STRING = 11,
    UTF8_STRING = 13,
    VISIBLE_STRING = 9,
};
pub const CERT_RDN_ANY_TYPE = CERT_RDN_ATTR_VALUE_TYPE.ANY_TYPE;
pub const CERT_RDN_NUMERIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.NUMERIC_STRING;
pub const CERT_RDN_PRINTABLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.PRINTABLE_STRING;
pub const CERT_RDN_T61_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_VIDEOTEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.VIDEOTEX_STRING;
pub const CERT_RDN_IA5_STRING = CERT_RDN_ATTR_VALUE_TYPE.IA5_STRING;
pub const CERT_RDN_GRAPHIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.GRAPHIC_STRING;
pub const CERT_RDN_ISO646_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;
pub const CERT_RDN_GENERAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.GENERAL_STRING;
pub const CERT_RDN_INT4_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UNICODE_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_BMP_STRING = CERT_RDN_ATTR_VALUE_TYPE.BMP_STRING;
pub const CERT_RDN_ENCODED_BLOB = CERT_RDN_ATTR_VALUE_TYPE.ENCODED_BLOB;
pub const CERT_RDN_OCTET_STRING = CERT_RDN_ATTR_VALUE_TYPE.OCTET_STRING;
pub const CERT_RDN_TELETEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.TELETEX_STRING;
pub const CERT_RDN_UNIVERSAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNIVERSAL_STRING;
pub const CERT_RDN_UTF8_STRING = CERT_RDN_ATTR_VALUE_TYPE.UTF8_STRING;
pub const CERT_RDN_VISIBLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.VISIBLE_STRING;

pub const CERT_STRING_TYPE = extern enum(u32) {
    SIMPLE_NAME_STR = 1,
    OID_NAME_STR = 2,
    X500_NAME_STR = 3,
};
pub const CERT_SIMPLE_NAME_STR = CERT_STRING_TYPE.SIMPLE_NAME_STR;
pub const CERT_OID_NAME_STR = CERT_STRING_TYPE.OID_NAME_STR;
pub const CERT_X500_NAME_STR = CERT_STRING_TYPE.X500_NAME_STR;

pub const CERT_VIEW_COLUMN_INDEX = extern enum(i32) {
    LOG_DEFAULT = -2,
    LOG_FAILED_DEFAULT = -3,
    QUEUE_DEFAULT = -1,
};
pub const CV_COLUMN_LOG_DEFAULT = CERT_VIEW_COLUMN_INDEX.LOG_DEFAULT;
pub const CV_COLUMN_LOG_FAILED_DEFAULT = CERT_VIEW_COLUMN_INDEX.LOG_FAILED_DEFAULT;
pub const CV_COLUMN_QUEUE_DEFAULT = CERT_VIEW_COLUMN_INDEX.QUEUE_DEFAULT;

pub const LOGON32_PROVIDER = extern enum(u32) {
    DEFAULT = 0,
    WINNT50 = 3,
    WINNT40 = 2,
};
pub const LOGON32_PROVIDER_DEFAULT = LOGON32_PROVIDER.DEFAULT;
pub const LOGON32_PROVIDER_WINNT50 = LOGON32_PROVIDER.WINNT50;
pub const LOGON32_PROVIDER_WINNT40 = LOGON32_PROVIDER.WINNT40;

pub const CERT_DELETE_ROW_FLAGS = extern enum(u32) {
    EXPIRED = 1,
    REQUEST_LAST_CHANGED = 2,
};
pub const CDR_EXPIRED = CERT_DELETE_ROW_FLAGS.EXPIRED;
pub const CDR_REQUEST_LAST_CHANGED = CERT_DELETE_ROW_FLAGS.REQUEST_LAST_CHANGED;

pub const SECPKG_ATTR = extern enum(u32) {
    C_ACCESS_TOKEN = 2147483666,
    C_FULL_ACCESS_TOKEN = 2147483778,
    CERT_TRUST_STATUS = 2147483780,
    CREDS = 2147483776,
    CREDS_2 = 2147483782,
    NEGOTIATION_PACKAGE = 2147483777,
    PACKAGE_INFO = 10,
    SERVER_AUTH_FLAGS = 2147483779,
    SIZES = 0,
    SUBJECT_SECURITY_ATTRIBUTES = 124,
    APP_DATA = 94,
    EAP_PRF_INFO = 101,
    EARLY_START = 105,
    DTLS_MTU = 34,
    KEYING_MATERIAL_INFO = 106,
    ACCESS_TOKEN = 18,
    AUTHORITY = 6,
    CLIENT_SPECIFIED_TARGET = 27,
    CONNECTION_INFO = 90,
    DCE_INFO = 3,
    ENDPOINT_BINDINGS = 26,
    EAP_KEY_BLOCK = 91,
    FLAGS = 14,
    ISSUER_LIST_EX = 89,
    KEY_INFO = 5,
    LAST_CLIENT_TOKEN_STATUS = 30,
    LIFESPAN = 2,
    LOCAL_CERT_CONTEXT = 84,
    LOCAL_CRED = 82,
    NAMES = 1,
    NATIVE_NAMES = 13,
    NEGOTIATION_INFO = 12,
    PASSWORD_EXPIRY = 8,
    REMOTE_CERT_CONTEXT = 83,
    ROOT_STORE = 85,
    SESSION_KEY = 9,
    SESSION_INFO = 93,
    STREAM_SIZES = 4,
    SUPPORTED_SIGNATURES = 102,
    TARGET_INFORMATION = 17,
    UNIQUE_BINDINGS = 25,
};
pub const SECPKG_ATTR_C_ACCESS_TOKEN = SECPKG_ATTR.C_ACCESS_TOKEN;
pub const SECPKG_ATTR_C_FULL_ACCESS_TOKEN = SECPKG_ATTR.C_FULL_ACCESS_TOKEN;
pub const SECPKG_ATTR_CERT_TRUST_STATUS = SECPKG_ATTR.CERT_TRUST_STATUS;
pub const SECPKG_ATTR_CREDS = SECPKG_ATTR.CREDS;
pub const SECPKG_ATTR_CREDS_2 = SECPKG_ATTR.CREDS_2;
pub const SECPKG_ATTR_NEGOTIATION_PACKAGE = SECPKG_ATTR.NEGOTIATION_PACKAGE;
pub const SECPKG_ATTR_PACKAGE_INFO = SECPKG_ATTR.PACKAGE_INFO;
pub const SECPKG_ATTR_SERVER_AUTH_FLAGS = SECPKG_ATTR.SERVER_AUTH_FLAGS;
pub const SECPKG_ATTR_SIZES = SECPKG_ATTR.SIZES;
pub const SECPKG_ATTR_SUBJECT_SECURITY_ATTRIBUTES = SECPKG_ATTR.SUBJECT_SECURITY_ATTRIBUTES;
pub const SECPKG_ATTR_APP_DATA = SECPKG_ATTR.APP_DATA;
pub const SECPKG_ATTR_EAP_PRF_INFO = SECPKG_ATTR.EAP_PRF_INFO;
pub const SECPKG_ATTR_EARLY_START = SECPKG_ATTR.EARLY_START;
pub const SECPKG_ATTR_DTLS_MTU = SECPKG_ATTR.DTLS_MTU;
pub const SECPKG_ATTR_KEYING_MATERIAL_INFO = SECPKG_ATTR.KEYING_MATERIAL_INFO;
pub const SECPKG_ATTR_ACCESS_TOKEN = SECPKG_ATTR.ACCESS_TOKEN;
pub const SECPKG_ATTR_AUTHORITY = SECPKG_ATTR.AUTHORITY;
pub const SECPKG_ATTR_CLIENT_SPECIFIED_TARGET = SECPKG_ATTR.CLIENT_SPECIFIED_TARGET;
pub const SECPKG_ATTR_CONNECTION_INFO = SECPKG_ATTR.CONNECTION_INFO;
pub const SECPKG_ATTR_DCE_INFO = SECPKG_ATTR.DCE_INFO;
pub const SECPKG_ATTR_ENDPOINT_BINDINGS = SECPKG_ATTR.ENDPOINT_BINDINGS;
pub const SECPKG_ATTR_EAP_KEY_BLOCK = SECPKG_ATTR.EAP_KEY_BLOCK;
pub const SECPKG_ATTR_FLAGS = SECPKG_ATTR.FLAGS;
pub const SECPKG_ATTR_ISSUER_LIST_EX = SECPKG_ATTR.ISSUER_LIST_EX;
pub const SECPKG_ATTR_KEY_INFO = SECPKG_ATTR.KEY_INFO;
pub const SECPKG_ATTR_LAST_CLIENT_TOKEN_STATUS = SECPKG_ATTR.LAST_CLIENT_TOKEN_STATUS;
pub const SECPKG_ATTR_LIFESPAN = SECPKG_ATTR.LIFESPAN;
pub const SECPKG_ATTR_LOCAL_CERT_CONTEXT = SECPKG_ATTR.LOCAL_CERT_CONTEXT;
pub const SECPKG_ATTR_LOCAL_CRED = SECPKG_ATTR.LOCAL_CRED;
pub const SECPKG_ATTR_NAMES = SECPKG_ATTR.NAMES;
pub const SECPKG_ATTR_NATIVE_NAMES = SECPKG_ATTR.NATIVE_NAMES;
pub const SECPKG_ATTR_NEGOTIATION_INFO = SECPKG_ATTR.NEGOTIATION_INFO;
pub const SECPKG_ATTR_PASSWORD_EXPIRY = SECPKG_ATTR.PASSWORD_EXPIRY;
pub const SECPKG_ATTR_REMOTE_CERT_CONTEXT = SECPKG_ATTR.REMOTE_CERT_CONTEXT;
pub const SECPKG_ATTR_ROOT_STORE = SECPKG_ATTR.ROOT_STORE;
pub const SECPKG_ATTR_SESSION_KEY = SECPKG_ATTR.SESSION_KEY;
pub const SECPKG_ATTR_SESSION_INFO = SECPKG_ATTR.SESSION_INFO;
pub const SECPKG_ATTR_STREAM_SIZES = SECPKG_ATTR.STREAM_SIZES;
pub const SECPKG_ATTR_SUPPORTED_SIGNATURES = SECPKG_ATTR.SUPPORTED_SIGNATURES;
pub const SECPKG_ATTR_TARGET_INFORMATION = SECPKG_ATTR.TARGET_INFORMATION;
pub const SECPKG_ATTR_UNIQUE_BINDINGS = SECPKG_ATTR.UNIQUE_BINDINGS;

pub const UNC_INFO_LEVEL = extern enum(u32) {
    UNIVERSAL_NAME_INFO_LEVEL = 1,
    REMOTE_NAME_INFO_LEVEL = 2,
};
pub const UNIVERSAL_NAME_INFO_LEVEL = UNC_INFO_LEVEL.UNIVERSAL_NAME_INFO_LEVEL;
pub const REMOTE_NAME_INFO_LEVEL = UNC_INFO_LEVEL.REMOTE_NAME_INFO_LEVEL;

pub const ENUM_SERVICE_STATE = extern enum(u32) {
    ACTIVE = 1,
    INACTIVE = 2,
    STATE_ALL = 3,
};
pub const SERVICE_ACTIVE = ENUM_SERVICE_STATE.ACTIVE;
pub const SERVICE_INACTIVE = ENUM_SERVICE_STATE.INACTIVE;
pub const SERVICE_STATE_ALL = ENUM_SERVICE_STATE.STATE_ALL;

pub const FULL_RESPONSE_PROPERTY_ID = extern enum(u32) {
    NONE = 0,
    FULLRESPONSE = 1,
    STATUSINFOCOUNT = 2,
    BODYPARTSTRING = 3,
    STATUS = 4,
    STATUSSTRING = 5,
    OTHERINFOCHOICE = 6,
    FAILINFO = 7,
    PENDINFOTOKEN = 8,
    PENDINFOTIME = 9,
    ISSUEDCERTIFICATEHASH = 10,
    ISSUEDCERTIFICATE = 11,
    ISSUEDCERTIFICATECHAIN = 12,
    ISSUEDCERTIFICATECRLCHAIN = 13,
    ENCRYPTEDKEYHASH = 14,
    FULLRESPONSENOPKCS7 = 15,
    CAEXCHANGECERTIFICATEHASH = 16,
    CAEXCHANGECERTIFICATE = 17,
    CAEXCHANGECERTIFICATECHAIN = 18,
    CAEXCHANGECERTIFICATECRLCHAIN = 19,
    ATTESTATIONCHALLENGE = 20,
    ATTESTATIONPROVIDERNAME = 21,
};
pub const FR_PROP_NONE = FULL_RESPONSE_PROPERTY_ID.NONE;
pub const FR_PROP_FULLRESPONSE = FULL_RESPONSE_PROPERTY_ID.FULLRESPONSE;
pub const FR_PROP_STATUSINFOCOUNT = FULL_RESPONSE_PROPERTY_ID.STATUSINFOCOUNT;
pub const FR_PROP_BODYPARTSTRING = FULL_RESPONSE_PROPERTY_ID.BODYPARTSTRING;
pub const FR_PROP_STATUS = FULL_RESPONSE_PROPERTY_ID.STATUS;
pub const FR_PROP_STATUSSTRING = FULL_RESPONSE_PROPERTY_ID.STATUSSTRING;
pub const FR_PROP_OTHERINFOCHOICE = FULL_RESPONSE_PROPERTY_ID.OTHERINFOCHOICE;
pub const FR_PROP_FAILINFO = FULL_RESPONSE_PROPERTY_ID.FAILINFO;
pub const FR_PROP_PENDINFOTOKEN = FULL_RESPONSE_PROPERTY_ID.PENDINFOTOKEN;
pub const FR_PROP_PENDINFOTIME = FULL_RESPONSE_PROPERTY_ID.PENDINFOTIME;
pub const FR_PROP_ISSUEDCERTIFICATEHASH = FULL_RESPONSE_PROPERTY_ID.ISSUEDCERTIFICATEHASH;
pub const FR_PROP_ISSUEDCERTIFICATE = FULL_RESPONSE_PROPERTY_ID.ISSUEDCERTIFICATE;
pub const FR_PROP_ISSUEDCERTIFICATECHAIN = FULL_RESPONSE_PROPERTY_ID.ISSUEDCERTIFICATECHAIN;
pub const FR_PROP_ISSUEDCERTIFICATECRLCHAIN = FULL_RESPONSE_PROPERTY_ID.ISSUEDCERTIFICATECRLCHAIN;
pub const FR_PROP_ENCRYPTEDKEYHASH = FULL_RESPONSE_PROPERTY_ID.ENCRYPTEDKEYHASH;
pub const FR_PROP_FULLRESPONSENOPKCS7 = FULL_RESPONSE_PROPERTY_ID.FULLRESPONSENOPKCS7;
pub const FR_PROP_CAEXCHANGECERTIFICATEHASH = FULL_RESPONSE_PROPERTY_ID.CAEXCHANGECERTIFICATEHASH;
pub const FR_PROP_CAEXCHANGECERTIFICATE = FULL_RESPONSE_PROPERTY_ID.CAEXCHANGECERTIFICATE;
pub const FR_PROP_CAEXCHANGECERTIFICATECHAIN = FULL_RESPONSE_PROPERTY_ID.CAEXCHANGECERTIFICATECHAIN;
pub const FR_PROP_CAEXCHANGECERTIFICATECRLCHAIN = FULL_RESPONSE_PROPERTY_ID.CAEXCHANGECERTIFICATECRLCHAIN;
pub const FR_PROP_ATTESTATIONCHALLENGE = FULL_RESPONSE_PROPERTY_ID.ATTESTATIONCHALLENGE;
pub const FR_PROP_ATTESTATIONPROVIDERNAME = FULL_RESPONSE_PROPERTY_ID.ATTESTATIONPROVIDERNAME;

pub const BCRYPT_TABLE = extern enum(u32) {
    LOCAL = 1,
    DOMAIN = 2,
};
pub const CRYPT_LOCAL = BCRYPT_TABLE.LOCAL;
pub const CRYPT_DOMAIN = BCRYPT_TABLE.DOMAIN;

pub const SERVICE_CONFIG = extern enum(u32) {
    DELAYED_AUTO_START_INFO = 3,
    DESCRIPTION = 1,
    FAILURE_ACTIONS = 2,
    FAILURE_ACTIONS_FLAG = 4,
    PREFERRED_NODE = 9,
    PRESHUTDOWN_INFO = 7,
    REQUIRED_PRIVILEGES_INFO = 6,
    SERVICE_SID_INFO = 5,
    TRIGGER_INFO = 8,
    LAUNCH_PROTECTED = 12,
};
pub const SERVICE_CONFIG_DELAYED_AUTO_START_INFO = SERVICE_CONFIG.DELAYED_AUTO_START_INFO;
pub const SERVICE_CONFIG_DESCRIPTION = SERVICE_CONFIG.DESCRIPTION;
pub const SERVICE_CONFIG_FAILURE_ACTIONS = SERVICE_CONFIG.FAILURE_ACTIONS;
pub const SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = SERVICE_CONFIG.FAILURE_ACTIONS_FLAG;
pub const SERVICE_CONFIG_PREFERRED_NODE = SERVICE_CONFIG.PREFERRED_NODE;
pub const SERVICE_CONFIG_PRESHUTDOWN_INFO = SERVICE_CONFIG.PRESHUTDOWN_INFO;
pub const SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = SERVICE_CONFIG.REQUIRED_PRIVILEGES_INFO;
pub const SERVICE_CONFIG_SERVICE_SID_INFO = SERVICE_CONFIG.SERVICE_SID_INFO;
pub const SERVICE_CONFIG_TRIGGER_INFO = SERVICE_CONFIG.TRIGGER_INFO;
pub const SERVICE_CONFIG_LAUNCH_PROTECTED = SERVICE_CONFIG.LAUNCH_PROTECTED;

pub const SCE_LOG_ERR_LEVEL = extern enum(u32) {
    ALWAYS = 0,
    ERROR = 1,
    DETAIL = 2,
    DEBUG = 3,
};
pub const SCE_LOG_LEVEL_ALWAYS = SCE_LOG_ERR_LEVEL.ALWAYS;
pub const SCE_LOG_LEVEL_ERROR = SCE_LOG_ERR_LEVEL.ERROR;
pub const SCE_LOG_LEVEL_DETAIL = SCE_LOG_ERR_LEVEL.DETAIL;
pub const SCE_LOG_LEVEL_DEBUG = SCE_LOG_ERR_LEVEL.DEBUG;

pub const WNPERM_DLG = extern enum(u32) {
    PERM = 0,
    AUDIT = 1,
    OWNER = 2,
};
pub const WNPERM_DLG_PERM = WNPERM_DLG.PERM;
pub const WNPERM_DLG_AUDIT = WNPERM_DLG.AUDIT;
pub const WNPERM_DLG_OWNER = WNPERM_DLG.OWNER;

pub const CERT_KEY_SPEC = extern enum(u32) {
    AT_KEYEXCHANGE = 1,
    AT_SIGNATURE = 2,
    CERT_NCRYPT_KEY_SPEC = 4294967295,
};
pub const AT_KEYEXCHANGE = CERT_KEY_SPEC.AT_KEYEXCHANGE;
pub const AT_SIGNATURE = CERT_KEY_SPEC.AT_SIGNATURE;
pub const CERT_NCRYPT_KEY_SPEC = CERT_KEY_SPEC.CERT_NCRYPT_KEY_SPEC;

pub const CVRC_COLUMN = extern enum(u32) {
    SCHEMA = 0,
    RESULT = 1,
    VALUE = 2,
    MASK = 4095,
};
pub const CVRC_COLUMN_SCHEMA = CVRC_COLUMN.SCHEMA;
pub const CVRC_COLUMN_RESULT = CVRC_COLUMN.RESULT;
pub const CVRC_COLUMN_VALUE = CVRC_COLUMN.VALUE;
pub const CVRC_COLUMN_MASK = CVRC_COLUMN.MASK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CREATE_RESTRICTED_TOKEN_FLAGS = extern enum(u32) {
    DISABLE_MAX_PRIVILEGE = 1,
    SANDBOX_INERT = 2,
    LUA_TOKEN = 4,
    WRITE_RESTRICTED = 8,
    _,
};
pub const DISABLE_MAX_PRIVILEGE = CREATE_RESTRICTED_TOKEN_FLAGS.DISABLE_MAX_PRIVILEGE;
pub const SANDBOX_INERT = CREATE_RESTRICTED_TOKEN_FLAGS.SANDBOX_INERT;
pub const LUA_TOKEN = CREATE_RESTRICTED_TOKEN_FLAGS.LUA_TOKEN;
pub const WRITE_RESTRICTED = CREATE_RESTRICTED_TOKEN_FLAGS.WRITE_RESTRICTED;

pub const CERT_IMPORT_FLAGS = extern enum(u32) {
    ASE64HEADER = 0,
    ASE64 = 1,
    INARY = 2,
};
pub const CR_IN_BASE64HEADER = CERT_IMPORT_FLAGS.ASE64HEADER;
pub const CR_IN_BASE64 = CERT_IMPORT_FLAGS.ASE64;
pub const CR_IN_BINARY = CERT_IMPORT_FLAGS.INARY;

pub const MSV1_0 = extern enum(u32) {
    PASSTHRU = 1,
    GUEST_LOGON = 2,
};
pub const MSV1_0_PASSTHRU = MSV1_0.PASSTHRU;
pub const MSV1_0_GUEST_LOGON = MSV1_0.GUEST_LOGON;

pub const LOGON32_LOGON = extern enum(u32) {
    BATCH = 4,
    INTERACTIVE = 2,
    NETWORK = 3,
    NETWORK_CLEARTEXT = 8,
    NEW_CREDENTIALS = 9,
    SERVICE = 5,
    UNLOCK = 7,
};
pub const LOGON32_LOGON_BATCH = LOGON32_LOGON.BATCH;
pub const LOGON32_LOGON_INTERACTIVE = LOGON32_LOGON.INTERACTIVE;
pub const LOGON32_LOGON_NETWORK = LOGON32_LOGON.NETWORK;
pub const LOGON32_LOGON_NETWORK_CLEARTEXT = LOGON32_LOGON.NETWORK_CLEARTEXT;
pub const LOGON32_LOGON_NEW_CREDENTIALS = LOGON32_LOGON.NEW_CREDENTIALS;
pub const LOGON32_LOGON_SERVICE = LOGON32_LOGON.SERVICE;
pub const LOGON32_LOGON_UNLOCK = LOGON32_LOGON.UNLOCK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ENUM_SERVICE_TYPE = extern enum(u32) {
    DRIVER = 11,
    FILE_SYSTEM_DRIVER_ = 2,
    KERNEL_DRIVER = 1,
    WIN32 = 48,
    WIN32_OWN_PROCESS_ = 16,
    WIN32_SHARE_PROCESS = 32,
    ADAPTER = 4,
    FILE_SYSTEM_DRIVER = 2,
    RECOGNIZER_DRIVER = 8,
    WIN32_OWN_PROCESS = 16,
    USER_OWN_PROCESS = 80,
    USER_SHARE_PROCESS = 96,
    _,
};
pub const SERVICE_DRIVER = ENUM_SERVICE_TYPE.DRIVER;
pub const SERVICE_FILE_SYSTEM_DRIVER_ = ENUM_SERVICE_TYPE.FILE_SYSTEM_DRIVER_;
pub const SERVICE_KERNEL_DRIVER = ENUM_SERVICE_TYPE.KERNEL_DRIVER;
pub const SERVICE_WIN32 = ENUM_SERVICE_TYPE.WIN32;
pub const SERVICE_WIN32_OWN_PROCESS_ = ENUM_SERVICE_TYPE.WIN32_OWN_PROCESS_;
pub const SERVICE_WIN32_SHARE_PROCESS = ENUM_SERVICE_TYPE.WIN32_SHARE_PROCESS;
pub const SERVICE_ADAPTER = ENUM_SERVICE_TYPE.ADAPTER;
pub const SERVICE_FILE_SYSTEM_DRIVER = ENUM_SERVICE_TYPE.FILE_SYSTEM_DRIVER;
pub const SERVICE_RECOGNIZER_DRIVER = ENUM_SERVICE_TYPE.RECOGNIZER_DRIVER;
pub const SERVICE_WIN32_OWN_PROCESS = ENUM_SERVICE_TYPE.WIN32_OWN_PROCESS;
pub const SERVICE_USER_OWN_PROCESS = ENUM_SERVICE_TYPE.USER_OWN_PROCESS;
pub const SERVICE_USER_SHARE_PROCESS = ENUM_SERVICE_TYPE.USER_SHARE_PROCESS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CREDUI_FLAGS = extern enum(u32) {
    ALWAYS_SHOW_UI = 128,
    COMPLETE_USERNAME = 2048,
    DO_NOT_PERSIST = 2,
    EXCLUDE_CERTIFICATES = 8,
    EXPECT_CONFIRMATION = 131072,
    GENERIC_CREDENTIALS = 262144,
    INCORRECT_PASSWORD = 1,
    KEEP_USERNAME = 1048576,
    PASSWORD_ONLY_OK = 512,
    PERSIST = 4096,
    REQUEST_ADMINISTRATOR = 4,
    REQUIRE_CERTIFICATE = 16,
    REQUIRE_SMARTCARD = 256,
    SERVER_CREDENTIAL = 16384,
    SHOW_SAVE_CHECK_BOX = 64,
    USERNAME_TARGET_CREDENTIALS = 524288,
    VALIDATE_USERNAME = 1024,
    _,
};
pub const CREDUI_FLAGS_ALWAYS_SHOW_UI = CREDUI_FLAGS.ALWAYS_SHOW_UI;
pub const CREDUI_FLAGS_COMPLETE_USERNAME = CREDUI_FLAGS.COMPLETE_USERNAME;
pub const CREDUI_FLAGS_DO_NOT_PERSIST = CREDUI_FLAGS.DO_NOT_PERSIST;
pub const CREDUI_FLAGS_EXCLUDE_CERTIFICATES = CREDUI_FLAGS.EXCLUDE_CERTIFICATES;
pub const CREDUI_FLAGS_EXPECT_CONFIRMATION = CREDUI_FLAGS.EXPECT_CONFIRMATION;
pub const CREDUI_FLAGS_GENERIC_CREDENTIALS = CREDUI_FLAGS.GENERIC_CREDENTIALS;
pub const CREDUI_FLAGS_INCORRECT_PASSWORD = CREDUI_FLAGS.INCORRECT_PASSWORD;
pub const CREDUI_FLAGS_KEEP_USERNAME = CREDUI_FLAGS.KEEP_USERNAME;
pub const CREDUI_FLAGS_PASSWORD_ONLY_OK = CREDUI_FLAGS.PASSWORD_ONLY_OK;
pub const CREDUI_FLAGS_PERSIST = CREDUI_FLAGS.PERSIST;
pub const CREDUI_FLAGS_REQUEST_ADMINISTRATOR = CREDUI_FLAGS.REQUEST_ADMINISTRATOR;
pub const CREDUI_FLAGS_REQUIRE_CERTIFICATE = CREDUI_FLAGS.REQUIRE_CERTIFICATE;
pub const CREDUI_FLAGS_REQUIRE_SMARTCARD = CREDUI_FLAGS.REQUIRE_SMARTCARD;
pub const CREDUI_FLAGS_SERVER_CREDENTIAL = CREDUI_FLAGS.SERVER_CREDENTIAL;
pub const CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = CREDUI_FLAGS.SHOW_SAVE_CHECK_BOX;
pub const CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = CREDUI_FLAGS.USERNAME_TARGET_CREDENTIALS;
pub const CREDUI_FLAGS_VALIDATE_USERNAME = CREDUI_FLAGS.VALIDATE_USERNAME;

pub const BCRYPT_INTERFACE = extern enum(u32) {
    BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    BCRYPT_CIPHER_INTERFACE = 1,
    BCRYPT_HASH_INTERFACE = 2,
    BCRYPT_RNG_INTERFACE = 6,
    BCRYPT_SECRET_AGREEMENT_INTERFACE = 4,
    BCRYPT_SIGNATURE_INTERFACE = 5,
    NCRYPT_KEY_STORAGE_INTERFACE = 65537,
    NCRYPT_SCHANNEL_INTERFACE = 65538,
    NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539,
};
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = BCRYPT_INTERFACE.BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const BCRYPT_CIPHER_INTERFACE = BCRYPT_INTERFACE.BCRYPT_CIPHER_INTERFACE;
pub const BCRYPT_HASH_INTERFACE = BCRYPT_INTERFACE.BCRYPT_HASH_INTERFACE;
pub const BCRYPT_RNG_INTERFACE = BCRYPT_INTERFACE.BCRYPT_RNG_INTERFACE;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SECRET_AGREEMENT_INTERFACE;
pub const BCRYPT_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SIGNATURE_INTERFACE;
pub const NCRYPT_KEY_STORAGE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_KEY_STORAGE_INTERFACE;
pub const NCRYPT_SCHANNEL_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_INTERFACE;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_SIGNATURE_INTERFACE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPTUI_WIZ_FLAGS = extern enum(u32) {
    NO_UI = 1,
    IGNORE_NO_UI_FLAG_FOR_CSPS = 2,
    NO_UI_EXCEPT_CSP = 3,
    IMPORT_ALLOW_CERT = 131072,
    IMPORT_ALLOW_CRL = 262144,
    IMPORT_ALLOW_CTL = 524288,
    IMPORT_NO_CHANGE_DEST_STORE = 65536,
    IMPORT_TO_LOCALMACHINE = 1048576,
    IMPORT_TO_CURRENTUSER = 2097152,
    IMPORT_REMOTE_DEST_STORE = 4194304,
    EXPORT_PRIVATE_KEY = 256,
    EXPORT_NO_DELETE_PRIVATE_KEY = 512,
    _,
};
pub const CRYPTUI_WIZ_NO_UI = CRYPTUI_WIZ_FLAGS.NO_UI;
pub const CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS = CRYPTUI_WIZ_FLAGS.IGNORE_NO_UI_FLAG_FOR_CSPS;
pub const CRYPTUI_WIZ_NO_UI_EXCEPT_CSP = CRYPTUI_WIZ_FLAGS.NO_UI_EXCEPT_CSP;
pub const CRYPTUI_WIZ_IMPORT_ALLOW_CERT = CRYPTUI_WIZ_FLAGS.IMPORT_ALLOW_CERT;
pub const CRYPTUI_WIZ_IMPORT_ALLOW_CRL = CRYPTUI_WIZ_FLAGS.IMPORT_ALLOW_CRL;
pub const CRYPTUI_WIZ_IMPORT_ALLOW_CTL = CRYPTUI_WIZ_FLAGS.IMPORT_ALLOW_CTL;
pub const CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE = CRYPTUI_WIZ_FLAGS.IMPORT_NO_CHANGE_DEST_STORE;
pub const CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE = CRYPTUI_WIZ_FLAGS.IMPORT_TO_LOCALMACHINE;
pub const CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER = CRYPTUI_WIZ_FLAGS.IMPORT_TO_CURRENTUSER;
pub const CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE = CRYPTUI_WIZ_FLAGS.IMPORT_REMOTE_DEST_STORE;
pub const CRYPTUI_WIZ_EXPORT_PRIVATE_KEY = CRYPTUI_WIZ_FLAGS.EXPORT_PRIVATE_KEY;
pub const CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY = CRYPTUI_WIZ_FLAGS.EXPORT_NO_DELETE_PRIVATE_KEY;

pub const CERT_GET_CONFIG_FLAGS = extern enum(u32) {
    DEFAULTCONFIG = 0,
    FIRSTCONFIG = 2,
    LOCALACTIVECONFIG = 4,
    LOCALCONFIG = 3,
    UIPICKCONFIG = 1,
    UIPICKCONFIGSKIPLOCALCA_ = 5,
};
pub const CC_DEFAULTCONFIG = CERT_GET_CONFIG_FLAGS.DEFAULTCONFIG;
pub const CC_FIRSTCONFIG = CERT_GET_CONFIG_FLAGS.FIRSTCONFIG;
pub const CC_LOCALACTIVECONFIG = CERT_GET_CONFIG_FLAGS.LOCALACTIVECONFIG;
pub const CC_LOCALCONFIG = CERT_GET_CONFIG_FLAGS.LOCALCONFIG;
pub const CC_UIPICKCONFIG = CERT_GET_CONFIG_FLAGS.UIPICKCONFIG;
pub const CC_UIPICKCONFIGSKIPLOCALCA_ = CERT_GET_CONFIG_FLAGS.UIPICKCONFIGSKIPLOCALCA_;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NCRYPT_FLAGS = extern enum(u32) {
    BCRYPT_PAD_NONE = 1,
    BCRYPT_PAD_OAEP = 4,
    BCRYPT_PAD_PKCS1 = 2,
    BCRYPT_PAD_PSS = 8,
    NCRYPT_SILENT_FLAG = 64,
    NCRYPT_NO_PADDING_FLAG = 1,
    NCRYPT_PAD_OAEP_FLAG = 4,
    NCRYPT_PAD_PKCS1_FLAG = 2,
    NCRYPT_REGISTER_NOTIFY_FLAG = 1,
    NCRYPT_UNREGISTER_NOTIFY_FLAG = 2,
    NCRYPT_MACHINE_KEY_FLAG = 32,
    NCRYPT_UNPROTECT_NO_DECRYPT = 1,
    NCRYPT_OVERWRITE_KEY_FLAG = 128,
    NCRYPT_NO_KEY_VALIDATION = 8,
    NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 512,
    NCRYPT_PAD_PSS_FLAG = 8,
    NCRYPT_PERSIST_FLAG = 2147483648,
    NCRYPT_PERSIST_ONLY_FLAG = 1073741824,
    _,
};
pub const BCRYPT_PAD_NONE = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const BCRYPT_PAD_OAEP = NCRYPT_FLAGS.BCRYPT_PAD_OAEP;
pub const BCRYPT_PAD_PKCS1 = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const BCRYPT_PAD_PSS = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_SILENT_FLAG = NCRYPT_FLAGS.NCRYPT_SILENT_FLAG;
pub const NCRYPT_NO_PADDING_FLAG = NCRYPT_FLAGS.NCRYPT_NO_PADDING_FLAG;
pub const NCRYPT_PAD_OAEP_FLAG = NCRYPT_FLAGS.NCRYPT_PAD_OAEP_FLAG;
pub const NCRYPT_PAD_PKCS1_FLAG = NCRYPT_FLAGS.NCRYPT_PAD_PKCS1_FLAG;
pub const NCRYPT_REGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.NCRYPT_REGISTER_NOTIFY_FLAG;
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.NCRYPT_UNREGISTER_NOTIFY_FLAG;
pub const NCRYPT_MACHINE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_MACHINE_KEY_FLAG;
pub const NCRYPT_UNPROTECT_NO_DECRYPT = NCRYPT_FLAGS.NCRYPT_UNPROTECT_NO_DECRYPT;
pub const NCRYPT_OVERWRITE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_OVERWRITE_KEY_FLAG;
pub const NCRYPT_NO_KEY_VALIDATION = NCRYPT_FLAGS.NCRYPT_NO_KEY_VALIDATION;
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = NCRYPT_FLAGS.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG;
pub const NCRYPT_PAD_PSS_FLAG = NCRYPT_FLAGS.NCRYPT_PAD_PSS_FLAG;
pub const NCRYPT_PERSIST_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_FLAG;
pub const NCRYPT_PERSIST_ONLY_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_ONLY_FLAG;

pub const CRYPT_STRING = extern enum(u32) {
    BASE64HEADER = 0,
    BASE64 = 1,
    BINARY = 2,
    BASE64REQUESTHEADER = 3,
    HEX = 4,
    HEXASCII = 5,
    BASE64X509CRLHEADER = 9,
    HEXADDR = 10,
    HEXASCIIADDR = 11,
    HEXRAW = 12,
    STRICT = 536870912,
    BASE64_ANY = 6,
    ANY = 7,
    HEX_ANY = 8,
};
pub const CRYPT_STRING_BASE64HEADER = CRYPT_STRING.BASE64HEADER;
pub const CRYPT_STRING_BASE64 = CRYPT_STRING.BASE64;
pub const CRYPT_STRING_BINARY = CRYPT_STRING.BINARY;
pub const CRYPT_STRING_BASE64REQUESTHEADER = CRYPT_STRING.BASE64REQUESTHEADER;
pub const CRYPT_STRING_HEX = CRYPT_STRING.HEX;
pub const CRYPT_STRING_HEXASCII = CRYPT_STRING.HEXASCII;
pub const CRYPT_STRING_BASE64X509CRLHEADER = CRYPT_STRING.BASE64X509CRLHEADER;
pub const CRYPT_STRING_HEXADDR = CRYPT_STRING.HEXADDR;
pub const CRYPT_STRING_HEXASCIIADDR = CRYPT_STRING.HEXASCIIADDR;
pub const CRYPT_STRING_HEXRAW = CRYPT_STRING.HEXRAW;
pub const CRYPT_STRING_STRICT = CRYPT_STRING.STRICT;
pub const CRYPT_STRING_BASE64_ANY = CRYPT_STRING.BASE64_ANY;
pub const CRYPT_STRING_ANY = CRYPT_STRING.ANY;
pub const CRYPT_STRING_HEX_ANY = CRYPT_STRING.HEX_ANY;

pub const ENUM_CERT_COLUMN_VALUE_FLAGS = extern enum(u32) {
    BASE64 = 1,
    BASE64HEADER = 0,
    BASE64REQUESTHEADER = 3,
    BASE64X509CRLHEADER = 9,
    BINARY = 2,
    HEX = 4,
    HEXADDR = 10,
    HEXASCII = 5,
    HEXASCIIADDR = 11,
};
pub const CV_OUT_BASE64 = ENUM_CERT_COLUMN_VALUE_FLAGS.BASE64;
pub const CV_OUT_BASE64HEADER = ENUM_CERT_COLUMN_VALUE_FLAGS.BASE64HEADER;
pub const CV_OUT_BASE64REQUESTHEADER = ENUM_CERT_COLUMN_VALUE_FLAGS.BASE64REQUESTHEADER;
pub const CV_OUT_BASE64X509CRLHEADER = ENUM_CERT_COLUMN_VALUE_FLAGS.BASE64X509CRLHEADER;
pub const CV_OUT_BINARY = ENUM_CERT_COLUMN_VALUE_FLAGS.BINARY;
pub const CV_OUT_HEX = ENUM_CERT_COLUMN_VALUE_FLAGS.HEX;
pub const CV_OUT_HEXADDR = ENUM_CERT_COLUMN_VALUE_FLAGS.HEXADDR;
pub const CV_OUT_HEXASCII = ENUM_CERT_COLUMN_VALUE_FLAGS.HEXASCII;
pub const CV_OUT_HEXASCIIADDR = ENUM_CERT_COLUMN_VALUE_FLAGS.HEXASCIIADDR;

pub const PENDING_REQUEST_DESIRED_PROPERTY = extern enum(u32) {
    CADNS = 1,
    CAFRIENDLYNAME = 3,
    CANAME = 2,
    HASH = 8,
    REQUESTID = 4,
};
pub const XEPR_CADNS = PENDING_REQUEST_DESIRED_PROPERTY.CADNS;
pub const XEPR_CAFRIENDLYNAME = PENDING_REQUEST_DESIRED_PROPERTY.CAFRIENDLYNAME;
pub const XEPR_CANAME = PENDING_REQUEST_DESIRED_PROPERTY.CANAME;
pub const XEPR_HASH = PENDING_REQUEST_DESIRED_PROPERTY.HASH;
pub const XEPR_REQUESTID = PENDING_REQUEST_DESIRED_PROPERTY.REQUESTID;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_IMPORT_PUBLIC_KEY_FLAGS = extern enum(u32) {
    SIGN_KEY_FLAG = 2147483648,
    ENCRYPT_KEY_FLAG = 1073741824,
    _,
};
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.SIGN_KEY_FLAG;
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.ENCRYPT_KEY_FLAG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERTADMIN_GET_ROLES_FLAGS = extern enum(u32) {
    ADMIN = 1,
    AUDITOR = 4,
    ENROLL = 512,
    OFFICER = 2,
    OPERATOR = 8,
    READ = 256,
    _,
};
pub const CA_ACCESS_ADMIN = CERTADMIN_GET_ROLES_FLAGS.ADMIN;
pub const CA_ACCESS_AUDITOR = CERTADMIN_GET_ROLES_FLAGS.AUDITOR;
pub const CA_ACCESS_ENROLL = CERTADMIN_GET_ROLES_FLAGS.ENROLL;
pub const CA_ACCESS_OFFICER = CERTADMIN_GET_ROLES_FLAGS.OFFICER;
pub const CA_ACCESS_OPERATOR = CERTADMIN_GET_ROLES_FLAGS.OPERATOR;
pub const CA_ACCESS_READ = CERTADMIN_GET_ROLES_FLAGS.READ;

pub const CRYPT_XML_FLAGS = extern enum(u32) {
    FLAG_DISABLE_EXTENSIONS = 268435456,
    FLAG_NO_SERIALIZE = 2147483648,
    SIGN_ADD_KEYVALUE = 1,
};
pub const CRYPT_XML_FLAG_DISABLE_EXTENSIONS = CRYPT_XML_FLAGS.FLAG_DISABLE_EXTENSIONS;
pub const CRYPT_XML_FLAG_NO_SERIALIZE = CRYPT_XML_FLAGS.FLAG_NO_SERIALIZE;
pub const CRYPT_XML_SIGN_ADD_KEYVALUE = CRYPT_XML_FLAGS.SIGN_ADD_KEYVALUE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ACE_FLAGS = extern enum(u32) {
    CONTAINER_INHERIT_ACE = 2,
    FAILED_ACCESS_ACE_FLAG = 128,
    INHERIT_ONLY_ACE = 8,
    INHERITED_ACE = 16,
    NO_PROPAGATE_INHERIT_ACE = 4,
    OBJECT_INHERIT_ACE = 1,
    SUCCESSFUL_ACCESS_ACE_FLAG = 64,
    SUB_CONTAINERS_AND_OBJECTS_INHERIT = 3,
    SUB_CONTAINERS_ONLY_INHERIT = 2,
    SUB_OBJECTS_ONLY_INHERIT = 1,
    INHERIT_NO_PROPAGATE = 4,
    INHERIT_ONLY = 8,
    NO_INHERITANCE = 0,
    INHERIT_ONLY_ACE_ = 8,
    _,
};
pub const CONTAINER_INHERIT_ACE = ACE_FLAGS.CONTAINER_INHERIT_ACE;
pub const FAILED_ACCESS_ACE_FLAG = ACE_FLAGS.FAILED_ACCESS_ACE_FLAG;
pub const INHERIT_ONLY_ACE = ACE_FLAGS.INHERIT_ONLY_ACE;
pub const INHERITED_ACE = ACE_FLAGS.INHERITED_ACE;
pub const NO_PROPAGATE_INHERIT_ACE = ACE_FLAGS.NO_PROPAGATE_INHERIT_ACE;
pub const OBJECT_INHERIT_ACE = ACE_FLAGS.OBJECT_INHERIT_ACE;
pub const SUCCESSFUL_ACCESS_ACE_FLAG = ACE_FLAGS.SUCCESSFUL_ACCESS_ACE_FLAG;
pub const SUB_CONTAINERS_AND_OBJECTS_INHERIT = ACE_FLAGS.SUB_CONTAINERS_AND_OBJECTS_INHERIT;
pub const SUB_CONTAINERS_ONLY_INHERIT = ACE_FLAGS.SUB_CONTAINERS_ONLY_INHERIT;
pub const SUB_OBJECTS_ONLY_INHERIT = ACE_FLAGS.SUB_OBJECTS_ONLY_INHERIT;
pub const INHERIT_NO_PROPAGATE = ACE_FLAGS.INHERIT_NO_PROPAGATE;
pub const INHERIT_ONLY = ACE_FLAGS.INHERIT_ONLY;
pub const NO_INHERITANCE = ACE_FLAGS.NO_INHERITANCE;
pub const INHERIT_ONLY_ACE_ = ACE_FLAGS.INHERIT_ONLY_ACE_;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const AUTHZ_RESOURCE_MANAGER_FLAGS = extern enum(u32) {
    NO_AUDIT = 1,
    INITIALIZE_UNDER_IMPERSONATION = 2,
    NO_CENTRAL_ACCESS_POLICIES = 4,
    _,
};
pub const AUTHZ_RM_FLAG_NO_AUDIT = AUTHZ_RESOURCE_MANAGER_FLAGS.NO_AUDIT;
pub const AUTHZ_RM_FLAG_INITIALIZE_UNDER_IMPERSONATION = AUTHZ_RESOURCE_MANAGER_FLAGS.INITIALIZE_UNDER_IMPERSONATION;
pub const AUTHZ_RM_FLAG_NO_CENTRAL_ACCESS_POLICIES = AUTHZ_RESOURCE_MANAGER_FLAGS.NO_CENTRAL_ACCESS_POLICIES;

pub const CR_DISP = extern enum(u32) {
    DENIED = 2,
    ERROR = 1,
    INCOMPLETE = 0,
    ISSUED = 3,
    ISSUED_OUT_OF_BAND = 4,
    UNDER_SUBMISSION = 5,
};
pub const CR_DISP_DENIED = CR_DISP.DENIED;
pub const CR_DISP_ERROR = CR_DISP.ERROR;
pub const CR_DISP_INCOMPLETE = CR_DISP.INCOMPLETE;
pub const CR_DISP_ISSUED = CR_DISP.ISSUED;
pub const CR_DISP_ISSUED_OUT_OF_BAND = CR_DISP.ISSUED_OUT_OF_BAND;
pub const CR_DISP_UNDER_SUBMISSION = CR_DISP.UNDER_SUBMISSION;

pub const XEKL_KEYSIZE = extern enum(u32) {
    MIN = 1,
    MAX = 2,
    INC = 3,
};
pub const XEKL_KEYSIZE_MIN = XEKL_KEYSIZE.MIN;
pub const XEKL_KEYSIZE_MAX = XEKL_KEYSIZE.MAX;
pub const XEKL_KEYSIZE_INC = XEKL_KEYSIZE.INC;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_ENCODE_OBJECT_FLAGS = extern enum(u32) {
    ENCODE_ALLOC_FLAG = 32768,
    ENCODE_ENABLE_PUNYCODE_FLAG = 131072,
    UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = 1073741824,
    UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = 2147483648,
    UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = 536870912,
    _,
};
pub const CRYPT_ENCODE_ALLOC_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ALLOC_FLAG;
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ENABLE_PUNYCODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const OBJECT_SECURITY_INFORMATION = extern enum(u32) {
    DACL_SECURITY_INFORMATION = 4,
    GROUP_SECURITY_INFORMATION = 2,
    OWNER_SECURITY_INFORMATION = 1,
    SACL_SECURITY_INFORMATION = 8,
    _,
};
pub const DACL_SECURITY_INFORMATION = OBJECT_SECURITY_INFORMATION.DACL_SECURITY_INFORMATION;
pub const GROUP_SECURITY_INFORMATION = OBJECT_SECURITY_INFORMATION.GROUP_SECURITY_INFORMATION;
pub const OWNER_SECURITY_INFORMATION = OBJECT_SECURITY_INFORMATION.OWNER_SECURITY_INFORMATION;
pub const SACL_SECURITY_INFORMATION = OBJECT_SECURITY_INFORMATION.SACL_SECURITY_INFORMATION;

pub const CRYPT_OBJECT_LOCATOR_RELEASE_REASON = extern enum(u32) {
    SYSTEM_SHUTDOWN = 1,
    SERVICE_STOP = 2,
    PROCESS_EXIT = 3,
    DLL_UNLOAD = 4,
};
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SYSTEM_SHUTDOWN;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SERVICE_STOP;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.PROCESS_EXIT;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.DLL_UNLOAD;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_ACQUIRE_FLAGS = extern enum(u32) {
    CACHE_FLAG = 1,
    COMPARE_KEY_FLAG = 4,
    NO_HEALING = 8,
    SILENT_FLAG = 64,
    USE_PROV_INFO_FLAG = 2,
    _,
};
pub const CRYPT_ACQUIRE_CACHE_FLAG = CRYPT_ACQUIRE_FLAGS.CACHE_FLAG;
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = CRYPT_ACQUIRE_FLAGS.COMPARE_KEY_FLAG;
pub const CRYPT_ACQUIRE_NO_HEALING = CRYPT_ACQUIRE_FLAGS.NO_HEALING;
pub const CRYPT_ACQUIRE_SILENT_FLAG = CRYPT_ACQUIRE_FLAGS.SILENT_FLAG;
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = CRYPT_ACQUIRE_FLAGS.USE_PROV_INFO_FLAG;

pub const CERT_CREATE_REQUEST_FLAGS = extern enum(u32) {
    CMC = 3,
    PKCS10_V1_5 = 4,
    PKCS10_V2_0 = 1,
    PKCS7 = 2,
};
pub const XECR_CMC = CERT_CREATE_REQUEST_FLAGS.CMC;
pub const XECR_PKCS10_V1_5 = CERT_CREATE_REQUEST_FLAGS.PKCS10_V1_5;
pub const XECR_PKCS10_V2_0 = CERT_CREATE_REQUEST_FLAGS.PKCS10_V2_0;
pub const XECR_PKCS7 = CERT_CREATE_REQUEST_FLAGS.PKCS7;

pub const SECPKG_CRED = extern enum(u32) {
    INBOUND = 1,
    OUTBOUND = 2,
};
pub const SECPKG_CRED_INBOUND = SECPKG_CRED.INBOUND;
pub const SECPKG_CRED_OUTBOUND = SECPKG_CRED.OUTBOUND;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_GET_URL_FLAGS = extern enum(u32) {
    PROPERTY = 1,
    EXTENSION = 2,
    UNAUTH_ATTRIBUTE = 4,
    AUTH_ATTRIBUTE = 8,
    _,
};
pub const CRYPT_GET_URL_FROM_PROPERTY = CRYPT_GET_URL_FLAGS.PROPERTY;
pub const CRYPT_GET_URL_FROM_EXTENSION = CRYPT_GET_URL_FLAGS.EXTENSION;
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.UNAUTH_ATTRIBUTE;
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.AUTH_ATTRIBUTE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SECURITY_INFO_PAGE_FLAGS = extern enum(u32) {
    ADVANCED = 16,
    EDIT_AUDITS = 2,
    EDIT_PROPERTIES = 128,
    _,
};
pub const SI_ADVANCED = SECURITY_INFO_PAGE_FLAGS.ADVANCED;
pub const SI_EDIT_AUDITS = SECURITY_INFO_PAGE_FLAGS.EDIT_AUDITS;
pub const SI_EDIT_PROPERTIES = SECURITY_INFO_PAGE_FLAGS.EDIT_PROPERTIES;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_EXIT_EVENT_MASK = extern enum(u32) {
    CERTDENIED = 4,
    CERTISSUED = 1,
    CERTPENDING = 2,
    CERTRETRIEVEPENDING = 16,
    CERTREVOKED = 8,
    CRLISSUED = 32,
    SHUTDOWN = 64,
    _,
};
pub const EXITEVENT_CERTDENIED = CERT_EXIT_EVENT_MASK.CERTDENIED;
pub const EXITEVENT_CERTISSUED = CERT_EXIT_EVENT_MASK.CERTISSUED;
pub const EXITEVENT_CERTPENDING = CERT_EXIT_EVENT_MASK.CERTPENDING;
pub const EXITEVENT_CERTRETRIEVEPENDING = CERT_EXIT_EVENT_MASK.CERTRETRIEVEPENDING;
pub const EXITEVENT_CERTREVOKED = CERT_EXIT_EVENT_MASK.CERTREVOKED;
pub const EXITEVENT_CRLISSUED = CERT_EXIT_EVENT_MASK.CRLISSUED;
pub const EXITEVENT_SHUTDOWN = CERT_EXIT_EVENT_MASK.SHUTDOWN;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SECURITY_AUTO_INHERIT_FLAGS = extern enum(u32) {
    AVOID_OWNER_CHECK = 16,
    AVOID_OWNER_RESTRICTION = 4096,
    AVOID_PRIVILEGE_CHECK = 8,
    DACL_AUTO_INHERIT = 1,
    DEFAULT_DESCRIPTOR_FOR_OBJECT = 4,
    DEFAULT_GROUP_FROM_PARENT = 64,
    DEFAULT_OWNER_FROM_PARENT = 32,
    MACL_NO_EXECUTE_UP = 1024,
    MACL_NO_READ_UP = 512,
    MACL_NO_WRITE_UP = 256,
    SACL_AUTO_INHERIT = 2,
    _,
};
pub const SEF_AVOID_OWNER_CHECK = SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_CHECK;
pub const SEF_AVOID_OWNER_RESTRICTION = SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_RESTRICTION;
pub const SEF_AVOID_PRIVILEGE_CHECK = SECURITY_AUTO_INHERIT_FLAGS.AVOID_PRIVILEGE_CHECK;
pub const SEF_DACL_AUTO_INHERIT = SECURITY_AUTO_INHERIT_FLAGS.DACL_AUTO_INHERIT;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_DESCRIPTOR_FOR_OBJECT;
pub const SEF_DEFAULT_GROUP_FROM_PARENT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_GROUP_FROM_PARENT;
pub const SEF_DEFAULT_OWNER_FROM_PARENT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_OWNER_FROM_PARENT;
pub const SEF_MACL_NO_EXECUTE_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_EXECUTE_UP;
pub const SEF_MACL_NO_READ_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_READ_UP;
pub const SEF_MACL_NO_WRITE_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_WRITE_UP;
pub const SEF_SACL_AUTO_INHERIT = SECURITY_AUTO_INHERIT_FLAGS.SACL_AUTO_INHERIT;

pub const NP_PROPERTY_DIALOG_SELECTION = extern enum(u32) {
    FILE = 0,
    DIR = 1,
    MULT = 2,
};
pub const WNPS_FILE = NP_PROPERTY_DIALOG_SELECTION.FILE;
pub const WNPS_DIR = NP_PROPERTY_DIALOG_SELECTION.DIR;
pub const WNPS_MULT = NP_PROPERTY_DIALOG_SELECTION.MULT;

pub const NPDIRECTORY_NOTIFY_OPERATION = extern enum(u32) {
    MKDIR = 1,
    RMDIR = 2,
    MVDIR = 3,
};
pub const WNDN_MKDIR = NPDIRECTORY_NOTIFY_OPERATION.MKDIR;
pub const WNDN_RMDIR = NPDIRECTORY_NOTIFY_OPERATION.RMDIR;
pub const WNDN_MVDIR = NPDIRECTORY_NOTIFY_OPERATION.MVDIR;

pub const CERT_STORE_SAVE_AS = extern enum(u32) {
    PKCS7 = 2,
    STORE = 1,
};
pub const CERT_STORE_SAVE_AS_PKCS7 = CERT_STORE_SAVE_AS.PKCS7;
pub const CERT_STORE_SAVE_AS_STORE = CERT_STORE_SAVE_AS.STORE;

pub const BCRYPT_QUERY_PROVIDER_MODE = extern enum(u32) {
    ANY = 4,
    UM = 1,
    KM = 2,
    MM = 3,
};
pub const CRYPT_ANY = BCRYPT_QUERY_PROVIDER_MODE.ANY;
pub const CRYPT_UM = BCRYPT_QUERY_PROVIDER_MODE.UM;
pub const CRYPT_KM = BCRYPT_QUERY_PROVIDER_MODE.KM;
pub const CRYPT_MM = BCRYPT_QUERY_PROVIDER_MODE.MM;

pub const ADDED_CERT_TYPE = extern enum(u32) {
    @"1" = 1,
    @"2" = 2,
};
pub const XECT_EXTENSION_V1 = ADDED_CERT_TYPE.@"1";
pub const XECT_EXTENSION_V2 = ADDED_CERT_TYPE.@"2";

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_FIND_CHAIN_IN_STORE_FLAGS = extern enum(u32) {
    COMPARE_KEY_FLAG = 1,
    COMPLEX_CHAIN_FLAG = 2,
    CACHE_ONLY_FLAG = 32768,
    CACHE_ONLY_URL_FLAG = 4,
    LOCAL_MACHINE_FLAG = 8,
    NO_KEY_FLAG = 16384,
    _,
};
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPARE_KEY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPLEX_CHAIN_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_URL_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.LOCAL_MACHINE_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.NO_KEY_FLAG;

pub const CERT_CONTROL_STORE_FLAGS = extern enum(u32) {
    COMMIT_FORCE_FLAG = 1,
    COMMIT_CLEAR_FLAG = 2,
    INHIBIT_DUPLICATE_HANDLE_FLAG = 1,
};
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_CLEAR_FLAG;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = CERT_CONTROL_STORE_FLAGS.INHIBIT_DUPLICATE_HANDLE_FLAG;

pub const AUTHZ_ACCESS_CHECK_FLAGS = extern enum(u32) {
    D = 1,
};
pub const AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD = AUTHZ_ACCESS_CHECK_FLAGS.D;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS = extern enum(u32) {
    ALG_HANDLE_HMAC_FLAG = 8,
    PROV_DISPATCH = 1,
    HASH_REUSABLE_FLAG = 32,
    _,
};
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.ALG_HANDLE_HMAC_FLAG;
pub const BCRYPT_PROV_DISPATCH = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.PROV_DISPATCH;
pub const BCRYPT_HASH_REUSABLE_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.HASH_REUSABLE_FLAG;

pub const AUTHZ_INITIALIZE_OBJECT_ACCESS_AUDIT_EVENT_FLAGS = extern enum(u32) {
    SUCCESS_AUDIT = 1,
    FAILURE_AUDIT = 2,
    ALLOC_STRINGS = 4,
};
pub const AUTHZ_NO_SUCCESS_AUDIT = AUTHZ_INITIALIZE_OBJECT_ACCESS_AUDIT_EVENT_FLAGS.SUCCESS_AUDIT;
pub const AUTHZ_NO_FAILURE_AUDIT = AUTHZ_INITIALIZE_OBJECT_ACCESS_AUDIT_EVENT_FLAGS.FAILURE_AUDIT;
pub const AUTHZ_NO_ALLOC_STRINGS = AUTHZ_INITIALIZE_OBJECT_ACCESS_AUDIT_EVENT_FLAGS.ALLOC_STRINGS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS = extern enum(u32) {
    NULL_IF_EQUAL = 1,
    COMPARE_ONLY = 2,
    MAKE_INERT = 4,
    WANT_FLAGS = 8,
    _,
};
pub const SAFER_TOKEN_NULL_IF_EQUAL = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.NULL_IF_EQUAL;
pub const SAFER_TOKEN_COMPARE_ONLY = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.COMPARE_ONLY;
pub const SAFER_TOKEN_MAKE_INERT = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.MAKE_INERT;
pub const SAFER_TOKEN_WANT_FLAGS = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.WANT_FLAGS;

pub const CVRC_TABLE = extern enum(u32) {
    ATTRIBUTES = 16384,
    CRL = 20480,
    EXTENSIONS = 12288,
    REQCERT = 0,
};
pub const CVRC_TABLE_ATTRIBUTES = CVRC_TABLE.ATTRIBUTES;
pub const CVRC_TABLE_CRL = CVRC_TABLE.CRL;
pub const CVRC_TABLE_EXTENSIONS = CVRC_TABLE.EXTENSIONS;
pub const CVRC_TABLE_REQCERT = CVRC_TABLE.REQCERT;

pub const CERT_STORE_SAVE_TO = extern enum(u32) {
    FILE = 1,
    FILENAME = 4,
    FILENAME_A = 3,
    FILENAME_W = 4,
    MEMORY = 2,
};
pub const CERT_STORE_SAVE_TO_FILE = CERT_STORE_SAVE_TO.FILE;
pub const CERT_STORE_SAVE_TO_FILENAME = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_FILENAME_A = CERT_STORE_SAVE_TO.FILENAME_A;
pub const CERT_STORE_SAVE_TO_FILENAME_W = CERT_STORE_SAVE_TO.FILENAME_W;
pub const CERT_STORE_SAVE_TO_MEMORY = CERT_STORE_SAVE_TO.MEMORY;

pub const CRYPT_SET_PROV_PARAM_ID = extern enum(u32) {
    CLIENT_HWND = 1,
    DELETEKEY = 24,
    KEYEXCHANGE_ALG = 14,
    KEYEXCHANGE_PIN = 32,
    KEYEXCHANGE_KEYSIZE = 12,
    KEYSET_SEC_DESCR = 8,
    PIN_PROMPT_STRING = 44,
    ROOT_CERTSTORE = 46,
    SIGNATURE_ALG = 15,
    SIGNATURE_PIN = 33,
    SIGNATURE_KEYSIZE = 13,
    UI_PROMPT = 21,
    USE_HARDWARE_RNG = 38,
    USER_CERTSTORE = 42,
    SECURE_KEYEXCHANGE_PIN = 47,
    SECURE_SIGNATURE_PIN = 48,
    SMARTCARD_READER = 43,
};
pub const PP_CLIENT_HWND = CRYPT_SET_PROV_PARAM_ID.CLIENT_HWND;
pub const PP_DELETEKEY = CRYPT_SET_PROV_PARAM_ID.DELETEKEY;
pub const PP_KEYEXCHANGE_ALG = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_ALG;
pub const PP_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_PIN;
pub const PP_KEYEXCHANGE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_KEYSIZE;
pub const PP_KEYSET_SEC_DESCR = CRYPT_SET_PROV_PARAM_ID.KEYSET_SEC_DESCR;
pub const PP_PIN_PROMPT_STRING = CRYPT_SET_PROV_PARAM_ID.PIN_PROMPT_STRING;
pub const PP_ROOT_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.ROOT_CERTSTORE;
pub const PP_SIGNATURE_ALG = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_ALG;
pub const PP_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_PIN;
pub const PP_SIGNATURE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_KEYSIZE;
pub const PP_UI_PROMPT = CRYPT_SET_PROV_PARAM_ID.UI_PROMPT;
pub const PP_USE_HARDWARE_RNG = CRYPT_SET_PROV_PARAM_ID.USE_HARDWARE_RNG;
pub const PP_USER_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.USER_CERTSTORE;
pub const PP_SECURE_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_KEYEXCHANGE_PIN;
pub const PP_SECURE_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_SIGNATURE_PIN;
pub const PP_SMARTCARD_READER = CRYPT_SET_PROV_PARAM_ID.SMARTCARD_READER;

pub const CERT_PROPERTY_TYPE = extern enum(u32) {
    BINARY = 3,
    DATE = 2,
    LONG = 1,
    STRING = 4,
};
pub const PROPTYPE_BINARY = CERT_PROPERTY_TYPE.BINARY;
pub const PROPTYPE_DATE = CERT_PROPERTY_TYPE.DATE;
pub const PROPTYPE_LONG = CERT_PROPERTY_TYPE.LONG;
pub const PROPTYPE_STRING = CERT_PROPERTY_TYPE.STRING;

pub const CRYPT_KEY_PARAM_ID = extern enum(u32) {
    ALGID = 7,
    CERTIFICATE = 26,
    PERMISSIONS = 6,
    SALT = 2,
    SALT_EX = 10,
    BLOCKLEN = 8,
    GET_USE_COUNT = 42,
    KEYLEN = 9,
};
pub const KP_ALGID = CRYPT_KEY_PARAM_ID.ALGID;
pub const KP_CERTIFICATE = CRYPT_KEY_PARAM_ID.CERTIFICATE;
pub const KP_PERMISSIONS = CRYPT_KEY_PARAM_ID.PERMISSIONS;
pub const KP_SALT = CRYPT_KEY_PARAM_ID.SALT;
pub const KP_SALT_EX = CRYPT_KEY_PARAM_ID.SALT_EX;
pub const KP_BLOCKLEN = CRYPT_KEY_PARAM_ID.BLOCKLEN;
pub const KP_GET_USE_COUNT = CRYPT_KEY_PARAM_ID.GET_USE_COUNT;
pub const KP_KEYLEN = CRYPT_KEY_PARAM_ID.KEYLEN;

pub const MSV_SUB_AUTHENTICATION_FILTER = extern enum(u32) {
    GUEST = 1,
    NOENCRYPTION = 2,
    CACHED_ACCOUNT = 4,
    USED_LM_PASSWORD = 8,
    EXTRA_SIDS = 32,
    SUBAUTH_SESSION_KEY = 64,
    SERVER_TRUST_ACCOUNT = 128,
    PROFILE_PATH_RETURNED = 1024,
    RESOURCE_GROUPS = 512,
};
pub const LOGON_GUEST = MSV_SUB_AUTHENTICATION_FILTER.GUEST;
pub const LOGON_NOENCRYPTION = MSV_SUB_AUTHENTICATION_FILTER.NOENCRYPTION;
pub const LOGON_CACHED_ACCOUNT = MSV_SUB_AUTHENTICATION_FILTER.CACHED_ACCOUNT;
pub const LOGON_USED_LM_PASSWORD = MSV_SUB_AUTHENTICATION_FILTER.USED_LM_PASSWORD;
pub const LOGON_EXTRA_SIDS = MSV_SUB_AUTHENTICATION_FILTER.EXTRA_SIDS;
pub const LOGON_SUBAUTH_SESSION_KEY = MSV_SUB_AUTHENTICATION_FILTER.SUBAUTH_SESSION_KEY;
pub const LOGON_SERVER_TRUST_ACCOUNT = MSV_SUB_AUTHENTICATION_FILTER.SERVER_TRUST_ACCOUNT;
pub const LOGON_PROFILE_PATH_RETURNED = MSV_SUB_AUTHENTICATION_FILTER.PROFILE_PATH_RETURNED;
pub const LOGON_RESOURCE_GROUPS = MSV_SUB_AUTHENTICATION_FILTER.RESOURCE_GROUPS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_KEY_FLAGS = extern enum(u32) {
    CRYPT_EXPORTABLE = 1,
    CRYPT_USER_PROTECTED = 2,
    CRYPT_ARCHIVABLE = 16384,
    CRYPT_CREATE_IV = 512,
    CRYPT_CREATE_SALT = 4,
    CRYPT_DATA_KEY = 2048,
    CRYPT_FORCE_KEY_PROTECTION_HIGH = 32768,
    CRYPT_KEK = 1024,
    CRYPT_INITIATOR = 64,
    CRYPT_NO_SALT = 16,
    CRYPT_ONLINE = 128,
    CRYPT_PREGEN = 64,
    CRYPT_RECIPIENT = 16,
    CRYPT_SF = 256,
    CRYPT_SGCKEY = 8192,
    CRYPT_VOLATILE = 4096,
    CRYPT_MACHINE_KEYSET = 32,
    CRYPT_USER_KEYSET = 4096,
    PKCS12_PREFER_CNG_KSP = 256,
    PKCS12_ALWAYS_CNG_KSP = 512,
    PKCS12_ALLOW_OVERWRITE_KEY = 16384,
    PKCS12_NO_PERSIST_KEY = 32768,
    PKCS12_INCLUDE_EXTENDED_PROPERTIES = 16,
    CRYPT_OAEP = 64,
    CRYPT_BLOB_VER3 = 128,
    CRYPT_DESTROYKEY = 4,
    CRYPT_SSL2_FALLBACK = 2,
    CRYPT_Y_ONLY = 1,
    CRYPT_IPSEC_HMAC_KEY = 256,
    _,
};
pub const CRYPT_EXPORTABLE = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CRYPT_USER_PROTECTED = CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED;
pub const CRYPT_ARCHIVABLE = CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE;
pub const CRYPT_CREATE_IV = CRYPT_KEY_FLAGS.CRYPT_CREATE_IV;
pub const CRYPT_CREATE_SALT = CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT;
pub const CRYPT_DATA_KEY = CRYPT_KEY_FLAGS.CRYPT_DATA_KEY;
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH = CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH;
pub const CRYPT_KEK = CRYPT_KEY_FLAGS.CRYPT_KEK;
pub const CRYPT_INITIATOR = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_NO_SALT = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_ONLINE = CRYPT_KEY_FLAGS.CRYPT_ONLINE;
pub const CRYPT_PREGEN = CRYPT_KEY_FLAGS.CRYPT_PREGEN;
pub const CRYPT_RECIPIENT = CRYPT_KEY_FLAGS.CRYPT_RECIPIENT;
pub const CRYPT_SF = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const CRYPT_SGCKEY = CRYPT_KEY_FLAGS.CRYPT_SGCKEY;
pub const CRYPT_VOLATILE = CRYPT_KEY_FLAGS.CRYPT_VOLATILE;
pub const CRYPT_MACHINE_KEYSET = CRYPT_KEY_FLAGS.CRYPT_MACHINE_KEYSET;
pub const CRYPT_USER_KEYSET = CRYPT_KEY_FLAGS.CRYPT_USER_KEYSET;
pub const PKCS12_PREFER_CNG_KSP = CRYPT_KEY_FLAGS.PKCS12_PREFER_CNG_KSP;
pub const PKCS12_ALWAYS_CNG_KSP = CRYPT_KEY_FLAGS.PKCS12_ALWAYS_CNG_KSP;
pub const PKCS12_ALLOW_OVERWRITE_KEY = CRYPT_KEY_FLAGS.PKCS12_ALLOW_OVERWRITE_KEY;
pub const PKCS12_NO_PERSIST_KEY = CRYPT_KEY_FLAGS.PKCS12_NO_PERSIST_KEY;
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES = CRYPT_KEY_FLAGS.PKCS12_INCLUDE_EXTENDED_PROPERTIES;
pub const CRYPT_OAEP = CRYPT_KEY_FLAGS.CRYPT_OAEP;
pub const CRYPT_BLOB_VER3 = CRYPT_KEY_FLAGS.CRYPT_BLOB_VER3;
pub const CRYPT_DESTROYKEY = CRYPT_KEY_FLAGS.CRYPT_DESTROYKEY;
pub const CRYPT_SSL2_FALLBACK = CRYPT_KEY_FLAGS.CRYPT_SSL2_FALLBACK;
pub const CRYPT_Y_ONLY = CRYPT_KEY_FLAGS.CRYPT_Y_ONLY;
pub const CRYPT_IPSEC_HMAC_KEY = CRYPT_KEY_FLAGS.CRYPT_IPSEC_HMAC_KEY;

pub const WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION = extern enum(u32) {
    ALLOCANDFILL = 1,
    FREE = 2,
};
pub const DWACTION_ALLOCANDFILL = WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION.ALLOCANDFILL;
pub const DWACTION_FREE = WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION.FREE;

pub const TREE_SEC_INFO = extern enum(u32) {
    SET = 1,
    RESET = 2,
    RESET_KEEP_EXPLICIT = 3,
};
pub const TREE_SEC_INFO_SET = TREE_SEC_INFO.SET;
pub const TREE_SEC_INFO_RESET = TREE_SEC_INFO.RESET;
pub const TREE_SEC_INFO_RESET_KEEP_EXPLICIT = TREE_SEC_INFO.RESET_KEEP_EXPLICIT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const EXPORT_SECURITY_CONTEXT_FLAGS = extern enum(u32) {
    RESET_NEW = 1,
    DELETE_OLD = 2,
    TO_KERNEL = 4,
    _,
};
pub const SECPKG_CONTEXT_EXPORT_RESET_NEW = EXPORT_SECURITY_CONTEXT_FLAGS.RESET_NEW;
pub const SECPKG_CONTEXT_EXPORT_DELETE_OLD = EXPORT_SECURITY_CONTEXT_FLAGS.DELETE_OLD;
pub const SECPKG_CONTEXT_EXPORT_TO_KERNEL = EXPORT_SECURITY_CONTEXT_FLAGS.TO_KERNEL;

pub const CERT_ALT_NAME = extern enum(u32) {
    RFC822_NAME = 2,
    DNS_NAME = 3,
    URL = 7,
    REGISTERED_ID = 9,
    DIRECTORY_NAME = 5,
    IP_ADDRESS = 8,
    OTHER_NAME = 1,
};
pub const CERT_ALT_NAME_RFC822_NAME = CERT_ALT_NAME.RFC822_NAME;
pub const CERT_ALT_NAME_DNS_NAME = CERT_ALT_NAME.DNS_NAME;
pub const CERT_ALT_NAME_URL = CERT_ALT_NAME.URL;
pub const CERT_ALT_NAME_REGISTERED_ID = CERT_ALT_NAME.REGISTERED_ID;
pub const CERT_ALT_NAME_DIRECTORY_NAME = CERT_ALT_NAME.DIRECTORY_NAME;
pub const CERT_ALT_NAME_IP_ADDRESS = CERT_ALT_NAME.IP_ADDRESS;
pub const CERT_ALT_NAME_OTHER_NAME = CERT_ALT_NAME.OTHER_NAME;

pub const SCARD_SCOPE = extern enum(u32) {
    USER = 0,
    SYSTEM = 2,
};
pub const SCARD_SCOPE_USER = SCARD_SCOPE.USER;
pub const SCARD_SCOPE_SYSTEM = SCARD_SCOPE.SYSTEM;

pub const CRYPT_MSG_TYPE = extern enum(u32) {
    DATA = 1,
    SIGNED = 2,
    ENVELOPED = 3,
    SIGNED_AND_ENVELOPED = 4,
    HASHED = 5,
};
pub const CMSG_DATA = CRYPT_MSG_TYPE.DATA;
pub const CMSG_SIGNED = CRYPT_MSG_TYPE.SIGNED;
pub const CMSG_ENVELOPED = CRYPT_MSG_TYPE.ENVELOPED;
pub const CMSG_SIGNED_AND_ENVELOPED = CRYPT_MSG_TYPE.SIGNED_AND_ENVELOPED;
pub const CMSG_HASHED = CRYPT_MSG_TYPE.HASHED;

pub const CSBACKUP_TYPE = extern enum(u32) {
    FULL = 1,
    LOGS_ONLY = 2,
};
pub const CSBACKUP_TYPE_FULL = CSBACKUP_TYPE.FULL;
pub const CSBACKUP_TYPE_LOGS_ONLY = CSBACKUP_TYPE.LOGS_ONLY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SERVICE_NOTIFY = extern enum(u32) {
    CREATED = 128,
    CONTINUE_PENDING = 16,
    DELETE_PENDING = 512,
    DELETED = 256,
    PAUSE_PENDING = 32,
    PAUSED = 64,
    RUNNING = 8,
    START_PENDING = 2,
    STOP_PENDING = 4,
    STOPPED = 1,
    _,
};
pub const SERVICE_NOTIFY_CREATED = SERVICE_NOTIFY.CREATED;
pub const SERVICE_NOTIFY_CONTINUE_PENDING = SERVICE_NOTIFY.CONTINUE_PENDING;
pub const SERVICE_NOTIFY_DELETE_PENDING = SERVICE_NOTIFY.DELETE_PENDING;
pub const SERVICE_NOTIFY_DELETED = SERVICE_NOTIFY.DELETED;
pub const SERVICE_NOTIFY_PAUSE_PENDING = SERVICE_NOTIFY.PAUSE_PENDING;
pub const SERVICE_NOTIFY_PAUSED = SERVICE_NOTIFY.PAUSED;
pub const SERVICE_NOTIFY_RUNNING = SERVICE_NOTIFY.RUNNING;
pub const SERVICE_NOTIFY_START_PENDING = SERVICE_NOTIFY.START_PENDING;
pub const SERVICE_NOTIFY_STOP_PENDING = SERVICE_NOTIFY.STOP_PENDING;
pub const SERVICE_NOTIFY_STOPPED = SERVICE_NOTIFY.STOPPED;

pub const ACE_REVISION = extern enum(u32) {
    N = 2,
    _DS = 4,
};
pub const ACL_REVISION = ACE_REVISION.N;
pub const ACL_REVISION_DS = ACE_REVISION._DS;

pub const CERT_OPEN_STORE_FLAGS = extern enum(u32) {
    BACKUP_RESTORE_FLAG = 2048,
    CREATE_NEW_FLAG = 8192,
    DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4,
    DELETE_FLAG = 16,
    ENUM_ARCHIVED_FLAG = 512,
    MAXIMUM_ALLOWED_FLAG = 4096,
    NO_CRYPT_RELEASE_FLAG = 1,
    OPEN_EXISTING_FLAG = 16384,
    READONLY_FLAG = 32768,
    SET_LOCALIZED_NAME_FLAG = 2,
    SHARE_CONTEXT_FLAG = 128,
    UPDATE_KEYID_FLAG = 1024,
};
pub const CERT_STORE_BACKUP_RESTORE_FLAG = CERT_OPEN_STORE_FLAGS.BACKUP_RESTORE_FLAG;
pub const CERT_STORE_CREATE_NEW_FLAG = CERT_OPEN_STORE_FLAGS.CREATE_NEW_FLAG;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = CERT_OPEN_STORE_FLAGS.DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
pub const CERT_STORE_DELETE_FLAG = CERT_OPEN_STORE_FLAGS.DELETE_FLAG;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG = CERT_OPEN_STORE_FLAGS.ENUM_ARCHIVED_FLAG;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG = CERT_OPEN_STORE_FLAGS.MAXIMUM_ALLOWED_FLAG;
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG = CERT_OPEN_STORE_FLAGS.NO_CRYPT_RELEASE_FLAG;
pub const CERT_STORE_OPEN_EXISTING_FLAG = CERT_OPEN_STORE_FLAGS.OPEN_EXISTING_FLAG;
pub const CERT_STORE_READONLY_FLAG = CERT_OPEN_STORE_FLAGS.READONLY_FLAG;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG = CERT_OPEN_STORE_FLAGS.SET_LOCALIZED_NAME_FLAG;
pub const CERT_STORE_SHARE_CONTEXT_FLAG = CERT_OPEN_STORE_FLAGS.SHARE_CONTEXT_FLAG;
pub const CERT_STORE_UPDATE_KEYID_FLAG = CERT_OPEN_STORE_FLAGS.UPDATE_KEYID_FLAG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_DEFAULT_CONTEXT_FLAGS = extern enum(u32) {
    AUTO_RELEASE_FLAG = 1,
    PROCESS_FLAG = 2,
    _,
};
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.AUTO_RELEASE_FLAG;
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.PROCESS_FLAG;

pub const XEKL_KEYSPEC = extern enum(u32) {
    KEYX = 1,
    SIG = 2,
};
pub const XEKL_KEYSPEC_KEYX = XEKL_KEYSPEC.KEYX;
pub const XEKL_KEYSPEC_SIG = XEKL_KEYSPEC.SIG;

pub const CRYPT_VERIFY_CERT_FLAGS = extern enum(u32) {
    DISABLE_MD2_MD4_FLAG = 1,
    SET_STRONG_PROPERTIES_FLAG = 2,
    RETURN_STRONG_PROPERTIES_FLAG = 4,
};
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = CRYPT_VERIFY_CERT_FLAGS.DISABLE_MD2_MD4_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.SET_STRONG_PROPERTIES_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.RETURN_STRONG_PROPERTIES_FLAG;

pub const CERT_REQUEST_OUT_TYPE = extern enum(u32) {
    ASE64HEADER = 0,
    ASE64 = 1,
    INARY = 2,
};
pub const CR_OUT_BASE64HEADER = CERT_REQUEST_OUT_TYPE.ASE64HEADER;
pub const CR_OUT_BASE64 = CERT_REQUEST_OUT_TYPE.ASE64;
pub const CR_OUT_BINARY = CERT_REQUEST_OUT_TYPE.INARY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const WINTRUST_POLICY_FLAGS = extern enum(u32) {
    TRUSTTEST = 32,
    TESTCANBEVALID = 128,
    IGNOREEXPIRATION = 256,
    IGNOREREVOKATION = 512,
    OFFLINEOK_IND = 1024,
    OFFLINEOK_COM = 2048,
    OFFLINEOKNBU_IND = 4096,
    OFFLINEOKNBU_COM = 8192,
    VERIFY_V1_OFF = 65536,
    IGNOREREVOCATIONONTS = 131072,
    ALLOWONLYPERTRUST = 262144,
    _,
};
pub const WTPF_TRUSTTEST = WINTRUST_POLICY_FLAGS.TRUSTTEST;
pub const WTPF_TESTCANBEVALID = WINTRUST_POLICY_FLAGS.TESTCANBEVALID;
pub const WTPF_IGNOREEXPIRATION = WINTRUST_POLICY_FLAGS.IGNOREEXPIRATION;
pub const WTPF_IGNOREREVOKATION = WINTRUST_POLICY_FLAGS.IGNOREREVOKATION;
pub const WTPF_OFFLINEOK_IND = WINTRUST_POLICY_FLAGS.OFFLINEOK_IND;
pub const WTPF_OFFLINEOK_COM = WINTRUST_POLICY_FLAGS.OFFLINEOK_COM;
pub const WTPF_OFFLINEOKNBU_IND = WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_IND;
pub const WTPF_OFFLINEOKNBU_COM = WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_COM;
pub const WTPF_VERIFY_V1_OFF = WINTRUST_POLICY_FLAGS.VERIFY_V1_OFF;
pub const WTPF_IGNOREREVOCATIONONTS = WINTRUST_POLICY_FLAGS.IGNOREREVOCATIONONTS;
pub const WTPF_ALLOWONLYPERTRUST = WINTRUST_POLICY_FLAGS.ALLOWONLYPERTRUST;

pub const NETWORK_NAME_FORMAT_FLAGS = extern enum(u32) {
    MULTILINE = 1,
    ABBREVIATED = 2,
};
pub const WNFMT_MULTILINE = NETWORK_NAME_FORMAT_FLAGS.MULTILINE;
pub const WNFMT_ABBREVIATED = NETWORK_NAME_FORMAT_FLAGS.ABBREVIATED;

pub const CRYPT_SET_HASH_PARAM = extern enum(u32) {
    MAC_INFO = 5,
    ASHVAL = 2,
};
pub const HP_HMAC_INFO = CRYPT_SET_HASH_PARAM.MAC_INFO;
pub const HP_HASHVAL = CRYPT_SET_HASH_PARAM.ASHVAL;

pub const CERT_VIEW_SEEK_OPERATOR_FLAGS = extern enum(u32) {
    EQ = 1,
    LE = 4,
    LT = 2,
    GE = 8,
    GT = 16,
};
pub const CVR_SEEK_EQ = CERT_VIEW_SEEK_OPERATOR_FLAGS.EQ;
pub const CVR_SEEK_LE = CERT_VIEW_SEEK_OPERATOR_FLAGS.LE;
pub const CVR_SEEK_LT = CERT_VIEW_SEEK_OPERATOR_FLAGS.LT;
pub const CVR_SEEK_GE = CERT_VIEW_SEEK_OPERATOR_FLAGS.GE;
pub const CVR_SEEK_GT = CERT_VIEW_SEEK_OPERATOR_FLAGS.GT;

pub const WLX_SHUTDOWN_TYPE = extern enum(u32) {
    N = 5,
    _REBOOT = 11,
    _POWER_OFF = 10,
};
pub const WLX_SAS_ACTION_SHUTDOWN = WLX_SHUTDOWN_TYPE.N;
pub const WLX_SAS_ACTION_SHUTDOWN_REBOOT = WLX_SHUTDOWN_TYPE._REBOOT;
pub const WLX_SAS_ACTION_SHUTDOWN_POWER_OFF = WLX_SHUTDOWN_TYPE._POWER_OFF;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRED_ENUMERATE_FLAGS = extern enum(u32) {
    S = 1,
    _,
};
pub const CRED_ENUMERATE_ALL_CREDENTIALS = CRED_ENUMERATE_FLAGS.S;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ = extern enum(u32) {
    ALLOCATE_MEMORY = 256,
    CONNECTION = 2048,
    DELEGATE = 1,
    EXTENDED_ERROR = 32768,
    REPLAY_DETECT = 4,
    SEQUENCE_DETECT = 8,
    STREAM = 65536,
    _,
};
pub const ASC_REQ_ALLOCATE_MEMORY = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.ALLOCATE_MEMORY;
pub const ASC_REQ_CONNECTION = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.CONNECTION;
pub const ASC_REQ_DELEGATE = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.DELEGATE;
pub const ASC_REQ_EXTENDED_ERROR = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.EXTENDED_ERROR;
pub const ASC_REQ_REPLAY_DETECT = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.REPLAY_DETECT;
pub const ASC_REQ_SEQUENCE_DETECT = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.SEQUENCE_DETECT;
pub const ASC_REQ_STREAM = ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ.STREAM;

pub const CRYPTCAT_VERSION = extern enum(u32) {
    @"1" = 256,
    @"2" = 512,
};
pub const CRYPTCAT_VERSION_1 = CRYPTCAT_VERSION.@"1";
pub const CRYPTCAT_VERSION_2 = CRYPTCAT_VERSION.@"2";

pub const CERT_SYSTEM_STORE_FLAGS = extern enum(u32) {
    LOCATION_MASK = 16711680,
    RELOCATE_FLAG = 2147483648,
};
pub const CERT_SYSTEM_STORE_LOCATION_MASK = CERT_SYSTEM_STORE_FLAGS.LOCATION_MASK;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG = CERT_SYSTEM_STORE_FLAGS.RELOCATE_FLAG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CREDUIWIN_FLAGS = extern enum(u32) {
    GENERIC = 1,
    CHECKBOX = 2,
    AUTHPACKAGE_ONLY = 16,
    IN_CRED_ONLY = 32,
    ENUMERATE_ADMINS = 256,
    ENUMERATE_CURRENT_USER = 512,
    SECURE_PROMPT = 4096,
    PREPROMPTING = 8192,
    PACK_32_WOW = 268435456,
    _,
};
pub const CREDUIWIN_GENERIC = CREDUIWIN_FLAGS.GENERIC;
pub const CREDUIWIN_CHECKBOX = CREDUIWIN_FLAGS.CHECKBOX;
pub const CREDUIWIN_AUTHPACKAGE_ONLY = CREDUIWIN_FLAGS.AUTHPACKAGE_ONLY;
pub const CREDUIWIN_IN_CRED_ONLY = CREDUIWIN_FLAGS.IN_CRED_ONLY;
pub const CREDUIWIN_ENUMERATE_ADMINS = CREDUIWIN_FLAGS.ENUMERATE_ADMINS;
pub const CREDUIWIN_ENUMERATE_CURRENT_USER = CREDUIWIN_FLAGS.ENUMERATE_CURRENT_USER;
pub const CREDUIWIN_SECURE_PROMPT = CREDUIWIN_FLAGS.SECURE_PROMPT;
pub const CREDUIWIN_PREPROMPTING = CREDUIWIN_FLAGS.PREPROMPTING;
pub const CREDUIWIN_PACK_32_WOW = CREDUIWIN_FLAGS.PACK_32_WOW;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_CREATE_SELFSIGN_FLAGS = extern enum(u32) {
    KEY_INFO = 2,
    SIGN = 1,
    _,
};
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO = CERT_CREATE_SELFSIGN_FLAGS.KEY_INFO;
pub const CERT_CREATE_SELFSIGN_NO_SIGN = CERT_CREATE_SELFSIGN_FLAGS.SIGN;

pub const CRYPT_DEFAULT_CONTEXT_TYPE = extern enum(u32) {
    CERT_SIGN_OID = 1,
    MULTI_CERT_SIGN_OID = 2,
};
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.CERT_SIGN_OID;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.MULTI_CERT_SIGN_OID;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPTCAT_OPEN_FLAGS = extern enum(u32) {
    ALWAYS = 2,
    CREATENEW = 1,
    EXISTING = 4,
    EXCLUDE_PAGE_HASHES = 65536,
    INCLUDE_PAGE_HASHES = 131072,
    VERIFYSIGHASH = 268435456,
    NO_CONTENT_HCRYPTMSG = 536870912,
    SORTED = 1073741824,
    FLAGS_MASK = 4294901760,
    _,
};
pub const CRYPTCAT_OPEN_ALWAYS = CRYPTCAT_OPEN_FLAGS.ALWAYS;
pub const CRYPTCAT_OPEN_CREATENEW = CRYPTCAT_OPEN_FLAGS.CREATENEW;
pub const CRYPTCAT_OPEN_EXISTING = CRYPTCAT_OPEN_FLAGS.EXISTING;
pub const CRYPTCAT_OPEN_EXCLUDE_PAGE_HASHES = CRYPTCAT_OPEN_FLAGS.EXCLUDE_PAGE_HASHES;
pub const CRYPTCAT_OPEN_INCLUDE_PAGE_HASHES = CRYPTCAT_OPEN_FLAGS.INCLUDE_PAGE_HASHES;
pub const CRYPTCAT_OPEN_VERIFYSIGHASH = CRYPTCAT_OPEN_FLAGS.VERIFYSIGHASH;
pub const CRYPTCAT_OPEN_NO_CONTENT_HCRYPTMSG = CRYPTCAT_OPEN_FLAGS.NO_CONTENT_HCRYPTMSG;
pub const CRYPTCAT_OPEN_SORTED = CRYPTCAT_OPEN_FLAGS.SORTED;
pub const CRYPTCAT_OPEN_FLAGS_MASK = CRYPTCAT_OPEN_FLAGS.FLAGS_MASK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const BCRYPT_RESOLVE_PROVIDERS_FLAGS = extern enum(u32) {
    FUNCTIONS = 1,
    PROVIDERS = 2,
    _,
};
pub const CRYPT_ALL_FUNCTIONS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.FUNCTIONS;
pub const CRYPT_ALL_PROVIDERS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.PROVIDERS;

pub const CERT_FIND_TYPE = extern enum(u32) {
    ANY = 0,
    SHA1_HASH = 1,
    MD5_HASH = 2,
    USAGE = 3,
    SAME_USAGE_FLAG = 1,
    EXISTING = 5,
    SUBJECT = 4,
};
pub const CTL_FIND_ANY = CERT_FIND_TYPE.ANY;
pub const CTL_FIND_SHA1_HASH = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_MD5_HASH = CERT_FIND_TYPE.MD5_HASH;
pub const CTL_FIND_USAGE = CERT_FIND_TYPE.USAGE;
pub const CTL_FIND_SAME_USAGE_FLAG = CERT_FIND_TYPE.SAME_USAGE_FLAG;
pub const CTL_FIND_EXISTING = CERT_FIND_TYPE.EXISTING;
pub const CTL_FIND_SUBJECT = CERT_FIND_TYPE.SUBJECT;

pub const CRYPT_FIND_FLAGS = extern enum(u32) {
    USER_KEYSET_FLAG = 1,
    MACHINE_KEYSET_FLAG = 2,
    SILENT_KEYSET_FLAG = 64,
};
pub const CRYPT_FIND_USER_KEYSET_FLAG = CRYPT_FIND_FLAGS.USER_KEYSET_FLAG;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG = CRYPT_FIND_FLAGS.MACHINE_KEYSET_FLAG;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG = CRYPT_FIND_FLAGS.SILENT_KEYSET_FLAG;

pub const TOKEN_MANDATORY_POLICY_ID = extern enum(u32) {
    OFF = 0,
    NO_WRITE_UP = 1,
    NEW_PROCESS_MIN = 2,
    VALID_MASK = 3,
};
pub const TOKEN_MANDATORY_POLICY_OFF = TOKEN_MANDATORY_POLICY_ID.OFF;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP = TOKEN_MANDATORY_POLICY_ID.NO_WRITE_UP;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = TOKEN_MANDATORY_POLICY_ID.NEW_PROCESS_MIN;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK = TOKEN_MANDATORY_POLICY_ID.VALID_MASK;

pub const AUTHZ_GENERATE_RESULTS = extern enum(u32) {
    SUCCESS_AUDIT = 1,
    FAILURE_AUDIT = 2,
};
pub const AUTHZ_GENERATE_SUCCESS_AUDIT = AUTHZ_GENERATE_RESULTS.SUCCESS_AUDIT;
pub const AUTHZ_GENERATE_FAILURE_AUDIT = AUTHZ_GENERATE_RESULTS.FAILURE_AUDIT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPTUI_VIEWCERTIFICATE_FLAGS = extern enum(u32) {
    HIDE_HIERARCHYPAGE = 1,
    HIDE_DETAILPAGE = 2,
    DISABLE_EDITPROPERTIES = 4,
    ENABLE_EDITPROPERTIES = 8,
    DISABLE_ADDTOSTORE = 16,
    ENABLE_ADDTOSTORE = 32,
    ACCEPT_DECLINE_STYLE = 64,
    IGNORE_UNTRUSTED_ROOT = 128,
    DONT_OPEN_STORES = 256,
    ONLY_OPEN_ROOT_STORE = 512,
    WARN_UNTRUSTED_ROOT = 1024,
    ENABLE_REVOCATION_CHECKING = 2048,
    WARN_REMOTE_TRUST = 4096,
    DISABLE_EXPORT = 8192,
    ENABLE_REVOCATION_CHECK_END_CERT = 16384,
    ENABLE_REVOCATION_CHECK_CHAIN = 32768,
    ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 2048,
    DISABLE_HTMLLINK = 65536,
    DISABLE_ISSUERSTATEMENT = 131072,
    CACHE_ONLY_URL_RETRIEVAL = 262144,
    _,
};
pub const CRYPTUI_HIDE_HIERARCHYPAGE = CRYPTUI_VIEWCERTIFICATE_FLAGS.HIDE_HIERARCHYPAGE;
pub const CRYPTUI_HIDE_DETAILPAGE = CRYPTUI_VIEWCERTIFICATE_FLAGS.HIDE_DETAILPAGE;
pub const CRYPTUI_DISABLE_EDITPROPERTIES = CRYPTUI_VIEWCERTIFICATE_FLAGS.DISABLE_EDITPROPERTIES;
pub const CRYPTUI_ENABLE_EDITPROPERTIES = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_EDITPROPERTIES;
pub const CRYPTUI_DISABLE_ADDTOSTORE = CRYPTUI_VIEWCERTIFICATE_FLAGS.DISABLE_ADDTOSTORE;
pub const CRYPTUI_ENABLE_ADDTOSTORE = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_ADDTOSTORE;
pub const CRYPTUI_ACCEPT_DECLINE_STYLE = CRYPTUI_VIEWCERTIFICATE_FLAGS.ACCEPT_DECLINE_STYLE;
pub const CRYPTUI_IGNORE_UNTRUSTED_ROOT = CRYPTUI_VIEWCERTIFICATE_FLAGS.IGNORE_UNTRUSTED_ROOT;
pub const CRYPTUI_DONT_OPEN_STORES = CRYPTUI_VIEWCERTIFICATE_FLAGS.DONT_OPEN_STORES;
pub const CRYPTUI_ONLY_OPEN_ROOT_STORE = CRYPTUI_VIEWCERTIFICATE_FLAGS.ONLY_OPEN_ROOT_STORE;
pub const CRYPTUI_WARN_UNTRUSTED_ROOT = CRYPTUI_VIEWCERTIFICATE_FLAGS.WARN_UNTRUSTED_ROOT;
pub const CRYPTUI_ENABLE_REVOCATION_CHECKING = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_REVOCATION_CHECKING;
pub const CRYPTUI_WARN_REMOTE_TRUST = CRYPTUI_VIEWCERTIFICATE_FLAGS.WARN_REMOTE_TRUST;
pub const CRYPTUI_DISABLE_EXPORT = CRYPTUI_VIEWCERTIFICATE_FLAGS.DISABLE_EXPORT;
pub const CRYPTUI_ENABLE_REVOCATION_CHECK_END_CERT = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_REVOCATION_CHECK_END_CERT;
pub const CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_REVOCATION_CHECK_CHAIN;
pub const CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = CRYPTUI_VIEWCERTIFICATE_FLAGS.ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
pub const CRYPTUI_DISABLE_HTMLLINK = CRYPTUI_VIEWCERTIFICATE_FLAGS.DISABLE_HTMLLINK;
pub const CRYPTUI_DISABLE_ISSUERSTATEMENT = CRYPTUI_VIEWCERTIFICATE_FLAGS.DISABLE_ISSUERSTATEMENT;
pub const CRYPTUI_CACHE_ONLY_URL_RETRIEVAL = CRYPTUI_VIEWCERTIFICATE_FLAGS.CACHE_ONLY_URL_RETRIEVAL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const KERB_TICKET_FLAGS = extern enum(u32) {
    forwardable = 1073741824,
    forwarded = 536870912,
    hw_authent = 1048576,
    initial = 4194304,
    invalid = 16777216,
    may_postdate = 67108864,
    ok_as_delegate = 262144,
    postdated = 33554432,
    pre_authent = 2097152,
    proxiable = 268435456,
    proxy = 134217728,
    renewable = 8388608,
    reserved = 2147483648,
    reserved1 = 1,
    _,
};
pub const KERB_TICKET_FLAGS_forwardable = KERB_TICKET_FLAGS.forwardable;
pub const KERB_TICKET_FLAGS_forwarded = KERB_TICKET_FLAGS.forwarded;
pub const KERB_TICKET_FLAGS_hw_authent = KERB_TICKET_FLAGS.hw_authent;
pub const KERB_TICKET_FLAGS_initial = KERB_TICKET_FLAGS.initial;
pub const KERB_TICKET_FLAGS_invalid = KERB_TICKET_FLAGS.invalid;
pub const KERB_TICKET_FLAGS_may_postdate = KERB_TICKET_FLAGS.may_postdate;
pub const KERB_TICKET_FLAGS_ok_as_delegate = KERB_TICKET_FLAGS.ok_as_delegate;
pub const KERB_TICKET_FLAGS_postdated = KERB_TICKET_FLAGS.postdated;
pub const KERB_TICKET_FLAGS_pre_authent = KERB_TICKET_FLAGS.pre_authent;
pub const KERB_TICKET_FLAGS_proxiable = KERB_TICKET_FLAGS.proxiable;
pub const KERB_TICKET_FLAGS_proxy = KERB_TICKET_FLAGS.proxy;
pub const KERB_TICKET_FLAGS_renewable = KERB_TICKET_FLAGS.renewable;
pub const KERB_TICKET_FLAGS_reserved = KERB_TICKET_FLAGS.reserved;
pub const KERB_TICKET_FLAGS_reserved1 = KERB_TICKET_FLAGS.reserved1;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SYSTEM_AUDIT_OBJECT_ACE_FLAGS = extern enum(u32) {
    OBJECT_TYPE_PRESENT = 1,
    INHERITED_OBJECT_TYPE_PRESENT = 2,
    _,
};
pub const ACE_OBJECT_TYPE_PRESENT = SYSTEM_AUDIT_OBJECT_ACE_FLAGS.OBJECT_TYPE_PRESENT;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT = SYSTEM_AUDIT_OBJECT_ACE_FLAGS.INHERITED_OBJECT_TYPE_PRESENT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_IMAGE_REF_FLAGS = extern enum(u32) {
    MIN_DEPENDENCIES = 1,
    PROCESS_ISOLATE = 65536,
    _,
};
pub const CRYPT_MIN_DEPENDENCIES = CRYPT_IMAGE_REF_FLAGS.MIN_DEPENDENCIES;
pub const CRYPT_PROCESS_ISOLATE = CRYPT_IMAGE_REF_FLAGS.PROCESS_ISOLATE;

pub const SERVICE_RUNS_IN_PROCESS = extern enum(u32) {
    NON_SYSTEM_OR_NOT_RUNNING = 0,
    SYSTEM_PROCESS = 1,
};
pub const SERVICE_RUNS_IN_NON_SYSTEM_OR_NOT_RUNNING = SERVICE_RUNS_IN_PROCESS.NON_SYSTEM_OR_NOT_RUNNING;
pub const SERVICE_RUNS_IN_SYSTEM_PROCESS = SERVICE_RUNS_IN_PROCESS.SYSTEM_PROCESS;

pub const CERT_REVOCATION_STATUS_REASON = extern enum(u32) {
    UNSPECIFIED = 0,
    KEY_COMPROMISE = 1,
    CA_COMPROMISE = 2,
    AFFILIATION_CHANGED = 3,
    SUPERSEDED = 4,
    CESSATION_OF_OPERATION = 5,
    CERTIFICATE_HOLD = 6,
    REMOVE_FROM_CRL = 8,
};
pub const CRL_REASON_UNSPECIFIED = CERT_REVOCATION_STATUS_REASON.UNSPECIFIED;
pub const CRL_REASON_KEY_COMPROMISE = CERT_REVOCATION_STATUS_REASON.KEY_COMPROMISE;
pub const CRL_REASON_CA_COMPROMISE = CERT_REVOCATION_STATUS_REASON.CA_COMPROMISE;
pub const CRL_REASON_AFFILIATION_CHANGED = CERT_REVOCATION_STATUS_REASON.AFFILIATION_CHANGED;
pub const CRL_REASON_SUPERSEDED = CERT_REVOCATION_STATUS_REASON.SUPERSEDED;
pub const CRL_REASON_CESSATION_OF_OPERATION = CERT_REVOCATION_STATUS_REASON.CESSATION_OF_OPERATION;
pub const CRL_REASON_CERTIFICATE_HOLD = CERT_REVOCATION_STATUS_REASON.CERTIFICATE_HOLD;
pub const CRL_REASON_REMOVE_FROM_CRL = CERT_REVOCATION_STATUS_REASON.REMOVE_FROM_CRL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_ROOT_PROGRAM_FLAGS = extern enum(u32) {
    LSC = 64,
    ORG = 128,
    SUBJECT_LOGO = 32,
    _,
};
pub const CERT_ROOT_PROGRAM_FLAG_LSC = CERT_ROOT_PROGRAM_FLAGS.LSC;
pub const CERT_ROOT_PROGRAM_FLAG_ORG = CERT_ROOT_PROGRAM_FLAGS.ORG;
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = CERT_ROOT_PROGRAM_FLAGS.SUBJECT_LOGO;

pub const CRYPT_XML_KEY_VALUE_TYPE = extern enum(u32) {
    DSA = 1,
    RSA = 2,
    ECDSA = 3,
    CUSTOM = 4,
};
pub const CRYPT_XML_KEY_VALUE_TYPE_DSA = CRYPT_XML_KEY_VALUE_TYPE.DSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_RSA = CRYPT_XML_KEY_VALUE_TYPE.RSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_ECDSA = CRYPT_XML_KEY_VALUE_TYPE.ECDSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_CUSTOM = CRYPT_XML_KEY_VALUE_TYPE.CUSTOM;

pub const CERT_LOGOTYPE_CHOICE = extern enum(u32) {
    NO_IMAGE_RESOLUTION_CHOICE = 0,
    BITS_IMAGE_RESOLUTION_CHOICE = 1,
    TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2,
};
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.NO_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.BITS_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.TABLE_SIZE_IMAGE_RESOLUTION_CHOICE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_SELECT_STRUCT_FLAGS = extern enum(u32) {
    HIDE_PROPERTIES = 1,
    ENABLEHOOK = 2,
    ALLOWMULTISELECT = 4,
    SHOW_HELP = 16,
    ENABLETEMPLATE = 32,
    ENABLETEMPLATEHANDLE = 64,
    _,
};
pub const CSS_HIDE_PROPERTIES = CERT_SELECT_STRUCT_FLAGS.HIDE_PROPERTIES;
pub const CSS_ENABLEHOOK = CERT_SELECT_STRUCT_FLAGS.ENABLEHOOK;
pub const CSS_ALLOWMULTISELECT = CERT_SELECT_STRUCT_FLAGS.ALLOWMULTISELECT;
pub const CSS_SHOW_HELP = CERT_SELECT_STRUCT_FLAGS.SHOW_HELP;
pub const CSS_ENABLETEMPLATE = CERT_SELECT_STRUCT_FLAGS.ENABLETEMPLATE;
pub const CSS_ENABLETEMPLATEHANDLE = CERT_SELECT_STRUCT_FLAGS.ENABLETEMPLATEHANDLE;

pub const CMSG_KEY_AGREE_OPTION = extern enum(u32) {
    EPHEMERAL_KEY_CHOICE = 1,
    STATIC_KEY_CHOICE = 2,
};
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.EPHEMERAL_KEY_CHOICE;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.STATIC_KEY_CHOICE;

pub const SEC_WINNT_AUTH_IDENTITY = extern enum(u32) {
    ANSI = 1,
    UNICODE = 2,
};
pub const SEC_WINNT_AUTH_IDENTITY_ANSI = SEC_WINNT_AUTH_IDENTITY.ANSI;
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE = SEC_WINNT_AUTH_IDENTITY.UNICODE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CLAIM_SECURITY_ATTRIBUTE_FLAGS = extern enum(u32) {
    NON_INHERITABLE = 1,
    VALUE_CASE_SENSITIVE = 2,
    USE_FOR_DENY_ONLY = 4,
    DISABLED_BY_DEFAULT = 8,
    DISABLED = 16,
    MANDATORY = 32,
    _,
};
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE = CLAIM_SECURITY_ATTRIBUTE_FLAGS.NON_INHERITABLE;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE = CLAIM_SECURITY_ATTRIBUTE_FLAGS.VALUE_CASE_SENSITIVE;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY = CLAIM_SECURITY_ATTRIBUTE_FLAGS.USE_FOR_DENY_ONLY;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT = CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED_BY_DEFAULT;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED = CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY = CLAIM_SECURITY_ATTRIBUTE_FLAGS.MANDATORY;

pub const CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION = extern enum(u32) {
    FILE = 1,
    CERT_CONTEXT = 2,
    CTL_CONTEXT = 3,
    CRL_CONTEXT = 4,
    CERT_STORE = 5,
};
pub const CRYPTUI_WIZ_IMPORT_SUBJECT_FILE = CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION.FILE;
pub const CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT = CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION.CERT_CONTEXT;
pub const CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT = CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION.CTL_CONTEXT;
pub const CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT = CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION.CRL_CONTEXT;
pub const CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE = CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION.CERT_STORE;

pub const KERB_ADDRESS_TYPE = extern enum(u32) {
    INET_ADDRESS = 1,
    NETBIOS_ADDRESS = 2,
};
pub const DS_INET_ADDRESS = KERB_ADDRESS_TYPE.INET_ADDRESS;
pub const DS_NETBIOS_ADDRESS = KERB_ADDRESS_TYPE.NETBIOS_ADDRESS;

pub const CERT_LOGOTYPE_OPTION = extern enum(u32) {
    DIRECT_INFO_CHOICE = 1,
    INDIRECT_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.DIRECT_INFO_CHOICE;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.INDIRECT_INFO_CHOICE;

pub const SCARD_STATE = extern enum(u32) {
    UNAWARE = 0,
    IGNORE = 1,
    UNAVAILABLE = 8,
    EMPTY = 16,
    PRESENT = 32,
    ATRMATCH = 64,
    EXCLUSIVE = 128,
    INUSE = 256,
    MUTE = 512,
    CHANGED = 2,
    UNKNOWN = 4,
};
pub const SCARD_STATE_UNAWARE = SCARD_STATE.UNAWARE;
pub const SCARD_STATE_IGNORE = SCARD_STATE.IGNORE;
pub const SCARD_STATE_UNAVAILABLE = SCARD_STATE.UNAVAILABLE;
pub const SCARD_STATE_EMPTY = SCARD_STATE.EMPTY;
pub const SCARD_STATE_PRESENT = SCARD_STATE.PRESENT;
pub const SCARD_STATE_ATRMATCH = SCARD_STATE.ATRMATCH;
pub const SCARD_STATE_EXCLUSIVE = SCARD_STATE.EXCLUSIVE;
pub const SCARD_STATE_INUSE = SCARD_STATE.INUSE;
pub const SCARD_STATE_MUTE = SCARD_STATE.MUTE;
pub const SCARD_STATE_CHANGED = SCARD_STATE.CHANGED;
pub const SCARD_STATE_UNKNOWN = SCARD_STATE.UNKNOWN;

pub const WINTRUST_DATA_UICHOICE = extern enum(u32) {
    ALL = 1,
    NONE = 2,
    NOBAD = 3,
    NOGOOD = 4,
};
pub const WTD_UI_ALL = WINTRUST_DATA_UICHOICE.ALL;
pub const WTD_UI_NONE = WINTRUST_DATA_UICHOICE.NONE;
pub const WTD_UI_NOBAD = WINTRUST_DATA_UICHOICE.NOBAD;
pub const WTD_UI_NOGOOD = WINTRUST_DATA_UICHOICE.NOGOOD;

pub const WINTRUST_SIGNATURE_SETTINGS_FLAGS = extern enum(u32) {
    VERIFY_SPECIFIC = 1,
    GET_SECONDARY_SIG_COUNT = 2,
};
pub const WSS_VERIFY_SPECIFIC = WINTRUST_SIGNATURE_SETTINGS_FLAGS.VERIFY_SPECIFIC;
pub const WSS_GET_SECONDARY_SIG_COUNT = WINTRUST_SIGNATURE_SETTINGS_FLAGS.GET_SECONDARY_SIG_COUNT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SCHANNEL_CRED_FLAGS = extern enum(u32) {
    CRED_AUTO_CRED_VALIDATION = 32,
    CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE = 131072,
    DISABLE_RECONNECTS = 128,
    CRED_IGNORE_NO_REVOCATION_CHECK = 2048,
    CRED_IGNORE_REVOCATION_OFFLINE = 4096,
    CRED_MANUAL_CRED_VALIDATION = 8,
    CRED_NO_DEFAULT_CREDS = 16,
    CRED_NO_SERVERNAME_CHECK = 4,
    CRED_NO_SYSTEM_MAPPER = 2,
    CRED_REVOCATION_CHECK_CHAIN = 512,
    CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 1024,
    CRED_REVOCATION_CHECK_END_CERT = 256,
    CRED_USE_DEFAULT_CREDS = 64,
    SEND_AUX_RECORD = 2097152,
    SEND_ROOT_CERT = 262144,
    USE_STRONG_CRYPTO = 4194304,
    USE_PRESHAREDKEY_ONLY = 8388608,
    _,
};
pub const SCH_CRED_AUTO_CRED_VALIDATION = SCHANNEL_CRED_FLAGS.CRED_AUTO_CRED_VALIDATION;
pub const SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE = SCHANNEL_CRED_FLAGS.CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE;
pub const SCH_DISABLE_RECONNECTS = SCHANNEL_CRED_FLAGS.DISABLE_RECONNECTS;
pub const SCH_CRED_IGNORE_NO_REVOCATION_CHECK = SCHANNEL_CRED_FLAGS.CRED_IGNORE_NO_REVOCATION_CHECK;
pub const SCH_CRED_IGNORE_REVOCATION_OFFLINE = SCHANNEL_CRED_FLAGS.CRED_IGNORE_REVOCATION_OFFLINE;
pub const SCH_CRED_MANUAL_CRED_VALIDATION = SCHANNEL_CRED_FLAGS.CRED_MANUAL_CRED_VALIDATION;
pub const SCH_CRED_NO_DEFAULT_CREDS = SCHANNEL_CRED_FLAGS.CRED_NO_DEFAULT_CREDS;
pub const SCH_CRED_NO_SERVERNAME_CHECK = SCHANNEL_CRED_FLAGS.CRED_NO_SERVERNAME_CHECK;
pub const SCH_CRED_NO_SYSTEM_MAPPER = SCHANNEL_CRED_FLAGS.CRED_NO_SYSTEM_MAPPER;
pub const SCH_CRED_REVOCATION_CHECK_CHAIN = SCHANNEL_CRED_FLAGS.CRED_REVOCATION_CHECK_CHAIN;
pub const SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = SCHANNEL_CRED_FLAGS.CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
pub const SCH_CRED_REVOCATION_CHECK_END_CERT = SCHANNEL_CRED_FLAGS.CRED_REVOCATION_CHECK_END_CERT;
pub const SCH_CRED_USE_DEFAULT_CREDS = SCHANNEL_CRED_FLAGS.CRED_USE_DEFAULT_CREDS;
pub const SCH_SEND_AUX_RECORD = SCHANNEL_CRED_FLAGS.SEND_AUX_RECORD;
pub const SCH_SEND_ROOT_CERT = SCHANNEL_CRED_FLAGS.SEND_ROOT_CERT;
pub const SCH_USE_STRONG_CRYPTO = SCHANNEL_CRED_FLAGS.USE_STRONG_CRYPTO;
pub const SCH_USE_PRESHAREDKEY_ONLY = SCHANNEL_CRED_FLAGS.USE_PRESHAREDKEY_ONLY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DOMAIN_PASSWORD_PROPERTIES = extern enum(u32) {
    PASSWORD_COMPLEX = 1,
    PASSWORD_NO_ANON_CHANGE = 2,
    PASSWORD_NO_CLEAR_CHANGE = 4,
    LOCKOUT_ADMINS = 8,
    PASSWORD_STORE_CLEARTEXT = 16,
    REFUSE_PASSWORD_CHANGE = 32,
    _,
};
pub const DOMAIN_PASSWORD_COMPLEX = DOMAIN_PASSWORD_PROPERTIES.PASSWORD_COMPLEX;
pub const DOMAIN_PASSWORD_NO_ANON_CHANGE = DOMAIN_PASSWORD_PROPERTIES.PASSWORD_NO_ANON_CHANGE;
pub const DOMAIN_PASSWORD_NO_CLEAR_CHANGE = DOMAIN_PASSWORD_PROPERTIES.PASSWORD_NO_CLEAR_CHANGE;
pub const DOMAIN_LOCKOUT_ADMINS = DOMAIN_PASSWORD_PROPERTIES.LOCKOUT_ADMINS;
pub const DOMAIN_PASSWORD_STORE_CLEARTEXT = DOMAIN_PASSWORD_PROPERTIES.PASSWORD_STORE_CLEARTEXT;
pub const DOMAIN_REFUSE_PASSWORD_CHANGE = DOMAIN_PASSWORD_PROPERTIES.REFUSE_PASSWORD_CHANGE;

pub const WINTRUST_DATA_STATE_ACTION = extern enum(u32) {
    IGNORE = 0,
    VERIFY = 1,
    CLOSE = 2,
    AUTO_CACHE = 3,
    AUTO_CACHE_FLUSH = 4,
};
pub const WTD_STATEACTION_IGNORE = WINTRUST_DATA_STATE_ACTION.IGNORE;
pub const WTD_STATEACTION_VERIFY = WINTRUST_DATA_STATE_ACTION.VERIFY;
pub const WTD_STATEACTION_CLOSE = WINTRUST_DATA_STATE_ACTION.CLOSE;
pub const WTD_STATEACTION_AUTO_CACHE = WINTRUST_DATA_STATE_ACTION.AUTO_CACHE;
pub const WTD_STATEACTION_AUTO_CACHE_FLUSH = WINTRUST_DATA_STATE_ACTION.AUTO_CACHE_FLUSH;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_STORE_PROV_FLAGS = extern enum(u32) {
    EXTERNAL_FLAG = 1,
    DELETED_FLAG = 2,
    NO_PERSIST_FLAG = 4,
    SYSTEM_STORE_FLAG = 8,
    LM_SYSTEM_STORE_FLAG = 16,
    _,
};
pub const CERT_STORE_PROV_EXTERNAL_FLAG = CERT_STORE_PROV_FLAGS.EXTERNAL_FLAG;
pub const CERT_STORE_PROV_DELETED_FLAG = CERT_STORE_PROV_FLAGS.DELETED_FLAG;
pub const CERT_STORE_PROV_NO_PERSIST_FLAG = CERT_STORE_PROV_FLAGS.NO_PERSIST_FLAG;
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.SYSTEM_STORE_FLAG;
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.LM_SYSTEM_STORE_FLAG;

pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE = extern enum(u32) {
    INT64 = 1,
    UINT64 = 2,
    STRING = 3,
    OCTET_STRING = 16,
    FQBN = 4,
    SID = 5,
    BOOLEAN = 6,
};
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.INT64;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.UINT64;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.STRING;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.OCTET_STRING;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.FQBN;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.SID;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.BOOLEAN;

pub const CMSG_KEY_AGREE_ORIGINATOR = extern enum(u32) {
    CERT = 1,
    PUBLIC_KEY = 2,
};
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT = CMSG_KEY_AGREE_ORIGINATOR.CERT;
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = CMSG_KEY_AGREE_ORIGINATOR.PUBLIC_KEY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_KEY_PROV_FLAGS = extern enum(u32) {
    CERT_SET_KEY_PROV_HANDLE_PROP_ID = 1,
    CERT_SET_KEY_CONTEXT_PROP_ID = 1,
    CRYPT_MACHINE_KEYSET = 32,
    NCRYPT_MACHINE_KEY_FLAG = 32,
    CRYPT_SILENT = 64,
    NCRYPT_SILENT_FLAG = 64,
    _,
};
// TODO: enum 'CRYPT_KEY_PROV_FLAGS' has known issues with its value aliases

pub const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT = extern enum(u32) {
    BLOB = 2,
    FILE = 1,
    None = 0,
};
pub const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB = CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT.BLOB;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE = CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT.FILE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_CONTEXT_CONFIG_FLAGS = extern enum(u32) {
    EXCLUSIVE = 1,
    OVERRIDE = 65536,
    _,
};
pub const CRYPT_EXCLUSIVE = CRYPT_CONTEXT_CONFIG_FLAGS.EXCLUSIVE;
pub const CRYPT_OVERRIDE = CRYPT_CONTEXT_CONFIG_FLAGS.OVERRIDE;

pub const SCHANNEL_ALERT_TOKEN_ALERT_TYPE = extern enum(u32) {
    WARNING = 1,
    FATAL = 2,
};
pub const TLS1_ALERT_WARNING = SCHANNEL_ALERT_TOKEN_ALERT_TYPE.WARNING;
pub const TLS1_ALERT_FATAL = SCHANNEL_ALERT_TOKEN_ALERT_TYPE.FATAL;

pub const BCRYPT_DSA_MAGIC = extern enum(u32) {
    UBLIC_MAGIC = 1112560452,
    RIVATE_MAGIC = 1448104772,
};
pub const BCRYPT_DSA_PUBLIC_MAGIC = BCRYPT_DSA_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DSA_PRIVATE_MAGIC = BCRYPT_DSA_MAGIC.RIVATE_MAGIC;

pub const WINTRUST_DATA_UNION_CHOICE = extern enum(u32) {
    FILE = 1,
    CATALOG = 2,
    BLOB = 3,
    SIGNER = 4,
    CERT = 5,
};
pub const WTD_CHOICE_FILE = WINTRUST_DATA_UNION_CHOICE.FILE;
pub const WTD_CHOICE_CATALOG = WINTRUST_DATA_UNION_CHOICE.CATALOG;
pub const WTD_CHOICE_BLOB = WINTRUST_DATA_UNION_CHOICE.BLOB;
pub const WTD_CHOICE_SIGNER = WINTRUST_DATA_UNION_CHOICE.SIGNER;
pub const WTD_CHOICE_CERT = WINTRUST_DATA_UNION_CHOICE.CERT;

pub const TRUSTED_DOMAIN_TRUST_TYPE = extern enum(u32) {
    DOWNLEVEL = 1,
    UPLEVEL = 2,
    MIT = 3,
    DCE = 4,
};
pub const TRUST_TYPE_DOWNLEVEL = TRUSTED_DOMAIN_TRUST_TYPE.DOWNLEVEL;
pub const TRUST_TYPE_UPLEVEL = TRUSTED_DOMAIN_TRUST_TYPE.UPLEVEL;
pub const TRUST_TYPE_MIT = TRUSTED_DOMAIN_TRUST_TYPE.MIT;
pub const TRUST_TYPE_DCE = TRUSTED_DOMAIN_TRUST_TYPE.DCE;

pub const CRYPTUI_WIZ_DIGITAL_SIGN = extern enum(u32) {
    CERT = 1,
    STORE = 2,
    PVK = 3,
    None = 0,
};
pub const CRYPTUI_WIZ_DIGITAL_SIGN_CERT = CRYPTUI_WIZ_DIGITAL_SIGN.CERT;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_STORE = CRYPTUI_WIZ_DIGITAL_SIGN.STORE;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_PVK = CRYPTUI_WIZ_DIGITAL_SIGN.PVK;

pub const WINTRUST_DATA_REVOCATION_CHECKS = extern enum(u32) {
    NONE = 0,
    WHOLECHAIN = 1,
};
pub const WTD_REVOKE_NONE = WINTRUST_DATA_REVOCATION_CHECKS.NONE;
pub const WTD_REVOKE_WHOLECHAIN = WINTRUST_DATA_REVOCATION_CHECKS.WHOLECHAIN;

pub const CRYPT_XML_X509DATA_TYPE = extern enum(u32) {
    ISSUER_SERIAL = 1,
    SKI = 2,
    SUBJECT_NAME = 3,
    CERTIFICATE = 4,
    CRL = 5,
    CUSTOM = 6,
};
pub const CRYPT_XML_X509DATA_TYPE_ISSUER_SERIAL = CRYPT_XML_X509DATA_TYPE.ISSUER_SERIAL;
pub const CRYPT_XML_X509DATA_TYPE_SKI = CRYPT_XML_X509DATA_TYPE.SKI;
pub const CRYPT_XML_X509DATA_TYPE_SUBJECT_NAME = CRYPT_XML_X509DATA_TYPE.SUBJECT_NAME;
pub const CRYPT_XML_X509DATA_TYPE_CERTIFICATE = CRYPT_XML_X509DATA_TYPE.CERTIFICATE;
pub const CRYPT_XML_X509DATA_TYPE_CRL = CRYPT_XML_X509DATA_TYPE.CRL;
pub const CRYPT_XML_X509DATA_TYPE_CUSTOM = CRYPT_XML_X509DATA_TYPE.CUSTOM;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MSV_SUBAUTH_LOGON_PARAMETER_CONTROL = extern enum(u32) {
    CLEARTEXT_PASSWORD_ALLOWED = 2,
    UPDATE_LOGON_STATISTICS = 4,
    RETURN_USER_PARAMETERS = 8,
    DONT_TRY_GUEST_ACCOUNT = 16,
    ALLOW_SERVER_TRUST_ACCOUNT = 32,
    RETURN_PASSWORD_EXPIRY = 64,
    ALLOW_WORKSTATION_TRUST_ACCOUNT = 2048,
    TRY_GUEST_ACCOUNT_ONLY = 256,
    RETURN_PROFILE_PATH = 512,
    TRY_SPECIFIED_DOMAIN_ONLY = 1024,
    _,
};
pub const MSV1_0_CLEARTEXT_PASSWORD_ALLOWED = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.CLEARTEXT_PASSWORD_ALLOWED;
pub const MSV1_0_UPDATE_LOGON_STATISTICS = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.UPDATE_LOGON_STATISTICS;
pub const MSV1_0_RETURN_USER_PARAMETERS = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.RETURN_USER_PARAMETERS;
pub const MSV1_0_DONT_TRY_GUEST_ACCOUNT = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.DONT_TRY_GUEST_ACCOUNT;
pub const MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.ALLOW_SERVER_TRUST_ACCOUNT;
pub const MSV1_0_RETURN_PASSWORD_EXPIRY = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.RETURN_PASSWORD_EXPIRY;
pub const MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.ALLOW_WORKSTATION_TRUST_ACCOUNT;
pub const MSV1_0_TRY_GUEST_ACCOUNT_ONLY = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.TRY_GUEST_ACCOUNT_ONLY;
pub const MSV1_0_RETURN_PROFILE_PATH = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.RETURN_PROFILE_PATH;
pub const MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY = MSV_SUBAUTH_LOGON_PARAMETER_CONTROL.TRY_SPECIFIED_DOMAIN_ONLY;

pub const KERB_REQUEST_FLAGS = extern enum(u32) {
    ADD_CREDENTIAL = 1,
    REPLACE_CREDENTIAL = 2,
    REMOVE_CREDENTIAL = 4,
};
pub const KERB_REQUEST_ADD_CREDENTIAL = KERB_REQUEST_FLAGS.ADD_CREDENTIAL;
pub const KERB_REQUEST_REPLACE_CREDENTIAL = KERB_REQUEST_FLAGS.REPLACE_CREDENTIAL;
pub const KERB_REQUEST_REMOVE_CREDENTIAL = KERB_REQUEST_FLAGS.REMOVE_CREDENTIAL;

pub const CERT_BIOMETRIC_DATA_TYPE = extern enum(u32) {
    PREDEFINED_DATA_CHOICE = 1,
    OID_DATA_CHOICE = 2,
};
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.PREDEFINED_DATA_CHOICE;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.OID_DATA_CHOICE;

pub const CERT_CHAIN_POLICY_FLAGS = extern enum(u32) {
    IGNORE_NOT_TIME_VALID_FLAG = 1,
    IGNORE_CTL_NOT_TIME_VALID_FLAG = 2,
    IGNORE_NOT_TIME_NESTED_FLAG = 4,
    IGNORE_ALL_NOT_TIME_VALID_FLAGS = 7,
    IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8,
    ALLOW_UNKNOWN_CA_FLAG = 16,
    IGNORE_WRONG_USAGE_FLAG = 32,
    IGNORE_INVALID_NAME_FLAG = 64,
    IGNORE_INVALID_POLICY_FLAG = 128,
    IGNORE_END_REV_UNKNOWN_FLAG = 256,
    IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512,
    IGNORE_CA_REV_UNKNOWN_FLAG = 1024,
    IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048,
    IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840,
    ALLOW_TESTROOT_FLAG = 32768,
    TRUST_TESTROOT_FLAG = 16384,
    IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192,
    IGNORE_PEER_TRUST_FLAG = 4096,
};
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_NESTED_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_NOT_TIME_VALID_FLAGS;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_UNKNOWN_CA_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_WRONG_USAGE_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_NAME_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_POLICY_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_END_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CA_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_ROOT_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_REV_UNKNOWN_FLAGS;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.TRUST_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_PEER_TRUST_FLAG;

pub const SERVICE_TRIGGER_ACTION = extern enum(u32) {
    ART = 1,
    OP = 2,
};
pub const SERVICE_TRIGGER_ACTION_SERVICE_START = SERVICE_TRIGGER_ACTION.ART;
pub const SERVICE_TRIGGER_ACTION_SERVICE_STOP = SERVICE_TRIGGER_ACTION.OP;

pub const SERVICE_TRIGGER_TYPE = extern enum(u32) {
    CUSTOM = 20,
    DEVICE_INTERFACE_ARRIVAL = 1,
    DOMAIN_JOIN = 3,
    FIREWALL_PORT_EVENT = 4,
    GROUP_POLICY = 5,
    IP_ADDRESS_AVAILABILITY = 2,
    NETWORK_ENDPOINT = 6,
};
pub const SERVICE_TRIGGER_TYPE_CUSTOM = SERVICE_TRIGGER_TYPE.CUSTOM;
pub const SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL = SERVICE_TRIGGER_TYPE.DEVICE_INTERFACE_ARRIVAL;
pub const SERVICE_TRIGGER_TYPE_DOMAIN_JOIN = SERVICE_TRIGGER_TYPE.DOMAIN_JOIN;
pub const SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT = SERVICE_TRIGGER_TYPE.FIREWALL_PORT_EVENT;
pub const SERVICE_TRIGGER_TYPE_GROUP_POLICY = SERVICE_TRIGGER_TYPE.GROUP_POLICY;
pub const SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY = SERVICE_TRIGGER_TYPE.IP_ADDRESS_AVAILABILITY;
pub const SERVICE_TRIGGER_TYPE_NETWORK_ENDPOINT = SERVICE_TRIGGER_TYPE.NETWORK_ENDPOINT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_STRONG_SIGN_FLAGS = extern enum(u32) {
    CRL_CHECK = 1,
    OCSP_CHECK = 2,
    _,
};
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = CERT_STRONG_SIGN_FLAGS.CRL_CHECK;
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = CERT_STRONG_SIGN_FLAGS.OCSP_CHECK;

pub const CERT_LOGOTYPE_IMAGE_INFO_TYPE = extern enum(u32) {
    GRAY_SCALE_IMAGE_INFO_CHOICE = 1,
    COLOR_IMAGE_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.GRAY_SCALE_IMAGE_INFO_CHOICE;
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.COLOR_IMAGE_INFO_CHOICE;

pub const CRYPT_XML_STATUS_INFO_STATUS = extern enum(u32) {
    INTERNAL_REFERENCE = 1,
    KEY_AVAILABLE = 2,
    DIGESTING = 4,
    DIGEST_VALID = 8,
    SIGNATURE_VALID = 65536,
    OPENED_TO_ENCODE = 2147483648,
};
pub const CRYPT_XML_STATUS_INTERNAL_REFERENCE = CRYPT_XML_STATUS_INFO_STATUS.INTERNAL_REFERENCE;
pub const CRYPT_XML_STATUS_KEY_AVAILABLE = CRYPT_XML_STATUS_INFO_STATUS.KEY_AVAILABLE;
pub const CRYPT_XML_STATUS_DIGESTING = CRYPT_XML_STATUS_INFO_STATUS.DIGESTING;
pub const CRYPT_XML_STATUS_DIGEST_VALID = CRYPT_XML_STATUS_INFO_STATUS.DIGEST_VALID;
pub const CRYPT_XML_STATUS_SIGNATURE_VALID = CRYPT_XML_STATUS_INFO_STATUS.SIGNATURE_VALID;
pub const CRYPT_XML_STATUS_OPENED_TO_ENCODE = CRYPT_XML_STATUS_INFO_STATUS.OPENED_TO_ENCODE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CRYPT_XML_TRANSFORM_FLAGS = extern enum(u32) {
    ON_STREAM = 1,
    ON_NODESET = 2,
    URI_QUERY_STRING = 3,
    _,
};
pub const CRYPT_XML_TRANSFORM_ON_STREAM = CRYPT_XML_TRANSFORM_FLAGS.ON_STREAM;
pub const CRYPT_XML_TRANSFORM_ON_NODESET = CRYPT_XML_TRANSFORM_FLAGS.ON_NODESET;
pub const CRYPT_XML_TRANSFORM_URI_QUERY_STRING = CRYPT_XML_TRANSFORM_FLAGS.URI_QUERY_STRING;

pub const CRYPT_XML_GROUP_ID = extern enum(u32) {
    HASH_________ = 1,
    SIGN_________ = 2,
};
pub const CRYPT_XML_GROUP_ID_HASH_________ = CRYPT_XML_GROUP_ID.HASH_________;
pub const CRYPT_XML_GROUP_ID_SIGN_________ = CRYPT_XML_GROUP_ID.SIGN_________;

pub const CRYPTUI_WIZ_EXPORT_SUBJECT = extern enum(u32) {
    ERT_CONTEXT = 1,
    TL_CONTEXT = 2,
    RL_CONTEXT = 3,
    ERT_STORE = 4,
    ERT_STORE_CERTIFICATES_ONLY = 5,
};
pub const CRYPTUI_WIZ_EXPORT_CERT_CONTEXT = CRYPTUI_WIZ_EXPORT_SUBJECT.ERT_CONTEXT;
pub const CRYPTUI_WIZ_EXPORT_CTL_CONTEXT = CRYPTUI_WIZ_EXPORT_SUBJECT.TL_CONTEXT;
pub const CRYPTUI_WIZ_EXPORT_CRL_CONTEXT = CRYPTUI_WIZ_EXPORT_SUBJECT.RL_CONTEXT;
pub const CRYPTUI_WIZ_EXPORT_CERT_STORE = CRYPTUI_WIZ_EXPORT_SUBJECT.ERT_STORE;
pub const CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY = CRYPTUI_WIZ_EXPORT_SUBJECT.ERT_STORE_CERTIFICATES_ONLY;

pub const CERT_SELECT_CRITERIA_TYPE = extern enum(u32) {
    ENHKEY_USAGE = 1,
    KEY_USAGE = 2,
    POLICY_OID = 3,
    PROV_NAME = 4,
    EXTENSION = 5,
    SUBJECT_HOST_NAME = 6,
    ISSUER_ATTR = 7,
    SUBJECT_ATTR = 8,
    ISSUER_NAME = 9,
    PUBLIC_KEY = 10,
    TLS_SIGNATURES = 11,
};
pub const CERT_SELECT_BY_ENHKEY_USAGE = CERT_SELECT_CRITERIA_TYPE.ENHKEY_USAGE;
pub const CERT_SELECT_BY_KEY_USAGE = CERT_SELECT_CRITERIA_TYPE.KEY_USAGE;
pub const CERT_SELECT_BY_POLICY_OID = CERT_SELECT_CRITERIA_TYPE.POLICY_OID;
pub const CERT_SELECT_BY_PROV_NAME = CERT_SELECT_CRITERIA_TYPE.PROV_NAME;
pub const CERT_SELECT_BY_EXTENSION = CERT_SELECT_CRITERIA_TYPE.EXTENSION;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME = CERT_SELECT_CRITERIA_TYPE.SUBJECT_HOST_NAME;
pub const CERT_SELECT_BY_ISSUER_ATTR = CERT_SELECT_CRITERIA_TYPE.ISSUER_ATTR;
pub const CERT_SELECT_BY_SUBJECT_ATTR = CERT_SELECT_CRITERIA_TYPE.SUBJECT_ATTR;
pub const CERT_SELECT_BY_ISSUER_NAME = CERT_SELECT_CRITERIA_TYPE.ISSUER_NAME;
pub const CERT_SELECT_BY_PUBLIC_KEY = CERT_SELECT_CRITERIA_TYPE.PUBLIC_KEY;
pub const CERT_SELECT_BY_TLS_SIGNATURES = CERT_SELECT_CRITERIA_TYPE.TLS_SIGNATURES;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SI_OBJECT_INFO_FLAGS = extern enum(u32) {
    AUDITS_ELEVATION_REQUIRED = 33554432,
    DISABLE_DENY_ACE = 2147483648,
    EDIT_EFFECTIVE = 131072,
    ENABLE_CENTRAL_POLICY = 1073741824,
    ENABLE_EDIT_ATTRIBUTE_CONDITION = 536870912,
    MAY_WRITE = 268435456,
    NO_ADDITIONAL_PERMISSION = 2097152,
    OWNER_ELEVATION_REQUIRED = 67108864,
    PERMS_ELEVATION_REQUIRED = 16777216,
    RESET_DACL = 262144,
    RESET_OWNER = 1048576,
    RESET_SACL = 524288,
    SCOPE_ELEVATION_REQUIRED = 134217728,
    VIEW_ONLY = 4194304,
    _,
};
pub const SI_AUDITS_ELEVATION_REQUIRED = SI_OBJECT_INFO_FLAGS.AUDITS_ELEVATION_REQUIRED;
pub const SI_DISABLE_DENY_ACE = SI_OBJECT_INFO_FLAGS.DISABLE_DENY_ACE;
pub const SI_EDIT_EFFECTIVE = SI_OBJECT_INFO_FLAGS.EDIT_EFFECTIVE;
pub const SI_ENABLE_CENTRAL_POLICY = SI_OBJECT_INFO_FLAGS.ENABLE_CENTRAL_POLICY;
pub const SI_ENABLE_EDIT_ATTRIBUTE_CONDITION = SI_OBJECT_INFO_FLAGS.ENABLE_EDIT_ATTRIBUTE_CONDITION;
pub const SI_MAY_WRITE = SI_OBJECT_INFO_FLAGS.MAY_WRITE;
pub const SI_NO_ADDITIONAL_PERMISSION = SI_OBJECT_INFO_FLAGS.NO_ADDITIONAL_PERMISSION;
pub const SI_OWNER_ELEVATION_REQUIRED = SI_OBJECT_INFO_FLAGS.OWNER_ELEVATION_REQUIRED;
pub const SI_PERMS_ELEVATION_REQUIRED = SI_OBJECT_INFO_FLAGS.PERMS_ELEVATION_REQUIRED;
pub const SI_RESET_DACL = SI_OBJECT_INFO_FLAGS.RESET_DACL;
pub const SI_RESET_OWNER = SI_OBJECT_INFO_FLAGS.RESET_OWNER;
pub const SI_RESET_SACL = SI_OBJECT_INFO_FLAGS.RESET_SACL;
pub const SI_SCOPE_ELEVATION_REQUIRED = SI_OBJECT_INFO_FLAGS.SCOPE_ELEVATION_REQUIRED;
pub const SI_VIEW_ONLY = SI_OBJECT_INFO_FLAGS.VIEW_ONLY;

pub const TRUSTED_DOMAIN_TRUST_DIRECTION = extern enum(u32) {
    DISABLED = 0,
    INBOUND = 1,
    OUTBOUND = 2,
    BIDIRECTIONAL = 3,
};
pub const TRUST_DIRECTION_DISABLED = TRUSTED_DOMAIN_TRUST_DIRECTION.DISABLED;
pub const TRUST_DIRECTION_INBOUND = TRUSTED_DOMAIN_TRUST_DIRECTION.INBOUND;
pub const TRUST_DIRECTION_OUTBOUND = TRUSTED_DOMAIN_TRUST_DIRECTION.OUTBOUND;
pub const TRUST_DIRECTION_BIDIRECTIONAL = TRUSTED_DOMAIN_TRUST_DIRECTION.BIDIRECTIONAL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MSV_SUPPLEMENTAL_CREDENTIAL_FLAGS = extern enum(u32) {
    LM_PRESENT = 1,
    NT_PRESENT = 2,
    VERSION = 0,
    _,
};
pub const MSV1_0_CRED_LM_PRESENT = MSV_SUPPLEMENTAL_CREDENTIAL_FLAGS.LM_PRESENT;
pub const MSV1_0_CRED_NT_PRESENT = MSV_SUPPLEMENTAL_CREDENTIAL_FLAGS.NT_PRESENT;
pub const MSV1_0_CRED_VERSION = MSV_SUPPLEMENTAL_CREDENTIAL_FLAGS.VERSION;

pub const CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE = extern enum(u32) {
    COMMERCIAL = 1,
    INDIVIDUAL = 2,
};
pub const CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL = CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE.COMMERCIAL;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL = CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE.INDIVIDUAL;

pub const WINTRUST_DATA_UICONTEXT = extern enum(u32) {
    EXECUTE = 0,
    INSTALL = 1,
};
pub const WTD_UICONTEXT_EXECUTE = WINTRUST_DATA_UICONTEXT.EXECUTE;
pub const WTD_UICONTEXT_INSTALL = WINTRUST_DATA_UICONTEXT.INSTALL;

pub const SECURITY_PACKAGE_OPTIONS_TYPE = extern enum(u32) {
    UNKNOWN = 0,
    LSA = 1,
    SSPI = 2,
};
pub const SECPKG_OPTIONS_TYPE_UNKNOWN = SECURITY_PACKAGE_OPTIONS_TYPE.UNKNOWN;
pub const SECPKG_OPTIONS_TYPE_LSA = SECURITY_PACKAGE_OPTIONS_TYPE.LSA;
pub const SECPKG_OPTIONS_TYPE_SSPI = SECURITY_PACKAGE_OPTIONS_TYPE.SSPI;

pub const BCRYPT_RSAKEY_BLOB_MAGIC = extern enum(u32) {
    PUBLIC_MAGIC = 826364754,
    PRIVATE_MAGIC = 843141970,
    FULLPRIVATE_MAGIC = 859919186,
};
pub const BCRYPT_RSAPUBLIC_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PUBLIC_MAGIC;
pub const BCRYPT_RSAPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PRIVATE_MAGIC;
pub const BCRYPT_RSAFULLPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.FULLPRIVATE_MAGIC;

pub const CRYPT_XML_KEYINFO_TYPE = extern enum(u32) {
    KEYNAME = 1,
    KEYVALUE = 2,
    RETRIEVAL = 3,
    X509DATA = 4,
    CUSTOM = 5,
};
pub const CRYPT_XML_KEYINFO_TYPE_KEYNAME = CRYPT_XML_KEYINFO_TYPE.KEYNAME;
pub const CRYPT_XML_KEYINFO_TYPE_KEYVALUE = CRYPT_XML_KEYINFO_TYPE.KEYVALUE;
pub const CRYPT_XML_KEYINFO_TYPE_RETRIEVAL = CRYPT_XML_KEYINFO_TYPE.RETRIEVAL;
pub const CRYPT_XML_KEYINFO_TYPE_X509DATA = CRYPT_XML_KEYINFO_TYPE.X509DATA;
pub const CRYPT_XML_KEYINFO_TYPE_CUSTOM = CRYPT_XML_KEYINFO_TYPE.CUSTOM;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const AUTHZ_SECURITY_ATTRIBUTE_FLAGS = extern enum(u32) {
    NON_INHERITABLE = 1,
    VALUE_CASE_SENSITIVE = 2,
    _,
};
pub const AUTHZ_SECURITY_ATTRIBUTE_NON_INHERITABLE = AUTHZ_SECURITY_ATTRIBUTE_FLAGS.NON_INHERITABLE;
pub const AUTHZ_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE = AUTHZ_SECURITY_ATTRIBUTE_FLAGS.VALUE_CASE_SENSITIVE;

pub const SCHANNEL_SESSION_TOKEN_FLAGS = extern enum(u32) {
    ENABLE_RECONNECTS = 1,
    DISABLE_RECONNECTS = 2,
};
pub const SSL_SESSION_ENABLE_RECONNECTS = SCHANNEL_SESSION_TOKEN_FLAGS.ENABLE_RECONNECTS;
pub const SSL_SESSION_DISABLE_RECONNECTS = SCHANNEL_SESSION_TOKEN_FLAGS.DISABLE_RECONNECTS;

pub const CRYPT_TIMESTAMP_VERSION = extern enum(u32) {
    N = 1,
};
pub const TIMESTAMP_VERSION = CRYPT_TIMESTAMP_VERSION.N;

pub const KERB_CRYPTO_KEY_TYPE = extern enum(i32) {
    DES_CBC_CRC = 1,
    DES_CBC_MD4 = 2,
    DES_CBC_MD5 = 3,
    NULL = 0,
    RC4_HMAC_NT = 23,
    RC4_MD4 = -128,
};
pub const KERB_ETYPE_DES_CBC_CRC = KERB_CRYPTO_KEY_TYPE.DES_CBC_CRC;
pub const KERB_ETYPE_DES_CBC_MD4 = KERB_CRYPTO_KEY_TYPE.DES_CBC_MD4;
pub const KERB_ETYPE_DES_CBC_MD5 = KERB_CRYPTO_KEY_TYPE.DES_CBC_MD5;
pub const KERB_ETYPE_NULL = KERB_CRYPTO_KEY_TYPE.NULL;
pub const KERB_ETYPE_RC4_HMAC_NT = KERB_CRYPTO_KEY_TYPE.RC4_HMAC_NT;
pub const KERB_ETYPE_RC4_MD4 = KERB_CRYPTO_KEY_TYPE.RC4_MD4;

pub const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION = extern enum(u32) {
    FILE = 1,
    PROV = 2,
};
pub const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE = CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION.FILE;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV = CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION.PROV;

pub const CERT_ID_OPTION = extern enum(u32) {
    ISSUER_SERIAL_NUMBER = 1,
    KEY_IDENTIFIER = 2,
    SHA1_HASH = 3,
};
pub const CERT_ID_ISSUER_SERIAL_NUMBER = CERT_ID_OPTION.ISSUER_SERIAL_NUMBER;
pub const CERT_ID_KEY_IDENTIFIER = CERT_ID_OPTION.KEY_IDENTIFIER;
pub const CERT_ID_SHA1_HASH = CERT_ID_OPTION.SHA1_HASH;

pub const HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE = extern enum(u32) {
    CLIENT = 1,
    SERVER = 2,
};
pub const AUTHTYPE_CLIENT = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.CLIENT;
pub const AUTHTYPE_SERVER = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.SERVER;

pub const CRYPTUI_WIZ_EXPORT_FORMAT = extern enum(u32) {
    DER = 1,
    PFX = 2,
    PKCS7 = 3,
    BASE64 = 4,
    CRL = 6,
    CTL = 7,
};
pub const CRYPTUI_WIZ_EXPORT_FORMAT_DER = CRYPTUI_WIZ_EXPORT_FORMAT.DER;
pub const CRYPTUI_WIZ_EXPORT_FORMAT_PFX = CRYPTUI_WIZ_EXPORT_FORMAT.PFX;
pub const CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7 = CRYPTUI_WIZ_EXPORT_FORMAT.PKCS7;
pub const CRYPTUI_WIZ_EXPORT_FORMAT_BASE64 = CRYPTUI_WIZ_EXPORT_FORMAT.BASE64;
pub const CRYPTUI_WIZ_EXPORT_FORMAT_CRL = CRYPTUI_WIZ_EXPORT_FORMAT.CRL;
pub const CRYPTUI_WIZ_EXPORT_FORMAT_CTL = CRYPTUI_WIZ_EXPORT_FORMAT.CTL;

pub const BCRYPT_DH_KEY_BLOB_MAGIC = extern enum(u32) {
    UBLIC_MAGIC = 1112557636,
    RIVATE_MAGIC = 1448101956,
};
pub const BCRYPT_DH_PUBLIC_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DH_PRIVATE_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.RIVATE_MAGIC;

pub const LSA_AUTH_INFORMATION_AUTH_TYPE = extern enum(u32) {
    NONE = 0,
    NT4OWF = 1,
    CLEAR = 2,
    VERSION = 3,
};
pub const TRUST_AUTH_TYPE_NONE = LSA_AUTH_INFORMATION_AUTH_TYPE.NONE;
pub const TRUST_AUTH_TYPE_NT4OWF = LSA_AUTH_INFORMATION_AUTH_TYPE.NT4OWF;
pub const TRUST_AUTH_TYPE_CLEAR = LSA_AUTH_INFORMATION_AUTH_TYPE.CLEAR;
pub const TRUST_AUTH_TYPE_VERSION = LSA_AUTH_INFORMATION_AUTH_TYPE.VERSION;

pub const CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE = extern enum(u32) {
    N = 1,
    _NO_ROOT = 2,
    None = 0,
};
pub const CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN = CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE.N;
pub const CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT = CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE._NO_ROOT;

pub const CRYPT_XML_STATUS_ERROR_STATUS = extern enum(u32) {
    NOT_RESOLVED = 1,
    DIGEST_INVALID = 2,
    NOT_SUPPORTED_ALGORITHM = 5,
    NOT_SUPPORTED_TRANSFORM = 8,
    SIGNATURE_INVALID = 65536,
    KEYINFO_NOT_PARSED = 131072,
};
pub const CRYPT_XML_STATUS_ERROR_NOT_RESOLVED = CRYPT_XML_STATUS_ERROR_STATUS.NOT_RESOLVED;
pub const CRYPT_XML_STATUS_ERROR_DIGEST_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.DIGEST_INVALID;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_ALGORITHM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_ALGORITHM;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_TRANSFORM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_TRANSFORM;
pub const CRYPT_XML_STATUS_ERROR_SIGNATURE_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.SIGNATURE_INVALID;
pub const CRYPT_XML_STATUS_ERROR_KEYINFO_NOT_PARSED = CRYPT_XML_STATUS_ERROR_STATUS.KEYINFO_NOT_PARSED;

pub const CRYPT_TIMESTAMP_RESPONSE_STATUS = extern enum(u32) {
    GRANTED = 0,
    GRANTED_WITH_MODS = 1,
    REJECTED = 2,
    WAITING = 3,
    REVOCATION_WARNING = 4,
    REVOKED = 5,
};
pub const TIMESTAMP_STATUS_GRANTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED_WITH_MODS;
pub const TIMESTAMP_STATUS_REJECTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REJECTED;
pub const TIMESTAMP_STATUS_WAITING = CRYPT_TIMESTAMP_RESPONSE_STATUS.WAITING;
pub const TIMESTAMP_STATUS_REVOCATION_WARNING = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOCATION_WARNING;
pub const TIMESTAMP_STATUS_REVOKED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOKED;

pub const NCRYPT_ALGORITHM_NAME_CLASS = extern enum(u32) {
    ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    SECRET_AGREEMENT_INTERFACE = 4,
    SIGNATURE_INTERFACE = 5,
};
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SECRET_AGREEMENT_INTERFACE;
pub const NCRYPT_SIGNATURE_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SIGNATURE_INTERFACE;

pub const SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE = extern enum(u32) {
    BINARY = 1,
    STRING = 2,
    LEVEL = 3,
    KEYWORD_ANY = 4,
    KEYWORD_ALL = 5,
};
pub const SERVICE_TRIGGER_DATA_TYPE_BINARY = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE.BINARY;
pub const SERVICE_TRIGGER_DATA_TYPE_STRING = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE.STRING;
pub const SERVICE_TRIGGER_DATA_TYPE_LEVEL = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE.LEVEL;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ANY = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE.KEYWORD_ANY;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ALL = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_DATA_TYPE.KEYWORD_ALL;

pub const SECPKG_PACKAGE_CHANGE_TYPE = extern enum(u32) {
    LOAD = 0,
    UNLOAD = 1,
    SELECT = 2,
};
pub const SECPKG_PACKAGE_CHANGE_LOAD = SECPKG_PACKAGE_CHANGE_TYPE.LOAD;
pub const SECPKG_PACKAGE_CHANGE_UNLOAD = SECPKG_PACKAGE_CHANGE_TYPE.UNLOAD;
pub const SECPKG_PACKAGE_CHANGE_SELECT = SECPKG_PACKAGE_CHANGE_TYPE.SELECT;

pub const CTL_MODIFY_REQUEST_OPERATION = extern enum(u32) {
    ADD_TRUSTED = 3,
    ADD_NOT_TRUSTED = 1,
    REMOVE = 2,
};
pub const CTL_MODIFY_REQUEST_ADD_TRUSTED = CTL_MODIFY_REQUEST_OPERATION.ADD_TRUSTED;
pub const CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED = CTL_MODIFY_REQUEST_OPERATION.ADD_NOT_TRUSTED;
pub const CTL_MODIFY_REQUEST_REMOVE = CTL_MODIFY_REQUEST_OPERATION.REMOVE;

pub const SERVICE_STATUS_CURRENT_STATE = extern enum(u32) {
    CONTINUE_PENDING = 5,
    PAUSE_PENDING = 6,
    PAUSED = 7,
    RUNNING = 4,
    START_PENDING = 2,
    STOP_PENDING = 3,
    STOPPED = 1,
};
pub const SERVICE_CONTINUE_PENDING = SERVICE_STATUS_CURRENT_STATE.CONTINUE_PENDING;
pub const SERVICE_PAUSE_PENDING = SERVICE_STATUS_CURRENT_STATE.PAUSE_PENDING;
pub const SERVICE_PAUSED = SERVICE_STATUS_CURRENT_STATE.PAUSED;
pub const SERVICE_RUNNING = SERVICE_STATUS_CURRENT_STATE.RUNNING;
pub const SERVICE_START_PENDING = SERVICE_STATUS_CURRENT_STATE.START_PENDING;
pub const SERVICE_STOP_PENDING = SERVICE_STATUS_CURRENT_STATE.STOP_PENDING;
pub const SERVICE_STOPPED = SERVICE_STATUS_CURRENT_STATE.STOPPED;

pub const TRUSTED_DOMAIN_TRUST_ATTRIBUTES = extern enum(u32) {
    NON_TRANSITIVE = 1,
    UPLEVEL_ONLY = 2,
    FILTER_SIDS = 4,
    FOREST_TRANSITIVE = 8,
    CROSS_ORGANIZATION = 16,
    TREAT_AS_EXTERNAL = 64,
    WITHIN_FOREST = 32,
};
pub const TRUST_ATTRIBUTE_NON_TRANSITIVE = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.NON_TRANSITIVE;
pub const TRUST_ATTRIBUTE_UPLEVEL_ONLY = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.UPLEVEL_ONLY;
pub const TRUST_ATTRIBUTE_FILTER_SIDS = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.FILTER_SIDS;
pub const TRUST_ATTRIBUTE_FOREST_TRANSITIVE = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.FOREST_TRANSITIVE;
pub const TRUST_ATTRIBUTE_CROSS_ORGANIZATION = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.CROSS_ORGANIZATION;
pub const TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.TREAT_AS_EXTERNAL;
pub const TRUST_ATTRIBUTE_WITHIN_FOREST = TRUSTED_DOMAIN_TRUST_ATTRIBUTES.WITHIN_FOREST;


//--------------------------------------------------------------------------------
// Section: Functions (1169)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateNamedPipeClient(
    hNamedPipe: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn SetUserObjectSecurity(
    hObj: HANDLE,
    pSIRequested: *OBJECT_SECURITY_INFORMATION,
    pSID: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn GetUserObjectSecurity(
    hObj: HANDLE,
    pSIRequested: *u32,
    // TODO: what to do with BytesParamIndex 3?
    pSID: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetThreadToken(
    Thread: ?*HANDLE,
    Token: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenProcessToken(
    ProcessHandle: HANDLE,
    DesiredAccess: TOKEN_ACCESS_MASK,
    TokenHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenThreadToken(
    ThreadHandle: HANDLE,
    DesiredAccess: TOKEN_ACCESS_MASK,
    OpenAsSelf: BOOL,
    TokenHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn InstallELAMCertificateInfo(
    ELAMFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckAndAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: ?*c_void,
    ObjectTypeName: PSTR,
    ObjectName: ?PSTR,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: *u32,
    AccessStatus: *i32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeAndAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    ObjectTypeName: [*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: *u32,
    AccessStatus: *i32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    ObjectTypeName: [*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    ClientToken: HANDLE,
    ObjectTypeName: [*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectOpenAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    ObjectTypeName: PSTR,
    ObjectName: ?PSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    GrantedAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    ObjectCreation: BOOL,
    AccessGranted: BOOL,
    GenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectPrivilegeAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    Privileges: *PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectCloseAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectDeleteAuditAlarmA(
    SubsystemName: [*:0]const u8,
    HandleId: *c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn PrivilegedServiceAuditAlarmA(
    SubsystemName: [*:0]const u8,
    ServiceName: [*:0]const u8,
    ClientToken: HANDLE,
    Privileges: *PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AddConditionalAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AceType: u8,
    AccessMask: u32,
    pSid: PSID,
    ConditionStr: [*]u16,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetFileSecurityA(
    lpFileName: [*:0]const u8,
    SecurityInformation: u32,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetFileSecurityA(
    lpFileName: [*:0]const u8,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountSidA(
    lpSystemName: ?[*:0]const u8,
    Sid: PSID,
    Name: ?[*:0]u8,
    cchName: *u32,
    ReferencedDomainName: ?[*:0]u8,
    cchReferencedDomainName: *u32,
    peUse: *SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountSidW(
    lpSystemName: ?[*:0]const u16,
    Sid: PSID,
    Name: ?[*:0]u16,
    cchName: *u32,
    ReferencedDomainName: ?[*:0]u16,
    cchReferencedDomainName: *u32,
    peUse: *SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountNameA(
    lpSystemName: ?[*:0]const u8,
    lpAccountName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    Sid: PSID,
    cbSid: *u32,
    ReferencedDomainName: ?[*:0]u8,
    cchReferencedDomainName: *u32,
    peUse: *SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountNameW(
    lpSystemName: ?[*:0]const u16,
    lpAccountName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    Sid: PSID,
    cbSid: *u32,
    ReferencedDomainName: ?[*:0]u16,
    cchReferencedDomainName: *u32,
    peUse: *SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeValueA(
    lpSystemName: ?[*:0]const u8,
    lpName: [*:0]const u8,
    lpLuid: *LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeValueW(
    lpSystemName: ?[*:0]const u16,
    lpName: [*:0]const u16,
    lpLuid: *LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeNameA(
    lpSystemName: ?[*:0]const u8,
    lpLuid: *LUID,
    lpName: ?[*:0]u8,
    cchName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeNameW(
    lpSystemName: ?[*:0]const u16,
    lpLuid: *LUID,
    lpName: ?[*:0]u16,
    cchName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeDisplayNameA(
    lpSystemName: ?[*:0]const u8,
    lpName: [*:0]const u8,
    lpDisplayName: ?[*:0]u8,
    cchDisplayName: *u32,
    lpLanguageId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeDisplayNameW(
    lpSystemName: ?[*:0]const u16,
    lpName: [*:0]const u16,
    lpDisplayName: ?[*:0]u16,
    cchDisplayName: *u32,
    lpLanguageId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserA(
    lpszUsername: [*:0]const u8,
    lpszDomain: ?[*:0]const u8,
    lpszPassword: ?[*:0]const u8,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserW(
    lpszUsername: [*:0]const u16,
    lpszDomain: ?[*:0]const u16,
    lpszPassword: ?[*:0]const u16,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserExA(
    lpszUsername: [*:0]const u8,
    lpszDomain: ?[*:0]const u8,
    lpszPassword: ?[*:0]const u8,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*HANDLE,
    ppLogonSid: ?*PSID,
    // TODO: what to do with BytesParamIndex 8?
    ppProfileBuffer: ?*?*c_void,
    pdwProfileLength: ?*u32,
    pQuotaLimits: ?*QUOTA_LIMITS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserExW(
    lpszUsername: [*:0]const u16,
    lpszDomain: ?[*:0]const u16,
    lpszPassword: ?[*:0]const u16,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*HANDLE,
    ppLogonSid: ?*PSID,
    // TODO: what to do with BytesParamIndex 8?
    ppProfileBuffer: ?*?*c_void,
    pdwProfileLength: ?*u32,
    pQuotaLimits: ?*QUOTA_LIMITS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegGetKeySecurity(
    hKey: HKEY,
    SecurityInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpcbSecurityDescriptor: *u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSetKeySecurity(
    hKey: HKEY,
    SecurityInformation: u32,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlConvertSidToUnicodeString(
    UnicodeString: *UNICODE_STRING,
    Sid: PSID,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "logoncli" fn NetAddServiceAccount(
    ServerName: ?PWSTR,
    AccountName: PWSTR,
    Password: PWSTR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "logoncli" fn NetRemoveServiceAccount(
    ServerName: ?PWSTR,
    AccountName: PWSTR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "logoncli" fn NetEnumerateServiceAccounts(
    ServerName: ?PWSTR,
    Flags: u32,
    AccountsCount: *u32,
    Accounts: ***u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "logoncli" fn NetIsServiceAccount(
    ServerName: ?PWSTR,
    AccountName: PWSTR,
    IsService: *BOOL,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "logoncli" fn NetQueryServiceAccount(
    ServerName: ?PWSTR,
    AccountName: PWSTR,
    InfoLevel: u32,
    Buffer: **u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetServiceBits(
    hServiceStatus: SERVICE_STATUS_HANDLE,
    dwServiceBits: u32,
    bSetBitsOn: BOOL,
    bUpdateImmediately: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheck(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    GenericMapping: *GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 5?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: *u32,
    GrantedAccess: *u32,
    AccessStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckAndAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: ?*c_void,
    ObjectTypeName: PWSTR,
    ObjectName: ?PWSTR,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: *u32,
    AccessStatus: *i32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByType(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 8?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: *u32,
    GrantedAccess: *u32,
    AccessStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultList(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 8?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: *u32,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeAndAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    ObjectTypeName: [*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: *u32,
    AccessStatus: *i32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    ObjectTypeName: [*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    ClientToken: HANDLE,
    ObjectTypeName: [*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    PrincipalSelfSid: PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: *GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AccessMask: u32,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedAceEx(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedObjectAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AccessMask: u32,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedAceEx(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedObjectAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    dwStartingAceIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pAceList: *c_void,
    nAceListLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    dwAccessMask: u32,
    pSid: PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessAceEx(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    dwAccessMask: u32,
    pSid: PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessObjectAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AddMandatoryAce(
    pAcl: *ACL,
    dwAceRevision: ACE_REVISION,
    AceFlags: ACE_FLAGS,
    MandatoryPolicy: u32,
    pLabelSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn AddResourceAttributeAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: PSID,
    pAttributeInfo: *CLAIM_SECURITY_ATTRIBUTES_INFORMATION,
    pReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn AddScopedPolicyIDAce(
    pAcl: *ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AdjustTokenGroups(
    TokenHandle: HANDLE,
    ResetToDefault: BOOL,
    NewState: ?*TOKEN_GROUPS,
    BufferLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    PreviousState: ?*TOKEN_GROUPS,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AdjustTokenPrivileges(
    TokenHandle: HANDLE,
    DisableAllPrivileges: BOOL,
    NewState: ?*TOKEN_PRIVILEGES,
    BufferLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    PreviousState: ?*TOKEN_PRIVILEGES,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AllocateAndInitializeSid(
    pIdentifierAuthority: *SID_IDENTIFIER_AUTHORITY,
    nSubAuthorityCount: u8,
    nSubAuthority0: u32,
    nSubAuthority1: u32,
    nSubAuthority2: u32,
    nSubAuthority3: u32,
    nSubAuthority4: u32,
    nSubAuthority5: u32,
    nSubAuthority6: u32,
    nSubAuthority7: u32,
    pSid: *PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AllocateLocallyUniqueId(
    Luid: *LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AreAllAccessesGranted(
    GrantedAccess: u32,
    DesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AreAnyAccessesGranted(
    GrantedAccess: u32,
    DesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CheckTokenMembership(
    TokenHandle: HANDLE,
    SidToCheck: PSID,
    IsMember: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CheckTokenCapability(
    TokenHandle: HANDLE,
    CapabilitySidToCheck: PSID,
    HasCapability: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetAppContainerAce(
    Acl: *ACL,
    StartingAceIndex: u32,
    AppContainerAce: **c_void,
    AppContainerAceIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CheckTokenMembershipEx(
    TokenHandle: HANDLE,
    SidToCheck: PSID,
    Flags: u32,
    IsMember: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CurrentSecurityDescriptor: *SECURITY_DESCRIPTOR,
    NewSecurityDescriptor: **SECURITY_DESCRIPTOR,
    ObjectType: ?*Guid,
    IsDirectoryObject: u8,
    GenericMapping: *GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CopySid(
    nDestinationSidLength: u32,
    // TODO: what to do with BytesParamIndex 0?
    pDestinationSid: PSID,
    pSourceSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurity(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: **SECURITY_DESCRIPTOR,
    IsDirectoryObject: BOOL,
    Token: HANDLE,
    GenericMapping: *GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurityEx(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: **SECURITY_DESCRIPTOR,
    ObjectType: ?*Guid,
    IsContainerObject: BOOL,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    Token: HANDLE,
    GenericMapping: *GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurityWithMultipleInheritance(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: **SECURITY_DESCRIPTOR,
    ObjectTypes: ?[*]?*Guid,
    GuidCount: u32,
    IsContainerObject: BOOL,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    Token: HANDLE,
    GenericMapping: *GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateRestrictedToken(
    ExistingTokenHandle: HANDLE,
    Flags: CREATE_RESTRICTED_TOKEN_FLAGS,
    DisableSidCount: u32,
    SidsToDisable: ?[*]SID_AND_ATTRIBUTES,
    DeletePrivilegeCount: u32,
    PrivilegesToDelete: ?[*]LUID_AND_ATTRIBUTES,
    RestrictedSidCount: u32,
    SidsToRestrict: ?[*]SID_AND_ATTRIBUTES,
    NewTokenHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateWellKnownSid(
    WellKnownSidType: WELL_KNOWN_SID_TYPE,
    DomainSid: PSID,
    // TODO: what to do with BytesParamIndex 3?
    pSid: PSID,
    cbSid: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualDomainSid(
    pSid1: PSID,
    pSid2: PSID,
    pfEqual: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DeleteAce(
    pAcl: *ACL,
    dwAceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DestroyPrivateObjectSecurity(
    ObjectDescriptor: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DuplicateToken(
    ExistingTokenHandle: HANDLE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DuplicateTokenHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DuplicateTokenEx(
    hExistingToken: HANDLE,
    dwDesiredAccess: TOKEN_ACCESS_MASK,
    lpTokenAttributes: ?*SECURITY_ATTRIBUTES,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenType: TOKEN_TYPE,
    phNewToken: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualPrefixSid(
    pSid1: PSID,
    pSid2: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualSid(
    pSid1: PSID,
    pSid2: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FindFirstFreeAce(
    pAcl: *ACL,
    pAce: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FreeSid(
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAce(
    pAcl: *ACL,
    dwAceIndex: u32,
    pAce: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAclInformation(
    pAcl: *ACL,
    // TODO: what to do with BytesParamIndex 2?
    pAclInformation: *c_void,
    nAclInformationLength: u32,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetFileSecurityW(
    lpFileName: [*:0]const u16,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetKernelObjectSecurity(
    Handle: HANDLE,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetLengthSid(
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetPrivateObjectSecurity(
    ObjectDescriptor: *SECURITY_DESCRIPTOR,
    SecurityInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    ResultantDescriptor: ?*SECURITY_DESCRIPTOR,
    DescriptorLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorControl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    pControl: *u16,
    lpdwRevision: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorDacl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    lpbDaclPresent: *i32,
    pDacl: **ACL,
    lpbDaclDefaulted: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorGroup(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    pGroup: *PSID,
    lpbGroupDefaulted: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorLength(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorOwner(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    pOwner: *PSID,
    lpbOwnerDefaulted: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorRMControl(
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    RMControl: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorSacl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    lpbSaclPresent: *i32,
    pSacl: **ACL,
    lpbSaclDefaulted: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidIdentifierAuthority(
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) *SID_IDENTIFIER_AUTHORITY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidLengthRequired(
    nSubAuthorityCount: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidSubAuthority(
    pSid: PSID,
    nSubAuthority: u32,
) callconv(@import("std").os.windows.WINAPI) *u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidSubAuthorityCount(
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTokenInformation(
    TokenHandle: HANDLE,
    TokenInformationClass: TOKEN_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    TokenInformation: ?*c_void,
    TokenInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetWindowsAccountDomainSid(
    pSid: PSID,
    // TODO: what to do with BytesParamIndex 2?
    pDomainSid: PSID,
    cbDomainSid: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateAnonymousToken(
    ThreadHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateLoggedOnUser(
    hToken: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateSelf(
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeAcl(
    // TODO: what to do with BytesParamIndex 1?
    pAcl: *ACL,
    nAclLength: u32,
    dwAclRevision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeSecurityDescriptor(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    dwRevision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeSid(
    Sid: PSID,
    pIdentifierAuthority: *SID_IDENTIFIER_AUTHORITY,
    nSubAuthorityCount: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsTokenRestricted(
    TokenHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidAcl(
    pAcl: *ACL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidSecurityDescriptor(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidSid(
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsWellKnownSid(
    pSid: PSID,
    WellKnownSidType: WELL_KNOWN_SID_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MakeAbsoluteSD(
    pSelfRelativeSecurityDescriptor: *SECURITY_DESCRIPTOR,
    // TODO: what to do with BytesParamIndex 2?
    pAbsoluteSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpdwAbsoluteSecurityDescriptorSize: *u32,
    // TODO: what to do with BytesParamIndex 4?
    pDacl: ?*ACL,
    lpdwDaclSize: *u32,
    // TODO: what to do with BytesParamIndex 6?
    pSacl: ?*ACL,
    lpdwSaclSize: *u32,
    // TODO: what to do with BytesParamIndex 8?
    pOwner: PSID,
    lpdwOwnerSize: *u32,
    // TODO: what to do with BytesParamIndex 10?
    pPrimaryGroup: PSID,
    lpdwPrimaryGroupSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MakeSelfRelativeSD(
    pAbsoluteSecurityDescriptor: *SECURITY_DESCRIPTOR,
    // TODO: what to do with BytesParamIndex 2?
    pSelfRelativeSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MapGenericMask(
    AccessMask: *u32,
    GenericMapping: *GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn ObjectCloseAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectDeleteAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectOpenAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    ObjectTypeName: PWSTR,
    ObjectName: ?PWSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    GrantedAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    ObjectCreation: BOOL,
    AccessGranted: BOOL,
    GenerateOnClose: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectPrivilegeAuditAlarmW(
    SubsystemName: [*:0]const u16,
    HandleId: *c_void,
    ClientToken: HANDLE,
    DesiredAccess: u32,
    Privileges: *PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn PrivilegeCheck(
    ClientToken: HANDLE,
    RequiredPrivileges: *PRIVILEGE_SET,
    pfResult: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn PrivilegedServiceAuditAlarmW(
    SubsystemName: [*:0]const u16,
    ServiceName: [*:0]const u16,
    ClientToken: HANDLE,
    Privileges: *PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn QuerySecurityAccessMask(
    SecurityInformation: u32,
    DesiredAccess: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RevertToSelf(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetAclInformation(
    pAcl: *ACL,
    // TODO: what to do with BytesParamIndex 2?
    pAclInformation: *c_void,
    nAclInformationLength: u32,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn SetFileSecurityW(
    lpFileName: [*:0]const u16,
    SecurityInformation: u32,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetKernelObjectSecurity(
    Handle: HANDLE,
    SecurityInformation: u32,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetPrivateObjectSecurity(
    SecurityInformation: u32,
    ModificationDescriptor: *SECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: **SECURITY_DESCRIPTOR,
    GenericMapping: *GENERIC_MAPPING,
    Token: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetPrivateObjectSecurityEx(
    SecurityInformation: u32,
    ModificationDescriptor: *SECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: **SECURITY_DESCRIPTOR,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    GenericMapping: *GENERIC_MAPPING,
    Token: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn SetSecurityAccessMask(
    SecurityInformation: u32,
    DesiredAccess: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorControl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    ControlBitsOfInterest: u16,
    ControlBitsToSet: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorDacl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    bDaclPresent: BOOL,
    pDacl: ?*ACL,
    bDaclDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorGroup(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    pGroup: PSID,
    bGroupDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorOwner(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    pOwner: PSID,
    bOwnerDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorRMControl(
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    RMControl: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorSacl(
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    bSaclPresent: BOOL,
    pSacl: ?*ACL,
    bSaclDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetTokenInformation(
    TokenHandle: HANDLE,
    TokenInformationClass: TOKEN_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    TokenInformation: *c_void,
    TokenInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCachedSigningLevel(
    SourceFiles: [*]HANDLE,
    SourceFileCount: u32,
    Flags: u32,
    TargetFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCachedSigningLevel(
    File: HANDLE,
    Flags: *u32,
    SigningLevel: *u32,
    // TODO: what to do with BytesParamIndex 4?
    Thumbprint: ?*u8,
    ThumbprintSize: ?*u32,
    ThumbprintAlgorithm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-security-base-l1-2-2" fn DeriveCapabilitySidsFromName(
    CapName: [*:0]const u16,
    CapabilityGroupSids: ?*?*PSID,
    CapabilityGroupSidCount: *u32,
    CapabilitySids: ?*?*PSID,
    CapabilitySidCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetAppContainerNamedObjectPath(
    Token: HANDLE,
    AppContainerSid: PSID,
    ObjectPathLength: u32,
    ObjectPath: ?[*:0]u16,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ChangeServiceConfig2A(
    hService: SC_HANDLE,
    dwInfoLevel: SERVICE_CONFIG,
    lpInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ChangeServiceConfig2W(
    hService: SC_HANDLE,
    dwInfoLevel: SERVICE_CONFIG,
    lpInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CloseServiceHandle(
    hSCObject: SC_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ControlService(
    hService: SC_HANDLE,
    dwControl: u32,
    lpServiceStatus: *SERVICE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DeleteService(
    hService: SC_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumDependentServicesA(
    hService: SC_HANDLE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 3?
    lpServices: ?*ENUM_SERVICE_STATUSA,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumDependentServicesW(
    hService: SC_HANDLE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 3?
    lpServices: ?*ENUM_SERVICE_STATUSW,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumServicesStatusA(
    hSCManager: SC_HANDLE,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 4?
    lpServices: ?*ENUM_SERVICE_STATUSA,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
    lpResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumServicesStatusW(
    hSCManager: SC_HANDLE,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 4?
    lpServices: ?*ENUM_SERVICE_STATUSW,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
    lpResumeHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumServicesStatusExA(
    hSCManager: SC_HANDLE,
    InfoLevel: SC_ENUM_TYPE,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 5?
    lpServices: ?*u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
    lpResumeHandle: ?*u32,
    pszGroupName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EnumServicesStatusExW(
    hSCManager: SC_HANDLE,
    InfoLevel: SC_ENUM_TYPE,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwServiceState: ENUM_SERVICE_STATE,
    // TODO: what to do with BytesParamIndex 5?
    lpServices: ?*u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
    lpServicesReturned: *u32,
    lpResumeHandle: ?*u32,
    pszGroupName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetServiceKeyNameA(
    hSCManager: SC_HANDLE,
    lpDisplayName: [*:0]const u8,
    lpServiceName: ?[*:0]u8,
    lpcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetServiceKeyNameW(
    hSCManager: SC_HANDLE,
    lpDisplayName: [*:0]const u16,
    lpServiceName: ?[*:0]u16,
    lpcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetServiceDisplayNameA(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u8,
    lpDisplayName: ?[*:0]u8,
    lpcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetServiceDisplayNameW(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u16,
    lpDisplayName: ?[*:0]u16,
    lpcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LockServiceDatabase(
    hSCManager: SC_HANDLE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn NotifyBootConfigStatus(
    BootAcceptable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenSCManagerA(
    lpMachineName: ?[*:0]const u8,
    lpDatabaseName: ?[*:0]const u8,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenSCManagerW(
    lpMachineName: ?[*:0]const u16,
    lpDatabaseName: ?[*:0]const u16,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenServiceA(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u8,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn OpenServiceW(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u16,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceConfigA(
    hService: SC_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceConfig: ?*QUERY_SERVICE_CONFIGA,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceConfigW(
    hService: SC_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceConfig: ?*QUERY_SERVICE_CONFIGW,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceConfig2A(
    hService: SC_HANDLE,
    dwInfoLevel: SERVICE_CONFIG,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceConfig2W(
    hService: SC_HANDLE,
    dwInfoLevel: SERVICE_CONFIG,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceLockStatusA(
    hSCManager: SC_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpLockStatus: ?*QUERY_SERVICE_LOCK_STATUSA,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceLockStatusW(
    hSCManager: SC_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpLockStatus: ?*QUERY_SERVICE_LOCK_STATUSW,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceObjectSecurity(
    hService: SC_HANDLE,
    dwSecurityInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceStatus(
    hService: SC_HANDLE,
    lpServiceStatus: *SERVICE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn QueryServiceStatusEx(
    hService: SC_HANDLE,
    InfoLevel: SC_STATUS_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegisterServiceCtrlHandlerA(
    lpServiceName: [*:0]const u8,
    lpHandlerProc: LPHANDLER_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) SERVICE_STATUS_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegisterServiceCtrlHandlerW(
    lpServiceName: [*:0]const u16,
    lpHandlerProc: LPHANDLER_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) SERVICE_STATUS_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegisterServiceCtrlHandlerExA(
    lpServiceName: [*:0]const u8,
    lpHandlerProc: LPHANDLER_FUNCTION_EX,
    lpContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) SERVICE_STATUS_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegisterServiceCtrlHandlerExW(
    lpServiceName: [*:0]const u16,
    lpHandlerProc: LPHANDLER_FUNCTION_EX,
    lpContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) SERVICE_STATUS_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetServiceObjectSecurity(
    hService: SC_HANDLE,
    dwSecurityInformation: OBJECT_SECURITY_INFORMATION,
    lpSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetServiceStatus(
    hServiceStatus: SERVICE_STATUS_HANDLE,
    lpServiceStatus: *SERVICE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn StartServiceCtrlDispatcherA(
    lpServiceStartTable: *const SERVICE_TABLE_ENTRYA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn StartServiceCtrlDispatcherW(
    lpServiceStartTable: *const SERVICE_TABLE_ENTRYW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn StartServiceA(
    hService: SC_HANDLE,
    dwNumServiceArgs: u32,
    lpServiceArgVectors: ?[*]?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn StartServiceW(
    hService: SC_HANDLE,
    dwNumServiceArgs: u32,
    lpServiceArgVectors: ?[*]?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn UnlockServiceDatabase(
    ScLock: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn NotifyServiceStatusChangeA(
    hService: SC_HANDLE,
    dwNotifyMask: SERVICE_NOTIFY,
    pNotifyBuffer: *SERVICE_NOTIFY_2A,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn NotifyServiceStatusChangeW(
    hService: SC_HANDLE,
    dwNotifyMask: SERVICE_NOTIFY,
    pNotifyBuffer: *SERVICE_NOTIFY_2W,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn ControlServiceExA(
    hService: SC_HANDLE,
    dwControl: u32,
    dwInfoLevel: u32,
    pControlParams: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn ControlServiceExW(
    hService: SC_HANDLE,
    dwControl: u32,
    dwInfoLevel: u32,
    pControlParams: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn QueryServiceDynamicInformation(
    hServiceStatus: SERVICE_STATUS_HANDLE,
    dwInfoLevel: u32,
    ppDynamicInfo: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn WaitServiceState(
    hService: SC_HANDLE,
    dwNotify: u32,
    dwTimeout: u32,
    hCancelEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "api-ms-win-service-core-l1-1-3" fn GetServiceRegistryStateKey(
    ServiceStatusHandle: SERVICE_STATUS_HANDLE,
    StateType: SERVICE_REGISTRY_STATE_TYPE,
    AccessMask: u32,
    ServiceStateKey: *HKEY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "api-ms-win-service-core-l1-1-4" fn GetServiceDirectory(
    hServiceStatus: SERVICE_STATUS_HANDLE,
    eDirectoryType: SERVICE_DIRECTORY_TYPE,
    lpPathBuffer: ?[*]u16,
    cchPathBufferLength: u32,
    lpcchRequiredBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaRegisterLogonProcess(
    LogonProcessName: *STRING,
    LsaHandle: *LsaHandle,
    SecurityMode: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaLogonUser(
    LsaHandle: HANDLE,
    OriginName: *STRING,
    LogonType: SECURITY_LOGON_TYPE,
    AuthenticationPackage: u32,
    // TODO: what to do with BytesParamIndex 5?
    AuthenticationInformation: *c_void,
    AuthenticationInformationLength: u32,
    LocalGroups: ?*TOKEN_GROUPS,
    SourceContext: *TOKEN_SOURCE,
    ProfileBuffer: **c_void,
    ProfileBufferLength: *u32,
    LogonId: *LUID,
    Token: *HANDLE,
    Quotas: *QUOTA_LIMITS,
    SubStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaLookupAuthenticationPackage(
    LsaHandle: HANDLE,
    PackageName: *STRING,
    AuthenticationPackage: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaFreeReturnBuffer(
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaCallAuthenticationPackage(
    LsaHandle: HANDLE,
    AuthenticationPackage: u32,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: *c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: ?*?*c_void,
    ReturnBufferLength: ?*u32,
    ProtocolStatus: ?*i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaDeregisterLogonProcess(
    LsaHandle: LsaHandle,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaConnectUntrusted(
    LsaHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaFreeMemory(
    Buffer: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaClose(
    ObjectHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaEnumerateLogonSessions(
    LogonSessionCount: *u32,
    LogonSessionList: **LUID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaGetLogonSessionData(
    LogonId: *LUID,
    ppLogonSessionData: **SECURITY_LOGON_SESSION_DATA,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaOpenPolicy(
    SystemName: ?*UNICODE_STRING,
    ObjectAttributes: *OBJECT_ATTRIBUTES,
    DesiredAccess: u32,
    PolicyHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ADVAPI32" fn LsaSetCAPs(
    CAPDNs: ?[*]UNICODE_STRING,
    CAPDNCount: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn LsaGetAppliedCAPIDs(
    SystemName: ?*UNICODE_STRING,
    CAPIDs: **PSID,
    CAPIDCount: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn LsaQueryCAPs(
    CAPIDs: ?[*]PSID,
    CAPIDCount: u32,
    CAPs: **CENTRAL_ACCESS_POLICY,
    CAPCount: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaQueryInformationPolicy(
    PolicyHandle: *c_void,
    InformationClass: POLICY_INFORMATION_CLASS,
    Buffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaSetInformationPolicy(
    PolicyHandle: *c_void,
    InformationClass: POLICY_INFORMATION_CLASS,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaQueryDomainInformationPolicy(
    PolicyHandle: *c_void,
    InformationClass: POLICY_DOMAIN_INFORMATION_CLASS,
    Buffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaSetDomainInformationPolicy(
    PolicyHandle: *c_void,
    InformationClass: POLICY_DOMAIN_INFORMATION_CLASS,
    Buffer: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaRegisterPolicyChangeNotification(
    InformationClass: POLICY_NOTIFICATION_INFORMATION_CLASS,
    NotificationEventHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn LsaUnregisterPolicyChangeNotification(
    InformationClass: POLICY_NOTIFICATION_INFORMATION_CLASS,
    NotificationEventHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaEnumerateTrustedDomains(
    PolicyHandle: *c_void,
    EnumerationContext: *u32,
    Buffer: **c_void,
    PreferedMaximumLength: u32,
    CountReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaLookupNames(
    PolicyHandle: *c_void,
    Count: u32,
    Names: *UNICODE_STRING,
    ReferencedDomains: **LSA_REFERENCED_DOMAIN_LIST,
    Sids: **LSA_TRANSLATED_SID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaLookupNames2(
    PolicyHandle: *c_void,
    Flags: u32,
    Count: u32,
    Names: *UNICODE_STRING,
    ReferencedDomains: **LSA_REFERENCED_DOMAIN_LIST,
    Sids: **LSA_TRANSLATED_SID2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaLookupSids(
    PolicyHandle: *c_void,
    Count: u32,
    Sids: *PSID,
    ReferencedDomains: **LSA_REFERENCED_DOMAIN_LIST,
    Names: **LSA_TRANSLATED_NAME,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ADVAPI32" fn LsaLookupSids2(
    PolicyHandle: *c_void,
    LookupOptions: u32,
    Count: u32,
    Sids: *PSID,
    ReferencedDomains: **LSA_REFERENCED_DOMAIN_LIST,
    Names: **LSA_TRANSLATED_NAME,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaEnumerateAccountsWithUserRight(
    PolicyHandle: *c_void,
    UserRight: ?*UNICODE_STRING,
    Buffer: **c_void,
    CountReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaEnumerateAccountRights(
    PolicyHandle: *c_void,
    AccountSid: PSID,
    UserRights: **UNICODE_STRING,
    CountOfRights: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaAddAccountRights(
    PolicyHandle: *c_void,
    AccountSid: PSID,
    UserRights: [*]UNICODE_STRING,
    CountOfRights: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaRemoveAccountRights(
    PolicyHandle: *c_void,
    AccountSid: PSID,
    AllRights: u8,
    UserRights: ?[*]UNICODE_STRING,
    CountOfRights: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaOpenTrustedDomainByName(
    PolicyHandle: *c_void,
    TrustedDomainName: *UNICODE_STRING,
    DesiredAccess: u32,
    TrustedDomainHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaQueryTrustedDomainInfo(
    PolicyHandle: *c_void,
    TrustedDomainSid: PSID,
    InformationClass: TRUSTED_INFORMATION_CLASS,
    Buffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaSetTrustedDomainInformation(
    PolicyHandle: *c_void,
    TrustedDomainSid: PSID,
    InformationClass: TRUSTED_INFORMATION_CLASS,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaDeleteTrustedDomain(
    PolicyHandle: *c_void,
    TrustedDomainSid: PSID,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaQueryTrustedDomainInfoByName(
    PolicyHandle: *c_void,
    TrustedDomainName: *UNICODE_STRING,
    InformationClass: TRUSTED_INFORMATION_CLASS,
    Buffer: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaSetTrustedDomainInfoByName(
    PolicyHandle: *c_void,
    TrustedDomainName: *UNICODE_STRING,
    InformationClass: TRUSTED_INFORMATION_CLASS,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaEnumerateTrustedDomainsEx(
    PolicyHandle: *c_void,
    EnumerationContext: *u32,
    Buffer: **c_void,
    PreferedMaximumLength: u32,
    CountReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaCreateTrustedDomainEx(
    PolicyHandle: *c_void,
    TrustedDomainInformation: *TRUSTED_DOMAIN_INFORMATION_EX,
    AuthenticationInformation: *TRUSTED_DOMAIN_AUTH_INFORMATION,
    DesiredAccess: u32,
    TrustedDomainHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "ADVAPI32" fn LsaQueryForestTrustInformation(
    PolicyHandle: *c_void,
    TrustedDomainName: *UNICODE_STRING,
    ForestTrustInfo: **LSA_FOREST_TRUST_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "ADVAPI32" fn LsaSetForestTrustInformation(
    PolicyHandle: *c_void,
    TrustedDomainName: *UNICODE_STRING,
    ForestTrustInfo: *LSA_FOREST_TRUST_INFORMATION,
    CheckOnly: u8,
    CollisionInfo: **LSA_FOREST_TRUST_COLLISION_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaStorePrivateData(
    PolicyHandle: *c_void,
    KeyName: *UNICODE_STRING,
    PrivateData: ?*UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaRetrievePrivateData(
    PolicyHandle: *c_void,
    KeyName: *UNICODE_STRING,
    PrivateData: **UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LsaNtStatusToWinError(
    Status: NTSTATUS,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn SystemFunction036(
    // TODO: what to do with BytesParamIndex 1?
    RandomBuffer: *c_void,
    RandomBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ADVAPI32" fn SystemFunction040(
    // TODO: what to do with BytesParamIndex 1?
    Memory: *c_void,
    MemorySize: u32,
    OptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ADVAPI32" fn SystemFunction041(
    // TODO: what to do with BytesParamIndex 1?
    Memory: *c_void,
    MemorySize: u32,
    OptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditSetSystemPolicy(
    pAuditPolicy: [*]AUDIT_POLICY_INFORMATION,
    dwPolicyCount: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditSetPerUserPolicy(
    pSid: PSID,
    pAuditPolicy: [*]AUDIT_POLICY_INFORMATION,
    dwPolicyCount: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditQuerySystemPolicy(
    pSubCategoryGuids: [*]const Guid,
    dwPolicyCount: u32,
    ppAuditPolicy: **AUDIT_POLICY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditQueryPerUserPolicy(
    pSid: PSID,
    pSubCategoryGuids: [*]const Guid,
    dwPolicyCount: u32,
    ppAuditPolicy: **AUDIT_POLICY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditEnumeratePerUserPolicy(
    ppAuditSidArray: **POLICY_AUDIT_SID_ARRAY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditComputeEffectivePolicyBySid(
    pSid: PSID,
    pSubCategoryGuids: [*]const Guid,
    dwPolicyCount: u32,
    ppAuditPolicy: **AUDIT_POLICY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditComputeEffectivePolicyByToken(
    hTokenHandle: HANDLE,
    pSubCategoryGuids: [*]const Guid,
    dwPolicyCount: u32,
    ppAuditPolicy: **AUDIT_POLICY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditEnumerateCategories(
    ppAuditCategoriesArray: **Guid,
    pdwCountReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditEnumerateSubCategories(
    pAuditCategoryGuid: ?*const Guid,
    bRetrieveAllSubCategories: u8,
    ppAuditSubCategoriesArray: **Guid,
    pdwCountReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupCategoryNameW(
    pAuditCategoryGuid: *const Guid,
    ppszCategoryName: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupCategoryNameA(
    pAuditCategoryGuid: *const Guid,
    ppszCategoryName: *PSTR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupSubCategoryNameW(
    pAuditSubCategoryGuid: *const Guid,
    ppszSubCategoryName: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupSubCategoryNameA(
    pAuditSubCategoryGuid: *const Guid,
    ppszSubCategoryName: *PSTR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupCategoryIdFromCategoryGuid(
    pAuditCategoryGuid: *const Guid,
    pAuditCategoryId: *POLICY_AUDIT_EVENT_TYPE,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditLookupCategoryGuidFromCategoryId(
    AuditCategoryId: POLICY_AUDIT_EVENT_TYPE,
    pAuditCategoryGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditSetSecurity(
    SecurityInformation: u32,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditQuerySecurity(
    SecurityInformation: u32,
    ppSecurityDescriptor: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AuditSetGlobalSaclW(
    ObjectTypeName: [*:0]const u16,
    Acl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AuditSetGlobalSaclA(
    ObjectTypeName: [*:0]const u8,
    Acl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AuditQueryGlobalSaclW(
    ObjectTypeName: [*:0]const u16,
    Acl: **ACL,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AuditQueryGlobalSaclA(
    ObjectTypeName: [*:0]const u8,
    Acl: **ACL,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AuditFree(
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn AcquireCredentialsHandleW(
    pszPrincipal: ?PWSTR,
    pszPackage: PWSTR,
    fCredentialUse: SECPKG_CRED,
    pvLogonId: ?*c_void,
    pAuthData: ?*c_void,
    pGetKeyFn: ?SEC_GET_KEY_FN,
    pvGetKeyArgument: ?*c_void,
    phCredential: *SecHandle,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn AcquireCredentialsHandleA(
    pszPrincipal: ?PSTR,
    pszPackage: PSTR,
    fCredentialUse: SECPKG_CRED,
    pvLogonId: ?*c_void,
    pAuthData: ?*c_void,
    pGetKeyFn: ?SEC_GET_KEY_FN,
    pvGetKeyArgument: ?*c_void,
    phCredential: *SecHandle,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn FreeCredentialsHandle(
    phCredential: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SspiCli" fn AddCredentialsW(
    hCredentials: *SecHandle,
    pszPrincipal: ?PWSTR,
    pszPackage: PWSTR,
    fCredentialUse: u32,
    pAuthData: ?*c_void,
    pGetKeyFn: ?SEC_GET_KEY_FN,
    pvGetKeyArgument: ?*c_void,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SspiCli" fn AddCredentialsA(
    hCredentials: *SecHandle,
    pszPrincipal: ?PSTR,
    pszPackage: PSTR,
    fCredentialUse: u32,
    pAuthData: ?*c_void,
    pGetKeyFn: ?SEC_GET_KEY_FN,
    pvGetKeyArgument: ?*c_void,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn ChangeAccountPasswordW(
    pszPackageName: *u16,
    pszDomainName: *u16,
    pszAccountName: *u16,
    pszOldPassword: *u16,
    pszNewPassword: *u16,
    bImpersonating: u8,
    dwReserved: u32,
    pOutput: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn ChangeAccountPasswordA(
    pszPackageName: *i8,
    pszDomainName: *i8,
    pszAccountName: *i8,
    pszOldPassword: *i8,
    pszNewPassword: *i8,
    bImpersonating: u8,
    dwReserved: u32,
    pOutput: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn InitializeSecurityContextW(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pszTargetName: ?*u16,
    fContextReq: u32,
    Reserved1: u32,
    TargetDataRep: u32,
    pInput: ?*SecBufferDesc,
    Reserved2: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn InitializeSecurityContextA(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pszTargetName: ?*i8,
    fContextReq: u32,
    Reserved1: u32,
    TargetDataRep: u32,
    pInput: ?*SecBufferDesc,
    Reserved2: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn AcceptSecurityContext(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pInput: ?*SecBufferDesc,
    fContextReq: ACCEPT_SECURITY_CONTEXT_CONTEXT_REQ,
    TargetDataRep: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn CompleteAuthToken(
    phContext: *SecHandle,
    pToken: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn ImpersonateSecurityContext(
    phContext: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn RevertSecurityContext(
    phContext: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QuerySecurityContextToken(
    phContext: *SecHandle,
    Token: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn DeleteSecurityContext(
    phContext: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn ApplyControlToken(
    phContext: *SecHandle,
    pInput: *SecBufferDesc,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn QueryContextAttributesW(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    pBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QueryContextAttributesExW(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SspiCli" fn QueryContextAttributesA(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    pBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QueryContextAttributesExA(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn SetContextAttributesW(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn SetContextAttributesA(
    phContext: *SecHandle,
    ulAttribute: SECPKG_ATTR,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QueryCredentialsAttributesW(
    phCredential: *SecHandle,
    ulAttribute: u32,
    pBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SspiCli" fn QueryCredentialsAttributesExW(
    phCredential: *SecHandle,
    ulAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QueryCredentialsAttributesA(
    phCredential: *SecHandle,
    ulAttribute: u32,
    pBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SspiCli" fn QueryCredentialsAttributesExA(
    phCredential: *SecHandle,
    ulAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn SetCredentialsAttributesW(
    phCredential: *SecHandle,
    ulAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn SetCredentialsAttributesA(
    phCredential: *SecHandle,
    ulAttribute: u32,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: *c_void,
    cbBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn FreeContextBuffer(
    pvContextBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn MakeSignature(
    phContext: *SecHandle,
    fQOP: u32,
    pMessage: *SecBufferDesc,
    MessageSeqNo: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn VerifySignature(
    phContext: *SecHandle,
    pMessage: *SecBufferDesc,
    MessageSeqNo: u32,
    pfQOP: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn EncryptMessage(
    phContext: *SecHandle,
    fQOP: u32,
    pMessage: *SecBufferDesc,
    MessageSeqNo: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn DecryptMessage(
    phContext: *SecHandle,
    pMessage: *SecBufferDesc,
    MessageSeqNo: u32,
    pfQOP: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn EnumerateSecurityPackagesW(
    pcPackages: *u32,
    ppPackageInfo: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn EnumerateSecurityPackagesA(
    pcPackages: *u32,
    ppPackageInfo: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QuerySecurityPackageInfoW(
    pszPackageName: PWSTR,
    ppPackageInfo: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn QuerySecurityPackageInfoA(
    pszPackageName: PSTR,
    ppPackageInfo: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn ExportSecurityContext(
    phContext: *SecHandle,
    fFlags: EXPORT_SECURITY_CONTEXT_FLAGS,
    pPackedContext: *SecBuffer,
    pToken: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn ImportSecurityContextW(
    pszPackage: PWSTR,
    pPackedContext: *SecBuffer,
    Token: *c_void,
    phContext: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn ImportSecurityContextA(
    pszPackage: PSTR,
    pPackedContext: *SecBuffer,
    Token: *c_void,
    phContext: *SecHandle,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn InitSecurityInterfaceA(
) callconv(@import("std").os.windows.WINAPI) *SecurityFunctionTableA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SspiCli" fn InitSecurityInterfaceW(
) callconv(@import("std").os.windows.WINAPI) *SecurityFunctionTableW;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslEnumerateProfilesA(
    ProfileList: *PSTR,
    ProfileCount: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslEnumerateProfilesW(
    ProfileList: *PWSTR,
    ProfileCount: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslGetProfilePackageA(
    ProfileName: PSTR,
    PackageInfo: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslGetProfilePackageW(
    ProfileName: PWSTR,
    PackageInfo: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslIdentifyPackageA(
    pInput: *SecBufferDesc,
    PackageInfo: **SecPkgInfoA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslIdentifyPackageW(
    pInput: *SecBufferDesc,
    PackageInfo: **SecPkgInfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslInitializeSecurityContextW(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pszTargetName: ?PWSTR,
    fContextReq: u32,
    Reserved1: u32,
    TargetDataRep: u32,
    pInput: ?*SecBufferDesc,
    Reserved2: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslInitializeSecurityContextA(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pszTargetName: ?PSTR,
    fContextReq: u32,
    Reserved1: u32,
    TargetDataRep: u32,
    pInput: ?*SecBufferDesc,
    Reserved2: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslAcceptSecurityContext(
    phCredential: ?*SecHandle,
    phContext: ?*SecHandle,
    pInput: ?*SecBufferDesc,
    fContextReq: u32,
    TargetDataRep: u32,
    phNewContext: ?*SecHandle,
    pOutput: ?*SecBufferDesc,
    pfContextAttr: *u32,
    ptsExpiry: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslSetContextOption(
    ContextHandle: *SecHandle,
    Option: u32,
    Value: *c_void,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "SspiCli" fn SaslGetContextOption(
    ContextHandle: *SecHandle,
    Option: u32,
    Value: *c_void,
    Size: u32,
    Needed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "credui" fn SspiPromptForCredentialsW(
    pszTargetName: [*:0]const u16,
    pUiInfo: ?*c_void,
    dwAuthError: u32,
    pszPackage: [*:0]const u16,
    pInputAuthIdentity: ?*c_void,
    ppAuthIdentity: **c_void,
    pfSave: ?*i32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "credui" fn SspiPromptForCredentialsA(
    pszTargetName: [*:0]const u8,
    pUiInfo: ?*c_void,
    dwAuthError: u32,
    pszPackage: [*:0]const u8,
    pInputAuthIdentity: ?*c_void,
    ppAuthIdentity: **c_void,
    pfSave: ?*i32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiPrepareForCredRead(
    AuthIdentity: *c_void,
    pszTargetName: [*:0]const u16,
    pCredmanCredentialType: *u32,
    ppszCredmanTargetName: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiPrepareForCredWrite(
    AuthIdentity: *c_void,
    pszTargetName: ?[*:0]const u16,
    pCredmanCredentialType: *u32,
    ppszCredmanTargetName: *PWSTR,
    ppszCredmanUserName: *PWSTR,
    ppCredentialBlob: **u8,
    pCredentialBlobSize: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiEncryptAuthIdentity(
    AuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SspiCli" fn SspiEncryptAuthIdentityEx(
    Options: u32,
    AuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiDecryptAuthIdentity(
    EncryptedAuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SspiCli" fn SspiDecryptAuthIdentityEx(
    Options: u32,
    EncryptedAuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiIsAuthIdentityEncrypted(
    EncryptedAuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiEncodeAuthIdentityAsStrings(
    pAuthIdentity: *c_void,
    ppszUserName: ?*?PWSTR,
    ppszDomainName: ?*?PWSTR,
    ppszPackedCredentialsString: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiValidateAuthIdentity(
    AuthData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiCopyAuthIdentity(
    AuthData: *c_void,
    AuthDataCopy: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiFreeAuthIdentity(
    AuthData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiZeroAuthIdentity(
    AuthData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiLocalFree(
    DataBuffer: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiEncodeStringsAsAuthIdentity(
    pszUserName: ?[*:0]const u16,
    pszDomainName: ?[*:0]const u16,
    pszPackedCredentialsString: ?[*:0]const u16,
    ppAuthIdentity: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiCompareAuthIdentities(
    AuthIdentity1: ?*c_void,
    AuthIdentity2: ?*c_void,
    SameSuppliedUser: ?*u8,
    SameSuppliedIdentity: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiMarshalAuthIdentity(
    AuthIdentity: *c_void,
    AuthIdentityLength: *u32,
    AuthIdentityByteArray: **i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiUnmarshalAuthIdentity(
    AuthIdentityLength: u32,
    // TODO: what to do with BytesParamIndex 0?
    AuthIdentityByteArray: PSTR,
    ppAuthIdentity: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "credui" fn SspiIsPromptingNeeded(
    ErrorOrNtStatus: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiGetTargetHostName(
    pszTargetName: [*:0]const u16,
    pszHostName: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn SspiExcludePackage(
    AuthIdentity: ?*c_void,
    pszPackageName: [*:0]const u16,
    ppNewAuthIdentity: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn AddSecurityPackageA(
    pszPackageName: PSTR,
    pOptions: ?*SECURITY_PACKAGE_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn AddSecurityPackageW(
    pszPackageName: PWSTR,
    pOptions: ?*SECURITY_PACKAGE_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn DeleteSecurityPackageA(
    pszPackageName: PSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SspiCli" fn DeleteSecurityPackageW(
    pszPackageName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredWriteW(
    Credential: *CREDENTIALW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredWriteA(
    Credential: *CREDENTIALA,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredReadW(
    TargetName: [*:0]const u16,
    Type: u32,
    Flags: u32,
    Credential: **CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredReadA(
    TargetName: [*:0]const u8,
    Type: u32,
    Flags: u32,
    Credential: **CREDENTIALA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredEnumerateW(
    Filter: ?[*:0]const u16,
    Flags: CRED_ENUMERATE_FLAGS,
    Count: *u32,
    Credential: ***CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredEnumerateA(
    Filter: ?[*:0]const u8,
    Flags: CRED_ENUMERATE_FLAGS,
    Count: *u32,
    Credential: ***CREDENTIALA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredWriteDomainCredentialsW(
    TargetInfo: *CREDENTIAL_TARGET_INFORMATIONW,
    Credential: *CREDENTIALW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredWriteDomainCredentialsA(
    TargetInfo: *CREDENTIAL_TARGET_INFORMATIONA,
    Credential: *CREDENTIALA,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredReadDomainCredentialsW(
    TargetInfo: *CREDENTIAL_TARGET_INFORMATIONW,
    Flags: u32,
    Count: *u32,
    Credential: ***CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredReadDomainCredentialsA(
    TargetInfo: *CREDENTIAL_TARGET_INFORMATIONA,
    Flags: u32,
    Count: *u32,
    Credential: ***CREDENTIALA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredDeleteW(
    TargetName: [*:0]const u16,
    Type: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredDeleteA(
    TargetName: [*:0]const u8,
    Type: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredRenameW(
    OldTargetName: [*:0]const u16,
    NewTargetName: [*:0]const u16,
    Type: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredRenameA(
    OldTargetName: [*:0]const u8,
    NewTargetName: [*:0]const u8,
    Type: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredGetTargetInfoW(
    TargetName: [*:0]const u16,
    Flags: u32,
    TargetInfo: **CREDENTIAL_TARGET_INFORMATIONW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredGetTargetInfoA(
    TargetName: [*:0]const u8,
    Flags: u32,
    TargetInfo: **CREDENTIAL_TARGET_INFORMATIONA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredMarshalCredentialW(
    CredType: CRED_MARSHAL_TYPE,
    Credential: *c_void,
    MarshaledCredential: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredMarshalCredentialA(
    CredType: CRED_MARSHAL_TYPE,
    Credential: *c_void,
    MarshaledCredential: *PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredUnmarshalCredentialW(
    MarshaledCredential: [*:0]const u16,
    CredType: *CRED_MARSHAL_TYPE,
    Credential: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredUnmarshalCredentialA(
    MarshaledCredential: [*:0]const u8,
    CredType: *CRED_MARSHAL_TYPE,
    Credential: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredIsMarshaledCredentialW(
    MarshaledCredential: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredIsMarshaledCredentialA(
    MarshaledCredential: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredUnPackAuthenticationBufferW(
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 2?
    pAuthBuffer: *c_void,
    cbAuthBuffer: u32,
    pszUserName: ?[*:0]u16,
    pcchMaxUserName: *u32,
    pszDomainName: ?[*:0]u16,
    pcchMaxDomainName: ?*u32,
    pszPassword: ?[*:0]u16,
    pcchMaxPassword: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredUnPackAuthenticationBufferA(
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 2?
    pAuthBuffer: *c_void,
    cbAuthBuffer: u32,
    pszUserName: ?[*:0]u8,
    pcchlMaxUserName: *u32,
    pszDomainName: ?[*:0]u8,
    pcchMaxDomainName: ?*u32,
    pszPassword: ?[*:0]u8,
    pcchMaxPassword: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredPackAuthenticationBufferW(
    dwFlags: u32,
    pszUserName: PWSTR,
    pszPassword: PWSTR,
    // TODO: what to do with BytesParamIndex 4?
    pPackedCredentials: ?*u8,
    pcbPackedCredentials: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredPackAuthenticationBufferA(
    dwFlags: u32,
    pszUserName: PSTR,
    pszPassword: PSTR,
    // TODO: what to do with BytesParamIndex 4?
    pPackedCredentials: ?*u8,
    pcbPackedCredentials: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredProtectW(
    fAsSelf: BOOL,
    pszCredentials: [*:0]u16,
    cchCredentials: u32,
    pszProtectedCredentials: [*:0]u16,
    pcchMaxChars: *u32,
    ProtectionType: ?*CRED_PROTECTION_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredProtectA(
    fAsSelf: BOOL,
    pszCredentials: [*:0]u8,
    cchCredentials: u32,
    pszProtectedCredentials: [*:0]u8,
    pcchMaxChars: *u32,
    ProtectionType: ?*CRED_PROTECTION_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredUnprotectW(
    fAsSelf: BOOL,
    pszProtectedCredentials: [*:0]u16,
    cchProtectedCredentials: u32,
    pszCredentials: ?[*:0]u16,
    pcchMaxChars: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredUnprotectA(
    fAsSelf: BOOL,
    pszProtectedCredentials: [*:0]u8,
    cchProtectedCredentials: u32,
    pszCredentials: ?[*:0]u8,
    pcchMaxChars: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredIsProtectedW(
    pszProtectedCredentials: PWSTR,
    pProtectionType: *CRED_PROTECTION_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredIsProtectedA(
    pszProtectedCredentials: PSTR,
    pProtectionType: *CRED_PROTECTION_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredFindBestCredentialW(
    TargetName: [*:0]const u16,
    Type: u32,
    Flags: u32,
    Credential: **CREDENTIALW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CredFindBestCredentialA(
    TargetName: [*:0]const u8,
    Type: u32,
    Flags: u32,
    Credential: **CREDENTIALA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredGetSessionTypes(
    MaximumPersistCount: u32,
    MaximumPersist: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CredFree(
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIPromptForCredentialsW(
    pUiInfo: ?*CREDUI_INFOW,
    pszTargetName: ?[*:0]const u16,
    pContext: *SecHandle,
    dwAuthError: u32,
    pszUserName: [*:0]u16,
    ulUserNameBufferSize: u32,
    pszPassword: [*:0]u16,
    ulPasswordBufferSize: u32,
    save: ?*BOOL,
    dwFlags: CREDUI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIPromptForCredentialsA(
    pUiInfo: ?*CREDUI_INFOA,
    pszTargetName: ?[*:0]const u8,
    pContext: *SecHandle,
    dwAuthError: u32,
    pszUserName: [*:0]u8,
    ulUserNameBufferSize: u32,
    pszPassword: [*:0]u8,
    ulPasswordBufferSize: u32,
    save: ?*BOOL,
    dwFlags: CREDUI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredUIPromptForWindowsCredentialsW(
    pUiInfo: ?*CREDUI_INFOW,
    dwAuthError: u32,
    pulAuthPackage: *u32,
    // TODO: what to do with BytesParamIndex 4?
    pvInAuthBuffer: ?*const c_void,
    ulInAuthBufferSize: u32,
    // TODO: what to do with BytesParamIndex 6?
    ppvOutAuthBuffer: **c_void,
    pulOutAuthBufferSize: *u32,
    pfSave: ?*BOOL,
    dwFlags: CREDUIWIN_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "credui" fn CredUIPromptForWindowsCredentialsA(
    pUiInfo: ?*CREDUI_INFOA,
    dwAuthError: u32,
    pulAuthPackage: *u32,
    // TODO: what to do with BytesParamIndex 4?
    pvInAuthBuffer: ?*const c_void,
    ulInAuthBufferSize: u32,
    // TODO: what to do with BytesParamIndex 6?
    ppvOutAuthBuffer: **c_void,
    pulOutAuthBufferSize: *u32,
    pfSave: ?*BOOL,
    dwFlags: CREDUIWIN_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIParseUserNameW(
    UserName: [*:0]const u16,
    user: [*:0]u16,
    userBufferSize: u32,
    domain: [*:0]u16,
    domainBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIParseUserNameA(
    userName: [*:0]const u8,
    user: [*:0]u8,
    userBufferSize: u32,
    domain: [*:0]u8,
    domainBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUICmdLinePromptForCredentialsW(
    pszTargetName: ?[*:0]const u16,
    pContext: *SecHandle,
    dwAuthError: u32,
    UserName: [*:0]u16,
    ulUserBufferSize: u32,
    pszPassword: [*:0]u16,
    ulPasswordBufferSize: u32,
    pfSave: ?*BOOL,
    dwFlags: CREDUI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUICmdLinePromptForCredentialsA(
    pszTargetName: ?[*:0]const u8,
    pContext: *SecHandle,
    dwAuthError: u32,
    UserName: [*:0]u8,
    ulUserBufferSize: u32,
    pszPassword: [*:0]u8,
    ulPasswordBufferSize: u32,
    pfSave: ?*BOOL,
    dwFlags: CREDUI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIConfirmCredentialsW(
    pszTargetName: [*:0]const u16,
    bConfirm: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIConfirmCredentialsA(
    pszTargetName: [*:0]const u8,
    bConfirm: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIStoreSSOCredW(
    pszRealm: ?[*:0]const u16,
    pszUsername: [*:0]const u16,
    pszPassword: [*:0]const u16,
    bPersist: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "credui" fn CredUIReadSSOCredW(
    pszRealm: ?[*:0]const u16,
    ppszUsername: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SECUR32" fn CredMarshalTargetInfo(
    InTargetInfo: *CREDENTIAL_TARGET_INFORMATIONW,
    Buffer: **u16,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SECUR32" fn CredUnmarshalTargetInfo(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *u16,
    BufferSize: u32,
    RetTargetInfo: ?*?*CREDENTIAL_TARGET_INFORMATIONW,
    RetActualSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptAcquireContextA(
    phProv: *usize,
    szContainer: ?[*:0]const u8,
    szProvider: ?[*:0]const u8,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptAcquireContextW(
    phProv: *usize,
    szContainer: ?[*:0]const u16,
    szProvider: ?[*:0]const u16,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptReleaseContext(
    hProv: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGenKey(
    hProv: usize,
    Algid: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDeriveKey(
    hProv: usize,
    Algid: u32,
    hBaseData: usize,
    dwFlags: u32,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDestroyKey(
    hKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    pbData: *const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetHashParam(
    hHash: usize,
    dwParam: CRYPT_SET_HASH_PARAM,
    pbData: *const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetHashParam(
    hHash: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProvParam(
    hProv: usize,
    dwParam: CRYPT_SET_PROV_PARAM_ID,
    pbData: *const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetProvParam(
    hProv: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGenRandom(
    hProv: usize,
    dwLen: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbBuffer: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetUserKey(
    hProv: usize,
    dwKeySpec: u32,
    phUserKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptExportKey(
    hKey: usize,
    hExpKey: usize,
    dwBlobType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    // TODO: what to do with BytesParamIndex 5?
    pbData: ?*u8,
    pdwDataLen: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptImportKey(
    hProv: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    dwDataLen: u32,
    hPubKey: usize,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEncrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*u8,
    pdwDataLen: *u32,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDecrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbData: *u8,
    pdwDataLen: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptCreateHash(
    hProv: usize,
    Algid: u32,
    hKey: usize,
    dwFlags: u32,
    phHash: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptHashData(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    dwDataLen: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptHashSessionKey(
    hHash: usize,
    hKey: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDestroyHash(
    hHash: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSignHashA(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSignHashW(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptVerifySignatureA(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: *const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptVerifySignatureW(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: *const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderA(
    pszProvName: [*:0]const u8,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderW(
    pszProvName: [*:0]const u16,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderExA(
    pszProvName: [*:0]const u8,
    dwProvType: u32,
    pdwReserved: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderExW(
    pszProvName: [*:0]const u16,
    dwProvType: u32,
    pdwReserved: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetDefaultProviderA(
    dwProvType: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PSTR,
    pcbProvName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetDefaultProviderW(
    dwProvType: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PWSTR,
    pcbProvName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProviderTypesA(
    dwIndex: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    pdwProvType: *u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PSTR,
    pcbTypeName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProviderTypesW(
    dwIndex: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    pdwProvType: *u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PWSTR,
    pcbTypeName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProvidersA(
    dwIndex: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    pdwProvType: *u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PSTR,
    pcbProvName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProvidersW(
    dwIndex: u32,
    pdwReserved: *u32,
    dwFlags: u32,
    pdwProvType: *u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PWSTR,
    pcbProvName: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptContextAddRef(
    hProv: usize,
    pdwReserved: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDuplicateKey(
    hKey: usize,
    pdwReserved: *u32,
    dwFlags: u32,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDuplicateHash(
    hHash: usize,
    pdwReserved: *u32,
    dwFlags: u32,
    phHash: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptOpenAlgorithmProvider(
    phAlgorithm: **c_void,
    pszAlgId: [*:0]const u16,
    pszImplementation: ?[*:0]const u16,
    dwFlags: BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumAlgorithms(
    dwAlgOperations: BCRYPT_OPERATION,
    pAlgCount: *u32,
    ppAlgList: **BCRYPT_ALGORITHM_IDENTIFIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumProviders(
    pszAlgId: [*:0]const u16,
    pImplCount: *u32,
    ppImplList: **BCRYPT_PROVIDER_NAME,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetProperty(
    hObject: *c_void,
    pszProperty: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetProperty(
    hObject: *c_void,
    pszProperty: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: *u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCloseAlgorithmProvider(
    hAlgorithm: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFreeBuffer(
    pvBuffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateSymmetricKey(
    hAlgorithm: *c_void,
    phKey: **c_void,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: *u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateKeyPair(
    hAlgorithm: *c_void,
    phKey: **c_void,
    dwLength: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEncrypt(
    hKey: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDecrypt(
    hKey: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptExportKey(
    hKey: *c_void,
    hExportKey: ?*c_void,
    pszBlobType: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKey(
    hAlgorithm: *c_void,
    hImportKey: ?*c_void,
    pszBlobType: [*:0]const u16,
    phKey: **c_void,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbInput: *u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKeyPair(
    hAlgorithm: *c_void,
    hImportKey: ?*c_void,
    pszBlobType: [*:0]const u16,
    phKey: **c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbInput: *u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateKey(
    hKey: *c_void,
    phNewKey: **c_void,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinalizeKeyPair(
    hKey: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyKey(
    hKey: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroySecret(
    hSecret: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSignHash(
    hKey: *c_void,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: *u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptVerifySignature(
    hKey: *c_void,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbHash: *u8,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: *u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSecretAgreement(
    hPrivKey: *c_void,
    hPubKey: *c_void,
    phAgreedSecret: **c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeriveKey(
    hSharedSecret: *c_void,
    pwszKDF: [*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptKeyDerivation(
    hKey: *c_void,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: *u8,
    cbDerivedKey: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateHash(
    hAlgorithm: *c_void,
    phHash: **c_void,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptHashData(
    hHash: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: *u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinishHash(
    hHash: *c_void,
    pbOutput: *u8,
    cbOutput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptCreateMultiHash(
    hAlgorithm: *c_void,
    phHash: **c_void,
    nHashes: u32,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptProcessMultiOperations(
    hObject: *c_void,
    operationType: BCRYPT_MULTI_OPERATION_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    pOperations: *c_void,
    cbOperations: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateHash(
    hHash: *c_void,
    phNewHash: **c_void,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyHash(
    hHash: *c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "bcrypt" fn BCryptHash(
    hAlgorithm: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: ?*u8,
    cbSecret: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: *u8,
    cbInput: u32,
    pbOutput: *u8,
    cbOutput: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenRandom(
    hAlgorithm: ?*c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbBuffer: *u8,
    cbBuffer: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyCapi(
    hHash: *c_void,
    hTargetAlg: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: *u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyPBKDF2(
    hPrf: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbPassword: ?*u8,
    cbPassword: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSalt: ?*u8,
    cbSalt: u32,
    cIterations: u64,
    // TODO: what to do with BytesParamIndex 7?
    pbDerivedKey: *u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryProviderRegistration(
    pszProvider: [*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: **CRYPT_PROVIDER_REG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumRegisteredProviders(
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 0?
    ppBuffer: **CRYPT_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateContext(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeleteContext(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContexts(
    dwTable: BCRYPT_TABLE,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 1?
    ppBuffer: **CRYPT_CONTEXTS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContext(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    pConfig: *CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 2?
    ppBuffer: **CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptAddContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    dwPosition: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRemoveContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctions(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: **CRYPT_CONTEXT_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    pConfig: *CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: **CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctionProviders(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: **CRYPT_CONTEXT_FUNCTION_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    pszProperty: [*:0]const u16,
    cbValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbValue: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: [*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: [*:0]const u16,
    pszProperty: [*:0]const u16,
    pcbValue: *u32,
    // TODO: what to do with BytesParamIndex 5?
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRegisterConfigChangeNotify(
    phEvent: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptUnregisterConfigChangeNotify(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptResolveProviders(
    pszContext: ?[*:0]const u16,
    dwInterface: u32,
    pszFunction: ?[*:0]const u16,
    pszProvider: ?[*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwFlags: BCRYPT_RESOLVE_PROVIDERS_FLAGS,
    pcbBuffer: *u32,
    // TODO: what to do with BytesParamIndex 6?
    ppBuffer: **CRYPT_PROVIDER_REFS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetFipsAlgorithmMode(
    pfEnabled: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptOpenStorageProvider(
    phProvider: *usize,
    pszProviderName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumAlgorithms(
    hProvider: usize,
    dwAlgOperations: NCRYPT_OPERATION,
    pdwAlgCount: *u32,
    ppAlgList: **NCryptAlgorithmName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsAlgSupported(
    hProvider: usize,
    pszAlgId: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumKeys(
    hProvider: usize,
    pszScope: ?[*:0]const u16,
    ppKeyName: **NCryptKeyName,
    ppEnumState: **c_void,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumStorageProviders(
    pdwProviderCount: *u32,
    ppProviderList: **NCryptProviderName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeBuffer(
    pvInput: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptOpenKey(
    hProvider: usize,
    phKey: *usize,
    pszKeyName: [*:0]const u16,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptCreatePersistedKey(
    hProvider: usize,
    phKey: *usize,
    pszAlgId: [*:0]const u16,
    pszKeyName: ?[*:0]const u16,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptGetProperty(
    hObject: usize,
    pszProperty: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: OBJECT_SECURITY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSetProperty(
    hObject: usize,
    pszProperty: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: *u8,
    cbInput: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFinalizeKey(
    hKey: usize,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEncrypt(
    hKey: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDecrypt(
    hKey: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptImportKey(
    hProvider: usize,
    hImportKey: usize,
    pszBlobType: [*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    phKey: *usize,
    // TODO: what to do with BytesParamIndex 6?
    pbData: *u8,
    cbData: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptExportKey(
    hKey: usize,
    hExportKey: usize,
    pszBlobType: [*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSignHash(
    hKey: usize,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: *u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    pcbResult: *u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptVerifySignature(
    hKey: usize,
    pPaddingInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: *u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: *u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeleteKey(
    hKey: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeObject(
    hObject: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsKeyHandle(
    hKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptTranslateHandle(
    phProvider: ?*usize,
    phKey: *usize,
    hLegacyProv: usize,
    hLegacyKey: usize,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptNotifyChangeKey(
    hProvider: usize,
    phEvent: *HANDLE,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSecretAgreement(
    hPrivKey: usize,
    hPubKey: usize,
    phAgreedSecret: *usize,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeriveKey(
    hSharedSecret: usize,
    pwszKDF: [*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptKeyDerivation(
    hKey: usize,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: *u8,
    cbDerivedKey: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptCreateClaim(
    hSubjectKey: usize,
    hAuthorityKey: usize,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: ?*u8,
    cbClaimBlob: u32,
    pcbResult: *u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptVerifyClaim(
    hSubjectKey: usize,
    hAuthorityKey: usize,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: *u8,
    cbClaimBlob: u32,
    pOutput: *BCryptBufferDesc,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFormatObject(
    dwCertEncodingType: u32,
    dwFormatType: u32,
    dwFormatStrType: u32,
    pFormatStruct: ?*c_void,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: *const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 8?
    pbFormat: ?*c_void,
    pcbFormat: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncodeObjectEx(
    dwCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    lpszStructType: [*:0]const u8,
    pvStructInfo: *const c_void,
    dwFlags: CRYPT_ENCODE_OBJECT_FLAGS,
    pEncodePara: ?*CRYPT_ENCODE_PARA,
    pvEncoded: ?*c_void,
    pcbEncoded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncodeObject(
    dwCertEncodingType: u32,
    lpszStructType: [*:0]const u8,
    pvStructInfo: *const c_void,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeObjectEx(
    dwCertEncodingType: u32,
    lpszStructType: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: *const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pDecodePara: ?*CRYPT_DECODE_PARA,
    pvStructInfo: ?*c_void,
    pcbStructInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeObject(
    dwCertEncodingType: u32,
    lpszStructType: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: *const u8,
    cbEncoded: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pvStructInfo: ?*c_void,
    pcbStructInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInstallOIDFunctionAddress(
    hModule: isize,
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    cFuncEntry: u32,
    rgFuncEntry: [*]const CRYPT_OID_FUNC_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInitOIDFunctionSet(
    pszFuncName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetOIDFunctionAddress(
    hFuncSet: *c_void,
    dwEncodingType: u32,
    pszOID: [*:0]const u8,
    dwFlags: u32,
    ppvFuncAddr: **c_void,
    phFuncAddr: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetDefaultOIDDllList(
    hFuncSet: *c_void,
    dwEncodingType: u32,
    pwszDllList: ?[*:0]u16,
    pcchDllList: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetDefaultOIDFunctionAddress(
    hFuncSet: *c_void,
    dwEncodingType: u32,
    pwszDll: ?[*:0]const u16,
    dwFlags: u32,
    ppvFuncAddr: **c_void,
    phFuncAddr: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFreeOIDFunctionAddress(
    hFuncAddr: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pszOID: [*:0]const u8,
    pwszDll: ?[*:0]const u16,
    pszOverrideFuncName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pszOID: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    dwIndex: u32,
    pwszDll: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pwszDll: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pszOID: [*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    dwValueType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*const u8,
    cbValueData: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: [*:0]const u8,
    pszOID: [*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    pdwValueType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*u8,
    pcbValueData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    dwFlags: u32,
    pvArg: ?*c_void,
    pfnEnumOIDFunc: PFN_CRYPT_ENUM_OID_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindOIDInfo(
    dwKeyType: u32,
    pvKey: *c_void,
    dwGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_OID_INFO;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterOIDInfo(
    pInfo: *CRYPT_OID_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterOIDInfo(
    pInfo: *CRYPT_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumOIDInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*c_void,
    pfnEnumOIDInfo: PFN_CRYPT_ENUM_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindLocalizedName(
    pwszCryptName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgOpenToEncode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: CRYPT_MSG_TYPE,
    pvMsgEncodeInfo: *const c_void,
    pszInnerContentObjID: ?PSTR,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCalculateEncodedLength(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    pvMsgEncodeInfo: *const c_void,
    pszInnerContentObjID: ?PSTR,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgOpenToDecode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    hCryptProv: usize,
    pRecipientInfo: *CERT_INFO,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgDuplicate(
    hCryptMsg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgClose(
    hCryptMsg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgUpdate(
    hCryptMsg: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgGetParam(
    hCryptMsg: *c_void,
    dwParamType: u32,
    dwIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgControl(
    hCryptMsg: *c_void,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgVerifyCountersignatureEncoded(
    hCryptProv: usize,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: *u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: *u8,
    cbSignerInfoCountersignature: u32,
    pciCountersigner: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgVerifyCountersignatureEncodedEx(
    hCryptProv: usize,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: *u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: *u8,
    cbSignerInfoCountersignature: u32,
    dwSignerType: u32,
    pvSigner: *c_void,
    dwFlags: u32,
    pvExtra: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCountersign(
    hCryptMsg: *c_void,
    dwIndex: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCountersignEncoded(
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignerInfo: *u8,
    cbSignerInfo: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbCountersignature: ?*u8,
    pcbCountersignature: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenStore(
    lpszStoreProvider: [*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: usize,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateStore(
    hCertStore: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSaveStore(
    hCertStore: *c_void,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    dwSaveAs: CERT_STORE_SAVE_AS,
    dwSaveTo: CERT_STORE_SAVE_TO,
    pvSaveToPara: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCloseStore(
    hCertStore: ?*c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetSubjectCertificateFromStore(
    hCertStore: *c_void,
    dwCertEncodingType: u32,
    pCertId: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCertificatesInStore(
    hCertStore: *c_void,
    pPrevCertContext: ?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCertificateInStore(
    hCertStore: *c_void,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_FLAGS,
    pvFindPara: ?*const c_void,
    pPrevCertContext: ?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetIssuerCertificateFromStore(
    hCertStore: *c_void,
    pSubjectContext: *CERT_CONTEXT,
    pPrevIssuerContext: ?*CERT_CONTEXT,
    pdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifySubjectCertificateContext(
    pSubject: *CERT_CONTEXT,
    pIssuer: ?*CERT_CONTEXT,
    pdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCertificateContext(
    pCertContext: ?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCertificateContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: *const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateContext(
    pCertContext: ?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCertificateContextProperty(
    pCertContext: *CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCertificateContextProperty(
    pCertContext: *CERT_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCertificateContextProperties(
    pCertContext: *CERT_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCTLEntryFromCertificateContextProperties(
    pCertContext: *CERT_CONTEXT,
    cOptAttr: u32,
    rgOptAttr: ?[*]CRYPT_ATTRIBUTE,
    dwFlags: u32,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 6?
    pCtlEntry: ?*CTL_ENTRY,
    pcbCtlEntry: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCertificateContextPropertiesFromCTLEntry(
    pCertContext: *CERT_CONTEXT,
    pCtlEntry: *CTL_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCRLFromStore(
    hCertStore: *c_void,
    pIssuerContext: ?*CERT_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) *CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCRLsInStore(
    hCertStore: *c_void,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCRLInStore(
    hCertStore: *c_void,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const c_void,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCRLContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCrlEncoded: *const u8,
    cbCrlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) *CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCRLContextProperty(
    pCrlContext: *CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCRLContextProperty(
    pCrlContext: *CRL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCRLContextProperties(
    pCrlContext: *CRL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCertificateInCRL(
    pCert: *CERT_CONTEXT,
    pCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: *c_void,
    ppCrlEntry: ?*?*CRL_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertIsValidCRLForCertificate(
    pCert: *CERT_CONTEXT,
    pCrl: *CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToStore(
    hCertStore: ?*c_void,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCertEncoded: *const u8,
    cbCertEncoded: u32,
    dwAddDisposition: u32,
    ppCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCertificateContextToStore(
    hCertStore: ?*c_void,
    pCertContext: *CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddSerializedElementToStore(
    hCertStore: ?*c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbElement: *const u8,
    cbElement: u32,
    dwAddDisposition: u32,
    dwFlags: u32,
    dwContextTypeFlags: u32,
    pdwContextType: ?*u32,
    ppvContext: ?*const ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCertificateFromStore(
    pCertContext: *CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCRLToStore(
    hCertStore: ?*c_void,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCrlEncoded: *const u8,
    cbCrlEncoded: u32,
    dwAddDisposition: u32,
    ppCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCRLContextToStore(
    hCertStore: ?*c_void,
    pCrlContext: *CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCRLFromStore(
    pCrlContext: *CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCertificateStoreElement(
    pCertContext: *CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCRLStoreElement(
    pCrlContext: *CRL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCTLContext(
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlEncoded: *const u8,
    cbCtlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) *CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCTLContextProperty(
    pCtlContext: *CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCTLContextProperty(
    pCtlContext: *CTL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCTLContextProperties(
    pCtlContext: *CTL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCTLsInStore(
    hCertStore: *c_void,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindSubjectInCTL(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *CTL_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCTLInStore(
    hCertStore: *c_void,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_TYPE,
    pvFindPara: ?*const c_void,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCTLToStore(
    hCertStore: ?*c_void,
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCtlEncoded: *const u8,
    cbCtlEncoded: u32,
    dwAddDisposition: u32,
    ppCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCTLContextToStore(
    hCertStore: ?*c_void,
    pCtlContext: *CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCTLStoreElement(
    pCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCTLFromStore(
    pCtlContext: *CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCertificateLinkToStore(
    hCertStore: *c_void,
    pCertContext: *CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCRLLinkToStore(
    hCertStore: *c_void,
    pCrlContext: *CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCTLLinkToStore(
    hCertStore: *c_void,
    pCtlContext: *CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddStoreToCollection(
    hCollectionStore: *c_void,
    hSiblingStore: ?*c_void,
    dwUpdateFlags: u32,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRemoveStoreFromCollection(
    hCollectionStore: *c_void,
    hSiblingStore: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertControlStore(
    hCertStore: *c_void,
    dwFlags: CERT_CONTROL_STORE_FLAGS,
    dwCtrlType: u32,
    pvCtrlPara: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetStoreProperty(
    hCertStore: *c_void,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetStoreProperty(
    hCertStore: *c_void,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateContext(
    dwContextType: u32,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: *const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pCreatePara: ?*CERT_CREATE_CONTEXT_PARA,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRegisterSystemStore(
    pvSystemStore: *const c_void,
    dwFlags: u32,
    pStoreInfo: ?*CERT_SYSTEM_STORE_INFO,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRegisterPhysicalStore(
    pvSystemStore: *const c_void,
    dwFlags: u32,
    pwszStoreName: [*:0]const u16,
    pStoreInfo: *CERT_PHYSICAL_STORE_INFO,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertUnregisterSystemStore(
    pvSystemStore: *const c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertUnregisterPhysicalStore(
    pvSystemStore: *const c_void,
    dwFlags: u32,
    pwszStoreName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSystemStoreLocation(
    dwFlags: u32,
    pvArg: ?*c_void,
    pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE_LOCATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSystemStore(
    dwFlags: u32,
    pvSystemStoreLocationPara: ?*c_void,
    pvArg: ?*c_void,
    pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumPhysicalStore(
    pvSystemStore: *const c_void,
    dwFlags: u32,
    pvArg: ?*c_void,
    pfnEnum: PFN_CERT_ENUM_PHYSICAL_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetEnhancedKeyUsage(
    pCertContext: *CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pUsage: ?*CTL_USAGE,
    pcbUsage: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetEnhancedKeyUsage(
    pCertContext: *CERT_CONTEXT,
    pUsage: ?*CTL_USAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEnhancedKeyUsageIdentifier(
    pCertContext: *CERT_CONTEXT,
    pszUsageIdentifier: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRemoveEnhancedKeyUsageIdentifier(
    pCertContext: *CERT_CONTEXT,
    pszUsageIdentifier: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetValidUsages(
    cCerts: u32,
    rghCerts: [*]*CERT_CONTEXT,
    cNumOIDs: *i32,
    // TODO: what to do with BytesParamIndex 4?
    rghOIDs: ?*?PSTR,
    pcbOIDs: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgGetAndVerifySigner(
    hCryptMsg: *c_void,
    cSignerStore: u32,
    rghSignerStore: ?[*]?*c_void,
    dwFlags: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    pdwSignerIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgSignCTL(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlContent: *u8,
    cbCtlContent: u32,
    pSignInfo: *CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgEncodeAndSignCTL(
    dwMsgEncodingType: u32,
    pCtlInfo: *CTL_INFO,
    pSignInfo: *CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindSubjectInSortedCTL(
    pSubjectIdentifier: *CRYPTOAPI_BLOB,
    pCtlContext: *CTL_CONTEXT,
    dwFlags: u32,
    pvReserved: *c_void,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSubjectInSortedCTL(
    pCtlContext: *CTL_CONTEXT,
    ppvNextSubject: **c_void,
    pSubjectIdentifier: ?*CRYPTOAPI_BLOB,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCTLUsage(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: *c_void,
    pSubjectUsage: *CTL_USAGE,
    dwFlags: u32,
    pVerifyUsagePara: ?*CTL_VERIFY_USAGE_PARA,
    pVerifyUsageStatus: *CTL_VERIFY_USAGE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyRevocation(
    dwEncodingType: u32,
    dwRevType: u32,
    cContext: u32,
    rgpvContext: [*]*c_void,
    dwFlags: u32,
    pRevPara: ?*CERT_REVOCATION_PARA,
    pRevStatus: *CERT_REVOCATION_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareIntegerBlob(
    pInt1: *CRYPTOAPI_BLOB,
    pInt2: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareCertificate(
    dwCertEncodingType: u32,
    pCertId1: *CERT_INFO,
    pCertId2: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareCertificateName(
    dwCertEncodingType: u32,
    pCertName1: *CRYPTOAPI_BLOB,
    pCertName2: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertIsRDNAttrsInCertificateName(
    dwCertEncodingType: u32,
    dwFlags: u32,
    pCertName: *CRYPTOAPI_BLOB,
    pRDN: *CERT_RDN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertComparePublicKeyInfo(
    dwCertEncodingType: u32,
    pPublicKey1: *CERT_PUBLIC_KEY_INFO,
    pPublicKey2: *CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetPublicKeyLength(
    dwCertEncodingType: u32,
    pPublicKey: *CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyCertificateSignature(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: *const u8,
    cbEncoded: u32,
    pPublicKey: *CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyCertificateSignatureEx(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: *c_void,
    dwIssuerType: u32,
    pvIssuer: ?*c_void,
    dwFlags: CRYPT_VERIFY_CERT_FLAGS,
    pvExtra: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "CRYPT32" fn CertIsStrongHashToSign(
    pStrongSignPara: *CERT_STRONG_SIGN_PARA,
    pwszCNGHashAlgid: [*:0]const u16,
    pSigningCert: ?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashToBeSigned(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: *const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbComputedHash: ?*u8,
    pcbComputedHash: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashCertificate(
    hCryptProv: usize,
    Algid: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: *const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptHashCertificate2(
    pwszCNGHashAlgid: [*:0]const u16,
    dwFlags: u32,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignCertificate(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedToBeSigned: *const u8,
    cbEncodedToBeSigned: u32,
    pSignatureAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*const c_void,
    // TODO: what to do with BytesParamIndex 8?
    pbSignature: ?*u8,
    pcbSignature: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignAndEncodeCertificate(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: CERT_KEY_SPEC,
    dwCertEncodingType: u32,
    lpszStructType: [*:0]const u8,
    pvStructInfo: *const c_void,
    pSignatureAlgorithm: *CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*const c_void,
    // TODO: what to do with BytesParamIndex 8?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCertInfo: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCRLTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCrlInfo: *CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyValidityNesting(
    pSubjectInfo: *CERT_INFO,
    pIssuerInfo: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCRLRevocation(
    dwCertEncodingType: u32,
    pCertId: *CERT_INFO,
    cCrlInfo: u32,
    rgpCrlInfo: [*]*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAlgIdToOID(
    dwAlgId: u32,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOIDToAlgId(
    pszObjId: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindExtension(
    pszObjId: [*:0]const u8,
    cExtensions: u32,
    rgExtensions: [*]CERT_EXTENSION,
) callconv(@import("std").os.windows.WINAPI) *CERT_EXTENSION;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindAttribute(
    pszObjId: [*:0]const u8,
    cAttr: u32,
    rgAttr: [*]CRYPT_ATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_ATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindRDNAttr(
    pszObjId: [*:0]const u8,
    pName: *CERT_NAME_INFO,
) callconv(@import("std").os.windows.WINAPI) *CERT_RDN_ATTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetIntendedKeyUsage(
    dwCertEncodingType: u32,
    pCertInfo: *CERT_INFO,
    pbKeyUsage: *u8,
    cbKeyUsage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInstallDefaultContext(
    hCryptProv: usize,
    dwDefaultType: CRYPT_DEFAULT_CONTEXT_TYPE,
    pvDefaultPara: ?*const c_void,
    dwFlags: CRYPT_DEFAULT_CONTEXT_FLAGS,
    pvReserved: *c_void,
    phDefaultContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUninstallDefaultContext(
    hDefaultContext: ?*c_void,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPublicKeyInfo(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPublicKeyInfoEx(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 7?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptExportPublicKeyInfoFromBCryptKeyHandle(
    hBCryptKey: *c_void,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPublicKeyInfo(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: *CERT_PUBLIC_KEY_INFO,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPublicKeyInfoEx(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: *CERT_PUBLIC_KEY_INFO,
    aiKeyAlg: u32,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    phKey: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptImportPublicKeyInfoEx2(
    dwCertEncodingType: u32,
    pInfo: *CERT_PUBLIC_KEY_INFO,
    dwFlags: CRYPT_IMPORT_PUBLIC_KEY_FLAGS,
    pvAuxInfo: ?*c_void,
    phKey: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptAcquireCertificatePrivateKey(
    pCert: *CERT_CONTEXT,
    dwFlags: CRYPT_ACQUIRE_FLAGS,
    pvParameters: ?*c_void,
    phCryptProvOrNCryptKey: *usize,
    pdwKeySpec: ?*CERT_KEY_SPEC,
    pfCallerFreeProvOrNCryptKey: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindCertificateKeyProvInfo(
    pCert: *CERT_CONTEXT,
    dwFlags: CRYPT_FIND_FLAGS,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPKCS8(
    sPrivateKeyAndParams: CRYPT_PKCS8_IMPORT_PARAMS,
    dwFlags: CRYPT_KEY_FLAGS,
    phCryptProv: ?*usize,
    pvAuxInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPKCS8(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*c_void,
    // TODO: what to do with BytesParamIndex 6?
    pbPrivateKeyBlob: ?*u8,
    pcbPrivateKeyBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashPublicKeyInfo(
    hCryptProv: usize,
    Algid: u32,
    dwFlags: u32,
    dwCertEncodingType: u32,
    pInfo: *CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRDNValueToStrA(
    dwValueType: u32,
    pValue: *CRYPTOAPI_BLOB,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRDNValueToStrW(
    dwValueType: u32,
    pValue: *CRYPTOAPI_BLOB,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertNameToStrA(
    dwCertEncodingType: u32,
    pName: *CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertNameToStrW(
    dwCertEncodingType: u32,
    pName: *CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertStrToNameA(
    dwCertEncodingType: u32,
    pszX500: [*:0]const u8,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
    ppszError: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertStrToNameW(
    dwCertEncodingType: u32,
    pszX500: [*:0]const u16,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: *u32,
    ppszError: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetNameStringA(
    pCertContext: *CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*c_void,
    pszNameString: ?[*:0]u8,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetNameStringW(
    pCertContext: *CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*c_void,
    pszNameString: ?[*:0]u16,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignMessage(
    pSignPara: *CRYPT_SIGN_MESSAGE_PARA,
    fDetachedSignature: BOOL,
    cToBeSigned: u32,
    rgpbToBeSigned: ?[*]const ?*const u8,
    rgcbToBeSigned: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageSignature(
    pVerifyPara: *CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: *const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetMessageSignerCount(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignedBlob: *const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetMessageCertificates(
    dwMsgAndCertEncodingType: u32,
    hCryptProv: usize,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: *const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyDetachedMessageSignature(
    pVerifyPara: *CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbDetachedSignBlob: *const u8,
    cbDetachedSignBlob: u32,
    cToBeSigned: u32,
    rgpbToBeSigned: [*]const *const u8,
    rgcbToBeSigned: [*]u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncryptMessage(
    pEncryptPara: *CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeEncrypted: ?*const u8,
    cbToBeEncrypted: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncryptedBlob: ?*u8,
    pcbEncryptedBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecryptMessage(
    pDecryptPara: *CRYPT_DECRYPT_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbEncryptedBlob: *const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignAndEncryptMessage(
    pSignPara: *CRYPT_SIGN_MESSAGE_PARA,
    pEncryptPara: *CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 5?
    pbToBeSignedAndEncrypted: *const u8,
    cbToBeSignedAndEncrypted: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbSignedAndEncryptedBlob: ?*u8,
    pcbSignedAndEncryptedBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecryptAndVerifyMessageSignature(
    pDecryptPara: *CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: *CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncryptedBlob: *const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeMessage(
    dwMsgTypeFlags: u32,
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedBlob: *const u8,
    cbEncodedBlob: u32,
    dwPrevInnerContentType: u32,
    pdwMsgType: ?*u32,
    pdwInnerContentType: ?*u32,
    // TODO: what to do with BytesParamIndex 10?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashMessage(
    pHashPara: *CRYPT_HASH_MESSAGE_PARA,
    fDetachedHash: BOOL,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const *const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbHashedBlob: ?*u8,
    pcbHashedBlob: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageHash(
    pHashPara: *CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbHashedBlob: *u8,
    cbHashedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeHashed: ?*u8,
    pcbToBeHashed: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyDetachedMessageHash(
    pHashPara: *CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbDetachedHashBlob: *u8,
    cbDetachedHashBlob: u32,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const *const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignMessageWithKey(
    pSignPara: *CRYPT_KEY_SIGN_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbToBeSigned: *const u8,
    cbToBeSigned: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageSignatureWithKey(
    pVerifyPara: *CRYPT_KEY_VERIFY_MESSAGE_PARA,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: *const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenSystemStoreA(
    hProv: usize,
    szSubsystemProtocol: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenSystemStoreW(
    hProv: usize,
    szSubsystemProtocol: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToSystemStoreA(
    szCertStoreName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: *const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToSystemStoreW(
    szCertStoreName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: *const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn FindCertsByIssuer(
    // TODO: what to do with BytesParamIndex 1?
    pCertChains: ?*CERT_CHAIN,
    pcbCertChains: *u32,
    pcCertChains: *u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedIssuerName: ?*u8,
    cbEncodedIssuerName: u32,
    pwszPurpose: ?[*:0]const u16,
    dwKeySpec: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptQueryObject(
    dwObjectType: CERT_QUERY_OBJECT_TYPE,
    pvObject: *const c_void,
    dwExpectedContentTypeFlags: CERT_QUERY_CONTENT_TYPE_FLAGS,
    dwExpectedFormatTypeFlags: CERT_QUERY_FORMAT_TYPE_FLAGS,
    dwFlags: u32,
    pdwMsgAndCertEncodingType: ?*CERT_QUERY_ENCODING_TYPE,
    pdwContentType: ?*CERT_QUERY_CONTENT_TYPE,
    pdwFormatType: ?*CERT_QUERY_FORMAT_TYPE,
    phCertStore: ?*?*c_void,
    phMsg: ?*?*c_void,
    ppvContext: ?*const ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemAlloc(
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemRealloc(
    pv: ?*c_void,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemFree(
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "CRYPT32" fn CryptCreateAsyncHandle(
    dwFlags: u32,
    phAsync: *HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptSetAsyncParam(
    hAsync: HCRYPTASYNC,
    pszParamOid: PSTR,
    pvParam: ?*c_void,
    pfnFree: PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptGetAsyncParam(
    hAsync: HCRYPTASYNC,
    pszParamOid: PSTR,
    ppvParam: ?*?*c_void,
    ppfnFree: ?*?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptCloseAsyncHandle(
    hAsync: HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptRetrieveObjectByUrlA(
    pszUrl: [*:0]const u8,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: **c_void,
    hAsyncRetrieve: HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*c_void,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptRetrieveObjectByUrlW(
    pszUrl: [*:0]const u16,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: **c_void,
    hAsyncRetrieve: HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*c_void,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPTNET" fn CryptInstallCancelRetrieval(
    pfnCancel: PFN_CRYPT_CANCEL_RETRIEVAL,
    pvArg: ?*const c_void,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPTNET" fn CryptUninstallCancelRetrieval(
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptGetObjectUrl(
    pszUrlOid: [*:0]const u8,
    pvPara: *c_void,
    dwFlags: CRYPT_GET_URL_FLAGS,
    // TODO: what to do with BytesParamIndex 4?
    pUrlArray: ?*CRYPT_URL_ARRAY,
    pcbUrlArray: *u32,
    // TODO: what to do with BytesParamIndex 6?
    pUrlInfo: ?*CRYPT_URL_INFO,
    pcbUrlInfo: ?*u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateSelfSignCertificate(
    hCryptProvOrNCryptKey: usize,
    pSubjectIssuerBlob: *CRYPTOAPI_BLOB,
    dwFlags: CERT_CREATE_SELFSIGN_FLAGS,
    pKeyProvInfo: ?*CRYPT_KEY_PROV_INFO,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pStartTime: ?*SYSTEMTIME,
    pEndTime: ?*SYSTEMTIME,
    pExtensions: ?*CERT_EXTENSIONS,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetKeyIdentifierProperty(
    pKeyIdentifier: *const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*c_void,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSetKeyIdentifierProperty(
    pKeyIdentifier: *const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: *c_void,
    pvData: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumKeyIdentifierProperties(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: *c_void,
    pvArg: ?*c_void,
    pfnEnum: PFN_CRYPT_ENUM_KEYID_PROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptCreateKeyIdentifierFromCSP(
    dwCertEncodingType: u32,
    pszPubKeyOID: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pPubKeyStruc: *const PUBLICKEYSTRUC,
    cbPubKeyStruc: u32,
    dwFlags: u32,
    pvReserved: *c_void,
    // TODO: what to do with BytesParamIndex 7?
    pbHash: ?*u8,
    pcbHash: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCertificateChainEngine(
    pConfig: *CERT_CHAIN_ENGINE_CONFIG,
    phChainEngine: *HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateChainEngine(
    hChainEngine: HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "CRYPT32" fn CertResyncCertificateChainEngine(
    hChainEngine: HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCertificateChain(
    hChainEngine: HCERTCHAINENGINE,
    pCertContext: *CERT_CONTEXT,
    pTime: ?*FILETIME,
    hAdditionalStore: ?*c_void,
    pChainPara: *CERT_CHAIN_PARA,
    dwFlags: u32,
    pvReserved: *c_void,
    ppChainContext: **CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateChain(
    pChainContext: *CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCertificateChain(
    pChainContext: *CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindChainInStore(
    hCertStore: *c_void,
    dwCertEncodingType: u32,
    dwFindFlags: CERT_FIND_CHAIN_IN_STORE_FLAGS,
    dwFindType: u32,
    pvFindPara: ?*const c_void,
    pPrevChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) *CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCertificateChainPolicy(
    pszPolicyOID: [*:0]const u8,
    pChainContext: *CERT_CHAIN_CONTEXT,
    pPolicyPara: *CERT_CHAIN_POLICY_PARA,
    pPolicyStatus: *CERT_CHAIN_POLICY_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptStringToBinaryA(
    pszString: [*:0]const u8,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: *u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptStringToBinaryW(
    pszString: [*:0]const u16,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: *u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptBinaryToStringA(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: *const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u8,
    pcchString: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptBinaryToStringW(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: *const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u16,
    pcchString: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXImportCertStore(
    pPFX: *CRYPTOAPI_BLOB,
    szPassword: [*:0]const u16,
    dwFlags: CRYPT_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXIsPFXBlob(
    pPFX: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXVerifyPassword(
    pPFX: *CRYPTOAPI_BLOB,
    szPassword: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXExportCertStoreEx(
    hStore: *c_void,
    pPFX: *CRYPTOAPI_BLOB,
    szPassword: [*:0]const u16,
    pvPara: *c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXExportCertStore(
    hStore: *c_void,
    pPFX: *CRYPTOAPI_BLOB,
    szPassword: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertOpenServerOcspResponse(
    pChainContext: *CERT_CHAIN_CONTEXT,
    dwFlags: u32,
    pOpenPara: ?*CERT_SERVER_OCSP_RESPONSE_OPEN_PARA,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertAddRefServerOcspResponse(
    hServerOcspResponse: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertCloseServerOcspResponse(
    hServerOcspResponse: ?*c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertGetServerOcspResponseContext(
    hServerOcspResponse: *c_void,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) *CERT_SERVER_OCSP_RESPONSE_CONTEXT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertAddRefServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertFreeServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertRetrieveLogoOrBiometricInfo(
    pCertContext: *CERT_CONTEXT,
    lpszLogoOrBiometricType: [*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    dwFlags: u32,
    pvReserved: *c_void,
    ppbData: **u8,
    pcbData: *u32,
    ppwszMimeType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CertSelectCertificateChains(
    pSelectionContext: ?*Guid,
    dwFlags: u32,
    pChainParameters: ?*CERT_SELECT_CHAIN_PARA,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    hStore: *c_void,
    pcSelection: *u32,
    pprgpSelection: ***CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CertFreeCertificateChainList(
    prgpSelection: **CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptRetrieveTimeStamp(
    wszUrl: [*:0]const u16,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    pszHashId: [*:0]const u8,
    pPara: ?*const CRYPT_TIMESTAMP_PARA,
    // TODO: what to do with BytesParamIndex 6?
    pbData: *const u8,
    cbData: u32,
    ppTsContext: **CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptVerifyTimeStampSignature(
    // TODO: what to do with BytesParamIndex 1?
    pbTSContentInfo: *const u8,
    cbTSContentInfo: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*const u8,
    cbData: u32,
    hAdditionalStore: ?*c_void,
    ppTsContext: **CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CertIsWeakHash(
    dwHashUseType: u32,
    pwszCNGHashAlgid: [*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptProtectData(
    pDataIn: *CRYPTOAPI_BLOB,
    szDataDescr: ?[*:0]const u16,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: *c_void,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnprotectData(
    pDataIn: *CRYPTOAPI_BLOB,
    ppszDataDescr: ?*?PWSTR,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: *c_void,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: *CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUpdateProtectedState(
    pOldSid: PSID,
    pwszOldPassword: ?[*:0]const u16,
    dwFlags: u32,
    pdwSuccessCount: ?*u32,
    pdwFailureCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptProtectMemory(
    pDataIn: *c_void,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUnprotectMemory(
    pDataIn: *c_void,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCHANNEL" fn SslEmptyCacheA(
    pszTargetName: PSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCHANNEL" fn SslEmptyCacheW(
    pszTargetName: PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SCHANNEL" fn SslGenerateRandomBits(
    pRandomData: *u8,
    cRandomData: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCHANNEL" fn SslCrackCertificate(
    pbCertificate: *u8,
    cbCertificate: u32,
    dwFlags: u32,
    ppCertificate: **X509Certificate,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCHANNEL" fn SslFreeCertificate(
    pCertificate: *X509Certificate,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "SCHANNEL" fn SslGetMaximumKeySize(
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SCHANNEL" fn SslGetServerIdentity(
    // TODO: what to do with BytesParamIndex 1?
    ClientHello: *u8,
    ClientHelloSize: u32,
    ServerIdentity: **u8,
    ServerIdentitySize: *u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SCHANNEL" fn SslGetExtensions(
    clientHello: [*:0]const u8,
    clientHelloByteSize: u32,
    genericExtensions: [*]SCH_EXTENSION_DATA,
    genericExtensionsCount: u8,
    bytesToRead: *u32,
    flags: SchGetExtensionsOptions,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KeyCredMgr" fn KeyCredentialManagerGetOperationErrorStates(
    keyCredentialManagerOperationType: KeyCredentialManagerOperationType,
    isReady: *BOOL,
    keyCredentialManagerOperationErrorStates: *KeyCredentialManagerOperationErrorStates,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KeyCredMgr" fn KeyCredentialManagerShowUIOperation(
    hWndOwner: HWND,
    keyCredentialManagerOperationType: KeyCredentialManagerOperationType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KeyCredMgr" fn KeyCredentialManagerGetInformation(
    keyCredentialManagerInfo: **KeyCredentialManagerInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KeyCredMgr" fn KeyCredentialManagerFreeInformation(
    keyCredentialManagerInfo: *KeyCredentialManagerInfo,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPAddConnection(
    lpNetResource: *NETRESOURCEW,
    lpPassword: ?PWSTR,
    lpUserName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPAddConnection3(
    hwndOwner: HWND,
    lpNetResource: *NETRESOURCEW,
    lpPassword: ?PWSTR,
    lpUserName: ?PWSTR,
    dwFlags: NET_USE_CONNECT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "NTLANMAN" fn NPAddConnection4(
    hwndOwner: HWND,
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 3?
    lpAuthBuffer: ?*c_void,
    cbAuthBuffer: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpUseOptions: ?*u8,
    cbUseOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPCancelConnection(
    lpName: PWSTR,
    fForce: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetConnection(
    lpLocalName: PWSTR,
    lpRemoteName: ?[*:0]u16,
    lpnBufferLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "NTLANMAN" fn NPGetConnection3(
    lpLocalName: [*:0]const u16,
    dwLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetUniversalName(
    lpLocalPath: [*:0]const u16,
    dwInfoLevel: UNC_INFO_LEVEL,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "NTLANMAN" fn NPGetConnectionPerformance(
    lpRemoteName: [*:0]const u16,
    lpNetConnectInfo: *NETCONNECTINFOSTRUCT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPOpenEnum(
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    lpNetResource: ?*NETRESOURCEW,
    lphEnum: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPEnumResource(
    hEnum: HANDLE,
    lpcCount: *u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPCloseEnum(
    hEnum: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetCaps(
    ndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetUser(
    lpName: PWSTR,
    lpUserName: [*:0]u16,
    lpnBufferLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "NTLANMAN" fn NPGetPersistentUseOptionsForConnection(
    lpRemotePath: PWSTR,
    // TODO: what to do with BytesParamIndex 2?
    lpReadUseOptions: ?*u8,
    cbReadUseOptions: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpWriteUseOptions: *u8,
    lpSizeWriteUseOptions: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetResourceParent(
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPGetResourceInformation(
    lpNetResource: *NETRESOURCEW,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    lpBufferSize: *u32,
    lplpSystem: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "davclnt" fn NPFormatNetworkName(
    lpRemoteName: PWSTR,
    lpFormattedName: [*:0]u16,
    lpnLength: *u32,
    dwFlags: NETWORK_NAME_FORMAT_FLAGS,
    dwAveCharPerLine: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "MPR" fn WNetSetLastErrorA(
    err: u32,
    lpError: PSTR,
    lpProviders: PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MPR" fn WNetSetLastErrorW(
    err: u32,
    lpError: PWSTR,
    lpProviders: PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardEstablishContext(
    dwScope: SCARD_SCOPE,
    pvReserved1: *const c_void,
    pvReserved2: *const c_void,
    phContext: *usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardReleaseContext(
    hContext: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIsValidContext(
    hContext: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListReaderGroupsA(
    hContext: usize,
    mszGroups: ?[*:0]u8,
    pcchGroups: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListReaderGroupsW(
    hContext: usize,
    mszGroups: ?[*:0]u16,
    pcchGroups: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListReadersA(
    hContext: usize,
    mszGroups: ?[*:0]const u8,
    mszReaders: ?PSTR,
    pcchReaders: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListReadersW(
    hContext: usize,
    mszGroups: ?[*:0]const u16,
    mszReaders: ?PWSTR,
    pcchReaders: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListCardsA(
    hContext: usize,
    pbAtr: ?*u8,
    rgquidInterfaces: ?[*]Guid,
    cguidInterfaceCount: u32,
    mszCards: ?PSTR,
    pcchCards: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListCardsW(
    hContext: usize,
    pbAtr: ?*u8,
    rgquidInterfaces: ?[*]Guid,
    cguidInterfaceCount: u32,
    mszCards: ?PWSTR,
    pcchCards: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListInterfacesA(
    hContext: usize,
    szCard: [*:0]const u8,
    pguidInterfaces: *Guid,
    pcguidInterfaces: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardListInterfacesW(
    hContext: usize,
    szCard: [*:0]const u16,
    pguidInterfaces: *Guid,
    pcguidInterfaces: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetProviderIdA(
    hContext: usize,
    szCard: [*:0]const u8,
    pguidProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetProviderIdW(
    hContext: usize,
    szCard: [*:0]const u16,
    pguidProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetCardTypeProviderNameA(
    hContext: usize,
    szCardName: [*:0]const u8,
    dwProviderId: u32,
    szProvider: [*:0]u8,
    pcchProvider: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetCardTypeProviderNameW(
    hContext: usize,
    szCardName: [*:0]const u16,
    dwProviderId: u32,
    szProvider: [*:0]u16,
    pcchProvider: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceReaderGroupA(
    hContext: usize,
    szGroupName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceReaderGroupW(
    hContext: usize,
    szGroupName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetReaderGroupA(
    hContext: usize,
    szGroupName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetReaderGroupW(
    hContext: usize,
    szGroupName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceReaderA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    szDeviceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceReaderW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    szDeviceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetReaderA(
    hContext: usize,
    szReaderName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetReaderW(
    hContext: usize,
    szReaderName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardAddReaderToGroupA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    szGroupName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardAddReaderToGroupW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    szGroupName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardRemoveReaderFromGroupA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    szGroupName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardRemoveReaderFromGroupW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    szGroupName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceCardTypeA(
    hContext: usize,
    szCardName: [*:0]const u8,
    pguidPrimaryProvider: ?*Guid,
    rgguidInterfaces: ?*Guid,
    dwInterfaceCount: u32,
    pbAtr: *u8,
    pbAtrMask: *u8,
    cbAtrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardIntroduceCardTypeW(
    hContext: usize,
    szCardName: [*:0]const u16,
    pguidPrimaryProvider: ?*Guid,
    rgguidInterfaces: ?*Guid,
    dwInterfaceCount: u32,
    pbAtr: *u8,
    pbAtrMask: *u8,
    cbAtrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardSetCardTypeProviderNameA(
    hContext: usize,
    szCardName: [*:0]const u8,
    dwProviderId: u32,
    szProvider: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardSetCardTypeProviderNameW(
    hContext: usize,
    szCardName: [*:0]const u16,
    dwProviderId: u32,
    szProvider: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetCardTypeA(
    hContext: usize,
    szCardName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardForgetCardTypeW(
    hContext: usize,
    szCardName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardFreeMemory(
    hContext: usize,
    pvMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardAccessStartedEvent(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardReleaseStartedEvent(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardLocateCardsA(
    hContext: usize,
    mszCards: [*:0]const u8,
    rgReaderStates: *SCARD_READERSTATEA,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardLocateCardsW(
    hContext: usize,
    mszCards: [*:0]const u16,
    rgReaderStates: *SCARD_READERSTATEW,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardLocateCardsByATRA(
    hContext: usize,
    rgAtrMasks: *SCARD_ATRMASK,
    cAtrs: u32,
    rgReaderStates: *SCARD_READERSTATEA,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardLocateCardsByATRW(
    hContext: usize,
    rgAtrMasks: *SCARD_ATRMASK,
    cAtrs: u32,
    rgReaderStates: *SCARD_READERSTATEW,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetStatusChangeA(
    hContext: usize,
    dwTimeout: u32,
    rgReaderStates: *SCARD_READERSTATEA,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetStatusChangeW(
    hContext: usize,
    dwTimeout: u32,
    rgReaderStates: *SCARD_READERSTATEW,
    cReaders: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardCancel(
    hContext: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardConnectA(
    hContext: usize,
    szReader: [*:0]const u8,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    phCard: *usize,
    pdwActiveProtocol: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardConnectW(
    hContext: usize,
    szReader: [*:0]const u16,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    phCard: *usize,
    pdwActiveProtocol: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardReconnect(
    hCard: usize,
    dwShareMode: u32,
    dwPreferredProtocols: u32,
    dwInitialization: u32,
    pdwActiveProtocol: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardDisconnect(
    hCard: usize,
    dwDisposition: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardBeginTransaction(
    hCard: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardEndTransaction(
    hCard: usize,
    dwDisposition: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WinSCard" fn SCardState(
    hCard: usize,
    pdwState: *u32,
    pdwProtocol: *u32,
    // TODO: what to do with BytesParamIndex 4?
    pbAtr: *u8,
    pcbAtrLen: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardStatusA(
    hCard: usize,
    mszReaderNames: ?PSTR,
    pcchReaderLen: ?*u32,
    pdwState: ?*u32,
    pdwProtocol: ?*u32,
    pbAtr: ?*u8,
    pcbAtrLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardStatusW(
    hCard: usize,
    mszReaderNames: ?PWSTR,
    pcchReaderLen: ?*u32,
    pdwState: ?*u32,
    pdwProtocol: ?*u32,
    pbAtr: ?*u8,
    pcbAtrLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardTransmit(
    hCard: usize,
    pioSendPci: *SCARD_IO_REQUEST,
    // TODO: what to do with BytesParamIndex 3?
    pbSendBuffer: *u8,
    cbSendLength: u32,
    pioRecvPci: ?*SCARD_IO_REQUEST,
    // TODO: what to do with BytesParamIndex 6?
    pbRecvBuffer: *u8,
    pcbRecvLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WinSCard" fn SCardGetTransmitCount(
    hCard: usize,
    pcTransmitCount: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardControl(
    hCard: usize,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpInBuffer: *const c_void,
    cbInBufferSize: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpOutBuffer: *c_void,
    cbOutBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardGetAttrib(
    hCard: usize,
    dwAttrId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbAttr: ?*u8,
    pcbAttrLen: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WinSCard" fn SCardSetAttrib(
    hCard: usize,
    dwAttrId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbAttr: *u8,
    cbAttrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCARDDLG" fn SCardUIDlgSelectCardA(
    param0: *OPENCARDNAME_EXA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCARDDLG" fn SCardUIDlgSelectCardW(
    param0: *OPENCARDNAME_EXW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCARDDLG" fn GetOpenCardNameA(
    param0: *OPENCARDNAMEA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SCARDDLG" fn GetOpenCardNameW(
    param0: *OPENCARDNAMEW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SCARDDLG" fn SCardDlgExtendedError(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WinSCard" fn SCardReadCacheA(
    hContext: usize,
    CardIdentifier: *Guid,
    FreshnessCounter: u32,
    LookupName: PSTR,
    // TODO: what to do with BytesParamIndex 5?
    Data: *u8,
    DataLen: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WinSCard" fn SCardReadCacheW(
    hContext: usize,
    CardIdentifier: *Guid,
    FreshnessCounter: u32,
    LookupName: PWSTR,
    // TODO: what to do with BytesParamIndex 5?
    Data: *u8,
    DataLen: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WinSCard" fn SCardWriteCacheA(
    hContext: usize,
    CardIdentifier: *Guid,
    FreshnessCounter: u32,
    LookupName: PSTR,
    // TODO: what to do with BytesParamIndex 5?
    Data: *u8,
    DataLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WinSCard" fn SCardWriteCacheW(
    hContext: usize,
    CardIdentifier: *Guid,
    FreshnessCounter: u32,
    LookupName: PWSTR,
    // TODO: what to do with BytesParamIndex 5?
    Data: *u8,
    DataLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetReaderIconA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbIcon: ?*u8,
    pcbIcon: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetReaderIconW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbIcon: ?*u8,
    pcbIcon: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetDeviceTypeIdA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    pdwDeviceTypeId: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetDeviceTypeIdW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    pdwDeviceTypeId: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetReaderDeviceInstanceIdA(
    hContext: usize,
    szReaderName: [*:0]const u8,
    szDeviceInstanceId: ?PSTR,
    pcchDeviceInstanceId: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardGetReaderDeviceInstanceIdW(
    hContext: usize,
    szReaderName: [*:0]const u16,
    szDeviceInstanceId: ?PWSTR,
    pcchDeviceInstanceId: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardListReadersWithDeviceInstanceIdA(
    hContext: usize,
    szDeviceInstanceId: [*:0]const u8,
    mszReaders: ?PSTR,
    pcchReaders: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardListReadersWithDeviceInstanceIdW(
    hContext: usize,
    szDeviceInstanceId: [*:0]const u16,
    mszReaders: ?PWSTR,
    pcchReaders: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WinSCard" fn SCardAudit(
    hContext: usize,
    dwEvent: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstGetTrustAnchors(
    pTargetName: *UNICODE_STRING,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    ppTrustedIssuers: **SecPkgContext_IssuerListInfoEx,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "certpoleng" fn PstGetTrustAnchorsEx(
    pTargetName: *UNICODE_STRING,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    pCertContext: ?*CERT_CONTEXT,
    ppTrustedIssuers: **SecPkgContext_IssuerListInfoEx,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "certpoleng" fn PstGetCertificateChain(
    pCert: *CERT_CONTEXT,
    pTrustedIssuers: *SecPkgContext_IssuerListInfoEx,
    ppCertChainContext: **CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstGetCertificates(
    pTargetName: *UNICODE_STRING,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    bIsClient: BOOL,
    pdwCertChainContextCount: *u32,
    ppCertChainContexts: ***CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstAcquirePrivateKey(
    pCert: *CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstValidate(
    pTargetName: ?*UNICODE_STRING,
    bIsClient: BOOL,
    pRequestedIssuancePolicy: ?*CERT_USAGE_MATCH,
    phAdditionalCertStore: ?*?*c_void,
    pCert: *CERT_CONTEXT,
    pProvGUID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstMapCertificate(
    pCert: *CERT_CONTEXT,
    pTokenInformationType: *LSA_TOKEN_INFORMATION_TYPE,
    ppTokenInformation: **c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "certpoleng" fn PstGetUserNameForCertificate(
    pCertContext: *CERT_CONTEXT,
    UserName: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SAS" fn SendSAS(
    AsUser: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzAccessCheck(
    Flags: AUTHZ_ACCESS_CHECK_FLAGS,
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pRequest: *AUTHZ_ACCESS_REQUEST,
    hAuditEvent: AUTHZ_AUDIT_EVENT_HANDLE,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    OptionalSecurityDescriptorArray: ?[*]?*SECURITY_DESCRIPTOR,
    OptionalSecurityDescriptorCount: u32,
    pReply: *AUTHZ_ACCESS_REPLY,
    phAccessCheckResults: ?*isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzCachedAccessCheck(
    Flags: u32,
    hAccessCheckResults: AUTHZ_ACCESS_CHECK_RESULTS_HANDLE,
    pRequest: *AUTHZ_ACCESS_REQUEST,
    hAuditEvent: AUTHZ_AUDIT_EVENT_HANDLE,
    pReply: *AUTHZ_ACCESS_REPLY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzOpenObjectAudit(
    Flags: u32,
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pRequest: *AUTHZ_ACCESS_REQUEST,
    hAuditEvent: AUTHZ_AUDIT_EVENT_HANDLE,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    OptionalSecurityDescriptorArray: ?[*]?*SECURITY_DESCRIPTOR,
    OptionalSecurityDescriptorCount: u32,
    pReply: *AUTHZ_ACCESS_REPLY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzFreeHandle(
    hAccessCheckResults: AUTHZ_ACCESS_CHECK_RESULTS_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzInitializeResourceManager(
    Flags: u32,
    pfnDynamicAccessCheck: ?PFN_AUTHZ_DYNAMIC_ACCESS_CHECK,
    pfnComputeDynamicGroups: ?PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS,
    pfnFreeDynamicGroups: ?PFN_AUTHZ_FREE_DYNAMIC_GROUPS,
    szResourceManagerName: ?[*:0]const u16,
    phAuthzResourceManager: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzInitializeResourceManagerEx(
    Flags: AUTHZ_RESOURCE_MANAGER_FLAGS,
    pAuthzInitInfo: ?*AUTHZ_INIT_INFO,
    phAuthzResourceManager: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzInitializeRemoteResourceManager(
    pRpcInitInfo: *AUTHZ_RPC_INIT_INFO_CLIENT,
    phAuthzResourceManager: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzFreeResourceManager(
    hAuthzResourceManager: AUTHZ_RESOURCE_MANAGER_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzInitializeContextFromToken(
    Flags: u32,
    TokenHandle: HANDLE,
    hAuthzResourceManager: AUTHZ_RESOURCE_MANAGER_HANDLE,
    pExpirationTime: ?*LARGE_INTEGER,
    Identifier: LUID,
    DynamicGroupArgs: ?*c_void,
    phAuthzClientContext: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzInitializeContextFromSid(
    Flags: u32,
    UserSid: PSID,
    hAuthzResourceManager: AUTHZ_RESOURCE_MANAGER_HANDLE,
    pExpirationTime: ?*LARGE_INTEGER,
    Identifier: LUID,
    DynamicGroupArgs: ?*c_void,
    phAuthzClientContext: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzInitializeContextFromAuthzContext(
    Flags: u32,
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pExpirationTime: ?*LARGE_INTEGER,
    Identifier: LUID,
    DynamicGroupArgs: *c_void,
    phNewAuthzClientContext: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzInitializeCompoundContext(
    UserContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    DeviceContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    phCompoundContext: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzAddSidsToContext(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    Sids: ?*SID_AND_ATTRIBUTES,
    SidCount: u32,
    RestrictedSids: ?*SID_AND_ATTRIBUTES,
    RestrictedSidCount: u32,
    phNewAuthzClientContext: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "AUTHZ" fn AuthzModifySecurityAttributes(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pOperations: *AUTHZ_SECURITY_ATTRIBUTE_OPERATION,
    pAttributes: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzModifyClaims(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    ClaimClass: AUTHZ_CONTEXT_INFORMATION_CLASS,
    pClaimOperations: *AUTHZ_SECURITY_ATTRIBUTE_OPERATION,
    pClaims: ?*AUTHZ_SECURITY_ATTRIBUTES_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzModifySids(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    SidClass: AUTHZ_CONTEXT_INFORMATION_CLASS,
    pSidOperations: *AUTHZ_SID_OPERATION,
    pSids: ?*TOKEN_GROUPS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzSetAppContainerInformation(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pAppContainerSid: PSID,
    CapabilityCount: u32,
    pCapabilitySids: ?[*]SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzGetInformationFromContext(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    InfoClass: AUTHZ_CONTEXT_INFORMATION_CLASS,
    BufferSize: u32,
    pSizeRequired: *u32,
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzFreeContext(
    hAuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzInitializeObjectAccessAuditEvent(
    Flags: AUTHZ_INITIALIZE_OBJECT_ACCESS_AUDIT_EVENT_FLAGS,
    hAuditEventType: AUTHZ_AUDIT_EVENT_TYPE_HANDLE,
    szOperationType: PWSTR,
    szObjectType: PWSTR,
    szObjectName: PWSTR,
    szAdditionalInfo: PWSTR,
    phAuditEvent: *isize,
    dwAdditionalParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzInitializeObjectAccessAuditEvent2(
    Flags: u32,
    hAuditEventType: AUTHZ_AUDIT_EVENT_TYPE_HANDLE,
    szOperationType: PWSTR,
    szObjectType: PWSTR,
    szObjectName: PWSTR,
    szAdditionalInfo: PWSTR,
    szAdditionalInfo2: PWSTR,
    phAuditEvent: *isize,
    dwAdditionalParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "AUTHZ" fn AuthzFreeAuditEvent(
    hAuditEvent: AUTHZ_AUDIT_EVENT_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "AUTHZ" fn AuthzEvaluateSacl(
    AuthzClientContext: AUTHZ_CLIENT_CONTEXT_HANDLE,
    pRequest: *AUTHZ_ACCESS_REQUEST,
    Sacl: *ACL,
    GrantedAccess: u32,
    AccessGranted: BOOL,
    pbGenerateAudit: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzInstallSecurityEventSource(
    dwFlags: u32,
    pRegistration: *AUTHZ_SOURCE_SCHEMA_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzUninstallSecurityEventSource(
    dwFlags: u32,
    szEventSourceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzEnumerateSecurityEventSources(
    dwFlags: u32,
    Buffer: *AUTHZ_SOURCE_SCHEMA_REGISTRATION,
    pdwCount: *u32,
    pdwLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzRegisterSecurityEventSource(
    dwFlags: u32,
    szEventSourceName: [*:0]const u16,
    phEventProvider: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzUnregisterSecurityEventSource(
    dwFlags: u32,
    phEventProvider: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzReportSecurityEvent(
    dwFlags: u32,
    hEventProvider: AUTHZ_SECURITY_EVENT_PROVIDER_HANDLE,
    dwAuditId: u32,
    pUserSid: PSID,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "AUTHZ" fn AuthzReportSecurityEventFromParams(
    dwFlags: u32,
    hEventProvider: AUTHZ_SECURITY_EVENT_PROVIDER_HANDLE,
    dwAuditId: u32,
    pUserSid: PSID,
    pParams: *AUDIT_PARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzRegisterCapChangeNotification(
    phCapChangeSubscription: **AUTHZ_CAP_CHANGE_SUBSCRIPTION_HANDLE__,
    pfnCapChangeCallback: LPTHREAD_START_ROUTINE,
    pCallbackContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzUnregisterCapChangeNotification(
    hCapChangeSubscription: *AUTHZ_CAP_CHANGE_SUBSCRIPTION_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "AUTHZ" fn AuthzFreeCentralAccessPolicyCache(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ACLUI" fn CreateSecurityPage(
    psi: *ISecurityInformation,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ACLUI" fn EditSecurity(
    hwndOwner: HWND,
    psi: *ISecurityInformation,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ACLUI" fn EditSecurityAdvanced(
    hwndOwner: HWND,
    psi: *ISecurityInformation,
    uSIPage: SI_PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetEntriesInAclA(
    cCountOfExplicitEntries: u32,
    pListOfExplicitEntries: ?[*]EXPLICIT_ACCESS_A,
    OldAcl: ?*ACL,
    NewAcl: **ACL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetEntriesInAclW(
    cCountOfExplicitEntries: u32,
    pListOfExplicitEntries: ?[*]EXPLICIT_ACCESS_W,
    OldAcl: ?*ACL,
    NewAcl: **ACL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetExplicitEntriesFromAclA(
    pacl: *ACL,
    pcCountOfExplicitEntries: *u32,
    pListOfExplicitEntries: **EXPLICIT_ACCESS_A,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetExplicitEntriesFromAclW(
    pacl: *ACL,
    pcCountOfExplicitEntries: *u32,
    pListOfExplicitEntries: **EXPLICIT_ACCESS_W,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetEffectiveRightsFromAclA(
    pacl: *ACL,
    pTrustee: *TRUSTEE_A,
    pAccessRights: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetEffectiveRightsFromAclW(
    pacl: *ACL,
    pTrustee: *TRUSTEE_W,
    pAccessRights: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAuditedPermissionsFromAclA(
    pacl: *ACL,
    pTrustee: *TRUSTEE_A,
    pSuccessfulAuditedRights: *u32,
    pFailedAuditRights: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAuditedPermissionsFromAclW(
    pacl: *ACL,
    pTrustee: *TRUSTEE_W,
    pSuccessfulAuditedRights: *u32,
    pFailedAuditRights: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetNamedSecurityInfoA(
    pObjectName: [*:0]const u8,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    ppsidOwner: ?*PSID,
    ppsidGroup: ?*PSID,
    ppDacl: ?*?*ACL,
    ppSacl: ?*?*ACL,
    ppSecurityDescriptor: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetNamedSecurityInfoW(
    pObjectName: [*:0]const u16,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    ppsidOwner: ?*PSID,
    ppsidGroup: ?*PSID,
    ppDacl: ?*?*ACL,
    ppSacl: ?*?*ACL,
    ppSecurityDescriptor: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityInfo(
    handle: HANDLE,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    ppsidOwner: ?*PSID,
    ppsidGroup: ?*PSID,
    ppDacl: ?*?*ACL,
    ppSacl: ?*?*ACL,
    ppSecurityDescriptor: ?*?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetNamedSecurityInfoA(
    pObjectName: PSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    psidOwner: PSID,
    psidGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetNamedSecurityInfoW(
    pObjectName: PWSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    psidOwner: PSID,
    psidGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityInfo(
    handle: HANDLE,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    psidOwner: PSID,
    psidGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetInheritanceSourceA(
    pObjectName: PSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    Container: BOOL,
    pObjectClassGuids: ?[*]?*Guid,
    GuidCount: u32,
    pAcl: *ACL,
    pfnArray: ?*FN_OBJECT_MGR_FUNCTIONS,
    pGenericMapping: *GENERIC_MAPPING,
    pInheritArray: *INHERITED_FROMA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetInheritanceSourceW(
    pObjectName: PWSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    Container: BOOL,
    pObjectClassGuids: ?[*]?*Guid,
    GuidCount: u32,
    pAcl: *ACL,
    pfnArray: ?*FN_OBJECT_MGR_FUNCTIONS,
    pGenericMapping: *GENERIC_MAPPING,
    pInheritArray: *INHERITED_FROMW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FreeInheritedFromArray(
    pInheritArray: [*]INHERITED_FROMW,
    AceCnt: u16,
    pfnArray: ?*FN_OBJECT_MGR_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn TreeResetNamedSecurityInfoA(
    pObjectName: PSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    pOwner: PSID,
    pGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
    KeepExplicit: BOOL,
    fnProgress: ?FN_PROGRESS,
    ProgressInvokeSetting: PROG_INVOKE_SETTING,
    Args: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn TreeResetNamedSecurityInfoW(
    pObjectName: PWSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    pOwner: PSID,
    pGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
    KeepExplicit: BOOL,
    fnProgress: ?FN_PROGRESS,
    ProgressInvokeSetting: PROG_INVOKE_SETTING,
    Args: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn TreeSetNamedSecurityInfoA(
    pObjectName: PSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    pOwner: PSID,
    pGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
    dwAction: TREE_SEC_INFO,
    fnProgress: ?FN_PROGRESS,
    ProgressInvokeSetting: PROG_INVOKE_SETTING,
    Args: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn TreeSetNamedSecurityInfoW(
    pObjectName: PWSTR,
    ObjectType: SE_OBJECT_TYPE,
    SecurityInfo: u32,
    pOwner: PSID,
    pGroup: PSID,
    pDacl: ?*ACL,
    pSacl: ?*ACL,
    dwAction: TREE_SEC_INFO,
    fnProgress: ?FN_PROGRESS,
    ProgressInvokeSetting: PROG_INVOKE_SETTING,
    Args: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildSecurityDescriptorA(
    pOwner: ?*TRUSTEE_A,
    pGroup: ?*TRUSTEE_A,
    cCountOfAccessEntries: u32,
    pListOfAccessEntries: ?[*]EXPLICIT_ACCESS_A,
    cCountOfAuditEntries: u32,
    pListOfAuditEntries: ?[*]EXPLICIT_ACCESS_A,
    pOldSD: ?*SECURITY_DESCRIPTOR,
    pSizeNewSD: *u32,
    pNewSD: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildSecurityDescriptorW(
    pOwner: ?*TRUSTEE_W,
    pGroup: ?*TRUSTEE_W,
    cCountOfAccessEntries: u32,
    pListOfAccessEntries: ?[*]EXPLICIT_ACCESS_W,
    cCountOfAuditEntries: u32,
    pListOfAuditEntries: ?[*]EXPLICIT_ACCESS_W,
    pOldSD: ?*SECURITY_DESCRIPTOR,
    pSizeNewSD: *u32,
    pNewSD: **SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupSecurityDescriptorPartsA(
    ppOwner: ?*?*TRUSTEE_A,
    ppGroup: ?*?*TRUSTEE_A,
    pcCountOfAccessEntries: ?*u32,
    ppListOfAccessEntries: ?*?*EXPLICIT_ACCESS_A,
    pcCountOfAuditEntries: ?*u32,
    ppListOfAuditEntries: ?*?*EXPLICIT_ACCESS_A,
    pSD: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupSecurityDescriptorPartsW(
    ppOwner: ?*?*TRUSTEE_W,
    ppGroup: ?*?*TRUSTEE_W,
    pcCountOfAccessEntries: ?*u32,
    ppListOfAccessEntries: ?*?*EXPLICIT_ACCESS_W,
    pcCountOfAuditEntries: ?*u32,
    ppListOfAuditEntries: ?*?*EXPLICIT_ACCESS_W,
    pSD: *SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildExplicitAccessWithNameA(
    pExplicitAccess: *EXPLICIT_ACCESS_A,
    pTrusteeName: ?PSTR,
    AccessPermissions: u32,
    AccessMode: ACCESS_MODE,
    Inheritance: ACE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildExplicitAccessWithNameW(
    pExplicitAccess: *EXPLICIT_ACCESS_W,
    pTrusteeName: ?PWSTR,
    AccessPermissions: u32,
    AccessMode: ACCESS_MODE,
    Inheritance: ACE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn BuildImpersonateExplicitAccessWithNameA(
    pExplicitAccess: *EXPLICIT_ACCESS_A,
    pTrusteeName: ?PSTR,
    pTrustee: ?*TRUSTEE_A,
    AccessPermissions: u32,
    AccessMode: ACCESS_MODE,
    Inheritance: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn BuildImpersonateExplicitAccessWithNameW(
    pExplicitAccess: *EXPLICIT_ACCESS_W,
    pTrusteeName: ?PWSTR,
    pTrustee: ?*TRUSTEE_W,
    AccessPermissions: u32,
    AccessMode: ACCESS_MODE,
    Inheritance: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithNameA(
    pTrustee: *TRUSTEE_A,
    pName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithNameW(
    pTrustee: *TRUSTEE_W,
    pName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn BuildImpersonateTrusteeA(
    pTrustee: *TRUSTEE_A,
    pImpersonateTrustee: ?*TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn BuildImpersonateTrusteeW(
    pTrustee: *TRUSTEE_W,
    pImpersonateTrustee: ?*TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithSidA(
    pTrustee: *TRUSTEE_A,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithSidW(
    pTrustee: *TRUSTEE_W,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithObjectsAndSidA(
    pTrustee: *TRUSTEE_A,
    pObjSid: ?*OBJECTS_AND_SID,
    pObjectGuid: ?*Guid,
    pInheritedObjectGuid: ?*Guid,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithObjectsAndSidW(
    pTrustee: *TRUSTEE_W,
    pObjSid: ?*OBJECTS_AND_SID,
    pObjectGuid: ?*Guid,
    pInheritedObjectGuid: ?*Guid,
    pSid: PSID,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithObjectsAndNameA(
    pTrustee: *TRUSTEE_A,
    pObjName: ?*OBJECTS_AND_NAME_A,
    ObjectType: SE_OBJECT_TYPE,
    ObjectTypeName: ?PSTR,
    InheritedObjectTypeName: ?PSTR,
    Name: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn BuildTrusteeWithObjectsAndNameW(
    pTrustee: *TRUSTEE_W,
    pObjName: ?*OBJECTS_AND_NAME_W,
    ObjectType: SE_OBJECT_TYPE,
    ObjectTypeName: ?PWSTR,
    InheritedObjectTypeName: ?PWSTR,
    Name: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeNameA(
    pTrustee: *TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeNameW(
    pTrustee: *TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeTypeA(
    pTrustee: ?*TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) TRUSTEE_TYPE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeTypeW(
    pTrustee: ?*TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) TRUSTEE_TYPE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeFormA(
    pTrustee: *TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) TRUSTEE_FORM;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTrusteeFormW(
    pTrustee: *TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) TRUSTEE_FORM;

pub extern "ADVAPI32" fn GetMultipleTrusteeOperationA(
    pTrustee: ?*TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) MULTIPLE_TRUSTEE_OPERATION;

pub extern "ADVAPI32" fn GetMultipleTrusteeOperationW(
    pTrustee: ?*TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) MULTIPLE_TRUSTEE_OPERATION;

pub extern "ADVAPI32" fn GetMultipleTrusteeA(
    pTrustee: ?*TRUSTEE_A,
) callconv(@import("std").os.windows.WINAPI) *TRUSTEE_A;

pub extern "ADVAPI32" fn GetMultipleTrusteeW(
    pTrustee: ?*TRUSTEE_W,
) callconv(@import("std").os.windows.WINAPI) *TRUSTEE_W;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertSidToStringSidA(
    Sid: PSID,
    StringSid: *PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertSidToStringSidW(
    Sid: PSID,
    StringSid: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertStringSidToSidA(
    StringSid: [*:0]const u8,
    Sid: *PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertStringSidToSidW(
    StringSid: [*:0]const u16,
    Sid: *PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertStringSecurityDescriptorToSecurityDescriptorA(
    StringSecurityDescriptor: [*:0]const u8,
    StringSDRevision: u32,
    SecurityDescriptor: **SECURITY_DESCRIPTOR,
    SecurityDescriptorSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertStringSecurityDescriptorToSecurityDescriptorW(
    StringSecurityDescriptor: [*:0]const u16,
    StringSDRevision: u32,
    SecurityDescriptor: **SECURITY_DESCRIPTOR,
    SecurityDescriptorSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertSecurityDescriptorToStringSecurityDescriptorA(
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    RequestedStringSDRevision: u32,
    SecurityInformation: u32,
    StringSecurityDescriptor: *PSTR,
    StringSecurityDescriptorLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertSecurityDescriptorToStringSecurityDescriptorW(
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
    RequestedStringSDRevision: u32,
    SecurityInformation: u32,
    StringSecurityDescriptor: *PWSTR,
    StringSecurityDescriptorLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSCreateISecurityInfoObject(
    pwszObjectPath: [*:0]const u16,
    pwszObjectClass: [*:0]const u16,
    dwFlags: u32,
    ppSI: **ISecurityInformation,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSCreateISecurityInfoObjectEx(
    pwszObjectPath: [*:0]const u16,
    pwszObjectClass: [*:0]const u16,
    pwszServer: [*:0]const u16,
    pwszUserName: [*:0]const u16,
    pwszPassword: [*:0]const u16,
    dwFlags: u32,
    ppSI: **ISecurityInformation,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "DSSEC" fn DSCreateSecurityPage(
    pwszObjectPath: [*:0]const u16,
    pwszObjectClass: [*:0]const u16,
    dwFlags: u32,
    phPage: *HPROPSHEETPAGE,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSEditSecurity(
    hwndOwner: HWND,
    pwszObjectPath: [*:0]const u16,
    pwszObjectClass: [*:0]const u16,
    dwFlags: u32,
    pwszCaption: [*:0]const u16,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvIsServerOnlineW(
    pwszServerName: [*:0]const u16,
    pfServerOnline: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupGetDynamicFileListW(
    hbc: *c_void,
    ppwszzFileList: *PWSTR,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupPrepareW(
    pwszServerName: [*:0]const u16,
    grbitJet: u32,
    dwBackupFlags: CSBACKUP_TYPE,
    phbc: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupGetDatabaseNamesW(
    hbc: *c_void,
    ppwszzAttachmentInformation: *PWSTR,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupOpenFileW(
    hbc: *c_void,
    pwszAttachmentName: [*:0]const u16,
    cbReadHintSize: u32,
    pliFileSize: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupRead(
    hbc: *c_void,
    pvBuffer: *c_void,
    cbBuffer: u32,
    pcbRead: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupClose(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupGetBackupLogsW(
    hbc: *c_void,
    ppwszzBackupLogFiles: *PWSTR,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupTruncateLogs(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupEnd(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvBackupFree(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestoreGetDatabaseLocationsW(
    hbc: *c_void,
    ppwszzDatabaseLocationList: *PWSTR,
    pcbSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestorePrepareW(
    pwszServerName: [*:0]const u16,
    dwRestoreFlags: u32,
    phbc: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestoreRegisterW(
    hbc: *c_void,
    pwszCheckPointFilePath: [*:0]const u16,
    pwszLogPath: [*:0]const u16,
    rgrstmap: *CSEDB_RSTMAPW,
    crstmap: i32,
    pwszBackupLogPath: [*:0]const u16,
    genLow: u32,
    genHigh: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestoreRegisterThroughFile(
    hbc: *c_void,
    pwszCheckPointFilePath: [*:0]const u16,
    pwszLogPath: [*:0]const u16,
    rgrstmap: *CSEDB_RSTMAPW,
    crstmap: i32,
    pwszBackupLogPath: [*:0]const u16,
    genLow: u32,
    genHigh: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestoreRegisterComplete(
    hbc: *c_void,
    hrRestoreState: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvRestoreEnd(
    hbc: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "certadm" fn CertSrvServerControlW(
    pwszServerName: [*:0]const u16,
    dwControlFlags: u32,
    pcbOut: *u32,
    ppbOut: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptRegisterProtectionDescriptorName(
    pwszName: [*:0]const u16,
    pwszDescriptorString: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptQueryProtectionDescriptorName(
    pwszName: [*:0]const u16,
    pwszDescriptorString: ?[*:0]u16,
    pcDescriptorString: *usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCreateProtectionDescriptor(
    pwszDescriptorString: [*:0]const u16,
    dwFlags: u32,
    phDescriptor: *NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCloseProtectionDescriptor(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptGetProtectionDescriptorInfo(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    dwInfoType: u32,
    ppvInfo: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptProtectSecret(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: *const u8,
    cbData: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: HWND,
    ppbProtectedBlob: **u8,
    pcbProtectedBlob: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptUnprotectSecret(
    phDescriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: NCRYPT_FLAGS,
    // TODO: what to do with BytesParamIndex 3?
    pbProtectedBlob: *const u8,
    cbProtectedBlob: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: HWND,
    ppbData: **u8,
    pcbData: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToProtect(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    hWnd: HWND,
    pStreamInfo: *NCRYPT_PROTECT_STREAM_INFO,
    phStream: *NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToUnprotect(
    pStreamInfo: *NCRYPT_PROTECT_STREAM_INFO,
    dwFlags: u32,
    hWnd: HWND,
    phStream: *NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ncrypt" fn NCryptStreamOpenToUnprotectEx(
    pStreamInfo: *NCRYPT_PROTECT_STREAM_INFO_EX,
    dwFlags: u32,
    hWnd: HWND,
    phStream: *NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamUpdate(
    hStream: NCRYPT_STREAM_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbData: *const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamClose(
    hStream: NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingGenerateBinding(
    keyType: TOKENBINDING_KEY_PARAMETERS_TYPE,
    targetURL: [*:0]const u16,
    bindingType: TOKENBINDING_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    tlsEKM: *const c_void,
    tlsEKMSize: u32,
    extensionFormat: TOKENBINDING_EXTENSION_FORMAT,
    extensionData: *const c_void,
    tokenBinding: **c_void,
    tokenBindingSize: *u32,
    resultData: ?*?*TOKENBINDING_RESULT_DATA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingGenerateMessage(
    tokenBindings: [*]const *const c_void,
    tokenBindingsSize: [*]const u32,
    tokenBindingsCount: u32,
    tokenBindingMessage: **c_void,
    tokenBindingMessageSize: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingVerifyMessage(
    // TODO: what to do with BytesParamIndex 1?
    tokenBindingMessage: *const c_void,
    tokenBindingMessageSize: u32,
    keyType: TOKENBINDING_KEY_PARAMETERS_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    tlsEKM: *const c_void,
    tlsEKMSize: u32,
    resultList: **TOKENBINDING_RESULT_LIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingGetKeyTypesClient(
    keyTypes: **TOKENBINDING_KEY_TYPES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingGetKeyTypesServer(
    keyTypes: **TOKENBINDING_KEY_TYPES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingDeleteBinding(
    targetURL: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingDeleteAllBindings(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "TOKENBINDING" fn TokenBindingGenerateID(
    keyType: TOKENBINDING_KEY_PARAMETERS_TYPE,
    // TODO: what to do with BytesParamIndex 2?
    publicKey: *const c_void,
    publicKeySize: u32,
    resultData: **TOKENBINDING_RESULT_DATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "TOKENBINDING" fn TokenBindingGenerateIDForUri(
    keyType: TOKENBINDING_KEY_PARAMETERS_TYPE,
    targetUri: [*:0]const u16,
    resultData: **TOKENBINDING_RESULT_DATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "TOKENBINDING" fn TokenBindingGetHighestSupportedVersion(
    majorVersion: *u8,
    minorVersion: *u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlClose(
    hCryptXml: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetTransforms(
    ppConfig: *const *const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlOpenToEncode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    wszId: ?[*:0]const u16,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    phSignature: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlOpenToDecode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: *const CRYPT_XML_BLOB,
    phCryptXml: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlAddObject(
    hSignatureOrObject: *c_void,
    dwFlags: u32,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: *const CRYPT_XML_BLOB,
    ppObject: ?*const ?*const CRYPT_XML_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlCreateReference(
    hCryptXml: *c_void,
    dwFlags: u32,
    wszId: ?[*:0]const u16,
    wszURI: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    pDigestMethod: *const CRYPT_XML_ALGORITHM,
    cTransform: u32,
    rgTransform: ?[*]const CRYPT_XML_ALGORITHM,
    phReference: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlDigestReference(
    hReference: *c_void,
    dwFlags: u32,
    pDataProviderIn: *CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlSetHMACSecret(
    hSignature: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: *const u8,
    cbSecret: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlSign(
    hSignature: *c_void,
    hKey: usize,
    dwKeySpec: CERT_KEY_SPEC,
    dwFlags: CRYPT_XML_FLAGS,
    dwKeyInfoSpec: CRYPT_XML_KEYINFO_SPEC,
    pvKeyInfoSpec: ?*const c_void,
    pSignatureMethod: *const CRYPT_XML_ALGORITHM,
    pCanonicalization: *const CRYPT_XML_ALGORITHM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlImportPublicKey(
    dwFlags: CRYPT_XML_FLAGS,
    pKeyValue: *const CRYPT_XML_KEY_VALUE,
    phKey: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlVerifySignature(
    hSignature: *c_void,
    hKey: ?*c_void,
    dwFlags: CRYPT_XML_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetDocContext(
    hCryptXml: *c_void,
    ppStruct: *const *const CRYPT_XML_DOC_CTXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetSignature(
    hCryptXml: *c_void,
    ppStruct: *const *const CRYPT_XML_SIGNATURE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetReference(
    hCryptXml: *c_void,
    ppStruct: *const *const CRYPT_XML_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetStatus(
    hCryptXml: *c_void,
    pStatus: *CRYPT_XML_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlEncode(
    hCryptXml: *c_void,
    dwCharset: CRYPT_XML_CHARSET,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pvCallbackState: *c_void,
    pfnWrite: PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetAlgorithmInfo(
    pXmlAlgorithm: *const CRYPT_XML_ALGORITHM,
    dwFlags: CRYPT_XML_FLAGS,
    ppAlgInfo: **CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "CRYPTXML" fn CryptXmlFindAlgorithmInfo(
    dwFindByType: u32,
    pvFindBy: *const c_void,
    dwGroupId: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_XML_ALGORITHM_INFO;

pub extern "CRYPTXML" fn CryptXmlEnumAlgorithmInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*c_void,
    pfnEnumAlgInfo: PFN_CRYPT_XML_ENUM_ALG_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WinVerifyTrust(
    hwnd: HWND,
    pgActionID: *Guid,
    pWVTData: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WinVerifyTrustEx(
    hwnd: HWND,
    pgActionID: *Guid,
    pWinTrustData: *WINTRUST_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustGetRegPolicyFlags(
    pdwPolicyFlags: *WINTRUST_POLICY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustSetRegPolicyFlags(
    dwPolicyFlags: WINTRUST_POLICY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustAddActionID(
    pgActionID: *Guid,
    fdwFlags: u32,
    psProvInfo: *CRYPT_REGISTER_ACTIONID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustRemoveActionID(
    pgActionID: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustLoadFunctionPointers(
    pgActionID: *Guid,
    pPfns: *CRYPT_PROVIDER_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustAddDefaultForUsage(
    pszUsageOID: [*:0]const u8,
    psDefUsage: *CRYPT_PROVIDER_REGDEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustGetDefaultForUsage(
    dwAction: WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION,
    pszUsageOID: [*:0]const u8,
    psUsage: *CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvSignerFromChain(
    pProvData: *CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_PROVIDER_SGNR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvCertFromChain(
    pSgnr: *CRYPT_PROVIDER_SGNR,
    idxCert: u32,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_PROVIDER_CERT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperProvDataFromStateData(
    hStateData: HANDLE,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_PROVIDER_DATA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvPrivateDataFromChain(
    pProvData: *CRYPT_PROVIDER_DATA,
    pgProviderID: *Guid,
) callconv(@import("std").os.windows.WINAPI) *CRYPT_PROVIDER_PRIVDATA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperCertIsSelfSigned(
    dwEncoding: u32,
    pCert: *CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WINTRUST" fn WTHelperCertCheckValidSignature(
    pProvData: *CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn OpenPersonalTrustDBDialogEx(
    hwndParent: HWND,
    dwFlags: u32,
    pvReserved: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn OpenPersonalTrustDBDialog(
    hwndParent: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WINTRUST" fn WintrustSetDefaultIncludePEPageHashes(
    fIncludePEPageHashes: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIDlgViewContext(
    dwContextType: u32,
    pvContext: *const c_void,
    hwnd: HWND,
    pwszTitle: ?[*:0]const u16,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIDlgSelectCertificateFromStore(
    hCertStore: *c_void,
    hwnd: HWND,
    pwszTitle: ?[*:0]const u16,
    pwszDisplayString: ?[*:0]const u16,
    dwDontUseColumn: u32,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) *CERT_CONTEXT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTUI" fn CertSelectionGetSerializedBlob(
    pcsi: *CERT_SELECTUI_INPUT,
    ppOutBuffer: ?*?*c_void,
    pulOutBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIDlgCertMgr(
    pCryptUICertMgr: *CRYPTUI_CERT_MGR_STRUCT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIWizDigitalSign(
    dwFlags: u32,
    hwndParent: HWND,
    pwszWizardTitle: ?[*:0]const u16,
    pDigitalSignInfo: *CRYPTUI_WIZ_DIGITAL_SIGN_INFO,
    ppSignContext: ?*?*CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIWizFreeDigitalSignContext(
    pSignContext: *CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIDlgViewCertificateW(
    pCertViewInfo: *CRYPTUI_VIEWCERTIFICATE_STRUCTW,
    pfPropertiesChanged: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIDlgViewCertificateA(
    pCertViewInfo: *CRYPTUI_VIEWCERTIFICATE_STRUCTA,
    pfPropertiesChanged: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIWizExport(
    dwFlags: CRYPTUI_WIZ_FLAGS,
    hwndParent: HWND,
    pwszWizardTitle: ?[*:0]const u16,
    pExportInfo: *CRYPTUI_WIZ_EXPORT_INFO,
    pvoid: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTUI" fn CryptUIWizImport(
    dwFlags: CRYPTUI_WIZ_FLAGS,
    hwndParent: HWND,
    pwszWizardTitle: ?[*:0]const u16,
    pImportSrc: ?*CRYPTUI_WIZ_IMPORT_SRC_INFO,
    hDestCertStore: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPGetSignedDataMsg(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pdwEncodingType: *CERT_QUERY_ENCODING_TYPE,
    dwIndex: u32,
    pcbSignedDataMsg: *u32,
    pbSignedDataMsg: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPPutSignedDataMsg(
    pSubjectInfo: *SIP_SUBJECTINFO,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    pdwIndex: *u32,
    cbSignedDataMsg: u32,
    pbSignedDataMsg: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPCreateIndirectData(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pcbIndirectData: *u32,
    pIndirectData: *SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPVerifyIndirectData(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pIndirectData: *SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRemoveSignedDataMsg(
    pSubjectInfo: *SIP_SUBJECTINFO,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPLoad(
    pgSubject: *const Guid,
    dwFlags: u32,
    pSipDispatch: *SIP_DISPATCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRetrieveSubjectGuid(
    FileName: [*:0]const u16,
    hFileIn: HANDLE,
    pgSubject: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRetrieveSubjectGuidForCatalogFile(
    FileName: [*:0]const u16,
    hFileIn: HANDLE,
    pgSubject: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPAddProvider(
    psNewProv: *SIP_ADD_NEWPROVIDER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRemoveProvider(
    pgProv: *Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "CRYPT32" fn CryptSIPGetCaps(
    pSubjInfo: *SIP_SUBJECTINFO,
    pCaps: *SIP_CAP_SET_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptSIPGetSealedDigest(
    pSubjectInfo: *SIP_SUBJECTINFO,
    pSig: ?[*:0]const u8,
    dwSig: u32,
    pbDigest: ?[*:0]u8,
    pcbDigest: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATOpen(
    pwszFileName: PWSTR,
    fdwOpenFlags: CRYPTCAT_OPEN_FLAGS,
    hProv: usize,
    dwPublicVersion: CRYPTCAT_VERSION,
    dwEncodingType: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATClose(
    hCatalog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATStoreFromHandle(
    hCatalog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATHandleFromStore(
    pCatStore: *CRYPTCATSTORE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPersistStore(
    hCatalog: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn CryptCATGetCatAttrInfo(
    hCatalog: HANDLE,
    pwszReferenceTag: PWSTR,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutCatAttrInfo(
    hCatalog: HANDLE,
    pwszReferenceTag: PWSTR,
    dwAttrTypeAndAction: u32,
    cbData: u32,
    pbData: *u8,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateCatAttr(
    hCatalog: HANDLE,
    pPrevAttr: *CRYPTCATATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATGetMemberInfo(
    hCatalog: HANDLE,
    pwszReferenceTag: PWSTR,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATAllocSortedMemberInfo(
    hCatalog: HANDLE,
    pwszReferenceTag: PWSTR,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATFreeSortedMemberInfo(
    hCatalog: HANDLE,
    pCatMember: *CRYPTCATMEMBER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATGetAttrInfo(
    hCatalog: HANDLE,
    pCatMember: *CRYPTCATMEMBER,
    pwszReferenceTag: PWSTR,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutMemberInfo(
    hCatalog: HANDLE,
    pwszFileName: ?PWSTR,
    pwszReferenceTag: PWSTR,
    pgSubjectType: *Guid,
    dwCertVersion: u32,
    cbSIPIndirectData: u32,
    pbSIPIndirectData: *u8,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATMEMBER;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutAttrInfo(
    hCatalog: HANDLE,
    pCatMember: *CRYPTCATMEMBER,
    pwszReferenceTag: PWSTR,
    dwAttrTypeAndAction: u32,
    cbData: u32,
    pbData: *u8,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateMember(
    hCatalog: HANDLE,
    pPrevMember: *CRYPTCATMEMBER,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATMEMBER;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateAttr(
    hCatalog: HANDLE,
    pCatMember: *CRYPTCATMEMBER,
    pPrevAttr: *CRYPTCATATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFOpen(
    pwszFilePath: PWSTR,
    pfnParseError: ?PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATCDF;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFClose(
    pCDF: *CRYPTCATCDF,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFEnumCatAttributes(
    pCDF: *CRYPTCATCDF,
    pPrevAttr: *CRYPTCATATTRIBUTE,
    pfnParseError: PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

pub extern "WINTRUST" fn CryptCATCDFEnumMembers(
    pCDF: *CRYPTCATCDF,
    pPrevMember: *CRYPTCATMEMBER,
    pfnParseError: PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATCDFEnumAttributes(
    pCDF: *CRYPTCATCDF,
    pMember: *CRYPTCATMEMBER,
    pPrevAttr: *CRYPTCATATTRIBUTE,
    pfnParseError: PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) *CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn IsCatalogFile(
    hFile: HANDLE,
    pwszFileName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminAcquireContext(
    phCatAdmin: *isize,
    pgSubsystem: ?*const Guid,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINTRUST" fn CryptCATAdminAcquireContext2(
    phCatAdmin: *isize,
    pgSubsystem: ?*const Guid,
    pwszHashAlgorithm: ?[*:0]const u16,
    pStrongHashPolicy: ?*CERT_STRONG_SIGN_PARA,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminReleaseContext(
    hCatAdmin: isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminReleaseCatalogContext(
    hCatAdmin: isize,
    hCatInfo: isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminEnumCatalogFromHash(
    hCatAdmin: isize,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: *u8,
    cbHash: u32,
    dwFlags: u32,
    phPrevCatInfo: ?*isize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminCalcHashFromFileHandle(
    hFile: HANDLE,
    pcbHash: *u32,
    // TODO: what to do with BytesParamIndex 1?
    pbHash: ?*u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINTRUST" fn CryptCATAdminCalcHashFromFileHandle2(
    hCatAdmin: isize,
    hFile: HANDLE,
    pcbHash: *u32,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminAddCatalog(
    hCatAdmin: isize,
    pwszCatalogFile: PWSTR,
    pwszSelectBaseName: ?PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminRemoveCatalog(
    hCatAdmin: isize,
    pwszCatalogFile: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCatalogInfoFromContext(
    hCatInfo: isize,
    psCatInfo: *CATALOG_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminResolveCatalogPath(
    hCatAdmin: isize,
    pwszCatalogFile: PWSTR,
    psCatInfo: *CATALOG_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn CryptCATAdminPauseServiceForBackup(
    dwFlags: u32,
    fResume: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferGetPolicyInformation(
    dwScopeId: u32,
    SaferPolicyInfoClass: SAFER_POLICY_INFO_CLASS,
    InfoBufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    InfoBuffer: *c_void,
    InfoBufferRetSize: *u32,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferSetPolicyInformation(
    dwScopeId: u32,
    SaferPolicyInfoClass: SAFER_POLICY_INFO_CLASS,
    InfoBufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    InfoBuffer: *c_void,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferCreateLevel(
    dwScopeId: u32,
    dwLevelId: u32,
    OpenFlags: u32,
    pLevelHandle: *SAFER_LEVEL_HANDLE,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferCloseLevel(
    hLevelHandle: SAFER_LEVEL_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferIdentifyLevel(
    dwNumProperties: u32,
    pCodeProperties: ?[*]SAFER_CODE_PROPERTIES_V2,
    pLevelHandle: *SAFER_LEVEL_HANDLE,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferComputeTokenFromLevel(
    LevelHandle: SAFER_LEVEL_HANDLE,
    InAccessToken: HANDLE,
    OutAccessToken: *HANDLE,
    dwFlags: SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferGetLevelInformation(
    LevelHandle: SAFER_LEVEL_HANDLE,
    dwInfoType: SAFER_OBJECT_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpQueryBuffer: ?*c_void,
    dwInBufferSize: u32,
    lpdwOutBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferSetLevelInformation(
    LevelHandle: SAFER_LEVEL_HANDLE,
    dwInfoType: SAFER_OBJECT_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpQueryBuffer: *c_void,
    dwInBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferRecordEventLogEntry(
    hLevel: SAFER_LEVEL_HANDLE,
    szTargetPath: [*:0]const u16,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferiIsExecutableFileType(
    szFullPathname: [*:0]const u16,
    bFromShellExecute: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLOpen(
    phSLC: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLClose(
    hSLC: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLInstallProofOfPurchase(
    hSLC: *c_void,
    pwszPKeyAlgorithm: [*:0]const u16,
    pwszPKeyString: [*:0]const u16,
    cbPKeySpecificData: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbPKeySpecificData: ?*u8,
    pPkeyId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLUninstallProofOfPurchase(
    hSLC: *c_void,
    pPKeyId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLInstallLicense(
    hSLC: *c_void,
    cbLicenseBlob: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbLicenseBlob: *const u8,
    pLicenseFileId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLUninstallLicense(
    hSLC: *c_void,
    pLicenseFileId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLConsumeRight(
    hSLC: *c_void,
    pAppId: *const Guid,
    pProductSkuId: ?*const Guid,
    pwszRightName: ?[*:0]const u16,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetProductSkuInformation(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetPKeyInformation(
    hSLC: *c_void,
    pPKeyId: *const Guid,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetLicenseInformation(
    hSLC: *c_void,
    pSLLicenseId: *const Guid,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetLicensingStatusInformation(
    hSLC: *c_void,
    pAppID: ?*const Guid,
    pProductSkuId: ?*const Guid,
    pwszRightName: ?[*:0]const u16,
    pnStatusCount: *u32,
    ppLicensingStatus: **SL_LICENSING_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetPolicyInformation(
    hSLC: *c_void,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetPolicyInformationDWORD(
    hSLC: *c_void,
    pwszValueName: [*:0]const u16,
    pdwValue: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetServiceInformation(
    hSLC: *c_void,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetApplicationInformation(
    hSLC: *c_void,
    pApplicationId: *const Guid,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "slcext" fn SLActivateProduct(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    cbAppSpecificData: u32,
    pvAppSpecificData: ?*const c_void,
    pActivationInfo: ?*const SL_ACTIVATION_INFO_HEADER,
    pwszProxyServer: ?[*:0]const u16,
    wProxyPort: u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "slcext" fn SLGetServerStatus(
    pwszServerURL: [*:0]const u16,
    pwszAcquisitionType: [*:0]const u16,
    pwszProxyServer: ?[*:0]const u16,
    wProxyPort: u16,
    phrStatus: *HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGenerateOfflineInstallationId(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    ppwszInstallationId: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGenerateOfflineInstallationIdEx(
    hSLC: *c_void,
    pProductSkuId: ?*const Guid,
    pActivationInfo: ?*const SL_ACTIVATION_INFO_HEADER,
    ppwszInstallationId: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLDepositOfflineConfirmationId(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    pwszInstallationId: [*:0]const u16,
    pwszConfirmationId: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLDepositOfflineConfirmationIdEx(
    hSLC: *c_void,
    pProductSkuId: ?*const Guid,
    pActivationInfo: ?*const SL_ACTIVATION_INFO_HEADER,
    pwszInstallationId: [*:0]const u16,
    pwszConfirmationId: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetPKeyId(
    hSLC: *c_void,
    pwszPKeyAlgorithm: [*:0]const u16,
    pwszPKeyString: [*:0]const u16,
    cbPKeySpecificData: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbPKeySpecificData: ?*const u8,
    pPKeyId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetInstalledProductKeyIds(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    pnProductKeyIds: *u32,
    ppProductKeyIds: **Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLSetCurrentProductKey(
    hSLC: *c_void,
    pProductSkuId: *const Guid,
    pProductKeyId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetSLIDList(
    hSLC: *c_void,
    eQueryIdType: SLIDTYPE,
    pQueryId: ?*const Guid,
    eReturnIdType: SLIDTYPE,
    pnReturnIds: *u32,
    ppReturnIds: **Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetLicenseFileId(
    hSLC: *c_void,
    cbLicenseBlob: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbLicenseBlob: *const u8,
    pLicenseFileId: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLGetLicense(
    hSLC: *c_void,
    pLicenseFileId: *const Guid,
    pcbLicenseFile: *u32,
    ppbLicenseFile: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLFireEvent(
    hSLC: *c_void,
    pwszEventId: [*:0]const u16,
    pApplicationId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLRegisterEvent(
    hSLC: ?*c_void,
    pwszEventId: [*:0]const u16,
    pApplicationId: *const Guid,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "SLC" fn SLUnregisterEvent(
    hSLC: ?*c_void,
    pwszEventId: [*:0]const u16,
    pApplicationId: *const Guid,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SLC" fn SLGetWindowsInformation(
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SLC" fn SLGetWindowsInformationDWORD(
    pwszValueName: [*:0]const u16,
    pdwValue: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SLWGA" fn SLIsGenuineLocal(
    pAppId: *const Guid,
    pGenuineState: *SL_GENUINE_STATE,
    pUIOptions: ?*SL_NONGENUINE_UI_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "slcext" fn SLAcquireGenuineTicket(
    ppTicketBlob: **c_void,
    pcbTicketBlob: *u32,
    pwszTemplateId: [*:0]const u16,
    pwszServerUrl: [*:0]const u16,
    pwszClientToken: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SLC" fn SLSetGenuineInformation(
    pQueryId: *const Guid,
    pwszValueName: [*:0]const u16,
    eDataType: SLDATATYPE,
    cbValue: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbValue: ?*const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "slcext" fn SLGetReferralInformation(
    hSLC: *c_void,
    eReferralType: SLREFERRALTYPE,
    pSkuOrAppId: *const Guid,
    pwszValueName: [*:0]const u16,
    ppwszValue: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SLC" fn SLGetGenuineInformation(
    pQueryId: *const Guid,
    pwszValueName: [*:0]const u16,
    peDataType: ?*SLDATATYPE,
    pcbValue: *u32,
    ppbValue: **u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-slapi-l1-1-0" fn SLQueryLicenseValueFromApp(
    valueName: [*:0]const u16,
    valueType: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    dataBuffer: ?*c_void,
    dataSize: u32,
    resultDataSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCreateSession(
    accessLevel: DdqAccessLevel,
    hSession: *HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCloseSession(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetSessionAccessLevel(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    accessLevel: *DdqAccessLevel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticDataAccessLevelAllowed(
    accessLevel: *DdqAccessLevel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordStats(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    searchCriteria: *const DIAGNOSTIC_DATA_SEARCH_CRITERIA,
    recordCount: *u32,
    minRowId: *i64,
    maxRowId: *i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordPayload(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    rowId: i64,
    payload: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTags(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    locale: [*:0]const u16,
    hTagDescription: *HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordLocaleTags(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTagAtIndex(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
    index: u32,
    tagDescription: *DIAGNOSTIC_DATA_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTagCount(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
    tagDescriptionCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducers(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    hProducerDescription: *HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordProducers(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerAtIndex(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
    index: u32,
    producerDescription: *DIAGNOSTIC_DATA_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerCount(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
    producerDescriptionCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerCategories(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerName: [*:0]const u16,
    hCategoryDescription: *HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordProducerCategories(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCategoryAtIndex(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
    index: u32,
    categoryDescription: *DIAGNOSTIC_DATA_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCategoryCount(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
    categoryDescriptionCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqIsDiagnosticRecordSampledIn(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    providerGroup: *const Guid,
    providerId: ?*const Guid,
    providerName: [*:0]const u16,
    eventId: ?*const u32,
    eventName: [*:0]const u16,
    eventVersion: ?*const u32,
    eventKeywords: ?*const u64,
    isSampledIn: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordPage(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    searchCriteria: *DIAGNOSTIC_DATA_SEARCH_CRITERIA,
    offset: u32,
    pageRecordCount: u32,
    baseRowId: i64,
    hRecord: *HDIAGNOSTIC_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordPage(
    hRecord: HDIAGNOSTIC_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordAtIndex(
    hRecord: HDIAGNOSTIC_RECORD,
    index: u32,
    record: *DIAGNOSTIC_DATA_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCount(
    hRecord: HDIAGNOSTIC_RECORD,
    recordCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportStoreReportCount(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    reportCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCancelDiagnosticRecordOperation(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReport(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    hReport: *HDIAGNOSTIC_REPORT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticReport(
    hReport: HDIAGNOSTIC_REPORT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportAtIndex(
    hReport: HDIAGNOSTIC_REPORT,
    index: u32,
    report: *DIAGNOSTIC_REPORT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportCount(
    hReport: HDIAGNOSTIC_REPORT,
    reportCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqExtractDiagnosticReport(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    reportKey: [*:0]const u16,
    destinationPath: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordTagDistribution(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]PWSTR,
    producerNameCount: u32,
    tagStats: [*]*DIAGNOSTIC_DATA_EVENT_TAG_STATS,
    statCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordBinaryDistribution(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]PWSTR,
    producerNameCount: u32,
    topNBinaries: u32,
    binaryStats: [*]*DIAGNOSTIC_DATA_EVENT_BINARY_STATS,
    statCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordSummary(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]const [*:0]const u16,
    producerNameCount: u32,
    generalStats: *DIAGNOSTIC_DATA_GENERAL_STATS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqSetTranscriptConfiguration(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    desiredConfig: *const DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetTranscriptConfiguration(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    currentConfig: *DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (221)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const NETRESOURCE = NETRESOURCEA;
        pub const UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOA;
        pub const REMOTE_NAME_INFO = REMOTE_NAME_INFOA;
        pub const SEC_WINNT_AUTH_IDENTITY_ = SEC_WINNT_AUTH_IDENTITY_A;
        pub const SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONA;
        pub const SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSA;
        pub const SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOA;
        pub const ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSA;
        pub const ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSA;
        pub const QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSA;
        pub const QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGA;
        pub const SERVICE_MAIN_FUNCTION = SERVICE_MAIN_FUNCTIONA;
        pub const LPSERVICE_MAIN_FUNCTION = LPSERVICE_MAIN_FUNCTIONA;
        pub const SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYA;
        pub const SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2A;
        pub const SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSA;
        pub const SecPkgInfo = SecPkgInfoA;
        pub const SecPkgCredentials_Names = SecPkgCredentials_NamesA;
        pub const SecPkgCredentials_SSIProvider = SecPkgCredentials_SSIProviderA;
        pub const SecPkgContext_Names = SecPkgContext_NamesA;
        pub const SecPkgContext_KeyInfo = SecPkgContext_KeyInfoA;
        pub const SecPkgContext_Authority = SecPkgContext_AuthorityA;
        pub const SecPkgContext_ProtoInfo = SecPkgContext_ProtoInfoA;
        pub const SecPkgContext_PackageInfo = SecPkgContext_PackageInfoA;
        pub const SecPkgContext_NegotiationInfo = SecPkgContext_NegotiationInfoA;
        pub const SecPkgContext_NativeNames = SecPkgContext_NativeNamesA;
        pub const SecPkgContext_CredentialName = SecPkgContext_CredentialNameA;
        pub const ACQUIRE_CREDENTIALS_HANDLE_FN_ = ACQUIRE_CREDENTIALS_HANDLE_FN_A;
        pub const ADD_CREDENTIALS_FN_ = ADD_CREDENTIALS_FN_A;
        pub const CHANGE_PASSWORD_FN_ = CHANGE_PASSWORD_FN_A;
        pub const INITIALIZE_SECURITY_CONTEXT_FN_ = INITIALIZE_SECURITY_CONTEXT_FN_A;
        pub const QUERY_CONTEXT_ATTRIBUTES_FN_ = QUERY_CONTEXT_ATTRIBUTES_FN_A;
        pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_ = QUERY_CONTEXT_ATTRIBUTES_EX_FN_A;
        pub const SET_CONTEXT_ATTRIBUTES_FN_ = SET_CONTEXT_ATTRIBUTES_FN_A;
        pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_ = QUERY_CREDENTIALS_ATTRIBUTES_FN_A;
        pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_ = QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A;
        pub const SET_CREDENTIALS_ATTRIBUTES_FN_ = SET_CREDENTIALS_ATTRIBUTES_FN_A;
        pub const ENUMERATE_SECURITY_PACKAGES_FN_ = ENUMERATE_SECURITY_PACKAGES_FN_A;
        pub const QUERY_SECURITY_PACKAGE_INFO_FN_ = QUERY_SECURITY_PACKAGE_INFO_FN_A;
        pub const IMPORT_SECURITY_CONTEXT_FN_ = IMPORT_SECURITY_CONTEXT_FN_A;
        pub const SecurityFunctionTable = SecurityFunctionTableA;
        pub const INIT_SECURITY_INTERFACE_ = INIT_SECURITY_INTERFACE_A;
        pub const SEC_WINNT_AUTH_IDENTITY_EX = SEC_WINNT_AUTH_IDENTITY_EXA;
        pub const CREDENTIAL_ATTRIBUTE = CREDENTIAL_ATTRIBUTEA;
        pub const CREDENTIAL = CREDENTIALA;
        pub const CREDENTIAL_TARGET_INFORMATION = CREDENTIAL_TARGET_INFORMATIONA;
        pub const CREDUI_INFO = CREDUI_INFOA;
        pub const CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSA;
        pub const SSL_EMPTY_CACHE_FN_ = SSL_EMPTY_CACHE_FN_A;
        pub const OBJECTS_AND_NAME_ = OBJECTS_AND_NAME_A;
        pub const TRUSTEE_ = TRUSTEE_A;
        pub const EXPLICIT_ACCESS_ = EXPLICIT_ACCESS_A;
        pub const TRUSTEE_ACCESS = TRUSTEE_ACCESSA;
        pub const ACTRL_ACCESS_INFO = ACTRL_ACCESS_INFOA;
        pub const ACTRL_CONTROL_INFO = ACTRL_CONTROL_INFOA;
        pub const INHERITED_FROM = INHERITED_FROMA;
        pub const SCARD_READERSTATE = SCARD_READERSTATEA;
        pub const LPOCNCONNPROC = LPOCNCONNPROCA;
        pub const OPENCARD_SEARCH_CRITERIA = OPENCARD_SEARCH_CRITERIAA;
        pub const OPENCARDNAME_EX = OPENCARDNAME_EXA;
        pub const OPENCARDNAME = OPENCARDNAMEA;
        pub const CERT_SELECT_STRUCT_ = CERT_SELECT_STRUCT_A;
        pub const CERT_VIEWPROPERTIES_STRUCT_ = CERT_VIEWPROPERTIES_STRUCT_A;
        pub const CRYPTUI_VIEWCERTIFICATE_STRUCT = CRYPTUI_VIEWCERTIFICATE_STRUCTA;
        pub const AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
        pub const AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
        pub const AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = AccessCheckByTypeResultListAndAuditAlarmByHandleA;
        pub const ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
        pub const ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
        pub const ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
        pub const ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
        pub const PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
        pub const SetFileSecurity = SetFileSecurityA;
        pub const GetFileSecurity = GetFileSecurityA;
        pub const LookupAccountSid = LookupAccountSidA;
        pub const LookupAccountName = LookupAccountNameA;
        pub const LookupPrivilegeValue = LookupPrivilegeValueA;
        pub const LookupPrivilegeName = LookupPrivilegeNameA;
        pub const LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
        pub const LogonUser = LogonUserA;
        pub const LogonUserEx = LogonUserExA;
        pub const ChangeServiceConfig2 = ChangeServiceConfig2A;
        pub const EnumDependentServices = EnumDependentServicesA;
        pub const EnumServicesStatus = EnumServicesStatusA;
        pub const EnumServicesStatusEx = EnumServicesStatusExA;
        pub const GetServiceKeyName = GetServiceKeyNameA;
        pub const GetServiceDisplayName = GetServiceDisplayNameA;
        pub const OpenSCManager = OpenSCManagerA;
        pub const OpenService = OpenServiceA;
        pub const QueryServiceConfig = QueryServiceConfigA;
        pub const QueryServiceConfig2 = QueryServiceConfig2A;
        pub const QueryServiceLockStatus = QueryServiceLockStatusA;
        pub const RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerA;
        pub const RegisterServiceCtrlHandlerEx = RegisterServiceCtrlHandlerExA;
        pub const StartServiceCtrlDispatcher = StartServiceCtrlDispatcherA;
        pub const StartService = StartServiceA;
        pub const NotifyServiceStatusChange = NotifyServiceStatusChangeA;
        pub const ControlServiceEx = ControlServiceExA;
        pub const AuditLookupCategoryName = AuditLookupCategoryNameA;
        pub const AuditLookupSubCategoryName = AuditLookupSubCategoryNameA;
        pub const AuditSetGlobalSacl = AuditSetGlobalSaclA;
        pub const AuditQueryGlobalSacl = AuditQueryGlobalSaclA;
        pub const AcquireCredentialsHandle = AcquireCredentialsHandleA;
        pub const AddCredentials = AddCredentialsA;
        pub const ChangeAccountPassword = ChangeAccountPasswordA;
        pub const InitializeSecurityContext = InitializeSecurityContextA;
        pub const QueryContextAttributes = QueryContextAttributesA;
        pub const QueryContextAttributesEx = QueryContextAttributesExA;
        pub const SetContextAttributes = SetContextAttributesA;
        pub const QueryCredentialsAttributes = QueryCredentialsAttributesA;
        pub const QueryCredentialsAttributesEx = QueryCredentialsAttributesExA;
        pub const SetCredentialsAttributes = SetCredentialsAttributesA;
        pub const EnumerateSecurityPackages = EnumerateSecurityPackagesA;
        pub const QuerySecurityPackageInfo = QuerySecurityPackageInfoA;
        pub const ImportSecurityContext = ImportSecurityContextA;
        pub const InitSecurityInterface = InitSecurityInterfaceA;
        pub const SaslEnumerateProfiles = SaslEnumerateProfilesA;
        pub const SaslGetProfilePackage = SaslGetProfilePackageA;
        pub const SaslIdentifyPackage = SaslIdentifyPackageA;
        pub const SaslInitializeSecurityContext = SaslInitializeSecurityContextA;
        pub const SspiPromptForCredentials = SspiPromptForCredentialsA;
        pub const AddSecurityPackage = AddSecurityPackageA;
        pub const DeleteSecurityPackage = DeleteSecurityPackageA;
        pub const CredWrite = CredWriteA;
        pub const CredRead = CredReadA;
        pub const CredEnumerate = CredEnumerateA;
        pub const CredWriteDomainCredentials = CredWriteDomainCredentialsA;
        pub const CredReadDomainCredentials = CredReadDomainCredentialsA;
        pub const CredDelete = CredDeleteA;
        pub const CredRename = CredRenameA;
        pub const CredGetTargetInfo = CredGetTargetInfoA;
        pub const CredMarshalCredential = CredMarshalCredentialA;
        pub const CredUnmarshalCredential = CredUnmarshalCredentialA;
        pub const CredIsMarshaledCredential = CredIsMarshaledCredentialA;
        pub const CredUnPackAuthenticationBuffer = CredUnPackAuthenticationBufferA;
        pub const CredPackAuthenticationBuffer = CredPackAuthenticationBufferA;
        pub const CredProtect = CredProtectA;
        pub const CredUnprotect = CredUnprotectA;
        pub const CredIsProtected = CredIsProtectedA;
        pub const CredFindBestCredential = CredFindBestCredentialA;
        pub const CredUIPromptForCredentials = CredUIPromptForCredentialsA;
        pub const CredUIPromptForWindowsCredentials = CredUIPromptForWindowsCredentialsA;
        pub const CredUIParseUserName = CredUIParseUserNameA;
        pub const CredUICmdLinePromptForCredentials = CredUICmdLinePromptForCredentialsA;
        pub const CredUIConfirmCredentials = CredUIConfirmCredentialsA;
        pub const CryptAcquireContext = CryptAcquireContextA;
        pub const CryptSignHash = CryptSignHashA;
        pub const CryptVerifySignature = CryptVerifySignatureA;
        pub const CryptSetProvider = CryptSetProviderA;
        pub const CryptSetProviderEx = CryptSetProviderExA;
        pub const CryptGetDefaultProvider = CryptGetDefaultProviderA;
        pub const CryptEnumProviderTypes = CryptEnumProviderTypesA;
        pub const CryptEnumProviders = CryptEnumProvidersA;
        pub const CertRDNValueToStr = CertRDNValueToStrA;
        pub const CertNameToStr = CertNameToStrA;
        pub const CertStrToName = CertStrToNameA;
        pub const CertGetNameString = CertGetNameStringA;
        pub const CertOpenSystemStore = CertOpenSystemStoreA;
        pub const CertAddEncodedCertificateToSystemStore = CertAddEncodedCertificateToSystemStoreA;
        pub const CryptRetrieveObjectByUrl = CryptRetrieveObjectByUrlA;
        pub const CryptStringToBinary = CryptStringToBinaryA;
        pub const CryptBinaryToString = CryptBinaryToStringA;
        pub const SslEmptyCache = SslEmptyCacheA;
        pub const WNetSetLastError = WNetSetLastErrorA;
        pub const SCardListReaderGroups = SCardListReaderGroupsA;
        pub const SCardListReaders = SCardListReadersA;
        pub const SCardListCards = SCardListCardsA;
        pub const SCardListInterfaces = SCardListInterfacesA;
        pub const SCardGetProviderId = SCardGetProviderIdA;
        pub const SCardGetCardTypeProviderName = SCardGetCardTypeProviderNameA;
        pub const SCardIntroduceReaderGroup = SCardIntroduceReaderGroupA;
        pub const SCardForgetReaderGroup = SCardForgetReaderGroupA;
        pub const SCardIntroduceReader = SCardIntroduceReaderA;
        pub const SCardForgetReader = SCardForgetReaderA;
        pub const SCardAddReaderToGroup = SCardAddReaderToGroupA;
        pub const SCardRemoveReaderFromGroup = SCardRemoveReaderFromGroupA;
        pub const SCardIntroduceCardType = SCardIntroduceCardTypeA;
        pub const SCardSetCardTypeProviderName = SCardSetCardTypeProviderNameA;
        pub const SCardForgetCardType = SCardForgetCardTypeA;
        pub const SCardLocateCards = SCardLocateCardsA;
        pub const SCardLocateCardsByATR = SCardLocateCardsByATRA;
        pub const SCardGetStatusChange = SCardGetStatusChangeA;
        pub const SCardConnect = SCardConnectA;
        pub const SCardStatus = SCardStatusA;
        pub const SCardUIDlgSelectCard = SCardUIDlgSelectCardA;
        pub const GetOpenCardName = GetOpenCardNameA;
        pub const SCardReadCache = SCardReadCacheA;
        pub const SCardWriteCache = SCardWriteCacheA;
        pub const SCardGetReaderIcon = SCardGetReaderIconA;
        pub const SCardGetDeviceTypeId = SCardGetDeviceTypeIdA;
        pub const SCardGetReaderDeviceInstanceId = SCardGetReaderDeviceInstanceIdA;
        pub const SCardListReadersWithDeviceInstanceId = SCardListReadersWithDeviceInstanceIdA;
        pub const SetEntriesInAcl = SetEntriesInAclA;
        pub const GetExplicitEntriesFromAcl = GetExplicitEntriesFromAclA;
        pub const GetEffectiveRightsFromAcl = GetEffectiveRightsFromAclA;
        pub const GetAuditedPermissionsFromAcl = GetAuditedPermissionsFromAclA;
        pub const GetNamedSecurityInfo = GetNamedSecurityInfoA;
        pub const SetNamedSecurityInfo = SetNamedSecurityInfoA;
        pub const GetInheritanceSource = GetInheritanceSourceA;
        pub const TreeResetNamedSecurityInfo = TreeResetNamedSecurityInfoA;
        pub const TreeSetNamedSecurityInfo = TreeSetNamedSecurityInfoA;
        pub const BuildSecurityDescriptor = BuildSecurityDescriptorA;
        pub const LookupSecurityDescriptorParts = LookupSecurityDescriptorPartsA;
        pub const BuildExplicitAccessWithName = BuildExplicitAccessWithNameA;
        pub const BuildImpersonateExplicitAccessWithName = BuildImpersonateExplicitAccessWithNameA;
        pub const BuildTrusteeWithName = BuildTrusteeWithNameA;
        pub const BuildImpersonateTrustee = BuildImpersonateTrusteeA;
        pub const BuildTrusteeWithSid = BuildTrusteeWithSidA;
        pub const BuildTrusteeWithObjectsAndSid = BuildTrusteeWithObjectsAndSidA;
        pub const BuildTrusteeWithObjectsAndName = BuildTrusteeWithObjectsAndNameA;
        pub const GetTrusteeName = GetTrusteeNameA;
        pub const GetTrusteeType = GetTrusteeTypeA;
        pub const GetTrusteeForm = GetTrusteeFormA;
        pub const GetMultipleTrusteeOperation = GetMultipleTrusteeOperationA;
        pub const GetMultipleTrustee = GetMultipleTrusteeA;
        pub const ConvertSidToStringSid = ConvertSidToStringSidA;
        pub const ConvertStringSidToSid = ConvertStringSidToSidA;
        pub const ConvertStringSecurityDescriptorToSecurityDescriptor = ConvertStringSecurityDescriptorToSecurityDescriptorA;
        pub const ConvertSecurityDescriptorToStringSecurityDescriptor = ConvertSecurityDescriptorToStringSecurityDescriptorA;
        pub const CryptUIDlgViewCertificate = CryptUIDlgViewCertificateA;
    },
    .wide => struct {
        pub const NETRESOURCE = NETRESOURCEW;
        pub const UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOW;
        pub const REMOTE_NAME_INFO = REMOTE_NAME_INFOW;
        pub const SEC_WINNT_AUTH_IDENTITY_ = SEC_WINNT_AUTH_IDENTITY_W;
        pub const SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONW;
        pub const SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSW;
        pub const SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOW;
        pub const ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSW;
        pub const ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSW;
        pub const QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSW;
        pub const QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGW;
        pub const SERVICE_MAIN_FUNCTION = SERVICE_MAIN_FUNCTIONW;
        pub const LPSERVICE_MAIN_FUNCTION = LPSERVICE_MAIN_FUNCTIONW;
        pub const SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYW;
        pub const SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2W;
        pub const SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSW;
        pub const SecPkgInfo = SecPkgInfoW;
        pub const SecPkgCredentials_Names = SecPkgCredentials_NamesW;
        pub const SecPkgCredentials_SSIProvider = SecPkgCredentials_SSIProviderW;
        pub const SecPkgContext_Names = SecPkgContext_NamesW;
        pub const SecPkgContext_KeyInfo = SecPkgContext_KeyInfoW;
        pub const SecPkgContext_Authority = SecPkgContext_AuthorityW;
        pub const SecPkgContext_ProtoInfo = SecPkgContext_ProtoInfoW;
        pub const SecPkgContext_PackageInfo = SecPkgContext_PackageInfoW;
        pub const SecPkgContext_NegotiationInfo = SecPkgContext_NegotiationInfoW;
        pub const SecPkgContext_NativeNames = SecPkgContext_NativeNamesW;
        pub const SecPkgContext_CredentialName = SecPkgContext_CredentialNameW;
        pub const ACQUIRE_CREDENTIALS_HANDLE_FN_ = ACQUIRE_CREDENTIALS_HANDLE_FN_W;
        pub const ADD_CREDENTIALS_FN_ = ADD_CREDENTIALS_FN_W;
        pub const CHANGE_PASSWORD_FN_ = CHANGE_PASSWORD_FN_W;
        pub const INITIALIZE_SECURITY_CONTEXT_FN_ = INITIALIZE_SECURITY_CONTEXT_FN_W;
        pub const QUERY_CONTEXT_ATTRIBUTES_FN_ = QUERY_CONTEXT_ATTRIBUTES_FN_W;
        pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_ = QUERY_CONTEXT_ATTRIBUTES_EX_FN_W;
        pub const SET_CONTEXT_ATTRIBUTES_FN_ = SET_CONTEXT_ATTRIBUTES_FN_W;
        pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_ = QUERY_CREDENTIALS_ATTRIBUTES_FN_W;
        pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_ = QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W;
        pub const SET_CREDENTIALS_ATTRIBUTES_FN_ = SET_CREDENTIALS_ATTRIBUTES_FN_W;
        pub const ENUMERATE_SECURITY_PACKAGES_FN_ = ENUMERATE_SECURITY_PACKAGES_FN_W;
        pub const QUERY_SECURITY_PACKAGE_INFO_FN_ = QUERY_SECURITY_PACKAGE_INFO_FN_W;
        pub const IMPORT_SECURITY_CONTEXT_FN_ = IMPORT_SECURITY_CONTEXT_FN_W;
        pub const SecurityFunctionTable = SecurityFunctionTableW;
        pub const INIT_SECURITY_INTERFACE_ = INIT_SECURITY_INTERFACE_W;
        pub const SEC_WINNT_AUTH_IDENTITY_EX = SEC_WINNT_AUTH_IDENTITY_EXW;
        pub const CREDENTIAL_ATTRIBUTE = CREDENTIAL_ATTRIBUTEW;
        pub const CREDENTIAL = CREDENTIALW;
        pub const CREDENTIAL_TARGET_INFORMATION = CREDENTIAL_TARGET_INFORMATIONW;
        pub const CREDUI_INFO = CREDUI_INFOW;
        pub const CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSW;
        pub const SSL_EMPTY_CACHE_FN_ = SSL_EMPTY_CACHE_FN_W;
        pub const OBJECTS_AND_NAME_ = OBJECTS_AND_NAME_W;
        pub const TRUSTEE_ = TRUSTEE_W;
        pub const EXPLICIT_ACCESS_ = EXPLICIT_ACCESS_W;
        pub const TRUSTEE_ACCESS = TRUSTEE_ACCESSW;
        pub const ACTRL_ACCESS_INFO = ACTRL_ACCESS_INFOW;
        pub const ACTRL_CONTROL_INFO = ACTRL_CONTROL_INFOW;
        pub const INHERITED_FROM = INHERITED_FROMW;
        pub const SCARD_READERSTATE = SCARD_READERSTATEW;
        pub const LPOCNCONNPROC = LPOCNCONNPROCW;
        pub const OPENCARD_SEARCH_CRITERIA = OPENCARD_SEARCH_CRITERIAW;
        pub const OPENCARDNAME_EX = OPENCARDNAME_EXW;
        pub const OPENCARDNAME = OPENCARDNAMEW;
        pub const CERT_SELECT_STRUCT_ = CERT_SELECT_STRUCT_W;
        pub const CERT_VIEWPROPERTIES_STRUCT_ = CERT_VIEWPROPERTIES_STRUCT_W;
        pub const CRYPTUI_VIEWCERTIFICATE_STRUCT = CRYPTUI_VIEWCERTIFICATE_STRUCTW;
        pub const AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
        pub const AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmW;
        pub const AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmW;
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = AccessCheckByTypeResultListAndAuditAlarmByHandleW;
        pub const ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
        pub const ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
        pub const ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
        pub const ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
        pub const PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
        pub const SetFileSecurity = SetFileSecurityW;
        pub const GetFileSecurity = GetFileSecurityW;
        pub const LookupAccountSid = LookupAccountSidW;
        pub const LookupAccountName = LookupAccountNameW;
        pub const LookupPrivilegeValue = LookupPrivilegeValueW;
        pub const LookupPrivilegeName = LookupPrivilegeNameW;
        pub const LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
        pub const LogonUser = LogonUserW;
        pub const LogonUserEx = LogonUserExW;
        pub const ChangeServiceConfig2 = ChangeServiceConfig2W;
        pub const EnumDependentServices = EnumDependentServicesW;
        pub const EnumServicesStatus = EnumServicesStatusW;
        pub const EnumServicesStatusEx = EnumServicesStatusExW;
        pub const GetServiceKeyName = GetServiceKeyNameW;
        pub const GetServiceDisplayName = GetServiceDisplayNameW;
        pub const OpenSCManager = OpenSCManagerW;
        pub const OpenService = OpenServiceW;
        pub const QueryServiceConfig = QueryServiceConfigW;
        pub const QueryServiceConfig2 = QueryServiceConfig2W;
        pub const QueryServiceLockStatus = QueryServiceLockStatusW;
        pub const RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerW;
        pub const RegisterServiceCtrlHandlerEx = RegisterServiceCtrlHandlerExW;
        pub const StartServiceCtrlDispatcher = StartServiceCtrlDispatcherW;
        pub const StartService = StartServiceW;
        pub const NotifyServiceStatusChange = NotifyServiceStatusChangeW;
        pub const ControlServiceEx = ControlServiceExW;
        pub const AuditLookupCategoryName = AuditLookupCategoryNameW;
        pub const AuditLookupSubCategoryName = AuditLookupSubCategoryNameW;
        pub const AuditSetGlobalSacl = AuditSetGlobalSaclW;
        pub const AuditQueryGlobalSacl = AuditQueryGlobalSaclW;
        pub const AcquireCredentialsHandle = AcquireCredentialsHandleW;
        pub const AddCredentials = AddCredentialsW;
        pub const ChangeAccountPassword = ChangeAccountPasswordW;
        pub const InitializeSecurityContext = InitializeSecurityContextW;
        pub const QueryContextAttributes = QueryContextAttributesW;
        pub const QueryContextAttributesEx = QueryContextAttributesExW;
        pub const SetContextAttributes = SetContextAttributesW;
        pub const QueryCredentialsAttributes = QueryCredentialsAttributesW;
        pub const QueryCredentialsAttributesEx = QueryCredentialsAttributesExW;
        pub const SetCredentialsAttributes = SetCredentialsAttributesW;
        pub const EnumerateSecurityPackages = EnumerateSecurityPackagesW;
        pub const QuerySecurityPackageInfo = QuerySecurityPackageInfoW;
        pub const ImportSecurityContext = ImportSecurityContextW;
        pub const InitSecurityInterface = InitSecurityInterfaceW;
        pub const SaslEnumerateProfiles = SaslEnumerateProfilesW;
        pub const SaslGetProfilePackage = SaslGetProfilePackageW;
        pub const SaslIdentifyPackage = SaslIdentifyPackageW;
        pub const SaslInitializeSecurityContext = SaslInitializeSecurityContextW;
        pub const SspiPromptForCredentials = SspiPromptForCredentialsW;
        pub const AddSecurityPackage = AddSecurityPackageW;
        pub const DeleteSecurityPackage = DeleteSecurityPackageW;
        pub const CredWrite = CredWriteW;
        pub const CredRead = CredReadW;
        pub const CredEnumerate = CredEnumerateW;
        pub const CredWriteDomainCredentials = CredWriteDomainCredentialsW;
        pub const CredReadDomainCredentials = CredReadDomainCredentialsW;
        pub const CredDelete = CredDeleteW;
        pub const CredRename = CredRenameW;
        pub const CredGetTargetInfo = CredGetTargetInfoW;
        pub const CredMarshalCredential = CredMarshalCredentialW;
        pub const CredUnmarshalCredential = CredUnmarshalCredentialW;
        pub const CredIsMarshaledCredential = CredIsMarshaledCredentialW;
        pub const CredUnPackAuthenticationBuffer = CredUnPackAuthenticationBufferW;
        pub const CredPackAuthenticationBuffer = CredPackAuthenticationBufferW;
        pub const CredProtect = CredProtectW;
        pub const CredUnprotect = CredUnprotectW;
        pub const CredIsProtected = CredIsProtectedW;
        pub const CredFindBestCredential = CredFindBestCredentialW;
        pub const CredUIPromptForCredentials = CredUIPromptForCredentialsW;
        pub const CredUIPromptForWindowsCredentials = CredUIPromptForWindowsCredentialsW;
        pub const CredUIParseUserName = CredUIParseUserNameW;
        pub const CredUICmdLinePromptForCredentials = CredUICmdLinePromptForCredentialsW;
        pub const CredUIConfirmCredentials = CredUIConfirmCredentialsW;
        pub const CryptAcquireContext = CryptAcquireContextW;
        pub const CryptSignHash = CryptSignHashW;
        pub const CryptVerifySignature = CryptVerifySignatureW;
        pub const CryptSetProvider = CryptSetProviderW;
        pub const CryptSetProviderEx = CryptSetProviderExW;
        pub const CryptGetDefaultProvider = CryptGetDefaultProviderW;
        pub const CryptEnumProviderTypes = CryptEnumProviderTypesW;
        pub const CryptEnumProviders = CryptEnumProvidersW;
        pub const CertRDNValueToStr = CertRDNValueToStrW;
        pub const CertNameToStr = CertNameToStrW;
        pub const CertStrToName = CertStrToNameW;
        pub const CertGetNameString = CertGetNameStringW;
        pub const CertOpenSystemStore = CertOpenSystemStoreW;
        pub const CertAddEncodedCertificateToSystemStore = CertAddEncodedCertificateToSystemStoreW;
        pub const CryptRetrieveObjectByUrl = CryptRetrieveObjectByUrlW;
        pub const CryptStringToBinary = CryptStringToBinaryW;
        pub const CryptBinaryToString = CryptBinaryToStringW;
        pub const SslEmptyCache = SslEmptyCacheW;
        pub const WNetSetLastError = WNetSetLastErrorW;
        pub const SCardListReaderGroups = SCardListReaderGroupsW;
        pub const SCardListReaders = SCardListReadersW;
        pub const SCardListCards = SCardListCardsW;
        pub const SCardListInterfaces = SCardListInterfacesW;
        pub const SCardGetProviderId = SCardGetProviderIdW;
        pub const SCardGetCardTypeProviderName = SCardGetCardTypeProviderNameW;
        pub const SCardIntroduceReaderGroup = SCardIntroduceReaderGroupW;
        pub const SCardForgetReaderGroup = SCardForgetReaderGroupW;
        pub const SCardIntroduceReader = SCardIntroduceReaderW;
        pub const SCardForgetReader = SCardForgetReaderW;
        pub const SCardAddReaderToGroup = SCardAddReaderToGroupW;
        pub const SCardRemoveReaderFromGroup = SCardRemoveReaderFromGroupW;
        pub const SCardIntroduceCardType = SCardIntroduceCardTypeW;
        pub const SCardSetCardTypeProviderName = SCardSetCardTypeProviderNameW;
        pub const SCardForgetCardType = SCardForgetCardTypeW;
        pub const SCardLocateCards = SCardLocateCardsW;
        pub const SCardLocateCardsByATR = SCardLocateCardsByATRW;
        pub const SCardGetStatusChange = SCardGetStatusChangeW;
        pub const SCardConnect = SCardConnectW;
        pub const SCardStatus = SCardStatusW;
        pub const SCardUIDlgSelectCard = SCardUIDlgSelectCardW;
        pub const GetOpenCardName = GetOpenCardNameW;
        pub const SCardReadCache = SCardReadCacheW;
        pub const SCardWriteCache = SCardWriteCacheW;
        pub const SCardGetReaderIcon = SCardGetReaderIconW;
        pub const SCardGetDeviceTypeId = SCardGetDeviceTypeIdW;
        pub const SCardGetReaderDeviceInstanceId = SCardGetReaderDeviceInstanceIdW;
        pub const SCardListReadersWithDeviceInstanceId = SCardListReadersWithDeviceInstanceIdW;
        pub const SetEntriesInAcl = SetEntriesInAclW;
        pub const GetExplicitEntriesFromAcl = GetExplicitEntriesFromAclW;
        pub const GetEffectiveRightsFromAcl = GetEffectiveRightsFromAclW;
        pub const GetAuditedPermissionsFromAcl = GetAuditedPermissionsFromAclW;
        pub const GetNamedSecurityInfo = GetNamedSecurityInfoW;
        pub const SetNamedSecurityInfo = SetNamedSecurityInfoW;
        pub const GetInheritanceSource = GetInheritanceSourceW;
        pub const TreeResetNamedSecurityInfo = TreeResetNamedSecurityInfoW;
        pub const TreeSetNamedSecurityInfo = TreeSetNamedSecurityInfoW;
        pub const BuildSecurityDescriptor = BuildSecurityDescriptorW;
        pub const LookupSecurityDescriptorParts = LookupSecurityDescriptorPartsW;
        pub const BuildExplicitAccessWithName = BuildExplicitAccessWithNameW;
        pub const BuildImpersonateExplicitAccessWithName = BuildImpersonateExplicitAccessWithNameW;
        pub const BuildTrusteeWithName = BuildTrusteeWithNameW;
        pub const BuildImpersonateTrustee = BuildImpersonateTrusteeW;
        pub const BuildTrusteeWithSid = BuildTrusteeWithSidW;
        pub const BuildTrusteeWithObjectsAndSid = BuildTrusteeWithObjectsAndSidW;
        pub const BuildTrusteeWithObjectsAndName = BuildTrusteeWithObjectsAndNameW;
        pub const GetTrusteeName = GetTrusteeNameW;
        pub const GetTrusteeType = GetTrusteeTypeW;
        pub const GetTrusteeForm = GetTrusteeFormW;
        pub const GetMultipleTrusteeOperation = GetMultipleTrusteeOperationW;
        pub const GetMultipleTrustee = GetMultipleTrusteeW;
        pub const ConvertSidToStringSid = ConvertSidToStringSidW;
        pub const ConvertStringSidToSid = ConvertStringSidToSidW;
        pub const ConvertStringSecurityDescriptorToSecurityDescriptor = ConvertStringSecurityDescriptorToSecurityDescriptorW;
        pub const ConvertSecurityDescriptorToStringSecurityDescriptor = ConvertSecurityDescriptorToStringSecurityDescriptorW;
        pub const CryptUIDlgViewCertificate = CryptUIDlgViewCertificateW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const NETRESOURCE = *opaque{};
        pub const UNIVERSAL_NAME_INFO = *opaque{};
        pub const REMOTE_NAME_INFO = *opaque{};
        pub const SEC_WINNT_AUTH_IDENTITY_ = *opaque{};
        pub const SERVICE_DESCRIPTION = *opaque{};
        pub const SERVICE_FAILURE_ACTIONS = *opaque{};
        pub const SERVICE_REQUIRED_PRIVILEGES_INFO = *opaque{};
        pub const ENUM_SERVICE_STATUS = *opaque{};
        pub const ENUM_SERVICE_STATUS_PROCESS = *opaque{};
        pub const QUERY_SERVICE_LOCK_STATUS = *opaque{};
        pub const QUERY_SERVICE_CONFIG = *opaque{};
        pub const SERVICE_MAIN_FUNCTION = *opaque{};
        pub const LPSERVICE_MAIN_FUNCTION = *opaque{};
        pub const SERVICE_TABLE_ENTRY = *opaque{};
        pub const SERVICE_NOTIFY_2 = *opaque{};
        pub const SERVICE_CONTROL_STATUS_REASON_PARAMS = *opaque{};
        pub const SecPkgInfo = *opaque{};
        pub const SecPkgCredentials_Names = *opaque{};
        pub const SecPkgCredentials_SSIProvider = *opaque{};
        pub const SecPkgContext_Names = *opaque{};
        pub const SecPkgContext_KeyInfo = *opaque{};
        pub const SecPkgContext_Authority = *opaque{};
        pub const SecPkgContext_ProtoInfo = *opaque{};
        pub const SecPkgContext_PackageInfo = *opaque{};
        pub const SecPkgContext_NegotiationInfo = *opaque{};
        pub const SecPkgContext_NativeNames = *opaque{};
        pub const SecPkgContext_CredentialName = *opaque{};
        pub const ACQUIRE_CREDENTIALS_HANDLE_FN_ = *opaque{};
        pub const ADD_CREDENTIALS_FN_ = *opaque{};
        pub const CHANGE_PASSWORD_FN_ = *opaque{};
        pub const INITIALIZE_SECURITY_CONTEXT_FN_ = *opaque{};
        pub const QUERY_CONTEXT_ATTRIBUTES_FN_ = *opaque{};
        pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_ = *opaque{};
        pub const SET_CONTEXT_ATTRIBUTES_FN_ = *opaque{};
        pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_ = *opaque{};
        pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_ = *opaque{};
        pub const SET_CREDENTIALS_ATTRIBUTES_FN_ = *opaque{};
        pub const ENUMERATE_SECURITY_PACKAGES_FN_ = *opaque{};
        pub const QUERY_SECURITY_PACKAGE_INFO_FN_ = *opaque{};
        pub const IMPORT_SECURITY_CONTEXT_FN_ = *opaque{};
        pub const SecurityFunctionTable = *opaque{};
        pub const INIT_SECURITY_INTERFACE_ = *opaque{};
        pub const SEC_WINNT_AUTH_IDENTITY_EX = *opaque{};
        pub const CREDENTIAL_ATTRIBUTE = *opaque{};
        pub const CREDENTIAL = *opaque{};
        pub const CREDENTIAL_TARGET_INFORMATION = *opaque{};
        pub const CREDUI_INFO = *opaque{};
        pub const CRYPT_PASSWORD_CREDENTIALS = *opaque{};
        pub const SSL_EMPTY_CACHE_FN_ = *opaque{};
        pub const OBJECTS_AND_NAME_ = *opaque{};
        pub const TRUSTEE_ = *opaque{};
        pub const EXPLICIT_ACCESS_ = *opaque{};
        pub const TRUSTEE_ACCESS = *opaque{};
        pub const ACTRL_ACCESS_INFO = *opaque{};
        pub const ACTRL_CONTROL_INFO = *opaque{};
        pub const INHERITED_FROM = *opaque{};
        pub const SCARD_READERSTATE = *opaque{};
        pub const LPOCNCONNPROC = *opaque{};
        pub const OPENCARD_SEARCH_CRITERIA = *opaque{};
        pub const OPENCARDNAME_EX = *opaque{};
        pub const OPENCARDNAME = *opaque{};
        pub const CERT_SELECT_STRUCT_ = *opaque{};
        pub const CERT_VIEWPROPERTIES_STRUCT_ = *opaque{};
        pub const CRYPTUI_VIEWCERTIFICATE_STRUCT = *opaque{};
        pub const AccessCheckAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeResultListAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = *opaque{};
        pub const ObjectOpenAuditAlarm = *opaque{};
        pub const ObjectPrivilegeAuditAlarm = *opaque{};
        pub const ObjectCloseAuditAlarm = *opaque{};
        pub const ObjectDeleteAuditAlarm = *opaque{};
        pub const PrivilegedServiceAuditAlarm = *opaque{};
        pub const SetFileSecurity = *opaque{};
        pub const GetFileSecurity = *opaque{};
        pub const LookupAccountSid = *opaque{};
        pub const LookupAccountName = *opaque{};
        pub const LookupPrivilegeValue = *opaque{};
        pub const LookupPrivilegeName = *opaque{};
        pub const LookupPrivilegeDisplayName = *opaque{};
        pub const LogonUser = *opaque{};
        pub const LogonUserEx = *opaque{};
        pub const ChangeServiceConfig2 = *opaque{};
        pub const EnumDependentServices = *opaque{};
        pub const EnumServicesStatus = *opaque{};
        pub const EnumServicesStatusEx = *opaque{};
        pub const GetServiceKeyName = *opaque{};
        pub const GetServiceDisplayName = *opaque{};
        pub const OpenSCManager = *opaque{};
        pub const OpenService = *opaque{};
        pub const QueryServiceConfig = *opaque{};
        pub const QueryServiceConfig2 = *opaque{};
        pub const QueryServiceLockStatus = *opaque{};
        pub const RegisterServiceCtrlHandler = *opaque{};
        pub const RegisterServiceCtrlHandlerEx = *opaque{};
        pub const StartServiceCtrlDispatcher = *opaque{};
        pub const StartService = *opaque{};
        pub const NotifyServiceStatusChange = *opaque{};
        pub const ControlServiceEx = *opaque{};
        pub const AuditLookupCategoryName = *opaque{};
        pub const AuditLookupSubCategoryName = *opaque{};
        pub const AuditSetGlobalSacl = *opaque{};
        pub const AuditQueryGlobalSacl = *opaque{};
        pub const AcquireCredentialsHandle = *opaque{};
        pub const AddCredentials = *opaque{};
        pub const ChangeAccountPassword = *opaque{};
        pub const InitializeSecurityContext = *opaque{};
        pub const QueryContextAttributes = *opaque{};
        pub const QueryContextAttributesEx = *opaque{};
        pub const SetContextAttributes = *opaque{};
        pub const QueryCredentialsAttributes = *opaque{};
        pub const QueryCredentialsAttributesEx = *opaque{};
        pub const SetCredentialsAttributes = *opaque{};
        pub const EnumerateSecurityPackages = *opaque{};
        pub const QuerySecurityPackageInfo = *opaque{};
        pub const ImportSecurityContext = *opaque{};
        pub const InitSecurityInterface = *opaque{};
        pub const SaslEnumerateProfiles = *opaque{};
        pub const SaslGetProfilePackage = *opaque{};
        pub const SaslIdentifyPackage = *opaque{};
        pub const SaslInitializeSecurityContext = *opaque{};
        pub const SspiPromptForCredentials = *opaque{};
        pub const AddSecurityPackage = *opaque{};
        pub const DeleteSecurityPackage = *opaque{};
        pub const CredWrite = *opaque{};
        pub const CredRead = *opaque{};
        pub const CredEnumerate = *opaque{};
        pub const CredWriteDomainCredentials = *opaque{};
        pub const CredReadDomainCredentials = *opaque{};
        pub const CredDelete = *opaque{};
        pub const CredRename = *opaque{};
        pub const CredGetTargetInfo = *opaque{};
        pub const CredMarshalCredential = *opaque{};
        pub const CredUnmarshalCredential = *opaque{};
        pub const CredIsMarshaledCredential = *opaque{};
        pub const CredUnPackAuthenticationBuffer = *opaque{};
        pub const CredPackAuthenticationBuffer = *opaque{};
        pub const CredProtect = *opaque{};
        pub const CredUnprotect = *opaque{};
        pub const CredIsProtected = *opaque{};
        pub const CredFindBestCredential = *opaque{};
        pub const CredUIPromptForCredentials = *opaque{};
        pub const CredUIPromptForWindowsCredentials = *opaque{};
        pub const CredUIParseUserName = *opaque{};
        pub const CredUICmdLinePromptForCredentials = *opaque{};
        pub const CredUIConfirmCredentials = *opaque{};
        pub const CryptAcquireContext = *opaque{};
        pub const CryptSignHash = *opaque{};
        pub const CryptVerifySignature = *opaque{};
        pub const CryptSetProvider = *opaque{};
        pub const CryptSetProviderEx = *opaque{};
        pub const CryptGetDefaultProvider = *opaque{};
        pub const CryptEnumProviderTypes = *opaque{};
        pub const CryptEnumProviders = *opaque{};
        pub const CertRDNValueToStr = *opaque{};
        pub const CertNameToStr = *opaque{};
        pub const CertStrToName = *opaque{};
        pub const CertGetNameString = *opaque{};
        pub const CertOpenSystemStore = *opaque{};
        pub const CertAddEncodedCertificateToSystemStore = *opaque{};
        pub const CryptRetrieveObjectByUrl = *opaque{};
        pub const CryptStringToBinary = *opaque{};
        pub const CryptBinaryToString = *opaque{};
        pub const SslEmptyCache = *opaque{};
        pub const WNetSetLastError = *opaque{};
        pub const SCardListReaderGroups = *opaque{};
        pub const SCardListReaders = *opaque{};
        pub const SCardListCards = *opaque{};
        pub const SCardListInterfaces = *opaque{};
        pub const SCardGetProviderId = *opaque{};
        pub const SCardGetCardTypeProviderName = *opaque{};
        pub const SCardIntroduceReaderGroup = *opaque{};
        pub const SCardForgetReaderGroup = *opaque{};
        pub const SCardIntroduceReader = *opaque{};
        pub const SCardForgetReader = *opaque{};
        pub const SCardAddReaderToGroup = *opaque{};
        pub const SCardRemoveReaderFromGroup = *opaque{};
        pub const SCardIntroduceCardType = *opaque{};
        pub const SCardSetCardTypeProviderName = *opaque{};
        pub const SCardForgetCardType = *opaque{};
        pub const SCardLocateCards = *opaque{};
        pub const SCardLocateCardsByATR = *opaque{};
        pub const SCardGetStatusChange = *opaque{};
        pub const SCardConnect = *opaque{};
        pub const SCardStatus = *opaque{};
        pub const SCardUIDlgSelectCard = *opaque{};
        pub const GetOpenCardName = *opaque{};
        pub const SCardReadCache = *opaque{};
        pub const SCardWriteCache = *opaque{};
        pub const SCardGetReaderIcon = *opaque{};
        pub const SCardGetDeviceTypeId = *opaque{};
        pub const SCardGetReaderDeviceInstanceId = *opaque{};
        pub const SCardListReadersWithDeviceInstanceId = *opaque{};
        pub const SetEntriesInAcl = *opaque{};
        pub const GetExplicitEntriesFromAcl = *opaque{};
        pub const GetEffectiveRightsFromAcl = *opaque{};
        pub const GetAuditedPermissionsFromAcl = *opaque{};
        pub const GetNamedSecurityInfo = *opaque{};
        pub const SetNamedSecurityInfo = *opaque{};
        pub const GetInheritanceSource = *opaque{};
        pub const TreeResetNamedSecurityInfo = *opaque{};
        pub const TreeSetNamedSecurityInfo = *opaque{};
        pub const BuildSecurityDescriptor = *opaque{};
        pub const LookupSecurityDescriptorParts = *opaque{};
        pub const BuildExplicitAccessWithName = *opaque{};
        pub const BuildImpersonateExplicitAccessWithName = *opaque{};
        pub const BuildTrusteeWithName = *opaque{};
        pub const BuildImpersonateTrustee = *opaque{};
        pub const BuildTrusteeWithSid = *opaque{};
        pub const BuildTrusteeWithObjectsAndSid = *opaque{};
        pub const BuildTrusteeWithObjectsAndName = *opaque{};
        pub const GetTrusteeName = *opaque{};
        pub const GetTrusteeType = *opaque{};
        pub const GetTrusteeForm = *opaque{};
        pub const GetMultipleTrusteeOperation = *opaque{};
        pub const GetMultipleTrustee = *opaque{};
        pub const ConvertSidToStringSid = *opaque{};
        pub const ConvertStringSidToSid = *opaque{};
        pub const ConvertStringSecurityDescriptorToSecurityDescriptor = *opaque{};
        pub const ConvertSecurityDescriptorToStringSecurityDescriptor = *opaque{};
        pub const CryptUIDlgViewCertificate = *opaque{};
    } else struct {
        pub const NETRESOURCE = @compileError("'NETRESOURCE' requires that UNICODE be set to true or false in the root module");
        pub const UNIVERSAL_NAME_INFO = @compileError("'UNIVERSAL_NAME_INFO' requires that UNICODE be set to true or false in the root module");
        pub const REMOTE_NAME_INFO = @compileError("'REMOTE_NAME_INFO' requires that UNICODE be set to true or false in the root module");
        pub const SEC_WINNT_AUTH_IDENTITY_ = @compileError("'SEC_WINNT_AUTH_IDENTITY_' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_DESCRIPTION = @compileError("'SERVICE_DESCRIPTION' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_FAILURE_ACTIONS = @compileError("'SERVICE_FAILURE_ACTIONS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_REQUIRED_PRIVILEGES_INFO = @compileError("'SERVICE_REQUIRED_PRIVILEGES_INFO' requires that UNICODE be set to true or false in the root module");
        pub const ENUM_SERVICE_STATUS = @compileError("'ENUM_SERVICE_STATUS' requires that UNICODE be set to true or false in the root module");
        pub const ENUM_SERVICE_STATUS_PROCESS = @compileError("'ENUM_SERVICE_STATUS_PROCESS' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_SERVICE_LOCK_STATUS = @compileError("'QUERY_SERVICE_LOCK_STATUS' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_SERVICE_CONFIG = @compileError("'QUERY_SERVICE_CONFIG' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_MAIN_FUNCTION = @compileError("'SERVICE_MAIN_FUNCTION' requires that UNICODE be set to true or false in the root module");
        pub const LPSERVICE_MAIN_FUNCTION = @compileError("'LPSERVICE_MAIN_FUNCTION' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TABLE_ENTRY = @compileError("'SERVICE_TABLE_ENTRY' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_NOTIFY_2 = @compileError("'SERVICE_NOTIFY_2' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_CONTROL_STATUS_REASON_PARAMS = @compileError("'SERVICE_CONTROL_STATUS_REASON_PARAMS' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgInfo = @compileError("'SecPkgInfo' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgCredentials_Names = @compileError("'SecPkgCredentials_Names' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgCredentials_SSIProvider = @compileError("'SecPkgCredentials_SSIProvider' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_Names = @compileError("'SecPkgContext_Names' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_KeyInfo = @compileError("'SecPkgContext_KeyInfo' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_Authority = @compileError("'SecPkgContext_Authority' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_ProtoInfo = @compileError("'SecPkgContext_ProtoInfo' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_PackageInfo = @compileError("'SecPkgContext_PackageInfo' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_NegotiationInfo = @compileError("'SecPkgContext_NegotiationInfo' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_NativeNames = @compileError("'SecPkgContext_NativeNames' requires that UNICODE be set to true or false in the root module");
        pub const SecPkgContext_CredentialName = @compileError("'SecPkgContext_CredentialName' requires that UNICODE be set to true or false in the root module");
        pub const ACQUIRE_CREDENTIALS_HANDLE_FN_ = @compileError("'ACQUIRE_CREDENTIALS_HANDLE_FN_' requires that UNICODE be set to true or false in the root module");
        pub const ADD_CREDENTIALS_FN_ = @compileError("'ADD_CREDENTIALS_FN_' requires that UNICODE be set to true or false in the root module");
        pub const CHANGE_PASSWORD_FN_ = @compileError("'CHANGE_PASSWORD_FN_' requires that UNICODE be set to true or false in the root module");
        pub const INITIALIZE_SECURITY_CONTEXT_FN_ = @compileError("'INITIALIZE_SECURITY_CONTEXT_FN_' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_CONTEXT_ATTRIBUTES_FN_ = @compileError("'QUERY_CONTEXT_ATTRIBUTES_FN_' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_CONTEXT_ATTRIBUTES_EX_FN_ = @compileError("'QUERY_CONTEXT_ATTRIBUTES_EX_FN_' requires that UNICODE be set to true or false in the root module");
        pub const SET_CONTEXT_ATTRIBUTES_FN_ = @compileError("'SET_CONTEXT_ATTRIBUTES_FN_' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_CREDENTIALS_ATTRIBUTES_FN_ = @compileError("'QUERY_CREDENTIALS_ATTRIBUTES_FN_' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_ = @compileError("'QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_' requires that UNICODE be set to true or false in the root module");
        pub const SET_CREDENTIALS_ATTRIBUTES_FN_ = @compileError("'SET_CREDENTIALS_ATTRIBUTES_FN_' requires that UNICODE be set to true or false in the root module");
        pub const ENUMERATE_SECURITY_PACKAGES_FN_ = @compileError("'ENUMERATE_SECURITY_PACKAGES_FN_' requires that UNICODE be set to true or false in the root module");
        pub const QUERY_SECURITY_PACKAGE_INFO_FN_ = @compileError("'QUERY_SECURITY_PACKAGE_INFO_FN_' requires that UNICODE be set to true or false in the root module");
        pub const IMPORT_SECURITY_CONTEXT_FN_ = @compileError("'IMPORT_SECURITY_CONTEXT_FN_' requires that UNICODE be set to true or false in the root module");
        pub const SecurityFunctionTable = @compileError("'SecurityFunctionTable' requires that UNICODE be set to true or false in the root module");
        pub const INIT_SECURITY_INTERFACE_ = @compileError("'INIT_SECURITY_INTERFACE_' requires that UNICODE be set to true or false in the root module");
        pub const SEC_WINNT_AUTH_IDENTITY_EX = @compileError("'SEC_WINNT_AUTH_IDENTITY_EX' requires that UNICODE be set to true or false in the root module");
        pub const CREDENTIAL_ATTRIBUTE = @compileError("'CREDENTIAL_ATTRIBUTE' requires that UNICODE be set to true or false in the root module");
        pub const CREDENTIAL = @compileError("'CREDENTIAL' requires that UNICODE be set to true or false in the root module");
        pub const CREDENTIAL_TARGET_INFORMATION = @compileError("'CREDENTIAL_TARGET_INFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const CREDUI_INFO = @compileError("'CREDUI_INFO' requires that UNICODE be set to true or false in the root module");
        pub const CRYPT_PASSWORD_CREDENTIALS = @compileError("'CRYPT_PASSWORD_CREDENTIALS' requires that UNICODE be set to true or false in the root module");
        pub const SSL_EMPTY_CACHE_FN_ = @compileError("'SSL_EMPTY_CACHE_FN_' requires that UNICODE be set to true or false in the root module");
        pub const OBJECTS_AND_NAME_ = @compileError("'OBJECTS_AND_NAME_' requires that UNICODE be set to true or false in the root module");
        pub const TRUSTEE_ = @compileError("'TRUSTEE_' requires that UNICODE be set to true or false in the root module");
        pub const EXPLICIT_ACCESS_ = @compileError("'EXPLICIT_ACCESS_' requires that UNICODE be set to true or false in the root module");
        pub const TRUSTEE_ACCESS = @compileError("'TRUSTEE_ACCESS' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_ACCESS_INFO = @compileError("'ACTRL_ACCESS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const ACTRL_CONTROL_INFO = @compileError("'ACTRL_CONTROL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const INHERITED_FROM = @compileError("'INHERITED_FROM' requires that UNICODE be set to true or false in the root module");
        pub const SCARD_READERSTATE = @compileError("'SCARD_READERSTATE' requires that UNICODE be set to true or false in the root module");
        pub const LPOCNCONNPROC = @compileError("'LPOCNCONNPROC' requires that UNICODE be set to true or false in the root module");
        pub const OPENCARD_SEARCH_CRITERIA = @compileError("'OPENCARD_SEARCH_CRITERIA' requires that UNICODE be set to true or false in the root module");
        pub const OPENCARDNAME_EX = @compileError("'OPENCARDNAME_EX' requires that UNICODE be set to true or false in the root module");
        pub const OPENCARDNAME = @compileError("'OPENCARDNAME' requires that UNICODE be set to true or false in the root module");
        pub const CERT_SELECT_STRUCT_ = @compileError("'CERT_SELECT_STRUCT_' requires that UNICODE be set to true or false in the root module");
        pub const CERT_VIEWPROPERTIES_STRUCT_ = @compileError("'CERT_VIEWPROPERTIES_STRUCT_' requires that UNICODE be set to true or false in the root module");
        pub const CRYPTUI_VIEWCERTIFICATE_STRUCT = @compileError("'CRYPTUI_VIEWCERTIFICATE_STRUCT' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckAndAuditAlarm = @compileError("'AccessCheckAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeAndAuditAlarm = @compileError("'AccessCheckByTypeAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeResultListAndAuditAlarm = @compileError("'AccessCheckByTypeResultListAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = @compileError("'AccessCheckByTypeResultListAndAuditAlarmByHandle' requires that UNICODE be set to true or false in the root module");
        pub const ObjectOpenAuditAlarm = @compileError("'ObjectOpenAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectPrivilegeAuditAlarm = @compileError("'ObjectPrivilegeAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectCloseAuditAlarm = @compileError("'ObjectCloseAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectDeleteAuditAlarm = @compileError("'ObjectDeleteAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const PrivilegedServiceAuditAlarm = @compileError("'PrivilegedServiceAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const SetFileSecurity = @compileError("'SetFileSecurity' requires that UNICODE be set to true or false in the root module");
        pub const GetFileSecurity = @compileError("'GetFileSecurity' requires that UNICODE be set to true or false in the root module");
        pub const LookupAccountSid = @compileError("'LookupAccountSid' requires that UNICODE be set to true or false in the root module");
        pub const LookupAccountName = @compileError("'LookupAccountName' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeValue = @compileError("'LookupPrivilegeValue' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeName = @compileError("'LookupPrivilegeName' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeDisplayName = @compileError("'LookupPrivilegeDisplayName' requires that UNICODE be set to true or false in the root module");
        pub const LogonUser = @compileError("'LogonUser' requires that UNICODE be set to true or false in the root module");
        pub const LogonUserEx = @compileError("'LogonUserEx' requires that UNICODE be set to true or false in the root module");
        pub const ChangeServiceConfig2 = @compileError("'ChangeServiceConfig2' requires that UNICODE be set to true or false in the root module");
        pub const EnumDependentServices = @compileError("'EnumDependentServices' requires that UNICODE be set to true or false in the root module");
        pub const EnumServicesStatus = @compileError("'EnumServicesStatus' requires that UNICODE be set to true or false in the root module");
        pub const EnumServicesStatusEx = @compileError("'EnumServicesStatusEx' requires that UNICODE be set to true or false in the root module");
        pub const GetServiceKeyName = @compileError("'GetServiceKeyName' requires that UNICODE be set to true or false in the root module");
        pub const GetServiceDisplayName = @compileError("'GetServiceDisplayName' requires that UNICODE be set to true or false in the root module");
        pub const OpenSCManager = @compileError("'OpenSCManager' requires that UNICODE be set to true or false in the root module");
        pub const OpenService = @compileError("'OpenService' requires that UNICODE be set to true or false in the root module");
        pub const QueryServiceConfig = @compileError("'QueryServiceConfig' requires that UNICODE be set to true or false in the root module");
        pub const QueryServiceConfig2 = @compileError("'QueryServiceConfig2' requires that UNICODE be set to true or false in the root module");
        pub const QueryServiceLockStatus = @compileError("'QueryServiceLockStatus' requires that UNICODE be set to true or false in the root module");
        pub const RegisterServiceCtrlHandler = @compileError("'RegisterServiceCtrlHandler' requires that UNICODE be set to true or false in the root module");
        pub const RegisterServiceCtrlHandlerEx = @compileError("'RegisterServiceCtrlHandlerEx' requires that UNICODE be set to true or false in the root module");
        pub const StartServiceCtrlDispatcher = @compileError("'StartServiceCtrlDispatcher' requires that UNICODE be set to true or false in the root module");
        pub const StartService = @compileError("'StartService' requires that UNICODE be set to true or false in the root module");
        pub const NotifyServiceStatusChange = @compileError("'NotifyServiceStatusChange' requires that UNICODE be set to true or false in the root module");
        pub const ControlServiceEx = @compileError("'ControlServiceEx' requires that UNICODE be set to true or false in the root module");
        pub const AuditLookupCategoryName = @compileError("'AuditLookupCategoryName' requires that UNICODE be set to true or false in the root module");
        pub const AuditLookupSubCategoryName = @compileError("'AuditLookupSubCategoryName' requires that UNICODE be set to true or false in the root module");
        pub const AuditSetGlobalSacl = @compileError("'AuditSetGlobalSacl' requires that UNICODE be set to true or false in the root module");
        pub const AuditQueryGlobalSacl = @compileError("'AuditQueryGlobalSacl' requires that UNICODE be set to true or false in the root module");
        pub const AcquireCredentialsHandle = @compileError("'AcquireCredentialsHandle' requires that UNICODE be set to true or false in the root module");
        pub const AddCredentials = @compileError("'AddCredentials' requires that UNICODE be set to true or false in the root module");
        pub const ChangeAccountPassword = @compileError("'ChangeAccountPassword' requires that UNICODE be set to true or false in the root module");
        pub const InitializeSecurityContext = @compileError("'InitializeSecurityContext' requires that UNICODE be set to true or false in the root module");
        pub const QueryContextAttributes = @compileError("'QueryContextAttributes' requires that UNICODE be set to true or false in the root module");
        pub const QueryContextAttributesEx = @compileError("'QueryContextAttributesEx' requires that UNICODE be set to true or false in the root module");
        pub const SetContextAttributes = @compileError("'SetContextAttributes' requires that UNICODE be set to true or false in the root module");
        pub const QueryCredentialsAttributes = @compileError("'QueryCredentialsAttributes' requires that UNICODE be set to true or false in the root module");
        pub const QueryCredentialsAttributesEx = @compileError("'QueryCredentialsAttributesEx' requires that UNICODE be set to true or false in the root module");
        pub const SetCredentialsAttributes = @compileError("'SetCredentialsAttributes' requires that UNICODE be set to true or false in the root module");
        pub const EnumerateSecurityPackages = @compileError("'EnumerateSecurityPackages' requires that UNICODE be set to true or false in the root module");
        pub const QuerySecurityPackageInfo = @compileError("'QuerySecurityPackageInfo' requires that UNICODE be set to true or false in the root module");
        pub const ImportSecurityContext = @compileError("'ImportSecurityContext' requires that UNICODE be set to true or false in the root module");
        pub const InitSecurityInterface = @compileError("'InitSecurityInterface' requires that UNICODE be set to true or false in the root module");
        pub const SaslEnumerateProfiles = @compileError("'SaslEnumerateProfiles' requires that UNICODE be set to true or false in the root module");
        pub const SaslGetProfilePackage = @compileError("'SaslGetProfilePackage' requires that UNICODE be set to true or false in the root module");
        pub const SaslIdentifyPackage = @compileError("'SaslIdentifyPackage' requires that UNICODE be set to true or false in the root module");
        pub const SaslInitializeSecurityContext = @compileError("'SaslInitializeSecurityContext' requires that UNICODE be set to true or false in the root module");
        pub const SspiPromptForCredentials = @compileError("'SspiPromptForCredentials' requires that UNICODE be set to true or false in the root module");
        pub const AddSecurityPackage = @compileError("'AddSecurityPackage' requires that UNICODE be set to true or false in the root module");
        pub const DeleteSecurityPackage = @compileError("'DeleteSecurityPackage' requires that UNICODE be set to true or false in the root module");
        pub const CredWrite = @compileError("'CredWrite' requires that UNICODE be set to true or false in the root module");
        pub const CredRead = @compileError("'CredRead' requires that UNICODE be set to true or false in the root module");
        pub const CredEnumerate = @compileError("'CredEnumerate' requires that UNICODE be set to true or false in the root module");
        pub const CredWriteDomainCredentials = @compileError("'CredWriteDomainCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CredReadDomainCredentials = @compileError("'CredReadDomainCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CredDelete = @compileError("'CredDelete' requires that UNICODE be set to true or false in the root module");
        pub const CredRename = @compileError("'CredRename' requires that UNICODE be set to true or false in the root module");
        pub const CredGetTargetInfo = @compileError("'CredGetTargetInfo' requires that UNICODE be set to true or false in the root module");
        pub const CredMarshalCredential = @compileError("'CredMarshalCredential' requires that UNICODE be set to true or false in the root module");
        pub const CredUnmarshalCredential = @compileError("'CredUnmarshalCredential' requires that UNICODE be set to true or false in the root module");
        pub const CredIsMarshaledCredential = @compileError("'CredIsMarshaledCredential' requires that UNICODE be set to true or false in the root module");
        pub const CredUnPackAuthenticationBuffer = @compileError("'CredUnPackAuthenticationBuffer' requires that UNICODE be set to true or false in the root module");
        pub const CredPackAuthenticationBuffer = @compileError("'CredPackAuthenticationBuffer' requires that UNICODE be set to true or false in the root module");
        pub const CredProtect = @compileError("'CredProtect' requires that UNICODE be set to true or false in the root module");
        pub const CredUnprotect = @compileError("'CredUnprotect' requires that UNICODE be set to true or false in the root module");
        pub const CredIsProtected = @compileError("'CredIsProtected' requires that UNICODE be set to true or false in the root module");
        pub const CredFindBestCredential = @compileError("'CredFindBestCredential' requires that UNICODE be set to true or false in the root module");
        pub const CredUIPromptForCredentials = @compileError("'CredUIPromptForCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CredUIPromptForWindowsCredentials = @compileError("'CredUIPromptForWindowsCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CredUIParseUserName = @compileError("'CredUIParseUserName' requires that UNICODE be set to true or false in the root module");
        pub const CredUICmdLinePromptForCredentials = @compileError("'CredUICmdLinePromptForCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CredUIConfirmCredentials = @compileError("'CredUIConfirmCredentials' requires that UNICODE be set to true or false in the root module");
        pub const CryptAcquireContext = @compileError("'CryptAcquireContext' requires that UNICODE be set to true or false in the root module");
        pub const CryptSignHash = @compileError("'CryptSignHash' requires that UNICODE be set to true or false in the root module");
        pub const CryptVerifySignature = @compileError("'CryptVerifySignature' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProvider = @compileError("'CryptSetProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProviderEx = @compileError("'CryptSetProviderEx' requires that UNICODE be set to true or false in the root module");
        pub const CryptGetDefaultProvider = @compileError("'CryptGetDefaultProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviderTypes = @compileError("'CryptEnumProviderTypes' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviders = @compileError("'CryptEnumProviders' requires that UNICODE be set to true or false in the root module");
        pub const CertRDNValueToStr = @compileError("'CertRDNValueToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertNameToStr = @compileError("'CertNameToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertStrToName = @compileError("'CertStrToName' requires that UNICODE be set to true or false in the root module");
        pub const CertGetNameString = @compileError("'CertGetNameString' requires that UNICODE be set to true or false in the root module");
        pub const CertOpenSystemStore = @compileError("'CertOpenSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CertAddEncodedCertificateToSystemStore = @compileError("'CertAddEncodedCertificateToSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CryptRetrieveObjectByUrl = @compileError("'CryptRetrieveObjectByUrl' requires that UNICODE be set to true or false in the root module");
        pub const CryptStringToBinary = @compileError("'CryptStringToBinary' requires that UNICODE be set to true or false in the root module");
        pub const CryptBinaryToString = @compileError("'CryptBinaryToString' requires that UNICODE be set to true or false in the root module");
        pub const SslEmptyCache = @compileError("'SslEmptyCache' requires that UNICODE be set to true or false in the root module");
        pub const WNetSetLastError = @compileError("'WNetSetLastError' requires that UNICODE be set to true or false in the root module");
        pub const SCardListReaderGroups = @compileError("'SCardListReaderGroups' requires that UNICODE be set to true or false in the root module");
        pub const SCardListReaders = @compileError("'SCardListReaders' requires that UNICODE be set to true or false in the root module");
        pub const SCardListCards = @compileError("'SCardListCards' requires that UNICODE be set to true or false in the root module");
        pub const SCardListInterfaces = @compileError("'SCardListInterfaces' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetProviderId = @compileError("'SCardGetProviderId' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetCardTypeProviderName = @compileError("'SCardGetCardTypeProviderName' requires that UNICODE be set to true or false in the root module");
        pub const SCardIntroduceReaderGroup = @compileError("'SCardIntroduceReaderGroup' requires that UNICODE be set to true or false in the root module");
        pub const SCardForgetReaderGroup = @compileError("'SCardForgetReaderGroup' requires that UNICODE be set to true or false in the root module");
        pub const SCardIntroduceReader = @compileError("'SCardIntroduceReader' requires that UNICODE be set to true or false in the root module");
        pub const SCardForgetReader = @compileError("'SCardForgetReader' requires that UNICODE be set to true or false in the root module");
        pub const SCardAddReaderToGroup = @compileError("'SCardAddReaderToGroup' requires that UNICODE be set to true or false in the root module");
        pub const SCardRemoveReaderFromGroup = @compileError("'SCardRemoveReaderFromGroup' requires that UNICODE be set to true or false in the root module");
        pub const SCardIntroduceCardType = @compileError("'SCardIntroduceCardType' requires that UNICODE be set to true or false in the root module");
        pub const SCardSetCardTypeProviderName = @compileError("'SCardSetCardTypeProviderName' requires that UNICODE be set to true or false in the root module");
        pub const SCardForgetCardType = @compileError("'SCardForgetCardType' requires that UNICODE be set to true or false in the root module");
        pub const SCardLocateCards = @compileError("'SCardLocateCards' requires that UNICODE be set to true or false in the root module");
        pub const SCardLocateCardsByATR = @compileError("'SCardLocateCardsByATR' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetStatusChange = @compileError("'SCardGetStatusChange' requires that UNICODE be set to true or false in the root module");
        pub const SCardConnect = @compileError("'SCardConnect' requires that UNICODE be set to true or false in the root module");
        pub const SCardStatus = @compileError("'SCardStatus' requires that UNICODE be set to true or false in the root module");
        pub const SCardUIDlgSelectCard = @compileError("'SCardUIDlgSelectCard' requires that UNICODE be set to true or false in the root module");
        pub const GetOpenCardName = @compileError("'GetOpenCardName' requires that UNICODE be set to true or false in the root module");
        pub const SCardReadCache = @compileError("'SCardReadCache' requires that UNICODE be set to true or false in the root module");
        pub const SCardWriteCache = @compileError("'SCardWriteCache' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetReaderIcon = @compileError("'SCardGetReaderIcon' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetDeviceTypeId = @compileError("'SCardGetDeviceTypeId' requires that UNICODE be set to true or false in the root module");
        pub const SCardGetReaderDeviceInstanceId = @compileError("'SCardGetReaderDeviceInstanceId' requires that UNICODE be set to true or false in the root module");
        pub const SCardListReadersWithDeviceInstanceId = @compileError("'SCardListReadersWithDeviceInstanceId' requires that UNICODE be set to true or false in the root module");
        pub const SetEntriesInAcl = @compileError("'SetEntriesInAcl' requires that UNICODE be set to true or false in the root module");
        pub const GetExplicitEntriesFromAcl = @compileError("'GetExplicitEntriesFromAcl' requires that UNICODE be set to true or false in the root module");
        pub const GetEffectiveRightsFromAcl = @compileError("'GetEffectiveRightsFromAcl' requires that UNICODE be set to true or false in the root module");
        pub const GetAuditedPermissionsFromAcl = @compileError("'GetAuditedPermissionsFromAcl' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedSecurityInfo = @compileError("'GetNamedSecurityInfo' requires that UNICODE be set to true or false in the root module");
        pub const SetNamedSecurityInfo = @compileError("'SetNamedSecurityInfo' requires that UNICODE be set to true or false in the root module");
        pub const GetInheritanceSource = @compileError("'GetInheritanceSource' requires that UNICODE be set to true or false in the root module");
        pub const TreeResetNamedSecurityInfo = @compileError("'TreeResetNamedSecurityInfo' requires that UNICODE be set to true or false in the root module");
        pub const TreeSetNamedSecurityInfo = @compileError("'TreeSetNamedSecurityInfo' requires that UNICODE be set to true or false in the root module");
        pub const BuildSecurityDescriptor = @compileError("'BuildSecurityDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const LookupSecurityDescriptorParts = @compileError("'LookupSecurityDescriptorParts' requires that UNICODE be set to true or false in the root module");
        pub const BuildExplicitAccessWithName = @compileError("'BuildExplicitAccessWithName' requires that UNICODE be set to true or false in the root module");
        pub const BuildImpersonateExplicitAccessWithName = @compileError("'BuildImpersonateExplicitAccessWithName' requires that UNICODE be set to true or false in the root module");
        pub const BuildTrusteeWithName = @compileError("'BuildTrusteeWithName' requires that UNICODE be set to true or false in the root module");
        pub const BuildImpersonateTrustee = @compileError("'BuildImpersonateTrustee' requires that UNICODE be set to true or false in the root module");
        pub const BuildTrusteeWithSid = @compileError("'BuildTrusteeWithSid' requires that UNICODE be set to true or false in the root module");
        pub const BuildTrusteeWithObjectsAndSid = @compileError("'BuildTrusteeWithObjectsAndSid' requires that UNICODE be set to true or false in the root module");
        pub const BuildTrusteeWithObjectsAndName = @compileError("'BuildTrusteeWithObjectsAndName' requires that UNICODE be set to true or false in the root module");
        pub const GetTrusteeName = @compileError("'GetTrusteeName' requires that UNICODE be set to true or false in the root module");
        pub const GetTrusteeType = @compileError("'GetTrusteeType' requires that UNICODE be set to true or false in the root module");
        pub const GetTrusteeForm = @compileError("'GetTrusteeForm' requires that UNICODE be set to true or false in the root module");
        pub const GetMultipleTrusteeOperation = @compileError("'GetMultipleTrusteeOperation' requires that UNICODE be set to true or false in the root module");
        pub const GetMultipleTrustee = @compileError("'GetMultipleTrustee' requires that UNICODE be set to true or false in the root module");
        pub const ConvertSidToStringSid = @compileError("'ConvertSidToStringSid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertStringSidToSid = @compileError("'ConvertStringSidToSid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertStringSecurityDescriptorToSecurityDescriptor = @compileError("'ConvertStringSecurityDescriptorToSecurityDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const ConvertSecurityDescriptorToStringSecurityDescriptor = @compileError("'ConvertSecurityDescriptorToStringSecurityDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const CryptUIDlgViewCertificate = @compileError("'CryptUIDlgViewCertificate' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (52)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HKEY = @import("windows_programming.zig").HKEY;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const FILETIME = @import("windows_programming.zig").FILETIME;
const LM_OWF_PASSWORD = @import("password_management.zig").LM_OWF_PASSWORD;
const CHAR = @import("system_services.zig").CHAR;
const IDispatch = @import("automation.zig").IDispatch;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const HRESULT = @import("com.zig").HRESULT;
const OBJECT_ATTRIBUTES = @import("windows_programming.zig").OBJECT_ATTRIBUTES;
const IEnumUnknown = @import("com.zig").IEnumUnknown;
const SCARD_IO_REQUEST = @import("system_services.zig").SCARD_IO_REQUEST;
const BOOL = @import("system_services.zig").BOOL;
const LUID = @import("kernel.zig").LUID;
const SERVICE_ERROR = @import("system_services.zig").SERVICE_ERROR;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const DLGPROC = @import("windows_and_messaging.zig").DLGPROC;
const CERT_VIEWPROPERTIES_STRUCT_FLAGS = @import("system_services.zig").CERT_VIEWPROPERTIES_STRUCT_FLAGS;
const PROPSHEETPAGEW = @import("controls.zig").PROPSHEETPAGEW;
const PSPCB_MESSAGE = @import("controls.zig").PSPCB_MESSAGE;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const PROPERTYKEY = @import("windows_properties_system.zig").PROPERTYKEY;
const NET_RESOURCE_SCOPE = @import("windows_networking.zig").NET_RESOURCE_SCOPE;
const NET_USE_CONNECT_FLAGS = @import("windows_networking.zig").NET_USE_CONNECT_FLAGS;
const NET_RESOURCE_TYPE = @import("windows_networking.zig").NET_RESOURCE_TYPE;
const IPropertyStore = @import("audio.zig").IPropertyStore;
const HICON = @import("menus_and_resources.zig").HICON;
const PWSTR = @import("system_services.zig").PWSTR;
const IBindCtx = @import("com.zig").IBindCtx;
const HDESK = @import("windows_stations_and_desktops.zig").HDESK;
const DLGTEMPLATE = @import("windows_and_messaging.zig").DLGTEMPLATE;
const IUnknown = @import("com.zig").IUnknown;
const PROPSHEETPAGEA = @import("controls.zig").PROPSHEETPAGEA;
const LSTATUS = @import("system_services.zig").LSTATUS;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const LPTHREAD_START_ROUTINE = @import("system_services.zig").LPTHREAD_START_ROUTINE;
const PSTR = @import("system_services.zig").PSTR;
const HBITMAP = @import("gdi.zig").HBITMAP;
const PROPVARIANT = @import("structured_storage.zig").PROPVARIANT;
const HWND = @import("windows_and_messaging.zig").HWND;
const BSTR = @import("automation.zig").BSTR;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const CYPHER_BLOCK = @import("password_management.zig").CYPHER_BLOCK;
const VARIANT = @import("automation.zig").VARIANT;
const IDataObject = @import("com.zig").IDataObject;
const STRING = @import("windows_programming.zig").STRING;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const HANDLE = @import("system_services.zig").HANDLE;
const HPROPSHEETPAGE = @import("controls.zig").HPROPSHEETPAGE;
const SERVICE_START_TYPE = @import("system_services.zig").SERVICE_START_TYPE;
const REG_VALUE_TYPE = @import("windows_programming.zig").REG_VALUE_TYPE;
const NTSTATUS = @import("system_services.zig").NTSTATUS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PLSA_AP_CALL_PACKAGE_UNTRUSTED")) { _ = PLSA_AP_CALL_PACKAGE_UNTRUSTED; }
    if (@hasDecl(@This(), "SEC_THREAD_START")) { _ = SEC_THREAD_START; }
    if (@hasDecl(@This(), "SERVICE_MAIN_FUNCTIONW")) { _ = SERVICE_MAIN_FUNCTIONW; }
    if (@hasDecl(@This(), "SERVICE_MAIN_FUNCTIONA")) { _ = SERVICE_MAIN_FUNCTIONA; }
    if (@hasDecl(@This(), "LPSERVICE_MAIN_FUNCTIONW")) { _ = LPSERVICE_MAIN_FUNCTIONW; }
    if (@hasDecl(@This(), "LPSERVICE_MAIN_FUNCTIONA")) { _ = LPSERVICE_MAIN_FUNCTIONA; }
    if (@hasDecl(@This(), "HANDLER_FUNCTION")) { _ = HANDLER_FUNCTION; }
    if (@hasDecl(@This(), "HANDLER_FUNCTION_EX")) { _ = HANDLER_FUNCTION_EX; }
    if (@hasDecl(@This(), "LPHANDLER_FUNCTION")) { _ = LPHANDLER_FUNCTION; }
    if (@hasDecl(@This(), "LPHANDLER_FUNCTION_EX")) { _ = LPHANDLER_FUNCTION_EX; }
    if (@hasDecl(@This(), "PFN_SC_NOTIFY_CALLBACK")) { _ = PFN_SC_NOTIFY_CALLBACK; }
    if (@hasDecl(@This(), "PSC_NOTIFICATION_CALLBACK")) { _ = PSC_NOTIFICATION_CALLBACK; }
    if (@hasDecl(@This(), "PSAM_PASSWORD_NOTIFICATION_ROUTINE")) { _ = PSAM_PASSWORD_NOTIFICATION_ROUTINE; }
    if (@hasDecl(@This(), "PSAM_INIT_NOTIFICATION_ROUTINE")) { _ = PSAM_INIT_NOTIFICATION_ROUTINE; }
    if (@hasDecl(@This(), "PSAM_PASSWORD_FILTER_ROUTINE")) { _ = PSAM_PASSWORD_FILTER_ROUTINE; }
    if (@hasDecl(@This(), "SEC_GET_KEY_FN")) { _ = SEC_GET_KEY_FN; }
    if (@hasDecl(@This(), "ACQUIRE_CREDENTIALS_HANDLE_FN_W")) { _ = ACQUIRE_CREDENTIALS_HANDLE_FN_W; }
    if (@hasDecl(@This(), "ACQUIRE_CREDENTIALS_HANDLE_FN_A")) { _ = ACQUIRE_CREDENTIALS_HANDLE_FN_A; }
    if (@hasDecl(@This(), "FREE_CREDENTIALS_HANDLE_FN")) { _ = FREE_CREDENTIALS_HANDLE_FN; }
    if (@hasDecl(@This(), "ADD_CREDENTIALS_FN_W")) { _ = ADD_CREDENTIALS_FN_W; }
    if (@hasDecl(@This(), "ADD_CREDENTIALS_FN_A")) { _ = ADD_CREDENTIALS_FN_A; }
    if (@hasDecl(@This(), "CHANGE_PASSWORD_FN_W")) { _ = CHANGE_PASSWORD_FN_W; }
    if (@hasDecl(@This(), "CHANGE_PASSWORD_FN_A")) { _ = CHANGE_PASSWORD_FN_A; }
    if (@hasDecl(@This(), "INITIALIZE_SECURITY_CONTEXT_FN_W")) { _ = INITIALIZE_SECURITY_CONTEXT_FN_W; }
    if (@hasDecl(@This(), "INITIALIZE_SECURITY_CONTEXT_FN_A")) { _ = INITIALIZE_SECURITY_CONTEXT_FN_A; }
    if (@hasDecl(@This(), "ACCEPT_SECURITY_CONTEXT_FN")) { _ = ACCEPT_SECURITY_CONTEXT_FN; }
    if (@hasDecl(@This(), "COMPLETE_AUTH_TOKEN_FN")) { _ = COMPLETE_AUTH_TOKEN_FN; }
    if (@hasDecl(@This(), "IMPERSONATE_SECURITY_CONTEXT_FN")) { _ = IMPERSONATE_SECURITY_CONTEXT_FN; }
    if (@hasDecl(@This(), "REVERT_SECURITY_CONTEXT_FN")) { _ = REVERT_SECURITY_CONTEXT_FN; }
    if (@hasDecl(@This(), "QUERY_SECURITY_CONTEXT_TOKEN_FN")) { _ = QUERY_SECURITY_CONTEXT_TOKEN_FN; }
    if (@hasDecl(@This(), "DELETE_SECURITY_CONTEXT_FN")) { _ = DELETE_SECURITY_CONTEXT_FN; }
    if (@hasDecl(@This(), "APPLY_CONTROL_TOKEN_FN")) { _ = APPLY_CONTROL_TOKEN_FN; }
    if (@hasDecl(@This(), "QUERY_CONTEXT_ATTRIBUTES_FN_W")) { _ = QUERY_CONTEXT_ATTRIBUTES_FN_W; }
    if (@hasDecl(@This(), "QUERY_CONTEXT_ATTRIBUTES_EX_FN_W")) { _ = QUERY_CONTEXT_ATTRIBUTES_EX_FN_W; }
    if (@hasDecl(@This(), "QUERY_CONTEXT_ATTRIBUTES_FN_A")) { _ = QUERY_CONTEXT_ATTRIBUTES_FN_A; }
    if (@hasDecl(@This(), "QUERY_CONTEXT_ATTRIBUTES_EX_FN_A")) { _ = QUERY_CONTEXT_ATTRIBUTES_EX_FN_A; }
    if (@hasDecl(@This(), "SET_CONTEXT_ATTRIBUTES_FN_W")) { _ = SET_CONTEXT_ATTRIBUTES_FN_W; }
    if (@hasDecl(@This(), "SET_CONTEXT_ATTRIBUTES_FN_A")) { _ = SET_CONTEXT_ATTRIBUTES_FN_A; }
    if (@hasDecl(@This(), "QUERY_CREDENTIALS_ATTRIBUTES_FN_W")) { _ = QUERY_CREDENTIALS_ATTRIBUTES_FN_W; }
    if (@hasDecl(@This(), "QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W")) { _ = QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W; }
    if (@hasDecl(@This(), "QUERY_CREDENTIALS_ATTRIBUTES_FN_A")) { _ = QUERY_CREDENTIALS_ATTRIBUTES_FN_A; }
    if (@hasDecl(@This(), "QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A")) { _ = QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_A; }
    if (@hasDecl(@This(), "SET_CREDENTIALS_ATTRIBUTES_FN_W")) { _ = SET_CREDENTIALS_ATTRIBUTES_FN_W; }
    if (@hasDecl(@This(), "SET_CREDENTIALS_ATTRIBUTES_FN_A")) { _ = SET_CREDENTIALS_ATTRIBUTES_FN_A; }
    if (@hasDecl(@This(), "FREE_CONTEXT_BUFFER_FN")) { _ = FREE_CONTEXT_BUFFER_FN; }
    if (@hasDecl(@This(), "MAKE_SIGNATURE_FN")) { _ = MAKE_SIGNATURE_FN; }
    if (@hasDecl(@This(), "VERIFY_SIGNATURE_FN")) { _ = VERIFY_SIGNATURE_FN; }
    if (@hasDecl(@This(), "ENCRYPT_MESSAGE_FN")) { _ = ENCRYPT_MESSAGE_FN; }
    if (@hasDecl(@This(), "DECRYPT_MESSAGE_FN")) { _ = DECRYPT_MESSAGE_FN; }
    if (@hasDecl(@This(), "ENUMERATE_SECURITY_PACKAGES_FN_W")) { _ = ENUMERATE_SECURITY_PACKAGES_FN_W; }
    if (@hasDecl(@This(), "ENUMERATE_SECURITY_PACKAGES_FN_A")) { _ = ENUMERATE_SECURITY_PACKAGES_FN_A; }
    if (@hasDecl(@This(), "QUERY_SECURITY_PACKAGE_INFO_FN_W")) { _ = QUERY_SECURITY_PACKAGE_INFO_FN_W; }
    if (@hasDecl(@This(), "QUERY_SECURITY_PACKAGE_INFO_FN_A")) { _ = QUERY_SECURITY_PACKAGE_INFO_FN_A; }
    if (@hasDecl(@This(), "EXPORT_SECURITY_CONTEXT_FN")) { _ = EXPORT_SECURITY_CONTEXT_FN; }
    if (@hasDecl(@This(), "IMPORT_SECURITY_CONTEXT_FN_W")) { _ = IMPORT_SECURITY_CONTEXT_FN_W; }
    if (@hasDecl(@This(), "IMPORT_SECURITY_CONTEXT_FN_A")) { _ = IMPORT_SECURITY_CONTEXT_FN_A; }
    if (@hasDecl(@This(), "INIT_SECURITY_INTERFACE_A")) { _ = INIT_SECURITY_INTERFACE_A; }
    if (@hasDecl(@This(), "INIT_SECURITY_INTERFACE_W")) { _ = INIT_SECURITY_INTERFACE_W; }
    if (@hasDecl(@This(), "PLSA_CREATE_LOGON_SESSION")) { _ = PLSA_CREATE_LOGON_SESSION; }
    if (@hasDecl(@This(), "PLSA_DELETE_LOGON_SESSION")) { _ = PLSA_DELETE_LOGON_SESSION; }
    if (@hasDecl(@This(), "PLSA_ADD_CREDENTIAL")) { _ = PLSA_ADD_CREDENTIAL; }
    if (@hasDecl(@This(), "PLSA_GET_CREDENTIALS")) { _ = PLSA_GET_CREDENTIALS; }
    if (@hasDecl(@This(), "PLSA_DELETE_CREDENTIAL")) { _ = PLSA_DELETE_CREDENTIAL; }
    if (@hasDecl(@This(), "PLSA_ALLOCATE_LSA_HEAP")) { _ = PLSA_ALLOCATE_LSA_HEAP; }
    if (@hasDecl(@This(), "PLSA_FREE_LSA_HEAP")) { _ = PLSA_FREE_LSA_HEAP; }
    if (@hasDecl(@This(), "PLSA_ALLOCATE_PRIVATE_HEAP")) { _ = PLSA_ALLOCATE_PRIVATE_HEAP; }
    if (@hasDecl(@This(), "PLSA_FREE_PRIVATE_HEAP")) { _ = PLSA_FREE_PRIVATE_HEAP; }
    if (@hasDecl(@This(), "PLSA_ALLOCATE_CLIENT_BUFFER")) { _ = PLSA_ALLOCATE_CLIENT_BUFFER; }
    if (@hasDecl(@This(), "PLSA_FREE_CLIENT_BUFFER")) { _ = PLSA_FREE_CLIENT_BUFFER; }
    if (@hasDecl(@This(), "PLSA_COPY_TO_CLIENT_BUFFER")) { _ = PLSA_COPY_TO_CLIENT_BUFFER; }
    if (@hasDecl(@This(), "PLSA_COPY_FROM_CLIENT_BUFFER")) { _ = PLSA_COPY_FROM_CLIENT_BUFFER; }
    if (@hasDecl(@This(), "PLSA_AP_INITIALIZE_PACKAGE")) { _ = PLSA_AP_INITIALIZE_PACKAGE; }
    if (@hasDecl(@This(), "PLSA_AP_LOGON_USER")) { _ = PLSA_AP_LOGON_USER; }
    if (@hasDecl(@This(), "PLSA_AP_LOGON_USER_EX")) { _ = PLSA_AP_LOGON_USER_EX; }
    if (@hasDecl(@This(), "PLSA_AP_CALL_PACKAGE")) { _ = PLSA_AP_CALL_PACKAGE; }
    if (@hasDecl(@This(), "PLSA_AP_CALL_PACKAGE_PASSTHROUGH")) { _ = PLSA_AP_CALL_PACKAGE_PASSTHROUGH; }
    if (@hasDecl(@This(), "PLSA_AP_LOGON_TERMINATED")) { _ = PLSA_AP_LOGON_TERMINATED; }
    if (@hasDecl(@This(), "PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE")) { _ = PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE; }
    if (@hasDecl(@This(), "PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE")) { _ = PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE; }
    if (@hasDecl(@This(), "PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE")) { _ = PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE; }
    if (@hasDecl(@This(), "PSAM_CREDENTIAL_UPDATE_REGISTER_MAPPED_ENTRYPOINTS_ROUTINE")) { _ = PSAM_CREDENTIAL_UPDATE_REGISTER_MAPPED_ENTRYPOINTS_ROUTINE; }
    if (@hasDecl(@This(), "PLSA_CALLBACK_FUNCTION")) { _ = PLSA_CALLBACK_FUNCTION; }
    if (@hasDecl(@This(), "PLSA_REDIRECTED_LOGON_INIT")) { _ = PLSA_REDIRECTED_LOGON_INIT; }
    if (@hasDecl(@This(), "PLSA_REDIRECTED_LOGON_CALLBACK")) { _ = PLSA_REDIRECTED_LOGON_CALLBACK; }
    if (@hasDecl(@This(), "PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK")) { _ = PLSA_REDIRECTED_LOGON_CLEANUP_CALLBACK; }
    if (@hasDecl(@This(), "PLSA_REDIRECTED_LOGON_GET_LOGON_CREDS")) { _ = PLSA_REDIRECTED_LOGON_GET_LOGON_CREDS; }
    if (@hasDecl(@This(), "PLSA_REDIRECTED_LOGON_GET_SUPP_CREDS")) { _ = PLSA_REDIRECTED_LOGON_GET_SUPP_CREDS; }
    if (@hasDecl(@This(), "PLSA_IMPERSONATE_CLIENT")) { _ = PLSA_IMPERSONATE_CLIENT; }
    if (@hasDecl(@This(), "PLSA_UNLOAD_PACKAGE")) { _ = PLSA_UNLOAD_PACKAGE; }
    if (@hasDecl(@This(), "PLSA_DUPLICATE_HANDLE")) { _ = PLSA_DUPLICATE_HANDLE; }
    if (@hasDecl(@This(), "PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS")) { _ = PLSA_SAVE_SUPPLEMENTAL_CREDENTIALS; }
    if (@hasDecl(@This(), "PLSA_CREATE_THREAD")) { _ = PLSA_CREATE_THREAD; }
    if (@hasDecl(@This(), "PLSA_GET_CLIENT_INFO")) { _ = PLSA_GET_CLIENT_INFO; }
    if (@hasDecl(@This(), "PLSA_REGISTER_NOTIFICATION")) { _ = PLSA_REGISTER_NOTIFICATION; }
    if (@hasDecl(@This(), "PLSA_CANCEL_NOTIFICATION")) { _ = PLSA_CANCEL_NOTIFICATION; }
    if (@hasDecl(@This(), "PLSA_MAP_BUFFER")) { _ = PLSA_MAP_BUFFER; }
    if (@hasDecl(@This(), "PLSA_CREATE_TOKEN")) { _ = PLSA_CREATE_TOKEN; }
    if (@hasDecl(@This(), "PLSA_CREATE_TOKEN_EX")) { _ = PLSA_CREATE_TOKEN_EX; }
    if (@hasDecl(@This(), "PLSA_AUDIT_LOGON")) { _ = PLSA_AUDIT_LOGON; }
    if (@hasDecl(@This(), "PLSA_CALL_PACKAGE")) { _ = PLSA_CALL_PACKAGE; }
    if (@hasDecl(@This(), "PLSA_CALL_PACKAGEEX")) { _ = PLSA_CALL_PACKAGEEX; }
    if (@hasDecl(@This(), "PLSA_CALL_PACKAGE_PASSTHROUGH")) { _ = PLSA_CALL_PACKAGE_PASSTHROUGH; }
    if (@hasDecl(@This(), "PLSA_GET_CALL_INFO")) { _ = PLSA_GET_CALL_INFO; }
    if (@hasDecl(@This(), "PLSA_CREATE_SHARED_MEMORY")) { _ = PLSA_CREATE_SHARED_MEMORY; }
    if (@hasDecl(@This(), "PLSA_ALLOCATE_SHARED_MEMORY")) { _ = PLSA_ALLOCATE_SHARED_MEMORY; }
    if (@hasDecl(@This(), "PLSA_FREE_SHARED_MEMORY")) { _ = PLSA_FREE_SHARED_MEMORY; }
    if (@hasDecl(@This(), "PLSA_DELETE_SHARED_MEMORY")) { _ = PLSA_DELETE_SHARED_MEMORY; }
    if (@hasDecl(@This(), "PLSA_GET_APP_MODE_INFO")) { _ = PLSA_GET_APP_MODE_INFO; }
    if (@hasDecl(@This(), "PLSA_SET_APP_MODE_INFO")) { _ = PLSA_SET_APP_MODE_INFO; }
    if (@hasDecl(@This(), "PLSA_OPEN_SAM_USER")) { _ = PLSA_OPEN_SAM_USER; }
    if (@hasDecl(@This(), "PLSA_GET_USER_CREDENTIALS")) { _ = PLSA_GET_USER_CREDENTIALS; }
    if (@hasDecl(@This(), "PLSA_GET_USER_AUTH_DATA")) { _ = PLSA_GET_USER_AUTH_DATA; }
    if (@hasDecl(@This(), "PLSA_CLOSE_SAM_USER")) { _ = PLSA_CLOSE_SAM_USER; }
    if (@hasDecl(@This(), "PLSA_GET_AUTH_DATA_FOR_USER")) { _ = PLSA_GET_AUTH_DATA_FOR_USER; }
    if (@hasDecl(@This(), "PLSA_CONVERT_AUTH_DATA_TO_TOKEN")) { _ = PLSA_CONVERT_AUTH_DATA_TO_TOKEN; }
    if (@hasDecl(@This(), "PLSA_CRACK_SINGLE_NAME")) { _ = PLSA_CRACK_SINGLE_NAME; }
    if (@hasDecl(@This(), "PLSA_AUDIT_ACCOUNT_LOGON")) { _ = PLSA_AUDIT_ACCOUNT_LOGON; }
    if (@hasDecl(@This(), "PLSA_CLIENT_CALLBACK")) { _ = PLSA_CLIENT_CALLBACK; }
    if (@hasDecl(@This(), "PLSA_REGISTER_CALLBACK")) { _ = PLSA_REGISTER_CALLBACK; }
    if (@hasDecl(@This(), "PLSA_GET_EXTENDED_CALL_FLAGS")) { _ = PLSA_GET_EXTENDED_CALL_FLAGS; }
    if (@hasDecl(@This(), "PLSA_UPDATE_PRIMARY_CREDENTIALS")) { _ = PLSA_UPDATE_PRIMARY_CREDENTIALS; }
    if (@hasDecl(@This(), "PLSA_PROTECT_MEMORY")) { _ = PLSA_PROTECT_MEMORY; }
    if (@hasDecl(@This(), "PLSA_OPEN_TOKEN_BY_LOGON_ID")) { _ = PLSA_OPEN_TOKEN_BY_LOGON_ID; }
    if (@hasDecl(@This(), "PLSA_EXPAND_AUTH_DATA_FOR_DOMAIN")) { _ = PLSA_EXPAND_AUTH_DATA_FOR_DOMAIN; }
    if (@hasDecl(@This(), "PLSA_GET_SERVICE_ACCOUNT_PASSWORD")) { _ = PLSA_GET_SERVICE_ACCOUNT_PASSWORD; }
    if (@hasDecl(@This(), "PLSA_AUDIT_LOGON_EX")) { _ = PLSA_AUDIT_LOGON_EX; }
    if (@hasDecl(@This(), "PLSA_CHECK_PROTECTED_USER_BY_TOKEN")) { _ = PLSA_CHECK_PROTECTED_USER_BY_TOKEN; }
    if (@hasDecl(@This(), "PLSA_QUERY_CLIENT_REQUEST")) { _ = PLSA_QUERY_CLIENT_REQUEST; }
    if (@hasDecl(@This(), "CredReadFn")) { _ = CredReadFn; }
    if (@hasDecl(@This(), "CredReadDomainCredentialsFn")) { _ = CredReadDomainCredentialsFn; }
    if (@hasDecl(@This(), "CredFreeCredentialsFn")) { _ = CredFreeCredentialsFn; }
    if (@hasDecl(@This(), "CredWriteFn")) { _ = CredWriteFn; }
    if (@hasDecl(@This(), "CrediUnmarshalandDecodeStringFn")) { _ = CrediUnmarshalandDecodeStringFn; }
    if (@hasDecl(@This(), "PLSA_LOCATE_PKG_BY_ID")) { _ = PLSA_LOCATE_PKG_BY_ID; }
    if (@hasDecl(@This(), "SpInitializeFn")) { _ = SpInitializeFn; }
    if (@hasDecl(@This(), "SpShutdownFn")) { _ = SpShutdownFn; }
    if (@hasDecl(@This(), "SpGetInfoFn")) { _ = SpGetInfoFn; }
    if (@hasDecl(@This(), "SpGetExtendedInformationFn")) { _ = SpGetExtendedInformationFn; }
    if (@hasDecl(@This(), "SpSetExtendedInformationFn")) { _ = SpSetExtendedInformationFn; }
    if (@hasDecl(@This(), "PLSA_AP_LOGON_USER_EX2")) { _ = PLSA_AP_LOGON_USER_EX2; }
    if (@hasDecl(@This(), "PLSA_AP_LOGON_USER_EX3")) { _ = PLSA_AP_LOGON_USER_EX3; }
    if (@hasDecl(@This(), "PLSA_AP_PRE_LOGON_USER_SURROGATE")) { _ = PLSA_AP_PRE_LOGON_USER_SURROGATE; }
    if (@hasDecl(@This(), "PLSA_AP_POST_LOGON_USER_SURROGATE")) { _ = PLSA_AP_POST_LOGON_USER_SURROGATE; }
    if (@hasDecl(@This(), "SpAcceptCredentialsFn")) { _ = SpAcceptCredentialsFn; }
    if (@hasDecl(@This(), "SpAcquireCredentialsHandleFn")) { _ = SpAcquireCredentialsHandleFn; }
    if (@hasDecl(@This(), "SpFreeCredentialsHandleFn")) { _ = SpFreeCredentialsHandleFn; }
    if (@hasDecl(@This(), "SpQueryCredentialsAttributesFn")) { _ = SpQueryCredentialsAttributesFn; }
    if (@hasDecl(@This(), "SpSetCredentialsAttributesFn")) { _ = SpSetCredentialsAttributesFn; }
    if (@hasDecl(@This(), "SpAddCredentialsFn")) { _ = SpAddCredentialsFn; }
    if (@hasDecl(@This(), "SpSaveCredentialsFn")) { _ = SpSaveCredentialsFn; }
    if (@hasDecl(@This(), "SpGetCredentialsFn")) { _ = SpGetCredentialsFn; }
    if (@hasDecl(@This(), "SpDeleteCredentialsFn")) { _ = SpDeleteCredentialsFn; }
    if (@hasDecl(@This(), "SpInitLsaModeContextFn")) { _ = SpInitLsaModeContextFn; }
    if (@hasDecl(@This(), "SpDeleteContextFn")) { _ = SpDeleteContextFn; }
    if (@hasDecl(@This(), "SpApplyControlTokenFn")) { _ = SpApplyControlTokenFn; }
    if (@hasDecl(@This(), "SpAcceptLsaModeContextFn")) { _ = SpAcceptLsaModeContextFn; }
    if (@hasDecl(@This(), "SpGetUserInfoFn")) { _ = SpGetUserInfoFn; }
    if (@hasDecl(@This(), "SpQueryContextAttributesFn")) { _ = SpQueryContextAttributesFn; }
    if (@hasDecl(@This(), "SpSetContextAttributesFn")) { _ = SpSetContextAttributesFn; }
    if (@hasDecl(@This(), "SpChangeAccountPasswordFn")) { _ = SpChangeAccountPasswordFn; }
    if (@hasDecl(@This(), "SpQueryMetaDataFn")) { _ = SpQueryMetaDataFn; }
    if (@hasDecl(@This(), "SpExchangeMetaDataFn")) { _ = SpExchangeMetaDataFn; }
    if (@hasDecl(@This(), "SpGetCredUIContextFn")) { _ = SpGetCredUIContextFn; }
    if (@hasDecl(@This(), "SpUpdateCredentialsFn")) { _ = SpUpdateCredentialsFn; }
    if (@hasDecl(@This(), "SpValidateTargetInfoFn")) { _ = SpValidateTargetInfoFn; }
    if (@hasDecl(@This(), "LSA_AP_POST_LOGON_USER")) { _ = LSA_AP_POST_LOGON_USER; }
    if (@hasDecl(@This(), "SpGetRemoteCredGuardLogonBufferFn")) { _ = SpGetRemoteCredGuardLogonBufferFn; }
    if (@hasDecl(@This(), "SpGetRemoteCredGuardSupplementalCredsFn")) { _ = SpGetRemoteCredGuardSupplementalCredsFn; }
    if (@hasDecl(@This(), "SpGetTbalSupplementalCredsFn")) { _ = SpGetTbalSupplementalCredsFn; }
    if (@hasDecl(@This(), "SpInstanceInitFn")) { _ = SpInstanceInitFn; }
    if (@hasDecl(@This(), "SpInitUserModeContextFn")) { _ = SpInitUserModeContextFn; }
    if (@hasDecl(@This(), "SpMakeSignatureFn")) { _ = SpMakeSignatureFn; }
    if (@hasDecl(@This(), "SpVerifySignatureFn")) { _ = SpVerifySignatureFn; }
    if (@hasDecl(@This(), "SpSealMessageFn")) { _ = SpSealMessageFn; }
    if (@hasDecl(@This(), "SpUnsealMessageFn")) { _ = SpUnsealMessageFn; }
    if (@hasDecl(@This(), "SpGetContextTokenFn")) { _ = SpGetContextTokenFn; }
    if (@hasDecl(@This(), "SpExportSecurityContextFn")) { _ = SpExportSecurityContextFn; }
    if (@hasDecl(@This(), "SpImportSecurityContextFn")) { _ = SpImportSecurityContextFn; }
    if (@hasDecl(@This(), "SpCompleteAuthTokenFn")) { _ = SpCompleteAuthTokenFn; }
    if (@hasDecl(@This(), "SpFormatCredentialsFn")) { _ = SpFormatCredentialsFn; }
    if (@hasDecl(@This(), "SpMarshallSupplementalCredsFn")) { _ = SpMarshallSupplementalCredsFn; }
    if (@hasDecl(@This(), "SpLsaModeInitializeFn")) { _ = SpLsaModeInitializeFn; }
    if (@hasDecl(@This(), "SpUserModeInitializeFn")) { _ = SpUserModeInitializeFn; }
    if (@hasDecl(@This(), "PKSEC_CREATE_CONTEXT_LIST")) { _ = PKSEC_CREATE_CONTEXT_LIST; }
    if (@hasDecl(@This(), "PKSEC_INSERT_LIST_ENTRY")) { _ = PKSEC_INSERT_LIST_ENTRY; }
    if (@hasDecl(@This(), "PKSEC_REFERENCE_LIST_ENTRY")) { _ = PKSEC_REFERENCE_LIST_ENTRY; }
    if (@hasDecl(@This(), "PKSEC_DEREFERENCE_LIST_ENTRY")) { _ = PKSEC_DEREFERENCE_LIST_ENTRY; }
    if (@hasDecl(@This(), "PKSEC_SERIALIZE_WINNT_AUTH_DATA")) { _ = PKSEC_SERIALIZE_WINNT_AUTH_DATA; }
    if (@hasDecl(@This(), "PKSEC_SERIALIZE_SCHANNEL_AUTH_DATA")) { _ = PKSEC_SERIALIZE_SCHANNEL_AUTH_DATA; }
    if (@hasDecl(@This(), "PKSEC_LOCATE_PKG_BY_ID")) { _ = PKSEC_LOCATE_PKG_BY_ID; }
    if (@hasDecl(@This(), "KspInitPackageFn")) { _ = KspInitPackageFn; }
    if (@hasDecl(@This(), "KspDeleteContextFn")) { _ = KspDeleteContextFn; }
    if (@hasDecl(@This(), "KspInitContextFn")) { _ = KspInitContextFn; }
    if (@hasDecl(@This(), "KspMakeSignatureFn")) { _ = KspMakeSignatureFn; }
    if (@hasDecl(@This(), "KspVerifySignatureFn")) { _ = KspVerifySignatureFn; }
    if (@hasDecl(@This(), "KspSealMessageFn")) { _ = KspSealMessageFn; }
    if (@hasDecl(@This(), "KspUnsealMessageFn")) { _ = KspUnsealMessageFn; }
    if (@hasDecl(@This(), "KspGetTokenFn")) { _ = KspGetTokenFn; }
    if (@hasDecl(@This(), "KspQueryAttributesFn")) { _ = KspQueryAttributesFn; }
    if (@hasDecl(@This(), "KspCompleteTokenFn")) { _ = KspCompleteTokenFn; }
    if (@hasDecl(@This(), "KspMapHandleFn")) { _ = KspMapHandleFn; }
    if (@hasDecl(@This(), "KspSetPagingModeFn")) { _ = KspSetPagingModeFn; }
    if (@hasDecl(@This(), "KspSerializeAuthDataFn")) { _ = KspSerializeAuthDataFn; }
    if (@hasDecl(@This(), "PFN_NCRYPT_ALLOC")) { _ = PFN_NCRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_NCRYPT_FREE")) { _ = PFN_NCRYPT_FREE; }
    if (@hasDecl(@This(), "PCRYPT_DECRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_DECRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_RESOLVE_HCRYPTPROV_FUNC")) { _ = PCRYPT_RESOLVE_HCRYPTPROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ALLOC")) { _ = PFN_CRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_CRYPT_FREE")) { _ = PFN_CRYPT_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_FUNC")) { _ = PFN_CRYPT_ENUM_OID_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_INFO")) { _ = PFN_CRYPT_ENUM_OID_INFO; }
    if (@hasDecl(@This(), "PFN_CMSG_STREAM_OUTPUT")) { _ = PFN_CMSG_STREAM_OUTPUT; }
    if (@hasDecl(@This(), "PFN_CMSG_ALLOC")) { _ = PFN_CMSG_ALLOC; }
    if (@hasDecl(@This(), "PFN_CMSG_FREE")) { _ = PFN_CMSG_FREE; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_EXPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_IMPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_TRANS")) { _ = PFN_CMSG_EXPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_AGREE")) { _ = PFN_CMSG_EXPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_MAIL_LIST")) { _ = PFN_CMSG_EXPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_MAIL_LIST")) { _ = PFN_CMSG_IMPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_CNG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_CNG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CERT_DLL_OPEN_STORE_PROV_FUNC")) { _ = PFN_CERT_DLL_OPEN_STORE_PROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CLOSE")) { _ = PFN_CERT_STORE_PROV_CLOSE; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CERT")) { _ = PFN_CERT_STORE_PROV_READ_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CERT")) { _ = PFN_CERT_STORE_PROV_WRITE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CERT")) { _ = PFN_CERT_STORE_PROV_DELETE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CRL")) { _ = PFN_CERT_STORE_PROV_READ_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CRL")) { _ = PFN_CERT_STORE_PROV_WRITE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CRL")) { _ = PFN_CERT_STORE_PROV_DELETE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CTL")) { _ = PFN_CERT_STORE_PROV_READ_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CTL")) { _ = PFN_CERT_STORE_PROV_WRITE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CTL")) { _ = PFN_CERT_STORE_PROV_DELETE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CONTROL")) { _ = PFN_CERT_STORE_PROV_CONTROL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_CREATE_CONTEXT_SORT_FUNC")) { _ = PFN_CERT_CREATE_CONTEXT_SORT_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE_LOCATION")) { _ = PFN_CERT_ENUM_SYSTEM_STORE_LOCATION; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE")) { _ = PFN_CERT_ENUM_SYSTEM_STORE; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_PHYSICAL_STORE")) { _ = PFN_CERT_ENUM_PHYSICAL_STORE; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC")) { _ = PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC")) { _ = PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC")) { _ = PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PRIV_KEY_FUNC")) { _ = PFN_IMPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_EXPORT_PRIV_KEY_FUNC")) { _ = PFN_EXPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_GET_SIGNER_CERTIFICATE")) { _ = PFN_CRYPT_GET_SIGNER_CERTIFICATE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_PARAM_FREE_FUNC")) { _ = PFN_CRYPT_ASYNC_PARAM_FREE_FUNC; }
    if (@hasDecl(@This(), "PFN_FREE_ENCODED_OBJECT_FUNC")) { _ = PFN_FREE_ENCODED_OBJECT_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_CANCEL_RETRIEVAL")) { _ = PFN_CRYPT_CANCEL_RETRIEVAL; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC")) { _ = PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC; }
    if (@hasDecl(@This(), "PFN_CANCEL_ASYNC_RETRIEVAL_FUNC")) { _ = PFN_CANCEL_ASYNC_RETRIEVAL_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_KEYID_PROP")) { _ = PFN_CRYPT_ENUM_KEYID_PROP; }
    if (@hasDecl(@This(), "PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK")) { _ = PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK")) { _ = PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE; }
    if (@hasDecl(@This(), "PFN_CERT_IS_WEAK_HASH")) { _ = PFN_CERT_IS_WEAK_HASH; }
    if (@hasDecl(@This(), "SSL_EMPTY_CACHE_FN_A")) { _ = SSL_EMPTY_CACHE_FN_A; }
    if (@hasDecl(@This(), "SSL_EMPTY_CACHE_FN_W")) { _ = SSL_EMPTY_CACHE_FN_W; }
    if (@hasDecl(@This(), "SSL_CRACK_CERTIFICATE_FN")) { _ = SSL_CRACK_CERTIFICATE_FN; }
    if (@hasDecl(@This(), "SSL_FREE_CERTIFICATE_FN")) { _ = SSL_FREE_CERTIFICATE_FN; }
    if (@hasDecl(@This(), "SslGetServerIdentityFn")) { _ = SslGetServerIdentityFn; }
    if (@hasDecl(@This(), "SslGetExtensionsFn")) { _ = SslGetExtensionsFn; }
    if (@hasDecl(@This(), "PWLX_USE_CTRL_ALT_DEL")) { _ = PWLX_USE_CTRL_ALT_DEL; }
    if (@hasDecl(@This(), "PWLX_SET_CONTEXT_POINTER")) { _ = PWLX_SET_CONTEXT_POINTER; }
    if (@hasDecl(@This(), "PWLX_SAS_NOTIFY")) { _ = PWLX_SAS_NOTIFY; }
    if (@hasDecl(@This(), "PWLX_SET_TIMEOUT")) { _ = PWLX_SET_TIMEOUT; }
    if (@hasDecl(@This(), "PWLX_ASSIGN_SHELL_PROTECTION")) { _ = PWLX_ASSIGN_SHELL_PROTECTION; }
    if (@hasDecl(@This(), "PWLX_MESSAGE_BOX")) { _ = PWLX_MESSAGE_BOX; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX")) { _ = PWLX_DIALOG_BOX; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_INDIRECT")) { _ = PWLX_DIALOG_BOX_INDIRECT; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_PARAM")) { _ = PWLX_DIALOG_BOX_PARAM; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_INDIRECT_PARAM")) { _ = PWLX_DIALOG_BOX_INDIRECT_PARAM; }
    if (@hasDecl(@This(), "PWLX_SWITCH_DESKTOP_TO_USER")) { _ = PWLX_SWITCH_DESKTOP_TO_USER; }
    if (@hasDecl(@This(), "PWLX_SWITCH_DESKTOP_TO_WINLOGON")) { _ = PWLX_SWITCH_DESKTOP_TO_WINLOGON; }
    if (@hasDecl(@This(), "PWLX_CHANGE_PASSWORD_NOTIFY")) { _ = PWLX_CHANGE_PASSWORD_NOTIFY; }
    if (@hasDecl(@This(), "PWLX_GET_SOURCE_DESKTOP")) { _ = PWLX_GET_SOURCE_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_SET_RETURN_DESKTOP")) { _ = PWLX_SET_RETURN_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_CREATE_USER_DESKTOP")) { _ = PWLX_CREATE_USER_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_CHANGE_PASSWORD_NOTIFY_EX")) { _ = PWLX_CHANGE_PASSWORD_NOTIFY_EX; }
    if (@hasDecl(@This(), "PWLX_CLOSE_USER_DESKTOP")) { _ = PWLX_CLOSE_USER_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_SET_OPTION")) { _ = PWLX_SET_OPTION; }
    if (@hasDecl(@This(), "PWLX_GET_OPTION")) { _ = PWLX_GET_OPTION; }
    if (@hasDecl(@This(), "PWLX_WIN31_MIGRATE")) { _ = PWLX_WIN31_MIGRATE; }
    if (@hasDecl(@This(), "PWLX_QUERY_CLIENT_CREDENTIALS")) { _ = PWLX_QUERY_CLIENT_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_QUERY_IC_CREDENTIALS")) { _ = PWLX_QUERY_IC_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_QUERY_TS_LOGON_CREDENTIALS")) { _ = PWLX_QUERY_TS_LOGON_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_DISCONNECT")) { _ = PWLX_DISCONNECT; }
    if (@hasDecl(@This(), "PWLX_QUERY_TERMINAL_SERVICES_DATA")) { _ = PWLX_QUERY_TERMINAL_SERVICES_DATA; }
    if (@hasDecl(@This(), "PWLX_QUERY_CONSOLESWITCH_CREDENTIALS")) { _ = PWLX_QUERY_CONSOLESWITCH_CREDENTIALS; }
    if (@hasDecl(@This(), "PFNMSGECALLBACK")) { _ = PFNMSGECALLBACK; }
    if (@hasDecl(@This(), "PF_NPAddConnection")) { _ = PF_NPAddConnection; }
    if (@hasDecl(@This(), "PF_NPAddConnection3")) { _ = PF_NPAddConnection3; }
    if (@hasDecl(@This(), "PF_NPAddConnection4")) { _ = PF_NPAddConnection4; }
    if (@hasDecl(@This(), "PF_NPCancelConnection")) { _ = PF_NPCancelConnection; }
    if (@hasDecl(@This(), "PF_NPGetConnection")) { _ = PF_NPGetConnection; }
    if (@hasDecl(@This(), "PF_NPGetConnection3")) { _ = PF_NPGetConnection3; }
    if (@hasDecl(@This(), "PF_NPGetUniversalName")) { _ = PF_NPGetUniversalName; }
    if (@hasDecl(@This(), "PF_NPGetConnectionPerformance")) { _ = PF_NPGetConnectionPerformance; }
    if (@hasDecl(@This(), "PF_NPOpenEnum")) { _ = PF_NPOpenEnum; }
    if (@hasDecl(@This(), "PF_NPEnumResource")) { _ = PF_NPEnumResource; }
    if (@hasDecl(@This(), "PF_NPCloseEnum")) { _ = PF_NPCloseEnum; }
    if (@hasDecl(@This(), "PF_NPGetCaps")) { _ = PF_NPGetCaps; }
    if (@hasDecl(@This(), "PF_NPGetUser")) { _ = PF_NPGetUser; }
    if (@hasDecl(@This(), "PF_NPGetPersistentUseOptionsForConnection")) { _ = PF_NPGetPersistentUseOptionsForConnection; }
    if (@hasDecl(@This(), "PF_NPDeviceMode")) { _ = PF_NPDeviceMode; }
    if (@hasDecl(@This(), "PF_NPSearchDialog")) { _ = PF_NPSearchDialog; }
    if (@hasDecl(@This(), "PF_NPGetResourceParent")) { _ = PF_NPGetResourceParent; }
    if (@hasDecl(@This(), "PF_NPGetResourceInformation")) { _ = PF_NPGetResourceInformation; }
    if (@hasDecl(@This(), "PF_NPFormatNetworkName")) { _ = PF_NPFormatNetworkName; }
    if (@hasDecl(@This(), "PF_NPGetPropertyText")) { _ = PF_NPGetPropertyText; }
    if (@hasDecl(@This(), "PF_NPPropertyDialog")) { _ = PF_NPPropertyDialog; }
    if (@hasDecl(@This(), "PF_NPGetDirectoryType")) { _ = PF_NPGetDirectoryType; }
    if (@hasDecl(@This(), "PF_NPDirectoryNotify")) { _ = PF_NPDirectoryNotify; }
    if (@hasDecl(@This(), "PF_NPLogonNotify")) { _ = PF_NPLogonNotify; }
    if (@hasDecl(@This(), "PF_NPPasswordChangeNotify")) { _ = PF_NPPasswordChangeNotify; }
    if (@hasDecl(@This(), "PF_AddConnectNotify")) { _ = PF_AddConnectNotify; }
    if (@hasDecl(@This(), "PF_CancelConnectNotify")) { _ = PF_CancelConnectNotify; }
    if (@hasDecl(@This(), "PF_NPFMXGetPermCaps")) { _ = PF_NPFMXGetPermCaps; }
    if (@hasDecl(@This(), "PF_NPFMXEditPerm")) { _ = PF_NPFMXEditPerm; }
    if (@hasDecl(@This(), "PF_NPFMXGetPermHelp")) { _ = PF_NPFMXGetPermHelp; }
    if (@hasDecl(@This(), "LPOCNCONNPROCA")) { _ = LPOCNCONNPROCA; }
    if (@hasDecl(@This(), "LPOCNCONNPROCW")) { _ = LPOCNCONNPROCW; }
    if (@hasDecl(@This(), "LPOCNCHKPROC")) { _ = LPOCNCHKPROC; }
    if (@hasDecl(@This(), "LPOCNDSCPROC")) { _ = LPOCNDSCPROC; }
    if (@hasDecl(@This(), "PFN_AUTHZ_DYNAMIC_ACCESS_CHECK")) { _ = PFN_AUTHZ_DYNAMIC_ACCESS_CHECK; }
    if (@hasDecl(@This(), "PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS")) { _ = PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS; }
    if (@hasDecl(@This(), "PFN_AUTHZ_FREE_DYNAMIC_GROUPS")) { _ = PFN_AUTHZ_FREE_DYNAMIC_GROUPS; }
    if (@hasDecl(@This(), "PFN_AUTHZ_GET_CENTRAL_ACCESS_POLICY")) { _ = PFN_AUTHZ_GET_CENTRAL_ACCESS_POLICY; }
    if (@hasDecl(@This(), "PFN_AUTHZ_FREE_CENTRAL_ACCESS_POLICY")) { _ = PFN_AUTHZ_FREE_CENTRAL_ACCESS_POLICY; }
    if (@hasDecl(@This(), "FN_PROGRESS")) { _ = FN_PROGRESS; }
    if (@hasDecl(@This(), "PFNREADOBJECTSECURITY")) { _ = PFNREADOBJECTSECURITY; }
    if (@hasDecl(@This(), "PFNWRITEOBJECTSECURITY")) { _ = PFNWRITEOBJECTSECURITY; }
    if (@hasDecl(@This(), "PFNDSCREATEISECINFO")) { _ = PFNDSCREATEISECINFO; }
    if (@hasDecl(@This(), "PFNDSCREATEISECINFOEX")) { _ = PFNDSCREATEISECINFOEX; }
    if (@hasDecl(@This(), "PFNDSCREATESECPAGE")) { _ = PFNDSCREATESECPAGE; }
    if (@hasDecl(@This(), "PFNDSEDITSECURITY")) { _ = PFNDSEDITSECURITY; }
    if (@hasDecl(@This(), "FNCERTSRVISSERVERONLINEW")) { _ = FNCERTSRVISSERVERONLINEW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPGETDYNAMICFILELISTW")) { _ = FNCERTSRVBACKUPGETDYNAMICFILELISTW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPPREPAREW")) { _ = FNCERTSRVBACKUPPREPAREW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPGETDATABASENAMESW")) { _ = FNCERTSRVBACKUPGETDATABASENAMESW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPOPENFILEW")) { _ = FNCERTSRVBACKUPOPENFILEW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPREAD")) { _ = FNCERTSRVBACKUPREAD; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPCLOSE")) { _ = FNCERTSRVBACKUPCLOSE; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPGETBACKUPLOGSW")) { _ = FNCERTSRVBACKUPGETBACKUPLOGSW; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPTRUNCATELOGS")) { _ = FNCERTSRVBACKUPTRUNCATELOGS; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPEND")) { _ = FNCERTSRVBACKUPEND; }
    if (@hasDecl(@This(), "FNCERTSRVBACKUPFREE")) { _ = FNCERTSRVBACKUPFREE; }
    if (@hasDecl(@This(), "FNCERTSRVRESTOREGETDATABASELOCATIONSW")) { _ = FNCERTSRVRESTOREGETDATABASELOCATIONSW; }
    if (@hasDecl(@This(), "FNCERTSRVRESTOREPREPAREW")) { _ = FNCERTSRVRESTOREPREPAREW; }
    if (@hasDecl(@This(), "FNCERTSRVRESTOREREGISTERW")) { _ = FNCERTSRVRESTOREREGISTERW; }
    if (@hasDecl(@This(), "FNCERTSRVRESTOREREGISTERCOMPLETE")) { _ = FNCERTSRVRESTOREREGISTERCOMPLETE; }
    if (@hasDecl(@This(), "FNCERTSRVRESTOREEND")) { _ = FNCERTSRVRESTOREEND; }
    if (@hasDecl(@This(), "FNCERTSRVSERVERCONTROLW")) { _ = FNCERTSRVSERVERCONTROLW; }
    if (@hasDecl(@This(), "FNIMPORTPFXTOPROVIDER")) { _ = FNIMPORTPFXTOPROVIDER; }
    if (@hasDecl(@This(), "FNIMPORTPFXTOPROVIDERFREEDATA")) { _ = FNIMPORTPFXTOPROVIDERFREEDATA; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallback")) { _ = PFNCryptStreamOutputCallback; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallbackEx")) { _ = PFNCryptStreamOutputCallbackEx; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_WRITE_CALLBACK")) { _ = PFN_CRYPT_XML_WRITE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_READ")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_READ; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_CLOSE")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_CLOSE; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_CREATE_TRANSFORM")) { _ = PFN_CRYPT_XML_CREATE_TRANSFORM; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_ENUM_ALG_INFO")) { _ = PFN_CRYPT_XML_ENUM_ALG_INFO; }
    if (@hasDecl(@This(), "CryptXmlDllGetInterface")) { _ = CryptXmlDllGetInterface; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeAlgorithm")) { _ = CryptXmlDllEncodeAlgorithm; }
    if (@hasDecl(@This(), "CryptXmlDllCreateDigest")) { _ = CryptXmlDllCreateDigest; }
    if (@hasDecl(@This(), "CryptXmlDllDigestData")) { _ = CryptXmlDllDigestData; }
    if (@hasDecl(@This(), "CryptXmlDllFinalizeDigest")) { _ = CryptXmlDllFinalizeDigest; }
    if (@hasDecl(@This(), "CryptXmlDllCloseDigest")) { _ = CryptXmlDllCloseDigest; }
    if (@hasDecl(@This(), "CryptXmlDllSignData")) { _ = CryptXmlDllSignData; }
    if (@hasDecl(@This(), "CryptXmlDllVerifySignature")) { _ = CryptXmlDllVerifySignature; }
    if (@hasDecl(@This(), "CryptXmlDllGetAlgorithmInfo")) { _ = CryptXmlDllGetAlgorithmInfo; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeKeyValue")) { _ = CryptXmlDllEncodeKeyValue; }
    if (@hasDecl(@This(), "CryptXmlDllCreateKey")) { _ = CryptXmlDllCreateKey; }
    if (@hasDecl(@This(), "PFNCMFILTERPROC")) { _ = PFNCMFILTERPROC; }
    if (@hasDecl(@This(), "PFNCMHOOKPROC")) { _ = PFNCMHOOKPROC; }
    if (@hasDecl(@This(), "PFNTRUSTHELPER")) { _ = PFNTRUSTHELPER; }
    if (@hasDecl(@This(), "PFN_CPD_MEM_ALLOC")) { _ = PFN_CPD_MEM_ALLOC; }
    if (@hasDecl(@This(), "PFN_CPD_MEM_FREE")) { _ = PFN_CPD_MEM_FREE; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_STORE")) { _ = PFN_CPD_ADD_STORE; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_SGNR")) { _ = PFN_CPD_ADD_SGNR; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_CERT")) { _ = PFN_CPD_ADD_CERT; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_PRIVDATA")) { _ = PFN_CPD_ADD_PRIVDATA; }
    if (@hasDecl(@This(), "PFN_PROVIDER_INIT_CALL")) { _ = PFN_PROVIDER_INIT_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_OBJTRUST_CALL")) { _ = PFN_PROVIDER_OBJTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_SIGTRUST_CALL")) { _ = PFN_PROVIDER_SIGTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CERTTRUST_CALL")) { _ = PFN_PROVIDER_CERTTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_FINALPOLICY_CALL")) { _ = PFN_PROVIDER_FINALPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_TESTFINALPOLICY_CALL")) { _ = PFN_PROVIDER_TESTFINALPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CLEANUP_CALL")) { _ = PFN_PROVIDER_CLEANUP_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CERTCHKPOLICY_CALL")) { _ = PFN_PROVIDER_CERTCHKPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVUI_CALL")) { _ = PFN_PROVUI_CALL; }
    if (@hasDecl(@This(), "PFN_ALLOCANDFILLDEFUSAGE")) { _ = PFN_ALLOCANDFILLDEFUSAGE; }
    if (@hasDecl(@This(), "PFN_FREEDEFUSAGE")) { _ = PFN_FREEDEFUSAGE; }
    if (@hasDecl(@This(), "PFNCFILTERPROC")) { _ = PFNCFILTERPROC; }
    if (@hasDecl(@This(), "pCryptSIPGetSignedDataMsg")) { _ = pCryptSIPGetSignedDataMsg; }
    if (@hasDecl(@This(), "pCryptSIPPutSignedDataMsg")) { _ = pCryptSIPPutSignedDataMsg; }
    if (@hasDecl(@This(), "pCryptSIPCreateIndirectData")) { _ = pCryptSIPCreateIndirectData; }
    if (@hasDecl(@This(), "pCryptSIPVerifyIndirectData")) { _ = pCryptSIPVerifyIndirectData; }
    if (@hasDecl(@This(), "pCryptSIPRemoveSignedDataMsg")) { _ = pCryptSIPRemoveSignedDataMsg; }
    if (@hasDecl(@This(), "pfnIsFileSupported")) { _ = pfnIsFileSupported; }
    if (@hasDecl(@This(), "pfnIsFileSupportedName")) { _ = pfnIsFileSupportedName; }
    if (@hasDecl(@This(), "pCryptSIPGetCaps")) { _ = pCryptSIPGetCaps; }
    if (@hasDecl(@This(), "pCryptSIPGetSealedDigest")) { _ = pCryptSIPGetSealedDigest; }
    if (@hasDecl(@This(), "PFN_CDF_PARSE_ERROR_CALLBACK")) { _ = PFN_CDF_PARSE_ERROR_CALLBACK; }
    if (@hasDecl(@This(), "PFSCE_QUERY_INFO")) { _ = PFSCE_QUERY_INFO; }
    if (@hasDecl(@This(), "PFSCE_SET_INFO")) { _ = PFSCE_SET_INFO; }
    if (@hasDecl(@This(), "PFSCE_FREE_INFO")) { _ = PFSCE_FREE_INFO; }
    if (@hasDecl(@This(), "PFSCE_LOG_INFO")) { _ = PFSCE_LOG_INFO; }
    if (@hasDecl(@This(), "PF_ConfigAnalyzeService")) { _ = PF_ConfigAnalyzeService; }
    if (@hasDecl(@This(), "PF_UpdateService")) { _ = PF_UpdateService; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
