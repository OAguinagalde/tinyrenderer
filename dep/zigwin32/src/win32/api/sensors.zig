//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (88)
//--------------------------------------------------------------------------------
pub const GUID_DEVINTERFACE_SENSOR = Guid.initString("ba1bb692-9b7a-4833-9a1e-525ed134e7e2");
pub const SENSOR_EVENT_STATE_CHANGED = Guid.initString("bfd96016-6bd7-4560-ad34-f2f6607e8f81");
pub const SENSOR_EVENT_DATA_UPDATED = Guid.initString("2ed0f2a4-0087-41d3-87db-6773370b3c88");
pub const SENSOR_EVENT_PROPERTY_CHANGED = Guid.initString("2358f099-84c9-4d3d-90df-c2421e2b2045");
pub const SENSOR_EVENT_ACCELEROMETER_SHAKE = Guid.initString("825f5a94-0f48-4396-9ca0-6ecb5c99d915");
pub const SENSOR_EVENT_PARAMETER_COMMON_GUID = Guid.initString("64346e30-8728-4b34-bdf6-4f52442c5c28");
pub const SENSOR_ERROR_PARAMETER_COMMON_GUID = Guid.initString("77112bcd-fce1-4f43-b8b8-a88256adb4b3");
pub const SENSOR_PROPERTY_COMMON_GUID = Guid.initString("7f8383ec-d3ec-495c-a8cf-b8bbe85c2920");
pub const SENSOR_CATEGORY_ALL = Guid.initString("c317c286-c468-4288-9975-d4c4587c442c");
pub const SENSOR_CATEGORY_LOCATION = Guid.initString("bfa794e4-f964-4fdb-90f6-51056bfe4b44");
pub const SENSOR_CATEGORY_ENVIRONMENTAL = Guid.initString("323439aa-7f66-492b-ba0c-73e9aa0a65d5");
pub const SENSOR_CATEGORY_MOTION = Guid.initString("cd09daf1-3b2e-4c3d-b598-b5e5ff93fd46");
pub const SENSOR_CATEGORY_ORIENTATION = Guid.initString("9e6c04b6-96fe-4954-b726-68682a473f69");
pub const SENSOR_CATEGORY_MECHANICAL = Guid.initString("8d131d68-8ef7-4656-80b5-cccbd93791c5");
pub const SENSOR_CATEGORY_ELECTRICAL = Guid.initString("fb73fcd8-fc4a-483c-ac58-27b691c6beff");
pub const SENSOR_CATEGORY_BIOMETRIC = Guid.initString("ca19690f-a2c7-477d-a99e-99ec6e2b5648");
pub const SENSOR_CATEGORY_LIGHT = Guid.initString("17a665c0-9063-4216-b202-5c7a255e18ce");
pub const SENSOR_CATEGORY_SCANNER = Guid.initString("b000e77e-f5b5-420f-815d-0270a726f270");
pub const SENSOR_CATEGORY_OTHER = Guid.initString("2c90e7a9-f4c9-4fa2-af37-56d471fe5a3d");
pub const SENSOR_CATEGORY_UNSUPPORTED = Guid.initString("2beae7fa-19b0-48c5-a1f6-b5480dc206b0");
pub const SENSOR_TYPE_LOCATION_GPS = Guid.initString("ed4ca589-327a-4ff9-a560-91da4b48275e");
pub const SENSOR_TYPE_LOCATION_STATIC = Guid.initString("095f8184-0fa9-4445-8e6e-b70f320b6b4c");
pub const SENSOR_TYPE_LOCATION_LOOKUP = Guid.initString("3b2eae4a-72ce-436d-96d2-3c5b8570e987");
pub const SENSOR_TYPE_LOCATION_TRIANGULATION = Guid.initString("691c341a-5406-4fe1-942f-2246cbeb39e0");
pub const SENSOR_TYPE_LOCATION_OTHER = Guid.initString("9b2d0566-0368-4f71-b88d-533f132031de");
pub const SENSOR_TYPE_LOCATION_BROADCAST = Guid.initString("d26988cf-5162-4039-bb17-4c58b698e44a");
pub const SENSOR_TYPE_LOCATION_DEAD_RECKONING = Guid.initString("1a37d538-f28b-42da-9fce-a9d0a2a6d829");
pub const SENSOR_TYPE_ENVIRONMENTAL_TEMPERATURE = Guid.initString("04fd0ec4-d5da-45fa-95a9-5db38ee19306");
pub const SENSOR_TYPE_ENVIRONMENTAL_ATMOSPHERIC_PRESSURE = Guid.initString("0e903829-ff8a-4a93-97df-3dcbde402288");
pub const SENSOR_TYPE_ENVIRONMENTAL_HUMIDITY = Guid.initString("5c72bf67-bd7e-4257-990b-98a3ba3b400a");
pub const SENSOR_TYPE_ENVIRONMENTAL_WIND_SPEED = Guid.initString("dd50607b-a45f-42cd-8efd-ec61761c4226");
pub const SENSOR_TYPE_ENVIRONMENTAL_WIND_DIRECTION = Guid.initString("9ef57a35-9306-434d-af09-37fa5a9c00bd");
pub const SENSOR_TYPE_ACCELEROMETER_1D = Guid.initString("c04d2387-7340-4cc2-991e-3b18cb8ef2f4");
pub const SENSOR_TYPE_ACCELEROMETER_2D = Guid.initString("b2c517a8-f6b5-4ba6-a423-5df560b4cc07");
pub const SENSOR_TYPE_ACCELEROMETER_3D = Guid.initString("c2fb0f5f-e2d2-4c78-bcd0-352a9582819d");
pub const SENSOR_TYPE_MOTION_DETECTOR = Guid.initString("5c7c1a12-30a5-43b9-a4b2-cf09ec5b7be8");
pub const SENSOR_TYPE_GYROMETER_1D = Guid.initString("fa088734-f552-4584-8324-edfaf649652c");
pub const SENSOR_TYPE_GYROMETER_2D = Guid.initString("31ef4f83-919b-48bf-8de0-5d7a9d240556");
pub const SENSOR_TYPE_GYROMETER_3D = Guid.initString("09485f5a-759e-42c2-bd4b-a349b75c8643");
pub const SENSOR_TYPE_SPEEDOMETER = Guid.initString("6bd73c1f-0bb4-4310-81b2-dfc18a52bf94");
pub const SENSOR_TYPE_COMPASS_1D = Guid.initString("a415f6c5-cb50-49d0-8e62-a8270bd7a26c");
pub const SENSOR_TYPE_COMPASS_2D = Guid.initString("15655cc0-997a-4d30-84db-57caba3648bb");
pub const SENSOR_TYPE_COMPASS_3D = Guid.initString("76b5ce0d-17dd-414d-93a1-e127f40bdf6e");
pub const SENSOR_TYPE_INCLINOMETER_1D = Guid.initString("b96f98c5-7a75-4ba7-94e9-ac868c966dd8");
pub const SENSOR_TYPE_INCLINOMETER_2D = Guid.initString("ab140f6d-83eb-4264-b70b-b16a5b256a01");
pub const SENSOR_TYPE_INCLINOMETER_3D = Guid.initString("b84919fb-ea85-4976-8444-6f6f5c6d31db");
pub const SENSOR_TYPE_DISTANCE_1D = Guid.initString("5f14ab2f-1407-4306-a93f-b1dbabe4f9c0");
pub const SENSOR_TYPE_DISTANCE_2D = Guid.initString("5cf9a46c-a9a2-4e55-b6a1-a04aafa95a92");
pub const SENSOR_TYPE_DISTANCE_3D = Guid.initString("a20cae31-0e25-4772-9fe5-96608a1354b2");
pub const SENSOR_TYPE_AGGREGATED_QUADRANT_ORIENTATION = Guid.initString("9f81f1af-c4ab-4307-9904-c828bfb90829");
pub const SENSOR_TYPE_AGGREGATED_DEVICE_ORIENTATION = Guid.initString("cdb5d8f7-3cfd-41c8-8542-cce622cf5d6e");
pub const SENSOR_TYPE_AGGREGATED_SIMPLE_DEVICE_ORIENTATION = Guid.initString("86a19291-0482-402c-bf4c-addac52b1c39");
pub const SENSOR_TYPE_VOLTAGE = Guid.initString("c5484637-4fb7-4953-98b8-a56d8aa1fb1e");
pub const SENSOR_TYPE_CURRENT = Guid.initString("5adc9fce-15a0-4bbe-a1ad-2d38a9ae831c");
pub const SENSOR_TYPE_CAPACITANCE = Guid.initString("ca2ffb1c-2317-49c0-a0b4-b63ce63461a0");
pub const SENSOR_TYPE_RESISTANCE = Guid.initString("9993d2c8-c157-4a52-a7b5-195c76037231");
pub const SENSOR_TYPE_INDUCTANCE = Guid.initString("dc1d933f-c435-4c7d-a2fe-607192a524d3");
pub const SENSOR_TYPE_ELECTRICAL_POWER = Guid.initString("212f10f5-14ab-4376-9a43-a7794098c2fe");
pub const SENSOR_TYPE_POTENTIOMETER = Guid.initString("2b3681a9-cadc-45aa-a6ff-54957c8bb440");
pub const SENSOR_TYPE_FREQUENCY = Guid.initString("8cd2cbb6-73e6-4640-a709-72ae8fb60d7f");
pub const SENSOR_TYPE_BOOLEAN_SWITCH = Guid.initString("9c7e371f-1041-460b-8d5c-71e4752e350c");
pub const SENSOR_TYPE_MULTIVALUE_SWITCH = Guid.initString("b3ee4d76-37a4-4402-b25e-99c60a775fa1");
pub const SENSOR_TYPE_FORCE = Guid.initString("c2ab2b02-1a1c-4778-a81b-954a1788cc75");
pub const SENSOR_TYPE_SCALE = Guid.initString("c06dd92c-7feb-438e-9bf6-82207fff5bb8");
pub const SENSOR_TYPE_PRESSURE = Guid.initString("26d31f34-6352-41cf-b793-ea0713d53d77");
pub const SENSOR_TYPE_STRAIN = Guid.initString("c6d1ec0e-6803-4361-ad3d-85bcc58c6d29");
pub const SENSOR_TYPE_BOOLEAN_SWITCH_ARRAY = Guid.initString("545c8ba5-b143-4545-868f-ca7fd986b4f6");
pub const SENSOR_TYPE_HUMAN_PRESENCE = Guid.initString("c138c12b-ad52-451c-9375-87f518ff10c6");
pub const SENSOR_TYPE_HUMAN_PROXIMITY = Guid.initString("5220dae9-3179-4430-9f90-06266d2a34de");
pub const SENSOR_TYPE_TOUCH = Guid.initString("17db3018-06c4-4f7d-81af-9274b7599c27");
pub const SENSOR_TYPE_AMBIENT_LIGHT = Guid.initString("97f115c8-599a-4153-8894-d2d12899918a");
pub const SENSOR_TYPE_RFID_SCANNER = Guid.initString("44328ef5-02dd-4e8d-ad5d-9249832b2eca");
pub const SENSOR_TYPE_BARCODE_SCANNER = Guid.initString("990b3d8f-85bb-45ff-914d-998c04f372df");
pub const SENSOR_TYPE_CUSTOM = Guid.initString("e83af229-8640-4d18-a213-e22675ebb2c3");
pub const SENSOR_TYPE_UNKNOWN = Guid.initString("10ba83e3-ef4f-41ed-9885-a87d6435a8e1");
pub const SENSOR_DATA_TYPE_COMMON_GUID = Guid.initString("db5e0cf2-cf1f-4c18-b46c-d86011d62150");
pub const SENSOR_DATA_TYPE_LOCATION_GUID = Guid.initString("055c74d8-ca6f-47d6-95c6-1ed3637a0ff4");
pub const SENSOR_DATA_TYPE_ENVIRONMENTAL_GUID = Guid.initString("8b0aa2f1-2d57-42ee-8cc0-4d27622b46c4");
pub const SENSOR_DATA_TYPE_MOTION_GUID = Guid.initString("3f8a69a2-07c5-4e48-a965-cd797aab56d5");
pub const SENSOR_DATA_TYPE_ORIENTATION_GUID = Guid.initString("1637d8a2-4248-4275-865d-558de84aedfd");
pub const SENSOR_DATA_TYPE_GUID_MECHANICAL_GUID = Guid.initString("38564a7c-f2f2-49bb-9b2b-ba60f66a58df");
pub const SENSOR_DATA_TYPE_BIOMETRIC_GUID = Guid.initString("2299288a-6d9e-4b0b-b7ec-3528f89e40af");
pub const SENSOR_DATA_TYPE_LIGHT_GUID = Guid.initString("e4c77ce2-dcb7-46e9-8439-4fec548833a6");
pub const SENSOR_DATA_TYPE_SCANNER_GUID = Guid.initString("d7a59a3c-3421-44ab-8d3a-9de8ab6c4cae");
pub const SENSOR_DATA_TYPE_ELECTRICAL_GUID = Guid.initString("bbb246d1-e242-4780-a2d3-cded84f35842");
pub const SENSOR_DATA_TYPE_CUSTOM_GUID = Guid.initString("b14c764f-07cf-41e8-9d82-ebe3d0776a6f");
pub const SENSOR_PROPERTY_TEST_GUID = Guid.initString("e1e962f4-6e65-45f7-9c36-d487b7b1bd34");
pub const GNSS_CLEAR_ALL_ASSISTANCE_DATA = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (17)
//--------------------------------------------------------------------------------
const CLSID_SensorManager_Value = @import("../zig.zig").Guid.initString("77a1c827-fcd2-4689-8915-9d613cc5fa3e");
pub const CLSID_SensorManager = &CLSID_SensorManager_Value;

const CLSID_SensorCollection_Value = @import("../zig.zig").Guid.initString("79c43adb-a429-469f-aa39-2f2b74b75937");
pub const CLSID_SensorCollection = &CLSID_SensorCollection_Value;

const CLSID_Sensor_Value = @import("../zig.zig").Guid.initString("e97ced00-523a-4133-bf6f-d3a2dae7f6ba");
pub const CLSID_Sensor = &CLSID_Sensor_Value;

const CLSID_SensorDataReport_Value = @import("../zig.zig").Guid.initString("4ea9d6ef-694b-4218-8816-ccda8da74bba");
pub const CLSID_SensorDataReport = &CLSID_SensorDataReport_Value;

pub const SensorState = extern enum(i32) {
    MIN = 0,
    READY = 0,
    NOT_AVAILABLE = 1,
    NO_DATA = 2,
    INITIALIZING = 3,
    ACCESS_DENIED = 4,
    ERROR = 5,
    MAX = 5,
};
pub const SENSOR_STATE_MIN = SensorState.MIN;
pub const SENSOR_STATE_READY = SensorState.READY;
pub const SENSOR_STATE_NOT_AVAILABLE = SensorState.NOT_AVAILABLE;
pub const SENSOR_STATE_NO_DATA = SensorState.NO_DATA;
pub const SENSOR_STATE_INITIALIZING = SensorState.INITIALIZING;
pub const SENSOR_STATE_ACCESS_DENIED = SensorState.ACCESS_DENIED;
pub const SENSOR_STATE_ERROR = SensorState.ERROR;
pub const SENSOR_STATE_MAX = SensorState.MAX;

pub const SensorConnectionType = extern enum(i32) {
    INTEGRATED = 0,
    ATTACHED = 1,
    EXTERNAL = 2,
};
pub const SENSOR_CONNECTION_TYPE_PC_INTEGRATED = SensorConnectionType.INTEGRATED;
pub const SENSOR_CONNECTION_TYPE_PC_ATTACHED = SensorConnectionType.ATTACHED;
pub const SENSOR_CONNECTION_TYPE_PC_EXTERNAL = SensorConnectionType.EXTERNAL;

pub const LOCATION_DESIRED_ACCURACY = extern enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
};
pub const LOCATION_DESIRED_ACCURACY_DEFAULT = LOCATION_DESIRED_ACCURACY.DEFAULT;
pub const LOCATION_DESIRED_ACCURACY_HIGH = LOCATION_DESIRED_ACCURACY.HIGH;

pub const LOCATION_POSITION_SOURCE = extern enum(i32) {
    CELLULAR = 0,
    SATELLITE = 1,
    WIFI = 2,
    IPADDRESS = 3,
    UNKNOWN = 4,
};
pub const LOCATION_POSITION_SOURCE_CELLULAR = LOCATION_POSITION_SOURCE.CELLULAR;
pub const LOCATION_POSITION_SOURCE_SATELLITE = LOCATION_POSITION_SOURCE.SATELLITE;
pub const LOCATION_POSITION_SOURCE_WIFI = LOCATION_POSITION_SOURCE.WIFI;
pub const LOCATION_POSITION_SOURCE_IPADDRESS = LOCATION_POSITION_SOURCE.IPADDRESS;
pub const LOCATION_POSITION_SOURCE_UNKNOWN = LOCATION_POSITION_SOURCE.UNKNOWN;

pub const SimpleDeviceOrientation = extern enum(i32) {
    NOT_ROTATED = 0,
    ROTATED_90 = 1,
    ROTATED_180 = 2,
    ROTATED_270 = 3,
    ROTATED_FACE_UP = 4,
    ROTATED_FACE_DOWN = 5,
};
pub const SIMPLE_DEVICE_ORIENTATION_NOT_ROTATED = SimpleDeviceOrientation.NOT_ROTATED;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_90 = SimpleDeviceOrientation.ROTATED_90;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_180 = SimpleDeviceOrientation.ROTATED_180;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_270 = SimpleDeviceOrientation.ROTATED_270;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_UP = SimpleDeviceOrientation.ROTATED_FACE_UP;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_DOWN = SimpleDeviceOrientation.ROTATED_FACE_DOWN;

pub const MagnetometerAccuracy = extern enum(i32) {
    UNKNOWN = 0,
    UNRELIABLE = 1,
    APPROXIMATE = 2,
    HIGH = 3,
};
pub const MAGNETOMETER_ACCURACY_UNKNOWN = MagnetometerAccuracy.UNKNOWN;
pub const MAGNETOMETER_ACCURACY_UNRELIABLE = MagnetometerAccuracy.UNRELIABLE;
pub const MAGNETOMETER_ACCURACY_APPROXIMATE = MagnetometerAccuracy.APPROXIMATE;
pub const MAGNETOMETER_ACCURACY_HIGH = MagnetometerAccuracy.HIGH;

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorManager_Value = @import("../zig.zig").Guid.initString("bd77db67-45a8-42dc-8d00-6dcf15f8377a");
pub const IID_ISensorManager = &IID_ISensorManager_Value;
pub const ISensorManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSensorsByCategory: fn(
            self: *const ISensorManager,
            sensorCategory: *Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorsByType: fn(
            self: *const ISensorManager,
            sensorType: *Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorByID: fn(
            self: *const ISensorManager,
            sensorID: *Guid,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensorManager,
            pEvents: ?*ISensorManagerEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestPermissions: fn(
            self: *const ISensorManager,
            hParent: HWND,
            pSensors: ?*ISensorCollection,
            fModal: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByCategory(self: *const T, sensorCategory: *Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByCategory(@ptrCast(*const ISensorManager, self), sensorCategory, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByType(self: *const T, sensorType: *Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByType(@ptrCast(*const ISensorManager, self), sensorType, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorByID(self: *const T, sensorID: *Guid, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorByID(@ptrCast(*const ISensorManager, self), sensorID, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_SetEventSink(self: *const T, pEvents: ?*ISensorManagerEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensorManager, self), pEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_RequestPermissions(self: *const T, hParent: HWND, pSensors: ?*ISensorCollection, fModal: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).RequestPermissions(@ptrCast(*const ISensorManager, self), hParent, pSensors, fModal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ILocationPermissions_Value = @import("../zig.zig").Guid.initString("d5fb0a7f-e74e-44f5-8e02-4806863a274f");
pub const IID_ILocationPermissions = &IID_ILocationPermissions_Value;
pub const ILocationPermissions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGlobalLocationPermission: fn(
            self: *const ILocationPermissions,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLocationCapability: fn(
            self: *const ILocationPermissions,
            dwClientThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_GetGlobalLocationPermission(self: *const T, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).GetGlobalLocationPermission(@ptrCast(*const ILocationPermissions, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_CheckLocationCapability(self: *const T, dwClientThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).CheckLocationCapability(@ptrCast(*const ILocationPermissions, self), dwClientThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorCollection_Value = @import("../zig.zig").Guid.initString("23571e11-e545-4dd8-a337-b89bf44b10df");
pub const IID_ISensorCollection = &IID_ISensorCollection_Value;
pub const ISensorCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAt: fn(
            self: *const ISensorCollection,
            ulIndex: u32,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ISensorCollection,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveByID: fn(
            self: *const ISensorCollection,
            sensorID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetAt(self: *const T, ulIndex: u32, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetAt(@ptrCast(*const ISensorCollection, self), ulIndex, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetCount(self: *const T, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetCount(@ptrCast(*const ISensorCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Add(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Add(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Remove(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Remove(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_RemoveByID(self: *const T, sensorID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).RemoveByID(@ptrCast(*const ISensorCollection, self), sensorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Clear(@ptrCast(*const ISensorCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensor_Value = @import("../zig.zig").Guid.initString("5fa08f80-2657-458e-af75-46f73fa6ac5c");
pub const IID_ISensor = &IID_ISensor_Value;
pub const ISensor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: fn(
            self: *const ISensor,
            pID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const ISensor,
            pSensorCategory: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ISensor,
            pSensorType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const ISensor,
            pFriendlyName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ISensor,
            key: *const PROPERTYKEY,
            pProperty: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const ISensor,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppProperties: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedDataFields: fn(
            self: *const ISensor,
            ppDataFields: ?*?*IPortableDeviceKeyCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ISensor,
            pProperties: ?*IPortableDeviceValues,
            ppResults: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsDataField: fn(
            self: *const ISensor,
            key: *const PROPERTYKEY,
            pIsSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const ISensor,
            pState: *SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const ISensor,
            ppDataReport: ?*?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsEvent: fn(
            self: *const ISensor,
            eventGuid: *const Guid,
            pIsSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventInterest: fn(
            self: *const ISensor,
            ppValues: ?[*]?*Guid,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventInterest: fn(
            self: *const ISensor,
            pValues: ?[*]Guid,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensor,
            pEvents: ?*ISensorEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetID(self: *const T, pID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetID(@ptrCast(*const ISensor, self), pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetCategory(self: *const T, pSensorCategory: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetCategory(@ptrCast(*const ISensor, self), pSensorCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetType(self: *const T, pSensorType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetType(@ptrCast(*const ISensor, self), pSensorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetFriendlyName(self: *const T, pFriendlyName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetFriendlyName(@ptrCast(*const ISensor, self), pFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperty(self: *const T, key: *const PROPERTYKEY, pProperty: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperty(@ptrCast(*const ISensor, self), key, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperties(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppProperties: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperties(@ptrCast(*const ISensor, self), pKeys, ppProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetSupportedDataFields(self: *const T, ppDataFields: ?*?*IPortableDeviceKeyCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetSupportedDataFields(@ptrCast(*const ISensor, self), ppDataFields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetProperties(self: *const T, pProperties: ?*IPortableDeviceValues, ppResults: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetProperties(@ptrCast(*const ISensor, self), pProperties, ppResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsDataField(self: *const T, key: *const PROPERTYKEY, pIsSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsDataField(@ptrCast(*const ISensor, self), key, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetState(self: *const T, pState: *SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetState(@ptrCast(*const ISensor, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetData(self: *const T, ppDataReport: ?*?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetData(@ptrCast(*const ISensor, self), ppDataReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsEvent(self: *const T, eventGuid: *const Guid, pIsSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsEvent(@ptrCast(*const ISensor, self), eventGuid, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetEventInterest(self: *const T, ppValues: ?[*]?*Guid, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetEventInterest(@ptrCast(*const ISensor, self), ppValues, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventInterest(self: *const T, pValues: ?[*]Guid, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventInterest(@ptrCast(*const ISensor, self), pValues, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventSink(self: *const T, pEvents: ?*ISensorEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensor, self), pEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorDataReport_Value = @import("../zig.zig").Guid.initString("0ab9df9b-c4b5-4796-8898-0470706a2e1d");
pub const IID_ISensorDataReport = &IID_ISensorDataReport_Value;
pub const ISensorDataReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestamp: fn(
            self: *const ISensorDataReport,
            pTimeStamp: *SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValue: fn(
            self: *const ISensorDataReport,
            pKey: *const PROPERTYKEY,
            pValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValues: fn(
            self: *const ISensorDataReport,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppValues: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetTimestamp(self: *const T, pTimeStamp: *SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetTimestamp(@ptrCast(*const ISensorDataReport, self), pTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValue(self: *const T, pKey: *const PROPERTYKEY, pValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValue(@ptrCast(*const ISensorDataReport, self), pKey, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValues(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppValues: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValues(@ptrCast(*const ISensorDataReport, self), pKeys, ppValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorManagerEvents_Value = @import("../zig.zig").Guid.initString("9b3b0b86-266a-4aad-b21f-fde5501001b7");
pub const IID_ISensorManagerEvents = &IID_ISensorManagerEvents_Value;
pub const ISensorManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSensorEnter: fn(
            self: *const ISensorManagerEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManagerEvents_OnSensorEnter(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManagerEvents.VTable, self.vtable).OnSensorEnter(@ptrCast(*const ISensorManagerEvents, self), pSensor, state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorEvents_Value = @import("../zig.zig").Guid.initString("5d8dcc91-4641-47e7-b7c3-b74f48a6c391");
pub const IID_ISensorEvents = &IID_ISensorEvents_Value;
pub const ISensorEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataUpdated: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            pNewData: ?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEvent: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            eventID: *const Guid,
            pEventData: ?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeave: fn(
            self: *const ISensorEvents,
            ID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnStateChanged(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnStateChanged(@ptrCast(*const ISensorEvents, self), pSensor, state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnDataUpdated(self: *const T, pSensor: ?*ISensor, pNewData: ?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnDataUpdated(@ptrCast(*const ISensorEvents, self), pSensor, pNewData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnEvent(self: *const T, pSensor: ?*ISensor, eventID: *const Guid, pEventData: ?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnEvent(@ptrCast(*const ISensorEvents, self), pSensor, eventID, pEventData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnLeave(self: *const T, ID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnLeave(@ptrCast(*const ISensorEvents, self), ID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IUnknown = @import("com.zig").IUnknown;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const HRESULT = @import("com.zig").HRESULT;
const PROPERTYKEY = @import("windows_properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("structured_storage.zig").PROPVARIANT;
const BSTR = @import("automation.zig").BSTR;
const IPortableDeviceKeyCollection = @import("windows_portable_devices.zig").IPortableDeviceKeyCollection;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const IPortableDeviceValues = @import("windows_portable_devices.zig").IPortableDeviceValues;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
