//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (423)
//--------------------------------------------------------------------------------
pub const WinUSB_TestGuid = Guid.initString("da812bff-12c3-46a2-8e2b-dbd3b7834c43");
pub const SHORT_PACKET_TERMINATE = @as(u32, 1);
pub const AUTO_CLEAR_STALL = @as(u32, 2);
pub const PIPE_TRANSFER_TIMEOUT = @as(u32, 3);
pub const IGNORE_SHORT_PACKETS = @as(u32, 4);
pub const ALLOW_PARTIAL_READS = @as(u32, 5);
pub const AUTO_FLUSH = @as(u32, 6);
pub const RAW_IO = @as(u32, 7);
pub const MAXIMUM_TRANSFER_SIZE = @as(u32, 8);
pub const RESET_PIPE_ON_RESUME = @as(u32, 9);
pub const AUTO_SUSPEND = @as(u32, 129);
pub const SUSPEND_DELAY = @as(u32, 131);
pub const DEVICE_SPEED = @as(u32, 1);
pub const LowSpeed = @as(u32, 1);
pub const FullSpeed = @as(u32, 2);
pub const HighSpeed = @as(u32, 3);
pub const USBUSER_VERSION = @as(u32, 4);
pub const USBUSER_GET_CONTROLLER_INFO_0 = @as(u32, 1);
pub const USBUSER_GET_CONTROLLER_DRIVER_KEY = @as(u32, 2);
pub const USBUSER_PASS_THRU = @as(u32, 3);
pub const USBUSER_GET_POWER_STATE_MAP = @as(u32, 4);
pub const USBUSER_GET_BANDWIDTH_INFORMATION = @as(u32, 5);
pub const USBUSER_GET_BUS_STATISTICS_0 = @as(u32, 6);
pub const USBUSER_GET_ROOTHUB_SYMBOLIC_NAME = @as(u32, 7);
pub const USBUSER_GET_USB_DRIVER_VERSION = @as(u32, 8);
pub const USBUSER_GET_USB2_HW_VERSION = @as(u32, 9);
pub const USBUSER_USB_REFRESH_HCT_REG = @as(u32, 10);
pub const USBUSER_OP_SEND_ONE_PACKET = @as(u32, 268435457);
pub const USBUSER_OP_RAW_RESET_PORT = @as(u32, 536870913);
pub const USBUSER_OP_OPEN_RAW_DEVICE = @as(u32, 536870914);
pub const USBUSER_OP_CLOSE_RAW_DEVICE = @as(u32, 536870915);
pub const USBUSER_OP_SEND_RAW_COMMAND = @as(u32, 536870916);
pub const USBUSER_SET_ROOTPORT_FEATURE = @as(u32, 536870917);
pub const USBUSER_CLEAR_ROOTPORT_FEATURE = @as(u32, 536870918);
pub const USBUSER_GET_ROOTPORT_STATUS = @as(u32, 536870919);
pub const USBUSER_INVALID_REQUEST = @as(u32, 4294967280);
pub const USBUSER_OP_MASK_DEVONLY_API = @as(u32, 268435456);
pub const USBUSER_OP_MASK_HCTEST_API = @as(u32, 536870912);
pub const USB_PACKETFLAG_LOW_SPEED = @as(u32, 1);
pub const USB_PACKETFLAG_FULL_SPEED = @as(u32, 2);
pub const USB_PACKETFLAG_HIGH_SPEED = @as(u32, 4);
pub const USB_PACKETFLAG_ASYNC_IN = @as(u32, 8);
pub const USB_PACKETFLAG_ASYNC_OUT = @as(u32, 16);
pub const USB_PACKETFLAG_ISO_IN = @as(u32, 32);
pub const USB_PACKETFLAG_ISO_OUT = @as(u32, 64);
pub const USB_PACKETFLAG_SETUP = @as(u32, 128);
pub const USB_PACKETFLAG_TOGGLE0 = @as(u32, 256);
pub const USB_PACKETFLAG_TOGGLE1 = @as(u32, 512);
pub const USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING = @as(u32, 1);
pub const USB_HC_FEATURE_FLAG_SEL_SUSPEND = @as(u32, 2);
pub const USB_HC_FEATURE_LEGACY_BIOS = @as(u32, 4);
pub const USB_HC_FEATURE_TIME_SYNC_API = @as(u32, 8);
pub const USB_SUBMIT_URB = @as(u32, 0);
pub const USB_RESET_PORT = @as(u32, 1);
pub const USB_GET_ROOTHUB_PDO = @as(u32, 3);
pub const USB_GET_PORT_STATUS = @as(u32, 4);
pub const USB_ENABLE_PORT = @as(u32, 5);
pub const USB_GET_HUB_COUNT = @as(u32, 6);
pub const USB_CYCLE_PORT = @as(u32, 7);
pub const USB_GET_HUB_NAME = @as(u32, 8);
pub const USB_IDLE_NOTIFICATION = @as(u32, 9);
pub const USB_RECORD_FAILURE = @as(u32, 10);
pub const USB_GET_BUS_INFO = @as(u32, 264);
pub const USB_GET_CONTROLLER_NAME = @as(u32, 265);
pub const USB_GET_BUSGUID_INFO = @as(u32, 266);
pub const USB_GET_PARENT_HUB_INFO = @as(u32, 267);
pub const USB_GET_DEVICE_HANDLE = @as(u32, 268);
pub const USB_GET_DEVICE_HANDLE_EX = @as(u32, 269);
pub const USB_GET_TT_DEVICE_HANDLE = @as(u32, 270);
pub const USB_GET_TOPOLOGY_ADDRESS = @as(u32, 271);
pub const USB_IDLE_NOTIFICATION_EX = @as(u32, 272);
pub const USB_REQ_GLOBAL_SUSPEND = @as(u32, 273);
pub const USB_REQ_GLOBAL_RESUME = @as(u32, 274);
pub const USB_GET_HUB_CONFIG_INFO = @as(u32, 275);
pub const USB_FAIL_GET_STATUS = @as(u32, 280);
pub const USB_REGISTER_COMPOSITE_DEVICE = @as(u32, 0);
pub const USB_UNREGISTER_COMPOSITE_DEVICE = @as(u32, 1);
pub const USB_REQUEST_REMOTE_WAKE_NOTIFICATION = @as(u32, 2);
pub const HCD_GET_STATS_1 = @as(u32, 255);
pub const HCD_DIAGNOSTIC_MODE_ON = @as(u32, 256);
pub const HCD_DIAGNOSTIC_MODE_OFF = @as(u32, 257);
pub const HCD_GET_ROOT_HUB_NAME = @as(u32, 258);
pub const HCD_GET_DRIVERKEY_NAME = @as(u32, 265);
pub const HCD_GET_STATS_2 = @as(u32, 266);
pub const HCD_DISABLE_PORT = @as(u32, 268);
pub const HCD_ENABLE_PORT = @as(u32, 269);
pub const HCD_USER_REQUEST = @as(u32, 270);
pub const HCD_TRACE_READ_REQUEST = @as(u32, 275);
pub const USB_GET_NODE_INFORMATION = @as(u32, 258);
pub const USB_GET_NODE_CONNECTION_INFORMATION = @as(u32, 259);
pub const USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION = @as(u32, 260);
pub const USB_GET_NODE_CONNECTION_NAME = @as(u32, 261);
pub const USB_DIAG_IGNORE_HUBS_ON = @as(u32, 262);
pub const USB_DIAG_IGNORE_HUBS_OFF = @as(u32, 263);
pub const USB_GET_NODE_CONNECTION_DRIVERKEY_NAME = @as(u32, 264);
pub const USB_GET_HUB_CAPABILITIES = @as(u32, 271);
pub const USB_GET_NODE_CONNECTION_ATTRIBUTES = @as(u32, 272);
pub const USB_HUB_CYCLE_PORT = @as(u32, 273);
pub const USB_GET_NODE_CONNECTION_INFORMATION_EX = @as(u32, 274);
pub const USB_RESET_HUB = @as(u32, 275);
pub const USB_GET_HUB_CAPABILITIES_EX = @as(u32, 276);
pub const USB_GET_HUB_INFORMATION_EX = @as(u32, 277);
pub const USB_GET_PORT_CONNECTOR_PROPERTIES = @as(u32, 278);
pub const USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 = @as(u32, 279);
pub const USB_GET_TRANSPORT_CHARACTERISTICS = @as(u32, 281);
pub const USB_REGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 282);
pub const USB_NOTIFY_ON_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 283);
pub const USB_UNREGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = @as(u32, 284);
pub const USB_START_TRACKING_FOR_TIME_SYNC = @as(u32, 285);
pub const USB_GET_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC = @as(u32, 286);
pub const USB_STOP_TRACKING_FOR_TIME_SYNC = @as(u32, 287);
pub const USB_GET_DEVICE_CHARACTERISTICS = @as(u32, 288);
pub const GUID_DEVINTERFACE_USB_HUB = Guid.initString("f18a0e88-c30c-11d0-8815-00a0c906bed8");
pub const GUID_DEVINTERFACE_USB_BILLBOARD = Guid.initString("5e9adaef-f879-473f-b807-4e5ea77d1b1c");
pub const GUID_DEVINTERFACE_USB_DEVICE = Guid.initString("a5dcbf10-6530-11d2-901f-00c04fb951ed");
pub const GUID_DEVINTERFACE_USB_HOST_CONTROLLER = Guid.initString("3abf6f2d-71c4-462a-8a92-1e6861e6af27");
pub const GUID_USB_WMI_STD_DATA = Guid.initString("4e623b20-cb14-11d1-b331-00a0c959bbd2");
pub const GUID_USB_WMI_STD_NOTIFICATION = Guid.initString("4e623b20-cb14-11d1-b331-00a0c959bbd2");
pub const GUID_USB_WMI_DEVICE_PERF_INFO = Guid.initString("66c1aa3c-499f-49a0-a9a5-61e2359f6407");
pub const GUID_USB_WMI_NODE_INFO = Guid.initString("9c179357-dc7a-4f41-b66b-323b9ddcb5b1");
pub const GUID_USB_WMI_TRACING = Guid.initString("3a61881b-b4e6-4bf9-ae0f-3cd8f394e52f");
pub const GUID_USB_TRANSFER_TRACING = Guid.initString("681eb8aa-403d-452c-9f8a-f0616fac9540");
pub const GUID_USB_PERFORMANCE_TRACING = Guid.initString("d5de77a6-6ae9-425c-b1e2-f5615fd348a9");
pub const GUID_USB_WMI_SURPRISE_REMOVAL_NOTIFICATION = Guid.initString("9bbbf831-a2f2-43b4-96d1-86944b5914b3");
pub const BMREQUEST_HOST_TO_DEVICE = @as(u32, 0);
pub const BMREQUEST_DEVICE_TO_HOST = @as(u32, 1);
pub const BMREQUEST_STANDARD = @as(u32, 0);
pub const BMREQUEST_CLASS = @as(u32, 1);
pub const BMREQUEST_VENDOR = @as(u32, 2);
pub const BMREQUEST_TO_DEVICE = @as(u32, 0);
pub const BMREQUEST_TO_INTERFACE = @as(u32, 1);
pub const BMREQUEST_TO_ENDPOINT = @as(u32, 2);
pub const BMREQUEST_TO_OTHER = @as(u32, 3);
pub const USB_REQUEST_GET_STATUS = @as(u32, 0);
pub const USB_REQUEST_CLEAR_FEATURE = @as(u32, 1);
pub const USB_REQUEST_SET_FEATURE = @as(u32, 3);
pub const USB_REQUEST_SET_ADDRESS = @as(u32, 5);
pub const USB_REQUEST_GET_DESCRIPTOR = @as(u32, 6);
pub const USB_REQUEST_SET_DESCRIPTOR = @as(u32, 7);
pub const USB_REQUEST_GET_CONFIGURATION = @as(u32, 8);
pub const USB_REQUEST_SET_CONFIGURATION = @as(u32, 9);
pub const USB_REQUEST_GET_INTERFACE = @as(u32, 10);
pub const USB_REQUEST_SET_INTERFACE = @as(u32, 11);
pub const USB_REQUEST_SYNC_FRAME = @as(u32, 12);
pub const USB_REQUEST_GET_FIRMWARE_STATUS = @as(u32, 26);
pub const USB_REQUEST_SET_FIRMWARE_STATUS = @as(u32, 27);
pub const USB_GET_FIRMWARE_ALLOWED_OR_DISALLOWED_STATE = @as(u32, 0);
pub const USB_GET_FIRMWARE_HASH = @as(u32, 1);
pub const USB_DEVICE_FIRMWARE_HASH_LENGTH = @as(u32, 32);
pub const USB_DISALLOW_FIRMWARE_UPDATE = @as(u32, 0);
pub const USB_ALLOW_FIRMWARE_UPDATE = @as(u32, 1);
pub const USB_REQUEST_SET_SEL = @as(u32, 48);
pub const USB_REQUEST_ISOCH_DELAY = @as(u32, 49);
pub const USB_DEVICE_DESCRIPTOR_TYPE = @as(u32, 1);
pub const USB_CONFIGURATION_DESCRIPTOR_TYPE = @as(u32, 2);
pub const USB_STRING_DESCRIPTOR_TYPE = @as(u32, 3);
pub const USB_INTERFACE_DESCRIPTOR_TYPE = @as(u32, 4);
pub const USB_ENDPOINT_DESCRIPTOR_TYPE = @as(u32, 5);
pub const USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE = @as(u32, 6);
pub const USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE = @as(u32, 7);
pub const USB_INTERFACE_POWER_DESCRIPTOR_TYPE = @as(u32, 8);
pub const USB_OTG_DESCRIPTOR_TYPE = @as(u32, 9);
pub const USB_DEBUG_DESCRIPTOR_TYPE = @as(u32, 10);
pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE = @as(u32, 11);
pub const USB_BOS_DESCRIPTOR_TYPE = @as(u32, 15);
pub const USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE = @as(u32, 16);
pub const USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = @as(u32, 48);
pub const USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = @as(u32, 49);
pub const USB_RESERVED_DESCRIPTOR_TYPE = @as(u32, 6);
pub const USB_CONFIG_POWER_DESCRIPTOR_TYPE = @as(u32, 7);
pub const USB_FEATURE_ENDPOINT_STALL = @as(u32, 0);
pub const USB_FEATURE_REMOTE_WAKEUP = @as(u32, 1);
pub const USB_FEATURE_TEST_MODE = @as(u32, 2);
pub const USB_FEATURE_FUNCTION_SUSPEND = @as(u32, 0);
pub const USB_FEATURE_U1_ENABLE = @as(u32, 48);
pub const USB_FEATURE_U2_ENABLE = @as(u32, 49);
pub const USB_FEATURE_LTM_ENABLE = @as(u32, 50);
pub const USB_FEATURE_LDM_ENABLE = @as(u32, 53);
pub const USB_FEATURE_BATTERY_WAKE_MASK = @as(u32, 40);
pub const USB_FEATURE_OS_IS_PD_AWARE = @as(u32, 41);
pub const USB_FEATURE_POLICY_MODE = @as(u32, 42);
pub const USB_FEATURE_CHARGING_POLICY = @as(u32, 54);
pub const USB_CHARGING_POLICY_DEFAULT = @as(u32, 0);
pub const USB_CHARGING_POLICY_ICCHPF = @as(u32, 1);
pub const USB_CHARGING_POLICY_ICCLPF = @as(u32, 2);
pub const USB_CHARGING_POLICY_NO_POWER = @as(u32, 3);
pub const USB_STATUS_PORT_STATUS = @as(u32, 0);
pub const USB_STATUS_PD_STATUS = @as(u32, 1);
pub const USB_STATUS_EXT_PORT_STATUS = @as(u32, 2);
pub const USB_GETSTATUS_SELF_POWERED = @as(u32, 1);
pub const USB_GETSTATUS_REMOTE_WAKEUP_ENABLED = @as(u32, 2);
pub const USB_GETSTATUS_U1_ENABLE = @as(u32, 4);
pub const USB_GETSTATUS_U2_ENABLE = @as(u32, 8);
pub const USB_GETSTATUS_LTM_ENABLE = @as(u32, 16);
pub const USB_DEVICE_CLASS_RESERVED = @as(u32, 0);
pub const USB_DEVICE_CLASS_AUDIO = @as(u32, 1);
pub const USB_DEVICE_CLASS_COMMUNICATIONS = @as(u32, 2);
pub const USB_DEVICE_CLASS_HUMAN_INTERFACE = @as(u32, 3);
pub const USB_DEVICE_CLASS_MONITOR = @as(u32, 4);
pub const USB_DEVICE_CLASS_PHYSICAL_INTERFACE = @as(u32, 5);
pub const USB_DEVICE_CLASS_POWER = @as(u32, 6);
pub const USB_DEVICE_CLASS_IMAGE = @as(u32, 6);
pub const USB_DEVICE_CLASS_PRINTER = @as(u32, 7);
pub const USB_DEVICE_CLASS_STORAGE = @as(u32, 8);
pub const USB_DEVICE_CLASS_HUB = @as(u32, 9);
pub const USB_DEVICE_CLASS_CDC_DATA = @as(u32, 10);
pub const USB_DEVICE_CLASS_SMART_CARD = @as(u32, 11);
pub const USB_DEVICE_CLASS_CONTENT_SECURITY = @as(u32, 13);
pub const USB_DEVICE_CLASS_VIDEO = @as(u32, 14);
pub const USB_DEVICE_CLASS_PERSONAL_HEALTHCARE = @as(u32, 15);
pub const USB_DEVICE_CLASS_AUDIO_VIDEO = @as(u32, 16);
pub const USB_DEVICE_CLASS_BILLBOARD = @as(u32, 17);
pub const USB_DEVICE_CLASS_DIAGNOSTIC_DEVICE = @as(u32, 220);
pub const USB_DEVICE_CLASS_WIRELESS_CONTROLLER = @as(u32, 224);
pub const USB_DEVICE_CLASS_MISCELLANEOUS = @as(u32, 239);
pub const USB_DEVICE_CLASS_APPLICATION_SPECIFIC = @as(u32, 254);
pub const USB_DEVICE_CLASS_VENDOR_SPECIFIC = @as(u32, 255);
pub const USB_DEVICE_CAPABILITY_WIRELESS_USB = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB = @as(u32, 3);
pub const USB_DEVICE_CAPABILITY_CONTAINER_ID = @as(u32, 4);
pub const USB_DEVICE_CAPABILITY_PLATFORM = @as(u32, 5);
pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY = @as(u32, 6);
pub const USB_DEVICE_CAPABILITY_BATTERY_INFO = @as(u32, 7);
pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT = @as(u32, 8);
pub const USB_DEVICE_CAPABILITY_PD_PROVIDER_PORT = @as(u32, 9);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT = @as(u32, 11);
pub const USB_DEVICE_CAPABILITY_BILLBOARD = @as(u32, 13);
pub const USB_DEVICE_CAPABILITY_FIRMWARE_STATUS = @as(u32, 17);
pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION_BMATTRIBUTES_RESERVED_MASK = @as(u32, 4294901985);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_RESERVED_MASK = @as(u32, 253);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_LTM_CAPABLE = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_RESERVED_MASK = @as(u32, 65520);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_LOW = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_FULL = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_HIGH = @as(u32, 4);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_SUPER = @as(u32, 8);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_U1_DEVICE_EXIT_MAX_VALUE = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_U2_DEVICE_EXIT_MAX_VALUE = @as(u32, 2047);
pub const USB_DEVICE_CAPABILITY_MAX_U1_LATENCY = @as(u32, 10);
pub const USB_DEVICE_CAPABILITY_MAX_U2_LATENCY = @as(u32, 2047);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_BPS = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_KBPS = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_MBPS = @as(u32, 2);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_GBPS = @as(u32, 3);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_SYMMETRIC = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_ASYMMETRIC = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_RX = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_TX = @as(u32, 1);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SS = @as(u32, 0);
pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SSP = @as(u32, 1);
pub const GUID_USB_MSOS20_PLATFORM_CAPABILITY_ID = Guid.initString("d8dd60df-4589-4cc7-9cd2-659d9e648a9f");
pub const USB_CONFIG_POWERED_MASK = @as(u32, 192);
pub const USB_CONFIG_BUS_POWERED = @as(u32, 128);
pub const USB_CONFIG_SELF_POWERED = @as(u32, 64);
pub const USB_CONFIG_REMOTE_WAKEUP = @as(u32, 32);
pub const USB_CONFIG_RESERVED = @as(u32, 31);
pub const USB_ENDPOINT_DIRECTION_MASK = @as(u32, 128);
pub const USB_ENDPOINT_ADDRESS_MASK = @as(u32, 15);
pub const USB_ENDPOINT_TYPE_MASK = @as(u32, 3);
pub const USB_ENDPOINT_TYPE_CONTROL = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS = @as(u32, 1);
pub const USB_ENDPOINT_TYPE_BULK = @as(u32, 2);
pub const USB_ENDPOINT_TYPE_INTERRUPT = @as(u32, 3);
pub const USB_ENDPOINT_TYPE_BULK_RESERVED_MASK = @as(u32, 252);
pub const USB_ENDPOINT_TYPE_CONTROL_RESERVED_MASK = @as(u32, 252);
pub const USB_20_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = @as(u32, 252);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = @as(u32, 204);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_RESERVED_MASK = @as(u32, 192);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_MASK = @as(u32, 48);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_PERIODIC = @as(u32, 0);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_NOTIFICATION = @as(u32, 16);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED10 = @as(u32, 32);
pub const USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED11 = @as(u32, 48);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_MASK = @as(u32, 12);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_NO_SYNCHRONIZATION = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ASYNCHRONOUS = @as(u32, 4);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ADAPTIVE = @as(u32, 8);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_SYNCHRONOUS = @as(u32, 12);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_MASK = @as(u32, 48);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_DATA_ENDOINT = @as(u32, 0);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_FEEDBACK_ENDPOINT = @as(u32, 16);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_IMPLICIT_FEEDBACK_DATA_ENDPOINT = @as(u32, 32);
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_RESERVED = @as(u32, 48);
pub const USB_ENDPOINT_SUPERSPEED_BULK_MAX_PACKET_SIZE = @as(u32, 1024);
pub const USB_ENDPOINT_SUPERSPEED_CONTROL_MAX_PACKET_SIZE = @as(u32, 512);
pub const USB_ENDPOINT_SUPERSPEED_ISO_MAX_PACKET_SIZE = @as(u32, 1024);
pub const USB_ENDPOINT_SUPERSPEED_INTERRUPT_MAX_PACKET_SIZE = @as(u32, 1024);
pub const MAXIMUM_USB_STRING_LENGTH = @as(u32, 255);
pub const USB_SUPERSPEED_ISOCHRONOUS_MAX_MULTIPLIER = @as(u32, 2);
pub const USB_SUPERSPEEDPLUS_ISOCHRONOUS_MIN_BYTESPERINTERVAL = @as(u32, 49153);
pub const USB_SUPERSPEEDPLUS_ISOCHRONOUS_MAX_BYTESPERINTERVAL = @as(u32, 16777215);
pub const USB_20_HUB_DESCRIPTOR_TYPE = @as(u32, 41);
pub const USB_30_HUB_DESCRIPTOR_TYPE = @as(u32, 42);
pub const USB_REQUEST_GET_STATE = @as(u32, 2);
pub const USB_REQUEST_CLEAR_TT_BUFFER = @as(u32, 8);
pub const USB_REQUEST_RESET_TT = @as(u32, 9);
pub const USB_REQUEST_GET_TT_STATE = @as(u32, 10);
pub const USB_REQUEST_STOP_TT = @as(u32, 11);
pub const USB_REQUEST_SET_HUB_DEPTH = @as(u32, 12);
pub const USB_REQUEST_GET_PORT_ERR_COUNT = @as(u32, 13);
pub const USB_PORT_STATUS_CONNECT = @as(u32, 1);
pub const USB_PORT_STATUS_ENABLE = @as(u32, 2);
pub const USB_PORT_STATUS_SUSPEND = @as(u32, 4);
pub const USB_PORT_STATUS_OVER_CURRENT = @as(u32, 8);
pub const USB_PORT_STATUS_RESET = @as(u32, 16);
pub const USB_PORT_STATUS_POWER = @as(u32, 256);
pub const USB_PORT_STATUS_LOW_SPEED = @as(u32, 512);
pub const USB_PORT_STATUS_HIGH_SPEED = @as(u32, 1024);
pub const PORT_LINK_STATE_U0 = @as(u32, 0);
pub const PORT_LINK_STATE_U1 = @as(u32, 1);
pub const PORT_LINK_STATE_U2 = @as(u32, 2);
pub const PORT_LINK_STATE_U3 = @as(u32, 3);
pub const PORT_LINK_STATE_DISABLED = @as(u32, 4);
pub const PORT_LINK_STATE_RX_DETECT = @as(u32, 5);
pub const PORT_LINK_STATE_INACTIVE = @as(u32, 6);
pub const PORT_LINK_STATE_POLLING = @as(u32, 7);
pub const PORT_LINK_STATE_RECOVERY = @as(u32, 8);
pub const PORT_LINK_STATE_HOT_RESET = @as(u32, 9);
pub const PORT_LINK_STATE_COMPLIANCE_MODE = @as(u32, 10);
pub const PORT_LINK_STATE_LOOPBACK = @as(u32, 11);
pub const PORT_LINK_STATE_TEST_MODE = @as(u32, 11);
pub const USB_FEATURE_INTERFACE_POWER_D0 = @as(u32, 2);
pub const USB_FEATURE_INTERFACE_POWER_D1 = @as(u32, 3);
pub const USB_FEATURE_INTERFACE_POWER_D2 = @as(u32, 4);
pub const USB_FEATURE_INTERFACE_POWER_D3 = @as(u32, 5);
pub const USB_SUPPORT_D0_COMMAND = @as(u32, 1);
pub const USB_SUPPORT_D1_COMMAND = @as(u32, 2);
pub const USB_SUPPORT_D2_COMMAND = @as(u32, 4);
pub const USB_SUPPORT_D3_COMMAND = @as(u32, 8);
pub const USB_SUPPORT_D1_WAKEUP = @as(u32, 16);
pub const USB_SUPPORT_D2_WAKEUP = @as(u32, 32);
pub const USBDI_VERSION = @as(u32, 1536);
pub const USB_PORTATTR_NO_CONNECTOR = @as(u32, 1);
pub const USB_PORTATTR_SHARED_USB2 = @as(u32, 2);
pub const USB_PORTATTR_MINI_CONNECTOR = @as(u32, 4);
pub const USB_PORTATTR_OEM_CONNECTOR = @as(u32, 8);
pub const USB_PORTATTR_OWNED_BY_CC = @as(u32, 16777216);
pub const USB_PORTATTR_NO_OVERCURRENT_UI = @as(u32, 33554432);
pub const USB_DEFAULT_DEVICE_ADDRESS = @as(u32, 0);
pub const USB_DEFAULT_ENDPOINT_ADDRESS = @as(u32, 0);
pub const USB_DEFAULT_MAX_PACKET = @as(u32, 64);
pub const URB_FUNCTION_SELECT_CONFIGURATION = @as(u32, 0);
pub const URB_FUNCTION_SELECT_INTERFACE = @as(u32, 1);
pub const URB_FUNCTION_ABORT_PIPE = @as(u32, 2);
pub const URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL = @as(u32, 3);
pub const URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL = @as(u32, 4);
pub const URB_FUNCTION_GET_FRAME_LENGTH = @as(u32, 5);
pub const URB_FUNCTION_SET_FRAME_LENGTH = @as(u32, 6);
pub const URB_FUNCTION_GET_CURRENT_FRAME_NUMBER = @as(u32, 7);
pub const URB_FUNCTION_CONTROL_TRANSFER = @as(u32, 8);
pub const URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER = @as(u32, 9);
pub const URB_FUNCTION_ISOCH_TRANSFER = @as(u32, 10);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE = @as(u32, 11);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE = @as(u32, 12);
pub const URB_FUNCTION_SET_FEATURE_TO_DEVICE = @as(u32, 13);
pub const URB_FUNCTION_SET_FEATURE_TO_INTERFACE = @as(u32, 14);
pub const URB_FUNCTION_SET_FEATURE_TO_ENDPOINT = @as(u32, 15);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE = @as(u32, 16);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE = @as(u32, 17);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT = @as(u32, 18);
pub const URB_FUNCTION_GET_STATUS_FROM_DEVICE = @as(u32, 19);
pub const URB_FUNCTION_GET_STATUS_FROM_INTERFACE = @as(u32, 20);
pub const URB_FUNCTION_GET_STATUS_FROM_ENDPOINT = @as(u32, 21);
pub const URB_FUNCTION_RESERVED_0X0016 = @as(u32, 22);
pub const URB_FUNCTION_VENDOR_DEVICE = @as(u32, 23);
pub const URB_FUNCTION_VENDOR_INTERFACE = @as(u32, 24);
pub const URB_FUNCTION_VENDOR_ENDPOINT = @as(u32, 25);
pub const URB_FUNCTION_CLASS_DEVICE = @as(u32, 26);
pub const URB_FUNCTION_CLASS_INTERFACE = @as(u32, 27);
pub const URB_FUNCTION_CLASS_ENDPOINT = @as(u32, 28);
pub const URB_FUNCTION_RESERVE_0X001D = @as(u32, 29);
pub const URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL = @as(u32, 30);
pub const URB_FUNCTION_CLASS_OTHER = @as(u32, 31);
pub const URB_FUNCTION_VENDOR_OTHER = @as(u32, 32);
pub const URB_FUNCTION_GET_STATUS_FROM_OTHER = @as(u32, 33);
pub const URB_FUNCTION_CLEAR_FEATURE_TO_OTHER = @as(u32, 34);
pub const URB_FUNCTION_SET_FEATURE_TO_OTHER = @as(u32, 35);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT = @as(u32, 36);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT = @as(u32, 37);
pub const URB_FUNCTION_GET_CONFIGURATION = @as(u32, 38);
pub const URB_FUNCTION_GET_INTERFACE = @as(u32, 39);
pub const URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE = @as(u32, 40);
pub const URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE = @as(u32, 41);
pub const URB_FUNCTION_RESERVE_0X002B = @as(u32, 43);
pub const URB_FUNCTION_RESERVE_0X002C = @as(u32, 44);
pub const URB_FUNCTION_RESERVE_0X002D = @as(u32, 45);
pub const URB_FUNCTION_RESERVE_0X002E = @as(u32, 46);
pub const URB_FUNCTION_RESERVE_0X002F = @as(u32, 47);
pub const URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR = @as(u32, 42);
pub const URB_FUNCTION_SYNC_RESET_PIPE = @as(u32, 48);
pub const URB_FUNCTION_SYNC_CLEAR_STALL = @as(u32, 49);
pub const URB_FUNCTION_CONTROL_TRANSFER_EX = @as(u32, 50);
pub const URB_FUNCTION_RESERVE_0X0033 = @as(u32, 51);
pub const URB_FUNCTION_RESERVE_0X0034 = @as(u32, 52);
pub const URB_FUNCTION_OPEN_STATIC_STREAMS = @as(u32, 53);
pub const URB_FUNCTION_CLOSE_STATIC_STREAMS = @as(u32, 54);
pub const URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL = @as(u32, 55);
pub const URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL = @as(u32, 56);
pub const URB_FUNCTION_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = @as(u32, 61);
pub const USBD_SHORT_TRANSFER_OK = @as(u32, 2);
pub const USBD_START_ISO_TRANSFER_ASAP = @as(u32, 4);
pub const USBD_DEFAULT_PIPE_TRANSFER = @as(u32, 8);
pub const USBD_TRANSFER_DIRECTION_OUT = @as(u32, 0);
pub const USBD_TRANSFER_DIRECTION_IN = @as(u32, 1);
pub const USBD_ISO_START_FRAME_RANGE = @as(u32, 1024);
pub const USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE = @as(u32, 4294967295);
pub const USBD_PF_CHANGE_MAX_PACKET = @as(u32, 1);
pub const USBD_PF_SHORT_PACKET_OPT = @as(u32, 2);
pub const USBD_PF_ENABLE_RT_THREAD_ACCESS = @as(u32, 4);
pub const USBD_PF_MAP_ADD_TRANSFERS = @as(u32, 8);
pub const USBD_PF_VIDEO_PRIORITY = @as(u32, 16);
pub const USBD_PF_VOICE_PRIORITY = @as(u32, 32);
pub const USBD_PF_INTERACTIVE_PRIORITY = @as(u32, 48);
pub const USBD_PF_PRIORITY_MASK = @as(u32, 240);
pub const USBD_PF_HANDLES_SSP_HIGH_BANDWIDTH_ISOCH = @as(u32, 256);
pub const USBD_PF_SSP_HIGH_BANDWIDTH_ISOCH = @as(u32, 65536);
pub const OS_STRING_DESCRIPTOR_INDEX = @as(u32, 238);
pub const MS_GENRE_DESCRIPTOR_INDEX = @as(u32, 1);
pub const MS_POWER_DESCRIPTOR_INDEX = @as(u32, 2);
pub const MS_OS_FLAGS_CONTAINERID = @as(u32, 2);
pub const URB_OPEN_STATIC_STREAMS_VERSION_100 = @as(u32, 256);

//--------------------------------------------------------------------------------
// Section: Types (124)
//--------------------------------------------------------------------------------
pub const USB_DEVICE_SPEED = extern enum(i32) {
    LowSpeed = 0,
    FullSpeed = 1,
    HighSpeed = 2,
    SuperSpeed = 3,
};
pub const UsbLowSpeed = USB_DEVICE_SPEED.LowSpeed;
pub const UsbFullSpeed = USB_DEVICE_SPEED.FullSpeed;
pub const UsbHighSpeed = USB_DEVICE_SPEED.HighSpeed;
pub const UsbSuperSpeed = USB_DEVICE_SPEED.SuperSpeed;

pub const USB_DEVICE_TYPE = extern enum(i32) {
    @"11Device" = 0,
    @"20Device" = 1,
};
pub const Usb11Device = USB_DEVICE_TYPE.@"11Device";
pub const Usb20Device = USB_DEVICE_TYPE.@"20Device";

pub const BM_REQUEST_TYPE = extern union {
    s: _BM,
    B: u8,
    const _BM = u32; // TODO: generate this nested type!
};

pub const USB_DEFAULT_PIPE_SETUP_PACKET = extern struct {
    bmRequestType: BM_REQUEST_TYPE,
    bRequest: u8,
    wValue: _wValue,
    wIndex: _wIndex,
    wLength: u16,
    const _wIndex = u32; // TODO: generate this nested type!
    const _wValue = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_INTERFACE_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_ENDPOINT_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_COMMON_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
};

pub const USB_DEVICE_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bcdUSB: u16,
    bDeviceClass: u8,
    bDeviceSubClass: u8,
    bDeviceProtocol: u8,
    bMaxPacketSize0: u8,
    idVendor: u16,
    idProduct: u16,
    bcdDevice: u16,
    iManufacturer: u8,
    iProduct: u8,
    iSerialNumber: u8,
    bNumConfigurations: u8,
};

pub const USB_DEVICE_QUALIFIER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bcdUSB: u16,
    bDeviceClass: u8,
    bDeviceSubClass: u8,
    bDeviceProtocol: u8,
    bMaxPacketSize0: u8,
    bNumConfigurations: u8,
    bReserved: u8,
};

pub const USB_BOS_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wTotalLength: u16,
    bNumDeviceCaps: u8,
};

pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bmAttributes: _bmAttributes_e__Union,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmAttributes: _bmAttributes_e__Union,
    bmProviderPorts: u16,
    bmConsumerPorts: u16,
    bcdBCVersion: u16,
    bcdPDVersion: u16,
    bcdUSBTypeCVersion: u16,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmCapabilities: _bmCapabilities_e__Union,
    wMinVoltage: u16,
    wMaxVoltage: u16,
    wReserved: u16,
    dwMaxOperatingPower: u32,
    dwMaxPeakPower: u32,
    dwMaxPeakPowerTime: u32,
    const _bmCapabilities_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bmAttributes: u8,
    wSpeedsSupported: u16,
    bFunctionalitySupport: u8,
    bU1DevExitLat: u8,
    wU2DevExitLat: u16,
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED = extern union {
    AsUlong32: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmAttributes: _bmAttributes_e__Union,
    wFunctionalitySupport: _wFunctionalitySupport_e__Union,
    wReserved: u16,
    bmSublinkSpeedAttr: [1]USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED,
    const _wFunctionalitySupport_e__Union = u32; // TODO: generate this nested type!
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_CONTAINER_ID_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    ContainerID: [16]u8,
};

pub const USB_DEVICE_CAPABILITY_PLATFORM_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    PlatformCapabilityUuid: Guid,
    CapabililityData: [1]u8,
};

pub const USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    iAddtionalInfoURL: u8,
    bNumberOfAlternateModes: u8,
    bPreferredAlternateMode: u8,
    VconnPower: _VconnPower_e__Union,
    bmConfigured: [32]u8,
    bReserved: u32,
    AlternateMode: [1]_Anonymous_e__Struct,
    const _VconnPower_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_FIRMWARE_STATUS_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bcdDescriptorVersion: u8,
    bmAttributes: _bmAttributes_e__Union,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
};

pub const USB_CONFIGURATION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wTotalLength: u16,
    bNumInterfaces: u8,
    bConfigurationValue: u8,
    iConfiguration: u8,
    bmAttributes: u8,
    MaxPower: u8,
};

pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bFirstInterface: u8,
    bInterfaceCount: u8,
    bFunctionClass: u8,
    bFunctionSubClass: u8,
    bFunctionProtocol: u8,
    iFunction: u8,
};

pub const USB_INTERFACE_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bInterfaceNumber: u8,
    bAlternateSetting: u8,
    bNumEndpoints: u8,
    bInterfaceClass: u8,
    bInterfaceSubClass: u8,
    bInterfaceProtocol: u8,
    iInterface: u8,
};

pub const USB_ENDPOINT_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bEndpointAddress: u8,
    bmAttributes: u8,
    wMaxPacketSize: u16,
    bInterval: u8,
};

pub const USB_HIGH_SPEED_MAXPACKET = extern union {
    us: u16,
    const _MP = u32; // TODO: generate this nested type!
};

pub const USB_STRING_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bString: [1]u16,
};

pub const USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bMaxBurst: u8,
    bmAttributes: _bmAttributes_e__Union,
    wBytesPerInterval: u16,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wReserved: u16,
    dwBytesPerInterval: u32,
};

pub const USB_HUB_DESCRIPTOR = extern struct {
    bDescriptorLength: u8,
    bDescriptorType: u8,
    bNumberOfPorts: u8,
    wHubCharacteristics: u16,
    bPowerOnToPowerGood: u8,
    bHubControlCurrent: u8,
    bRemoveAndPowerMask: [64]u8,
};

pub const USB_30_HUB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bNumberOfPorts: u8,
    wHubCharacteristics: u16,
    bPowerOnToPowerGood: u8,
    bHubControlCurrent: u8,
    bHubHdrDecLat: u8,
    wHubDelay: u16,
    DeviceRemovable: u16,
};

pub const USB_HUB_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_HUB_CHANGE = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_HUB_STATUS_AND_CHANGE = extern union {
    AsUlong32: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_20_PORT_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_20_PORT_CHANGE = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_30_PORT_STATUS = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_30_PORT_CHANGE = extern union {
    AsUshort16: u16,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_PORT_STATUS = extern union {
    AsUshort16: u16,
    Usb20PortStatus: USB_20_PORT_STATUS,
    Usb30PortStatus: USB_30_PORT_STATUS,
};

pub const USB_PORT_CHANGE = extern union {
    AsUshort16: u16,
    Usb20PortChange: USB_20_PORT_CHANGE,
    Usb30PortChange: USB_30_PORT_CHANGE,
};

pub const USB_PORT_EXT_STATUS = extern union {
    AsUlong32: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_PORT_STATUS_AND_CHANGE = extern union {
    AsUlong32: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_PORT_EXT_STATUS_AND_CHANGE = extern union {
    AsUlong64: u64,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_HUB_30_PORT_REMOTE_WAKE_MASK = extern union {
    AsUchar8: u8,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_FUNCTION_SUSPEND_OPTIONS = extern union {
    AsUchar: u8,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_CONFIGURATION_POWER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    SelfPowerConsumedD0: [3]u8,
    bPowerSummaryId: u8,
    bBusPowerSavingD1: u8,
    bSelfPowerSavingD1: u8,
    bBusPowerSavingD2: u8,
    bSelfPowerSavingD2: u8,
    bBusPowerSavingD3: u8,
    bSelfPowerSavingD3: u8,
    TransitionTimeFromD1: u16,
    TransitionTimeFromD2: u16,
    TransitionTimeFromD3: u16,
};

pub const USB_INTERFACE_POWER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bmCapabilitiesFlags: u8,
    bBusPowerSavingD1: u8,
    bSelfPowerSavingD1: u8,
    bBusPowerSavingD2: u8,
    bSelfPowerSavingD2: u8,
    bBusPowerSavingD3: u8,
    bSelfPowerSavingD3: u8,
    TransitionTimeFromD1: u16,
    TransitionTimeFromD2: u16,
    TransitionTimeFromD3: u16,
};

pub const USB_CONTROLLER_FLAVOR = extern enum(i32) {
    USB_HcGeneric = 0,
    OHCI_Generic = 100,
    OHCI_Hydra = 101,
    OHCI_NEC = 102,
    UHCI_Generic = 200,
    UHCI_Piix4 = 201,
    UHCI_Piix3 = 202,
    UHCI_Ich2 = 203,
    UHCI_Reserved204 = 204,
    UHCI_Ich1 = 205,
    UHCI_Ich3m = 206,
    UHCI_Ich4 = 207,
    UHCI_Ich5 = 208,
    UHCI_Ich6 = 209,
    UHCI_Intel = 249,
    UHCI_VIA = 250,
    UHCI_VIA_x01 = 251,
    UHCI_VIA_x02 = 252,
    UHCI_VIA_x03 = 253,
    UHCI_VIA_x04 = 254,
    UHCI_VIA_x0E_FIFO = 264,
    EHCI_Generic = 1000,
    EHCI_NEC = 2000,
    EHCI_Lucent = 3000,
    EHCI_NVIDIA_Tegra2 = 4000,
    EHCI_NVIDIA_Tegra3 = 4001,
    EHCI_Intel_Medfield = 5001,
};
pub const USB_HcGeneric = USB_CONTROLLER_FLAVOR.USB_HcGeneric;
pub const OHCI_Generic = USB_CONTROLLER_FLAVOR.OHCI_Generic;
pub const OHCI_Hydra = USB_CONTROLLER_FLAVOR.OHCI_Hydra;
pub const OHCI_NEC = USB_CONTROLLER_FLAVOR.OHCI_NEC;
pub const UHCI_Generic = USB_CONTROLLER_FLAVOR.UHCI_Generic;
pub const UHCI_Piix4 = USB_CONTROLLER_FLAVOR.UHCI_Piix4;
pub const UHCI_Piix3 = USB_CONTROLLER_FLAVOR.UHCI_Piix3;
pub const UHCI_Ich2 = USB_CONTROLLER_FLAVOR.UHCI_Ich2;
pub const UHCI_Reserved204 = USB_CONTROLLER_FLAVOR.UHCI_Reserved204;
pub const UHCI_Ich1 = USB_CONTROLLER_FLAVOR.UHCI_Ich1;
pub const UHCI_Ich3m = USB_CONTROLLER_FLAVOR.UHCI_Ich3m;
pub const UHCI_Ich4 = USB_CONTROLLER_FLAVOR.UHCI_Ich4;
pub const UHCI_Ich5 = USB_CONTROLLER_FLAVOR.UHCI_Ich5;
pub const UHCI_Ich6 = USB_CONTROLLER_FLAVOR.UHCI_Ich6;
pub const UHCI_Intel = USB_CONTROLLER_FLAVOR.UHCI_Intel;
pub const UHCI_VIA = USB_CONTROLLER_FLAVOR.UHCI_VIA;
pub const UHCI_VIA_x01 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x01;
pub const UHCI_VIA_x02 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x02;
pub const UHCI_VIA_x03 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x03;
pub const UHCI_VIA_x04 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x04;
pub const UHCI_VIA_x0E_FIFO = USB_CONTROLLER_FLAVOR.UHCI_VIA_x0E_FIFO;
pub const EHCI_Generic = USB_CONTROLLER_FLAVOR.EHCI_Generic;
pub const EHCI_NEC = USB_CONTROLLER_FLAVOR.EHCI_NEC;
pub const EHCI_Lucent = USB_CONTROLLER_FLAVOR.EHCI_Lucent;
pub const EHCI_NVIDIA_Tegra2 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra2;
pub const EHCI_NVIDIA_Tegra3 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra3;
pub const EHCI_Intel_Medfield = USB_CONTROLLER_FLAVOR.EHCI_Intel_Medfield;

pub const USBD_VERSION_INFORMATION = extern struct {
    USBDI_Version: u32,
    Supported_USB_Version: u32,
};

pub const USBD_PIPE_TYPE = extern enum(i32) {
    Control = 0,
    Isochronous = 1,
    Bulk = 2,
    Interrupt = 3,
};
pub const UsbdPipeTypeControl = USBD_PIPE_TYPE.Control;
pub const UsbdPipeTypeIsochronous = USBD_PIPE_TYPE.Isochronous;
pub const UsbdPipeTypeBulk = USBD_PIPE_TYPE.Bulk;
pub const UsbdPipeTypeInterrupt = USBD_PIPE_TYPE.Interrupt;

pub const USBD_DEVICE_INFORMATION = extern struct {
    OffsetNext: u32,
    UsbdDeviceHandle: *c_void,
    DeviceDescriptor: USB_DEVICE_DESCRIPTOR,
};

pub const USBD_PIPE_INFORMATION = extern struct {
    MaximumPacketSize: u16,
    EndpointAddress: u8,
    Interval: u8,
    PipeType: USBD_PIPE_TYPE,
    PipeHandle: *c_void,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const USBD_ENDPOINT_OFFLOAD_MODE = extern enum(i32) {
    ModeNotSupported = 0,
    SoftwareAssisted = 1,
    HardwareAssisted = 2,
};
pub const UsbdEndpointOffloadModeNotSupported = USBD_ENDPOINT_OFFLOAD_MODE.ModeNotSupported;
pub const UsbdEndpointOffloadSoftwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.SoftwareAssisted;
pub const UsbdEndpointOffloadHardwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.HardwareAssisted;

pub const USBD_ENDPOINT_OFFLOAD_INFORMATION = extern struct {
    Size: u32,
    EndpointAddress: u16,
    ResourceId: u32,
    Mode: USBD_ENDPOINT_OFFLOAD_MODE,
    _bitfield1: u32,
    _bitfield2: u32,
    TransferSegmentLA: LARGE_INTEGER,
    TransferSegmentVA: *c_void,
    TransferRingSize: usize,
    TransferRingInitialCycleBit: u32,
    MessageNumber: u32,
    EventRingSegmentLA: LARGE_INTEGER,
    EventRingSegmentVA: *c_void,
    EventRingSize: usize,
    EventRingInitialCycleBit: u32,
};

pub const USBD_INTERFACE_INFORMATION = extern struct {
    Length: u16,
    InterfaceNumber: u8,
    AlternateSetting: u8,
    Class: u8,
    SubClass: u8,
    Protocol: u8,
    Reserved: u8,
    InterfaceHandle: *c_void,
    NumberOfPipes: u32,
    Pipes: [1]USBD_PIPE_INFORMATION,
};

pub const _URB_HCD_AREA = extern struct {
    Reserved8: [8]*c_void,
};

pub const _URB_HEADER = extern struct {
    Length: u16,
    Function: u16,
    Status: i32,
    UsbdDeviceHandle: *c_void,
    UsbdFlags: u32,
};

pub const _URB_SELECT_INTERFACE = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationHandle: *c_void,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_SELECT_CONFIGURATION = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationDescriptor: *USB_CONFIGURATION_DESCRIPTOR,
    ConfigurationHandle: *c_void,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_PIPE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    Reserved: u32,
};

pub const _URB_FRAME_LENGTH_CONTROL = extern struct {
    Hdr: _URB_HEADER,
};

pub const _URB_GET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLength: u32,
    FrameNumber: u32,
};

pub const _URB_SET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLengthDelta: i32,
};

pub const _URB_GET_CURRENT_FRAME_NUMBER = extern struct {
    Hdr: _URB_HEADER,
    FrameNumber: u32,
};

pub const _URB_CONTROL_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: u16,
    Index: u8,
    DescriptorType: u8,
    LanguageId: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_STATUS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Index: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_FEATURE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved2: u32,
    Reserved3: u32,
    Reserved4: *c_void,
    Reserved5: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved0: u16,
    FeatureSelector: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_VENDOR_OR_CLASS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    RequestTypeReservedBits: u8,
    Request: u8,
    Value: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_GET_INTERFACE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Interface: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_CONFIGURATION_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [8]u8,
};

pub const OS_STRING = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    MicrosoftString: [7]u16,
    bVendorCode: u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const _URB_OS_FEATURE_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    _bitfield: u8,
    Reserved2: u8,
    InterfaceNumber: u8,
    MS_PageIndex: u8,
    MS_FeatureDescriptorIndex: u16,
    Reserved3: u16,
};

pub const _URB_CONTROL_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_CONTROL_TRANSFER_EX = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    Timeout: u32,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_BULK_OR_INTERRUPT_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
};

pub const USBD_ISO_PACKET_DESCRIPTOR = extern struct {
    Offset: u32,
    Length: u32,
    Status: i32,
};

pub const _URB_ISOCH_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    StartFrame: u32,
    NumberOfPackets: u32,
    ErrorCount: u32,
    IsoPacket: [1]USBD_ISO_PACKET_DESCRIPTOR,
};

pub const USBD_STREAM_INFORMATION = extern struct {
    PipeHandle: *c_void,
    StreamID: u32,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const _URB_OPEN_STATIC_STREAMS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    NumberOfStreams: u32,
    StreamInfoVersion: u16,
    StreamInfoSize: u16,
    Streams: *USBD_STREAM_INFORMATION,
};

pub const _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    MaximumSendPathDelayInMilliSeconds: u32,
    MaximumCompletionPathDelayInMilliSeconds: u32,
};

pub const URB = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_IDLE_CALLBACK = fn(
    Context: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const USB_IDLE_CALLBACK_INFO = extern struct {
    IdleCallback: USB_IDLE_CALLBACK,
    IdleContext: *c_void,
};

pub const USB_USER_ERROR_CODE = extern enum(i32) {
    Success = 0,
    NotSupported = 1,
    InvalidRequestCode = 2,
    FeatureDisabled = 3,
    InvalidHeaderParameter = 4,
    InvalidParameter = 5,
    MiniportError = 6,
    BufferTooSmall = 7,
    ErrorNotMapped = 8,
    DeviceNotStarted = 9,
    NoDeviceConnected = 10,
};
pub const UsbUserSuccess = USB_USER_ERROR_CODE.Success;
pub const UsbUserNotSupported = USB_USER_ERROR_CODE.NotSupported;
pub const UsbUserInvalidRequestCode = USB_USER_ERROR_CODE.InvalidRequestCode;
pub const UsbUserFeatureDisabled = USB_USER_ERROR_CODE.FeatureDisabled;
pub const UsbUserInvalidHeaderParameter = USB_USER_ERROR_CODE.InvalidHeaderParameter;
pub const UsbUserInvalidParameter = USB_USER_ERROR_CODE.InvalidParameter;
pub const UsbUserMiniportError = USB_USER_ERROR_CODE.MiniportError;
pub const UsbUserBufferTooSmall = USB_USER_ERROR_CODE.BufferTooSmall;
pub const UsbUserErrorNotMapped = USB_USER_ERROR_CODE.ErrorNotMapped;
pub const UsbUserDeviceNotStarted = USB_USER_ERROR_CODE.DeviceNotStarted;
pub const UsbUserNoDeviceConnected = USB_USER_ERROR_CODE.NoDeviceConnected;

pub const USBUSER_REQUEST_HEADER = extern struct {
    UsbUserRequest: u32,
    UsbUserStatusCode: USB_USER_ERROR_CODE,
    RequestBufferLength: u32,
    ActualBufferLength: u32,
};

pub const PACKET_PARAMETERS = extern struct {
    DeviceAddress: u8,
    EndpointAddress: u8,
    MaximumPacketSize: u16,
    Timeout: u32,
    Flags: u32,
    DataLength: u32,
    HubDeviceAddress: u16,
    PortTTNumber: u16,
    ErrorCount: u8,
    Pad: [3]u8,
    UsbdStatusCode: i32,
    Data: [4]u8,
};

pub const USBUSER_SEND_ONE_PACKET = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PacketParameters: PACKET_PARAMETERS,
};

pub const RAW_RESET_PORT_PARAMETERS = extern struct {
    PortNumber: u16,
    PortStatus: u16,
};

pub const USBUSER_RAW_RESET_ROOT_PORT = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_RESET_PORT_PARAMETERS,
};

pub const RAW_ROOTPORT_FEATURE = extern struct {
    PortNumber: u16,
    PortFeature: u16,
    PortStatus: u16,
};

pub const USBUSER_ROOTPORT_FEATURE_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_FEATURE,
};

pub const RAW_ROOTPORT_PARAMETERS = extern struct {
    PortNumber: u16,
    PortStatus: u16,
};

pub const USBUSER_ROOTPORT_PARAMETERS = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_PARAMETERS,
};

pub const USB_CONTROLLER_INFO_0 = extern struct {
    PciVendorId: u32,
    PciDeviceId: u32,
    PciRevision: u32,
    NumberOfRootPorts: u32,
    ControllerFlavor: USB_CONTROLLER_FLAVOR,
    HcFeatureFlags: u32,
};

pub const USBUSER_CONTROLLER_INFO_0 = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Info0: USB_CONTROLLER_INFO_0,
};

pub const USB_UNICODE_NAME = extern struct {
    Length: u32,
    String: [1]u16,
};

pub const USBUSER_CONTROLLER_UNICODE_NAME = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    UnicodeName: USB_UNICODE_NAME,
};

pub const USB_PASS_THRU_PARAMETERS = extern struct {
    FunctionGUID: Guid,
    ParameterLength: u32,
    Parameters: [4]u8,
};

pub const USBUSER_PASS_THRU_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PassThru: USB_PASS_THRU_PARAMETERS,
};

pub const WDMUSB_POWER_STATE = extern enum(i32) {
    NotMapped = 0,
    SystemUnspecified = 100,
    SystemWorking = 101,
    SystemSleeping1 = 102,
    SystemSleeping2 = 103,
    SystemSleeping3 = 104,
    SystemHibernate = 105,
    SystemShutdown = 106,
    DeviceUnspecified = 200,
    DeviceD0 = 201,
    DeviceD1 = 202,
    DeviceD2 = 203,
    DeviceD3 = 204,
};
pub const WdmUsbPowerNotMapped = WDMUSB_POWER_STATE.NotMapped;
pub const WdmUsbPowerSystemUnspecified = WDMUSB_POWER_STATE.SystemUnspecified;
pub const WdmUsbPowerSystemWorking = WDMUSB_POWER_STATE.SystemWorking;
pub const WdmUsbPowerSystemSleeping1 = WDMUSB_POWER_STATE.SystemSleeping1;
pub const WdmUsbPowerSystemSleeping2 = WDMUSB_POWER_STATE.SystemSleeping2;
pub const WdmUsbPowerSystemSleeping3 = WDMUSB_POWER_STATE.SystemSleeping3;
pub const WdmUsbPowerSystemHibernate = WDMUSB_POWER_STATE.SystemHibernate;
pub const WdmUsbPowerSystemShutdown = WDMUSB_POWER_STATE.SystemShutdown;
pub const WdmUsbPowerDeviceUnspecified = WDMUSB_POWER_STATE.DeviceUnspecified;
pub const WdmUsbPowerDeviceD0 = WDMUSB_POWER_STATE.DeviceD0;
pub const WdmUsbPowerDeviceD1 = WDMUSB_POWER_STATE.DeviceD1;
pub const WdmUsbPowerDeviceD2 = WDMUSB_POWER_STATE.DeviceD2;
pub const WdmUsbPowerDeviceD3 = WDMUSB_POWER_STATE.DeviceD3;

pub const USB_POWER_INFO = extern struct {
    SystemState: WDMUSB_POWER_STATE,
    HcDevicePowerState: WDMUSB_POWER_STATE,
    HcDeviceWake: WDMUSB_POWER_STATE,
    HcSystemWake: WDMUSB_POWER_STATE,
    RhDevicePowerState: WDMUSB_POWER_STATE,
    RhDeviceWake: WDMUSB_POWER_STATE,
    RhSystemWake: WDMUSB_POWER_STATE,
    LastSystemSleepState: WDMUSB_POWER_STATE,
    CanWakeup: u8,
    IsPowered: u8,
};

pub const USBUSER_POWER_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PowerInformation: USB_POWER_INFO,
};

pub const USB_OPEN_RAW_DEVICE_PARAMETERS = extern struct {
    PortStatus: u16,
    MaxPacketEp0: u16,
};

pub const USBUSER_OPEN_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_OPEN_RAW_DEVICE_PARAMETERS,
};

pub const USB_CLOSE_RAW_DEVICE_PARAMETERS = extern struct {
    xxx: u32,
};

pub const USBUSER_CLOSE_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_CLOSE_RAW_DEVICE_PARAMETERS,
};

pub const USB_SEND_RAW_COMMAND_PARAMETERS = extern struct {
    Usb_bmRequest: u8,
    Usb_bRequest: u8,
    Usb_wVlaue: u16,
    Usb_wIndex: u16,
    Usb_wLength: u16,
    DeviceAddress: u16,
    MaximumPacketSize: u16,
    Timeout: u32,
    DataLength: u32,
    UsbdStatusCode: i32,
    Data: [4]u8,
};

pub const USBUSER_SEND_RAW_COMMAND = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_SEND_RAW_COMMAND_PARAMETERS,
};

pub const USB_BANDWIDTH_INFO = extern struct {
    DeviceCount: u32,
    TotalBusBandwidth: u32,
    Total32secBandwidth: u32,
    AllocedBulkAndControl: u32,
    AllocedIso: u32,
    AllocedInterrupt_1ms: u32,
    AllocedInterrupt_2ms: u32,
    AllocedInterrupt_4ms: u32,
    AllocedInterrupt_8ms: u32,
    AllocedInterrupt_16ms: u32,
    AllocedInterrupt_32ms: u32,
};

pub const USBUSER_BANDWIDTH_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BandwidthInformation: USB_BANDWIDTH_INFO,
};

pub const USB_BUS_STATISTICS_0 = extern struct {
    DeviceCount: u32,
    CurrentSystemTime: LARGE_INTEGER,
    CurrentUsbFrame: u32,
    BulkBytes: u32,
    IsoBytes: u32,
    InterruptBytes: u32,
    ControlDataBytes: u32,
    PciInterruptCount: u32,
    HardResetCount: u32,
    WorkerSignalCount: u32,
    CommonBufferBytes: u32,
    WorkerIdleTimeMs: u32,
    RootHubEnabled: u8,
    RootHubDevicePowerState: u8,
    Unused: u8,
    NameIndex: u8,
};

pub const USBUSER_BUS_STATISTICS_0_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BusStatistics0: USB_BUS_STATISTICS_0,
};

pub const USB_DRIVER_VERSION_PARAMETERS = extern struct {
    DriverTrackingCode: u32,
    USBDI_Version: u32,
    USBUSER_Version: u32,
    CheckedPortDriver: u8,
    CheckedMiniportDriver: u8,
    USB_Version: u16,
};

pub const USBUSER_GET_DRIVER_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_DRIVER_VERSION_PARAMETERS,
};

pub const USB_USB2HW_VERSION_PARAMETERS = extern struct {
    Usb2HwRevision: u8,
};

pub const USBUSER_GET_USB2HW_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_USB2HW_VERSION_PARAMETERS,
};

pub const USBUSER_REFRESH_HCT_REG = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Flags: u32,
};

pub const WINUSB_PIPE_INFORMATION = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
};

pub const WINUSB_PIPE_INFORMATION_EX = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
    MaximumBytesPerInterval: u32,
};

pub const WINUSB_SETUP_PACKET = extern struct {
    RequestType: u8,
    Request: u8,
    Value: u16,
    Index: u16,
    Length: u16,
};

pub const USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
    IsStartupDelayTolerable: u8,
};

pub const USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
};

pub const USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
    InputFrameNumber: u32,
    InputMicroFrameNumber: u32,
    QueryPerformanceCounterAtInputFrameOrMicroFrame: LARGE_INTEGER,
    QueryPerformanceCounterFrequency: LARGE_INTEGER,
    PredictedAccuracyInMicroSeconds: u32,
    CurrentGenerationID: u32,
    CurrentQueryPerformanceCounter: LARGE_INTEGER,
    CurrentHardwareFrameNumber: u32,
    CurrentHardwareMicroFrameNumber: u32,
    CurrentUSBFrameNumber: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (34)
//--------------------------------------------------------------------------------
pub extern "WINUSB" fn WinUsb_Initialize(
    DeviceHandle: HANDLE,
    InterfaceHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_Free(
    InterfaceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetAssociatedInterface(
    InterfaceHandle: *c_void,
    AssociatedInterfaceIndex: u8,
    AssociatedInterfaceHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetDescriptor(
    InterfaceHandle: *c_void,
    DescriptorType: u8,
    Index: u8,
    LanguageID: u16,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryInterfaceSettings(
    InterfaceHandle: *c_void,
    AlternateInterfaceNumber: u8,
    UsbAltInterfaceDescriptor: *USB_INTERFACE_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryDeviceInformation(
    InterfaceHandle: *c_void,
    InformationType: u32,
    BufferLength: *u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetCurrentAlternateSetting(
    InterfaceHandle: *c_void,
    SettingNumber: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetCurrentAlternateSetting(
    InterfaceHandle: *c_void,
    SettingNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryPipe(
    InterfaceHandle: *c_void,
    AlternateInterfaceNumber: u8,
    PipeIndex: u8,
    PipeInformation: *WINUSB_PIPE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryPipeEx(
    InterfaceHandle: *c_void,
    AlternateSettingNumber: u8,
    PipeIndex: u8,
    PipeInformationEx: *WINUSB_PIPE_INFORMATION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetPipePolicy(
    InterfaceHandle: *c_void,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    Value: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetPipePolicy(
    InterfaceHandle: *c_void,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: *u32,
    // TODO: what to do with BytesParamIndex 3?
    Value: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ReadPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_WritePipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ControlTransfer(
    InterfaceHandle: *c_void,
    SetupPacket: WINUSB_SETUP_PACKET,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ResetPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_AbortPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_FlushPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetPowerPolicy(
    InterfaceHandle: *c_void,
    PolicyType: u32,
    ValueLength: u32,
    // TODO: what to do with BytesParamIndex 2?
    Value: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetPowerPolicy(
    InterfaceHandle: *c_void,
    PolicyType: u32,
    ValueLength: *u32,
    // TODO: what to do with BytesParamIndex 2?
    Value: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetOverlappedResult(
    InterfaceHandle: *c_void,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ParseConfigurationDescriptor(
    ConfigurationDescriptor: *USB_CONFIGURATION_DESCRIPTOR,
    StartPosition: *c_void,
    InterfaceNumber: i32,
    AlternateSetting: i32,
    InterfaceClass: i32,
    InterfaceSubClass: i32,
    InterfaceProtocol: i32,
) callconv(@import("std").os.windows.WINAPI) *USB_INTERFACE_DESCRIPTOR;

pub extern "WINUSB" fn WinUsb_ParseDescriptors(
    // TODO: what to do with BytesParamIndex 1?
    DescriptorBuffer: *c_void,
    TotalLength: u32,
    StartPosition: *c_void,
    DescriptorType: i32,
) callconv(@import("std").os.windows.WINAPI) *USB_COMMON_DESCRIPTOR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_GetCurrentFrameNumber(
    InterfaceHandle: *c_void,
    CurrentFrameNumber: *u32,
    TimeStamp: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_GetAdjustedFrameNumber(
    CurrentFrameNumber: *u32,
    TimeStamp: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_RegisterIsochBuffer(
    InterfaceHandle: *c_void,
    PipeID: u8,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *u8,
    BufferLength: u32,
    IsochBufferHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_UnregisterIsochBuffer(
    IsochBufferHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_WriteIsochPipe(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    FrameNumber: *u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_ReadIsochPipe(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    FrameNumber: *u32,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_WriteIsochPipeAsap(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINUSB" fn WinUsb_ReadIsochPipeAsap(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "WINUSB" fn WinUsb_StartTrackingForTimeSync(
    InterfaceHandle: *c_void,
    StartTrackingInfo: *USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "WINUSB" fn WinUsb_GetCurrentFrameNumberAndQpc(
    InterfaceHandle: *c_void,
    FrameQpcInfo: *USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "WINUSB" fn WinUsb_StopTrackingForTimeSync(
    InterfaceHandle: *c_void,
    StopTrackingInfo: *USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (5)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const HANDLE = @import("system_services.zig").HANDLE;
const BOOL = @import("system_services.zig").BOOL;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "USB_IDLE_CALLBACK")) { _ = USB_IDLE_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
