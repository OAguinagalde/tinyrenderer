//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (2040)
//--------------------------------------------------------------------------------
pub const TVI_ROOT = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65536));
pub const TVI_FIRST = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65535));
pub const TVI_LAST = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65534));
pub const TVI_SORT = @import("../zig.zig").typedConst(HTREEITEM, @as(i32, -65533));
pub const BCN_FIRST = @as(u32, 4294966046);
pub const FILEOPENORD = @as(u32, 1536);
pub const MULTIFILEOPENORD = @as(u32, 1537);
pub const PRINTDLGORD = @as(u32, 1538);
pub const PRNSETUPDLGORD = @as(u32, 1539);
pub const FINDDLGORD = @as(u32, 1540);
pub const REPLACEDLGORD = @as(u32, 1541);
pub const FONTDLGORD = @as(u32, 1542);
pub const FORMATDLGORD31 = @as(u32, 1543);
pub const FORMATDLGORD30 = @as(u32, 1544);
pub const RUNDLGORD = @as(u32, 1545);
pub const PAGESETUPDLGORD = @as(u32, 1546);
pub const NEWFILEOPENORD = @as(u32, 1547);
pub const PRINTDLGEXORD = @as(u32, 1549);
pub const PAGESETUPDLGORDMOTIF = @as(u32, 1550);
pub const COLORMGMTDLGORD = @as(u32, 1551);
pub const NEWFILEOPENV2ORD = @as(u32, 1552);
pub const NEWFILEOPENV3ORD = @as(u32, 1553);
pub const NEWFORMATDLGWITHLINK = @as(u32, 1591);
pub const IDC_MANAGE_LINK = @as(u32, 1592);
pub const WM_CTLCOLOR = @as(u32, 25);
pub const ILDRF_IMAGELOWQUALITY = @as(u32, 1);
pub const ILDRF_OVERLAYLOWQUALITY = @as(u32, 16);
pub const ILR_DEFAULT = @as(u32, 0);
pub const ILR_HORIZONTAL_LEFT = @as(u32, 0);
pub const ILR_HORIZONTAL_CENTER = @as(u32, 1);
pub const ILR_HORIZONTAL_RIGHT = @as(u32, 2);
pub const ILR_VERTICAL_TOP = @as(u32, 0);
pub const ILR_VERTICAL_CENTER = @as(u32, 16);
pub const ILR_VERTICAL_BOTTOM = @as(u32, 32);
pub const ILR_SCALE_CLIP = @as(u32, 0);
pub const ILR_SCALE_ASPECTRATIO = @as(u32, 256);
pub const ILGOS_ALWAYS = @as(u32, 0);
pub const ILGOS_FROMSTANDBY = @as(u32, 1);
pub const ILFIP_ALWAYS = @as(u32, 0);
pub const ILFIP_FROMSTANDBY = @as(u32, 1);
pub const ILDI_PURGE = @as(u32, 1);
pub const ILDI_STANDBY = @as(u32, 2);
pub const ILDI_RESETACCESS = @as(u32, 4);
pub const ILDI_QUERYACCESS = @as(u32, 8);
pub const MAXPROPPAGES = @as(u32, 100);
pub const PSP_DEFAULT = @as(u32, 0);
pub const PSP_DLGINDIRECT = @as(u32, 1);
pub const PSP_USEHICON = @as(u32, 2);
pub const PSP_USEICONID = @as(u32, 4);
pub const PSP_USETITLE = @as(u32, 8);
pub const PSP_RTLREADING = @as(u32, 16);
pub const PSP_HASHELP = @as(u32, 32);
pub const PSP_USEREFPARENT = @as(u32, 64);
pub const PSP_USECALLBACK = @as(u32, 128);
pub const PSP_PREMATURE = @as(u32, 1024);
pub const PSP_HIDEHEADER = @as(u32, 2048);
pub const PSP_USEHEADERTITLE = @as(u32, 4096);
pub const PSP_USEHEADERSUBTITLE = @as(u32, 8192);
pub const PSP_USEFUSIONCONTEXT = @as(u32, 16384);
pub const PSH_DEFAULT = @as(u32, 0);
pub const PSH_PROPTITLE = @as(u32, 1);
pub const PSH_USEHICON = @as(u32, 2);
pub const PSH_USEICONID = @as(u32, 4);
pub const PSH_PROPSHEETPAGE = @as(u32, 8);
pub const PSH_WIZARDHASFINISH = @as(u32, 16);
pub const PSH_WIZARD = @as(u32, 32);
pub const PSH_USEPSTARTPAGE = @as(u32, 64);
pub const PSH_NOAPPLYNOW = @as(u32, 128);
pub const PSH_USECALLBACK = @as(u32, 256);
pub const PSH_HASHELP = @as(u32, 512);
pub const PSH_MODELESS = @as(u32, 1024);
pub const PSH_RTLREADING = @as(u32, 2048);
pub const PSH_WIZARDCONTEXTHELP = @as(u32, 4096);
pub const PSH_WIZARD97 = @as(u32, 8192);
pub const PSH_WATERMARK = @as(u32, 32768);
pub const PSH_USEHBMWATERMARK = @as(u32, 65536);
pub const PSH_USEHPLWATERMARK = @as(u32, 131072);
pub const PSH_STRETCHWATERMARK = @as(u32, 262144);
pub const PSH_HEADER = @as(u32, 524288);
pub const PSH_USEHBMHEADER = @as(u32, 1048576);
pub const PSH_USEPAGELANG = @as(u32, 2097152);
pub const PSH_WIZARD_LITE = @as(u32, 4194304);
pub const PSH_NOCONTEXTHELP = @as(u32, 33554432);
pub const PSH_AEROWIZARD = @as(u32, 16384);
pub const PSH_RESIZABLE = @as(u32, 67108864);
pub const PSH_HEADERBITMAP = @as(u32, 134217728);
pub const PSH_NOMARGIN = @as(u32, 268435456);
pub const PSCB_INITIALIZED = @as(u32, 1);
pub const PSCB_PRECREATE = @as(u32, 2);
pub const PSCB_BUTTONPRESSED = @as(u32, 3);
pub const PSNRET_NOERROR = @as(u32, 0);
pub const PSNRET_INVALID = @as(u32, 1);
pub const PSNRET_INVALID_NOCHANGEPAGE = @as(u32, 2);
pub const PSNRET_MESSAGEHANDLED = @as(u32, 3);
pub const PSM_SETCURSEL = @as(u32, 1125);
pub const PSM_REMOVEPAGE = @as(u32, 1126);
pub const PSM_ADDPAGE = @as(u32, 1127);
pub const PSM_CHANGED = @as(u32, 1128);
pub const PSM_RESTARTWINDOWS = @as(u32, 1129);
pub const PSM_REBOOTSYSTEM = @as(u32, 1130);
pub const PSM_CANCELTOCLOSE = @as(u32, 1131);
pub const PSM_QUERYSIBLINGS = @as(u32, 1132);
pub const PSM_UNCHANGED = @as(u32, 1133);
pub const PSM_APPLY = @as(u32, 1134);
pub const PSM_SETTITLEA = @as(u32, 1135);
pub const PSM_SETTITLEW = @as(u32, 1144);
pub const PSM_SETWIZBUTTONS = @as(u32, 1136);
pub const PSWIZB_BACK = @as(u32, 1);
pub const PSWIZB_NEXT = @as(u32, 2);
pub const PSWIZB_FINISH = @as(u32, 4);
pub const PSWIZB_DISABLEDFINISH = @as(u32, 8);
pub const PSWIZBF_ELEVATIONREQUIRED = @as(u32, 1);
pub const PSWIZB_CANCEL = @as(u32, 16);
pub const PSM_PRESSBUTTON = @as(u32, 1137);
pub const PSBTN_BACK = @as(u32, 0);
pub const PSBTN_NEXT = @as(u32, 1);
pub const PSBTN_FINISH = @as(u32, 2);
pub const PSBTN_OK = @as(u32, 3);
pub const PSBTN_APPLYNOW = @as(u32, 4);
pub const PSBTN_CANCEL = @as(u32, 5);
pub const PSBTN_HELP = @as(u32, 6);
pub const PSBTN_MAX = @as(u32, 6);
pub const PSM_SETCURSELID = @as(u32, 1138);
pub const PSM_SETFINISHTEXTA = @as(u32, 1139);
pub const PSM_SETFINISHTEXTW = @as(u32, 1145);
pub const PSM_GETTABCONTROL = @as(u32, 1140);
pub const PSM_ISDIALOGMESSAGE = @as(u32, 1141);
pub const PSM_GETCURRENTPAGEHWND = @as(u32, 1142);
pub const PSM_INSERTPAGE = @as(u32, 1143);
pub const PSM_SETHEADERTITLEA = @as(u32, 1149);
pub const PSM_SETHEADERTITLEW = @as(u32, 1150);
pub const PSM_SETHEADERSUBTITLEA = @as(u32, 1151);
pub const PSM_SETHEADERSUBTITLEW = @as(u32, 1152);
pub const PSM_HWNDTOINDEX = @as(u32, 1153);
pub const PSM_INDEXTOHWND = @as(u32, 1154);
pub const PSM_PAGETOINDEX = @as(u32, 1155);
pub const PSM_INDEXTOPAGE = @as(u32, 1156);
pub const PSM_IDTOINDEX = @as(u32, 1157);
pub const PSM_INDEXTOID = @as(u32, 1158);
pub const PSM_GETRESULT = @as(u32, 1159);
pub const PSM_RECALCPAGESIZES = @as(u32, 1160);
pub const PSM_SETNEXTTEXTW = @as(u32, 1161);
pub const PSWIZB_SHOW = @as(u32, 0);
pub const PSWIZB_RESTORE = @as(u32, 1);
pub const PSM_SHOWWIZBUTTONS = @as(u32, 1162);
pub const PSM_ENABLEWIZBUTTONS = @as(u32, 1163);
pub const PSM_SETBUTTONTEXTW = @as(u32, 1164);
pub const ID_PSRESTARTWINDOWS = @as(u32, 2);
pub const WIZ_CXDLG = @as(u32, 276);
pub const WIZ_CYDLG = @as(u32, 140);
pub const WIZ_CXBMP = @as(u32, 80);
pub const WIZ_BODYX = @as(u32, 92);
pub const WIZ_BODYCX = @as(u32, 184);
pub const PROP_SM_CXDLG = @as(u32, 212);
pub const PROP_SM_CYDLG = @as(u32, 188);
pub const PROP_MED_CXDLG = @as(u32, 227);
pub const PROP_MED_CYDLG = @as(u32, 215);
pub const PROP_LG_CXDLG = @as(u32, 252);
pub const PROP_LG_CYDLG = @as(u32, 218);
pub const WM_CONTEXTMENU = @as(u32, 123);
pub const WM_UNICHAR = @as(u32, 265);
pub const WM_PRINTCLIENT = @as(u32, 792);
pub const EM_GETLIMITTEXT = @as(u32, 1061);
pub const EM_POSFROMCHAR = @as(u32, 1062);
pub const EM_CHARFROMPOS = @as(u32, 1063);
pub const EM_SCROLLCARET = @as(u32, 1073);
pub const EM_CANPASTE = @as(u32, 1074);
pub const EM_DISPLAYBAND = @as(u32, 1075);
pub const EM_EXGETSEL = @as(u32, 1076);
pub const EM_EXLIMITTEXT = @as(u32, 1077);
pub const EM_EXLINEFROMCHAR = @as(u32, 1078);
pub const EM_EXSETSEL = @as(u32, 1079);
pub const EM_FINDTEXT = @as(u32, 1080);
pub const EM_FORMATRANGE = @as(u32, 1081);
pub const EM_GETCHARFORMAT = @as(u32, 1082);
pub const EM_GETEVENTMASK = @as(u32, 1083);
pub const EM_GETOLEINTERFACE = @as(u32, 1084);
pub const EM_GETPARAFORMAT = @as(u32, 1085);
pub const EM_GETSELTEXT = @as(u32, 1086);
pub const EM_HIDESELECTION = @as(u32, 1087);
pub const EM_PASTESPECIAL = @as(u32, 1088);
pub const EM_REQUESTRESIZE = @as(u32, 1089);
pub const EM_SELECTIONTYPE = @as(u32, 1090);
pub const EM_SETBKGNDCOLOR = @as(u32, 1091);
pub const EM_SETCHARFORMAT = @as(u32, 1092);
pub const EM_SETEVENTMASK = @as(u32, 1093);
pub const EM_SETOLECALLBACK = @as(u32, 1094);
pub const EM_SETPARAFORMAT = @as(u32, 1095);
pub const EM_SETTARGETDEVICE = @as(u32, 1096);
pub const EM_STREAMIN = @as(u32, 1097);
pub const EM_STREAMOUT = @as(u32, 1098);
pub const EM_GETTEXTRANGE = @as(u32, 1099);
pub const EM_FINDWORDBREAK = @as(u32, 1100);
pub const EM_SETOPTIONS = @as(u32, 1101);
pub const EM_GETOPTIONS = @as(u32, 1102);
pub const EM_FINDTEXTEX = @as(u32, 1103);
pub const EM_GETWORDBREAKPROCEX = @as(u32, 1104);
pub const EM_SETWORDBREAKPROCEX = @as(u32, 1105);
pub const EM_SETUNDOLIMIT = @as(u32, 1106);
pub const EM_REDO = @as(u32, 1108);
pub const EM_CANREDO = @as(u32, 1109);
pub const EM_GETUNDONAME = @as(u32, 1110);
pub const EM_GETREDONAME = @as(u32, 1111);
pub const EM_STOPGROUPTYPING = @as(u32, 1112);
pub const EM_SETTEXTMODE = @as(u32, 1113);
pub const EM_GETTEXTMODE = @as(u32, 1114);
pub const EM_AUTOURLDETECT = @as(u32, 1115);
pub const AURL_ENABLEURL = @as(u32, 1);
pub const AURL_ENABLEEMAILADDR = @as(u32, 2);
pub const AURL_ENABLETELNO = @as(u32, 4);
pub const AURL_ENABLEEAURLS = @as(u32, 8);
pub const AURL_ENABLEDRIVELETTERS = @as(u32, 16);
pub const AURL_DISABLEMIXEDLGC = @as(u32, 32);
pub const EM_GETAUTOURLDETECT = @as(u32, 1116);
pub const EM_SETPALETTE = @as(u32, 1117);
pub const EM_GETTEXTEX = @as(u32, 1118);
pub const EM_GETTEXTLENGTHEX = @as(u32, 1119);
pub const EM_SHOWSCROLLBAR = @as(u32, 1120);
pub const EM_SETTEXTEX = @as(u32, 1121);
pub const EM_SETPUNCTUATION = @as(u32, 1124);
pub const EM_GETPUNCTUATION = @as(u32, 1125);
pub const EM_SETWORDWRAPMODE = @as(u32, 1126);
pub const EM_GETWORDWRAPMODE = @as(u32, 1127);
pub const EM_SETIMECOLOR = @as(u32, 1128);
pub const EM_GETIMECOLOR = @as(u32, 1129);
pub const EM_SETIMEOPTIONS = @as(u32, 1130);
pub const EM_GETIMEOPTIONS = @as(u32, 1131);
pub const EM_CONVPOSITION = @as(u32, 1132);
pub const EM_SETLANGOPTIONS = @as(u32, 1144);
pub const EM_GETLANGOPTIONS = @as(u32, 1145);
pub const EM_GETIMECOMPMODE = @as(u32, 1146);
pub const EM_FINDTEXTW = @as(u32, 1147);
pub const EM_FINDTEXTEXW = @as(u32, 1148);
pub const EM_RECONVERSION = @as(u32, 1149);
pub const EM_SETIMEMODEBIAS = @as(u32, 1150);
pub const EM_GETIMEMODEBIAS = @as(u32, 1151);
pub const EM_SETBIDIOPTIONS = @as(u32, 1224);
pub const EM_GETBIDIOPTIONS = @as(u32, 1225);
pub const EM_SETTYPOGRAPHYOPTIONS = @as(u32, 1226);
pub const EM_GETTYPOGRAPHYOPTIONS = @as(u32, 1227);
pub const EM_SETEDITSTYLE = @as(u32, 1228);
pub const EM_GETEDITSTYLE = @as(u32, 1229);
pub const SES_EMULATESYSEDIT = @as(u32, 1);
pub const SES_BEEPONMAXTEXT = @as(u32, 2);
pub const SES_EXTENDBACKCOLOR = @as(u32, 4);
pub const SES_MAPCPS = @as(u32, 8);
pub const SES_HYPERLINKTOOLTIPS = @as(u32, 8);
pub const SES_EMULATE10 = @as(u32, 16);
pub const SES_DEFAULTLATINLIGA = @as(u32, 16);
pub const SES_USECRLF = @as(u32, 32);
pub const SES_NOFOCUSLINKNOTIFY = @as(u32, 32);
pub const SES_USEAIMM = @as(u32, 64);
pub const SES_NOIME = @as(u32, 128);
pub const SES_ALLOWBEEPS = @as(u32, 256);
pub const SES_UPPERCASE = @as(u32, 512);
pub const SES_LOWERCASE = @as(u32, 1024);
pub const SES_NOINPUTSEQUENCECHK = @as(u32, 2048);
pub const SES_BIDI = @as(u32, 4096);
pub const SES_SCROLLONKILLFOCUS = @as(u32, 8192);
pub const SES_XLTCRCRLFTOCR = @as(u32, 16384);
pub const SES_DRAFTMODE = @as(u32, 32768);
pub const SES_USECTF = @as(u32, 65536);
pub const SES_HIDEGRIDLINES = @as(u32, 131072);
pub const SES_USEATFONT = @as(u32, 262144);
pub const SES_CUSTOMLOOK = @as(u32, 524288);
pub const SES_LBSCROLLNOTIFY = @as(u32, 1048576);
pub const SES_CTFALLOWEMBED = @as(u32, 2097152);
pub const SES_CTFALLOWSMARTTAG = @as(u32, 4194304);
pub const SES_CTFALLOWPROOFING = @as(u32, 8388608);
pub const SES_LOGICALCARET = @as(u32, 16777216);
pub const SES_WORDDRAGDROP = @as(u32, 33554432);
pub const SES_SMARTDRAGDROP = @as(u32, 67108864);
pub const SES_MULTISELECT = @as(u32, 134217728);
pub const SES_CTFNOLOCK = @as(u32, 268435456);
pub const SES_NOEALINEHEIGHTADJUST = @as(u32, 536870912);
pub const SES_MAX = @as(u32, 536870912);
pub const IMF_AUTOKEYBOARD = @as(u32, 1);
pub const IMF_AUTOFONT = @as(u32, 2);
pub const IMF_IMECANCELCOMPLETE = @as(u32, 4);
pub const IMF_IMEALWAYSSENDNOTIFY = @as(u32, 8);
pub const IMF_AUTOFONTSIZEADJUST = @as(u32, 16);
pub const IMF_UIFONTS = @as(u32, 32);
pub const IMF_NOIMPLICITLANG = @as(u32, 64);
pub const IMF_DUALFONT = @as(u32, 128);
pub const IMF_NOKBDLIDFIXUP = @as(u32, 512);
pub const IMF_NORTFFONTSUBSTITUTE = @as(u32, 1024);
pub const IMF_SPELLCHECKING = @as(u32, 2048);
pub const IMF_TKBPREDICTION = @as(u32, 4096);
pub const IMF_IMEUIINTEGRATION = @as(u32, 8192);
pub const ICM_NOTOPEN = @as(u32, 0);
pub const ICM_LEVEL3 = @as(u32, 1);
pub const ICM_LEVEL2 = @as(u32, 2);
pub const ICM_LEVEL2_5 = @as(u32, 3);
pub const ICM_LEVEL2_SUI = @as(u32, 4);
pub const ICM_CTF = @as(u32, 5);
pub const TO_ADVANCEDTYPOGRAPHY = @as(u32, 1);
pub const TO_SIMPLELINEBREAK = @as(u32, 2);
pub const TO_DISABLECUSTOMTEXTOUT = @as(u32, 4);
pub const TO_ADVANCEDLAYOUT = @as(u32, 8);
pub const EM_OUTLINE = @as(u32, 1244);
pub const EM_GETSCROLLPOS = @as(u32, 1245);
pub const EM_SETSCROLLPOS = @as(u32, 1246);
pub const EM_SETFONTSIZE = @as(u32, 1247);
pub const EM_GETZOOM = @as(u32, 1248);
pub const EM_SETZOOM = @as(u32, 1249);
pub const EM_GETVIEWKIND = @as(u32, 1250);
pub const EM_SETVIEWKIND = @as(u32, 1251);
pub const EM_GETPAGE = @as(u32, 1252);
pub const EM_SETPAGE = @as(u32, 1253);
pub const EM_GETHYPHENATEINFO = @as(u32, 1254);
pub const EM_SETHYPHENATEINFO = @as(u32, 1255);
pub const EM_GETPAGEROTATE = @as(u32, 1259);
pub const EM_SETPAGEROTATE = @as(u32, 1260);
pub const EM_GETCTFMODEBIAS = @as(u32, 1261);
pub const EM_SETCTFMODEBIAS = @as(u32, 1262);
pub const EM_GETCTFOPENSTATUS = @as(u32, 1264);
pub const EM_SETCTFOPENSTATUS = @as(u32, 1265);
pub const EM_GETIMECOMPTEXT = @as(u32, 1266);
pub const EM_ISIME = @as(u32, 1267);
pub const EM_GETIMEPROPERTY = @as(u32, 1268);
pub const EM_GETQUERYRTFOBJ = @as(u32, 1293);
pub const EM_SETQUERYRTFOBJ = @as(u32, 1294);
pub const EPR_0 = @as(u32, 0);
pub const EPR_270 = @as(u32, 1);
pub const EPR_180 = @as(u32, 2);
pub const EPR_90 = @as(u32, 3);
pub const EPR_SE = @as(u32, 5);
pub const CTFMODEBIAS_DEFAULT = @as(u32, 0);
pub const CTFMODEBIAS_FILENAME = @as(u32, 1);
pub const CTFMODEBIAS_NAME = @as(u32, 2);
pub const CTFMODEBIAS_READING = @as(u32, 3);
pub const CTFMODEBIAS_DATETIME = @as(u32, 4);
pub const CTFMODEBIAS_CONVERSATION = @as(u32, 5);
pub const CTFMODEBIAS_NUMERIC = @as(u32, 6);
pub const CTFMODEBIAS_HIRAGANA = @as(u32, 7);
pub const CTFMODEBIAS_KATAKANA = @as(u32, 8);
pub const CTFMODEBIAS_HANGUL = @as(u32, 9);
pub const CTFMODEBIAS_HALFWIDTHKATAKANA = @as(u32, 10);
pub const CTFMODEBIAS_FULLWIDTHALPHANUMERIC = @as(u32, 11);
pub const CTFMODEBIAS_HALFWIDTHALPHANUMERIC = @as(u32, 12);
pub const IMF_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IMF_SMODE_NONE = @as(u32, 2);
pub const EMO_EXIT = @as(u32, 0);
pub const EMO_ENTER = @as(u32, 1);
pub const EMO_PROMOTE = @as(u32, 2);
pub const EMO_EXPAND = @as(u32, 3);
pub const EMO_MOVESELECTION = @as(u32, 4);
pub const EMO_GETVIEWMODE = @as(u32, 5);
pub const EMO_EXPANDSELECTION = @as(u32, 0);
pub const EMO_EXPANDDOCUMENT = @as(u32, 1);
pub const VM_NORMAL = @as(u32, 4);
pub const VM_OUTLINE = @as(u32, 2);
pub const VM_PAGE = @as(u32, 9);
pub const EM_INSERTTABLE = @as(u32, 1256);
pub const EM_GETAUTOCORRECTPROC = @as(u32, 1257);
pub const EM_SETAUTOCORRECTPROC = @as(u32, 1258);
pub const EM_CALLAUTOCORRECTPROC = @as(u32, 1279);
pub const ATP_NOCHANGE = @as(u32, 0);
pub const ATP_CHANGE = @as(u32, 1);
pub const ATP_NODELIMITER = @as(u32, 2);
pub const ATP_REPLACEALLTEXT = @as(u32, 4);
pub const EM_GETTABLEPARMS = @as(u32, 1289);
pub const EM_SETEDITSTYLEEX = @as(u32, 1299);
pub const EM_GETEDITSTYLEEX = @as(u32, 1300);
pub const SES_EX_NOTABLE = @as(u32, 4);
pub const SES_EX_NOMATH = @as(u32, 64);
pub const SES_EX_HANDLEFRIENDLYURL = @as(u32, 256);
pub const SES_EX_NOTHEMING = @as(u32, 524288);
pub const SES_EX_NOACETATESELECTION = @as(u32, 1048576);
pub const SES_EX_USESINGLELINE = @as(u32, 2097152);
pub const SES_EX_MULTITOUCH = @as(u32, 134217728);
pub const SES_EX_HIDETEMPFORMAT = @as(u32, 268435456);
pub const SES_EX_USEMOUSEWPARAM = @as(u32, 536870912);
pub const EM_GETSTORYTYPE = @as(u32, 1314);
pub const EM_SETSTORYTYPE = @as(u32, 1315);
pub const EM_GETELLIPSISMODE = @as(u32, 1329);
pub const EM_SETELLIPSISMODE = @as(u32, 1330);
pub const ELLIPSIS_MASK = @as(u32, 3);
pub const ELLIPSIS_NONE = @as(u32, 0);
pub const ELLIPSIS_END = @as(u32, 1);
pub const ELLIPSIS_WORD = @as(u32, 3);
pub const EM_SETTABLEPARMS = @as(u32, 1331);
pub const EM_GETTOUCHOPTIONS = @as(u32, 1334);
pub const EM_SETTOUCHOPTIONS = @as(u32, 1335);
pub const EM_INSERTIMAGE = @as(u32, 1338);
pub const EM_SETUIANAME = @as(u32, 1344);
pub const EM_GETELLIPSISSTATE = @as(u32, 1346);
pub const RTO_SHOWHANDLES = @as(u32, 1);
pub const RTO_DISABLEHANDLES = @as(u32, 2);
pub const RTO_READINGMODE = @as(u32, 3);
pub const EN_MSGFILTER = @as(u32, 1792);
pub const EN_REQUESTRESIZE = @as(u32, 1793);
pub const EN_SELCHANGE = @as(u32, 1794);
pub const EN_DROPFILES = @as(u32, 1795);
pub const EN_PROTECTED = @as(u32, 1796);
pub const EN_CORRECTTEXT = @as(u32, 1797);
pub const EN_STOPNOUNDO = @as(u32, 1798);
pub const EN_IMECHANGE = @as(u32, 1799);
pub const EN_SAVECLIPBOARD = @as(u32, 1800);
pub const EN_OLEOPFAILED = @as(u32, 1801);
pub const EN_OBJECTPOSITIONS = @as(u32, 1802);
pub const EN_LINK = @as(u32, 1803);
pub const EN_DRAGDROPDONE = @as(u32, 1804);
pub const EN_PARAGRAPHEXPANDED = @as(u32, 1805);
pub const EN_PAGECHANGE = @as(u32, 1806);
pub const EN_LOWFIRTF = @as(u32, 1807);
pub const EN_ALIGNLTR = @as(u32, 1808);
pub const EN_ALIGNRTL = @as(u32, 1809);
pub const EN_CLIPFORMAT = @as(u32, 1810);
pub const EN_STARTCOMPOSITION = @as(u32, 1811);
pub const EN_ENDCOMPOSITION = @as(u32, 1812);
pub const ENM_NONE = @as(u32, 0);
pub const ENM_CHANGE = @as(u32, 1);
pub const ENM_UPDATE = @as(u32, 2);
pub const ENM_SCROLL = @as(u32, 4);
pub const ENM_SCROLLEVENTS = @as(u32, 8);
pub const ENM_DRAGDROPDONE = @as(u32, 16);
pub const ENM_PARAGRAPHEXPANDED = @as(u32, 32);
pub const ENM_PAGECHANGE = @as(u32, 64);
pub const ENM_CLIPFORMAT = @as(u32, 128);
pub const ENM_KEYEVENTS = @as(u32, 65536);
pub const ENM_MOUSEEVENTS = @as(u32, 131072);
pub const ENM_REQUESTRESIZE = @as(u32, 262144);
pub const ENM_SELCHANGE = @as(u32, 524288);
pub const ENM_DROPFILES = @as(u32, 1048576);
pub const ENM_PROTECTED = @as(u32, 2097152);
pub const ENM_CORRECTTEXT = @as(u32, 4194304);
pub const ENM_IMECHANGE = @as(u32, 8388608);
pub const ENM_LANGCHANGE = @as(u32, 16777216);
pub const ENM_OBJECTPOSITIONS = @as(u32, 33554432);
pub const ENM_LINK = @as(u32, 67108864);
pub const ENM_LOWFIRTF = @as(u32, 134217728);
pub const ENM_STARTCOMPOSITION = @as(u32, 268435456);
pub const ENM_ENDCOMPOSITION = @as(u32, 536870912);
pub const ENM_GROUPTYPINGCHANGE = @as(u32, 1073741824);
pub const ENM_HIDELINKTOOLTIP = @as(u32, 2147483648);
pub const ES_SAVESEL = @as(u32, 32768);
pub const ES_SUNKEN = @as(u32, 16384);
pub const ES_DISABLENOSCROLL = @as(u32, 8192);
pub const ES_SELECTIONBAR = @as(u32, 16777216);
pub const ES_NOOLEDRAGDROP = @as(u32, 8);
pub const ES_EX_NOCALLOLEINIT = @as(u32, 0);
pub const ES_VERTICAL = @as(u32, 4194304);
pub const ES_NOIME = @as(u32, 524288);
pub const ES_SELFIME = @as(u32, 262144);
pub const ECO_AUTOWORDSELECTION = @as(u32, 1);
pub const ECO_AUTOVSCROLL = @as(u32, 64);
pub const ECO_AUTOHSCROLL = @as(u32, 128);
pub const ECO_NOHIDESEL = @as(u32, 256);
pub const ECO_READONLY = @as(u32, 2048);
pub const ECO_WANTRETURN = @as(u32, 4096);
pub const ECO_SAVESEL = @as(u32, 32768);
pub const ECO_SELECTIONBAR = @as(u32, 16777216);
pub const ECO_VERTICAL = @as(u32, 4194304);
pub const ECOOP_SET = @as(u32, 1);
pub const ECOOP_OR = @as(u32, 2);
pub const ECOOP_AND = @as(u32, 3);
pub const ECOOP_XOR = @as(u32, 4);
pub const WB_MOVEWORDPREV = @as(u32, 4);
pub const WB_MOVEWORDNEXT = @as(u32, 5);
pub const WB_PREVBREAK = @as(u32, 6);
pub const WB_NEXTBREAK = @as(u32, 7);
pub const PC_FOLLOWING = @as(u32, 1);
pub const PC_LEADING = @as(u32, 2);
pub const PC_OVERFLOW = @as(u32, 3);
pub const PC_DELIMITER = @as(u32, 4);
pub const WBF_WORDWRAP = @as(u32, 16);
pub const WBF_WORDBREAK = @as(u32, 32);
pub const WBF_OVERFLOW = @as(u32, 64);
pub const WBF_LEVEL1 = @as(u32, 128);
pub const WBF_LEVEL2 = @as(u32, 256);
pub const WBF_CUSTOM = @as(u32, 512);
pub const IMF_FORCENONE = @as(u32, 1);
pub const IMF_FORCEENABLE = @as(u32, 2);
pub const IMF_FORCEDISABLE = @as(u32, 4);
pub const IMF_CLOSESTATUSWINDOW = @as(u32, 8);
pub const IMF_VERTICAL = @as(u32, 32);
pub const IMF_FORCEACTIVE = @as(u32, 64);
pub const IMF_FORCEINACTIVE = @as(u32, 128);
pub const IMF_FORCEREMEMBER = @as(u32, 256);
pub const IMF_MULTIPLEEDIT = @as(u32, 1024);
pub const SCF_SELECTION = @as(u32, 1);
pub const SCF_WORD = @as(u32, 2);
pub const SCF_DEFAULT = @as(u32, 0);
pub const SCF_ALL = @as(u32, 4);
pub const SCF_USEUIRULES = @as(u32, 8);
pub const SCF_ASSOCIATEFONT = @as(u32, 16);
pub const SCF_NOKBUPDATE = @as(u32, 32);
pub const SCF_ASSOCIATEFONT2 = @as(u32, 64);
pub const SCF_SMARTFONT = @as(u32, 128);
pub const SCF_CHARREPFROMLCID = @as(u32, 256);
pub const SPF_DONTSETDEFAULT = @as(u32, 2);
pub const SPF_SETDEFAULT = @as(u32, 4);
pub const SF_TEXT = @as(u32, 1);
pub const SF_RTF = @as(u32, 2);
pub const SF_RTFNOOBJS = @as(u32, 3);
pub const SF_TEXTIZED = @as(u32, 4);
pub const SF_UNICODE = @as(u32, 16);
pub const SF_USECODEPAGE = @as(u32, 32);
pub const SF_NCRFORNONASCII = @as(u32, 64);
pub const SFF_WRITEXTRAPAR = @as(u32, 128);
pub const SFF_SELECTION = @as(u32, 32768);
pub const SFF_PLAINRTF = @as(u32, 16384);
pub const SFF_PERSISTVIEWSCALE = @as(u32, 8192);
pub const SFF_KEEPDOCINFO = @as(u32, 4096);
pub const SFF_PWD = @as(u32, 2048);
pub const SF_RTFVAL = @as(u32, 1792);
pub const MAX_TAB_STOPS = @as(u32, 32);
pub const MAX_TABLE_CELLS = @as(u32, 63);
pub const PFM_SPACEBEFORE = @as(u32, 64);
pub const PFM_SPACEAFTER = @as(u32, 128);
pub const PFM_LINESPACING = @as(u32, 256);
pub const PFM_STYLE = @as(u32, 1024);
pub const PFM_BORDER = @as(u32, 2048);
pub const PFM_SHADING = @as(u32, 4096);
pub const PFM_NUMBERINGSTYLE = @as(u32, 8192);
pub const PFM_NUMBERINGTAB = @as(u32, 16384);
pub const PFM_NUMBERINGSTART = @as(u32, 32768);
pub const PFM_KEEP = @as(u32, 131072);
pub const PFM_KEEPNEXT = @as(u32, 262144);
pub const PFM_PAGEBREAKBEFORE = @as(u32, 524288);
pub const PFM_NOLINENUMBER = @as(u32, 1048576);
pub const PFM_NOWIDOWCONTROL = @as(u32, 2097152);
pub const PFM_DONOTHYPHEN = @as(u32, 4194304);
pub const PFM_SIDEBYSIDE = @as(u32, 8388608);
pub const PFM_COLLAPSED = @as(u32, 16777216);
pub const PFM_OUTLINELEVEL = @as(u32, 33554432);
pub const PFM_BOX = @as(u32, 67108864);
pub const PFM_RESERVED2 = @as(u32, 134217728);
pub const PFM_TABLEROWDELIMITER = @as(u32, 268435456);
pub const PFM_TEXTWRAPPINGBREAK = @as(u32, 536870912);
pub const PFM_TABLE = @as(u32, 1073741824);
pub const PFN_BULLET = @as(u32, 1);
pub const PFN_ARABIC = @as(u32, 2);
pub const PFN_LCLETTER = @as(u32, 3);
pub const PFN_UCLETTER = @as(u32, 4);
pub const PFN_LCROMAN = @as(u32, 5);
pub const PFN_UCROMAN = @as(u32, 6);
pub const PFA_JUSTIFY = @as(u32, 4);
pub const PFA_FULL_INTERWORD = @as(u32, 4);
pub const WM_NOTIFY = @as(u32, 78);
pub const GCMF_GRIPPER = @as(u32, 1);
pub const GCMF_SPELLING = @as(u32, 2);
pub const GCMF_TOUCHMENU = @as(u32, 16384);
pub const GCMF_MOUSEMENU = @as(u32, 8192);
pub const OLEOP_DOVERB = @as(u32, 1);
pub const ST_DEFAULT = @as(u32, 0);
pub const ST_KEEPUNDO = @as(u32, 1);
pub const ST_SELECTION = @as(u32, 2);
pub const ST_NEWCHARS = @as(u32, 4);
pub const ST_UNICODE = @as(u32, 8);
pub const BOM_DEFPARADIR = @as(u32, 1);
pub const BOM_PLAINTEXT = @as(u32, 2);
pub const BOM_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOM_CONTEXTREADING = @as(u32, 8);
pub const BOM_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOM_LEGACYBIDICLASS = @as(u32, 64);
pub const BOM_UNICODEBIDI = @as(u32, 128);
pub const BOE_RTLDIR = @as(u32, 1);
pub const BOE_PLAINTEXT = @as(u32, 2);
pub const BOE_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOE_CONTEXTREADING = @as(u32, 8);
pub const BOE_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOE_FORCERECALC = @as(u32, 32);
pub const BOE_LEGACYBIDICLASS = @as(u32, 64);
pub const BOE_UNICODEBIDI = @as(u32, 128);
pub const FR_MATCHDIAC = @as(u32, 536870912);
pub const FR_MATCHKASHIDA = @as(u32, 1073741824);
pub const FR_MATCHALEFHAMZA = @as(u32, 2147483648);
pub const PFA_FULL_NEWSPAPER = @as(u32, 5);
pub const PFA_FULL_INTERLETTER = @as(u32, 6);
pub const PFA_FULL_SCALED = @as(u32, 7);
pub const PFA_FULL_GLYPHS = @as(u32, 8);
pub const AURL_ENABLEEA = @as(u32, 1);
pub const GCM_TOUCHMENU = @as(u32, 16384);
pub const GCM_MOUSEMENU = @as(u32, 8192);
pub const REO_NULL = @as(i32, 0);
pub const REO_READWRITEMASK = @as(i32, 2047);
pub const RECO_PASTE = @as(i32, 0);
pub const RECO_DROP = @as(i32, 1);
pub const RECO_COPY = @as(i32, 2);
pub const RECO_CUT = @as(i32, 3);
pub const RECO_DRAG = @as(i32, 4);
pub const TXTBIT_RICHTEXT = @as(u32, 1);
pub const TXTBIT_MULTILINE = @as(u32, 2);
pub const TXTBIT_READONLY = @as(u32, 4);
pub const TXTBIT_SHOWACCELERATOR = @as(u32, 8);
pub const TXTBIT_USEPASSWORD = @as(u32, 16);
pub const TXTBIT_HIDESELECTION = @as(u32, 32);
pub const TXTBIT_SAVESELECTION = @as(u32, 64);
pub const TXTBIT_AUTOWORDSEL = @as(u32, 128);
pub const TXTBIT_VERTICAL = @as(u32, 256);
pub const TXTBIT_SELBARCHANGE = @as(u32, 512);
pub const TXTBIT_WORDWRAP = @as(u32, 1024);
pub const TXTBIT_ALLOWBEEP = @as(u32, 2048);
pub const TXTBIT_DISABLEDRAG = @as(u32, 4096);
pub const TXTBIT_VIEWINSETCHANGE = @as(u32, 8192);
pub const TXTBIT_BACKSTYLECHANGE = @as(u32, 16384);
pub const TXTBIT_MAXLENGTHCHANGE = @as(u32, 32768);
pub const TXTBIT_SCROLLBARCHANGE = @as(u32, 65536);
pub const TXTBIT_CHARFORMATCHANGE = @as(u32, 131072);
pub const TXTBIT_PARAFORMATCHANGE = @as(u32, 262144);
pub const TXTBIT_EXTENTCHANGE = @as(u32, 524288);
pub const TXTBIT_CLIENTRECTCHANGE = @as(u32, 1048576);
pub const TXTBIT_USECURRENTBKG = @as(u32, 2097152);
pub const TXTBIT_NOTHREADREFCOUNT = @as(u32, 4194304);
pub const TXTBIT_SHOWPASSWORD = @as(u32, 8388608);
pub const TXTBIT_D2DDWRITE = @as(u32, 16777216);
pub const TXTBIT_D2DSIMPLETYPOGRAPHY = @as(u32, 33554432);
pub const TXTBIT_D2DPIXELSNAPPED = @as(u32, 67108864);
pub const TXTBIT_D2DSUBPIXELLINES = @as(u32, 134217728);
pub const TXTBIT_FLASHLASTPASSWORDCHAR = @as(u32, 268435456);
pub const TXTBIT_ADVANCEDINPUT = @as(u32, 536870912);
pub const TXES_ISDIALOG = @as(u32, 1);
pub const DA_LAST = @as(u32, 2147483647);
pub const DA_ERR = @as(i32, -1);
pub const DPAM_SORTED = @as(u32, 1);
pub const DPAM_NORMAL = @as(u32, 2);
pub const DPAM_UNION = @as(u32, 4);
pub const DPAM_INTERSECT = @as(u32, 8);
pub const DPAS_SORTED = @as(u32, 1);
pub const DPAS_INSERTBEFORE = @as(u32, 2);
pub const DPAS_INSERTAFTER = @as(u32, 4);
pub const MAX_THEMECOLOR = @as(u32, 64);
pub const MAX_THEMESIZE = @as(u32, 64);
pub const DTBG_CLIPRECT = @as(u32, 1);
pub const DTBG_DRAWSOLID = @as(u32, 2);
pub const DTBG_OMITBORDER = @as(u32, 4);
pub const DTBG_OMITCONTENT = @as(u32, 8);
pub const DTBG_COMPUTINGREGION = @as(u32, 16);
pub const DTBG_MIRRORDC = @as(u32, 32);
pub const DTBG_NOMIRROR = @as(u32, 64);
pub const DTT_GRAYED = @as(u32, 1);
pub const HTTB_BACKGROUNDSEG = @as(u32, 0);
pub const HTTB_FIXEDBORDER = @as(u32, 2);
pub const HTTB_CAPTION = @as(u32, 4);
pub const HTTB_RESIZINGBORDER_LEFT = @as(u32, 16);
pub const HTTB_RESIZINGBORDER_TOP = @as(u32, 32);
pub const HTTB_RESIZINGBORDER_RIGHT = @as(u32, 64);
pub const HTTB_RESIZINGBORDER_BOTTOM = @as(u32, 128);
pub const HTTB_SIZINGTEMPLATE = @as(u32, 256);
pub const HTTB_SYSTEMSIZINGMARGINS = @as(u32, 512);
pub const MAX_INTLIST_COUNT = @as(u32, 402);
pub const ETDT_DISABLE = @as(u32, 1);
pub const ETDT_ENABLE = @as(u32, 2);
pub const ETDT_USETABTEXTURE = @as(u32, 4);
pub const ETDT_USEAEROWIZARDTABTEXTURE = @as(u32, 8);
pub const WTNCA_NODRAWCAPTION = @as(u32, 1);
pub const WTNCA_NODRAWICON = @as(u32, 2);
pub const WTNCA_NOSYSMENU = @as(u32, 4);
pub const WTNCA_NOMIRRORHELP = @as(u32, 8);
pub const ODT_HEADER = @as(u32, 100);
pub const LVM_FIRST = @as(u32, 4096);
pub const TV_FIRST = @as(u32, 4352);
pub const HDM_FIRST = @as(u32, 4608);
pub const TCM_FIRST = @as(u32, 4864);
pub const PGM_FIRST = @as(u32, 5120);
pub const ECM_FIRST = @as(u32, 5376);
pub const BCM_FIRST = @as(u32, 5632);
pub const CBM_FIRST = @as(u32, 5888);
pub const CCM_FIRST = @as(u32, 8192);
pub const CCM_LAST = @as(u32, 8704);
pub const CCM_SETBKCOLOR = @as(u32, 8193);
pub const CCM_SETCOLORSCHEME = @as(u32, 8194);
pub const CCM_GETCOLORSCHEME = @as(u32, 8195);
pub const CCM_GETDROPTARGET = @as(u32, 8196);
pub const CCM_SETUNICODEFORMAT = @as(u32, 8197);
pub const CCM_GETUNICODEFORMAT = @as(u32, 8198);
pub const COMCTL32_VERSION = @as(u32, 6);
pub const CCM_SETVERSION = @as(u32, 8199);
pub const CCM_GETVERSION = @as(u32, 8200);
pub const CCM_SETNOTIFYWINDOW = @as(u32, 8201);
pub const CCM_SETWINDOWTHEME = @as(u32, 8203);
pub const CCM_DPISCALE = @as(u32, 8204);
pub const INFOTIPSIZE = @as(u32, 1024);
pub const MSGF_COMMCTRL_BEGINDRAG = @as(u32, 16896);
pub const MSGF_COMMCTRL_SIZEHEADER = @as(u32, 16897);
pub const MSGF_COMMCTRL_DRAGSELECT = @as(u32, 16898);
pub const MSGF_COMMCTRL_TOOLBARCUST = @as(u32, 16899);
pub const CDRF_DODEFAULT = @as(u32, 0);
pub const CDRF_NEWFONT = @as(u32, 2);
pub const CDRF_SKIPDEFAULT = @as(u32, 4);
pub const CDRF_DOERASE = @as(u32, 8);
pub const CDRF_SKIPPOSTPAINT = @as(u32, 256);
pub const CDRF_NOTIFYPOSTPAINT = @as(u32, 16);
pub const CDRF_NOTIFYITEMDRAW = @as(u32, 32);
pub const CDRF_NOTIFYSUBITEMDRAW = @as(u32, 32);
pub const CDRF_NOTIFYPOSTERASE = @as(u32, 64);
pub const CDDS_POSTERASE = @as(u32, 4);
pub const CDDS_ITEM = @as(u32, 65536);
pub const CDIS_SELECTED = @as(u32, 1);
pub const CDIS_GRAYED = @as(u32, 2);
pub const CDIS_DISABLED = @as(u32, 4);
pub const CDIS_CHECKED = @as(u32, 8);
pub const CDIS_FOCUS = @as(u32, 16);
pub const CDIS_DEFAULT = @as(u32, 32);
pub const CDIS_HOT = @as(u32, 64);
pub const CDIS_MARKED = @as(u32, 128);
pub const CDIS_INDETERMINATE = @as(u32, 256);
pub const CDIS_SHOWKEYBOARDCUES = @as(u32, 512);
pub const CDIS_NEARHOT = @as(u32, 1024);
pub const CDIS_OTHERSIDEHOT = @as(u32, 2048);
pub const CDIS_DROPHILITED = @as(u32, 4096);
pub const NM_GETCUSTOMSPLITRECT = @as(u32, 4294966049);
pub const CLR_NONE = @as(i32, -1);
pub const CLR_DEFAULT = @as(i32, -16777216);
pub const ILC_MASK = @as(u32, 1);
pub const ILC_COLOR = @as(u32, 0);
pub const ILC_COLORDDB = @as(u32, 254);
pub const ILC_COLOR4 = @as(u32, 4);
pub const ILC_COLOR8 = @as(u32, 8);
pub const ILC_COLOR16 = @as(u32, 16);
pub const ILC_COLOR24 = @as(u32, 24);
pub const ILC_COLOR32 = @as(u32, 32);
pub const ILC_PALETTE = @as(u32, 2048);
pub const ILC_MIRROR = @as(u32, 8192);
pub const ILC_PERITEMMIRROR = @as(u32, 32768);
pub const ILC_ORIGINALSIZE = @as(u32, 65536);
pub const ILC_HIGHQUALITYSCALE = @as(u32, 131072);
pub const ILD_TRANSPARENT = @as(u32, 1);
pub const ILD_IMAGE = @as(u32, 32);
pub const ILD_ROP = @as(u32, 64);
pub const ILD_BLEND25 = @as(u32, 2);
pub const ILD_OVERLAYMASK = @as(u32, 3840);
pub const ILD_PRESERVEALPHA = @as(u32, 4096);
pub const ILD_SCALE = @as(u32, 8192);
pub const ILD_DPISCALE = @as(u32, 16384);
pub const ILD_ASYNC = @as(u32, 32768);
pub const ILS_NORMAL = @as(u32, 0);
pub const ILS_GLOW = @as(u32, 1);
pub const ILS_SHADOW = @as(u32, 2);
pub const ILS_SATURATE = @as(u32, 4);
pub const ILS_ALPHA = @as(u32, 8);
pub const ILGT_NORMAL = @as(u32, 0);
pub const ILGT_ASYNC = @as(u32, 1);
pub const ILP_NORMAL = @as(u32, 0);
pub const ILP_DOWNLEVEL = @as(u32, 1);
pub const HDS_HORZ = @as(u32, 0);
pub const HDS_BUTTONS = @as(u32, 2);
pub const HDS_HOTTRACK = @as(u32, 4);
pub const HDS_HIDDEN = @as(u32, 8);
pub const HDS_DRAGDROP = @as(u32, 64);
pub const HDS_FULLDRAG = @as(u32, 128);
pub const HDS_FILTERBAR = @as(u32, 256);
pub const HDS_FLAT = @as(u32, 512);
pub const HDS_CHECKBOXES = @as(u32, 1024);
pub const HDS_NOSIZING = @as(u32, 2048);
pub const HDS_OVERFLOW = @as(u32, 4096);
pub const HDFT_ISSTRING = @as(u32, 0);
pub const HDFT_ISNUMBER = @as(u32, 1);
pub const HDFT_ISDATE = @as(u32, 2);
pub const HDFT_HASNOVALUE = @as(u32, 32768);
pub const HDF_LEFT = @as(u32, 0);
pub const HDF_RIGHT = @as(u32, 1);
pub const HDF_CENTER = @as(u32, 2);
pub const HDF_JUSTIFYMASK = @as(u32, 3);
pub const HDF_RTLREADING = @as(u32, 4);
pub const HDF_BITMAP = @as(u32, 8192);
pub const HDF_STRING = @as(u32, 16384);
pub const HDF_OWNERDRAW = @as(u32, 32768);
pub const HDF_IMAGE = @as(u32, 2048);
pub const HDF_BITMAP_ON_RIGHT = @as(u32, 4096);
pub const HDF_SORTUP = @as(u32, 1024);
pub const HDF_SORTDOWN = @as(u32, 512);
pub const HDF_CHECKBOX = @as(u32, 64);
pub const HDF_CHECKED = @as(u32, 128);
pub const HDF_FIXEDWIDTH = @as(u32, 256);
pub const HDF_SPLITBUTTON = @as(u32, 16777216);
pub const HDIS_FOCUSED = @as(u32, 1);
pub const HDM_GETITEMCOUNT = @as(u32, 4608);
pub const HDM_INSERTITEMA = @as(u32, 4609);
pub const HDM_INSERTITEMW = @as(u32, 4618);
pub const HDM_DELETEITEM = @as(u32, 4610);
pub const HDM_GETITEMA = @as(u32, 4611);
pub const HDM_GETITEMW = @as(u32, 4619);
pub const HDM_SETITEMA = @as(u32, 4612);
pub const HDM_SETITEMW = @as(u32, 4620);
pub const HDM_LAYOUT = @as(u32, 4613);
pub const HHT_NOWHERE = @as(u32, 1);
pub const HHT_ONHEADER = @as(u32, 2);
pub const HHT_ONDIVIDER = @as(u32, 4);
pub const HHT_ONDIVOPEN = @as(u32, 8);
pub const HHT_ONFILTER = @as(u32, 16);
pub const HHT_ONFILTERBUTTON = @as(u32, 32);
pub const HHT_ABOVE = @as(u32, 256);
pub const HHT_BELOW = @as(u32, 512);
pub const HHT_TORIGHT = @as(u32, 1024);
pub const HHT_TOLEFT = @as(u32, 2048);
pub const HHT_ONITEMSTATEICON = @as(u32, 4096);
pub const HHT_ONDROPDOWN = @as(u32, 8192);
pub const HHT_ONOVERFLOW = @as(u32, 16384);
pub const HDSIL_NORMAL = @as(u32, 0);
pub const HDSIL_STATE = @as(u32, 1);
pub const HDM_HITTEST = @as(u32, 4614);
pub const HDM_GETITEMRECT = @as(u32, 4615);
pub const HDM_SETIMAGELIST = @as(u32, 4616);
pub const HDM_GETIMAGELIST = @as(u32, 4617);
pub const HDM_ORDERTOINDEX = @as(u32, 4623);
pub const HDM_CREATEDRAGIMAGE = @as(u32, 4624);
pub const HDM_GETORDERARRAY = @as(u32, 4625);
pub const HDM_SETORDERARRAY = @as(u32, 4626);
pub const HDM_SETHOTDIVIDER = @as(u32, 4627);
pub const HDM_SETBITMAPMARGIN = @as(u32, 4628);
pub const HDM_GETBITMAPMARGIN = @as(u32, 4629);
pub const HDM_SETFILTERCHANGETIMEOUT = @as(u32, 4630);
pub const HDM_EDITFILTER = @as(u32, 4631);
pub const HDM_CLEARFILTER = @as(u32, 4632);
pub const HDM_GETITEMDROPDOWNRECT = @as(u32, 4633);
pub const HDM_GETOVERFLOWRECT = @as(u32, 4634);
pub const HDM_GETFOCUSEDITEM = @as(u32, 4635);
pub const HDM_SETFOCUSEDITEM = @as(u32, 4636);
pub const CMB_MASKED = @as(u32, 2);
pub const TBSTATE_CHECKED = @as(u32, 1);
pub const TBSTATE_PRESSED = @as(u32, 2);
pub const TBSTATE_ENABLED = @as(u32, 4);
pub const TBSTATE_HIDDEN = @as(u32, 8);
pub const TBSTATE_INDETERMINATE = @as(u32, 16);
pub const TBSTATE_WRAP = @as(u32, 32);
pub const TBSTATE_ELLIPSES = @as(u32, 64);
pub const TBSTATE_MARKED = @as(u32, 128);
pub const TBSTYLE_BUTTON = @as(u32, 0);
pub const TBSTYLE_SEP = @as(u32, 1);
pub const TBSTYLE_CHECK = @as(u32, 2);
pub const TBSTYLE_GROUP = @as(u32, 4);
pub const TBSTYLE_DROPDOWN = @as(u32, 8);
pub const TBSTYLE_AUTOSIZE = @as(u32, 16);
pub const TBSTYLE_NOPREFIX = @as(u32, 32);
pub const TBSTYLE_TOOLTIPS = @as(u32, 256);
pub const TBSTYLE_WRAPABLE = @as(u32, 512);
pub const TBSTYLE_ALTDRAG = @as(u32, 1024);
pub const TBSTYLE_FLAT = @as(u32, 2048);
pub const TBSTYLE_LIST = @as(u32, 4096);
pub const TBSTYLE_CUSTOMERASE = @as(u32, 8192);
pub const TBSTYLE_REGISTERDROP = @as(u32, 16384);
pub const TBSTYLE_TRANSPARENT = @as(u32, 32768);
pub const TBSTYLE_EX_DRAWDDARROWS = @as(u32, 1);
pub const BTNS_SHOWTEXT = @as(u32, 64);
pub const BTNS_WHOLEDROPDOWN = @as(u32, 128);
pub const TBSTYLE_EX_MIXEDBUTTONS = @as(u32, 8);
pub const TBSTYLE_EX_HIDECLIPPEDBUTTONS = @as(u32, 16);
pub const TBSTYLE_EX_MULTICOLUMN = @as(u32, 2);
pub const TBSTYLE_EX_VERTICAL = @as(u32, 4);
pub const TBSTYLE_EX_DOUBLEBUFFER = @as(u32, 128);
pub const TBCDRF_NOEDGES = @as(u32, 65536);
pub const TBCDRF_HILITEHOTTRACK = @as(u32, 131072);
pub const TBCDRF_NOOFFSET = @as(u32, 262144);
pub const TBCDRF_NOMARK = @as(u32, 524288);
pub const TBCDRF_NOETCHEDEFFECT = @as(u32, 1048576);
pub const TBCDRF_BLENDICON = @as(u32, 2097152);
pub const TBCDRF_NOBACKGROUND = @as(u32, 4194304);
pub const TBCDRF_USECDCOLORS = @as(u32, 8388608);
pub const TB_ENABLEBUTTON = @as(u32, 1025);
pub const TB_CHECKBUTTON = @as(u32, 1026);
pub const TB_PRESSBUTTON = @as(u32, 1027);
pub const TB_HIDEBUTTON = @as(u32, 1028);
pub const TB_INDETERMINATE = @as(u32, 1029);
pub const TB_MARKBUTTON = @as(u32, 1030);
pub const TB_ISBUTTONENABLED = @as(u32, 1033);
pub const TB_ISBUTTONCHECKED = @as(u32, 1034);
pub const TB_ISBUTTONPRESSED = @as(u32, 1035);
pub const TB_ISBUTTONHIDDEN = @as(u32, 1036);
pub const TB_ISBUTTONINDETERMINATE = @as(u32, 1037);
pub const TB_ISBUTTONHIGHLIGHTED = @as(u32, 1038);
pub const TB_SETSTATE = @as(u32, 1041);
pub const TB_GETSTATE = @as(u32, 1042);
pub const TB_ADDBITMAP = @as(u32, 1043);
pub const IDB_STD_SMALL_COLOR = @as(u32, 0);
pub const IDB_STD_LARGE_COLOR = @as(u32, 1);
pub const IDB_VIEW_SMALL_COLOR = @as(u32, 4);
pub const IDB_VIEW_LARGE_COLOR = @as(u32, 5);
pub const IDB_HIST_SMALL_COLOR = @as(u32, 8);
pub const IDB_HIST_LARGE_COLOR = @as(u32, 9);
pub const IDB_HIST_NORMAL = @as(u32, 12);
pub const IDB_HIST_HOT = @as(u32, 13);
pub const IDB_HIST_DISABLED = @as(u32, 14);
pub const IDB_HIST_PRESSED = @as(u32, 15);
pub const STD_CUT = @as(u32, 0);
pub const STD_COPY = @as(u32, 1);
pub const STD_PASTE = @as(u32, 2);
pub const STD_UNDO = @as(u32, 3);
pub const STD_REDOW = @as(u32, 4);
pub const STD_DELETE = @as(u32, 5);
pub const STD_FILENEW = @as(u32, 6);
pub const STD_FILEOPEN = @as(u32, 7);
pub const STD_FILESAVE = @as(u32, 8);
pub const STD_PRINTPRE = @as(u32, 9);
pub const STD_PROPERTIES = @as(u32, 10);
pub const STD_HELP = @as(u32, 11);
pub const STD_FIND = @as(u32, 12);
pub const STD_REPLACE = @as(u32, 13);
pub const STD_PRINT = @as(u32, 14);
pub const VIEW_LARGEICONS = @as(u32, 0);
pub const VIEW_SMALLICONS = @as(u32, 1);
pub const VIEW_LIST = @as(u32, 2);
pub const VIEW_DETAILS = @as(u32, 3);
pub const VIEW_SORTNAME = @as(u32, 4);
pub const VIEW_SORTSIZE = @as(u32, 5);
pub const VIEW_SORTDATE = @as(u32, 6);
pub const VIEW_SORTTYPE = @as(u32, 7);
pub const VIEW_PARENTFOLDER = @as(u32, 8);
pub const VIEW_NETCONNECT = @as(u32, 9);
pub const VIEW_NETDISCONNECT = @as(u32, 10);
pub const VIEW_NEWFOLDER = @as(u32, 11);
pub const VIEW_VIEWMENU = @as(u32, 12);
pub const HIST_BACK = @as(u32, 0);
pub const HIST_FORWARD = @as(u32, 1);
pub const HIST_FAVORITES = @as(u32, 2);
pub const HIST_ADDTOFAVORITES = @as(u32, 3);
pub const HIST_VIEWTREE = @as(u32, 4);
pub const TB_ADDBUTTONSA = @as(u32, 1044);
pub const TB_INSERTBUTTONA = @as(u32, 1045);
pub const TB_DELETEBUTTON = @as(u32, 1046);
pub const TB_GETBUTTON = @as(u32, 1047);
pub const TB_BUTTONCOUNT = @as(u32, 1048);
pub const TB_COMMANDTOINDEX = @as(u32, 1049);
pub const TB_SAVERESTOREA = @as(u32, 1050);
pub const TB_SAVERESTOREW = @as(u32, 1100);
pub const TB_CUSTOMIZE = @as(u32, 1051);
pub const TB_ADDSTRINGA = @as(u32, 1052);
pub const TB_ADDSTRINGW = @as(u32, 1101);
pub const TB_GETITEMRECT = @as(u32, 1053);
pub const TB_BUTTONSTRUCTSIZE = @as(u32, 1054);
pub const TB_SETBUTTONSIZE = @as(u32, 1055);
pub const TB_SETBITMAPSIZE = @as(u32, 1056);
pub const TB_AUTOSIZE = @as(u32, 1057);
pub const TB_GETTOOLTIPS = @as(u32, 1059);
pub const TB_SETTOOLTIPS = @as(u32, 1060);
pub const TB_SETPARENT = @as(u32, 1061);
pub const TB_SETROWS = @as(u32, 1063);
pub const TB_GETROWS = @as(u32, 1064);
pub const TB_SETCMDID = @as(u32, 1066);
pub const TB_CHANGEBITMAP = @as(u32, 1067);
pub const TB_GETBITMAP = @as(u32, 1068);
pub const TB_GETBUTTONTEXTA = @as(u32, 1069);
pub const TB_GETBUTTONTEXTW = @as(u32, 1099);
pub const TB_REPLACEBITMAP = @as(u32, 1070);
pub const TB_SETINDENT = @as(u32, 1071);
pub const TB_SETIMAGELIST = @as(u32, 1072);
pub const TB_GETIMAGELIST = @as(u32, 1073);
pub const TB_LOADIMAGES = @as(u32, 1074);
pub const TB_GETRECT = @as(u32, 1075);
pub const TB_SETHOTIMAGELIST = @as(u32, 1076);
pub const TB_GETHOTIMAGELIST = @as(u32, 1077);
pub const TB_SETDISABLEDIMAGELIST = @as(u32, 1078);
pub const TB_GETDISABLEDIMAGELIST = @as(u32, 1079);
pub const TB_SETSTYLE = @as(u32, 1080);
pub const TB_GETSTYLE = @as(u32, 1081);
pub const TB_GETBUTTONSIZE = @as(u32, 1082);
pub const TB_SETBUTTONWIDTH = @as(u32, 1083);
pub const TB_SETMAXTEXTROWS = @as(u32, 1084);
pub const TB_GETTEXTROWS = @as(u32, 1085);
pub const TB_GETOBJECT = @as(u32, 1086);
pub const TB_GETHOTITEM = @as(u32, 1095);
pub const TB_SETHOTITEM = @as(u32, 1096);
pub const TB_SETANCHORHIGHLIGHT = @as(u32, 1097);
pub const TB_GETANCHORHIGHLIGHT = @as(u32, 1098);
pub const TB_MAPACCELERATORA = @as(u32, 1102);
pub const TB_GETINSERTMARK = @as(u32, 1103);
pub const TB_SETINSERTMARK = @as(u32, 1104);
pub const TB_INSERTMARKHITTEST = @as(u32, 1105);
pub const TB_MOVEBUTTON = @as(u32, 1106);
pub const TB_GETMAXSIZE = @as(u32, 1107);
pub const TB_SETEXTENDEDSTYLE = @as(u32, 1108);
pub const TB_GETEXTENDEDSTYLE = @as(u32, 1109);
pub const TB_GETPADDING = @as(u32, 1110);
pub const TB_SETPADDING = @as(u32, 1111);
pub const TB_SETINSERTMARKCOLOR = @as(u32, 1112);
pub const TB_GETINSERTMARKCOLOR = @as(u32, 1113);
pub const TB_MAPACCELERATORW = @as(u32, 1114);
pub const TBBF_LARGE = @as(u32, 1);
pub const TB_GETBITMAPFLAGS = @as(u32, 1065);
pub const TB_GETBUTTONINFOW = @as(u32, 1087);
pub const TB_SETBUTTONINFOW = @as(u32, 1088);
pub const TB_GETBUTTONINFOA = @as(u32, 1089);
pub const TB_SETBUTTONINFOA = @as(u32, 1090);
pub const TB_INSERTBUTTONW = @as(u32, 1091);
pub const TB_ADDBUTTONSW = @as(u32, 1092);
pub const TB_HITTEST = @as(u32, 1093);
pub const TB_SETDRAWTEXTFLAGS = @as(u32, 1094);
pub const TB_GETSTRINGW = @as(u32, 1115);
pub const TB_GETSTRINGA = @as(u32, 1116);
pub const TB_SETBOUNDINGSIZE = @as(u32, 1117);
pub const TB_SETHOTITEM2 = @as(u32, 1118);
pub const TB_HASACCELERATOR = @as(u32, 1119);
pub const TB_SETLISTGAP = @as(u32, 1120);
pub const TB_GETIMAGELISTCOUNT = @as(u32, 1122);
pub const TB_GETIDEALSIZE = @as(u32, 1123);
pub const TBMF_PAD = @as(u32, 1);
pub const TBMF_BARPAD = @as(u32, 2);
pub const TBMF_BUTTONSPACING = @as(u32, 4);
pub const TB_GETMETRICS = @as(u32, 1125);
pub const TB_SETMETRICS = @as(u32, 1126);
pub const TB_GETITEMDROPDOWNRECT = @as(u32, 1127);
pub const TB_SETPRESSEDIMAGELIST = @as(u32, 1128);
pub const TB_GETPRESSEDIMAGELIST = @as(u32, 1129);
pub const TBNRF_HIDEHELP = @as(u32, 1);
pub const TBNRF_ENDCUSTOMIZE = @as(u32, 2);
pub const TBDDRET_DEFAULT = @as(u32, 0);
pub const TBDDRET_NODEFAULT = @as(u32, 1);
pub const TBDDRET_TREATPRESSED = @as(u32, 2);
pub const RBIM_IMAGELIST = @as(u32, 1);
pub const RBS_TOOLTIPS = @as(u32, 256);
pub const RBS_VARHEIGHT = @as(u32, 512);
pub const RBS_BANDBORDERS = @as(u32, 1024);
pub const RBS_FIXEDORDER = @as(u32, 2048);
pub const RBS_REGISTERDROP = @as(u32, 4096);
pub const RBS_AUTOSIZE = @as(u32, 8192);
pub const RBS_VERTICALGRIPPER = @as(u32, 16384);
pub const RBS_DBLCLKTOGGLE = @as(u32, 32768);
pub const RBBS_BREAK = @as(u32, 1);
pub const RBBS_FIXEDSIZE = @as(u32, 2);
pub const RBBS_CHILDEDGE = @as(u32, 4);
pub const RBBS_HIDDEN = @as(u32, 8);
pub const RBBS_NOVERT = @as(u32, 16);
pub const RBBS_FIXEDBMP = @as(u32, 32);
pub const RBBS_VARIABLEHEIGHT = @as(u32, 64);
pub const RBBS_GRIPPERALWAYS = @as(u32, 128);
pub const RBBS_NOGRIPPER = @as(u32, 256);
pub const RBBS_USECHEVRON = @as(u32, 512);
pub const RBBS_HIDETITLE = @as(u32, 1024);
pub const RBBS_TOPALIGN = @as(u32, 2048);
pub const RBBIM_STYLE = @as(u32, 1);
pub const RBBIM_COLORS = @as(u32, 2);
pub const RBBIM_TEXT = @as(u32, 4);
pub const RBBIM_IMAGE = @as(u32, 8);
pub const RBBIM_CHILD = @as(u32, 16);
pub const RBBIM_CHILDSIZE = @as(u32, 32);
pub const RBBIM_SIZE = @as(u32, 64);
pub const RBBIM_BACKGROUND = @as(u32, 128);
pub const RBBIM_ID = @as(u32, 256);
pub const RBBIM_IDEALSIZE = @as(u32, 512);
pub const RBBIM_LPARAM = @as(u32, 1024);
pub const RBBIM_HEADERSIZE = @as(u32, 2048);
pub const RBBIM_CHEVRONLOCATION = @as(u32, 4096);
pub const RBBIM_CHEVRONSTATE = @as(u32, 8192);
pub const RB_INSERTBANDA = @as(u32, 1025);
pub const RB_DELETEBAND = @as(u32, 1026);
pub const RB_GETBARINFO = @as(u32, 1027);
pub const RB_SETBARINFO = @as(u32, 1028);
pub const RB_SETBANDINFOA = @as(u32, 1030);
pub const RB_SETPARENT = @as(u32, 1031);
pub const RB_HITTEST = @as(u32, 1032);
pub const RB_GETRECT = @as(u32, 1033);
pub const RB_INSERTBANDW = @as(u32, 1034);
pub const RB_SETBANDINFOW = @as(u32, 1035);
pub const RB_GETBANDCOUNT = @as(u32, 1036);
pub const RB_GETROWCOUNT = @as(u32, 1037);
pub const RB_GETROWHEIGHT = @as(u32, 1038);
pub const RB_IDTOINDEX = @as(u32, 1040);
pub const RB_GETTOOLTIPS = @as(u32, 1041);
pub const RB_SETTOOLTIPS = @as(u32, 1042);
pub const RB_SETBKCOLOR = @as(u32, 1043);
pub const RB_GETBKCOLOR = @as(u32, 1044);
pub const RB_SETTEXTCOLOR = @as(u32, 1045);
pub const RB_GETTEXTCOLOR = @as(u32, 1046);
pub const RBSTR_CHANGERECT = @as(u32, 1);
pub const RB_SIZETORECT = @as(u32, 1047);
pub const RB_BEGINDRAG = @as(u32, 1048);
pub const RB_ENDDRAG = @as(u32, 1049);
pub const RB_DRAGMOVE = @as(u32, 1050);
pub const RB_GETBARHEIGHT = @as(u32, 1051);
pub const RB_GETBANDINFOW = @as(u32, 1052);
pub const RB_GETBANDINFOA = @as(u32, 1053);
pub const RB_MINIMIZEBAND = @as(u32, 1054);
pub const RB_MAXIMIZEBAND = @as(u32, 1055);
pub const RB_GETBANDBORDERS = @as(u32, 1058);
pub const RB_SHOWBAND = @as(u32, 1059);
pub const RB_SETPALETTE = @as(u32, 1061);
pub const RB_GETPALETTE = @as(u32, 1062);
pub const RB_MOVEBAND = @as(u32, 1063);
pub const RB_GETBANDMARGINS = @as(u32, 1064);
pub const RB_SETEXTENDEDSTYLE = @as(u32, 1065);
pub const RB_GETEXTENDEDSTYLE = @as(u32, 1066);
pub const RB_PUSHCHEVRON = @as(u32, 1067);
pub const RB_SETBANDWIDTH = @as(u32, 1068);
pub const RBAB_AUTOSIZE = @as(u32, 1);
pub const RBAB_ADDBAND = @as(u32, 2);
pub const RBHT_NOWHERE = @as(u32, 1);
pub const RBHT_CAPTION = @as(u32, 2);
pub const RBHT_CLIENT = @as(u32, 3);
pub const RBHT_GRABBER = @as(u32, 4);
pub const RBHT_CHEVRON = @as(u32, 8);
pub const RBHT_SPLITTER = @as(u32, 16);
pub const TTS_ALWAYSTIP = @as(u32, 1);
pub const TTS_NOPREFIX = @as(u32, 2);
pub const TTS_NOANIMATE = @as(u32, 16);
pub const TTS_NOFADE = @as(u32, 32);
pub const TTS_BALLOON = @as(u32, 64);
pub const TTS_CLOSE = @as(u32, 128);
pub const TTS_USEVISUALSTYLE = @as(u32, 256);
pub const TTF_DI_SETITEM = @as(u32, 32768);
pub const TTDT_AUTOMATIC = @as(u32, 0);
pub const TTDT_RESHOW = @as(u32, 1);
pub const TTDT_AUTOPOP = @as(u32, 2);
pub const TTDT_INITIAL = @as(u32, 3);
pub const TTM_ACTIVATE = @as(u32, 1025);
pub const TTM_SETDELAYTIME = @as(u32, 1027);
pub const TTM_ADDTOOLA = @as(u32, 1028);
pub const TTM_ADDTOOLW = @as(u32, 1074);
pub const TTM_DELTOOLA = @as(u32, 1029);
pub const TTM_DELTOOLW = @as(u32, 1075);
pub const TTM_NEWTOOLRECTA = @as(u32, 1030);
pub const TTM_NEWTOOLRECTW = @as(u32, 1076);
pub const TTM_RELAYEVENT = @as(u32, 1031);
pub const TTM_GETTOOLINFOA = @as(u32, 1032);
pub const TTM_GETTOOLINFOW = @as(u32, 1077);
pub const TTM_SETTOOLINFOA = @as(u32, 1033);
pub const TTM_SETTOOLINFOW = @as(u32, 1078);
pub const TTM_HITTESTA = @as(u32, 1034);
pub const TTM_HITTESTW = @as(u32, 1079);
pub const TTM_GETTEXTA = @as(u32, 1035);
pub const TTM_GETTEXTW = @as(u32, 1080);
pub const TTM_UPDATETIPTEXTA = @as(u32, 1036);
pub const TTM_UPDATETIPTEXTW = @as(u32, 1081);
pub const TTM_GETTOOLCOUNT = @as(u32, 1037);
pub const TTM_ENUMTOOLSA = @as(u32, 1038);
pub const TTM_ENUMTOOLSW = @as(u32, 1082);
pub const TTM_GETCURRENTTOOLA = @as(u32, 1039);
pub const TTM_GETCURRENTTOOLW = @as(u32, 1083);
pub const TTM_WINDOWFROMPOINT = @as(u32, 1040);
pub const TTM_TRACKACTIVATE = @as(u32, 1041);
pub const TTM_TRACKPOSITION = @as(u32, 1042);
pub const TTM_SETTIPBKCOLOR = @as(u32, 1043);
pub const TTM_SETTIPTEXTCOLOR = @as(u32, 1044);
pub const TTM_GETDELAYTIME = @as(u32, 1045);
pub const TTM_GETTIPBKCOLOR = @as(u32, 1046);
pub const TTM_GETTIPTEXTCOLOR = @as(u32, 1047);
pub const TTM_SETMAXTIPWIDTH = @as(u32, 1048);
pub const TTM_GETMAXTIPWIDTH = @as(u32, 1049);
pub const TTM_SETMARGIN = @as(u32, 1050);
pub const TTM_GETMARGIN = @as(u32, 1051);
pub const TTM_POP = @as(u32, 1052);
pub const TTM_UPDATE = @as(u32, 1053);
pub const TTM_GETBUBBLESIZE = @as(u32, 1054);
pub const TTM_ADJUSTRECT = @as(u32, 1055);
pub const TTM_SETTITLEA = @as(u32, 1056);
pub const TTM_SETTITLEW = @as(u32, 1057);
pub const TTM_POPUP = @as(u32, 1058);
pub const TTM_GETTITLE = @as(u32, 1059);
pub const SBARS_SIZEGRIP = @as(u32, 256);
pub const SBARS_TOOLTIPS = @as(u32, 2048);
pub const SBT_TOOLTIPS = @as(u32, 2048);
pub const SB_SETTEXTA = @as(u32, 1025);
pub const SB_SETTEXTW = @as(u32, 1035);
pub const SB_GETTEXTA = @as(u32, 1026);
pub const SB_GETTEXTW = @as(u32, 1037);
pub const SB_GETTEXTLENGTHA = @as(u32, 1027);
pub const SB_GETTEXTLENGTHW = @as(u32, 1036);
pub const SB_SETPARTS = @as(u32, 1028);
pub const SB_GETPARTS = @as(u32, 1030);
pub const SB_GETBORDERS = @as(u32, 1031);
pub const SB_SETMINHEIGHT = @as(u32, 1032);
pub const SB_SIMPLE = @as(u32, 1033);
pub const SB_GETRECT = @as(u32, 1034);
pub const SB_ISSIMPLE = @as(u32, 1038);
pub const SB_SETICON = @as(u32, 1039);
pub const SB_SETTIPTEXTA = @as(u32, 1040);
pub const SB_SETTIPTEXTW = @as(u32, 1041);
pub const SB_GETTIPTEXTA = @as(u32, 1042);
pub const SB_GETTIPTEXTW = @as(u32, 1043);
pub const SB_GETICON = @as(u32, 1044);
pub const SBT_OWNERDRAW = @as(u32, 4096);
pub const SBT_NOBORDERS = @as(u32, 256);
pub const SBT_POPOUT = @as(u32, 512);
pub const SBT_RTLREADING = @as(u32, 1024);
pub const SBT_NOTABPARSING = @as(u32, 2048);
pub const SB_SIMPLEID = @as(u32, 255);
pub const TBS_AUTOTICKS = @as(u32, 1);
pub const TBS_VERT = @as(u32, 2);
pub const TBS_HORZ = @as(u32, 0);
pub const TBS_TOP = @as(u32, 4);
pub const TBS_BOTTOM = @as(u32, 0);
pub const TBS_LEFT = @as(u32, 4);
pub const TBS_RIGHT = @as(u32, 0);
pub const TBS_BOTH = @as(u32, 8);
pub const TBS_NOTICKS = @as(u32, 16);
pub const TBS_ENABLESELRANGE = @as(u32, 32);
pub const TBS_FIXEDLENGTH = @as(u32, 64);
pub const TBS_NOTHUMB = @as(u32, 128);
pub const TBS_TOOLTIPS = @as(u32, 256);
pub const TBS_REVERSED = @as(u32, 512);
pub const TBS_DOWNISLEFT = @as(u32, 1024);
pub const TBS_NOTIFYBEFOREMOVE = @as(u32, 2048);
pub const TBS_TRANSPARENTBKGND = @as(u32, 4096);
pub const TBM_GETRANGEMIN = @as(u32, 1025);
pub const TBM_GETRANGEMAX = @as(u32, 1026);
pub const TBM_GETTIC = @as(u32, 1027);
pub const TBM_SETTIC = @as(u32, 1028);
pub const TBM_SETPOS = @as(u32, 1029);
pub const TBM_SETRANGE = @as(u32, 1030);
pub const TBM_SETRANGEMIN = @as(u32, 1031);
pub const TBM_SETRANGEMAX = @as(u32, 1032);
pub const TBM_CLEARTICS = @as(u32, 1033);
pub const TBM_SETSEL = @as(u32, 1034);
pub const TBM_SETSELSTART = @as(u32, 1035);
pub const TBM_SETSELEND = @as(u32, 1036);
pub const TBM_GETPTICS = @as(u32, 1038);
pub const TBM_GETTICPOS = @as(u32, 1039);
pub const TBM_GETNUMTICS = @as(u32, 1040);
pub const TBM_GETSELSTART = @as(u32, 1041);
pub const TBM_GETSELEND = @as(u32, 1042);
pub const TBM_CLEARSEL = @as(u32, 1043);
pub const TBM_SETTICFREQ = @as(u32, 1044);
pub const TBM_SETPAGESIZE = @as(u32, 1045);
pub const TBM_GETPAGESIZE = @as(u32, 1046);
pub const TBM_SETLINESIZE = @as(u32, 1047);
pub const TBM_GETLINESIZE = @as(u32, 1048);
pub const TBM_GETTHUMBRECT = @as(u32, 1049);
pub const TBM_GETCHANNELRECT = @as(u32, 1050);
pub const TBM_SETTHUMBLENGTH = @as(u32, 1051);
pub const TBM_GETTHUMBLENGTH = @as(u32, 1052);
pub const TBM_SETTOOLTIPS = @as(u32, 1053);
pub const TBM_GETTOOLTIPS = @as(u32, 1054);
pub const TBM_SETTIPSIDE = @as(u32, 1055);
pub const TBTS_TOP = @as(u32, 0);
pub const TBTS_LEFT = @as(u32, 1);
pub const TBTS_BOTTOM = @as(u32, 2);
pub const TBTS_RIGHT = @as(u32, 3);
pub const TBM_SETBUDDY = @as(u32, 1056);
pub const TBM_GETBUDDY = @as(u32, 1057);
pub const TBM_SETPOSNOTIFY = @as(u32, 1058);
pub const TB_LINEUP = @as(u32, 0);
pub const TB_LINEDOWN = @as(u32, 1);
pub const TB_PAGEUP = @as(u32, 2);
pub const TB_PAGEDOWN = @as(u32, 3);
pub const TB_THUMBPOSITION = @as(u32, 4);
pub const TB_THUMBTRACK = @as(u32, 5);
pub const TB_TOP = @as(u32, 6);
pub const TB_BOTTOM = @as(u32, 7);
pub const TB_ENDTRACK = @as(u32, 8);
pub const TBCD_TICS = @as(u32, 1);
pub const TBCD_THUMB = @as(u32, 2);
pub const TBCD_CHANNEL = @as(u32, 3);
pub const DL_CURSORSET = @as(u32, 0);
pub const DL_STOPCURSOR = @as(u32, 1);
pub const DL_COPYCURSOR = @as(u32, 2);
pub const DL_MOVECURSOR = @as(u32, 3);
pub const UD_MAXVAL = @as(u32, 32767);
pub const UDS_WRAP = @as(u32, 1);
pub const UDS_SETBUDDYINT = @as(u32, 2);
pub const UDS_ALIGNRIGHT = @as(u32, 4);
pub const UDS_ALIGNLEFT = @as(u32, 8);
pub const UDS_AUTOBUDDY = @as(u32, 16);
pub const UDS_ARROWKEYS = @as(u32, 32);
pub const UDS_HORZ = @as(u32, 64);
pub const UDS_NOTHOUSANDS = @as(u32, 128);
pub const UDS_HOTTRACK = @as(u32, 256);
pub const UDM_SETRANGE = @as(u32, 1125);
pub const UDM_GETRANGE = @as(u32, 1126);
pub const UDM_SETPOS = @as(u32, 1127);
pub const UDM_GETPOS = @as(u32, 1128);
pub const UDM_SETBUDDY = @as(u32, 1129);
pub const UDM_GETBUDDY = @as(u32, 1130);
pub const UDM_SETACCEL = @as(u32, 1131);
pub const UDM_GETACCEL = @as(u32, 1132);
pub const UDM_SETBASE = @as(u32, 1133);
pub const UDM_GETBASE = @as(u32, 1134);
pub const UDM_SETRANGE32 = @as(u32, 1135);
pub const UDM_GETRANGE32 = @as(u32, 1136);
pub const UDM_SETPOS32 = @as(u32, 1137);
pub const UDM_GETPOS32 = @as(u32, 1138);
pub const PBS_SMOOTH = @as(u32, 1);
pub const PBS_VERTICAL = @as(u32, 4);
pub const PBM_SETRANGE = @as(u32, 1025);
pub const PBM_SETPOS = @as(u32, 1026);
pub const PBM_DELTAPOS = @as(u32, 1027);
pub const PBM_SETSTEP = @as(u32, 1028);
pub const PBM_STEPIT = @as(u32, 1029);
pub const PBM_SETRANGE32 = @as(u32, 1030);
pub const PBM_GETRANGE = @as(u32, 1031);
pub const PBM_GETPOS = @as(u32, 1032);
pub const PBM_SETBARCOLOR = @as(u32, 1033);
pub const PBS_MARQUEE = @as(u32, 8);
pub const PBM_SETMARQUEE = @as(u32, 1034);
pub const PBS_SMOOTHREVERSE = @as(u32, 16);
pub const PBM_GETSTEP = @as(u32, 1037);
pub const PBM_GETBKCOLOR = @as(u32, 1038);
pub const PBM_GETBARCOLOR = @as(u32, 1039);
pub const PBM_SETSTATE = @as(u32, 1040);
pub const PBM_GETSTATE = @as(u32, 1041);
pub const PBST_NORMAL = @as(u32, 1);
pub const PBST_ERROR = @as(u32, 2);
pub const PBST_PAUSED = @as(u32, 3);
pub const HOTKEYF_SHIFT = @as(u32, 1);
pub const HOTKEYF_CONTROL = @as(u32, 2);
pub const HOTKEYF_ALT = @as(u32, 4);
pub const HOTKEYF_EXT = @as(u32, 128);
pub const HKCOMB_NONE = @as(u32, 1);
pub const HKCOMB_S = @as(u32, 2);
pub const HKCOMB_C = @as(u32, 4);
pub const HKCOMB_A = @as(u32, 8);
pub const HKCOMB_SC = @as(u32, 16);
pub const HKCOMB_SA = @as(u32, 32);
pub const HKCOMB_CA = @as(u32, 64);
pub const HKCOMB_SCA = @as(u32, 128);
pub const HKM_SETHOTKEY = @as(u32, 1025);
pub const HKM_GETHOTKEY = @as(u32, 1026);
pub const HKM_SETRULES = @as(u32, 1027);
pub const CCS_TOP = @as(i32, 1);
pub const CCS_NOMOVEY = @as(i32, 2);
pub const CCS_BOTTOM = @as(i32, 3);
pub const CCS_NORESIZE = @as(i32, 4);
pub const CCS_NOPARENTALIGN = @as(i32, 8);
pub const CCS_ADJUSTABLE = @as(i32, 32);
pub const CCS_NODIVIDER = @as(i32, 64);
pub const CCS_VERT = @as(i32, 128);
pub const INVALID_LINK_INDEX = @as(i32, -1);
pub const MAX_LINKID_TEXT = @as(u32, 48);
pub const LWS_TRANSPARENT = @as(u32, 1);
pub const LWS_IGNORERETURN = @as(u32, 2);
pub const LWS_NOPREFIX = @as(u32, 4);
pub const LWS_USEVISUALSTYLE = @as(u32, 8);
pub const LWS_USECUSTOMTEXT = @as(u32, 16);
pub const LWS_RIGHT = @as(u32, 32);
pub const LIF_ITEMINDEX = @as(u32, 1);
pub const LIF_STATE = @as(u32, 2);
pub const LIF_ITEMID = @as(u32, 4);
pub const LIF_URL = @as(u32, 8);
pub const LIS_FOCUSED = @as(u32, 1);
pub const LIS_ENABLED = @as(u32, 2);
pub const LIS_VISITED = @as(u32, 4);
pub const LIS_HOTTRACK = @as(u32, 8);
pub const LIS_DEFAULTCOLORS = @as(u32, 16);
pub const LM_HITTEST = @as(u32, 1792);
pub const LM_GETIDEALHEIGHT = @as(u32, 1793);
pub const LM_SETITEM = @as(u32, 1794);
pub const LM_GETITEM = @as(u32, 1795);
pub const LVS_ICON = @as(u32, 0);
pub const LVS_REPORT = @as(u32, 1);
pub const LVS_SMALLICON = @as(u32, 2);
pub const LVS_LIST = @as(u32, 3);
pub const LVS_TYPEMASK = @as(u32, 3);
pub const LVS_SINGLESEL = @as(u32, 4);
pub const LVS_SHOWSELALWAYS = @as(u32, 8);
pub const LVS_SORTASCENDING = @as(u32, 16);
pub const LVS_SORTDESCENDING = @as(u32, 32);
pub const LVS_SHAREIMAGELISTS = @as(u32, 64);
pub const LVS_NOLABELWRAP = @as(u32, 128);
pub const LVS_AUTOARRANGE = @as(u32, 256);
pub const LVS_EDITLABELS = @as(u32, 512);
pub const LVS_OWNERDATA = @as(u32, 4096);
pub const LVS_NOSCROLL = @as(u32, 8192);
pub const LVS_TYPESTYLEMASK = @as(u32, 64512);
pub const LVS_ALIGNTOP = @as(u32, 0);
pub const LVS_ALIGNLEFT = @as(u32, 2048);
pub const LVS_ALIGNMASK = @as(u32, 3072);
pub const LVS_OWNERDRAWFIXED = @as(u32, 1024);
pub const LVS_NOCOLUMNHEADER = @as(u32, 16384);
pub const LVS_NOSORTHEADER = @as(u32, 32768);
pub const LVM_GETBKCOLOR = @as(u32, 4096);
pub const LVM_SETBKCOLOR = @as(u32, 4097);
pub const LVM_GETIMAGELIST = @as(u32, 4098);
pub const LVSIL_NORMAL = @as(u32, 0);
pub const LVSIL_SMALL = @as(u32, 1);
pub const LVSIL_STATE = @as(u32, 2);
pub const LVSIL_GROUPHEADER = @as(u32, 3);
pub const LVM_SETIMAGELIST = @as(u32, 4099);
pub const LVM_GETITEMCOUNT = @as(u32, 4100);
pub const LVIF_TEXT = @as(u32, 1);
pub const LVIF_IMAGE = @as(u32, 2);
pub const LVIF_PARAM = @as(u32, 4);
pub const LVIF_STATE = @as(u32, 8);
pub const LVIF_INDENT = @as(u32, 16);
pub const LVIF_NORECOMPUTE = @as(u32, 2048);
pub const LVIF_GROUPID = @as(u32, 256);
pub const LVIF_COLUMNS = @as(u32, 512);
pub const LVIF_COLFMT = @as(u32, 65536);
pub const LVIS_FOCUSED = @as(u32, 1);
pub const LVIS_SELECTED = @as(u32, 2);
pub const LVIS_CUT = @as(u32, 4);
pub const LVIS_DROPHILITED = @as(u32, 8);
pub const LVIS_GLOW = @as(u32, 16);
pub const LVIS_ACTIVATING = @as(u32, 32);
pub const LVIS_OVERLAYMASK = @as(u32, 3840);
pub const LVIS_STATEIMAGEMASK = @as(u32, 61440);
pub const I_INDENTCALLBACK = @as(i32, -1);
pub const I_IMAGECALLBACK = @as(i32, -1);
pub const I_IMAGENONE = @as(i32, -2);
pub const LVM_GETITEMA = @as(u32, 4101);
pub const LVM_GETITEMW = @as(u32, 4171);
pub const LVM_SETITEMA = @as(u32, 4102);
pub const LVM_SETITEMW = @as(u32, 4172);
pub const LVM_INSERTITEMA = @as(u32, 4103);
pub const LVM_INSERTITEMW = @as(u32, 4173);
pub const LVM_DELETEITEM = @as(u32, 4104);
pub const LVM_DELETEALLITEMS = @as(u32, 4105);
pub const LVM_GETCALLBACKMASK = @as(u32, 4106);
pub const LVM_SETCALLBACKMASK = @as(u32, 4107);
pub const LVNI_ALL = @as(u32, 0);
pub const LVNI_FOCUSED = @as(u32, 1);
pub const LVNI_SELECTED = @as(u32, 2);
pub const LVNI_CUT = @as(u32, 4);
pub const LVNI_DROPHILITED = @as(u32, 8);
pub const LVNI_VISIBLEORDER = @as(u32, 16);
pub const LVNI_PREVIOUS = @as(u32, 32);
pub const LVNI_VISIBLEONLY = @as(u32, 64);
pub const LVNI_SAMEGROUPONLY = @as(u32, 128);
pub const LVNI_ABOVE = @as(u32, 256);
pub const LVNI_BELOW = @as(u32, 512);
pub const LVNI_TOLEFT = @as(u32, 1024);
pub const LVNI_TORIGHT = @as(u32, 2048);
pub const LVM_GETNEXTITEM = @as(u32, 4108);
pub const LVM_FINDITEMA = @as(u32, 4109);
pub const LVM_FINDITEMW = @as(u32, 4179);
pub const LVIR_BOUNDS = @as(u32, 0);
pub const LVIR_ICON = @as(u32, 1);
pub const LVIR_LABEL = @as(u32, 2);
pub const LVIR_SELECTBOUNDS = @as(u32, 3);
pub const LVM_GETITEMRECT = @as(u32, 4110);
pub const LVM_SETITEMPOSITION = @as(u32, 4111);
pub const LVM_GETITEMPOSITION = @as(u32, 4112);
pub const LVM_GETSTRINGWIDTHA = @as(u32, 4113);
pub const LVM_GETSTRINGWIDTHW = @as(u32, 4183);
pub const LVM_HITTEST = @as(u32, 4114);
pub const LVM_ENSUREVISIBLE = @as(u32, 4115);
pub const LVM_SCROLL = @as(u32, 4116);
pub const LVM_REDRAWITEMS = @as(u32, 4117);
pub const LVA_DEFAULT = @as(u32, 0);
pub const LVA_ALIGNLEFT = @as(u32, 1);
pub const LVA_ALIGNTOP = @as(u32, 2);
pub const LVA_SNAPTOGRID = @as(u32, 5);
pub const LVM_ARRANGE = @as(u32, 4118);
pub const LVM_EDITLABELA = @as(u32, 4119);
pub const LVM_EDITLABELW = @as(u32, 4214);
pub const LVM_GETEDITCONTROL = @as(u32, 4120);
pub const LVCFMT_LINE_BREAK = @as(u32, 1048576);
pub const LVCFMT_FILL = @as(u32, 2097152);
pub const LVCFMT_WRAP = @as(u32, 4194304);
pub const LVCFMT_NO_TITLE = @as(u32, 8388608);
pub const LVM_GETCOLUMNA = @as(u32, 4121);
pub const LVM_GETCOLUMNW = @as(u32, 4191);
pub const LVM_SETCOLUMNA = @as(u32, 4122);
pub const LVM_SETCOLUMNW = @as(u32, 4192);
pub const LVM_INSERTCOLUMNA = @as(u32, 4123);
pub const LVM_INSERTCOLUMNW = @as(u32, 4193);
pub const LVM_DELETECOLUMN = @as(u32, 4124);
pub const LVM_GETCOLUMNWIDTH = @as(u32, 4125);
pub const LVSCW_AUTOSIZE = @as(i32, -1);
pub const LVSCW_AUTOSIZE_USEHEADER = @as(i32, -2);
pub const LVM_SETCOLUMNWIDTH = @as(u32, 4126);
pub const LVM_GETHEADER = @as(u32, 4127);
pub const LVM_CREATEDRAGIMAGE = @as(u32, 4129);
pub const LVM_GETVIEWRECT = @as(u32, 4130);
pub const LVM_GETTEXTCOLOR = @as(u32, 4131);
pub const LVM_SETTEXTCOLOR = @as(u32, 4132);
pub const LVM_GETTEXTBKCOLOR = @as(u32, 4133);
pub const LVM_SETTEXTBKCOLOR = @as(u32, 4134);
pub const LVM_GETTOPINDEX = @as(u32, 4135);
pub const LVM_GETCOUNTPERPAGE = @as(u32, 4136);
pub const LVM_GETORIGIN = @as(u32, 4137);
pub const LVM_UPDATE = @as(u32, 4138);
pub const LVM_SETITEMSTATE = @as(u32, 4139);
pub const LVM_GETITEMSTATE = @as(u32, 4140);
pub const LVM_GETITEMTEXTA = @as(u32, 4141);
pub const LVM_GETITEMTEXTW = @as(u32, 4211);
pub const LVM_SETITEMTEXTA = @as(u32, 4142);
pub const LVM_SETITEMTEXTW = @as(u32, 4212);
pub const LVSICF_NOINVALIDATEALL = @as(u32, 1);
pub const LVSICF_NOSCROLL = @as(u32, 2);
pub const LVM_SETITEMCOUNT = @as(u32, 4143);
pub const LVM_SORTITEMS = @as(u32, 4144);
pub const LVM_SETITEMPOSITION32 = @as(u32, 4145);
pub const LVM_GETSELECTEDCOUNT = @as(u32, 4146);
pub const LVM_GETITEMSPACING = @as(u32, 4147);
pub const LVM_GETISEARCHSTRINGA = @as(u32, 4148);
pub const LVM_GETISEARCHSTRINGW = @as(u32, 4213);
pub const LVM_SETICONSPACING = @as(u32, 4149);
pub const LVM_SETEXTENDEDLISTVIEWSTYLE = @as(u32, 4150);
pub const LVM_GETEXTENDEDLISTVIEWSTYLE = @as(u32, 4151);
pub const LVS_EX_GRIDLINES = @as(u32, 1);
pub const LVS_EX_SUBITEMIMAGES = @as(u32, 2);
pub const LVS_EX_CHECKBOXES = @as(u32, 4);
pub const LVS_EX_TRACKSELECT = @as(u32, 8);
pub const LVS_EX_HEADERDRAGDROP = @as(u32, 16);
pub const LVS_EX_FULLROWSELECT = @as(u32, 32);
pub const LVS_EX_ONECLICKACTIVATE = @as(u32, 64);
pub const LVS_EX_TWOCLICKACTIVATE = @as(u32, 128);
pub const LVS_EX_FLATSB = @as(u32, 256);
pub const LVS_EX_REGIONAL = @as(u32, 512);
pub const LVS_EX_INFOTIP = @as(u32, 1024);
pub const LVS_EX_UNDERLINEHOT = @as(u32, 2048);
pub const LVS_EX_UNDERLINECOLD = @as(u32, 4096);
pub const LVS_EX_MULTIWORKAREAS = @as(u32, 8192);
pub const LVS_EX_LABELTIP = @as(u32, 16384);
pub const LVS_EX_BORDERSELECT = @as(u32, 32768);
pub const LVS_EX_DOUBLEBUFFER = @as(u32, 65536);
pub const LVS_EX_HIDELABELS = @as(u32, 131072);
pub const LVS_EX_SINGLEROW = @as(u32, 262144);
pub const LVS_EX_SNAPTOGRID = @as(u32, 524288);
pub const LVS_EX_SIMPLESELECT = @as(u32, 1048576);
pub const LVS_EX_JUSTIFYCOLUMNS = @as(u32, 2097152);
pub const LVS_EX_TRANSPARENTBKGND = @as(u32, 4194304);
pub const LVS_EX_TRANSPARENTSHADOWTEXT = @as(u32, 8388608);
pub const LVS_EX_AUTOAUTOARRANGE = @as(u32, 16777216);
pub const LVS_EX_HEADERINALLVIEWS = @as(u32, 33554432);
pub const LVS_EX_AUTOCHECKSELECT = @as(u32, 134217728);
pub const LVS_EX_AUTOSIZECOLUMNS = @as(u32, 268435456);
pub const LVS_EX_COLUMNSNAPPOINTS = @as(u32, 1073741824);
pub const LVS_EX_COLUMNOVERFLOW = @as(u32, 2147483648);
pub const LVM_GETSUBITEMRECT = @as(u32, 4152);
pub const LVM_SUBITEMHITTEST = @as(u32, 4153);
pub const LVM_SETCOLUMNORDERARRAY = @as(u32, 4154);
pub const LVM_GETCOLUMNORDERARRAY = @as(u32, 4155);
pub const LVM_SETHOTITEM = @as(u32, 4156);
pub const LVM_GETHOTITEM = @as(u32, 4157);
pub const LVM_SETHOTCURSOR = @as(u32, 4158);
pub const LVM_GETHOTCURSOR = @as(u32, 4159);
pub const LVM_APPROXIMATEVIEWRECT = @as(u32, 4160);
pub const LV_MAX_WORKAREAS = @as(u32, 16);
pub const LVM_SETWORKAREAS = @as(u32, 4161);
pub const LVM_GETWORKAREAS = @as(u32, 4166);
pub const LVM_GETNUMBEROFWORKAREAS = @as(u32, 4169);
pub const LVM_GETSELECTIONMARK = @as(u32, 4162);
pub const LVM_SETSELECTIONMARK = @as(u32, 4163);
pub const LVM_SETHOVERTIME = @as(u32, 4167);
pub const LVM_GETHOVERTIME = @as(u32, 4168);
pub const LVM_SETTOOLTIPS = @as(u32, 4170);
pub const LVM_GETTOOLTIPS = @as(u32, 4174);
pub const LVM_SORTITEMSEX = @as(u32, 4177);
pub const LVBKIF_SOURCE_NONE = @as(u32, 0);
pub const LVBKIF_SOURCE_HBITMAP = @as(u32, 1);
pub const LVBKIF_SOURCE_URL = @as(u32, 2);
pub const LVBKIF_SOURCE_MASK = @as(u32, 3);
pub const LVBKIF_STYLE_NORMAL = @as(u32, 0);
pub const LVBKIF_STYLE_TILE = @as(u32, 16);
pub const LVBKIF_STYLE_MASK = @as(u32, 16);
pub const LVBKIF_FLAG_TILEOFFSET = @as(u32, 256);
pub const LVBKIF_TYPE_WATERMARK = @as(u32, 268435456);
pub const LVBKIF_FLAG_ALPHABLEND = @as(u32, 536870912);
pub const LVM_SETBKIMAGEA = @as(u32, 4164);
pub const LVM_SETBKIMAGEW = @as(u32, 4234);
pub const LVM_GETBKIMAGEA = @as(u32, 4165);
pub const LVM_GETBKIMAGEW = @as(u32, 4235);
pub const LVM_SETSELECTEDCOLUMN = @as(u32, 4236);
pub const LV_VIEW_ICON = @as(u32, 0);
pub const LV_VIEW_DETAILS = @as(u32, 1);
pub const LV_VIEW_SMALLICON = @as(u32, 2);
pub const LV_VIEW_LIST = @as(u32, 3);
pub const LV_VIEW_TILE = @as(u32, 4);
pub const LV_VIEW_MAX = @as(u32, 4);
pub const LVM_SETVIEW = @as(u32, 4238);
pub const LVM_GETVIEW = @as(u32, 4239);
pub const LVGF_ALIGN = @as(u32, 8);
pub const LVGF_GROUPID = @as(u32, 16);
pub const LVGF_SUBTITLE = @as(u32, 256);
pub const LVGF_TASK = @as(u32, 512);
pub const LVGF_DESCRIPTIONTOP = @as(u32, 1024);
pub const LVGF_DESCRIPTIONBOTTOM = @as(u32, 2048);
pub const LVGF_TITLEIMAGE = @as(u32, 4096);
pub const LVGF_EXTENDEDIMAGE = @as(u32, 8192);
pub const LVGF_ITEMS = @as(u32, 16384);
pub const LVGF_SUBSET = @as(u32, 32768);
pub const LVGF_SUBSETITEMS = @as(u32, 65536);
pub const LVGS_NORMAL = @as(u32, 0);
pub const LVGS_COLLAPSED = @as(u32, 1);
pub const LVGS_HIDDEN = @as(u32, 2);
pub const LVGS_NOHEADER = @as(u32, 4);
pub const LVGS_COLLAPSIBLE = @as(u32, 8);
pub const LVGS_FOCUSED = @as(u32, 16);
pub const LVGS_SELECTED = @as(u32, 32);
pub const LVGS_SUBSETED = @as(u32, 64);
pub const LVGS_SUBSETLINKFOCUSED = @as(u32, 128);
pub const LVGA_FOOTER_LEFT = @as(u32, 8);
pub const LVGA_FOOTER_CENTER = @as(u32, 16);
pub const LVGA_FOOTER_RIGHT = @as(u32, 32);
pub const LVM_INSERTGROUP = @as(u32, 4241);
pub const LVM_SETGROUPINFO = @as(u32, 4243);
pub const LVM_GETGROUPINFO = @as(u32, 4245);
pub const LVM_REMOVEGROUP = @as(u32, 4246);
pub const LVM_MOVEGROUP = @as(u32, 4247);
pub const LVM_GETGROUPCOUNT = @as(u32, 4248);
pub const LVM_GETGROUPINFOBYINDEX = @as(u32, 4249);
pub const LVM_MOVEITEMTOGROUP = @as(u32, 4250);
pub const LVGGR_GROUP = @as(u32, 0);
pub const LVGGR_HEADER = @as(u32, 1);
pub const LVGGR_LABEL = @as(u32, 2);
pub const LVGGR_SUBSETLINK = @as(u32, 3);
pub const LVM_GETGROUPRECT = @as(u32, 4194);
pub const LVGMF_NONE = @as(u32, 0);
pub const LVGMF_BORDERSIZE = @as(u32, 1);
pub const LVGMF_BORDERCOLOR = @as(u32, 2);
pub const LVGMF_TEXTCOLOR = @as(u32, 4);
pub const LVM_SETGROUPMETRICS = @as(u32, 4251);
pub const LVM_GETGROUPMETRICS = @as(u32, 4252);
pub const LVM_ENABLEGROUPVIEW = @as(u32, 4253);
pub const LVM_SORTGROUPS = @as(u32, 4254);
pub const LVM_INSERTGROUPSORTED = @as(u32, 4255);
pub const LVM_REMOVEALLGROUPS = @as(u32, 4256);
pub const LVM_HASGROUP = @as(u32, 4257);
pub const LVM_GETGROUPSTATE = @as(u32, 4188);
pub const LVM_GETFOCUSEDGROUP = @as(u32, 4189);
pub const LVTVIF_AUTOSIZE = @as(u32, 0);
pub const LVTVIF_FIXEDWIDTH = @as(u32, 1);
pub const LVTVIF_FIXEDHEIGHT = @as(u32, 2);
pub const LVTVIF_FIXEDSIZE = @as(u32, 3);
pub const LVTVIM_TILESIZE = @as(u32, 1);
pub const LVTVIM_COLUMNS = @as(u32, 2);
pub const LVTVIM_LABELMARGIN = @as(u32, 4);
pub const LVM_SETTILEVIEWINFO = @as(u32, 4258);
pub const LVM_GETTILEVIEWINFO = @as(u32, 4259);
pub const LVM_SETTILEINFO = @as(u32, 4260);
pub const LVM_GETTILEINFO = @as(u32, 4261);
pub const LVIM_AFTER = @as(u32, 1);
pub const LVM_SETINSERTMARK = @as(u32, 4262);
pub const LVM_GETINSERTMARK = @as(u32, 4263);
pub const LVM_INSERTMARKHITTEST = @as(u32, 4264);
pub const LVM_GETINSERTMARKRECT = @as(u32, 4265);
pub const LVM_SETINSERTMARKCOLOR = @as(u32, 4266);
pub const LVM_GETINSERTMARKCOLOR = @as(u32, 4267);
pub const LVM_SETINFOTIP = @as(u32, 4269);
pub const LVM_GETSELECTEDCOLUMN = @as(u32, 4270);
pub const LVM_ISGROUPVIEWENABLED = @as(u32, 4271);
pub const LVM_GETOUTLINECOLOR = @as(u32, 4272);
pub const LVM_SETOUTLINECOLOR = @as(u32, 4273);
pub const LVM_CANCELEDITLABEL = @as(u32, 4275);
pub const LVM_MAPINDEXTOID = @as(u32, 4276);
pub const LVM_MAPIDTOINDEX = @as(u32, 4277);
pub const LVM_ISITEMVISIBLE = @as(u32, 4278);
pub const LVM_GETEMPTYTEXT = @as(u32, 4300);
pub const LVM_GETFOOTERRECT = @as(u32, 4301);
pub const LVFF_ITEMCOUNT = @as(u32, 1);
pub const LVM_GETFOOTERINFO = @as(u32, 4302);
pub const LVM_GETFOOTERITEMRECT = @as(u32, 4303);
pub const LVFIS_FOCUSED = @as(u32, 1);
pub const LVM_GETFOOTERITEM = @as(u32, 4304);
pub const LVM_GETITEMINDEXRECT = @as(u32, 4305);
pub const LVM_SETITEMINDEXSTATE = @as(u32, 4306);
pub const LVM_GETNEXTITEMINDEX = @as(u32, 4307);
pub const LVKF_ALT = @as(u32, 1);
pub const LVKF_CONTROL = @as(u32, 2);
pub const LVKF_SHIFT = @as(u32, 4);
pub const LVCDRF_NOSELECT = @as(u32, 65536);
pub const LVCDRF_NOGROUPFRAME = @as(u32, 131072);
pub const LVIF_DI_SETITEM = @as(u32, 4096);
pub const LVGIT_UNFOLDED = @as(u32, 1);
pub const LVNSCH_DEFAULT = @as(i32, -1);
pub const LVNSCH_ERROR = @as(i32, -2);
pub const LVNSCH_IGNORE = @as(i32, -3);
pub const TVS_HASBUTTONS = @as(u32, 1);
pub const TVS_HASLINES = @as(u32, 2);
pub const TVS_LINESATROOT = @as(u32, 4);
pub const TVS_EDITLABELS = @as(u32, 8);
pub const TVS_DISABLEDRAGDROP = @as(u32, 16);
pub const TVS_SHOWSELALWAYS = @as(u32, 32);
pub const TVS_RTLREADING = @as(u32, 64);
pub const TVS_NOTOOLTIPS = @as(u32, 128);
pub const TVS_CHECKBOXES = @as(u32, 256);
pub const TVS_TRACKSELECT = @as(u32, 512);
pub const TVS_SINGLEEXPAND = @as(u32, 1024);
pub const TVS_INFOTIP = @as(u32, 2048);
pub const TVS_FULLROWSELECT = @as(u32, 4096);
pub const TVS_NOSCROLL = @as(u32, 8192);
pub const TVS_NONEVENHEIGHT = @as(u32, 16384);
pub const TVS_NOHSCROLL = @as(u32, 32768);
pub const TVS_EX_NOSINGLECOLLAPSE = @as(u32, 1);
pub const TVS_EX_MULTISELECT = @as(u32, 2);
pub const TVS_EX_DOUBLEBUFFER = @as(u32, 4);
pub const TVS_EX_NOINDENTSTATE = @as(u32, 8);
pub const TVS_EX_RICHTOOLTIP = @as(u32, 16);
pub const TVS_EX_AUTOHSCROLL = @as(u32, 32);
pub const TVS_EX_FADEINOUTEXPANDOS = @as(u32, 64);
pub const TVS_EX_PARTIALCHECKBOXES = @as(u32, 128);
pub const TVS_EX_EXCLUSIONCHECKBOXES = @as(u32, 256);
pub const TVS_EX_DIMMEDCHECKBOXES = @as(u32, 512);
pub const TVS_EX_DRAWIMAGEASYNC = @as(u32, 1024);
pub const TVIS_SELECTED = @as(u32, 2);
pub const TVIS_CUT = @as(u32, 4);
pub const TVIS_DROPHILITED = @as(u32, 8);
pub const TVIS_BOLD = @as(u32, 16);
pub const TVIS_EXPANDED = @as(u32, 32);
pub const TVIS_EXPANDEDONCE = @as(u32, 64);
pub const TVIS_EXPANDPARTIAL = @as(u32, 128);
pub const TVIS_OVERLAYMASK = @as(u32, 3840);
pub const TVIS_STATEIMAGEMASK = @as(u32, 61440);
pub const TVIS_USERMASK = @as(u32, 61440);
pub const TVIS_EX_FLAT = @as(u32, 1);
pub const TVIS_EX_DISABLED = @as(u32, 2);
pub const TVIS_EX_ALL = @as(u32, 2);
pub const TVM_INSERTITEMA = @as(u32, 4352);
pub const TVM_INSERTITEMW = @as(u32, 4402);
pub const TVM_DELETEITEM = @as(u32, 4353);
pub const TVM_EXPAND = @as(u32, 4354);
pub const TVE_COLLAPSE = @as(u32, 1);
pub const TVE_EXPAND = @as(u32, 2);
pub const TVE_TOGGLE = @as(u32, 3);
pub const TVE_EXPANDPARTIAL = @as(u32, 16384);
pub const TVE_COLLAPSERESET = @as(u32, 32768);
pub const TVM_GETITEMRECT = @as(u32, 4356);
pub const TVM_GETCOUNT = @as(u32, 4357);
pub const TVM_GETINDENT = @as(u32, 4358);
pub const TVM_SETINDENT = @as(u32, 4359);
pub const TVM_GETIMAGELIST = @as(u32, 4360);
pub const TVSIL_NORMAL = @as(u32, 0);
pub const TVSIL_STATE = @as(u32, 2);
pub const TVM_SETIMAGELIST = @as(u32, 4361);
pub const TVM_GETNEXTITEM = @as(u32, 4362);
pub const TVGN_ROOT = @as(u32, 0);
pub const TVGN_NEXT = @as(u32, 1);
pub const TVGN_PREVIOUS = @as(u32, 2);
pub const TVGN_PARENT = @as(u32, 3);
pub const TVGN_CHILD = @as(u32, 4);
pub const TVGN_FIRSTVISIBLE = @as(u32, 5);
pub const TVGN_NEXTVISIBLE = @as(u32, 6);
pub const TVGN_PREVIOUSVISIBLE = @as(u32, 7);
pub const TVGN_DROPHILITE = @as(u32, 8);
pub const TVGN_CARET = @as(u32, 9);
pub const TVGN_LASTVISIBLE = @as(u32, 10);
pub const TVGN_NEXTSELECTED = @as(u32, 11);
pub const TVSI_NOSINGLEEXPAND = @as(u32, 32768);
pub const TVM_SELECTITEM = @as(u32, 4363);
pub const TVM_GETITEMA = @as(u32, 4364);
pub const TVM_GETITEMW = @as(u32, 4414);
pub const TVM_SETITEMA = @as(u32, 4365);
pub const TVM_SETITEMW = @as(u32, 4415);
pub const TVM_EDITLABELA = @as(u32, 4366);
pub const TVM_EDITLABELW = @as(u32, 4417);
pub const TVM_GETEDITCONTROL = @as(u32, 4367);
pub const TVM_GETVISIBLECOUNT = @as(u32, 4368);
pub const TVM_HITTEST = @as(u32, 4369);
pub const TVM_CREATEDRAGIMAGE = @as(u32, 4370);
pub const TVM_SORTCHILDREN = @as(u32, 4371);
pub const TVM_ENSUREVISIBLE = @as(u32, 4372);
pub const TVM_SORTCHILDRENCB = @as(u32, 4373);
pub const TVM_ENDEDITLABELNOW = @as(u32, 4374);
pub const TVM_GETISEARCHSTRINGA = @as(u32, 4375);
pub const TVM_GETISEARCHSTRINGW = @as(u32, 4416);
pub const TVM_SETTOOLTIPS = @as(u32, 4376);
pub const TVM_GETTOOLTIPS = @as(u32, 4377);
pub const TVM_SETINSERTMARK = @as(u32, 4378);
pub const TVM_SETITEMHEIGHT = @as(u32, 4379);
pub const TVM_GETITEMHEIGHT = @as(u32, 4380);
pub const TVM_SETBKCOLOR = @as(u32, 4381);
pub const TVM_SETTEXTCOLOR = @as(u32, 4382);
pub const TVM_GETBKCOLOR = @as(u32, 4383);
pub const TVM_GETTEXTCOLOR = @as(u32, 4384);
pub const TVM_SETSCROLLTIME = @as(u32, 4385);
pub const TVM_GETSCROLLTIME = @as(u32, 4386);
pub const TVM_SETINSERTMARKCOLOR = @as(u32, 4389);
pub const TVM_GETINSERTMARKCOLOR = @as(u32, 4390);
pub const TVM_SETBORDER = @as(u32, 4387);
pub const TVSBF_XBORDER = @as(u32, 1);
pub const TVSBF_YBORDER = @as(u32, 2);
pub const TVM_GETITEMSTATE = @as(u32, 4391);
pub const TVM_SETLINECOLOR = @as(u32, 4392);
pub const TVM_GETLINECOLOR = @as(u32, 4393);
pub const TVM_MAPACCIDTOHTREEITEM = @as(u32, 4394);
pub const TVM_MAPHTREEITEMTOACCID = @as(u32, 4395);
pub const TVM_SETEXTENDEDSTYLE = @as(u32, 4396);
pub const TVM_GETEXTENDEDSTYLE = @as(u32, 4397);
pub const TVM_SETAUTOSCROLLINFO = @as(u32, 4411);
pub const TVM_SETHOT = @as(u32, 4410);
pub const TVM_GETSELECTEDCOUNT = @as(u32, 4422);
pub const TVM_SHOWINFOTIP = @as(u32, 4423);
pub const TVM_GETITEMPARTRECT = @as(u32, 4424);
pub const TVC_UNKNOWN = @as(u32, 0);
pub const TVC_BYMOUSE = @as(u32, 1);
pub const TVC_BYKEYBOARD = @as(u32, 2);
pub const TVNRET_DEFAULT = @as(u32, 0);
pub const TVNRET_SKIPOLD = @as(u32, 1);
pub const TVNRET_SKIPNEW = @as(u32, 2);
pub const TVCDRF_NOIMAGES = @as(u32, 65536);
pub const CBEM_INSERTITEMA = @as(u32, 1025);
pub const CBEM_SETIMAGELIST = @as(u32, 1026);
pub const CBEM_GETIMAGELIST = @as(u32, 1027);
pub const CBEM_GETITEMA = @as(u32, 1028);
pub const CBEM_SETITEMA = @as(u32, 1029);
pub const CBEM_GETCOMBOCONTROL = @as(u32, 1030);
pub const CBEM_GETEDITCONTROL = @as(u32, 1031);
pub const CBEM_SETEXSTYLE = @as(u32, 1032);
pub const CBEM_SETEXTENDEDSTYLE = @as(u32, 1038);
pub const CBEM_GETEXSTYLE = @as(u32, 1033);
pub const CBEM_GETEXTENDEDSTYLE = @as(u32, 1033);
pub const CBEM_HASEDITCHANGED = @as(u32, 1034);
pub const CBEM_INSERTITEMW = @as(u32, 1035);
pub const CBEM_SETITEMW = @as(u32, 1036);
pub const CBEM_GETITEMW = @as(u32, 1037);
pub const CBES_EX_NOEDITIMAGE = @as(u32, 1);
pub const CBES_EX_NOEDITIMAGEINDENT = @as(u32, 2);
pub const CBES_EX_PATHWORDBREAKPROC = @as(u32, 4);
pub const CBES_EX_NOSIZELIMIT = @as(u32, 8);
pub const CBES_EX_CASESENSITIVE = @as(u32, 16);
pub const CBES_EX_TEXTENDELLIPSIS = @as(u32, 32);
pub const CBENF_KILLFOCUS = @as(u32, 1);
pub const CBENF_RETURN = @as(u32, 2);
pub const CBENF_ESCAPE = @as(u32, 3);
pub const CBENF_DROPDOWN = @as(u32, 4);
pub const CBEMAXSTRLEN = @as(u32, 260);
pub const TCS_SCROLLOPPOSITE = @as(u32, 1);
pub const TCS_BOTTOM = @as(u32, 2);
pub const TCS_RIGHT = @as(u32, 2);
pub const TCS_MULTISELECT = @as(u32, 4);
pub const TCS_FLATBUTTONS = @as(u32, 8);
pub const TCS_FORCEICONLEFT = @as(u32, 16);
pub const TCS_FORCELABELLEFT = @as(u32, 32);
pub const TCS_HOTTRACK = @as(u32, 64);
pub const TCS_VERTICAL = @as(u32, 128);
pub const TCS_TABS = @as(u32, 0);
pub const TCS_BUTTONS = @as(u32, 256);
pub const TCS_SINGLELINE = @as(u32, 0);
pub const TCS_MULTILINE = @as(u32, 512);
pub const TCS_RIGHTJUSTIFY = @as(u32, 0);
pub const TCS_FIXEDWIDTH = @as(u32, 1024);
pub const TCS_RAGGEDRIGHT = @as(u32, 2048);
pub const TCS_FOCUSONBUTTONDOWN = @as(u32, 4096);
pub const TCS_OWNERDRAWFIXED = @as(u32, 8192);
pub const TCS_TOOLTIPS = @as(u32, 16384);
pub const TCS_FOCUSNEVER = @as(u32, 32768);
pub const TCS_EX_FLATSEPARATORS = @as(u32, 1);
pub const TCS_EX_REGISTERDROP = @as(u32, 2);
pub const TCM_GETIMAGELIST = @as(u32, 4866);
pub const TCM_SETIMAGELIST = @as(u32, 4867);
pub const TCM_GETITEMCOUNT = @as(u32, 4868);
pub const TCIS_BUTTONPRESSED = @as(u32, 1);
pub const TCIS_HIGHLIGHTED = @as(u32, 2);
pub const TCM_GETITEMA = @as(u32, 4869);
pub const TCM_GETITEMW = @as(u32, 4924);
pub const TCM_SETITEMA = @as(u32, 4870);
pub const TCM_SETITEMW = @as(u32, 4925);
pub const TCM_INSERTITEMA = @as(u32, 4871);
pub const TCM_INSERTITEMW = @as(u32, 4926);
pub const TCM_DELETEITEM = @as(u32, 4872);
pub const TCM_DELETEALLITEMS = @as(u32, 4873);
pub const TCM_GETITEMRECT = @as(u32, 4874);
pub const TCM_GETCURSEL = @as(u32, 4875);
pub const TCM_SETCURSEL = @as(u32, 4876);
pub const TCM_HITTEST = @as(u32, 4877);
pub const TCM_SETITEMEXTRA = @as(u32, 4878);
pub const TCM_ADJUSTRECT = @as(u32, 4904);
pub const TCM_SETITEMSIZE = @as(u32, 4905);
pub const TCM_REMOVEIMAGE = @as(u32, 4906);
pub const TCM_SETPADDING = @as(u32, 4907);
pub const TCM_GETROWCOUNT = @as(u32, 4908);
pub const TCM_GETTOOLTIPS = @as(u32, 4909);
pub const TCM_SETTOOLTIPS = @as(u32, 4910);
pub const TCM_GETCURFOCUS = @as(u32, 4911);
pub const TCM_SETCURFOCUS = @as(u32, 4912);
pub const TCM_SETMINTABWIDTH = @as(u32, 4913);
pub const TCM_DESELECTALL = @as(u32, 4914);
pub const TCM_HIGHLIGHTITEM = @as(u32, 4915);
pub const TCM_SETEXTENDEDSTYLE = @as(u32, 4916);
pub const TCM_GETEXTENDEDSTYLE = @as(u32, 4917);
pub const ACS_CENTER = @as(u32, 1);
pub const ACS_TRANSPARENT = @as(u32, 2);
pub const ACS_AUTOPLAY = @as(u32, 4);
pub const ACS_TIMER = @as(u32, 8);
pub const ACM_OPENA = @as(u32, 1124);
pub const ACM_OPENW = @as(u32, 1127);
pub const ACM_PLAY = @as(u32, 1125);
pub const ACM_STOP = @as(u32, 1126);
pub const ACM_ISPLAYING = @as(u32, 1128);
pub const ACN_START = @as(u32, 1);
pub const ACN_STOP = @as(u32, 2);
pub const MCM_FIRST = @as(u32, 4096);
pub const MCM_GETCURSEL = @as(u32, 4097);
pub const MCM_SETCURSEL = @as(u32, 4098);
pub const MCM_GETMAXSELCOUNT = @as(u32, 4099);
pub const MCM_SETMAXSELCOUNT = @as(u32, 4100);
pub const MCM_GETSELRANGE = @as(u32, 4101);
pub const MCM_SETSELRANGE = @as(u32, 4102);
pub const MCM_GETMONTHRANGE = @as(u32, 4103);
pub const MCM_SETDAYSTATE = @as(u32, 4104);
pub const MCM_GETMINREQRECT = @as(u32, 4105);
pub const MCM_SETCOLOR = @as(u32, 4106);
pub const MCM_GETCOLOR = @as(u32, 4107);
pub const MCSC_BACKGROUND = @as(u32, 0);
pub const MCSC_TEXT = @as(u32, 1);
pub const MCSC_TITLEBK = @as(u32, 2);
pub const MCSC_TITLETEXT = @as(u32, 3);
pub const MCSC_MONTHBK = @as(u32, 4);
pub const MCSC_TRAILINGTEXT = @as(u32, 5);
pub const MCM_SETTODAY = @as(u32, 4108);
pub const MCM_GETTODAY = @as(u32, 4109);
pub const MCM_HITTEST = @as(u32, 4110);
pub const MCHT_TITLE = @as(u32, 65536);
pub const MCHT_CALENDAR = @as(u32, 131072);
pub const MCHT_TODAYLINK = @as(u32, 196608);
pub const MCHT_CALENDARCONTROL = @as(u32, 1048576);
pub const MCHT_NEXT = @as(u32, 16777216);
pub const MCHT_PREV = @as(u32, 33554432);
pub const MCHT_NOWHERE = @as(u32, 0);
pub const MCM_SETFIRSTDAYOFWEEK = @as(u32, 4111);
pub const MCM_GETFIRSTDAYOFWEEK = @as(u32, 4112);
pub const MCM_GETRANGE = @as(u32, 4113);
pub const MCM_SETRANGE = @as(u32, 4114);
pub const MCM_GETMONTHDELTA = @as(u32, 4115);
pub const MCM_SETMONTHDELTA = @as(u32, 4116);
pub const MCM_GETMAXTODAYWIDTH = @as(u32, 4117);
pub const MCMV_MONTH = @as(u32, 0);
pub const MCMV_YEAR = @as(u32, 1);
pub const MCMV_DECADE = @as(u32, 2);
pub const MCMV_CENTURY = @as(u32, 3);
pub const MCM_GETCURRENTVIEW = @as(u32, 4118);
pub const MCM_GETCALENDARCOUNT = @as(u32, 4119);
pub const MCM_GETCALENDARGRIDINFO = @as(u32, 4120);
pub const MCM_GETCALID = @as(u32, 4123);
pub const MCM_SETCALID = @as(u32, 4124);
pub const MCM_SIZERECTTOMIN = @as(u32, 4125);
pub const MCM_SETCALENDARBORDER = @as(u32, 4126);
pub const MCM_GETCALENDARBORDER = @as(u32, 4127);
pub const MCM_SETCURRENTVIEW = @as(u32, 4128);
pub const MCS_DAYSTATE = @as(u32, 1);
pub const MCS_MULTISELECT = @as(u32, 2);
pub const MCS_WEEKNUMBERS = @as(u32, 4);
pub const MCS_NOTODAYCIRCLE = @as(u32, 8);
pub const MCS_NOTODAY = @as(u32, 16);
pub const MCS_NOTRAILINGDATES = @as(u32, 64);
pub const MCS_SHORTDAYSOFWEEK = @as(u32, 128);
pub const MCS_NOSELCHANGEONNAV = @as(u32, 256);
pub const GMR_VISIBLE = @as(u32, 0);
pub const GMR_DAYSTATE = @as(u32, 1);
pub const DTM_FIRST = @as(u32, 4096);
pub const DTM_GETSYSTEMTIME = @as(u32, 4097);
pub const DTM_SETSYSTEMTIME = @as(u32, 4098);
pub const DTM_GETRANGE = @as(u32, 4099);
pub const DTM_SETRANGE = @as(u32, 4100);
pub const DTM_SETFORMATA = @as(u32, 4101);
pub const DTM_SETFORMATW = @as(u32, 4146);
pub const DTM_SETMCCOLOR = @as(u32, 4102);
pub const DTM_GETMCCOLOR = @as(u32, 4103);
pub const DTM_GETMONTHCAL = @as(u32, 4104);
pub const DTM_SETMCFONT = @as(u32, 4105);
pub const DTM_GETMCFONT = @as(u32, 4106);
pub const DTM_SETMCSTYLE = @as(u32, 4107);
pub const DTM_GETMCSTYLE = @as(u32, 4108);
pub const DTM_CLOSEMONTHCAL = @as(u32, 4109);
pub const DTM_GETDATETIMEPICKERINFO = @as(u32, 4110);
pub const DTM_GETIDEALSIZE = @as(u32, 4111);
pub const DTS_UPDOWN = @as(u32, 1);
pub const DTS_SHOWNONE = @as(u32, 2);
pub const DTS_SHORTDATEFORMAT = @as(u32, 0);
pub const DTS_LONGDATEFORMAT = @as(u32, 4);
pub const DTS_SHORTDATECENTURYFORMAT = @as(u32, 12);
pub const DTS_TIMEFORMAT = @as(u32, 9);
pub const DTS_APPCANPARSE = @as(u32, 16);
pub const DTS_RIGHTALIGN = @as(u32, 32);
pub const GDTR_MIN = @as(u32, 1);
pub const GDTR_MAX = @as(u32, 2);
pub const GDT_ERROR = @as(i32, -1);
pub const GDT_VALID = @as(u32, 0);
pub const GDT_NONE = @as(u32, 1);
pub const IPM_CLEARADDRESS = @as(u32, 1124);
pub const IPM_SETADDRESS = @as(u32, 1125);
pub const IPM_GETADDRESS = @as(u32, 1126);
pub const IPM_SETRANGE = @as(u32, 1127);
pub const IPM_SETFOCUS = @as(u32, 1128);
pub const IPM_ISBLANK = @as(u32, 1129);
pub const PGS_VERT = @as(u32, 0);
pub const PGS_HORZ = @as(u32, 1);
pub const PGS_AUTOSCROLL = @as(u32, 2);
pub const PGS_DRAGNDROP = @as(u32, 4);
pub const PGF_INVISIBLE = @as(u32, 0);
pub const PGF_NORMAL = @as(u32, 1);
pub const PGF_GRAYED = @as(u32, 2);
pub const PGF_DEPRESSED = @as(u32, 4);
pub const PGF_HOT = @as(u32, 8);
pub const PGB_TOPORLEFT = @as(u32, 0);
pub const PGB_BOTTOMORRIGHT = @as(u32, 1);
pub const PGM_SETCHILD = @as(u32, 5121);
pub const PGM_RECALCSIZE = @as(u32, 5122);
pub const PGM_FORWARDMOUSE = @as(u32, 5123);
pub const PGM_SETBKCOLOR = @as(u32, 5124);
pub const PGM_GETBKCOLOR = @as(u32, 5125);
pub const PGM_SETBORDER = @as(u32, 5126);
pub const PGM_GETBORDER = @as(u32, 5127);
pub const PGM_SETPOS = @as(u32, 5128);
pub const PGM_GETPOS = @as(u32, 5129);
pub const PGM_SETBUTTONSIZE = @as(u32, 5130);
pub const PGM_GETBUTTONSIZE = @as(u32, 5131);
pub const PGM_GETBUTTONSTATE = @as(u32, 5132);
pub const PGM_SETSCROLLINFO = @as(u32, 5133);
pub const NFS_EDIT = @as(u32, 1);
pub const NFS_STATIC = @as(u32, 2);
pub const NFS_LISTCOMBO = @as(u32, 4);
pub const NFS_BUTTON = @as(u32, 8);
pub const NFS_ALL = @as(u32, 16);
pub const NFS_USEFONTASSOC = @as(u32, 32);
pub const BCM_GETIDEALSIZE = @as(u32, 5633);
pub const BCM_SETIMAGELIST = @as(u32, 5634);
pub const BCM_GETIMAGELIST = @as(u32, 5635);
pub const BCM_SETTEXTMARGIN = @as(u32, 5636);
pub const BCM_GETTEXTMARGIN = @as(u32, 5637);
pub const BCN_HOTITEMCHANGE = @as(u32, 4294966047);
pub const BST_HOT = @as(u32, 512);
pub const BST_DROPDOWNPUSHED = @as(u32, 1024);
pub const BS_SPLITBUTTON = @as(i32, 12);
pub const BS_DEFSPLITBUTTON = @as(i32, 13);
pub const BS_COMMANDLINK = @as(i32, 14);
pub const BS_DEFCOMMANDLINK = @as(i32, 15);
pub const BCSIF_GLYPH = @as(u32, 1);
pub const BCSIF_IMAGE = @as(u32, 2);
pub const BCSIF_STYLE = @as(u32, 4);
pub const BCSIF_SIZE = @as(u32, 8);
pub const BCSS_NOSPLIT = @as(u32, 1);
pub const BCSS_STRETCH = @as(u32, 2);
pub const BCSS_ALIGNLEFT = @as(u32, 4);
pub const BCSS_IMAGE = @as(u32, 8);
pub const BCM_SETDROPDOWNSTATE = @as(u32, 5638);
pub const BCM_SETSPLITINFO = @as(u32, 5639);
pub const BCM_GETSPLITINFO = @as(u32, 5640);
pub const BCM_SETNOTE = @as(u32, 5641);
pub const BCM_GETNOTE = @as(u32, 5642);
pub const BCM_GETNOTELENGTH = @as(u32, 5643);
pub const BCM_SETSHIELD = @as(u32, 5644);
pub const BCN_DROPDOWN = @as(u32, 4294966048);
pub const ES_EX_ALLOWEOL_CR = @as(i32, 1);
pub const ES_EX_ALLOWEOL_LF = @as(i32, 2);
pub const ES_EX_CONVERT_EOL_ON_PASTE = @as(i32, 4);
pub const ES_EX_ZOOMABLE = @as(i32, 16);
pub const EM_SETCUEBANNER = @as(u32, 5377);
pub const EM_GETCUEBANNER = @as(u32, 5378);
pub const EM_SHOWBALLOONTIP = @as(u32, 5379);
pub const EM_HIDEBALLOONTIP = @as(u32, 5380);
pub const EM_SETHILITE = @as(u32, 5381);
pub const EM_GETHILITE = @as(u32, 5382);
pub const EM_NOSETFOCUS = @as(u32, 5383);
pub const EM_TAKEFOCUS = @as(u32, 5384);
pub const EM_SETEXTENDEDSTYLE = @as(u32, 5386);
pub const EM_GETEXTENDEDSTYLE = @as(u32, 5387);
pub const EM_SETENDOFLINE = @as(u32, 5388);
pub const EM_GETENDOFLINE = @as(u32, 5389);
pub const EM_ENABLESEARCHWEB = @as(u32, 5390);
pub const EM_SEARCHWEB = @as(u32, 5391);
pub const EM_SETCARETINDEX = @as(u32, 5393);
pub const EM_GETCARETINDEX = @as(u32, 5394);
pub const EM_FILELINEFROMCHAR = @as(u32, 5395);
pub const EM_FILELINEINDEX = @as(u32, 5396);
pub const EM_FILELINELENGTH = @as(u32, 5397);
pub const EM_GETFILELINE = @as(u32, 5398);
pub const EM_GETFILELINECOUNT = @as(u32, 5399);
pub const CB_SETMINVISIBLE = @as(u32, 5889);
pub const CB_GETMINVISIBLE = @as(u32, 5890);
pub const CB_SETCUEBANNER = @as(u32, 5891);
pub const CB_GETCUEBANNER = @as(u32, 5892);
pub const WM_MOUSEHOVER = @as(u32, 673);
pub const WM_MOUSELEAVE = @as(u32, 675);
pub const HOVER_DEFAULT = @as(u32, 4294967295);
pub const WSB_PROP_MASK = @as(i32, 4095);
pub const FSB_FLAT_MODE = @as(u32, 2);
pub const FSB_ENCARTA_MODE = @as(u32, 1);
pub const FSB_REGULAR_MODE = @as(u32, 0);

//--------------------------------------------------------------------------------
// Section: Types (498)
//--------------------------------------------------------------------------------
pub const _IMAGELIST = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const TBBUTTON = extern struct {
    iBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsStyle: u8,
    bReserved: [6]u8,
    dwData: usize,
    iString: isize,
};

}, else => struct { } };

pub const _TREEITEM = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _DSA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _DPA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32,
    yHeight: i32,
    Ascent: i32,
    Type: TEXT_ALIGN_OPTIONS,
    pwszAlternateText: [*:0]const u16,
    pIStream: *IStream,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR,
    dwCode: ENDCOMPOSITIONNOTIFY_CODE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE,
    lpstrText: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE,
    lpstrText: PWSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const EDITSTREAM = extern struct {
    dwCookie: usize,
    dwError: u32,
    pfnCallback: EDITSTREAMCALLBACK,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
    chrgText: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
    chrgText: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FORMATRANGE = extern struct {
    hdc: HDC,
    hdcTarget: HDC,
    rc: RECT,
    rcPage: RECT,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const MSGFILTER = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const REQRESIZE = extern struct {
    nmhdr: NMHDR,
    rc: RECT,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const SELCHANGE = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR,
    fGroupTyping: BOOL,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR,
    cf: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE,
    dwFlags: u32,
    pt: POINT,
    pvReserved: *c_void,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR,
    hDrop: HANDLE,
    cp: i32,
    fProtected: BOOL,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    cch: i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR,
    iob: i32,
    lOper: i32,
    hr: HRESULT,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    pcpPositions: *i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENLINK = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR,
    szControl: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const PUNCTUATION = extern struct {
    iSize: u32,
    szPunctuation: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const REPASTESPECIAL = extern struct {
    dwAspect: DVASPECT,
    dwParam: usize,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const GETTEXTEX = extern struct {
    cb: u32,
    flags: GETTEXTEX_FLAGS,
    codepage: u32,
    lpDefaultChar: [*:0]const u8,
    lpUsedDefChar: *i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const HYPHENATEINFO = extern struct {
    cbSize: i16,
    dxHyphenateZone: i16,
    pfnHyphenate: isize,
};

}, else => struct { } };

pub const HSYNTHETICPOINTERDEVICE = ?*opaque{};

// TODO: this type has a FreeFunc 'DestroyPropertySheetPage', what can Zig do with this information?
pub const HPROPSHEETPAGE = ?*opaque{};

// TODO: this type has a FreeFunc 'ImageList_Destroy', what can Zig do with this information?
pub const HIMAGELIST = ?*opaque{};

pub const HTREEITEM = ?*opaque{};

pub const LPFNPSPCALLBACKA = fn(
    hwnd: HWND,
    uMsg: PSPCB_MESSAGE,
    ppsp: *PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFNPSPCALLBACKW = fn(
    hwnd: HWND,
    uMsg: PSPCB_MESSAGE,
    ppsp: *PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PROPSHEETPAGEA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    hActCtx: HANDLE,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    hActCtx: HANDLE,
    Anonymous3: _Anonymous3_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    hActCtx: HANDLE,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    hActCtx: HANDLE,
    Anonymous3: _Anonymous3_e__Union,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNPROPSHEETCALLBACK = fn(
    param0: HWND,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PROPSHEETHEADERA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: [*:0]const u8,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: [*:0]const u8,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: _Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: _Anonymous5_e__Union,
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: [*:0]const u16,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: _Anonymous1_e__Union,
    pszCaption: [*:0]const u16,
    nPages: u32,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: _Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: _Anonymous5_e__Union,
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFNSVADDPROPSHEETPAGE = fn(
    param0: HPROPSHEETPAGE,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNADDPROPSHEETPAGES = fn(
    param0: *c_void,
    param1: LPFNSVADDPROPSHEETPAGE,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSHNOTIFY = extern struct {
    hdr: NMHDR,
    lParam: LPARAM,
};

pub const INITCOMMONCONTROLSEX = extern struct {
    dwSize: u32,
    dwICC: INITCOMMONCONTROLSEX_ICC,
};

pub const COLORSCHEME = extern struct {
    dwSize: u32,
    clrBtnHighlight: u32,
    clrBtnShadow: u32,
};

pub const NMTOOLTIPSCREATED = extern struct {
    hdr: NMHDR,
    hwndToolTips: HWND,
};

pub const NMMOUSE = extern struct {
    hdr: NMHDR,
    dwItemSpec: usize,
    dwItemData: usize,
    pt: POINT,
    dwHitInfo: LPARAM,
};

pub const NMOBJECTNOTIFY = extern struct {
    hdr: NMHDR,
    iItem: i32,
    piid: *const Guid,
    pObject: *c_void,
    hResult: HRESULT,
    dwFlags: u32,
};

pub const NMKEY = extern struct {
    hdr: NMHDR,
    nVKey: u32,
    uFlags: u32,
};

pub const NMCHAR = extern struct {
    hdr: NMHDR,
    ch: u32,
    dwItemPrev: u32,
    dwItemNext: u32,
};

pub const NMCUSTOMTEXT = extern struct {
    hdr: NMHDR,
    hDC: HDC,
    lpString: [*:0]const u16,
    nCount: i32,
    lpRect: *RECT,
    uFormat: u32,
    fLink: BOOL,
};

pub const NMCUSTOMDRAW = extern struct {
    hdr: NMHDR,
    dwDrawStage: NMCUSTOMDRAW_DRAW_STAGE,
    hdc: HDC,
    rc: RECT,
    dwItemSpec: usize,
    uItemState: u32,
    lItemlParam: LPARAM,
};

pub const NMTTCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    uDrawFlags: u32,
};

pub const NMCUSTOMSPLITRECTINFO = extern struct {
    hdr: NMHDR,
    rcClient: RECT,
    rcButton: RECT,
    rcSplit: RECT,
};

pub const IMAGELISTDRAWPARAMS = extern struct {
    cbSize: u32,
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    xBitmap: i32,
    yBitmap: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
    dwRop: u32,
    fState: u32,
    Frame: u32,
    crEffect: u32,
};

pub const IMAGEINFO = extern struct {
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
    Unused1: i32,
    Unused2: i32,
    rcImage: RECT,
};

pub const HD_TEXTFILTERA = extern struct {
    pszText: PSTR,
    cchTextMax: i32,
};

pub const HD_TEXTFILTERW = extern struct {
    pszText: PWSTR,
    cchTextMax: i32,
};

pub const HDITEMA = extern struct {
    mask: HDI_MASK,
    cxy: i32,
    pszText: PSTR,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: *c_void,
    state: u32,
};

pub const HDITEMW = extern struct {
    mask: HDI_MASK,
    cxy: i32,
    pszText: PWSTR,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: *c_void,
    state: u32,
};

pub const HDLAYOUT = extern struct {
    prc: *RECT,
    pwpos: *WINDOWPOS,
};

pub const HDHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
};

pub const NMHEADERA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: HEADER_CONTROL_NOTIFICATION_BUTTON,
    pitem: *HDITEMA,
};

pub const NMHEADERW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: HEADER_CONTROL_NOTIFICATION_BUTTON,
    pitem: *HDITEMW,
};

pub const NMHDDISPINFOW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: HDI_MASK,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDDISPINFOA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: HDI_MASK,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDFILTERBTNCLICK = extern struct {
    hdr: NMHDR,
    iItem: i32,
    rc: RECT,
};

pub const COLORMAP = extern struct {
    from: u32,
    to: u32,
};

pub const NMTBCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    hbrMonoDither: HBRUSH,
    hbrLines: HBRUSH,
    hpenLines: HPEN,
    clrText: u32,
    clrMark: u32,
    clrTextHighlight: u32,
    clrBtnFace: u32,
    clrBtnHighlight: u32,
    clrHighlightHotTrack: u32,
    rcText: RECT,
    nStringBkMode: i32,
    nHLStringBkMode: i32,
    iListGap: i32,
};

pub const TBADDBITMAP = extern struct {
    hInst: HINSTANCE,
    nID: usize,
};

pub const TBSAVEPARAMSA = extern struct {
    hkr: HKEY,
    pszSubKey: [*:0]const u8,
    pszValueName: [*:0]const u8,
};

pub const TBSAVEPARAMSW = extern struct {
    hkr: HKEY,
    pszSubKey: [*:0]const u16,
    pszValueName: [*:0]const u16,
};

pub const TBINSERTMARK = extern struct {
    iButton: i32,
    dwFlags: TBINSERTMARK_FLAGS,
};

pub const TBREPLACEBITMAP = extern struct {
    hInstOld: HINSTANCE,
    nIDOld: usize,
    hInstNew: HINSTANCE,
    nIDNew: usize,
    nButtons: i32,
};

pub const TBBUTTONINFOA = extern struct {
    cbSize: u32,
    dwMask: TBBUTTONINFOW_MASK,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: usize,
    pszText: PSTR,
    cchText: i32,
};

pub const TBBUTTONINFOW = extern struct {
    cbSize: u32,
    dwMask: TBBUTTONINFOW_MASK,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: usize,
    pszText: PWSTR,
    cchText: i32,
};

pub const TBMETRICS = extern struct {
    cbSize: u32,
    dwMask: u32,
    cxPad: i32,
    cyPad: i32,
    cxBarPad: i32,
    cyBarPad: i32,
    cxButtonSpacing: i32,
    cyButtonSpacing: i32,
};

pub const NMTBHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: NMTBHOTITEM_FLAGS,
};

pub const NMTBSAVE = extern struct {
    hdr: NMHDR,
    pData: *u32,
    pCurrent: *u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    tbButton: TBBUTTON,
};

pub const NMTBRESTORE = extern struct {
    hdr: NMHDR,
    pData: *u32,
    pCurrent: *u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    cbBytesPerRecord: i32,
    tbButton: TBBUTTON,
};

pub const NMTBGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: PSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: PWSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBDISPINFOA = extern struct {
    hdr: NMHDR,
    dwMask: NMTBDISPINFOW_MASK,
    idCommand: i32,
    lParam: usize,
    iImage: i32,
    pszText: PSTR,
    cchText: i32,
};

pub const NMTBDISPINFOW = extern struct {
    hdr: NMHDR,
    dwMask: NMTBDISPINFOW_MASK,
    idCommand: i32,
    lParam: usize,
    iImage: i32,
    pszText: PWSTR,
    cchText: i32,
};

pub const NMTOOLBARA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: PSTR,
    rcButton: RECT,
};

pub const NMTOOLBARW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: PWSTR,
    rcButton: RECT,
};

pub const REBARINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    himl: HIMAGELIST,
};

pub const REBARBANDINFOA = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: PSTR,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const REBARBANDINFOW = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: PWSTR,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const NMREBARCHILDSIZE = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    rcChild: RECT,
    rcBand: RECT,
};

pub const NMREBAR = extern struct {
    hdr: NMHDR,
    dwMask: NMREBAR_MASK_FLAGS,
    uBand: u32,
    fStyle: u32,
    wID: u32,
    lParam: LPARAM,
};

pub const NMRBAUTOSIZE = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    rcTarget: RECT,
    rcActual: RECT,
};

pub const NMREBARCHEVRON = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    rc: RECT,
    lParamNM: LPARAM,
};

pub const NMREBARSPLITTER = extern struct {
    hdr: NMHDR,
    rcSizing: RECT,
};

pub const NMREBARAUTOBREAK = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    uMsg: u32,
    fStyleCurrent: u32,
    fAutoBreak: BOOL,
};

pub const RBHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iBand: i32,
};

pub const TTTOOLINFOA = extern struct {
    cbSize: u32,
    uFlags: TTTOOLINFO_FLAGS,
    hwnd: HWND,
    uId: usize,
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: PSTR,
    lParam: LPARAM,
    lpReserved: *c_void,
};

pub const TTTOOLINFOW = extern struct {
    cbSize: u32,
    uFlags: TTTOOLINFO_FLAGS,
    hwnd: HWND,
    uId: usize,
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: PWSTR,
    lParam: LPARAM,
    lpReserved: *c_void,
};

pub const TTGETTITLE = extern struct {
    dwSize: u32,
    uTitleBitmap: u32,
    cch: u32,
    pszTitle: PWSTR,
};

pub const TTHITTESTINFOA = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOA,
};

pub const TTHITTESTINFOW = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOW,
};

pub const NMTTDISPINFOA = extern struct {
    hdr: NMHDR,
    lpszText: PSTR,
    szText: [80]CHAR,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTTDISPINFOW = extern struct {
    hdr: NMHDR,
    lpszText: PWSTR,
    szText: [80]u16,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTRBTHUMBPOSCHANGING = extern struct {
    hdr: NMHDR,
    dwPos: u32,
    nReason: i32,
};

pub const DRAGLISTINFO = extern struct {
    uNotification: DRAGLISTINFO_NOTIFICATION_FLAGS,
    hWnd: HWND,
    ptCursor: POINT,
};

pub const UDACCEL = extern struct {
    nSec: u32,
    nInc: u32,
};

pub const NMUPDOWN = extern struct {
    hdr: NMHDR,
    iPos: i32,
    iDelta: i32,
};

pub const PBRANGE = extern struct {
    iLow: i32,
    iHigh: i32,
};

pub const LITEM = extern struct {
    mask: u32,
    iLink: i32,
    state: u32,
    stateMask: u32,
    szID: [48]u16,
    szUrl: [2084]u16,
};

pub const LHITTESTINFO = extern struct {
    pt: POINT,
    item: LITEM,
};

pub const NMLINK = extern struct {
    hdr: NMHDR,
    item: LITEM,
};

pub const LVITEMA = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: LVITEMA_GROUP_ID,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
    iGroup: i32,
};

pub const LVITEMW = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: LVITEMA_GROUP_ID,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
    iGroup: i32,
};

pub const LVFINDINFOA = extern struct {
    flags: LVFINDINFOW_FLAGS,
    psz: [*:0]const u8,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVFINDINFOW = extern struct {
    flags: LVFINDINFOW_FLAGS,
    psz: [*:0]const u16,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVHITTESTINFO = extern struct {
    pt: POINT,
    flags: LVHITTESTINFO_FLAGS,
    iItem: i32,
    iSubItem: i32,
    iGroup: i32,
};

pub const LVCOLUMNA = extern struct {
    mask: LVCOLUMNW_MASK,
    fmt: LVCOLUMNW_FORMAT,
    cx: i32,
    pszText: PSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const LVCOLUMNW = extern struct {
    mask: LVCOLUMNW_MASK,
    fmt: LVCOLUMNW_FORMAT,
    cx: i32,
    pszText: PWSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const PFNLVCOMPARE = fn(
    param0: LPARAM,
    param1: LPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVBKIMAGEA = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: PSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVBKIMAGEW = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: PWSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVGROUP = extern struct {
    cbSize: u32,
    mask: LVGROUP_MASK,
    pszHeader: PWSTR,
    cchHeader: i32,
    pszFooter: PWSTR,
    cchFooter: i32,
    iGroupId: i32,
    stateMask: u32,
    state: u32,
    uAlign: u32,
    pszSubtitle: PWSTR,
    cchSubtitle: u32,
    pszTask: PWSTR,
    cchTask: u32,
    pszDescriptionTop: PWSTR,
    cchDescriptionTop: u32,
    pszDescriptionBottom: PWSTR,
    cchDescriptionBottom: u32,
    iTitleImage: i32,
    iExtendedImage: i32,
    iFirstItem: i32,
    cItems: u32,
    pszSubsetTitle: PWSTR,
    cchSubsetTitle: u32,
};

pub const LVGROUPMETRICS = extern struct {
    cbSize: u32,
    mask: u32,
    Left: u32,
    Top: u32,
    Right: u32,
    Bottom: u32,
    crLeft: u32,
    crTop: u32,
    crRight: u32,
    crBottom: u32,
    crHeader: u32,
    crFooter: u32,
};

pub const PFNLVGROUPCOMPARE = fn(
    param0: i32,
    param1: i32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVINSERTGROUPSORTED = extern struct {
    pfnGroupCompare: PFNLVGROUPCOMPARE,
    pvData: *c_void,
    lvGroup: LVGROUP,
};

pub const LVTILEVIEWINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwFlags: LVTILEVIEWINFO_FLAGS,
    sizeTile: SIZE,
    cLines: i32,
    rcLabelMargin: RECT,
};

pub const LVTILEINFO = extern struct {
    cbSize: u32,
    iItem: i32,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
};

pub const LVINSERTMARK = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iItem: i32,
    dwReserved: u32,
};

pub const LVSETINFOTIP = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pszText: PWSTR,
    iItem: i32,
    iSubItem: i32,
};

pub const LVFOOTERINFO = extern struct {
    mask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    cItems: u32,
};

pub const LVFOOTERITEM = extern struct {
    mask: LVFOOTERITEM_MASK,
    iItem: i32,
    pszText: PWSTR,
    cchTextMax: i32,
    state: u32,
    stateMask: u32,
};

pub const LVITEMINDEX = extern struct {
    iItem: i32,
    iGroup: i32,
};

pub const NMLISTVIEW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
};

pub const NMITEMACTIVATE = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
    uKeyFlags: u32,
};

pub const NMLVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iSubItem: i32,
    dwItemType: NMLVCUSTOMDRAW_ITEM_TYPE,
    clrFace: u32,
    iIconEffect: i32,
    iIconPhase: i32,
    iPartId: i32,
    iStateId: i32,
    rcText: RECT,
    uAlign: NMLVCUSTOMDRAW_ALIGN,
};

pub const NMLVCACHEHINT = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
};

pub const NMLVFINDITEMA = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOA,
};

pub const NMLVFINDITEMW = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOW,
};

pub const NMLVODSTATECHANGE = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
    uNewState: u32,
    uOldState: u32,
};

pub const NMLVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: LVITEMA,
};

pub const NMLVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: LVITEMW,
};

pub const NMLVKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMLVLINK = extern struct {
    hdr: NMHDR,
    link: LITEM,
    iItem: i32,
    iSubItem: i32,
};

pub const NMLVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVSCROLL = extern struct {
    hdr: NMHDR,
    dx: i32,
    dy: i32,
};

pub const NMLVEMPTYMARKUP = extern struct {
    hdr: NMHDR,
    dwFlags: NMLVEMPTYMARKUP_FLAGS,
    szMarkup: [2084]u16,
};

pub const NMTVSTATEIMAGECHANGING = extern struct {
    hdr: NMHDR,
    hti: *_TREEITEM,
    iOldStateImageIndex: i32,
    iNewStateImageIndex: i32,
};

pub const TVITEMA = extern struct {
    mask: TVITEM_MASK,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
};

pub const TVITEMW = extern struct {
    mask: TVITEM_MASK,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
};

pub const TVITEMEXA = extern struct {
    mask: TVITEM_MASK,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVITEMEXW = extern struct {
    mask: TVITEM_MASK,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: TVITEMEXW_CHILDREN,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVINSERTSTRUCTA = extern struct {
    hParent: *_TREEITEM,
    hInsertAfter: *_TREEITEM,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TVINSERTSTRUCTW = extern struct {
    hParent: *_TREEITEM,
    hInsertAfter: *_TREEITEM,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TVHITTESTINFO = extern struct {
    pt: POINT,
    flags: TVHITTESTINFO_FLAGS,
    hItem: *_TREEITEM,
};

pub const TVITEMPART = extern enum(i32) {
    N = 1,
};
pub const TVGIPR_BUTTON = TVITEMPART.N;

pub const TVGETITEMPARTRECTINFO = extern struct {
    hti: *_TREEITEM,
    prc: *RECT,
    partID: TVITEMPART,
};

pub const PFNTVCOMPARE = fn(
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParamSort: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const TVSORTCB = extern struct {
    hParent: *_TREEITEM,
    lpfnCompare: PFNTVCOMPARE,
    lParam: LPARAM,
};

pub const NMTREEVIEWA = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMA,
    itemNew: TVITEMA,
    ptDrag: POINT,
};

pub const NMTREEVIEWW = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMW,
    itemNew: TVITEMW,
    ptDrag: POINT,
};

pub const NMTVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: TVITEMA,
};

pub const NMTVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: TVITEMW,
};

pub const NMTVDISPINFOEXA = extern struct {
    hdr: NMHDR,
    item: TVITEMEXA,
};

pub const NMTVDISPINFOEXW = extern struct {
    hdr: NMHDR,
    item: TVITEMEXW,
};

pub const NMTVKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMTVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iLevel: i32,
};

pub const NMTVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: PSTR,
    cchTextMax: i32,
    hItem: *_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: PWSTR,
    cchTextMax: i32,
    hItem: *_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVITEMCHANGE = extern struct {
    hdr: NMHDR,
    uChanged: u32,
    hItem: *_TREEITEM,
    uStateNew: u32,
    uStateOld: u32,
    lParam: LPARAM,
};

pub const NMTVASYNCDRAW = extern struct {
    hdr: NMHDR,
    pimldp: *IMAGELISTDRAWPARAMS,
    hr: HRESULT,
    hItem: *_TREEITEM,
    lParam: LPARAM,
    dwRetFlags: u32,
    iRetImageIndex: i32,
};

pub const COMBOBOXEXITEMA = extern struct {
    mask: COMBOBOX_EX_ITEM_FLAGS,
    iItem: isize,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const COMBOBOXEXITEMW = extern struct {
    mask: COMBOBOX_EX_ITEM_FLAGS,
    iItem: isize,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const NMCOMBOBOXEXA = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMA,
};

pub const NMCOMBOBOXEXW = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMW,
};

pub const NMCBEDRAGBEGINW = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]u16,
};

pub const NMCBEDRAGBEGINA = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]CHAR,
};

pub const NMCBEENDEDITW = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]u16,
    iWhy: i32,
};

pub const NMCBEENDEDITA = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]CHAR,
    iWhy: i32,
};

pub const TCITEMHEADERA = extern struct {
    mask: TCITEMHEADERA_MASK,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMHEADERW = extern struct {
    mask: TCITEMHEADERA_MASK,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMA = extern struct {
    mask: TCITEMHEADERA_MASK,
    dwState: u32,
    dwStateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCITEMW = extern struct {
    mask: TCITEMHEADERA_MASK,
    dwState: u32,
    dwStateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCHITTESTINFO = extern struct {
    pt: POINT,
    flags: TCHITTESTINFO_FLAGS,
};

pub const NMTCKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const MCHITTESTINFO = extern struct {
    cbSize: u32,
    pt: POINT,
    uHit: u32,
    st: SYSTEMTIME,
    rc: RECT,
    iOffset: i32,
    iRow: i32,
    iCol: i32,
};

pub const MCGRIDINFO = extern struct {
    cbSize: u32,
    dwPart: MCGRIDINFO_PART,
    dwFlags: MCGRIDINFO_FLAGS,
    iCalendar: i32,
    iRow: i32,
    iCol: i32,
    bSelected: BOOL,
    stStart: SYSTEMTIME,
    stEnd: SYSTEMTIME,
    rc: RECT,
    pszName: PWSTR,
    cchName: usize,
};

pub const NMSELCHANGE = extern struct {
    nmhdr: NMHDR,
    stSelStart: SYSTEMTIME,
    stSelEnd: SYSTEMTIME,
};

pub const NMDAYSTATE = extern struct {
    nmhdr: NMHDR,
    stStart: SYSTEMTIME,
    cDayState: i32,
    prgDayState: *u32,
};

pub const NMVIEWCHANGE = extern struct {
    nmhdr: NMHDR,
    dwOldView: u32,
    dwNewView: u32,
};

pub const DATETIMEPICKERINFO = extern struct {
    cbSize: u32,
    rcCheck: RECT,
    stateCheck: u32,
    rcButton: RECT,
    stateButton: u32,
    hwndEdit: HWND,
    hwndUD: HWND,
    hwndDropDown: HWND,
};

pub const NMDATETIMECHANGE = extern struct {
    nmhdr: NMHDR,
    dwFlags: u32,
    st: SYSTEMTIME,
};

pub const NMDATETIMESTRINGA = extern struct {
    nmhdr: NMHDR,
    pszUserString: [*:0]const u8,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMESTRINGW = extern struct {
    nmhdr: NMHDR,
    pszUserString: [*:0]const u16,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMEWMKEYDOWNA = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: [*:0]const u8,
    st: SYSTEMTIME,
};

pub const NMDATETIMEWMKEYDOWNW = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: [*:0]const u16,
    st: SYSTEMTIME,
};

pub const NMDATETIMEFORMATA = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u8,
    st: SYSTEMTIME,
    pszDisplay: [*:0]const u8,
    szDisplay: [64]CHAR,
};

pub const NMDATETIMEFORMATW = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u16,
    st: SYSTEMTIME,
    pszDisplay: [*:0]const u16,
    szDisplay: [64]u16,
};

pub const NMDATETIMEFORMATQUERYA = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u8,
    szMax: SIZE,
};

pub const NMDATETIMEFORMATQUERYW = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u16,
    szMax: SIZE,
};

pub const NMIPADDRESS = extern struct {
    hdr: NMHDR,
    iField: i32,
    iValue: i32,
};

pub const NMPGSCROLL = extern struct {
    hdr: NMHDR,
    fwKeys: NMPGSCROLL_KEYS,
    rcParent: RECT,
    iDir: NMPGSCROLL_DIR,
    iXpos: i32,
    iYpos: i32,
    iScroll: i32,
};

pub const NMPGCALCSIZE = extern struct {
    hdr: NMHDR,
    dwFlag: NMPGCALCSIZE_FLAGS,
    iWidth: i32,
    iHeight: i32,
};

pub const NMPGHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};

pub const BUTTON_IMAGELIST = extern struct {
    himl: HIMAGELIST,
    margin: RECT,
    uAlign: BUTTON_IMAGELIST_ALIGN,
};

pub const NMBCHOTITEM = extern struct {
    hdr: NMHDR,
    dwFlags: NMTBHOTITEM_FLAGS,
};

pub const BUTTON_SPLITINFO = extern struct {
    mask: u32,
    himlGlyph: HIMAGELIST,
    uSplitStyle: u32,
    size: SIZE,
};

pub const NMBCDROPDOWN = extern struct {
    hdr: NMHDR,
    rcButton: RECT,
};

pub const EDITBALLOONTIP = extern struct {
    cbStruct: u32,
    pszTitle: [*:0]const u16,
    pszText: [*:0]const u16,
    ttiIcon: EDITBALLOONTIP_ICON,
};

pub const EC_ENDOFLINE = extern enum(i32) {
    DETECTFROMCONTENT = 0,
    CRLF = 1,
    CR = 2,
    LF = 3,
};
pub const EC_ENDOFLINE_DETECTFROMCONTENT = EC_ENDOFLINE.DETECTFROMCONTENT;
pub const EC_ENDOFLINE_CRLF = EC_ENDOFLINE.CRLF;
pub const EC_ENDOFLINE_CR = EC_ENDOFLINE.CR;
pub const EC_ENDOFLINE_LF = EC_ENDOFLINE.LF;

pub const EC_SEARCHWEB_ENTRYPOINT = extern enum(i32) {
    EXTERNAL = 0,
    CONTEXTMENU = 1,
};
pub const EC_SEARCHWEB_ENTRYPOINT_EXTERNAL = EC_SEARCHWEB_ENTRYPOINT.EXTERNAL;
pub const EC_SEARCHWEB_ENTRYPOINT_CONTEXTMENU = EC_SEARCHWEB_ENTRYPOINT.CONTEXTMENU;

pub const NMSEARCHWEB = extern struct {
    hdr: NMHDR,
    entrypoint: EC_SEARCHWEB_ENTRYPOINT,
    hasQueryText: BOOL,
    invokeSucceeded: BOOL,
};

pub const PFTASKDIALOGCALLBACK = fn(
    hwnd: HWND,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    lpRefData: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const _TASKDIALOG_FLAGS = extern enum(i32) {
    ENABLE_HYPERLINKS = 1,
    USE_HICON_MAIN = 2,
    USE_HICON_FOOTER = 4,
    ALLOW_DIALOG_CANCELLATION = 8,
    USE_COMMAND_LINKS = 16,
    USE_COMMAND_LINKS_NO_ICON = 32,
    EXPAND_FOOTER_AREA = 64,
    EXPANDED_BY_DEFAULT = 128,
    VERIFICATION_FLAG_CHECKED = 256,
    SHOW_PROGRESS_BAR = 512,
    SHOW_MARQUEE_PROGRESS_BAR = 1024,
    CALLBACK_TIMER = 2048,
    POSITION_RELATIVE_TO_WINDOW = 4096,
    RTL_LAYOUT = 8192,
    NO_DEFAULT_RADIO_BUTTON = 16384,
    CAN_BE_MINIMIZED = 32768,
    NO_SET_FOREGROUND = 65536,
    SIZE_TO_CONTENT = 16777216,
};
pub const TDF_ENABLE_HYPERLINKS = _TASKDIALOG_FLAGS.ENABLE_HYPERLINKS;
pub const TDF_USE_HICON_MAIN = _TASKDIALOG_FLAGS.USE_HICON_MAIN;
pub const TDF_USE_HICON_FOOTER = _TASKDIALOG_FLAGS.USE_HICON_FOOTER;
pub const TDF_ALLOW_DIALOG_CANCELLATION = _TASKDIALOG_FLAGS.ALLOW_DIALOG_CANCELLATION;
pub const TDF_USE_COMMAND_LINKS = _TASKDIALOG_FLAGS.USE_COMMAND_LINKS;
pub const TDF_USE_COMMAND_LINKS_NO_ICON = _TASKDIALOG_FLAGS.USE_COMMAND_LINKS_NO_ICON;
pub const TDF_EXPAND_FOOTER_AREA = _TASKDIALOG_FLAGS.EXPAND_FOOTER_AREA;
pub const TDF_EXPANDED_BY_DEFAULT = _TASKDIALOG_FLAGS.EXPANDED_BY_DEFAULT;
pub const TDF_VERIFICATION_FLAG_CHECKED = _TASKDIALOG_FLAGS.VERIFICATION_FLAG_CHECKED;
pub const TDF_SHOW_PROGRESS_BAR = _TASKDIALOG_FLAGS.SHOW_PROGRESS_BAR;
pub const TDF_SHOW_MARQUEE_PROGRESS_BAR = _TASKDIALOG_FLAGS.SHOW_MARQUEE_PROGRESS_BAR;
pub const TDF_CALLBACK_TIMER = _TASKDIALOG_FLAGS.CALLBACK_TIMER;
pub const TDF_POSITION_RELATIVE_TO_WINDOW = _TASKDIALOG_FLAGS.POSITION_RELATIVE_TO_WINDOW;
pub const TDF_RTL_LAYOUT = _TASKDIALOG_FLAGS.RTL_LAYOUT;
pub const TDF_NO_DEFAULT_RADIO_BUTTON = _TASKDIALOG_FLAGS.NO_DEFAULT_RADIO_BUTTON;
pub const TDF_CAN_BE_MINIMIZED = _TASKDIALOG_FLAGS.CAN_BE_MINIMIZED;
pub const TDF_NO_SET_FOREGROUND = _TASKDIALOG_FLAGS.NO_SET_FOREGROUND;
pub const TDF_SIZE_TO_CONTENT = _TASKDIALOG_FLAGS.SIZE_TO_CONTENT;

pub const TASKDIALOG_MESSAGES = extern enum(i32) {
    NAVIGATE_PAGE = 1125,
    CLICK_BUTTON = 1126,
    SET_MARQUEE_PROGRESS_BAR = 1127,
    SET_PROGRESS_BAR_STATE = 1128,
    SET_PROGRESS_BAR_RANGE = 1129,
    SET_PROGRESS_BAR_POS = 1130,
    SET_PROGRESS_BAR_MARQUEE = 1131,
    SET_ELEMENT_TEXT = 1132,
    CLICK_RADIO_BUTTON = 1134,
    ENABLE_BUTTON = 1135,
    ENABLE_RADIO_BUTTON = 1136,
    CLICK_VERIFICATION = 1137,
    UPDATE_ELEMENT_TEXT = 1138,
    SET_BUTTON_ELEVATION_REQUIRED_STATE = 1139,
    UPDATE_ICON = 1140,
};
pub const TDM_NAVIGATE_PAGE = TASKDIALOG_MESSAGES.NAVIGATE_PAGE;
pub const TDM_CLICK_BUTTON = TASKDIALOG_MESSAGES.CLICK_BUTTON;
pub const TDM_SET_MARQUEE_PROGRESS_BAR = TASKDIALOG_MESSAGES.SET_MARQUEE_PROGRESS_BAR;
pub const TDM_SET_PROGRESS_BAR_STATE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_STATE;
pub const TDM_SET_PROGRESS_BAR_RANGE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_RANGE;
pub const TDM_SET_PROGRESS_BAR_POS = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_POS;
pub const TDM_SET_PROGRESS_BAR_MARQUEE = TASKDIALOG_MESSAGES.SET_PROGRESS_BAR_MARQUEE;
pub const TDM_SET_ELEMENT_TEXT = TASKDIALOG_MESSAGES.SET_ELEMENT_TEXT;
pub const TDM_CLICK_RADIO_BUTTON = TASKDIALOG_MESSAGES.CLICK_RADIO_BUTTON;
pub const TDM_ENABLE_BUTTON = TASKDIALOG_MESSAGES.ENABLE_BUTTON;
pub const TDM_ENABLE_RADIO_BUTTON = TASKDIALOG_MESSAGES.ENABLE_RADIO_BUTTON;
pub const TDM_CLICK_VERIFICATION = TASKDIALOG_MESSAGES.CLICK_VERIFICATION;
pub const TDM_UPDATE_ELEMENT_TEXT = TASKDIALOG_MESSAGES.UPDATE_ELEMENT_TEXT;
pub const TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = TASKDIALOG_MESSAGES.SET_BUTTON_ELEVATION_REQUIRED_STATE;
pub const TDM_UPDATE_ICON = TASKDIALOG_MESSAGES.UPDATE_ICON;

pub const TASKDIALOG_NOTIFICATIONS = extern enum(i32) {
    CREATED = 0,
    NAVIGATED = 1,
    BUTTON_CLICKED = 2,
    HYPERLINK_CLICKED = 3,
    TIMER = 4,
    DESTROYED = 5,
    RADIO_BUTTON_CLICKED = 6,
    DIALOG_CONSTRUCTED = 7,
    VERIFICATION_CLICKED = 8,
    HELP = 9,
    EXPANDO_BUTTON_CLICKED = 10,
};
pub const TDN_CREATED = TASKDIALOG_NOTIFICATIONS.CREATED;
pub const TDN_NAVIGATED = TASKDIALOG_NOTIFICATIONS.NAVIGATED;
pub const TDN_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.BUTTON_CLICKED;
pub const TDN_HYPERLINK_CLICKED = TASKDIALOG_NOTIFICATIONS.HYPERLINK_CLICKED;
pub const TDN_TIMER = TASKDIALOG_NOTIFICATIONS.TIMER;
pub const TDN_DESTROYED = TASKDIALOG_NOTIFICATIONS.DESTROYED;
pub const TDN_RADIO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.RADIO_BUTTON_CLICKED;
pub const TDN_DIALOG_CONSTRUCTED = TASKDIALOG_NOTIFICATIONS.DIALOG_CONSTRUCTED;
pub const TDN_VERIFICATION_CLICKED = TASKDIALOG_NOTIFICATIONS.VERIFICATION_CLICKED;
pub const TDN_HELP = TASKDIALOG_NOTIFICATIONS.HELP;
pub const TDN_EXPANDO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.EXPANDO_BUTTON_CLICKED;

pub const TASKDIALOG_BUTTON = extern struct {
    nButtonID: i32,
    pszButtonText: [*:0]const u16,
};

pub const TASKDIALOG_ELEMENTS = extern enum(i32) {
    CONTENT = 0,
    EXPANDED_INFORMATION = 1,
    FOOTER = 2,
    MAIN_INSTRUCTION = 3,
};
pub const TDE_CONTENT = TASKDIALOG_ELEMENTS.CONTENT;
pub const TDE_EXPANDED_INFORMATION = TASKDIALOG_ELEMENTS.EXPANDED_INFORMATION;
pub const TDE_FOOTER = TASKDIALOG_ELEMENTS.FOOTER;
pub const TDE_MAIN_INSTRUCTION = TASKDIALOG_ELEMENTS.MAIN_INSTRUCTION;

pub const TASKDIALOG_ICON_ELEMENTS = extern enum(i32) {
    MAIN = 0,
    FOOTER = 1,
};
pub const TDIE_ICON_MAIN = TASKDIALOG_ICON_ELEMENTS.MAIN;
pub const TDIE_ICON_FOOTER = TASKDIALOG_ICON_ELEMENTS.FOOTER;

pub const _TASKDIALOG_COMMON_BUTTON_FLAGS = extern enum(i32) {
    OK_BUTTON = 1,
    YES_BUTTON = 2,
    NO_BUTTON = 4,
    CANCEL_BUTTON = 8,
    RETRY_BUTTON = 16,
    CLOSE_BUTTON = 32,
};
pub const TDCBF_OK_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.OK_BUTTON;
pub const TDCBF_YES_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.YES_BUTTON;
pub const TDCBF_NO_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.NO_BUTTON;
pub const TDCBF_CANCEL_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.CANCEL_BUTTON;
pub const TDCBF_RETRY_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.RETRY_BUTTON;
pub const TDCBF_CLOSE_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.CLOSE_BUTTON;

pub const TASKDIALOGCONFIG = extern struct {
    cbSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwFlags: i32,
    dwCommonButtons: i32,
    pszWindowTitle: [*:0]const u16,
    Anonymous1: _Anonymous1_e__Union,
    pszMainInstruction: [*:0]const u16,
    pszContent: [*:0]const u16,
    cButtons: u32,
    pButtons: *const TASKDIALOG_BUTTON,
    nDefaultButton: i32,
    cRadioButtons: u32,
    pRadioButtons: *const TASKDIALOG_BUTTON,
    nDefaultRadioButton: i32,
    pszVerificationText: [*:0]const u16,
    pszExpandedInformation: [*:0]const u16,
    pszExpandedControlText: [*:0]const u16,
    pszCollapsedControlText: [*:0]const u16,
    Anonymous2: _Anonymous2_e__Union,
    pszFooter: [*:0]const u16,
    pfCallback: PFTASKDIALOGCALLBACK,
    lpCallbackData: isize,
    cxWidth: u32,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNDAENUMCALLBACK = fn(
    p: ?*c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDAENUMCALLBACKCONST = fn(
    p: ?*const c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARE = fn(
    p1: ?*c_void,
    p2: ?*c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARECONST = fn(
    p1: ?*const c_void,
    p2: ?*const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DPASTREAMINFO = extern struct {
    iPos: i32,
    pvItem: *c_void,
};

pub const PFNDPASTREAM = fn(
    pinfo: *DPASTREAMINFO,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDPAMERGE = fn(
    uMsg: DPAMM_MESSAGE,
    pvDest: *c_void,
    pvSrc: *c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNDPAMERGECONST = fn(
    uMsg: DPAMM_MESSAGE,
    pvDest: *const c_void,
    pvSrc: *const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const _LI_METRIC = extern enum(i32) {
    SMALL = 0,
    LARGE = 1,
};
pub const LIM_SMALL = _LI_METRIC.SMALL;
pub const LIM_LARGE = _LI_METRIC.LARGE;

const CLSID_ImageList_Value = @import("../zig.zig").Guid.initString("7c476ba2-02b1-48f4-8048-b24619ddc058");
pub const CLSID_ImageList = &CLSID_ImageList_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList_Value = @import("../zig.zig").Guid.initString("46eb5926-582e-4017-9fdf-e8998daa0950");
pub const IID_IImageList = &IID_IImageList_Value;
pub const IImageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const IImageList,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceIcon: fn(
            self: *const IImageList,
            i: i32,
            hicon: HICON,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayImage: fn(
            self: *const IImageList,
            iImage: i32,
            iOverlay: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace: fn(
            self: *const IImageList,
            i: i32,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMasked: fn(
            self: *const IImageList,
            hbmImage: HBITMAP,
            crMask: u32,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Draw: fn(
            self: *const IImageList,
            pimldp: *IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IImageList,
            i: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const IImageList,
            i: i32,
            flags: u32,
            picon: *HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageInfo: fn(
            self: *const IImageList,
            i: i32,
            pImageInfo: *IMAGEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IImageList,
            iDst: i32,
            punkSrc: *IUnknown,
            iSrc: i32,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: fn(
            self: *const IImageList,
            i1: i32,
            punk2: *IUnknown,
            i2: i32,
            dx: i32,
            dy: i32,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IImageList,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageRect: fn(
            self: *const IImageList,
            i: i32,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconSize: fn(
            self: *const IImageList,
            cx: *i32,
            cy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconSize: fn(
            self: *const IImageList,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageCount: fn(
            self: *const IImageList,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImageCount: fn(
            self: *const IImageList,
            uNewCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBkColor: fn(
            self: *const IImageList,
            clrBk: u32,
            pclr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBkColor: fn(
            self: *const IImageList,
            pclr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDrag: fn(
            self: *const IImageList,
            iTrack: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDrag: fn(
            self: *const IImageList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragEnter: fn(
            self: *const IImageList,
            hwndLock: HWND,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeave: fn(
            self: *const IImageList,
            hwndLock: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragMove: fn(
            self: *const IImageList,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDragCursorImage: fn(
            self: *const IImageList,
            punk: *IUnknown,
            iDrag: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragShowNolock: fn(
            self: *const IImageList,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragImage: fn(
            self: *const IImageList,
            ppt: ?*POINT,
            pptHotspot: ?*POINT,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFlags: fn(
            self: *const IImageList,
            i: i32,
            dwFlags: *IMAGE_LIST_ITEM_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayImage: fn(
            self: *const IImageList,
            iOverlay: i32,
            piIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Add(self: *const T, hbmImage: HBITMAP, hbmMask: HBITMAP, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Add(@ptrCast(*const IImageList, self), hbmImage, hbmMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ReplaceIcon(self: *const T, i: i32, hicon: HICON, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ReplaceIcon(@ptrCast(*const IImageList, self), i, hicon, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetOverlayImage(self: *const T, iImage: i32, iOverlay: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetOverlayImage(@ptrCast(*const IImageList, self), iImage, iOverlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Replace(self: *const T, i: i32, hbmImage: HBITMAP, hbmMask: HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Replace(@ptrCast(*const IImageList, self), i, hbmImage, hbmMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_AddMasked(self: *const T, hbmImage: HBITMAP, crMask: u32, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).AddMasked(@ptrCast(*const IImageList, self), hbmImage, crMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Draw(self: *const T, pimldp: *IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Draw(@ptrCast(*const IImageList, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Remove(self: *const T, i: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Remove(@ptrCast(*const IImageList, self), i);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIcon(self: *const T, i: i32, flags: u32, picon: *HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIcon(@ptrCast(*const IImageList, self), i, flags, picon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageInfo(self: *const T, i: i32, pImageInfo: *IMAGEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageInfo(@ptrCast(*const IImageList, self), i, pImageInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Copy(self: *const T, iDst: i32, punkSrc: *IUnknown, iSrc: i32, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Copy(@ptrCast(*const IImageList, self), iDst, punkSrc, iSrc, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Merge(self: *const T, i1: i32, punk2: *IUnknown, i2: i32, dx: i32, dy: i32, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Merge(@ptrCast(*const IImageList, self), i1, punk2, i2, dx, dy, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Clone(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Clone(@ptrCast(*const IImageList, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageRect(self: *const T, i: i32, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageRect(@ptrCast(*const IImageList, self), i, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIconSize(self: *const T, cx: *i32, cy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetIconSize(self: *const T, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageCount(self: *const T, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageCount(@ptrCast(*const IImageList, self), pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetImageCount(self: *const T, uNewCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetImageCount(@ptrCast(*const IImageList, self), uNewCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetBkColor(self: *const T, clrBk: u32, pclr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetBkColor(@ptrCast(*const IImageList, self), clrBk, pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetBkColor(self: *const T, pclr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetBkColor(@ptrCast(*const IImageList, self), pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_BeginDrag(self: *const T, iTrack: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).BeginDrag(@ptrCast(*const IImageList, self), iTrack, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_EndDrag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).EndDrag(@ptrCast(*const IImageList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragEnter(self: *const T, hwndLock: HWND, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragEnter(@ptrCast(*const IImageList, self), hwndLock, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragLeave(self: *const T, hwndLock: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragLeave(@ptrCast(*const IImageList, self), hwndLock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragMove(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragMove(@ptrCast(*const IImageList, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetDragCursorImage(self: *const T, punk: *IUnknown, iDrag: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetDragCursorImage(@ptrCast(*const IImageList, self), punk, iDrag, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragShowNolock(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragShowNolock(@ptrCast(*const IImageList, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetDragImage(self: *const T, ppt: ?*POINT, pptHotspot: ?*POINT, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetDragImage(@ptrCast(*const IImageList, self), ppt, pptHotspot, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetItemFlags(self: *const T, i: i32, dwFlags: *IMAGE_LIST_ITEM_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetItemFlags(@ptrCast(*const IImageList, self), i, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetOverlayImage(self: *const T, iOverlay: i32, piIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetOverlayImage(@ptrCast(*const IImageList, self), iOverlay, piIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAGELISTSTATS = extern struct {
    cbSize: u32,
    cAlloc: i32,
    cUsed: i32,
    cStandby: i32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList2_Value = @import("../zig.zig").Guid.initString("192b9d83-50fc-457b-90a0-2b82a8b5dae1");
pub const IID_IImageList2 = &IID_IImageList2_Value;
pub const IImageList2 = extern struct {
    pub const VTable = extern struct {
        base: IImageList.VTable,
        Resize: fn(
            self: *const IImageList2,
            cxNewIconSize: i32,
            cyNewIconSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
            pcx: *i32,
            pcy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallback: fn(
            self: *const IImageList2,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallback: fn(
            self: *const IImageList2,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceImagePresent: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardImages: fn(
            self: *const IImageList2,
            iFirstImage: i32,
            iLastImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreloadImages: fn(
            self: *const IImageList2,
            pimldp: *IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IImageList2,
            pils: *IMAGELISTSTATS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IImageList2,
            cx: i32,
            cy: i32,
            flags: u32,
            cInitial: i32,
            cGrow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace2: fn(
            self: *const IImageList2,
            i: i32,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceFromImageList: fn(
            self: *const IImageList2,
            i: i32,
            pil: *IImageList,
            iSrc: i32,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IImageList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Resize(self: *const T, cxNewIconSize: i32, cyNewIconSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Resize(@ptrCast(*const IImageList2, self), cxNewIconSize, cyNewIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetOriginalSize(self: *const T, iImage: i32, dwFlags: u32, pcx: *i32, pcy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetOriginalSize(@ptrCast(*const IImageList2, self), iImage, dwFlags, pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetOriginalSize(self: *const T, iImage: i32, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetOriginalSize(@ptrCast(*const IImageList2, self), iImage, cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetCallback(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetCallback(@ptrCast(*const IImageList2, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetCallback(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetCallback(@ptrCast(*const IImageList2, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ForceImagePresent(self: *const T, iImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ForceImagePresent(@ptrCast(*const IImageList2, self), iImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_DiscardImages(self: *const T, iFirstImage: i32, iLastImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).DiscardImages(@ptrCast(*const IImageList2, self), iFirstImage, iLastImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_PreloadImages(self: *const T, pimldp: *IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).PreloadImages(@ptrCast(*const IImageList2, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetStatistics(self: *const T, pils: *IMAGELISTSTATS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetStatistics(@ptrCast(*const IImageList2, self), pils);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Initialize(self: *const T, cx: i32, cy: i32, flags: u32, cInitial: i32, cGrow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Initialize(@ptrCast(*const IImageList2, self), cx, cy, flags, cInitial, cGrow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Replace2(self: *const T, i: i32, hbmImage: HBITMAP, hbmMask: HBITMAP, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Replace2(@ptrCast(*const IImageList2, self), i, hbmImage, hbmMask, punk, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ReplaceFromImageList(self: *const T, i: i32, pil: *IImageList, iSrc: i32, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ReplaceFromImageList(@ptrCast(*const IImageList2, self), i, pil, iSrc, punk, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TEXTMODE = extern enum(i32) {
    PLAINTEXT = 1,
    RICHTEXT = 2,
    SINGLELEVELUNDO = 4,
    MULTILEVELUNDO = 8,
    SINGLECODEPAGE = 16,
    MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: IMECOMPTEXT_FLAGS,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = fn(
    langid: u16,
    pszBefore: [*:0]const u16,
    pszAfter: PWSTR,
    cchAfter: i32,
    pcchReplaced: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EDITWORDBREAKPROCEX = fn(
    pchText: PSTR,
    cchText: i32,
    bCharSet: u8,
    action: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]CHAR,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: _Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: _Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const EDITSTREAMCALLBACK = fn(
    dwCookie: usize,
    pbBuff: *u8,
    cb: i32,
    pcb: *i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: PARAFORMAT_MASK,
    wNumbering: u16,
    Anonymous: _Anonymous_e__Union,
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: PARAFORMAT_ALIGNMENT,
    cTabCount: i16,
    rgxTabs: [32]u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: PARAFORMAT_SHADING_STYLE,
    wNumberingStart: u16,
    wNumberingStyle: PARAFORMAT_NUMBERING_STYLE,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: PARAFORMAT_BORDERS,
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const UNDONAMEID = extern enum(i32) {
    UNKNOWN = 0,
    TYPING = 1,
    DELETE = 2,
    DRAGDROP = 3,
    CUT = 4,
    PASTE = 5,
    AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UNKNOWN;
pub const UID_TYPING = UNDONAMEID.TYPING;
pub const UID_DELETE = UNDONAMEID.DELETE;
pub const UID_DRAGDROP = UNDONAMEID.DRAGDROP;
pub const UID_CUT = UNDONAMEID.CUT;
pub const UID_PASTE = UNDONAMEID.PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: GETTEXTLENGTHEX_FLAGS,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = extern enum(i32) {
    Nil = 0,
    Normal = 1,
    AddBefore = 2,
    ChangeBefore = 3,
    DeleteBefore = 4,
    ChangeAfter = 5,
    DelAndChange = 6,
};
pub const khyphNil = KHYPH.Nil;
pub const khyphNormal = KHYPH.Normal;
pub const khyphAddBefore = KHYPH.AddBefore;
pub const khyphChangeBefore = KHYPH.ChangeBefore;
pub const khyphDeleteBefore = KHYPH.DeleteBefore;
pub const khyphChangeAfter = KHYPH.ChangeAfter;
pub const khyphDelAndChange = KHYPH.DelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const tomConstants = extern enum(i32) {
    False = 0,
    True = -1,
    Undefined = -9999999,
    Toggle = -9999998,
    AutoColor = -9999997,
    Default = -9999996,
    Suspend = -9999995,
    Resume = -9999994,
    ApplyNow = 0,
    ApplyLater = 1,
    TrackParms = 2,
    CacheParms = 3,
    ApplyTmp = 4,
    DisableSmartFont = 8,
    EnableSmartFont = 9,
    UsePoints = 10,
    UseTwips = 11,
    Backward = -1073741823,
    Forward = 1073741823,
    Move = 0,
    Extend = 1,
    NoSelection = 0,
    SelectionIP = 1,
    SelectionNormal = 2,
    SelectionFrame = 3,
    SelectionColumn = 4,
    SelectionRow = 5,
    SelectionBlock = 6,
    SelectionInlineShape = 7,
    SelectionShape = 8,
    SelStartActive = 1,
    SelAtEOL = 2,
    SelOvertype = 4,
    SelActive = 8,
    SelReplace = 16,
    End = 0,
    Start = 32,
    CollapseEnd = 0,
    CollapseStart = 1,
    ClientCoord = 256,
    AllowOffClient = 512,
    Transform = 1024,
    ObjectArg = 2048,
    AtEnd = 4096,
    None = 0,
    Single = 1,
    Words = 2,
    Double = 3,
    Dotted = 4,
    Dash = 5,
    DashDot = 6,
    DashDotDot = 7,
    Wave = 8,
    Thick = 9,
    Hair = 10,
    DoubleWave = 11,
    HeavyWave = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    ThickDashDotDot = 16,
    ThickDotted = 17,
    ThickLongDash = 18,
    LineSpaceSingle = 0,
    LineSpace1pt5 = 1,
    LineSpaceDouble = 2,
    LineSpaceAtLeast = 3,
    LineSpaceExactly = 4,
    LineSpaceMultiple = 5,
    LineSpacePercent = 6,
    AlignLeft = 0,
    AlignCenter = 1,
    AlignRight = 2,
    AlignJustify = 3,
    AlignDecimal = 3,
    AlignBar = 4,
    DefaultTab = 5,
    AlignInterWord = 3,
    AlignNewspaper = 4,
    AlignInterLetter = 5,
    AlignScaled = 6,
    Spaces = 0,
    Dots = 1,
    Dashes = 2,
    Lines = 3,
    ThickLines = 4,
    Equals = 5,
    TabBack = -3,
    TabNext = -2,
    TabHere = -1,
    ListNone = 0,
    ListBullet = 1,
    ListNumberAsArabic = 2,
    ListNumberAsLCLetter = 3,
    ListNumberAsUCLetter = 4,
    ListNumberAsLCRoman = 5,
    ListNumberAsUCRoman = 6,
    ListNumberAsSequence = 7,
    ListNumberedCircle = 8,
    ListNumberedBlackCircleWingding = 9,
    ListNumberedWhiteCircleWingding = 10,
    ListNumberedArabicWide = 11,
    ListNumberedChS = 12,
    ListNumberedChT = 13,
    ListNumberedJpnChS = 14,
    ListNumberedJpnKor = 15,
    ListNumberedArabic1 = 16,
    ListNumberedArabic2 = 17,
    ListNumberedHebrew = 18,
    ListNumberedThaiAlpha = 19,
    ListNumberedThaiNum = 20,
    ListNumberedHindiAlpha = 21,
    ListNumberedHindiAlpha1 = 22,
    ListNumberedHindiNum = 23,
    ListParentheses = 65536,
    ListPeriod = 131072,
    ListPlain = 196608,
    ListNoNumber = 262144,
    ListMinus = 524288,
    IgnoreNumberStyle = 16777216,
    ParaStyleNormal = -1,
    ParaStyleHeading1 = -2,
    ParaStyleHeading2 = -3,
    ParaStyleHeading3 = -4,
    ParaStyleHeading4 = -5,
    ParaStyleHeading5 = -6,
    ParaStyleHeading6 = -7,
    ParaStyleHeading7 = -8,
    ParaStyleHeading8 = -9,
    ParaStyleHeading9 = -10,
    Character = 1,
    Word = 2,
    Sentence = 3,
    Paragraph = 4,
    Line = 5,
    Story = 6,
    Screen = 7,
    Section = 8,
    TableColumn = 9,
    Column = 9,
    Row = 10,
    Window = 11,
    Cell = 12,
    CharFormat = 13,
    ParaFormat = 14,
    Table = 15,
    Object = 16,
    Page = 17,
    HardParagraph = 18,
    Cluster = 19,
    InlineObject = 20,
    InlineObjectArg = 21,
    LeafLine = 22,
    LayoutColumn = 23,
    ProcessId = 1073741825,
    MatchWord = 2,
    MatchCase = 4,
    MatchPattern = 8,
    UnknownStory = 0,
    MainTextStory = 1,
    FootnotesStory = 2,
    EndnotesStory = 3,
    CommentsStory = 4,
    TextFrameStory = 5,
    EvenPagesHeaderStory = 6,
    PrimaryHeaderStory = 7,
    EvenPagesFooterStory = 8,
    PrimaryFooterStory = 9,
    FirstPageHeaderStory = 10,
    FirstPageFooterStory = 11,
    ScratchStory = 127,
    FindStory = 128,
    ReplaceStory = 129,
    StoryInactive = 0,
    StoryActiveDisplay = 1,
    StoryActiveUI = 2,
    StoryActiveDisplayUI = 3,
    NoAnimation = 0,
    LasVegasLights = 1,
    BlinkingBackground = 2,
    SparkleText = 3,
    MarchingBlackAnts = 4,
    MarchingRedAnts = 5,
    Shimmer = 6,
    WipeDown = 7,
    WipeRight = 8,
    AnimationMax = 8,
    LowerCase = 0,
    UpperCase = 1,
    TitleCase = 2,
    SentenceCase = 4,
    ToggleCase = 5,
    ReadOnly = 256,
    ShareDenyRead = 512,
    ShareDenyWrite = 1024,
    PasteFile = 4096,
    CreateNew = 16,
    CreateAlways = 32,
    OpenExisting = 48,
    OpenAlways = 64,
    TruncateExisting = 80,
    RTF = 1,
    Text = 2,
    HTML = 3,
    WordDocument = 4,
    Bold = -2147483647,
    Italic = -2147483646,
    Underline = -2147483644,
    Strikeout = -2147483640,
    Protected = -2147483632,
    Link = -2147483616,
    SmallCaps = -2147483584,
    AllCaps = -2147483520,
    Hidden = -2147483392,
    Outline = -2147483136,
    Shadow = -2147482624,
    Emboss = -2147481600,
    Imprint = -2147479552,
    Disabled = -2147475456,
    Revised = -2147467264,
    SubscriptCF = -2147418112,
    SuperscriptCF = -2147352576,
    FontBound = -2146435072,
    LinkProtected = -2139095040,
    InlineObjectStart = -2130706432,
    ExtendedChar = -2113929216,
    AutoBackColor = -2080374784,
    MathZoneNoBuildUp = -2013265920,
    MathZone = -1879048192,
    MathZoneOrdinary = -1610612736,
    AutoTextColor = -1073741824,
    MathZoneDisplay = 262144,
    ParaEffectRTL = 1,
    ParaEffectKeep = 2,
    ParaEffectKeepNext = 4,
    ParaEffectPageBreakBefore = 8,
    ParaEffectNoLineNumber = 16,
    ParaEffectNoWidowControl = 32,
    ParaEffectDoNotHyphen = 64,
    ParaEffectSideBySide = 128,
    ParaEffectCollapsed = 256,
    ParaEffectOutlineLevel = 512,
    ParaEffectBox = 1024,
    ParaEffectTableRowDelimiter = 4096,
    ParaEffectTable = 16384,
    ModWidthPairs = 1,
    ModWidthSpace = 2,
    AutoSpaceAlpha = 4,
    AutoSpaceNumeric = 8,
    AutoSpaceParens = 16,
    EmbeddedFont = 32,
    Doublestrike = 64,
    Overlapping = 128,
    NormalCaret = 0,
    KoreanBlockCaret = 1,
    NullCaret = 2,
    IncludeInset = 1,
    UnicodeBiDi = 1,
    MathCFCheck = 4,
    Unlink = 8,
    Unhide = 16,
    CheckTextLimit = 32,
    IgnoreCurrentFont = 0,
    MatchCharRep = 1,
    MatchFontSignature = 2,
    MatchAscii = 4,
    GetHeightOnly = 8,
    MatchMathFont = 16,
    Charset = -2147483648,
    CharRepFromLcid = 1073741824,
    Ansi = 0,
    EastEurope = 1,
    Cyrillic = 2,
    Greek = 3,
    Turkish = 4,
    Hebrew = 5,
    Arabic = 6,
    Baltic = 7,
    Vietnamese = 8,
    DefaultCharRep = 9,
    Symbol = 10,
    Thai = 11,
    ShiftJIS = 12,
    GB2312 = 13,
    Hangul = 14,
    BIG5 = 15,
    PC437 = 16,
    OEM = 17,
    Mac = 18,
    Armenian = 19,
    Syriac = 20,
    Thaana = 21,
    Devanagari = 22,
    Bengali = 23,
    Gurmukhi = 24,
    Gujarati = 25,
    Oriya = 26,
    Tamil = 27,
    Telugu = 28,
    Kannada = 29,
    Malayalam = 30,
    Sinhala = 31,
    Lao = 32,
    Tibetan = 33,
    Myanmar = 34,
    Georgian = 35,
    Jamo = 36,
    Ethiopic = 37,
    Cherokee = 38,
    Aboriginal = 39,
    Ogham = 40,
    Runic = 41,
    Khmer = 42,
    Mongolian = 43,
    Braille = 44,
    Yi = 45,
    Limbu = 46,
    TaiLe = 47,
    NewTaiLue = 48,
    SylotiNagri = 49,
    Kharoshthi = 50,
    Kayahli = 51,
    Usymbol = 52,
    Emoji = 53,
    Glagolitic = 54,
    Lisu = 55,
    Vai = 56,
    NKo = 57,
    Osmanya = 58,
    PhagsPa = 59,
    Gothic = 60,
    Deseret = 61,
    Tifinagh = 62,
    CharRepMax = 63,
    RE10Mode = 1,
    UseAtFont = 2,
    TextFlowMask = 12,
    TextFlowES = 0,
    TextFlowSW = 4,
    TextFlowWN = 8,
    TextFlowNE = 12,
    NoIME = 524288,
    SelfIME = 262144,
    NoUpScroll = 65536,
    NoVpScroll = 262144,
    NoLink = 0,
    ClientLink = 1,
    FriendlyLinkName = 2,
    FriendlyLinkAddress = 3,
    AutoLinkURL = 4,
    AutoLinkEmail = 5,
    AutoLinkPhone = 6,
    AutoLinkPath = 7,
    CompressNone = 0,
    CompressPunctuation = 1,
    CompressPunctuationAndKana = 2,
    CompressMax = 2,
    UnderlinePositionAuto = 0,
    UnderlinePositionBelow = 1,
    UnderlinePositionAbove = 2,
    UnderlinePositionMax = 2,
    FontAlignmentAuto = 0,
    FontAlignmentTop = 1,
    FontAlignmentBaseline = 2,
    FontAlignmentBottom = 3,
    FontAlignmentCenter = 4,
    FontAlignmentMax = 4,
    RubyBelow = 128,
    RubyAlignCenter = 0,
    RubyAlign010 = 1,
    RubyAlign121 = 2,
    RubyAlignLeft = 3,
    RubyAlignRight = 4,
    LimitsDefault = 0,
    LimitsUnderOver = 1,
    LimitsSubSup = 2,
    UpperLimitAsSuperScript = 3,
    LimitsOpposite = 4,
    ShowLLimPlaceHldr = 8,
    ShowULimPlaceHldr = 16,
    DontGrowWithContent = 64,
    GrowWithContent = 128,
    SubSupAlign = 1,
    LimitAlignMask = 3,
    LimitAlignCenter = 0,
    LimitAlignLeft = 1,
    LimitAlignRight = 2,
    ShowDegPlaceHldr = 8,
    AlignDefault = 0,
    AlignMatchAscentDescent = 2,
    MathVariant = 32,
    StyleDefault = 0,
    StyleScriptScriptCramped = 1,
    StyleScriptScript = 2,
    StyleScriptCramped = 3,
    StyleScript = 4,
    StyleTextCramped = 5,
    StyleText = 6,
    StyleDisplayCramped = 7,
    StyleDisplay = 8,
    MathRelSize = 64,
    DecDecSize = 254,
    DecSize = 255,
    IncSize = 65,
    IncIncSize = 66,
    GravityUI = 0,
    GravityBack = 1,
    GravityFore = 2,
    GravityIn = 3,
    GravityOut = 4,
    GravityBackward = 536870912,
    GravityForward = 1073741824,
    AdjustCRLF = 1,
    UseCRLF = 2,
    Textize = 4,
    AllowFinalEOP = 8,
    FoldMathAlpha = 16,
    NoHidden = 32,
    IncludeNumbering = 64,
    TranslateTableCell = 128,
    NoMathZoneBrackets = 256,
    ConvertMathChar = 512,
    NoUCGreekItalic = 1024,
    AllowMathBold = 2048,
    LanguageTag = 4096,
    ConvertRTF = 8192,
    ApplyRtfDocProps = 16384,
    PhantomShow = 1,
    PhantomZeroWidth = 2,
    PhantomZeroAscent = 4,
    PhantomZeroDescent = 8,
    PhantomTransparent = 16,
    PhantomASmash = 5,
    PhantomDSmash = 9,
    PhantomHSmash = 3,
    PhantomSmash = 13,
    PhantomHorz = 12,
    PhantomVert = 2,
    BoxHideTop = 1,
    BoxHideBottom = 2,
    BoxHideLeft = 4,
    BoxHideRight = 8,
    BoxStrikeH = 16,
    BoxStrikeV = 32,
    BoxStrikeTLBR = 64,
    BoxStrikeBLTR = 128,
    BoxAlignCenter = 1,
    SpaceMask = 28,
    SpaceDefault = 0,
    SpaceUnary = 4,
    SpaceBinary = 8,
    SpaceRelational = 12,
    SpaceSkip = 16,
    SpaceOrd = 20,
    SpaceDifferential = 24,
    SizeText = 32,
    SizeScript = 64,
    SizeScriptScript = 96,
    NoBreak = 128,
    TransparentForPositioning = 256,
    TransparentForSpacing = 512,
    StretchCharBelow = 0,
    StretchCharAbove = 1,
    StretchBaseBelow = 2,
    StretchBaseAbove = 3,
    MatrixAlignMask = 3,
    MatrixAlignCenter = 0,
    MatrixAlignTopRow = 1,
    MatrixAlignBottomRow = 3,
    ShowMatPlaceHldr = 8,
    EqArrayLayoutWidth = 1,
    EqArrayAlignMask = 12,
    EqArrayAlignCenter = 0,
    EqArrayAlignTopRow = 4,
    EqArrayAlignBottomRow = 12,
    MathManualBreakMask = 127,
    MathBreakLeft = 125,
    MathBreakCenter = 126,
    MathBreakRight = 127,
    MathEqAlign = 128,
    MathArgShadingStart = 593,
    MathArgShadingEnd = 594,
    MathObjShadingStart = 595,
    MathObjShadingEnd = 596,
    FunctionTypeNone = 0,
    FunctionTypeTakesArg = 1,
    FunctionTypeTakesLim = 2,
    FunctionTypeTakesLim2 = 3,
    FunctionTypeIsLim = 4,
    MathParaAlignDefault = 0,
    MathParaAlignCenterGroup = 1,
    MathParaAlignCenter = 2,
    MathParaAlignLeft = 3,
    MathParaAlignRight = 4,
    MathDispAlignMask = 3,
    MathDispAlignCenterGroup = 0,
    MathDispAlignCenter = 1,
    MathDispAlignLeft = 2,
    MathDispAlignRight = 3,
    MathDispIntUnderOver = 4,
    MathDispFracTeX = 8,
    MathDispNaryGrow = 16,
    MathDocEmptyArgMask = 96,
    MathDocEmptyArgAuto = 0,
    MathDocEmptyArgAlways = 32,
    MathDocEmptyArgNever = 64,
    MathDocSbSpOpUnchanged = 128,
    MathDocDiffMask = 768,
    MathDocDiffDefault = 0,
    MathDocDiffUpright = 256,
    MathDocDiffItalic = 512,
    MathDocDiffOpenItalic = 768,
    MathDispNarySubSup = 1024,
    MathDispDef = 2048,
    MathEnableRtl = 4096,
    MathBrkBinMask = 196608,
    MathBrkBinBefore = 0,
    MathBrkBinAfter = 65536,
    MathBrkBinDup = 131072,
    MathBrkBinSubMask = 786432,
    MathBrkBinSubMM = 0,
    MathBrkBinSubPM = 262144,
    MathBrkBinSubMP = 524288,
    SelRange = 597,
    Hstring = 596,
    FontPropTeXStyle = 828,
    FontPropAlign = 829,
    FontStretch = 830,
    FontStyle = 831,
    FontStyleUpright = 0,
    FontStyleOblique = 1,
    FontStyleItalic = 2,
    FontStretchDefault = 0,
    FontStretchUltraCondensed = 1,
    FontStretchExtraCondensed = 2,
    FontStretchCondensed = 3,
    FontStretchSemiCondensed = 4,
    FontStretchNormal = 5,
    FontStretchSemiExpanded = 6,
    FontStretchExpanded = 7,
    FontStretchExtraExpanded = 8,
    FontStretchUltraExpanded = 9,
    FontWeightDefault = 0,
    FontWeightThin = 100,
    FontWeightExtraLight = 200,
    FontWeightLight = 300,
    FontWeightNormal = 400,
    FontWeightRegular = 400,
    FontWeightMedium = 500,
    FontWeightSemiBold = 600,
    FontWeightBold = 700,
    FontWeightExtraBold = 800,
    FontWeightBlack = 900,
    FontWeightHeavy = 900,
    FontWeightExtraBlack = 950,
    ParaPropMathAlign = 1079,
    DocMathBuild = 128,
    MathLMargin = 129,
    MathRMargin = 130,
    MathWrapIndent = 131,
    MathWrapRight = 132,
    MathPostSpace = 134,
    MathPreSpace = 133,
    MathInterSpace = 135,
    MathIntraSpace = 136,
    CanCopy = 137,
    CanRedo = 138,
    CanUndo = 139,
    UndoLimit = 140,
    DocAutoLink = 141,
    EllipsisMode = 142,
    EllipsisState = 143,
    EllipsisNone = 0,
    EllipsisEnd = 1,
    EllipsisWord = 3,
    EllipsisPresent = 1,
    VTopCell = 1,
    VLowCell = 2,
    HStartCell = 4,
    HContCell = 8,
    RowUpdate = 1,
    RowApplyDefault = 0,
    CellStructureChangeOnly = 1,
    RowHeightActual = 2059,
};
pub const tomFalse = tomConstants.False;
pub const tomTrue = tomConstants.True;
pub const tomUndefined = tomConstants.Undefined;
pub const tomToggle = tomConstants.Toggle;
pub const tomAutoColor = tomConstants.AutoColor;
pub const tomDefault = tomConstants.Default;
pub const tomSuspend = tomConstants.Suspend;
pub const tomResume = tomConstants.Resume;
pub const tomApplyNow = tomConstants.ApplyNow;
pub const tomApplyLater = tomConstants.ApplyLater;
pub const tomTrackParms = tomConstants.TrackParms;
pub const tomCacheParms = tomConstants.CacheParms;
pub const tomApplyTmp = tomConstants.ApplyTmp;
pub const tomDisableSmartFont = tomConstants.DisableSmartFont;
pub const tomEnableSmartFont = tomConstants.EnableSmartFont;
pub const tomUsePoints = tomConstants.UsePoints;
pub const tomUseTwips = tomConstants.UseTwips;
pub const tomBackward = tomConstants.Backward;
pub const tomForward = tomConstants.Forward;
pub const tomMove = tomConstants.Move;
pub const tomExtend = tomConstants.Extend;
pub const tomNoSelection = tomConstants.NoSelection;
pub const tomSelectionIP = tomConstants.SelectionIP;
pub const tomSelectionNormal = tomConstants.SelectionNormal;
pub const tomSelectionFrame = tomConstants.SelectionFrame;
pub const tomSelectionColumn = tomConstants.SelectionColumn;
pub const tomSelectionRow = tomConstants.SelectionRow;
pub const tomSelectionBlock = tomConstants.SelectionBlock;
pub const tomSelectionInlineShape = tomConstants.SelectionInlineShape;
pub const tomSelectionShape = tomConstants.SelectionShape;
pub const tomSelStartActive = tomConstants.SelStartActive;
pub const tomSelAtEOL = tomConstants.SelAtEOL;
pub const tomSelOvertype = tomConstants.SelOvertype;
pub const tomSelActive = tomConstants.SelActive;
pub const tomSelReplace = tomConstants.SelReplace;
pub const tomEnd = tomConstants.End;
pub const tomStart = tomConstants.Start;
pub const tomCollapseEnd = tomConstants.CollapseEnd;
pub const tomCollapseStart = tomConstants.CollapseStart;
pub const tomClientCoord = tomConstants.ClientCoord;
pub const tomAllowOffClient = tomConstants.AllowOffClient;
pub const tomTransform = tomConstants.Transform;
pub const tomObjectArg = tomConstants.ObjectArg;
pub const tomAtEnd = tomConstants.AtEnd;
pub const tomNone = tomConstants.None;
pub const tomSingle = tomConstants.Single;
pub const tomWords = tomConstants.Words;
pub const tomDouble = tomConstants.Double;
pub const tomDotted = tomConstants.Dotted;
pub const tomDash = tomConstants.Dash;
pub const tomDashDot = tomConstants.DashDot;
pub const tomDashDotDot = tomConstants.DashDotDot;
pub const tomWave = tomConstants.Wave;
pub const tomThick = tomConstants.Thick;
pub const tomHair = tomConstants.Hair;
pub const tomDoubleWave = tomConstants.DoubleWave;
pub const tomHeavyWave = tomConstants.HeavyWave;
pub const tomLongDash = tomConstants.LongDash;
pub const tomThickDash = tomConstants.ThickDash;
pub const tomThickDashDot = tomConstants.ThickDashDot;
pub const tomThickDashDotDot = tomConstants.ThickDashDotDot;
pub const tomThickDotted = tomConstants.ThickDotted;
pub const tomThickLongDash = tomConstants.ThickLongDash;
pub const tomLineSpaceSingle = tomConstants.LineSpaceSingle;
pub const tomLineSpace1pt5 = tomConstants.LineSpace1pt5;
pub const tomLineSpaceDouble = tomConstants.LineSpaceDouble;
pub const tomLineSpaceAtLeast = tomConstants.LineSpaceAtLeast;
pub const tomLineSpaceExactly = tomConstants.LineSpaceExactly;
pub const tomLineSpaceMultiple = tomConstants.LineSpaceMultiple;
pub const tomLineSpacePercent = tomConstants.LineSpacePercent;
pub const tomAlignLeft = tomConstants.AlignLeft;
pub const tomAlignCenter = tomConstants.AlignCenter;
pub const tomAlignRight = tomConstants.AlignRight;
pub const tomAlignJustify = tomConstants.AlignJustify;
pub const tomAlignDecimal = tomConstants.AlignDecimal;
pub const tomAlignBar = tomConstants.AlignBar;
pub const tomDefaultTab = tomConstants.DefaultTab;
pub const tomAlignInterWord = tomConstants.AlignInterWord;
pub const tomAlignNewspaper = tomConstants.AlignNewspaper;
pub const tomAlignInterLetter = tomConstants.AlignInterLetter;
pub const tomAlignScaled = tomConstants.AlignScaled;
pub const tomSpaces = tomConstants.Spaces;
pub const tomDots = tomConstants.Dots;
pub const tomDashes = tomConstants.Dashes;
pub const tomLines = tomConstants.Lines;
pub const tomThickLines = tomConstants.ThickLines;
pub const tomEquals = tomConstants.Equals;
pub const tomTabBack = tomConstants.TabBack;
pub const tomTabNext = tomConstants.TabNext;
pub const tomTabHere = tomConstants.TabHere;
pub const tomListNone = tomConstants.ListNone;
pub const tomListBullet = tomConstants.ListBullet;
pub const tomListNumberAsArabic = tomConstants.ListNumberAsArabic;
pub const tomListNumberAsLCLetter = tomConstants.ListNumberAsLCLetter;
pub const tomListNumberAsUCLetter = tomConstants.ListNumberAsUCLetter;
pub const tomListNumberAsLCRoman = tomConstants.ListNumberAsLCRoman;
pub const tomListNumberAsUCRoman = tomConstants.ListNumberAsUCRoman;
pub const tomListNumberAsSequence = tomConstants.ListNumberAsSequence;
pub const tomListNumberedCircle = tomConstants.ListNumberedCircle;
pub const tomListNumberedBlackCircleWingding = tomConstants.ListNumberedBlackCircleWingding;
pub const tomListNumberedWhiteCircleWingding = tomConstants.ListNumberedWhiteCircleWingding;
pub const tomListNumberedArabicWide = tomConstants.ListNumberedArabicWide;
pub const tomListNumberedChS = tomConstants.ListNumberedChS;
pub const tomListNumberedChT = tomConstants.ListNumberedChT;
pub const tomListNumberedJpnChS = tomConstants.ListNumberedJpnChS;
pub const tomListNumberedJpnKor = tomConstants.ListNumberedJpnKor;
pub const tomListNumberedArabic1 = tomConstants.ListNumberedArabic1;
pub const tomListNumberedArabic2 = tomConstants.ListNumberedArabic2;
pub const tomListNumberedHebrew = tomConstants.ListNumberedHebrew;
pub const tomListNumberedThaiAlpha = tomConstants.ListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.ListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.ListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.ListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.ListNumberedHindiNum;
pub const tomListParentheses = tomConstants.ListParentheses;
pub const tomListPeriod = tomConstants.ListPeriod;
pub const tomListPlain = tomConstants.ListPlain;
pub const tomListNoNumber = tomConstants.ListNoNumber;
pub const tomListMinus = tomConstants.ListMinus;
pub const tomIgnoreNumberStyle = tomConstants.IgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.ParaStyleNormal;
pub const tomParaStyleHeading1 = tomConstants.ParaStyleHeading1;
pub const tomParaStyleHeading2 = tomConstants.ParaStyleHeading2;
pub const tomParaStyleHeading3 = tomConstants.ParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.ParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.ParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.ParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.ParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.ParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.ParaStyleHeading9;
pub const tomCharacter = tomConstants.Character;
pub const tomWord = tomConstants.Word;
pub const tomSentence = tomConstants.Sentence;
pub const tomParagraph = tomConstants.Paragraph;
pub const tomLine = tomConstants.Line;
pub const tomStory = tomConstants.Story;
pub const tomScreen = tomConstants.Screen;
pub const tomSection = tomConstants.Section;
pub const tomTableColumn = tomConstants.TableColumn;
pub const tomColumn = tomConstants.Column;
pub const tomRow = tomConstants.Row;
pub const tomWindow = tomConstants.Window;
pub const tomCell = tomConstants.Cell;
pub const tomCharFormat = tomConstants.CharFormat;
pub const tomParaFormat = tomConstants.ParaFormat;
pub const tomTable = tomConstants.Table;
pub const tomObject = tomConstants.Object;
pub const tomPage = tomConstants.Page;
pub const tomHardParagraph = tomConstants.HardParagraph;
pub const tomCluster = tomConstants.Cluster;
pub const tomInlineObject = tomConstants.InlineObject;
pub const tomInlineObjectArg = tomConstants.InlineObjectArg;
pub const tomLeafLine = tomConstants.LeafLine;
pub const tomLayoutColumn = tomConstants.LayoutColumn;
pub const tomProcessId = tomConstants.ProcessId;
pub const tomMatchWord = tomConstants.MatchWord;
pub const tomMatchCase = tomConstants.MatchCase;
pub const tomMatchPattern = tomConstants.MatchPattern;
pub const tomUnknownStory = tomConstants.UnknownStory;
pub const tomMainTextStory = tomConstants.MainTextStory;
pub const tomFootnotesStory = tomConstants.FootnotesStory;
pub const tomEndnotesStory = tomConstants.EndnotesStory;
pub const tomCommentsStory = tomConstants.CommentsStory;
pub const tomTextFrameStory = tomConstants.TextFrameStory;
pub const tomEvenPagesHeaderStory = tomConstants.EvenPagesHeaderStory;
pub const tomPrimaryHeaderStory = tomConstants.PrimaryHeaderStory;
pub const tomEvenPagesFooterStory = tomConstants.EvenPagesFooterStory;
pub const tomPrimaryFooterStory = tomConstants.PrimaryFooterStory;
pub const tomFirstPageHeaderStory = tomConstants.FirstPageHeaderStory;
pub const tomFirstPageFooterStory = tomConstants.FirstPageFooterStory;
pub const tomScratchStory = tomConstants.ScratchStory;
pub const tomFindStory = tomConstants.FindStory;
pub const tomReplaceStory = tomConstants.ReplaceStory;
pub const tomStoryInactive = tomConstants.StoryInactive;
pub const tomStoryActiveDisplay = tomConstants.StoryActiveDisplay;
pub const tomStoryActiveUI = tomConstants.StoryActiveUI;
pub const tomStoryActiveDisplayUI = tomConstants.StoryActiveDisplayUI;
pub const tomNoAnimation = tomConstants.NoAnimation;
pub const tomLasVegasLights = tomConstants.LasVegasLights;
pub const tomBlinkingBackground = tomConstants.BlinkingBackground;
pub const tomSparkleText = tomConstants.SparkleText;
pub const tomMarchingBlackAnts = tomConstants.MarchingBlackAnts;
pub const tomMarchingRedAnts = tomConstants.MarchingRedAnts;
pub const tomShimmer = tomConstants.Shimmer;
pub const tomWipeDown = tomConstants.WipeDown;
pub const tomWipeRight = tomConstants.WipeRight;
pub const tomAnimationMax = tomConstants.AnimationMax;
pub const tomLowerCase = tomConstants.LowerCase;
pub const tomUpperCase = tomConstants.UpperCase;
pub const tomTitleCase = tomConstants.TitleCase;
pub const tomSentenceCase = tomConstants.SentenceCase;
pub const tomToggleCase = tomConstants.ToggleCase;
pub const tomReadOnly = tomConstants.ReadOnly;
pub const tomShareDenyRead = tomConstants.ShareDenyRead;
pub const tomShareDenyWrite = tomConstants.ShareDenyWrite;
pub const tomPasteFile = tomConstants.PasteFile;
pub const tomCreateNew = tomConstants.CreateNew;
pub const tomCreateAlways = tomConstants.CreateAlways;
pub const tomOpenExisting = tomConstants.OpenExisting;
pub const tomOpenAlways = tomConstants.OpenAlways;
pub const tomTruncateExisting = tomConstants.TruncateExisting;
pub const tomRTF = tomConstants.RTF;
pub const tomText = tomConstants.Text;
pub const tomHTML = tomConstants.HTML;
pub const tomWordDocument = tomConstants.WordDocument;
pub const tomBold = tomConstants.Bold;
pub const tomItalic = tomConstants.Italic;
pub const tomUnderline = tomConstants.Underline;
pub const tomStrikeout = tomConstants.Strikeout;
pub const tomProtected = tomConstants.Protected;
pub const tomLink = tomConstants.Link;
pub const tomSmallCaps = tomConstants.SmallCaps;
pub const tomAllCaps = tomConstants.AllCaps;
pub const tomHidden = tomConstants.Hidden;
pub const tomOutline = tomConstants.Outline;
pub const tomShadow = tomConstants.Shadow;
pub const tomEmboss = tomConstants.Emboss;
pub const tomImprint = tomConstants.Imprint;
pub const tomDisabled = tomConstants.Disabled;
pub const tomRevised = tomConstants.Revised;
pub const tomSubscriptCF = tomConstants.SubscriptCF;
pub const tomSuperscriptCF = tomConstants.SuperscriptCF;
pub const tomFontBound = tomConstants.FontBound;
pub const tomLinkProtected = tomConstants.LinkProtected;
pub const tomInlineObjectStart = tomConstants.InlineObjectStart;
pub const tomExtendedChar = tomConstants.ExtendedChar;
pub const tomAutoBackColor = tomConstants.AutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.MathZoneNoBuildUp;
pub const tomMathZone = tomConstants.MathZone;
pub const tomMathZoneOrdinary = tomConstants.MathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.AutoTextColor;
pub const tomMathZoneDisplay = tomConstants.MathZoneDisplay;
pub const tomParaEffectRTL = tomConstants.ParaEffectRTL;
pub const tomParaEffectKeep = tomConstants.ParaEffectKeep;
pub const tomParaEffectKeepNext = tomConstants.ParaEffectKeepNext;
pub const tomParaEffectPageBreakBefore = tomConstants.ParaEffectPageBreakBefore;
pub const tomParaEffectNoLineNumber = tomConstants.ParaEffectNoLineNumber;
pub const tomParaEffectNoWidowControl = tomConstants.ParaEffectNoWidowControl;
pub const tomParaEffectDoNotHyphen = tomConstants.ParaEffectDoNotHyphen;
pub const tomParaEffectSideBySide = tomConstants.ParaEffectSideBySide;
pub const tomParaEffectCollapsed = tomConstants.ParaEffectCollapsed;
pub const tomParaEffectOutlineLevel = tomConstants.ParaEffectOutlineLevel;
pub const tomParaEffectBox = tomConstants.ParaEffectBox;
pub const tomParaEffectTableRowDelimiter = tomConstants.ParaEffectTableRowDelimiter;
pub const tomParaEffectTable = tomConstants.ParaEffectTable;
pub const tomModWidthPairs = tomConstants.ModWidthPairs;
pub const tomModWidthSpace = tomConstants.ModWidthSpace;
pub const tomAutoSpaceAlpha = tomConstants.AutoSpaceAlpha;
pub const tomAutoSpaceNumeric = tomConstants.AutoSpaceNumeric;
pub const tomAutoSpaceParens = tomConstants.AutoSpaceParens;
pub const tomEmbeddedFont = tomConstants.EmbeddedFont;
pub const tomDoublestrike = tomConstants.Doublestrike;
pub const tomOverlapping = tomConstants.Overlapping;
pub const tomNormalCaret = tomConstants.NormalCaret;
pub const tomKoreanBlockCaret = tomConstants.KoreanBlockCaret;
pub const tomNullCaret = tomConstants.NullCaret;
pub const tomIncludeInset = tomConstants.IncludeInset;
pub const tomUnicodeBiDi = tomConstants.UnicodeBiDi;
pub const tomMathCFCheck = tomConstants.MathCFCheck;
pub const tomUnlink = tomConstants.Unlink;
pub const tomUnhide = tomConstants.Unhide;
pub const tomCheckTextLimit = tomConstants.CheckTextLimit;
pub const tomIgnoreCurrentFont = tomConstants.IgnoreCurrentFont;
pub const tomMatchCharRep = tomConstants.MatchCharRep;
pub const tomMatchFontSignature = tomConstants.MatchFontSignature;
pub const tomMatchAscii = tomConstants.MatchAscii;
pub const tomGetHeightOnly = tomConstants.GetHeightOnly;
pub const tomMatchMathFont = tomConstants.MatchMathFont;
pub const tomCharset = tomConstants.Charset;
pub const tomCharRepFromLcid = tomConstants.CharRepFromLcid;
pub const tomAnsi = tomConstants.Ansi;
pub const tomEastEurope = tomConstants.EastEurope;
pub const tomCyrillic = tomConstants.Cyrillic;
pub const tomGreek = tomConstants.Greek;
pub const tomTurkish = tomConstants.Turkish;
pub const tomHebrew = tomConstants.Hebrew;
pub const tomArabic = tomConstants.Arabic;
pub const tomBaltic = tomConstants.Baltic;
pub const tomVietnamese = tomConstants.Vietnamese;
pub const tomDefaultCharRep = tomConstants.DefaultCharRep;
pub const tomSymbol = tomConstants.Symbol;
pub const tomThai = tomConstants.Thai;
pub const tomShiftJIS = tomConstants.ShiftJIS;
pub const tomGB2312 = tomConstants.GB2312;
pub const tomHangul = tomConstants.Hangul;
pub const tomBIG5 = tomConstants.BIG5;
pub const tomPC437 = tomConstants.PC437;
pub const tomOEM = tomConstants.OEM;
pub const tomMac = tomConstants.Mac;
pub const tomArmenian = tomConstants.Armenian;
pub const tomSyriac = tomConstants.Syriac;
pub const tomThaana = tomConstants.Thaana;
pub const tomDevanagari = tomConstants.Devanagari;
pub const tomBengali = tomConstants.Bengali;
pub const tomGurmukhi = tomConstants.Gurmukhi;
pub const tomGujarati = tomConstants.Gujarati;
pub const tomOriya = tomConstants.Oriya;
pub const tomTamil = tomConstants.Tamil;
pub const tomTelugu = tomConstants.Telugu;
pub const tomKannada = tomConstants.Kannada;
pub const tomMalayalam = tomConstants.Malayalam;
pub const tomSinhala = tomConstants.Sinhala;
pub const tomLao = tomConstants.Lao;
pub const tomTibetan = tomConstants.Tibetan;
pub const tomMyanmar = tomConstants.Myanmar;
pub const tomGeorgian = tomConstants.Georgian;
pub const tomJamo = tomConstants.Jamo;
pub const tomEthiopic = tomConstants.Ethiopic;
pub const tomCherokee = tomConstants.Cherokee;
pub const tomAboriginal = tomConstants.Aboriginal;
pub const tomOgham = tomConstants.Ogham;
pub const tomRunic = tomConstants.Runic;
pub const tomKhmer = tomConstants.Khmer;
pub const tomMongolian = tomConstants.Mongolian;
pub const tomBraille = tomConstants.Braille;
pub const tomYi = tomConstants.Yi;
pub const tomLimbu = tomConstants.Limbu;
pub const tomTaiLe = tomConstants.TaiLe;
pub const tomNewTaiLue = tomConstants.NewTaiLue;
pub const tomSylotiNagri = tomConstants.SylotiNagri;
pub const tomKharoshthi = tomConstants.Kharoshthi;
pub const tomKayahli = tomConstants.Kayahli;
pub const tomUsymbol = tomConstants.Usymbol;
pub const tomEmoji = tomConstants.Emoji;
pub const tomGlagolitic = tomConstants.Glagolitic;
pub const tomLisu = tomConstants.Lisu;
pub const tomVai = tomConstants.Vai;
pub const tomNKo = tomConstants.NKo;
pub const tomOsmanya = tomConstants.Osmanya;
pub const tomPhagsPa = tomConstants.PhagsPa;
pub const tomGothic = tomConstants.Gothic;
pub const tomDeseret = tomConstants.Deseret;
pub const tomTifinagh = tomConstants.Tifinagh;
pub const tomCharRepMax = tomConstants.CharRepMax;
pub const tomRE10Mode = tomConstants.RE10Mode;
pub const tomUseAtFont = tomConstants.UseAtFont;
pub const tomTextFlowMask = tomConstants.TextFlowMask;
pub const tomTextFlowES = tomConstants.TextFlowES;
pub const tomTextFlowSW = tomConstants.TextFlowSW;
pub const tomTextFlowWN = tomConstants.TextFlowWN;
pub const tomTextFlowNE = tomConstants.TextFlowNE;
pub const tomNoIME = tomConstants.NoIME;
pub const tomSelfIME = tomConstants.SelfIME;
pub const tomNoUpScroll = tomConstants.NoUpScroll;
pub const tomNoVpScroll = tomConstants.NoVpScroll;
pub const tomNoLink = tomConstants.NoLink;
pub const tomClientLink = tomConstants.ClientLink;
pub const tomFriendlyLinkName = tomConstants.FriendlyLinkName;
pub const tomFriendlyLinkAddress = tomConstants.FriendlyLinkAddress;
pub const tomAutoLinkURL = tomConstants.AutoLinkURL;
pub const tomAutoLinkEmail = tomConstants.AutoLinkEmail;
pub const tomAutoLinkPhone = tomConstants.AutoLinkPhone;
pub const tomAutoLinkPath = tomConstants.AutoLinkPath;
pub const tomCompressNone = tomConstants.CompressNone;
pub const tomCompressPunctuation = tomConstants.CompressPunctuation;
pub const tomCompressPunctuationAndKana = tomConstants.CompressPunctuationAndKana;
pub const tomCompressMax = tomConstants.CompressMax;
pub const tomUnderlinePositionAuto = tomConstants.UnderlinePositionAuto;
pub const tomUnderlinePositionBelow = tomConstants.UnderlinePositionBelow;
pub const tomUnderlinePositionAbove = tomConstants.UnderlinePositionAbove;
pub const tomUnderlinePositionMax = tomConstants.UnderlinePositionMax;
pub const tomFontAlignmentAuto = tomConstants.FontAlignmentAuto;
pub const tomFontAlignmentTop = tomConstants.FontAlignmentTop;
pub const tomFontAlignmentBaseline = tomConstants.FontAlignmentBaseline;
pub const tomFontAlignmentBottom = tomConstants.FontAlignmentBottom;
pub const tomFontAlignmentCenter = tomConstants.FontAlignmentCenter;
pub const tomFontAlignmentMax = tomConstants.FontAlignmentMax;
pub const tomRubyBelow = tomConstants.RubyBelow;
pub const tomRubyAlignCenter = tomConstants.RubyAlignCenter;
pub const tomRubyAlign010 = tomConstants.RubyAlign010;
pub const tomRubyAlign121 = tomConstants.RubyAlign121;
pub const tomRubyAlignLeft = tomConstants.RubyAlignLeft;
pub const tomRubyAlignRight = tomConstants.RubyAlignRight;
pub const tomLimitsDefault = tomConstants.LimitsDefault;
pub const tomLimitsUnderOver = tomConstants.LimitsUnderOver;
pub const tomLimitsSubSup = tomConstants.LimitsSubSup;
pub const tomUpperLimitAsSuperScript = tomConstants.UpperLimitAsSuperScript;
pub const tomLimitsOpposite = tomConstants.LimitsOpposite;
pub const tomShowLLimPlaceHldr = tomConstants.ShowLLimPlaceHldr;
pub const tomShowULimPlaceHldr = tomConstants.ShowULimPlaceHldr;
pub const tomDontGrowWithContent = tomConstants.DontGrowWithContent;
pub const tomGrowWithContent = tomConstants.GrowWithContent;
pub const tomSubSupAlign = tomConstants.SubSupAlign;
pub const tomLimitAlignMask = tomConstants.LimitAlignMask;
pub const tomLimitAlignCenter = tomConstants.LimitAlignCenter;
pub const tomLimitAlignLeft = tomConstants.LimitAlignLeft;
pub const tomLimitAlignRight = tomConstants.LimitAlignRight;
pub const tomShowDegPlaceHldr = tomConstants.ShowDegPlaceHldr;
pub const tomAlignDefault = tomConstants.AlignDefault;
pub const tomAlignMatchAscentDescent = tomConstants.AlignMatchAscentDescent;
pub const tomMathVariant = tomConstants.MathVariant;
pub const tomStyleDefault = tomConstants.StyleDefault;
pub const tomStyleScriptScriptCramped = tomConstants.StyleScriptScriptCramped;
pub const tomStyleScriptScript = tomConstants.StyleScriptScript;
pub const tomStyleScriptCramped = tomConstants.StyleScriptCramped;
pub const tomStyleScript = tomConstants.StyleScript;
pub const tomStyleTextCramped = tomConstants.StyleTextCramped;
pub const tomStyleText = tomConstants.StyleText;
pub const tomStyleDisplayCramped = tomConstants.StyleDisplayCramped;
pub const tomStyleDisplay = tomConstants.StyleDisplay;
pub const tomMathRelSize = tomConstants.MathRelSize;
pub const tomDecDecSize = tomConstants.DecDecSize;
pub const tomDecSize = tomConstants.DecSize;
pub const tomIncSize = tomConstants.IncSize;
pub const tomIncIncSize = tomConstants.IncIncSize;
pub const tomGravityUI = tomConstants.GravityUI;
pub const tomGravityBack = tomConstants.GravityBack;
pub const tomGravityFore = tomConstants.GravityFore;
pub const tomGravityIn = tomConstants.GravityIn;
pub const tomGravityOut = tomConstants.GravityOut;
pub const tomGravityBackward = tomConstants.GravityBackward;
pub const tomGravityForward = tomConstants.GravityForward;
pub const tomAdjustCRLF = tomConstants.AdjustCRLF;
pub const tomUseCRLF = tomConstants.UseCRLF;
pub const tomTextize = tomConstants.Textize;
pub const tomAllowFinalEOP = tomConstants.AllowFinalEOP;
pub const tomFoldMathAlpha = tomConstants.FoldMathAlpha;
pub const tomNoHidden = tomConstants.NoHidden;
pub const tomIncludeNumbering = tomConstants.IncludeNumbering;
pub const tomTranslateTableCell = tomConstants.TranslateTableCell;
pub const tomNoMathZoneBrackets = tomConstants.NoMathZoneBrackets;
pub const tomConvertMathChar = tomConstants.ConvertMathChar;
pub const tomNoUCGreekItalic = tomConstants.NoUCGreekItalic;
pub const tomAllowMathBold = tomConstants.AllowMathBold;
pub const tomLanguageTag = tomConstants.LanguageTag;
pub const tomConvertRTF = tomConstants.ConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.ApplyRtfDocProps;
pub const tomPhantomShow = tomConstants.PhantomShow;
pub const tomPhantomZeroWidth = tomConstants.PhantomZeroWidth;
pub const tomPhantomZeroAscent = tomConstants.PhantomZeroAscent;
pub const tomPhantomZeroDescent = tomConstants.PhantomZeroDescent;
pub const tomPhantomTransparent = tomConstants.PhantomTransparent;
pub const tomPhantomASmash = tomConstants.PhantomASmash;
pub const tomPhantomDSmash = tomConstants.PhantomDSmash;
pub const tomPhantomHSmash = tomConstants.PhantomHSmash;
pub const tomPhantomSmash = tomConstants.PhantomSmash;
pub const tomPhantomHorz = tomConstants.PhantomHorz;
pub const tomPhantomVert = tomConstants.PhantomVert;
pub const tomBoxHideTop = tomConstants.BoxHideTop;
pub const tomBoxHideBottom = tomConstants.BoxHideBottom;
pub const tomBoxHideLeft = tomConstants.BoxHideLeft;
pub const tomBoxHideRight = tomConstants.BoxHideRight;
pub const tomBoxStrikeH = tomConstants.BoxStrikeH;
pub const tomBoxStrikeV = tomConstants.BoxStrikeV;
pub const tomBoxStrikeTLBR = tomConstants.BoxStrikeTLBR;
pub const tomBoxStrikeBLTR = tomConstants.BoxStrikeBLTR;
pub const tomBoxAlignCenter = tomConstants.BoxAlignCenter;
pub const tomSpaceMask = tomConstants.SpaceMask;
pub const tomSpaceDefault = tomConstants.SpaceDefault;
pub const tomSpaceUnary = tomConstants.SpaceUnary;
pub const tomSpaceBinary = tomConstants.SpaceBinary;
pub const tomSpaceRelational = tomConstants.SpaceRelational;
pub const tomSpaceSkip = tomConstants.SpaceSkip;
pub const tomSpaceOrd = tomConstants.SpaceOrd;
pub const tomSpaceDifferential = tomConstants.SpaceDifferential;
pub const tomSizeText = tomConstants.SizeText;
pub const tomSizeScript = tomConstants.SizeScript;
pub const tomSizeScriptScript = tomConstants.SizeScriptScript;
pub const tomNoBreak = tomConstants.NoBreak;
pub const tomTransparentForPositioning = tomConstants.TransparentForPositioning;
pub const tomTransparentForSpacing = tomConstants.TransparentForSpacing;
pub const tomStretchCharBelow = tomConstants.StretchCharBelow;
pub const tomStretchCharAbove = tomConstants.StretchCharAbove;
pub const tomStretchBaseBelow = tomConstants.StretchBaseBelow;
pub const tomStretchBaseAbove = tomConstants.StretchBaseAbove;
pub const tomMatrixAlignMask = tomConstants.MatrixAlignMask;
pub const tomMatrixAlignCenter = tomConstants.MatrixAlignCenter;
pub const tomMatrixAlignTopRow = tomConstants.MatrixAlignTopRow;
pub const tomMatrixAlignBottomRow = tomConstants.MatrixAlignBottomRow;
pub const tomShowMatPlaceHldr = tomConstants.ShowMatPlaceHldr;
pub const tomEqArrayLayoutWidth = tomConstants.EqArrayLayoutWidth;
pub const tomEqArrayAlignMask = tomConstants.EqArrayAlignMask;
pub const tomEqArrayAlignCenter = tomConstants.EqArrayAlignCenter;
pub const tomEqArrayAlignTopRow = tomConstants.EqArrayAlignTopRow;
pub const tomEqArrayAlignBottomRow = tomConstants.EqArrayAlignBottomRow;
pub const tomMathManualBreakMask = tomConstants.MathManualBreakMask;
pub const tomMathBreakLeft = tomConstants.MathBreakLeft;
pub const tomMathBreakCenter = tomConstants.MathBreakCenter;
pub const tomMathBreakRight = tomConstants.MathBreakRight;
pub const tomMathEqAlign = tomConstants.MathEqAlign;
pub const tomMathArgShadingStart = tomConstants.MathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.MathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.MathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.MathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.FunctionTypeNone;
pub const tomFunctionTypeTakesArg = tomConstants.FunctionTypeTakesArg;
pub const tomFunctionTypeTakesLim = tomConstants.FunctionTypeTakesLim;
pub const tomFunctionTypeTakesLim2 = tomConstants.FunctionTypeTakesLim2;
pub const tomFunctionTypeIsLim = tomConstants.FunctionTypeIsLim;
pub const tomMathParaAlignDefault = tomConstants.MathParaAlignDefault;
pub const tomMathParaAlignCenterGroup = tomConstants.MathParaAlignCenterGroup;
pub const tomMathParaAlignCenter = tomConstants.MathParaAlignCenter;
pub const tomMathParaAlignLeft = tomConstants.MathParaAlignLeft;
pub const tomMathParaAlignRight = tomConstants.MathParaAlignRight;
pub const tomMathDispAlignMask = tomConstants.MathDispAlignMask;
pub const tomMathDispAlignCenterGroup = tomConstants.MathDispAlignCenterGroup;
pub const tomMathDispAlignCenter = tomConstants.MathDispAlignCenter;
pub const tomMathDispAlignLeft = tomConstants.MathDispAlignLeft;
pub const tomMathDispAlignRight = tomConstants.MathDispAlignRight;
pub const tomMathDispIntUnderOver = tomConstants.MathDispIntUnderOver;
pub const tomMathDispFracTeX = tomConstants.MathDispFracTeX;
pub const tomMathDispNaryGrow = tomConstants.MathDispNaryGrow;
pub const tomMathDocEmptyArgMask = tomConstants.MathDocEmptyArgMask;
pub const tomMathDocEmptyArgAuto = tomConstants.MathDocEmptyArgAuto;
pub const tomMathDocEmptyArgAlways = tomConstants.MathDocEmptyArgAlways;
pub const tomMathDocEmptyArgNever = tomConstants.MathDocEmptyArgNever;
pub const tomMathDocSbSpOpUnchanged = tomConstants.MathDocSbSpOpUnchanged;
pub const tomMathDocDiffMask = tomConstants.MathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.MathDocDiffDefault;
pub const tomMathDocDiffUpright = tomConstants.MathDocDiffUpright;
pub const tomMathDocDiffItalic = tomConstants.MathDocDiffItalic;
pub const tomMathDocDiffOpenItalic = tomConstants.MathDocDiffOpenItalic;
pub const tomMathDispNarySubSup = tomConstants.MathDispNarySubSup;
pub const tomMathDispDef = tomConstants.MathDispDef;
pub const tomMathEnableRtl = tomConstants.MathEnableRtl;
pub const tomMathBrkBinMask = tomConstants.MathBrkBinMask;
pub const tomMathBrkBinBefore = tomConstants.MathBrkBinBefore;
pub const tomMathBrkBinAfter = tomConstants.MathBrkBinAfter;
pub const tomMathBrkBinDup = tomConstants.MathBrkBinDup;
pub const tomMathBrkBinSubMask = tomConstants.MathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.MathBrkBinSubMM;
pub const tomMathBrkBinSubPM = tomConstants.MathBrkBinSubPM;
pub const tomMathBrkBinSubMP = tomConstants.MathBrkBinSubMP;
pub const tomSelRange = tomConstants.SelRange;
pub const tomHstring = tomConstants.Hstring;
pub const tomFontPropTeXStyle = tomConstants.FontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.FontPropAlign;
pub const tomFontStretch = tomConstants.FontStretch;
pub const tomFontStyle = tomConstants.FontStyle;
pub const tomFontStyleUpright = tomConstants.FontStyleUpright;
pub const tomFontStyleOblique = tomConstants.FontStyleOblique;
pub const tomFontStyleItalic = tomConstants.FontStyleItalic;
pub const tomFontStretchDefault = tomConstants.FontStretchDefault;
pub const tomFontStretchUltraCondensed = tomConstants.FontStretchUltraCondensed;
pub const tomFontStretchExtraCondensed = tomConstants.FontStretchExtraCondensed;
pub const tomFontStretchCondensed = tomConstants.FontStretchCondensed;
pub const tomFontStretchSemiCondensed = tomConstants.FontStretchSemiCondensed;
pub const tomFontStretchNormal = tomConstants.FontStretchNormal;
pub const tomFontStretchSemiExpanded = tomConstants.FontStretchSemiExpanded;
pub const tomFontStretchExpanded = tomConstants.FontStretchExpanded;
pub const tomFontStretchExtraExpanded = tomConstants.FontStretchExtraExpanded;
pub const tomFontStretchUltraExpanded = tomConstants.FontStretchUltraExpanded;
pub const tomFontWeightDefault = tomConstants.FontWeightDefault;
pub const tomFontWeightThin = tomConstants.FontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.FontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.FontWeightLight;
pub const tomFontWeightNormal = tomConstants.FontWeightNormal;
pub const tomFontWeightRegular = tomConstants.FontWeightRegular;
pub const tomFontWeightMedium = tomConstants.FontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.FontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.FontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.FontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.FontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.FontWeightHeavy;
pub const tomFontWeightExtraBlack = tomConstants.FontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.ParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.DocMathBuild;
pub const tomMathLMargin = tomConstants.MathLMargin;
pub const tomMathRMargin = tomConstants.MathRMargin;
pub const tomMathWrapIndent = tomConstants.MathWrapIndent;
pub const tomMathWrapRight = tomConstants.MathWrapRight;
pub const tomMathPostSpace = tomConstants.MathPostSpace;
pub const tomMathPreSpace = tomConstants.MathPreSpace;
pub const tomMathInterSpace = tomConstants.MathInterSpace;
pub const tomMathIntraSpace = tomConstants.MathIntraSpace;
pub const tomCanCopy = tomConstants.CanCopy;
pub const tomCanRedo = tomConstants.CanRedo;
pub const tomCanUndo = tomConstants.CanUndo;
pub const tomUndoLimit = tomConstants.UndoLimit;
pub const tomDocAutoLink = tomConstants.DocAutoLink;
pub const tomEllipsisMode = tomConstants.EllipsisMode;
pub const tomEllipsisState = tomConstants.EllipsisState;
pub const tomEllipsisNone = tomConstants.EllipsisNone;
pub const tomEllipsisEnd = tomConstants.EllipsisEnd;
pub const tomEllipsisWord = tomConstants.EllipsisWord;
pub const tomEllipsisPresent = tomConstants.EllipsisPresent;
pub const tomVTopCell = tomConstants.VTopCell;
pub const tomVLowCell = tomConstants.VLowCell;
pub const tomHStartCell = tomConstants.HStartCell;
pub const tomHContCell = tomConstants.HContCell;
pub const tomRowUpdate = tomConstants.RowUpdate;
pub const tomRowApplyDefault = tomConstants.RowApplyDefault;
pub const tomCellStructureChangeOnly = tomConstants.CellStructureChangeOnly;
pub const tomRowHeightActual = tomConstants.RowHeightActual;

pub const OBJECTTYPE = extern enum(i32) {
    SimpleText = 0,
    Ruby = 1,
    HorzVert = 2,
    Warichu = 3,
    Eq = 9,
    Math = 10,
    Accent = 10,
    Box = 11,
    BoxedFormula = 12,
    Brackets = 13,
    BracketsWithSeps = 14,
    EquationArray = 15,
    Fraction = 16,
    FunctionApply = 17,
    LeftSubSup = 18,
    LowerLimit = 19,
    Matrix = 20,
    Nary = 21,
    OpChar = 22,
    Overbar = 23,
    Phantom = 24,
    Radical = 25,
    SlashedFraction = 26,
    Stack = 27,
    StretchStack = 28,
    Subscript = 29,
    SubSup = 30,
    Superscript = 31,
    Underbar = 32,
    UpperLimit = 33,
    ObjectMax = 33,
};
pub const tomSimpleText = OBJECTTYPE.SimpleText;
pub const tomRuby = OBJECTTYPE.Ruby;
pub const tomHorzVert = OBJECTTYPE.HorzVert;
pub const tomWarichu = OBJECTTYPE.Warichu;
pub const tomEq = OBJECTTYPE.Eq;
pub const tomMath = OBJECTTYPE.Math;
pub const tomAccent = OBJECTTYPE.Accent;
pub const tomBox = OBJECTTYPE.Box;
pub const tomBoxedFormula = OBJECTTYPE.BoxedFormula;
pub const tomBrackets = OBJECTTYPE.Brackets;
pub const tomBracketsWithSeps = OBJECTTYPE.BracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.EquationArray;
pub const tomFraction = OBJECTTYPE.Fraction;
pub const tomFunctionApply = OBJECTTYPE.FunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.LeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.LowerLimit;
pub const tomMatrix = OBJECTTYPE.Matrix;
pub const tomNary = OBJECTTYPE.Nary;
pub const tomOpChar = OBJECTTYPE.OpChar;
pub const tomOverbar = OBJECTTYPE.Overbar;
pub const tomPhantom = OBJECTTYPE.Phantom;
pub const tomRadical = OBJECTTYPE.Radical;
pub const tomSlashedFraction = OBJECTTYPE.SlashedFraction;
pub const tomStack = OBJECTTYPE.Stack;
pub const tomStretchStack = OBJECTTYPE.StretchStack;
pub const tomSubscript = OBJECTTYPE.Subscript;
pub const tomSubSup = OBJECTTYPE.SubSup;
pub const tomSuperscript = OBJECTTYPE.Superscript;
pub const tomUnderbar = OBJECTTYPE.Underbar;
pub const tomUpperLimit = OBJECTTYPE.UpperLimit;
pub const tomObjectMax = OBJECTTYPE.ObjectMax;

pub const MANCODE = extern enum(i32) {
    BOLD = 16,
    ITAL = 32,
    GREEK = 64,
    ROMN = 0,
    SCRP = 1,
    FRAK = 2,
    OPEN = 3,
    SANS = 4,
    MONO = 5,
    MATH = 6,
    ISOL = 7,
    INIT = 8,
    TAIL = 9,
    STRCH = 10,
    LOOP = 11,
    OPENA = 12,
};
pub const MBOLD = MANCODE.BOLD;
pub const MITAL = MANCODE.ITAL;
pub const MGREEK = MANCODE.GREEK;
pub const MROMN = MANCODE.ROMN;
pub const MSCRP = MANCODE.SCRP;
pub const MFRAK = MANCODE.FRAK;
pub const MOPEN = MANCODE.OPEN;
pub const MSANS = MANCODE.SANS;
pub const MMONO = MANCODE.MONO;
pub const MMATH = MANCODE.MATH;
pub const MISOL = MANCODE.ISOL;
pub const MINIT = MANCODE.INIT;
pub const MTAIL = MANCODE.TAIL;
pub const MSTRCH = MANCODE.STRCH;
pub const MLOOP = MANCODE.LOOP;
pub const MOPENA = MANCODE.OPENA;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextDocument_Value = @import("../zig.zig").Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: fn(
            self: *const ITextDocument,
            pName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextDocument,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryCount: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges: fn(
            self: *const ITextDocument,
            ppStories: ?*?*ITextStoryRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSaved: fn(
            self: *const ITextDocument,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSaved: fn(
            self: *const ITextDocument,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTabStop: fn(
            self: *const ITextDocument,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTabStop: fn(
            self: *const ITextDocument,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        New: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const ITextDocument,
            pVar: *VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const ITextDocument,
            pVar: *VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range: fn(
            self: *const ITextDocument,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: fn(
            self: *const ITextDocument,
            x: i32,
            y: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetName(self: *const T, pName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetName(@ptrCast(*const ITextDocument, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSelection(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSelection(@ptrCast(*const ITextDocument, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryCount(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryRanges(self: *const T, ppStories: ?*?*ITextStoryRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryRanges(@ptrCast(*const ITextDocument, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSaved(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSaved(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetSaved(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetSaved(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetDefaultTabStop(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetDefaultTabStop(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetDefaultTabStop(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetDefaultTabStop(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_New(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).New(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Open(self: *const T, pVar: *VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Open(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Save(self: *const T, pVar: *VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Save(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Freeze(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Freeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Unfreeze(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Unfreeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_BeginEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).BeginEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_EndEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).EndEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Undo(self: *const T, Count: i32, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Undo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Redo(self: *const T, Count: i32, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Redo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Range(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Range(@ptrCast(*const ITextDocument, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_RangeFromPoint(self: *const T, x: i32, y: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextDocument, self), x, y, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextRange_Value = @import("../zig.zig").Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: fn(
            self: *const ITextRange,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextRange,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar: fn(
            self: *const ITextRange,
            pChar: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChar: fn(
            self: *const ITextRange,
            Char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITextRange,
            pcpFirst: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStart: fn(
            self: *const ITextRange,
            cpFirst: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITextRange,
            pcpLim: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnd: fn(
            self: *const ITextRange,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: fn(
            self: *const ITextRange,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const ITextRange,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara: fn(
            self: *const ITextRange,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara: fn(
            self: *const ITextRange,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryLength: fn(
            self: *const ITextRange,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryType: fn(
            self: *const ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const ITextRange,
            bStart: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const ITextRange,
            Unit: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            Index: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: fn(
            self: *const ITextRange,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InRange: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InStory: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStart: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEnd: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindText: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextStart: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextEnd: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cut: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
            Format: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPaste: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
            Format: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanEdit: fn(
            self: *const ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCase: fn(
            self: *const ITextRange,
            Type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPoint: fn(
            self: *const ITextRange,
            Type: i32,
            px: *i32,
            py: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoint: fn(
            self: *const ITextRange,
            x: i32,
            y: i32,
            Type: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const ITextRange,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedObject: fn(
            self: *const ITextRange,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetText(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetText(@ptrCast(*const ITextRange, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetText(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetText(@ptrCast(*const ITextRange, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetChar(self: *const T, pChar: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetChar(@ptrCast(*const ITextRange, self), pChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetChar(self: *const T, Char: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetChar(@ptrCast(*const ITextRange, self), Char);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetDuplicate(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFormattedText(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFormattedText(self: *const T, pRange: ?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextRange, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStart(self: *const T, pcpFirst: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStart(@ptrCast(*const ITextRange, self), pcpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetStart(self: *const T, cpFirst: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetStart(@ptrCast(*const ITextRange, self), cpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEnd(self: *const T, pcpLim: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEnd(@ptrCast(*const ITextRange, self), pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetEnd(self: *const T, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetEnd(@ptrCast(*const ITextRange, self), cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFont(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFont(@ptrCast(*const ITextRange, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFont(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFont(@ptrCast(*const ITextRange, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPara(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPara(@ptrCast(*const ITextRange, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPara(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPara(@ptrCast(*const ITextRange, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryLength(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryLength(@ptrCast(*const ITextRange, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryType(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Collapse(self: *const T, bStart: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Collapse(@ptrCast(*const ITextRange, self), bStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Expand(self: *const T, Unit: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Expand(@ptrCast(*const ITextRange, self), Unit, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetIndex(self: *const T, Unit: i32, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetIndex(@ptrCast(*const ITextRange, self), Unit, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetIndex(self: *const T, Unit: i32, Index: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetIndex(@ptrCast(*const ITextRange, self), Unit, Index, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetRange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetRange(@ptrCast(*const ITextRange, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InRange(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InRange(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InStory(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InStory(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_IsEqual(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Select(@ptrCast(*const ITextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_StartOf(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).StartOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_EndOf(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).EndOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Move(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Move(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStart(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStart(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEnd(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEnd(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindText(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindText(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextStart(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextStart(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextEnd(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextEnd(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Delete(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Delete(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Cut(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Cut(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Copy(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Copy(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Paste(self: *const T, pVar: *VARIANT, Format: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Paste(@ptrCast(*const ITextRange, self), pVar, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanPaste(self: *const T, pVar: *VARIANT, Format: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanPaste(@ptrCast(*const ITextRange, self), pVar, Format, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanEdit(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanEdit(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ChangeCase(self: *const T, Type: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ChangeCase(@ptrCast(*const ITextRange, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPoint(self: *const T, Type: i32, px: *i32, py: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPoint(@ptrCast(*const ITextRange, self), Type, px, py);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPoint(self: *const T, x: i32, y: i32, Type: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPoint(@ptrCast(*const ITextRange, self), x, y, Type, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ScrollIntoView(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRange, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEmbeddedObject(self: *const T, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEmbeddedObject(@ptrCast(*const ITextRange, self), ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextSelection_Value = @import("../zig.zig").Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: fn(
            self: *const ITextSelection,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const ITextSelection,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextSelection,
            pType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveLeft: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRight: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUp: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDown: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HomeKey: fn(
            self: *const ITextSelection,
            Unit: tomConstants,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndKey: fn(
            self: *const ITextSelection,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TypeText: fn(
            self: *const ITextSelection,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetFlags(@ptrCast(*const ITextSelection, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_SetFlags(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).SetFlags(@ptrCast(*const ITextSelection, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetType(self: *const T, pType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetType(@ptrCast(*const ITextSelection, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveLeft(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveLeft(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveRight(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveRight(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveUp(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveUp(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveDown(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveDown(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_HomeKey(self: *const T, Unit: tomConstants, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).HomeKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_EndKey(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).EndKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_TypeText(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).TypeText(@ptrCast(*const ITextSelection, self), bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextFont_Value = @import("../zig.zig").Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextFont,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextFont,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCaps: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnimation: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackColor: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBold: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmboss: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmboss: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeColor: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetForeColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHidden: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHidden: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngrave: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngrave: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItalic: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItalic: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKerning: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKerning: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageID: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLanguageID: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ITextFont,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ITextFont,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutline: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtected: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProtected: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShadow: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShadow: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSmallCaps: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSmallCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpacing: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrikeThrough: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrikeThrough: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscript: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuperscript: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSuperscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderline: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWeight: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWeight: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetDuplicate(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextFont, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetDuplicate(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextFont, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).CanChange(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_IsEqual(self: *const T, pFont: ?*ITextFont, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).IsEqual(@ptrCast(*const ITextFont, self), pFont, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_Reset(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).Reset(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStyle(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStyle(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStyle(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAllCaps(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAllCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAllCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAllCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAnimation(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAnimation(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAnimation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAnimation(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBackColor(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBackColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBackColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBackColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBold(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBold(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBold(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBold(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEmboss(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEmboss(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEmboss(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEmboss(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetForeColor(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetForeColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetForeColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetForeColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetHidden(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetHidden(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetHidden(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetHidden(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEngrave(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEngrave(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEngrave(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEngrave(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetItalic(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetItalic(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetItalic(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetItalic(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetKerning(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetKerning(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetKerning(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetKerning(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetLanguageID(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetLanguageID(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetLanguageID(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetLanguageID(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetName(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetName(@ptrCast(*const ITextFont, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetName(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetName(@ptrCast(*const ITextFont, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetOutline(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetOutline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetOutline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetOutline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetPosition(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetPosition(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetPosition(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetPosition(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetProtected(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetProtected(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetProtected(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetProtected(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetShadow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetShadow(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetShadow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetShadow(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSize(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSize(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSize(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSize(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSmallCaps(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSmallCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSmallCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSmallCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSpacing(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSpacing(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSpacing(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSpacing(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStrikeThrough(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStrikeThrough(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStrikeThrough(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStrikeThrough(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSubscript(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSubscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSubscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSubscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSuperscript(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSuperscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSuperscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSuperscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetUnderline(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetUnderline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetUnderline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetUnderline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetWeight(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetWeight(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetWeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetWeight(@ptrCast(*const ITextFont, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextPara_Value = @import("../zig.zig").Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextPara,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlignment: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHyphenation: fn(
            self: *const ITextPara,
            pValue: *tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHyphenation: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstLineIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextPara,
            pValue: *tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextPara,
            pValue: *tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeftIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacing: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacingRule: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListAlignment: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListLevelIndex: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListLevelIndex: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListStart: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListStart: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListTab: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListTab: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListType: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListType: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNoLineNumber: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoLineNumber: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageBreakBefore: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageBreakBefore: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRightIndent: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndents: fn(
            self: *const ITextPara,
            First: f32,
            Left: f32,
            Right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineSpacing: fn(
            self: *const ITextPara,
            Rule: i32,
            Spacing: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceAfter: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceAfter: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceBefore: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceBefore: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWidowControl: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWidowControl: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTabCount: fn(
            self: *const ITextPara,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: fn(
            self: *const ITextPara,
            tbPos: f32,
            tbAlign: i32,
            tbLeader: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllTabs: fn(
            self: *const ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: fn(
            self: *const ITextPara,
            tbPos: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTab: fn(
            self: *const ITextPara,
            iTab: i32,
            ptbPos: *f32,
            ptbAlign: *i32,
            ptbLeader: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetDuplicate(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextPara, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetDuplicate(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextPara, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).CanChange(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_IsEqual(self: *const T, pPara: ?*ITextPara, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).IsEqual(@ptrCast(*const ITextPara, self), pPara, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).Reset(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetStyle(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetStyle(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetStyle(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetHyphenation(self: *const T, pValue: *tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetHyphenation(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetHyphenation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetHyphenation(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetFirstLineIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetFirstLineIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepTogether(self: *const T, pValue: *tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepWithNext(self: *const T, pValue: *tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLeftIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLeftIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacing(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacing(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacingRule(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacingRule(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListLevelIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListLevelIndex(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListLevelIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListLevelIndex(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListStart(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListStart(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListStart(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListTab(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListTab(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListTab(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListTab(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListType(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListType(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetNoLineNumber(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetNoLineNumber(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetNoLineNumber(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetNoLineNumber(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetPageBreakBefore(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetPageBreakBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetPageBreakBefore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetPageBreakBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetRightIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetRightIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetRightIndent(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetRightIndent(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetIndents(self: *const T, First: f32, Left: f32, Right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetIndents(@ptrCast(*const ITextPara, self), First, Left, Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetLineSpacing(self: *const T, Rule: i32, Spacing: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetLineSpacing(@ptrCast(*const ITextPara, self), Rule, Spacing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceAfter(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceAfter(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceAfter(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceAfter(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceBefore(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceBefore(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetWidowControl(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetWidowControl(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetWidowControl(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetWidowControl(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTabCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTabCount(@ptrCast(*const ITextPara, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_AddTab(self: *const T, tbPos: f32, tbAlign: i32, tbLeader: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).AddTab(@ptrCast(*const ITextPara, self), tbPos, tbAlign, tbLeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_ClearAllTabs(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).ClearAllTabs(@ptrCast(*const ITextPara, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_DeleteTab(self: *const T, tbPos: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).DeleteTab(@ptrCast(*const ITextPara, self), tbPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTab(self: *const T, iTab: i32, ptbPos: *f32, ptbAlign: *i32, ptbLeader: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTab(@ptrCast(*const ITextPara, self), iTab, ptbPos, ptbAlign, ptbLeader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextStoryRanges_Value = @import("../zig.zig").Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: fn(
            self: *const ITextStoryRanges,
            ppunkEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const ITextStoryRanges,
            Index: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStoryRanges,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges__NewEnum(self: *const T, ppunkEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable)._NewEnum(@ptrCast(*const ITextStoryRanges, self), ppunkEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).Item(@ptrCast(*const ITextStoryRanges, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).GetCount(@ptrCast(*const ITextStoryRanges, self), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDocument2_Value = @import("../zig.zig").Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplays: fn(
            self: *const ITextDocument2,
            ppDisplays: ?*?*ITextDisplays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentFont: fn(
            self: *const ITextDocument2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPara: fn(
            self: *const ITextDocument2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEastAsianFlags: fn(
            self: *const ITextDocument2,
            pFlags: *tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerator: fn(
            self: *const ITextDocument2,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIMEInProgress: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2,
            ppSel: ?*?*ITextSelection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges2: fn(
            self: *const ITextDocument2,
            ppStories: ?*?*ITextStoryRanges2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypographyOptions: fn(
            self: *const ITextDocument2,
            pOptions: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2,
            pHwnd: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMsgFilter: fn(
            self: *const ITextDocument2,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2,
            cch: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2,
            Type: tomConstants,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2,
            pContext: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2,
            cp: i32,
            CharRep: i32,
            Options: i32,
            curCharRep: i32,
            curFontSize: i32,
            pbstr: ?*BSTR,
            pPitchAndFamily: *i32,
            pNewFontSize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrings: fn(
            self: *const ITextDocument2,
            ppStrs: ?*?*ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range2: fn(
            self: *const ITextDocument2,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint2: fn(
            self: *const ITextDocument2,
            x: i32,
            y: i32,
            Type: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypographyOptions: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathProperties: fn(
            self: *const ITextDocument2,
            pOptions: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathProperties: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveStory: fn(
            self: *const ITextDocument2,
            pStory: ?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStory: fn(
            self: *const ITextDocument2,
            Index: i32,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCaretType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetCaretType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDisplays(self: *const T, ppDisplays: ?*?*ITextDisplays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDisplays(@ptrCast(*const ITextDocument2, self), ppDisplays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentFont(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentFont(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentFont(@ptrCast(*const ITextDocument2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentPara(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentPara(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentPara(@ptrCast(*const ITextDocument2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEastAsianFlags(self: *const T, pFlags: *tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEastAsianFlags(@ptrCast(*const ITextDocument2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetGenerator(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetGenerator(@ptrCast(*const ITextDocument2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetIMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetIMEInProgress(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNotificationMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetNotificationMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStoryRanges2(self: *const T, ppStories: ?*?*ITextStoryRanges2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStoryRanges2(@ptrCast(*const ITextDocument2, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetTypographyOptions(self: *const T, pOptions: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetTypographyOptions(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetVersion(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetVersion(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetWindow(self: *const T, pHwnd: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_CheckTextLimit(self: *const T, cch: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetClientRect(self: *const T, Type: tomConstants, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEffectColor(self: *const T, Index: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetImmContext(self: *const T, pContext: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Options: i32, curCharRep: i32, curFontSize: i32, pbstr: ?*BSTR, pPitchAndFamily: *i32, pNewFontSize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2, self), cp, CharRep, Options, curCharRep, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextDocument2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStrings(self: *const T, ppStrs: ?*?*ITextStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStrings(@ptrCast(*const ITextDocument2, self), ppStrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Range2(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Range2(@ptrCast(*const ITextDocument2, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_RangeFromPoint2(self: *const T, x: i32, y: i32, Type: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).RangeFromPoint2(@ptrCast(*const ITextDocument2, self), x, y, Type, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2, self), pVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetEffectColor(self: *const T, Index: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextDocument2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetTypographyOptions(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetTypographyOptions(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Update(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMathProperties(self: *const T, pOptions: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMathProperties(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetMathProperties(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetMathProperties(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetActiveStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetActiveStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetActiveStory(self: *const T, pStory: ?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetActiveStory(@ptrCast(*const ITextDocument2, self), pStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMainStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMainStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNewStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNewStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStory(self: *const T, Index: i32, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStory(@ptrCast(*const ITextDocument2, self), Index, ppStory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRange2_Value = @import("../zig.zig").Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: fn(
            self: *const ITextRange2,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCells: fn(
            self: *const ITextRange2,
            ppCells: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: fn(
            self: *const ITextRange2,
            ppColumn: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextRange2,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont2: fn(
            self: *const ITextRange2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont2: fn(
            self: *const ITextRange2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText2: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const ITextRange2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const ITextRange2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara2: fn(
            self: *const ITextRange2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara2: fn(
            self: *const ITextRange2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRow: fn(
            self: *const ITextRange2,
            ppRow: ?*?*ITextRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartPara: fn(
            self: *const ITextRange2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const ITextRange2,
            ppTable: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const ITextRange2,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURL: fn(
            self: *const ITextRange2,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubrange: fn(
            self: *const ITextRange2,
            cp1: i32,
            cp2: i32,
            Activate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpMath: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubrange: fn(
            self: *const ITextRange2,
            cpFirst: i32,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
            Count: i32,
            Flags: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar2: fn(
            self: *const ITextRange2,
            pChar: *i32,
            Offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropCap: fn(
            self: *const ITextRange2,
            pcLine: *i32,
            pPosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInlineObject: fn(
            self: *const ITextRange2,
            pType: *i32,
            pAlign: *i32,
            pChar: *i32,
            pChar1: *i32,
            pChar2: *i32,
            pCount: *i32,
            pTeXStyle: *i32,
            pcCol: *i32,
            pLevel: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: fn(
            self: *const ITextRange2,
            Type: i32,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
            pHit: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubrange: fn(
            self: *const ITextRange2,
            iSubrange: i32,
            pcpFirst: *i32,
            pcpLim: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HexToUnicode: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTable: fn(
            self: *const ITextRange2,
            cCol: i32,
            cRow: i32,
            AutoFit: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Linearize: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveSubrange: fn(
            self: *const ITextRange2,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDropCap: fn(
            self: *const ITextRange2,
            cLine: i32,
            Position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnicodeToHex: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInlineObject: fn(
            self: *const ITextRange2,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathFunctionType: fn(
            self: *const ITextRange2,
            bstr: BSTR,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertImage: fn(
            self: *const ITextRange2,
            width: i32,
            height: i32,
            ascent: i32,
            Type: TEXT_ALIGN_OPTIONS,
            bstrAltText: BSTR,
            pStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextSelection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCch(self: *const T, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCch(@ptrCast(*const ITextRange2, self), pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCells(self: *const T, ppCells: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCells(@ptrCast(*const ITextRange2, self), ppCells);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetColumn(self: *const T, ppColumn: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetColumn(@ptrCast(*const ITextRange2, self), ppColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCount(@ptrCast(*const ITextRange2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDuplicate2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFont2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFont2(@ptrCast(*const ITextRange2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFont2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFont2(@ptrCast(*const ITextRange2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFormattedText2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFormattedText2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFormattedText2(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFormattedText2(@ptrCast(*const ITextRange2, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetGravity(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetGravity(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetGravity(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetGravity(@ptrCast(*const ITextRange2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetPara2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetPara2(@ptrCast(*const ITextRange2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetPara2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetPara2(@ptrCast(*const ITextRange2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRow(self: *const T, ppRow: ?*?*ITextRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRow(@ptrCast(*const ITextRange2, self), ppRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetStartPara(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetStartPara(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetTable(self: *const T, ppTable: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetTable(@ptrCast(*const ITextRange2, self), ppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetURL(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetURL(@ptrCast(*const ITextRange2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetURL(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetURL(@ptrCast(*const ITextRange2, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_AddSubrange(self: *const T, cp1: i32, cp2: i32, Activate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).AddSubrange(@ptrCast(*const ITextRange2, self), cp1, cp2, Activate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_BuildUpMath(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).BuildUpMath(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_DeleteSubrange(self: *const T, cpFirst: i32, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).DeleteSubrange(@ptrCast(*const ITextRange2, self), cpFirst, cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Find(self: *const T, pRange: ?*ITextRange2, Count: i32, Flags: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Find(@ptrCast(*const ITextRange2, self), pRange, Count, Flags, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetChar2(self: *const T, pChar: *i32, Offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetChar2(@ptrCast(*const ITextRange2, self), pChar, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDropCap(self: *const T, pcLine: *i32, pPosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDropCap(@ptrCast(*const ITextRange2, self), pcLine, pPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetInlineObject(self: *const T, pType: *i32, pAlign: *i32, pChar: *i32, pChar1: *i32, pChar2: *i32, pCount: *i32, pTeXStyle: *i32, pcCol: *i32, pLevel: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetInlineObject(@ptrCast(*const ITextRange2, self), pType, pAlign, pChar, pChar1, pChar2, pCount, pTeXStyle, pcCol, pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRange2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRect(self: *const T, Type: i32, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32, pHit: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRect(@ptrCast(*const ITextRange2, self), Type, pLeft, pTop, pRight, pBottom, pHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetSubrange(self: *const T, iSubrange: i32, pcpFirst: *i32, pcpLim: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetSubrange(@ptrCast(*const ITextRange2, self), iSubrange, pcpFirst, pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetText2(self: *const T, Flags: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetText2(@ptrCast(*const ITextRange2, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_HexToUnicode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).HexToUnicode(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertTable(self: *const T, cCol: i32, cRow: i32, AutoFit: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertTable(@ptrCast(*const ITextRange2, self), cCol, cRow, AutoFit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Linearize(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Linearize(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetActiveSubrange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetActiveSubrange(@ptrCast(*const ITextRange2, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetDropCap(self: *const T, cLine: i32, Position: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetDropCap(@ptrCast(*const ITextRange2, self), cLine, Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRange2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetText2(self: *const T, Flags: i32, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetText2(@ptrCast(*const ITextRange2, self), Flags, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_UnicodeToHex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).UnicodeToHex(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetInlineObject(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetInlineObject(@ptrCast(*const ITextRange2, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetMathFunctionType(self: *const T, bstr: BSTR, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetMathFunctionType(@ptrCast(*const ITextRange2, self), bstr, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertImage(self: *const T, width: i32, height: i32, ascent: i32, Type: TEXT_ALIGN_OPTIONS, bstrAltText: BSTR, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertImage(@ptrCast(*const ITextRange2, self), width, height, ascent, Type, bstrAltText, pStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextSelection2_Value = @import("../zig.zig").Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextFont2_Value = @import("../zig.zig").Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: fn(
            self: *const ITextFont2,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoLigatures: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutoLigatures: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceAlpha: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceAlpha: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceNumeric: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceNumeric: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceParens: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceParens: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharRep: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCharRep: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionMode: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompressionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDoubleStrike: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDoubleStrike: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextFont2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkType: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathZone: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathZone: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthPairs: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthPairs: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthSpace: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthSpace: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOldNumbers: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOldNumbers: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlapping: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlapping: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionSubSuper: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositionSubSuper: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScaling: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaling: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceExtension: fn(
            self: *const ITextFont2,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceExtension: fn(
            self: *const ITextFont2,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextFont2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects2: fn(
            self: *const ITextFont2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const ITextFont2,
            Index: i32,
            pType: *i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects2: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextFont.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCount(@ptrCast(*const ITextFont2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutoLigatures(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutoLigatures(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutoLigatures(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutoLigatures(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceAlpha(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceAlpha(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceAlpha(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceAlpha(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceNumeric(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceNumeric(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceNumeric(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceNumeric(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceParens(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceParens(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceParens(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceParens(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCharRep(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCharRep(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCharRep(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCharRep(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCompressionMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCompressionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCompressionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCompressionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCookie(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCookie(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCookie(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCookie(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDoubleStrike(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDoubleStrike(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDoubleStrike(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDoubleStrike(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDuplicate2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextFont2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDuplicate2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextFont2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetLinkType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetLinkType(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetMathZone(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetMathZone(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetMathZone(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetMathZone(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthPairs(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthPairs(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthPairs(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthPairs(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthSpace(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthSpace(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthSpace(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthSpace(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOldNumbers(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOldNumbers(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOldNumbers(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOldNumbers(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOverlapping(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOverlapping(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOverlapping(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOverlapping(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPositionSubSuper(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPositionSubSuper(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetPositionSubSuper(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetPositionSubSuper(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetScaling(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetScaling(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetScaling(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetScaling(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetSpaceExtension(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetSpaceExtension(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetSpaceExtension(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetSpaceExtension(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetUnderlinePositionMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetUnderlinePositionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects2(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects2(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextFont2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPropertyInfo(self: *const T, Index: i32, pType: *i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const ITextFont2, self), Index, pType, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_IsEqual2(self: *const T, pFont: ?*ITextFont2, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextFont2, self), pFont, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects2(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects2(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextFont2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextPara2_Value = @import("../zig.zig").Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: fn(
            self: *const ITextPara2,
            ppBorders: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextPara2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontAlignment: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFontAlignment: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHangingPunctuation: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHangingPunctuation: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapToGrid: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapToGrid: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextPara2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextPara2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextPara.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetBorders(self: *const T, ppBorders: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetBorders(@ptrCast(*const ITextPara2, self), ppBorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetDuplicate2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextPara2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetDuplicate2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextPara2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetFontAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetFontAlignment(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetFontAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetFontAlignment(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetHangingPunctuation(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetHangingPunctuation(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetHangingPunctuation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetHangingPunctuation(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetSnapToGrid(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetSnapToGrid(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetSnapToGrid(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetSnapToGrid(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetTrimPunctuationAtStart(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetTrimPunctuationAtStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetEffects(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextPara2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextPara2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_IsEqual2(self: *const T, pPara: ?*ITextPara2, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextPara2, self), pPara, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextPara2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextPara2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoryRanges2_Value = @import("../zig.zig").Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: fn(
            self: *const ITextStoryRanges2,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoryRanges.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges2_Item2(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges2.VTable, self.vtable).Item2(@ptrCast(*const ITextStoryRanges2, self), Index, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStory_Value = @import("../zig.zig").Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActive: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplay: fn(
            self: *const ITextStory,
            ppDisplay: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: fn(
            self: *const ITextStory,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStory,
            Flags: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStory,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStory,
            Flags: i32,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetActive(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetActive(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetActive(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetActive(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetDisplay(self: *const T, ppDisplay: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetDisplay(@ptrCast(*const ITextStory, self), ppDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetIndex(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetType(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetType(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetProperty(@ptrCast(*const ITextStory, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetRange(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetRange(@ptrCast(*const ITextStory, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetText(self: *const T, Flags: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetText(@ptrCast(*const ITextStory, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetFormattedText(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStory, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetProperty(@ptrCast(*const ITextStory, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetText(self: *const T, Flags: i32, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetText(@ptrCast(*const ITextStory, self), Flags, bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStrings_Value = @import("../zig.zig").Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const ITextStrings,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStrings,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cat2: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatTop2: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRange: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeFunction: fn(
            self: *const ITextStrings,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCch: fn(
            self: *const ITextStrings,
            iString: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertNullStr: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveBoundary: fn(
            self: *const ITextStrings,
            iString: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrefixTop: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITextStrings,
            iString: i32,
            cString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStrings,
            pRangeD: ?*ITextRange2,
            pRangeS: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpCp: fn(
            self: *const ITextStrings,
            iString: i32,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuffixTop: fn(
            self: *const ITextStrings,
            bstr: BSTR,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Swap: fn(
            self: *const ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Item(@ptrCast(*const ITextStrings, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCount(@ptrCast(*const ITextStrings, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Add(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Add(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Append(self: *const T, pRange: ?*ITextRange2, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Append(@ptrCast(*const ITextStrings, self), pRange, iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Cat2(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Cat2(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_CatTop2(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).CatTop2(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_DeleteRange(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).DeleteRange(@ptrCast(*const ITextStrings, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_EncodeFunction(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).EncodeFunction(@ptrCast(*const ITextStrings, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCch(self: *const T, iString: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCch(@ptrCast(*const ITextStrings, self), iString, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_InsertNullStr(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).InsertNullStr(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_MoveBoundary(self: *const T, iString: i32, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).MoveBoundary(@ptrCast(*const ITextStrings, self), iString, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_PrefixTop(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).PrefixTop(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Remove(self: *const T, iString: i32, cString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Remove(@ptrCast(*const ITextStrings, self), iString, cString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetFormattedText(self: *const T, pRangeD: ?*ITextRange2, pRangeS: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStrings, self), pRangeD, pRangeS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetOpCp(self: *const T, iString: i32, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetOpCp(@ptrCast(*const ITextStrings, self), iString, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SuffixTop(self: *const T, bstr: BSTR, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SuffixTop(@ptrCast(*const ITextStrings, self), bstr, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Swap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Swap(@ptrCast(*const ITextStrings, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRow_Value = @import("../zig.zig").Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCount: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCount: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCountCache: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCountCache: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellIndex: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellIndex: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMargin: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMargin: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeight: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeight: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndent: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndent: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNestLevel: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRTL: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRTL: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellAlignment: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorBack: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorBack: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorFore: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorFore: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMergeFlags: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMergeFlags: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellShading: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellShading: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellVerticalText: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellVerticalText: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellWidth: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellWidth: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderColors: fn(
            self: *const ITextRow,
            pcrLeft: *i32,
            pcrTop: *i32,
            pcrRight: *i32,
            pcrBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderWidths: fn(
            self: *const ITextRow,
            pduLeft: *i32,
            pduTop: *i32,
            pduRight: *i32,
            pduBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderColors: fn(
            self: *const ITextRow,
            crLeft: i32,
            crTop: i32,
            crRight: i32,
            crBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderWidths: fn(
            self: *const ITextRow,
            duLeft: i32,
            duTop: i32,
            duRight: i32,
            duBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: fn(
            self: *const ITextRow,
            cRow: i32,
            Flags: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: fn(
            self: *const ITextRow,
            cRow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRow,
            pRow: ?*ITextRow,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCount(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCount(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCount(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCount(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCountCache(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCountCache(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCountCache(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCountCache(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellIndex(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellIndex(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMargin(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMargin(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMargin(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMargin(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetHeight(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetHeight(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetHeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetHeight(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetIndent(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetIndent(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetIndent(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetIndent(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepTogether(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepWithNext(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetNestLevel(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetNestLevel(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetRTL(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetRTL(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetRTL(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetRTL(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorBack(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorBack(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorBack(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorBack(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorFore(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorFore(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorFore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorFore(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMergeFlags(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMergeFlags(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMergeFlags(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMergeFlags(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellShading(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellShading(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellShading(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellShading(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellVerticalText(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellVerticalText(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellVerticalText(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellVerticalText(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellWidth(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellWidth(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellWidth(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellWidth(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderColors(self: *const T, pcrLeft: *i32, pcrTop: *i32, pcrRight: *i32, pcrBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderColors(@ptrCast(*const ITextRow, self), pcrLeft, pcrTop, pcrRight, pcrBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderWidths(self: *const T, pduLeft: *i32, pduTop: *i32, pduRight: *i32, pduBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderWidths(@ptrCast(*const ITextRow, self), pduLeft, pduTop, pduRight, pduBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderColors(self: *const T, crLeft: i32, crTop: i32, crRight: i32, crBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderColors(@ptrCast(*const ITextRow, self), crLeft, crTop, crRight, crBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderWidths(self: *const T, duLeft: i32, duTop: i32, duRight: i32, duBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderWidths(@ptrCast(*const ITextRow, self), duLeft, duTop, duRight, duBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Apply(self: *const T, cRow: i32, Flags: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Apply(@ptrCast(*const ITextRow, self), cRow, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).CanChange(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRow, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Insert(self: *const T, cRow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Insert(@ptrCast(*const ITextRow, self), cRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_IsEqual(self: *const T, pRow: ?*ITextRow, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRow, self), pRow, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Reset(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRow, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDisplays_Value = @import("../zig.zig").Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = @import("../zig.zig").Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: fn(
            self: *const ITextDocument2Old,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            pcr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretType: fn(
            self: *const ITextDocument2Old,
            pCaretType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2Old,
            CaretType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2Old,
            pContext: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2Old,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2Old,
            cp: i32,
            CharRep: i32,
            Option: i32,
            CharRepCur: i32,
            curFontSize: i32,
            pbstr: ?*BSTR,
            pPitchAndFamily: *i32,
            pNewFontSize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2Old,
            pMode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2Old,
            Type: i32,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2Old,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2Old,
            phWnd: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFEFlags: fn(
            self: *const ITextDocument2Old,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2Old,
            cch: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IMEInProgress: fn(
            self: *const ITextDocument2Old,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2Old,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2Old,
            ppITextFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2Old,
            ppITextPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2Old,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2Old,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2Old, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetEffectColor(self: *const T, Index: i32, cr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, cr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetEffectColor(self: *const T, Index: i32, pcr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, pcr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCaretType(self: *const T, pCaretType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2Old, self), pCaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetCaretType(self: *const T, CaretType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2Old, self), CaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetImmContext(self: *const T, pContext: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2Old, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2Old, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Option: i32, CharRepCur: i32, curFontSize: i32, pbstr: ?*BSTR, pPitchAndFamily: *i32, pNewFontSize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2Old, self), cp, CharRep, Option, CharRepCur, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetNotificationMode(self: *const T, pMode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2Old, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetNotificationMode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetClientRect(self: *const T, Type: i32, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2Old, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2Old, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetWindow(self: *const T, phWnd: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2Old, self), phWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetFEFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetFEFlags(@ptrCast(*const ITextDocument2Old, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_CheckTextLimit(self: *const T, cch: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2Old, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_IMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).IMEInProgress(@ptrCast(*const ITextDocument2Old, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Update(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2Old, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentFont(self: *const T, ppITextFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2Old, self), ppITextFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentPara(self: *const T, ppITextPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2Old, self), ppITextPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2Old, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2Old, self), pVoid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: *IOleObject,
    pstg: *IStorage,
    polesite: *IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: REOBJECT_FLAGS,
    dwUser: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOle_Value = @import("../zig.zig").Guid.initString("00020d00-0000-0000-c000-000000000046");
pub const IID_IRichEditOle = &IID_IRichEditOle_Value;
pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: fn(
            self: *const IRichEditOle,
            lplpolesite: **IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetLinkCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpreobject: *REOBJECT,
            dwFlags: RICH_EDIT_GET_OBJECT_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertObject: fn(
            self: *const IRichEditOle,
            lpreobject: *REOBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            rclsidNew: *const Guid,
            lpstrUserTypeNew: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAs: fn(
            self: *const IRichEditOle,
            rclsid: *const Guid,
            rclsidAs: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: fn(
            self: *const IRichEditOle,
            lpstrContainerApp: [*:0]const u8,
            lpstrContainerObj: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkAvailable: fn(
            self: *const IRichEditOle,
            iob: i32,
            fAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDvaspect: fn(
            self: *const IRichEditOle,
            iob: i32,
            dvaspect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: fn(
            self: *const IRichEditOle,
            iob: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpstg: *IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPlaceDeactivate: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOle,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOle,
            lpchrg: *CHARRANGE,
            reco: u32,
            lplpdataobj: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportDataObject: fn(
            self: *const IRichEditOle,
            lpdataobj: *IDataObject,
            cf: u16,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClientSite(self: *const T, lplpolesite: **IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClientSite(@ptrCast(*const IRichEditOle, self), lplpolesite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObjectCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObjectCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetLinkCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetLinkCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObject(self: *const T, iob: i32, lpreobject: *REOBJECT, dwFlags: RICH_EDIT_GET_OBJECT_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObject(@ptrCast(*const IRichEditOle, self), iob, lpreobject, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InsertObject(self: *const T, lpreobject: *REOBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InsertObject(@ptrCast(*const IRichEditOle, self), lpreobject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ConvertObject(self: *const T, iob: i32, rclsidNew: *const Guid, lpstrUserTypeNew: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ConvertObject(@ptrCast(*const IRichEditOle, self), iob, rclsidNew, lpstrUserTypeNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ActivateAs(self: *const T, rclsid: *const Guid, rclsidAs: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ActivateAs(@ptrCast(*const IRichEditOle, self), rclsid, rclsidAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetHostNames(self: *const T, lpstrContainerApp: [*:0]const u8, lpstrContainerObj: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetHostNames(@ptrCast(*const IRichEditOle, self), lpstrContainerApp, lpstrContainerObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetLinkAvailable(self: *const T, iob: i32, fAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetLinkAvailable(@ptrCast(*const IRichEditOle, self), iob, fAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetDvaspect(self: *const T, iob: i32, dvaspect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetDvaspect(@ptrCast(*const IRichEditOle, self), iob, dvaspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_HandsOffStorage(self: *const T, iob: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).HandsOffStorage(@ptrCast(*const IRichEditOle, self), iob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SaveCompleted(self: *const T, iob: i32, lpstg: *IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SaveCompleted(@ptrCast(*const IRichEditOle, self), iob, lpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InPlaceDeactivate(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOle, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClipboardData(self: *const T, lpchrg: *CHARRANGE, reco: u32, lplpdataobj: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOle, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ImportDataObject(self: *const T, lpdataobj: *IDataObject, cf: u16, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ImportDataObject(@ptrCast(*const IRichEditOle, self), lpdataobj, cf, hMetaPict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOleCallback_Value = @import("../zig.zig").Guid.initString("00020d03-0000-0000-c000-000000000046");
pub const IID_IRichEditOleCallback = &IID_IRichEditOleCallback_Value;
pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: fn(
            self: *const IRichEditOleCallback,
            lplpstg: **IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceContext: fn(
            self: *const IRichEditOleCallback,
            lplpFrame: **IOleInPlaceFrame,
            lplpDoc: **IOleInPlaceUIWindow,
            lpFrameInfo: *OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContainerUI: fn(
            self: *const IRichEditOleCallback,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertObject: fn(
            self: *const IRichEditOleCallback,
            lpclsid: *Guid,
            lpstg: *IStorage,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteObject: fn(
            self: *const IRichEditOleCallback,
            lpoleobj: *IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAcceptData: fn(
            self: *const IRichEditOleCallback,
            lpdataobj: *IDataObject,
            lpcfFormat: *u16,
            reco: u32,
            fReally: BOOL,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOleCallback,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOleCallback,
            lpchrg: *CHARRANGE,
            reco: u32,
            lplpdataobj: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragDropEffect: fn(
            self: *const IRichEditOleCallback,
            fDrag: BOOL,
            grfKeyState: u32,
            pdwEffect: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextMenu: fn(
            self: *const IRichEditOleCallback,
            seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
            lpoleobj: *IOleObject,
            lpchrg: *CHARRANGE,
            lphmenu: *HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetNewStorage(self: *const T, lplpstg: **IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetNewStorage(@ptrCast(*const IRichEditOleCallback, self), lplpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetInPlaceContext(self: *const T, lplpFrame: **IOleInPlaceFrame, lplpDoc: **IOleInPlaceUIWindow, lpFrameInfo: *OIFI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetInPlaceContext(@ptrCast(*const IRichEditOleCallback, self), lplpFrame, lplpDoc, lpFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ShowContainerUI(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ShowContainerUI(@ptrCast(*const IRichEditOleCallback, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryInsertObject(self: *const T, lpclsid: *Guid, lpstg: *IStorage, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryInsertObject(@ptrCast(*const IRichEditOleCallback, self), lpclsid, lpstg, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_DeleteObject(self: *const T, lpoleobj: *IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).DeleteObject(@ptrCast(*const IRichEditOleCallback, self), lpoleobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryAcceptData(self: *const T, lpdataobj: *IDataObject, lpcfFormat: *u16, reco: u32, fReally: BOOL, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryAcceptData(@ptrCast(*const IRichEditOleCallback, self), lpdataobj, lpcfFormat, reco, fReally, hMetaPict);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOleCallback, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetClipboardData(self: *const T, lpchrg: *CHARRANGE, reco: u32, lplpdataobj: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOleCallback, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetDragDropEffect(self: *const T, fDrag: BOOL, grfKeyState: u32, pdwEffect: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetDragDropEffect(@ptrCast(*const IRichEditOleCallback, self), fDrag, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetContextMenu(self: *const T, seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, lpoleobj: *IOleObject, lpchrg: *CHARRANGE, lphmenu: *HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetContextMenu(@ptrCast(*const IRichEditOleCallback, self), seltype, lpoleobj, lpchrg, lphmenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TXTBACKSTYLE = extern enum(i32) {
    TRANSPARENT = 0,
    OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.OPAQUE;

pub const TXTHITRESULT = extern enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = extern enum(i32) {
    FITTOCONTENT2 = 0,
    FITTOCONTENT = 1,
    ROUNDTOLINE = 2,
    FITTOCONTENT3 = 3,
    FITTOCONTENTWSP = 4,
    INCLUDELASTLINE = 1073741824,
    EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.EMU;

pub const TXTVIEW = extern enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = extern enum(i32) {
    GENERIC = 0,
    TEXTCHANGED = 1,
    NEWUNDO = 2,
    NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: CHANGETYPE,
    pvCookieData: *c_void,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: fn(
            self: *const ITextServices,
            msg: u32,
            wparam: WPARAM,
            lparam: LPARAM,
            plresult: *LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDraw: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcBounds: *RECTL,
            lprcWBounds: *RECTL,
            lprcUpdate: *RECT,
            pfnContinue: isize,
            dwContinue: u32,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHScroll: fn(
            self: *const ITextServices,
            plMin: *i32,
            plMax: *i32,
            plPos: *i32,
            plPage: *i32,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetVScroll: fn(
            self: *const ITextServices,
            plMin: *i32,
            plMax: *i32,
            plPos: *i32,
            plPage: *i32,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxSetCursor: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcClient: *RECT,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxQueryHitPoint: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcClient: *RECT,
            x: i32,
            y: i32,
            pHitResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceActivate: fn(
            self: *const ITextServices,
            prcClient: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIActivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetText: fn(
            self: *const ITextServices,
            pbstrText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetText: fn(
            self: *const ITextServices,
            pszText: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCurTargetX: fn(
            self: *const ITextServices,
            param0: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetBaseLinePos: fn(
            self: *const ITextServices,
            param0: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetNaturalSize: fn(
            self: *const ITextServices,
            dwAspect: u32,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            ptd: *DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: *const SIZE,
            pwidth: *i32,
            pheight: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetDropTarget: fn(
            self: *const ITextServices,
            ppDropTarget: **IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxPropertyBitsChange: fn(
            self: *const ITextServices,
            dwMask: u32,
            dwBits: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCachedSize: fn(
            self: *const ITextServices,
            pdwWidth: *u32,
            pdwHeight: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSendMessage(self: *const T, msg: u32, wparam: WPARAM, lparam: LPARAM, plresult: *LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSendMessage(@ptrCast(*const ITextServices, self), msg, wparam, lparam, plresult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxDraw(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcBounds: *RECTL, lprcWBounds: *RECTL, lprcUpdate: *RECT, pfnContinue: isize, dwContinue: u32, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxDraw(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate, pfnContinue, dwContinue, lViewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetHScroll(self: *const T, plMin: *i32, plMax: *i32, plPos: *i32, plPage: *i32, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetHScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetVScroll(self: *const T, plMin: *i32, plMax: *i32, plPos: *i32, plPage: *i32, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetVScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxSetCursor(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcClient: *RECT, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxSetCursor(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxQueryHitPoint(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcClient: *RECT, x: i32, y: i32, pHitResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxQueryHitPoint(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceActivate(self: *const T, prcClient: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceActivate(@ptrCast(*const ITextServices, self), prcClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIActivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetText(self: *const T, pbstrText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetText(@ptrCast(*const ITextServices, self), pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSetText(self: *const T, pszText: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSetText(@ptrCast(*const ITextServices, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCurTargetX(self: *const T, param0: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCurTargetX(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetBaseLinePos(self: *const T, param0: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetBaseLinePos(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetNaturalSize(self: *const T, dwAspect: u32, hdcDraw: HDC, hicTargetDev: HDC, ptd: *DVTARGETDEVICE, dwMode: u32, psizelExtent: *const SIZE, pwidth: *i32, pheight: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetNaturalSize(@ptrCast(*const ITextServices, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetDropTarget(self: *const T, ppDropTarget: **IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetDropTarget(@ptrCast(*const ITextServices, self), ppDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxPropertyBitsChange(self: *const T, dwMask: u32, dwBits: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxPropertyBitsChange(@ptrCast(*const ITextServices, self), dwMask, dwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCachedSize(self: *const T, pdwWidth: *u32, pdwHeight: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCachedSize(@ptrCast(*const ITextServices, self), pdwWidth, pdwHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = extern enum(i32) {
    NONE = 0,
    CUSTOM = 1,
    RTL = 2,
    ITALIC = 32,
    NULL = 64,
    ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CUSTOM;
pub const CARET_RTL = CARET_FLAGS.RTL;
pub const CARET_ITALIC = CARET_FLAGS.ITALIC;
pub const CARET_NULL = CARET_FLAGS.NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.ROTATE90;

pub const CARET_INFO = extern union {
    hbitmap: HBITMAP,
    caretFlags: CARET_FLAGS,
};

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) HDC,
        TxReleaseDC: fn(
            self: *const ITextHost,
            hdc: HDC,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        TxShowScrollBar: fn(
            self: *const ITextHost,
            fnBar: i32,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxEnableScrollBar: fn(
            self: *const ITextHost,
            fuSBFlags: SCROLLBAR_CONSTANTS,
            fuArrowflags: ENABLE_SCROLL_BAR_ARROWS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollRange: fn(
            self: *const ITextHost,
            fnBar: i32,
            nMinPos: i32,
            nMaxPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollPos: fn(
            self: *const ITextHost,
            fnBar: i32,
            nPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxInvalidateRect: fn(
            self: *const ITextHost,
            prc: *RECT,
            fMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxViewChange: fn(
            self: *const ITextHost,
            fUpdate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxCreateCaret: fn(
            self: *const ITextHost,
            hbmp: HBITMAP,
            xWidth: i32,
            yHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxShowCaret: fn(
            self: *const ITextHost,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetCaretPos: fn(
            self: *const ITextHost,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
            uTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxKillTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScrollWindowEx: fn(
            self: *const ITextHost,
            dx: i32,
            dy: i32,
            lprcScroll: *RECT,
            lprcClip: *RECT,
            hrgnUpdate: HRGN,
            lprcUpdate: *RECT,
            fuScroll: SHOW_WINDOW_CMD,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCapture: fn(
            self: *const ITextHost,
            fCapture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetFocus: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCursor: fn(
            self: *const ITextHost,
            hcur: HCURSOR,
            fText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScreenToClient: fn(
            self: *const ITextHost,
            lppt: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxClientToScreen: fn(
            self: *const ITextHost,
            lppt: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxActivate: fn(
            self: *const ITextHost,
            plOldState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDeactivate: fn(
            self: *const ITextHost,
            lNewState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetClientRect: fn(
            self: *const ITextHost,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetViewInset: fn(
            self: *const ITextHost,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCharFormat: fn(
            self: *const ITextHost,
            ppCF: *const *const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetParaFormat: fn(
            self: *const ITextHost,
            ppPF: *const *const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetSysColor: fn(
            self: *const ITextHost,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        TxGetBackStyle: fn(
            self: *const ITextHost,
            pstyle: *TXTBACKSTYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetMaxLength: fn(
            self: *const ITextHost,
            plength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetScrollBars: fn(
            self: *const ITextHost,
            pdwScrollBar: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPasswordChar: fn(
            self: *const ITextHost,
            pch: *i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetAcceleratorPos: fn(
            self: *const ITextHost,
            pcp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetExtent: fn(
            self: *const ITextHost,
            lpExtent: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxCharFormatChange: fn(
            self: *const ITextHost,
            pCF: *const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxParaFormatChange: fn(
            self: *const ITextHost,
            pPF: *const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPropertyBits: fn(
            self: *const ITextHost,
            dwMask: u32,
            pdwBits: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxNotify: fn(
            self: *const ITextHost,
            iNotify: u32,
            pv: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxImmGetContext: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) HIMC,
        TxImmReleaseContext: fn(
            self: *const ITextHost,
            himc: HIMC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetSelectionBarWidth: fn(
            self: *const ITextHost,
            lSelBarWidth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetDC(self: *const T) callconv(.Inline) HDC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetDC(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxReleaseDC(self: *const T, hdc: HDC) callconv(.Inline) i32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxReleaseDC(@ptrCast(*const ITextHost, self), hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowScrollBar(self: *const T, fnBar: i32, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowScrollBar(@ptrCast(*const ITextHost, self), fnBar, fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxEnableScrollBar(self: *const T, fuSBFlags: SCROLLBAR_CONSTANTS, fuArrowflags: ENABLE_SCROLL_BAR_ARROWS) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxEnableScrollBar(@ptrCast(*const ITextHost, self), fuSBFlags, fuArrowflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollRange(self: *const T, fnBar: i32, nMinPos: i32, nMaxPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollRange(@ptrCast(*const ITextHost, self), fnBar, nMinPos, nMaxPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollPos(self: *const T, fnBar: i32, nPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollPos(@ptrCast(*const ITextHost, self), fnBar, nPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxInvalidateRect(self: *const T, prc: *RECT, fMode: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxInvalidateRect(@ptrCast(*const ITextHost, self), prc, fMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxViewChange(self: *const T, fUpdate: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxViewChange(@ptrCast(*const ITextHost, self), fUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxCreateCaret(self: *const T, hbmp: HBITMAP, xWidth: i32, yHeight: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxCreateCaret(@ptrCast(*const ITextHost, self), hbmp, xWidth, yHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowCaret(self: *const T, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowCaret(@ptrCast(*const ITextHost, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCaretPos(self: *const T, x: i32, y: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCaretPos(@ptrCast(*const ITextHost, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetTimer(self: *const T, idTimer: u32, uTimeout: u32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetTimer(@ptrCast(*const ITextHost, self), idTimer, uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxKillTimer(self: *const T, idTimer: u32) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxKillTimer(@ptrCast(*const ITextHost, self), idTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScrollWindowEx(self: *const T, dx: i32, dy: i32, lprcScroll: *RECT, lprcClip: *RECT, hrgnUpdate: HRGN, lprcUpdate: *RECT, fuScroll: SHOW_WINDOW_CMD) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScrollWindowEx(@ptrCast(*const ITextHost, self), dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCapture(self: *const T, fCapture: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCapture(@ptrCast(*const ITextHost, self), fCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetFocus(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetFocus(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCursor(self: *const T, hcur: HCURSOR, fText: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCursor(@ptrCast(*const ITextHost, self), hcur, fText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScreenToClient(self: *const T, lppt: *POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScreenToClient(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxClientToScreen(self: *const T, lppt: *POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxClientToScreen(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxActivate(self: *const T, plOldState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxActivate(@ptrCast(*const ITextHost, self), plOldState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxDeactivate(self: *const T, lNewState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxDeactivate(@ptrCast(*const ITextHost, self), lNewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetClientRect(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetClientRect(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetViewInset(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetViewInset(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetCharFormat(self: *const T, ppCF: *const *const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetCharFormat(@ptrCast(*const ITextHost, self), ppCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetParaFormat(self: *const T, ppPF: *const *const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetParaFormat(@ptrCast(*const ITextHost, self), ppPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSysColor(self: *const T, nIndex: i32) callconv(.Inline) u32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSysColor(@ptrCast(*const ITextHost, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetBackStyle(self: *const T, pstyle: *TXTBACKSTYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetBackStyle(@ptrCast(*const ITextHost, self), pstyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetMaxLength(self: *const T, plength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetMaxLength(@ptrCast(*const ITextHost, self), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetScrollBars(self: *const T, pdwScrollBar: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetScrollBars(@ptrCast(*const ITextHost, self), pdwScrollBar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPasswordChar(self: *const T, pch: *i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPasswordChar(@ptrCast(*const ITextHost, self), pch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetAcceleratorPos(self: *const T, pcp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetAcceleratorPos(@ptrCast(*const ITextHost, self), pcp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetExtent(self: *const T, lpExtent: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetExtent(@ptrCast(*const ITextHost, self), lpExtent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxCharFormatChange(self: *const T, pCF: *const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxCharFormatChange(@ptrCast(*const ITextHost, self), pCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxParaFormatChange(self: *const T, pPF: *const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxParaFormatChange(@ptrCast(*const ITextHost, self), pPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPropertyBits(self: *const T, dwMask: u32, pdwBits: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPropertyBits(@ptrCast(*const ITextHost, self), dwMask, pdwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxNotify(self: *const T, iNotify: u32, pv: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxNotify(@ptrCast(*const ITextHost, self), iNotify, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmGetContext(self: *const T) callconv(.Inline) HIMC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmGetContext(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmReleaseContext(self: *const T, himc: HIMC) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmReleaseContext(@ptrCast(*const ITextHost, self), himc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSelectionBarWidth(self: *const T, lSelBarWidth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSelectionBarWidth(@ptrCast(*const ITextHost, self), lSelBarWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditWindowlessAccessibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: fn(
            self: *const IRicheditWindowlessAccessibility,
            pSite: *IRawElementProviderWindowlessSite,
            ppProvider: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditWindowlessAccessibility_CreateProvider(self: *const T, pSite: *IRawElementProviderWindowlessSite, ppProvider: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditWindowlessAccessibility.VTable, self.vtable).CreateProvider(@ptrCast(*const IRicheditWindowlessAccessibility, self), pSite, ppProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRichEditUiaInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoundaryRectangle: fn(
            self: *const IRichEditUiaInformation,
            pUiaRect: *UiaRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVisible: fn(
            self: *const IRichEditUiaInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_GetBoundaryRectangle(self: *const T, pUiaRect: *UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).GetBoundaryRectangle(@ptrCast(*const IRichEditUiaInformation, self), pUiaRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_IsVisible(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).IsVisible(@ptrCast(*const IRichEditUiaInformation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: fn(
            self: *const IRicheditUiaOverrides,
            propertyId: i32,
            pRetValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditUiaOverrides_GetPropertyOverrideValue(self: *const T, propertyId: i32, pRetValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditUiaOverrides.VTable, self.vtable).GetPropertyOverrideValue(@ptrCast(*const IRicheditUiaOverrides, self), propertyId, pRetValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = fn(
    punkOuter: *IUnknown,
    pITextHost: *ITextHost,
    ppUnk: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PShutdownTextServices = fn(
    pTextServices: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxGetWindow: fn(
            self: *const ITextHost2,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetForegroundWindow: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPalette: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HPALETTE,
        TxGetEastAsianFlags: fn(
            self: *const ITextHost2,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetCursor2: fn(
            self: *const ITextHost2,
            hcur: HCURSOR,
            bText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HCURSOR,
        TxFreeTextServicesNotification: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetEditStyle: fn(
            self: *const ITextHost2,
            dwItem: u32,
            pdwData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetWindowStyles: fn(
            self: *const ITextHost2,
            pdwStyle: *u32,
            pdwExStyle: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxShowDropCaret: fn(
            self: *const ITextHost2,
            fShow: BOOL,
            hdc: HDC,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDestroyCaret: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHorzExtent: fn(
            self: *const ITextHost2,
            plHorzExtent: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxIsDoubleClickPending(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxIsDoubleClickPending(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindow(self: *const T, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindow(@ptrCast(*const ITextHost2, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetForegroundWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetForegroundWindow(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetPalette(self: *const T) callconv(.Inline) HPALETTE {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetPalette(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEastAsianFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEastAsianFlags(@ptrCast(*const ITextHost2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetCursor2(self: *const T, hcur: HCURSOR, bText: BOOL) callconv(.Inline) HCURSOR {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetCursor2(@ptrCast(*const ITextHost2, self), hcur, bText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxFreeTextServicesNotification(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxFreeTextServicesNotification(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEditStyle(self: *const T, dwItem: u32, pdwData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEditStyle(@ptrCast(*const ITextHost2, self), dwItem, pdwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindowStyles(self: *const T, pdwStyle: *u32, pdwExStyle: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindowStyles(@ptrCast(*const ITextHost2, self), pdwStyle, pdwExStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxShowDropCaret(self: *const T, fShow: BOOL, hdc: HDC, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxShowDropCaret(@ptrCast(*const ITextHost2, self), fShow, hdc, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxDestroyCaret(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxDestroyCaret(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetHorzExtent(self: *const T, plHorzExtent: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetHorzExtent(@ptrCast(*const ITextHost2, self), plHorzExtent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: fn(
            self: *const ITextServices2,
            dwAspect: u32,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            ptd: *DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: *const SIZE,
            pwidth: *i32,
            pheight: *i32,
            pascent: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDrawD2D: fn(
            self: *const ITextServices2,
            pRenderTarget: *ID2D1RenderTarget,
            lprcBounds: *RECTL,
            lprcUpdate: *RECT,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxGetNaturalSize2(self: *const T, dwAspect: u32, hdcDraw: HDC, hicTargetDev: HDC, ptd: *DVTARGETDEVICE, dwMode: u32, psizelExtent: *const SIZE, pwidth: *i32, pheight: *i32, pascent: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxGetNaturalSize2(@ptrCast(*const ITextServices2, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight, pascent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxDrawD2D(self: *const T, pRenderTarget: *ID2D1RenderTarget, lprcBounds: *RECTL, lprcUpdate: *RECT, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxDrawD2D(@ptrCast(*const ITextServices2, self), pRenderTarget, lprcBounds, lprcUpdate, lViewId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TA_PROPERTY = extern enum(i32) {
    FLAGS = 0,
    TRANSFORMCOUNT = 1,
    STAGGERDELAY = 2,
    STAGGERDELAYCAP = 3,
    STAGGERDELAYFACTOR = 4,
    ZORDER = 5,
};
pub const TAP_FLAGS = TA_PROPERTY.FLAGS;
pub const TAP_TRANSFORMCOUNT = TA_PROPERTY.TRANSFORMCOUNT;
pub const TAP_STAGGERDELAY = TA_PROPERTY.STAGGERDELAY;
pub const TAP_STAGGERDELAYCAP = TA_PROPERTY.STAGGERDELAYCAP;
pub const TAP_STAGGERDELAYFACTOR = TA_PROPERTY.STAGGERDELAYFACTOR;
pub const TAP_ZORDER = TA_PROPERTY.ZORDER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TA_PROPERTY_FLAG = extern enum(u32) {
    NONE = 0,
    HASSTAGGER = 1,
    ISRTLAWARE = 2,
    ALLOWCOLLECTION = 4,
    HASBACKGROUND = 8,
    HASPERSPECTIVE = 16,
    _,
};
pub const TAPF_NONE = TA_PROPERTY_FLAG.NONE;
pub const TAPF_HASSTAGGER = TA_PROPERTY_FLAG.HASSTAGGER;
pub const TAPF_ISRTLAWARE = TA_PROPERTY_FLAG.ISRTLAWARE;
pub const TAPF_ALLOWCOLLECTION = TA_PROPERTY_FLAG.ALLOWCOLLECTION;
pub const TAPF_HASBACKGROUND = TA_PROPERTY_FLAG.HASBACKGROUND;
pub const TAPF_HASPERSPECTIVE = TA_PROPERTY_FLAG.HASPERSPECTIVE;

pub const TA_TRANSFORM_TYPE = extern enum(i32) {
    TRANSLATE_2D = 0,
    SCALE_2D = 1,
    OPACITY = 2,
    CLIP = 3,
};
pub const TATT_TRANSLATE_2D = TA_TRANSFORM_TYPE.TRANSLATE_2D;
pub const TATT_SCALE_2D = TA_TRANSFORM_TYPE.SCALE_2D;
pub const TATT_OPACITY = TA_TRANSFORM_TYPE.OPACITY;
pub const TATT_CLIP = TA_TRANSFORM_TYPE.CLIP;

pub const TA_TRANSFORM_FLAG = extern enum(i32) {
    NONE = 0,
    TARGETVALUES_USER = 1,
    HASINITIALVALUES = 2,
    HASORIGINVALUES = 4,
};
pub const TATF_NONE = TA_TRANSFORM_FLAG.NONE;
pub const TATF_TARGETVALUES_USER = TA_TRANSFORM_FLAG.TARGETVALUES_USER;
pub const TATF_HASINITIALVALUES = TA_TRANSFORM_FLAG.HASINITIALVALUES;
pub const TATF_HASORIGINVALUES = TA_TRANSFORM_FLAG.HASORIGINVALUES;

pub const TA_TRANSFORM = extern struct {
    eTransformType: TA_TRANSFORM_TYPE,
    dwTimingFunctionId: u32,
    dwStartTime: u32,
    dwDurationTime: u32,
    eFlags: TA_TRANSFORM_FLAG,
};

pub const TA_TRANSFORM_2D = extern struct {
    header: TA_TRANSFORM,
    rX: f32,
    rY: f32,
    rInitialX: f32,
    rInitialY: f32,
    rOriginX: f32,
    rOriginY: f32,
};

pub const TA_TRANSFORM_OPACITY = extern struct {
    header: TA_TRANSFORM,
    rOpacity: f32,
    rInitialOpacity: f32,
};

pub const TA_TRANSFORM_CLIP = extern struct {
    header: TA_TRANSFORM,
    rLeft: f32,
    rTop: f32,
    rRight: f32,
    rBottom: f32,
    rInitialLeft: f32,
    rInitialTop: f32,
    rInitialRight: f32,
    rInitialBottom: f32,
};

pub const TA_TIMINGFUNCTION_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    CUBIC_BEZIER = 1,
};
pub const TTFT_UNDEFINED = TA_TIMINGFUNCTION_TYPE.UNDEFINED;
pub const TTFT_CUBIC_BEZIER = TA_TIMINGFUNCTION_TYPE.CUBIC_BEZIER;

pub const TA_TIMINGFUNCTION = extern struct {
    eTimingFunctionType: TA_TIMINGFUNCTION_TYPE,
};

pub const TA_CUBIC_BEZIER = extern struct {
    header: TA_TIMINGFUNCTION,
    rX0: f32,
    rY0: f32,
    rX1: f32,
    rY1: f32,
};

pub const DTBGOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    rcClip: RECT,
};

pub const THEMESIZE = extern enum(i32) {
    MIN = 0,
    TRUE = 1,
    DRAW = 2,
};
pub const TS_MIN = THEMESIZE.MIN;
pub const TS_TRUE = THEMESIZE.TRUE;
pub const TS_DRAW = THEMESIZE.DRAW;

pub const MARGINS = extern struct {
    cxLeftWidth: i32,
    cxRightWidth: i32,
    cyTopHeight: i32,
    cyBottomHeight: i32,
};

pub const INTLIST = extern struct {
    iValueCount: i32,
    iValues: [402]i32,
};

pub const PROPERTYORIGIN = extern enum(i32) {
    STATE = 0,
    PART = 1,
    CLASS = 2,
    GLOBAL = 3,
    NOTFOUND = 4,
};
pub const PO_STATE = PROPERTYORIGIN.STATE;
pub const PO_PART = PROPERTYORIGIN.PART;
pub const PO_CLASS = PROPERTYORIGIN.CLASS;
pub const PO_GLOBAL = PROPERTYORIGIN.GLOBAL;
pub const PO_NOTFOUND = PROPERTYORIGIN.NOTFOUND;

pub const WINDOWTHEMEATTRIBUTETYPE = extern enum(i32) {
    T = 1,
};
pub const WTA_NONCLIENT = WINDOWTHEMEATTRIBUTETYPE.T;

pub const WTA_OPTIONS = extern struct {
    dwFlags: u32,
    dwMask: u32,
};

pub const DTT_CALLBACK_PROC = fn(
    hdc: HDC,
    pszText: [*:0]u16,
    cchText: i32,
    prc: *RECT,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DTTOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    crText: u32,
    crBorder: u32,
    crShadow: u32,
    iTextShadowType: i32,
    ptShadowOffset: POINT,
    iBorderSize: i32,
    iFontPropId: i32,
    iColorPropId: i32,
    iStateId: i32,
    fApplyOverlay: BOOL,
    iGlowSize: i32,
    pfnDrawTextCallback: DTT_CALLBACK_PROC,
    lParam: LPARAM,
};

pub const BP_BUFFERFORMAT = extern enum(i32) {
    COMPATIBLEBITMAP = 0,
    DIB = 1,
    TOPDOWNDIB = 2,
    TOPDOWNMONODIB = 3,
};
pub const BPBF_COMPATIBLEBITMAP = BP_BUFFERFORMAT.COMPATIBLEBITMAP;
pub const BPBF_DIB = BP_BUFFERFORMAT.DIB;
pub const BPBF_TOPDOWNDIB = BP_BUFFERFORMAT.TOPDOWNDIB;
pub const BPBF_TOPDOWNMONODIB = BP_BUFFERFORMAT.TOPDOWNMONODIB;

pub const BP_ANIMATIONSTYLE = extern enum(i32) {
    NONE = 0,
    LINEAR = 1,
    CUBIC = 2,
    SINE = 3,
};
pub const BPAS_NONE = BP_ANIMATIONSTYLE.NONE;
pub const BPAS_LINEAR = BP_ANIMATIONSTYLE.LINEAR;
pub const BPAS_CUBIC = BP_ANIMATIONSTYLE.CUBIC;
pub const BPAS_SINE = BP_ANIMATIONSTYLE.SINE;

pub const BP_ANIMATIONPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    style: BP_ANIMATIONSTYLE,
    dwDuration: u32,
};

pub const BP_PAINTPARAMS = extern struct {
    cbSize: u32,
    dwFlags: BP_PAINTPARAMS_FLAGS,
    prcExclude: *const RECT,
    pBlendFunction: *const BLENDFUNCTION,
};

pub const BGTYPE = extern enum(i32) {
    IMAGEFILE = 0,
    BORDERFILL = 1,
    NONE = 2,
};
pub const BT_IMAGEFILE = BGTYPE.IMAGEFILE;
pub const BT_BORDERFILL = BGTYPE.BORDERFILL;
pub const BT_NONE = BGTYPE.NONE;

pub const IMAGELAYOUT = extern enum(i32) {
    VERTICAL = 0,
    HORIZONTAL = 1,
};
pub const IL_VERTICAL = IMAGELAYOUT.VERTICAL;
pub const IL_HORIZONTAL = IMAGELAYOUT.HORIZONTAL;

pub const BORDERTYPE = extern enum(i32) {
    RECT = 0,
    ROUNDRECT = 1,
    ELLIPSE = 2,
};
pub const BT_RECT = BORDERTYPE.RECT;
pub const BT_ROUNDRECT = BORDERTYPE.ROUNDRECT;
pub const BT_ELLIPSE = BORDERTYPE.ELLIPSE;

pub const FILLTYPE = extern enum(i32) {
    SOLID = 0,
    VERTGRADIENT = 1,
    HORZGRADIENT = 2,
    RADIALGRADIENT = 3,
    TILEIMAGE = 4,
};
pub const FT_SOLID = FILLTYPE.SOLID;
pub const FT_VERTGRADIENT = FILLTYPE.VERTGRADIENT;
pub const FT_HORZGRADIENT = FILLTYPE.HORZGRADIENT;
pub const FT_RADIALGRADIENT = FILLTYPE.RADIALGRADIENT;
pub const FT_TILEIMAGE = FILLTYPE.TILEIMAGE;

pub const SIZINGTYPE = extern enum(i32) {
    TRUESIZE = 0,
    STRETCH = 1,
    TILE = 2,
};
pub const ST_TRUESIZE = SIZINGTYPE.TRUESIZE;
pub const ST_STRETCH = SIZINGTYPE.STRETCH;
pub const ST_TILE = SIZINGTYPE.TILE;

pub const HALIGN = extern enum(i32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
};
pub const HA_LEFT = HALIGN.LEFT;
pub const HA_CENTER = HALIGN.CENTER;
pub const HA_RIGHT = HALIGN.RIGHT;

pub const CONTENTALIGNMENT = extern enum(i32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
};
pub const CA_LEFT = CONTENTALIGNMENT.LEFT;
pub const CA_CENTER = CONTENTALIGNMENT.CENTER;
pub const CA_RIGHT = CONTENTALIGNMENT.RIGHT;

pub const VALIGN = extern enum(i32) {
    TOP = 0,
    CENTER = 1,
    BOTTOM = 2,
};
pub const VA_TOP = VALIGN.TOP;
pub const VA_CENTER = VALIGN.CENTER;
pub const VA_BOTTOM = VALIGN.BOTTOM;

pub const OFFSETTYPE = extern enum(i32) {
    TOPLEFT = 0,
    TOPRIGHT = 1,
    TOPMIDDLE = 2,
    BOTTOMLEFT = 3,
    BOTTOMRIGHT = 4,
    BOTTOMMIDDLE = 5,
    MIDDLELEFT = 6,
    MIDDLERIGHT = 7,
    LEFTOFCAPTION = 8,
    RIGHTOFCAPTION = 9,
    LEFTOFLASTBUTTON = 10,
    RIGHTOFLASTBUTTON = 11,
    ABOVELASTBUTTON = 12,
    BELOWLASTBUTTON = 13,
};
pub const OT_TOPLEFT = OFFSETTYPE.TOPLEFT;
pub const OT_TOPRIGHT = OFFSETTYPE.TOPRIGHT;
pub const OT_TOPMIDDLE = OFFSETTYPE.TOPMIDDLE;
pub const OT_BOTTOMLEFT = OFFSETTYPE.BOTTOMLEFT;
pub const OT_BOTTOMRIGHT = OFFSETTYPE.BOTTOMRIGHT;
pub const OT_BOTTOMMIDDLE = OFFSETTYPE.BOTTOMMIDDLE;
pub const OT_MIDDLELEFT = OFFSETTYPE.MIDDLELEFT;
pub const OT_MIDDLERIGHT = OFFSETTYPE.MIDDLERIGHT;
pub const OT_LEFTOFCAPTION = OFFSETTYPE.LEFTOFCAPTION;
pub const OT_RIGHTOFCAPTION = OFFSETTYPE.RIGHTOFCAPTION;
pub const OT_LEFTOFLASTBUTTON = OFFSETTYPE.LEFTOFLASTBUTTON;
pub const OT_RIGHTOFLASTBUTTON = OFFSETTYPE.RIGHTOFLASTBUTTON;
pub const OT_ABOVELASTBUTTON = OFFSETTYPE.ABOVELASTBUTTON;
pub const OT_BELOWLASTBUTTON = OFFSETTYPE.BELOWLASTBUTTON;

pub const ICONEFFECT = extern enum(i32) {
    NONE = 0,
    GLOW = 1,
    SHADOW = 2,
    PULSE = 3,
    ALPHA = 4,
};
pub const ICE_NONE = ICONEFFECT.NONE;
pub const ICE_GLOW = ICONEFFECT.GLOW;
pub const ICE_SHADOW = ICONEFFECT.SHADOW;
pub const ICE_PULSE = ICONEFFECT.PULSE;
pub const ICE_ALPHA = ICONEFFECT.ALPHA;

pub const TEXTSHADOWTYPE = extern enum(i32) {
    NONE = 0,
    SINGLE = 1,
    CONTINUOUS = 2,
};
pub const TST_NONE = TEXTSHADOWTYPE.NONE;
pub const TST_SINGLE = TEXTSHADOWTYPE.SINGLE;
pub const TST_CONTINUOUS = TEXTSHADOWTYPE.CONTINUOUS;

pub const GLYPHTYPE = extern enum(i32) {
    NONE = 0,
    IMAGEGLYPH = 1,
    FONTGLYPH = 2,
};
pub const GT_NONE = GLYPHTYPE.NONE;
pub const GT_IMAGEGLYPH = GLYPHTYPE.IMAGEGLYPH;
pub const GT_FONTGLYPH = GLYPHTYPE.FONTGLYPH;

pub const IMAGESELECTTYPE = extern enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const IST_NONE = IMAGESELECTTYPE.NONE;
pub const IST_SIZE = IMAGESELECTTYPE.SIZE;
pub const IST_DPI = IMAGESELECTTYPE.DPI;

pub const TRUESIZESCALINGTYPE = extern enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const TSST_NONE = TRUESIZESCALINGTYPE.NONE;
pub const TSST_SIZE = TRUESIZESCALINGTYPE.SIZE;
pub const TSST_DPI = TRUESIZESCALINGTYPE.DPI;

pub const GLYPHFONTSIZINGTYPE = extern enum(i32) {
    NONE = 0,
    SIZE = 1,
    DPI = 2,
};
pub const GFST_NONE = GLYPHFONTSIZINGTYPE.NONE;
pub const GFST_SIZE = GLYPHFONTSIZINGTYPE.SIZE;
pub const GFST_DPI = GLYPHFONTSIZINGTYPE.DPI;

pub const LINKPARTS = extern enum(i32) {
    K = 1,
};
pub const LP_HYPERLINK = LINKPARTS.K;

pub const HYPERLINKSTATES = extern enum(i32) {
    NORMALTEXT = 1,
    LINKTEXT = 2,
};
pub const HLS_NORMALTEXT = HYPERLINKSTATES.NORMALTEXT;
pub const HLS_LINKTEXT = HYPERLINKSTATES.LINKTEXT;

pub const EMPTYMARKUPPARTS = extern enum(i32) {
    T = 1,
};
pub const EMP_MARKUPTEXT = EMPTYMARKUPPARTS.T;

pub const MARKUPTEXTSTATES = extern enum(i32) {
    NORMALTEXT = 1,
    LINKTEXT = 2,
};
pub const EMT_NORMALTEXT = MARKUPTEXTSTATES.NORMALTEXT;
pub const EMT_LINKTEXT = MARKUPTEXTSTATES.LINKTEXT;

pub const STATICPARTS = extern enum(i32) {
    T = 1,
};
pub const STAT_TEXT = STATICPARTS.T;

pub const PAGEPARTS = extern enum(i32) {
    UP = 1,
    DOWN = 2,
    UPHORZ = 3,
    DOWNHORZ = 4,
};
pub const PGRP_UP = PAGEPARTS.UP;
pub const PGRP_DOWN = PAGEPARTS.DOWN;
pub const PGRP_UPHORZ = PAGEPARTS.UPHORZ;
pub const PGRP_DOWNHORZ = PAGEPARTS.DOWNHORZ;

pub const MONTHCALPARTS = extern enum(i32) {
    BACKGROUND = 1,
    BORDERS = 2,
    GRIDBACKGROUND = 3,
    COLHEADERSPLITTER = 4,
    GRIDCELLBACKGROUND = 5,
    GRIDCELL = 6,
    GRIDCELLUPPER = 7,
    TRAILINGGRIDCELL = 8,
    TRAILINGGRIDCELLUPPER = 9,
    NAVNEXT = 10,
    NAVPREV = 11,
};
pub const MC_BACKGROUND = MONTHCALPARTS.BACKGROUND;
pub const MC_BORDERS = MONTHCALPARTS.BORDERS;
pub const MC_GRIDBACKGROUND = MONTHCALPARTS.GRIDBACKGROUND;
pub const MC_COLHEADERSPLITTER = MONTHCALPARTS.COLHEADERSPLITTER;
pub const MC_GRIDCELLBACKGROUND = MONTHCALPARTS.GRIDCELLBACKGROUND;
pub const MC_GRIDCELL = MONTHCALPARTS.GRIDCELL;
pub const MC_GRIDCELLUPPER = MONTHCALPARTS.GRIDCELLUPPER;
pub const MC_TRAILINGGRIDCELL = MONTHCALPARTS.TRAILINGGRIDCELL;
pub const MC_TRAILINGGRIDCELLUPPER = MONTHCALPARTS.TRAILINGGRIDCELLUPPER;
pub const MC_NAVNEXT = MONTHCALPARTS.NAVNEXT;
pub const MC_NAVPREV = MONTHCALPARTS.NAVPREV;

pub const GRIDCELLBACKGROUNDSTATES = extern enum(i32) {
    SELECTED = 1,
    HOT = 2,
    SELECTEDHOT = 3,
    SELECTEDNOTFOCUSED = 4,
    TODAY = 5,
    TODAYSELECTED = 6,
};
pub const MCGCB_SELECTED = GRIDCELLBACKGROUNDSTATES.SELECTED;
pub const MCGCB_HOT = GRIDCELLBACKGROUNDSTATES.HOT;
pub const MCGCB_SELECTEDHOT = GRIDCELLBACKGROUNDSTATES.SELECTEDHOT;
pub const MCGCB_SELECTEDNOTFOCUSED = GRIDCELLBACKGROUNDSTATES.SELECTEDNOTFOCUSED;
pub const MCGCB_TODAY = GRIDCELLBACKGROUNDSTATES.TODAY;
pub const MCGCB_TODAYSELECTED = GRIDCELLBACKGROUNDSTATES.TODAYSELECTED;

pub const GRIDCELLSTATES = extern enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    TODAY = 4,
    TODAYSELECTED = 5,
    SELECTED = 6,
    SELECTEDHOT = 7,
};
pub const MCGC_HOT = GRIDCELLSTATES.HOT;
pub const MCGC_HASSTATE = GRIDCELLSTATES.HASSTATE;
pub const MCGC_HASSTATEHOT = GRIDCELLSTATES.HASSTATEHOT;
pub const MCGC_TODAY = GRIDCELLSTATES.TODAY;
pub const MCGC_TODAYSELECTED = GRIDCELLSTATES.TODAYSELECTED;
pub const MCGC_SELECTED = GRIDCELLSTATES.SELECTED;
pub const MCGC_SELECTEDHOT = GRIDCELLSTATES.SELECTEDHOT;

pub const GRIDCELLUPPERSTATES = extern enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    SELECTED = 4,
    SELECTEDHOT = 5,
};
pub const MCGCU_HOT = GRIDCELLUPPERSTATES.HOT;
pub const MCGCU_HASSTATE = GRIDCELLUPPERSTATES.HASSTATE;
pub const MCGCU_HASSTATEHOT = GRIDCELLUPPERSTATES.HASSTATEHOT;
pub const MCGCU_SELECTED = GRIDCELLUPPERSTATES.SELECTED;
pub const MCGCU_SELECTEDHOT = GRIDCELLUPPERSTATES.SELECTEDHOT;

pub const TRAILINGGRIDCELLSTATES = extern enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    TODAY = 4,
    TODAYSELECTED = 5,
    SELECTED = 6,
    SELECTEDHOT = 7,
};
pub const MCTGC_HOT = TRAILINGGRIDCELLSTATES.HOT;
pub const MCTGC_HASSTATE = TRAILINGGRIDCELLSTATES.HASSTATE;
pub const MCTGC_HASSTATEHOT = TRAILINGGRIDCELLSTATES.HASSTATEHOT;
pub const MCTGC_TODAY = TRAILINGGRIDCELLSTATES.TODAY;
pub const MCTGC_TODAYSELECTED = TRAILINGGRIDCELLSTATES.TODAYSELECTED;
pub const MCTGC_SELECTED = TRAILINGGRIDCELLSTATES.SELECTED;
pub const MCTGC_SELECTEDHOT = TRAILINGGRIDCELLSTATES.SELECTEDHOT;

pub const TRAILINGGRIDCELLUPPERSTATES = extern enum(i32) {
    HOT = 1,
    HASSTATE = 2,
    HASSTATEHOT = 3,
    SELECTED = 4,
    SELECTEDHOT = 5,
};
pub const MCTGCU_HOT = TRAILINGGRIDCELLUPPERSTATES.HOT;
pub const MCTGCU_HASSTATE = TRAILINGGRIDCELLUPPERSTATES.HASSTATE;
pub const MCTGCU_HASSTATEHOT = TRAILINGGRIDCELLUPPERSTATES.HASSTATEHOT;
pub const MCTGCU_SELECTED = TRAILINGGRIDCELLUPPERSTATES.SELECTED;
pub const MCTGCU_SELECTEDHOT = TRAILINGGRIDCELLUPPERSTATES.SELECTEDHOT;

pub const NAVNEXTSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
};
pub const MCNN_NORMAL = NAVNEXTSTATES.NORMAL;
pub const MCNN_HOT = NAVNEXTSTATES.HOT;
pub const MCNN_PRESSED = NAVNEXTSTATES.PRESSED;
pub const MCNN_DISABLED = NAVNEXTSTATES.DISABLED;

pub const NAVPREVSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
};
pub const MCNP_NORMAL = NAVPREVSTATES.NORMAL;
pub const MCNP_HOT = NAVPREVSTATES.HOT;
pub const MCNP_PRESSED = NAVPREVSTATES.PRESSED;
pub const MCNP_DISABLED = NAVPREVSTATES.DISABLED;

pub const CLOCKPARTS = extern enum(i32) {
    E = 1,
};
pub const CLP_TIME = CLOCKPARTS.E;

pub const CLOCKSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const CLS_NORMAL = CLOCKSTATES.NORMAL;
pub const CLS_HOT = CLOCKSTATES.HOT;
pub const CLS_PRESSED = CLOCKSTATES.PRESSED;

pub const TRAYNOTIFYPARTS = extern enum(i32) {
    BACKGROUND = 1,
    ANIMBACKGROUND = 2,
};
pub const TNP_BACKGROUND = TRAYNOTIFYPARTS.BACKGROUND;
pub const TNP_ANIMBACKGROUND = TRAYNOTIFYPARTS.ANIMBACKGROUND;

pub const TASKBARPARTS = extern enum(i32) {
    BACKGROUNDBOTTOM = 1,
    BACKGROUNDRIGHT = 2,
    BACKGROUNDTOP = 3,
    BACKGROUNDLEFT = 4,
    SIZINGBARBOTTOM = 5,
    SIZINGBARRIGHT = 6,
    SIZINGBARTOP = 7,
    SIZINGBARLEFT = 8,
};
pub const TBP_BACKGROUNDBOTTOM = TASKBARPARTS.BACKGROUNDBOTTOM;
pub const TBP_BACKGROUNDRIGHT = TASKBARPARTS.BACKGROUNDRIGHT;
pub const TBP_BACKGROUNDTOP = TASKBARPARTS.BACKGROUNDTOP;
pub const TBP_BACKGROUNDLEFT = TASKBARPARTS.BACKGROUNDLEFT;
pub const TBP_SIZINGBARBOTTOM = TASKBARPARTS.SIZINGBARBOTTOM;
pub const TBP_SIZINGBARRIGHT = TASKBARPARTS.SIZINGBARRIGHT;
pub const TBP_SIZINGBARTOP = TASKBARPARTS.SIZINGBARTOP;
pub const TBP_SIZINGBARLEFT = TASKBARPARTS.SIZINGBARLEFT;

pub const TASKBANDPARTS = extern enum(i32) {
    GROUPCOUNT = 1,
    FLASHBUTTON = 2,
    FLASHBUTTONGROUPMENU = 3,
};
pub const TDP_GROUPCOUNT = TASKBANDPARTS.GROUPCOUNT;
pub const TDP_FLASHBUTTON = TASKBANDPARTS.FLASHBUTTON;
pub const TDP_FLASHBUTTONGROUPMENU = TASKBANDPARTS.FLASHBUTTONGROUPMENU;

pub const STARTPANELPARTS = extern enum(i32) {
    USERPANE = 1,
    MOREPROGRAMS = 2,
    MOREPROGRAMSARROW = 3,
    PROGLIST = 4,
    PROGLISTSEPARATOR = 5,
    PLACESLIST = 6,
    PLACESLISTSEPARATOR = 7,
    LOGOFF = 8,
    LOGOFFBUTTONS = 9,
    USERPICTURE = 10,
    PREVIEW = 11,
    MOREPROGRAMSTAB = 12,
    NSCHOST = 13,
    SOFTWAREEXPLORER = 14,
    OPENBOX = 15,
    SEARCHVIEW = 16,
    MOREPROGRAMSARROWBACK = 17,
    TOPMATCH = 18,
    LOGOFFSPLITBUTTONDROPDOWN = 19,
};
pub const SPP_USERPANE = STARTPANELPARTS.USERPANE;
pub const SPP_MOREPROGRAMS = STARTPANELPARTS.MOREPROGRAMS;
pub const SPP_MOREPROGRAMSARROW = STARTPANELPARTS.MOREPROGRAMSARROW;
pub const SPP_PROGLIST = STARTPANELPARTS.PROGLIST;
pub const SPP_PROGLISTSEPARATOR = STARTPANELPARTS.PROGLISTSEPARATOR;
pub const SPP_PLACESLIST = STARTPANELPARTS.PLACESLIST;
pub const SPP_PLACESLISTSEPARATOR = STARTPANELPARTS.PLACESLISTSEPARATOR;
pub const SPP_LOGOFF = STARTPANELPARTS.LOGOFF;
pub const SPP_LOGOFFBUTTONS = STARTPANELPARTS.LOGOFFBUTTONS;
pub const SPP_USERPICTURE = STARTPANELPARTS.USERPICTURE;
pub const SPP_PREVIEW = STARTPANELPARTS.PREVIEW;
pub const SPP_MOREPROGRAMSTAB = STARTPANELPARTS.MOREPROGRAMSTAB;
pub const SPP_NSCHOST = STARTPANELPARTS.NSCHOST;
pub const SPP_SOFTWAREEXPLORER = STARTPANELPARTS.SOFTWAREEXPLORER;
pub const SPP_OPENBOX = STARTPANELPARTS.OPENBOX;
pub const SPP_SEARCHVIEW = STARTPANELPARTS.SEARCHVIEW;
pub const SPP_MOREPROGRAMSARROWBACK = STARTPANELPARTS.MOREPROGRAMSARROWBACK;
pub const SPP_TOPMATCH = STARTPANELPARTS.TOPMATCH;
pub const SPP_LOGOFFSPLITBUTTONDROPDOWN = STARTPANELPARTS.LOGOFFSPLITBUTTONDROPDOWN;

pub const MOREPROGRAMSTABSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPMPT_NORMAL = MOREPROGRAMSTABSTATES.NORMAL;
pub const SPMPT_HOT = MOREPROGRAMSTABSTATES.HOT;
pub const SPMPT_SELECTED = MOREPROGRAMSTABSTATES.SELECTED;
pub const SPMPT_DISABLED = MOREPROGRAMSTABSTATES.DISABLED;
pub const SPMPT_FOCUSED = MOREPROGRAMSTABSTATES.FOCUSED;

pub const SOFTWAREEXPLORERSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPSE_NORMAL = SOFTWAREEXPLORERSTATES.NORMAL;
pub const SPSE_HOT = SOFTWAREEXPLORERSTATES.HOT;
pub const SPSE_SELECTED = SOFTWAREEXPLORERSTATES.SELECTED;
pub const SPSE_DISABLED = SOFTWAREEXPLORERSTATES.DISABLED;
pub const SPSE_FOCUSED = SOFTWAREEXPLORERSTATES.FOCUSED;

pub const OPENBOXSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    SELECTED = 3,
    DISABLED = 4,
    FOCUSED = 5,
};
pub const SPOB_NORMAL = OPENBOXSTATES.NORMAL;
pub const SPOB_HOT = OPENBOXSTATES.HOT;
pub const SPOB_SELECTED = OPENBOXSTATES.SELECTED;
pub const SPOB_DISABLED = OPENBOXSTATES.DISABLED;
pub const SPOB_FOCUSED = OPENBOXSTATES.FOCUSED;

pub const MOREPROGRAMSARROWSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPS_NORMAL = MOREPROGRAMSARROWSTATES.NORMAL;
pub const SPS_HOT = MOREPROGRAMSARROWSTATES.HOT;
pub const SPS_PRESSED = MOREPROGRAMSARROWSTATES.PRESSED;

pub const MOREPROGRAMSARROWBACKSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPSB_NORMAL = MOREPROGRAMSARROWBACKSTATES.NORMAL;
pub const SPSB_HOT = MOREPROGRAMSARROWBACKSTATES.HOT;
pub const SPSB_PRESSED = MOREPROGRAMSARROWBACKSTATES.PRESSED;

pub const LOGOFFBUTTONSSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
};
pub const SPLS_NORMAL = LOGOFFBUTTONSSTATES.NORMAL;
pub const SPLS_HOT = LOGOFFBUTTONSSTATES.HOT;
pub const SPLS_PRESSED = LOGOFFBUTTONSSTATES.PRESSED;

pub const MENUBANDPARTS = extern enum(i32) {
    NEWAPPBUTTON = 1,
    SEPERATOR = 2,
};
pub const MDP_NEWAPPBUTTON = MENUBANDPARTS.NEWAPPBUTTON;
pub const MDP_SEPERATOR = MENUBANDPARTS.SEPERATOR;

pub const MENUBANDSTATES = extern enum(i32) {
    NORMAL = 1,
    HOT = 2,
    PRESSED = 3,
    DISABLED = 4,
    CHECKED = 5,
    HOTCHECKED = 6,
};
pub const MDS_NORMAL = MENUBANDSTATES.NORMAL;
pub const MDS_HOT = MENUBANDSTATES.HOT;
pub const MDS_PRESSED = MENUBANDSTATES.PRESSED;
pub const MDS_DISABLED = MENUBANDSTATES.DISABLED;
pub const MDS_CHECKED = MENUBANDSTATES.CHECKED;
pub const MDS_HOTCHECKED = MENUBANDSTATES.HOTCHECKED;

pub const THEME_PROPERTY_SYMBOL_ID = extern enum(u32) {
    RESERVEDLOW = 0,
    RESERVEDHIGH = 7999,
    DIBDATA = 2,
    GLYPHDIBDATA = 8,
    ENUM = 200,
    STRING = 201,
    INT = 202,
    BOOL = 203,
    COLOR = 204,
    MARGINS = 205,
    FILENAME = 206,
    SIZE = 207,
    POSITION = 208,
    RECT = 209,
    FONT = 210,
    INTLIST = 211,
    HBITMAP = 212,
    DISKSTREAM = 213,
    STREAM = 214,
    BITMAPREF = 215,
    FLOAT = 216,
    FLOATLIST = 217,
    COLORSCHEMES = 401,
    SIZES = 402,
    CHARSET = 403,
    NAME = 600,
    DISPLAYNAME = 601,
    TOOLTIP = 602,
    COMPANY = 603,
    AUTHOR = 604,
    COPYRIGHT = 605,
    URL = 606,
    VERSION = 607,
    DESCRIPTION = 608,
    FIRST_RCSTRING_NAME = 601,
    LAST_RCSTRING_NAME = 608,
    CAPTIONFONT = 801,
    SMALLCAPTIONFONT = 802,
    MENUFONT = 803,
    STATUSFONT = 804,
    MSGBOXFONT = 805,
    ICONTITLEFONT = 806,
    HEADING1FONT = 807,
    HEADING2FONT = 808,
    BODYFONT = 809,
    FIRSTFONT = 801,
    LASTFONT = 809,
    FLATMENUS = 1001,
    FIRSTBOOL = 1001,
    LASTBOOL = 1001,
    SIZINGBORDERWIDTH = 1201,
    SCROLLBARWIDTH = 1202,
    SCROLLBARHEIGHT = 1203,
    CAPTIONBARWIDTH = 1204,
    CAPTIONBARHEIGHT = 1205,
    SMCAPTIONBARWIDTH = 1206,
    SMCAPTIONBARHEIGHT = 1207,
    MENUBARWIDTH = 1208,
    MENUBARHEIGHT = 1209,
    PADDEDBORDERWIDTH = 1210,
    FIRSTSIZE = 1201,
    LASTSIZE = 1210,
    MINCOLORDEPTH = 1301,
    FIRSTINT = 1301,
    LASTINT = 1301,
    CSSNAME = 1401,
    XMLNAME = 1402,
    LASTUPDATED = 1403,
    ALIAS = 1404,
    FIRSTSTRING = 1401,
    LASTSTRING = 1404,
    SCROLLBAR = 1601,
    BACKGROUND = 1602,
    ACTIVECAPTION = 1603,
    INACTIVECAPTION = 1604,
    MENU = 1605,
    WINDOW = 1606,
    WINDOWFRAME = 1607,
    MENUTEXT = 1608,
    WINDOWTEXT = 1609,
    CAPTIONTEXT = 1610,
    ACTIVEBORDER = 1611,
    INACTIVEBORDER = 1612,
    APPWORKSPACE = 1613,
    HIGHLIGHT = 1614,
    HIGHLIGHTTEXT = 1615,
    BTNFACE = 1616,
    BTNSHADOW = 1617,
    GRAYTEXT = 1618,
    BTNTEXT = 1619,
    INACTIVECAPTIONTEXT = 1620,
    BTNHIGHLIGHT = 1621,
    DKSHADOW3D = 1622,
    LIGHT3D = 1623,
    INFOTEXT = 1624,
    INFOBK = 1625,
    BUTTONALTERNATEFACE = 1626,
    HOTTRACKING = 1627,
    GRADIENTACTIVECAPTION = 1628,
    GRADIENTINACTIVECAPTION = 1629,
    MENUHILIGHT = 1630,
    MENUBAR = 1631,
    FIRSTCOLOR = 1601,
    LASTCOLOR = 1631,
    FROMHUE1 = 1801,
    FROMHUE2 = 1802,
    FROMHUE3 = 1803,
    FROMHUE4 = 1804,
    FROMHUE5 = 1805,
    TOHUE1 = 1806,
    TOHUE2 = 1807,
    TOHUE3 = 1808,
    TOHUE4 = 1809,
    TOHUE5 = 1810,
    FROMCOLOR1 = 2001,
    FROMCOLOR2 = 2002,
    FROMCOLOR3 = 2003,
    FROMCOLOR4 = 2004,
    FROMCOLOR5 = 2005,
    TOCOLOR1 = 2006,
    TOCOLOR2 = 2007,
    TOCOLOR3 = 2008,
    TOCOLOR4 = 2009,
    TOCOLOR5 = 2010,
    TRANSPARENT = 2201,
    AUTOSIZE = 2202,
    BORDERONLY = 2203,
    COMPOSITED = 2204,
    BGFILL = 2205,
    GLYPHTRANSPARENT = 2206,
    GLYPHONLY = 2207,
    ALWAYSSHOWSIZINGBAR = 2208,
    MIRRORIMAGE = 2209,
    UNIFORMSIZING = 2210,
    INTEGRALSIZING = 2211,
    SOURCEGROW = 2212,
    SOURCESHRINK = 2213,
    DRAWBORDERS = 2214,
    NOETCHEDEFFECT = 2215,
    TEXTAPPLYOVERLAY = 2216,
    TEXTGLOW = 2217,
    TEXTITALIC = 2218,
    COMPOSITEDOPAQUE = 2219,
    LOCALIZEDMIRRORIMAGE = 2220,
    IMAGECOUNT = 2401,
    ALPHALEVEL = 2402,
    BORDERSIZE = 2403,
    ROUNDCORNERWIDTH = 2404,
    ROUNDCORNERHEIGHT = 2405,
    GRADIENTRATIO1 = 2406,
    GRADIENTRATIO2 = 2407,
    GRADIENTRATIO3 = 2408,
    GRADIENTRATIO4 = 2409,
    GRADIENTRATIO5 = 2410,
    PROGRESSCHUNKSIZE = 2411,
    PROGRESSSPACESIZE = 2412,
    SATURATION = 2413,
    TEXTBORDERSIZE = 2414,
    ALPHATHRESHOLD = 2415,
    WIDTH = 2416,
    HEIGHT = 2417,
    GLYPHINDEX = 2418,
    TRUESIZESTRETCHMARK = 2419,
    MINDPI1 = 2420,
    MINDPI2 = 2421,
    MINDPI3 = 2422,
    MINDPI4 = 2423,
    MINDPI5 = 2424,
    TEXTGLOWSIZE = 2425,
    FRAMESPERSECOND = 2426,
    PIXELSPERFRAME = 2427,
    ANIMATIONDELAY = 2428,
    GLOWINTENSITY = 2429,
    OPACITY = 2430,
    COLORIZATIONCOLOR = 2431,
    COLORIZATIONOPACITY = 2432,
    MINDPI6 = 2433,
    MINDPI7 = 2434,
    GLYPHFONT = 2601,
    IMAGEFILE = 3001,
    IMAGEFILE1 = 3002,
    IMAGEFILE2 = 3003,
    IMAGEFILE3 = 3004,
    IMAGEFILE4 = 3005,
    IMAGEFILE5 = 3006,
    GLYPHIMAGEFILE = 3008,
    IMAGEFILE6 = 3009,
    IMAGEFILE7 = 3010,
    TEXT = 3201,
    CLASSICVALUE = 3202,
    OFFSET = 3401,
    TEXTSHADOWOFFSET = 3402,
    MINSIZE = 3403,
    MINSIZE1 = 3404,
    MINSIZE2 = 3405,
    MINSIZE3 = 3406,
    MINSIZE4 = 3407,
    MINSIZE5 = 3408,
    NORMALSIZE = 3409,
    MINSIZE6 = 3410,
    MINSIZE7 = 3411,
    SIZINGMARGINS = 3601,
    CONTENTMARGINS = 3602,
    CAPTIONMARGINS = 3603,
    BORDERCOLOR = 3801,
    FILLCOLOR = 3802,
    TEXTCOLOR = 3803,
    EDGELIGHTCOLOR = 3804,
    EDGEHIGHLIGHTCOLOR = 3805,
    EDGESHADOWCOLOR = 3806,
    EDGEDKSHADOWCOLOR = 3807,
    EDGEFILLCOLOR = 3808,
    TRANSPARENTCOLOR = 3809,
    GRADIENTCOLOR1 = 3810,
    GRADIENTCOLOR2 = 3811,
    GRADIENTCOLOR3 = 3812,
    GRADIENTCOLOR4 = 3813,
    GRADIENTCOLOR5 = 3814,
    SHADOWCOLOR = 3815,
    GLOWCOLOR = 3816,
    TEXTBORDERCOLOR = 3817,
    TEXTSHADOWCOLOR = 3818,
    GLYPHTEXTCOLOR = 3819,
    GLYPHTRANSPARENTCOLOR = 3820,
    FILLCOLORHINT = 3821,
    BORDERCOLORHINT = 3822,
    ACCENTCOLORHINT = 3823,
    TEXTCOLORHINT = 3824,
    HEADING1TEXTCOLOR = 3825,
    HEADING2TEXTCOLOR = 3826,
    BODYTEXTCOLOR = 3827,
    BGTYPE = 4001,
    BORDERTYPE = 4002,
    FILLTYPE = 4003,
    SIZINGTYPE = 4004,
    HALIGN = 4005,
    CONTENTALIGNMENT = 4006,
    VALIGN = 4007,
    OFFSETTYPE = 4008,
    ICONEFFECT = 4009,
    TEXTSHADOWTYPE = 4010,
    IMAGELAYOUT = 4011,
    GLYPHTYPE = 4012,
    IMAGESELECTTYPE = 4013,
    GLYPHFONTSIZINGTYPE = 4014,
    TRUESIZESCALINGTYPE = 4015,
    USERPICTURE = 5001,
    DEFAULTPANESIZE = 5002,
    BLENDCOLOR = 5003,
    CUSTOMSPLITRECT = 5004,
    ANIMATIONBUTTONRECT = 5005,
    ANIMATIONDURATION = 5006,
    TRANSITIONDURATIONS = 6000,
    SCALEDBACKGROUND = 7001,
    ATLASIMAGE = 8000,
    ATLASINPUTIMAGE = 8001,
    ATLASRECT = 8002,
};
pub const TMT_RESERVEDLOW = THEME_PROPERTY_SYMBOL_ID.RESERVEDLOW;
pub const TMT_RESERVEDHIGH = THEME_PROPERTY_SYMBOL_ID.RESERVEDHIGH;
pub const TMT_DIBDATA = THEME_PROPERTY_SYMBOL_ID.DIBDATA;
pub const TMT_GLYPHDIBDATA = THEME_PROPERTY_SYMBOL_ID.GLYPHDIBDATA;
pub const TMT_ENUM = THEME_PROPERTY_SYMBOL_ID.ENUM;
pub const TMT_STRING = THEME_PROPERTY_SYMBOL_ID.STRING;
pub const TMT_INT = THEME_PROPERTY_SYMBOL_ID.INT;
pub const TMT_BOOL = THEME_PROPERTY_SYMBOL_ID.BOOL;
pub const TMT_COLOR = THEME_PROPERTY_SYMBOL_ID.COLOR;
pub const TMT_MARGINS = THEME_PROPERTY_SYMBOL_ID.MARGINS;
pub const TMT_FILENAME = THEME_PROPERTY_SYMBOL_ID.FILENAME;
pub const TMT_SIZE = THEME_PROPERTY_SYMBOL_ID.SIZE;
pub const TMT_POSITION = THEME_PROPERTY_SYMBOL_ID.POSITION;
pub const TMT_RECT = THEME_PROPERTY_SYMBOL_ID.RECT;
pub const TMT_FONT = THEME_PROPERTY_SYMBOL_ID.FONT;
pub const TMT_INTLIST = THEME_PROPERTY_SYMBOL_ID.INTLIST;
pub const TMT_HBITMAP = THEME_PROPERTY_SYMBOL_ID.HBITMAP;
pub const TMT_DISKSTREAM = THEME_PROPERTY_SYMBOL_ID.DISKSTREAM;
pub const TMT_STREAM = THEME_PROPERTY_SYMBOL_ID.STREAM;
pub const TMT_BITMAPREF = THEME_PROPERTY_SYMBOL_ID.BITMAPREF;
pub const TMT_FLOAT = THEME_PROPERTY_SYMBOL_ID.FLOAT;
pub const TMT_FLOATLIST = THEME_PROPERTY_SYMBOL_ID.FLOATLIST;
pub const TMT_COLORSCHEMES = THEME_PROPERTY_SYMBOL_ID.COLORSCHEMES;
pub const TMT_SIZES = THEME_PROPERTY_SYMBOL_ID.SIZES;
pub const TMT_CHARSET = THEME_PROPERTY_SYMBOL_ID.CHARSET;
pub const TMT_NAME = THEME_PROPERTY_SYMBOL_ID.NAME;
pub const TMT_DISPLAYNAME = THEME_PROPERTY_SYMBOL_ID.DISPLAYNAME;
pub const TMT_TOOLTIP = THEME_PROPERTY_SYMBOL_ID.TOOLTIP;
pub const TMT_COMPANY = THEME_PROPERTY_SYMBOL_ID.COMPANY;
pub const TMT_AUTHOR = THEME_PROPERTY_SYMBOL_ID.AUTHOR;
pub const TMT_COPYRIGHT = THEME_PROPERTY_SYMBOL_ID.COPYRIGHT;
pub const TMT_URL = THEME_PROPERTY_SYMBOL_ID.URL;
pub const TMT_VERSION = THEME_PROPERTY_SYMBOL_ID.VERSION;
pub const TMT_DESCRIPTION = THEME_PROPERTY_SYMBOL_ID.DESCRIPTION;
pub const TMT_FIRST_RCSTRING_NAME = THEME_PROPERTY_SYMBOL_ID.FIRST_RCSTRING_NAME;
pub const TMT_LAST_RCSTRING_NAME = THEME_PROPERTY_SYMBOL_ID.LAST_RCSTRING_NAME;
pub const TMT_CAPTIONFONT = THEME_PROPERTY_SYMBOL_ID.CAPTIONFONT;
pub const TMT_SMALLCAPTIONFONT = THEME_PROPERTY_SYMBOL_ID.SMALLCAPTIONFONT;
pub const TMT_MENUFONT = THEME_PROPERTY_SYMBOL_ID.MENUFONT;
pub const TMT_STATUSFONT = THEME_PROPERTY_SYMBOL_ID.STATUSFONT;
pub const TMT_MSGBOXFONT = THEME_PROPERTY_SYMBOL_ID.MSGBOXFONT;
pub const TMT_ICONTITLEFONT = THEME_PROPERTY_SYMBOL_ID.ICONTITLEFONT;
pub const TMT_HEADING1FONT = THEME_PROPERTY_SYMBOL_ID.HEADING1FONT;
pub const TMT_HEADING2FONT = THEME_PROPERTY_SYMBOL_ID.HEADING2FONT;
pub const TMT_BODYFONT = THEME_PROPERTY_SYMBOL_ID.BODYFONT;
pub const TMT_FIRSTFONT = THEME_PROPERTY_SYMBOL_ID.FIRSTFONT;
pub const TMT_LASTFONT = THEME_PROPERTY_SYMBOL_ID.LASTFONT;
pub const TMT_FLATMENUS = THEME_PROPERTY_SYMBOL_ID.FLATMENUS;
pub const TMT_FIRSTBOOL = THEME_PROPERTY_SYMBOL_ID.FIRSTBOOL;
pub const TMT_LASTBOOL = THEME_PROPERTY_SYMBOL_ID.LASTBOOL;
pub const TMT_SIZINGBORDERWIDTH = THEME_PROPERTY_SYMBOL_ID.SIZINGBORDERWIDTH;
pub const TMT_SCROLLBARWIDTH = THEME_PROPERTY_SYMBOL_ID.SCROLLBARWIDTH;
pub const TMT_SCROLLBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.SCROLLBARHEIGHT;
pub const TMT_CAPTIONBARWIDTH = THEME_PROPERTY_SYMBOL_ID.CAPTIONBARWIDTH;
pub const TMT_CAPTIONBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.CAPTIONBARHEIGHT;
pub const TMT_SMCAPTIONBARWIDTH = THEME_PROPERTY_SYMBOL_ID.SMCAPTIONBARWIDTH;
pub const TMT_SMCAPTIONBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.SMCAPTIONBARHEIGHT;
pub const TMT_MENUBARWIDTH = THEME_PROPERTY_SYMBOL_ID.MENUBARWIDTH;
pub const TMT_MENUBARHEIGHT = THEME_PROPERTY_SYMBOL_ID.MENUBARHEIGHT;
pub const TMT_PADDEDBORDERWIDTH = THEME_PROPERTY_SYMBOL_ID.PADDEDBORDERWIDTH;
pub const TMT_FIRSTSIZE = THEME_PROPERTY_SYMBOL_ID.FIRSTSIZE;
pub const TMT_LASTSIZE = THEME_PROPERTY_SYMBOL_ID.LASTSIZE;
pub const TMT_MINCOLORDEPTH = THEME_PROPERTY_SYMBOL_ID.MINCOLORDEPTH;
pub const TMT_FIRSTINT = THEME_PROPERTY_SYMBOL_ID.FIRSTINT;
pub const TMT_LASTINT = THEME_PROPERTY_SYMBOL_ID.LASTINT;
pub const TMT_CSSNAME = THEME_PROPERTY_SYMBOL_ID.CSSNAME;
pub const TMT_XMLNAME = THEME_PROPERTY_SYMBOL_ID.XMLNAME;
pub const TMT_LASTUPDATED = THEME_PROPERTY_SYMBOL_ID.LASTUPDATED;
pub const TMT_ALIAS = THEME_PROPERTY_SYMBOL_ID.ALIAS;
pub const TMT_FIRSTSTRING = THEME_PROPERTY_SYMBOL_ID.FIRSTSTRING;
pub const TMT_LASTSTRING = THEME_PROPERTY_SYMBOL_ID.LASTSTRING;
pub const TMT_SCROLLBAR = THEME_PROPERTY_SYMBOL_ID.SCROLLBAR;
pub const TMT_BACKGROUND = THEME_PROPERTY_SYMBOL_ID.BACKGROUND;
pub const TMT_ACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.ACTIVECAPTION;
pub const TMT_INACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.INACTIVECAPTION;
pub const TMT_MENU = THEME_PROPERTY_SYMBOL_ID.MENU;
pub const TMT_WINDOW = THEME_PROPERTY_SYMBOL_ID.WINDOW;
pub const TMT_WINDOWFRAME = THEME_PROPERTY_SYMBOL_ID.WINDOWFRAME;
pub const TMT_MENUTEXT = THEME_PROPERTY_SYMBOL_ID.MENUTEXT;
pub const TMT_WINDOWTEXT = THEME_PROPERTY_SYMBOL_ID.WINDOWTEXT;
pub const TMT_CAPTIONTEXT = THEME_PROPERTY_SYMBOL_ID.CAPTIONTEXT;
pub const TMT_ACTIVEBORDER = THEME_PROPERTY_SYMBOL_ID.ACTIVEBORDER;
pub const TMT_INACTIVEBORDER = THEME_PROPERTY_SYMBOL_ID.INACTIVEBORDER;
pub const TMT_APPWORKSPACE = THEME_PROPERTY_SYMBOL_ID.APPWORKSPACE;
pub const TMT_HIGHLIGHT = THEME_PROPERTY_SYMBOL_ID.HIGHLIGHT;
pub const TMT_HIGHLIGHTTEXT = THEME_PROPERTY_SYMBOL_ID.HIGHLIGHTTEXT;
pub const TMT_BTNFACE = THEME_PROPERTY_SYMBOL_ID.BTNFACE;
pub const TMT_BTNSHADOW = THEME_PROPERTY_SYMBOL_ID.BTNSHADOW;
pub const TMT_GRAYTEXT = THEME_PROPERTY_SYMBOL_ID.GRAYTEXT;
pub const TMT_BTNTEXT = THEME_PROPERTY_SYMBOL_ID.BTNTEXT;
pub const TMT_INACTIVECAPTIONTEXT = THEME_PROPERTY_SYMBOL_ID.INACTIVECAPTIONTEXT;
pub const TMT_BTNHIGHLIGHT = THEME_PROPERTY_SYMBOL_ID.BTNHIGHLIGHT;
pub const TMT_DKSHADOW3D = THEME_PROPERTY_SYMBOL_ID.DKSHADOW3D;
pub const TMT_LIGHT3D = THEME_PROPERTY_SYMBOL_ID.LIGHT3D;
pub const TMT_INFOTEXT = THEME_PROPERTY_SYMBOL_ID.INFOTEXT;
pub const TMT_INFOBK = THEME_PROPERTY_SYMBOL_ID.INFOBK;
pub const TMT_BUTTONALTERNATEFACE = THEME_PROPERTY_SYMBOL_ID.BUTTONALTERNATEFACE;
pub const TMT_HOTTRACKING = THEME_PROPERTY_SYMBOL_ID.HOTTRACKING;
pub const TMT_GRADIENTACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.GRADIENTACTIVECAPTION;
pub const TMT_GRADIENTINACTIVECAPTION = THEME_PROPERTY_SYMBOL_ID.GRADIENTINACTIVECAPTION;
pub const TMT_MENUHILIGHT = THEME_PROPERTY_SYMBOL_ID.MENUHILIGHT;
pub const TMT_MENUBAR = THEME_PROPERTY_SYMBOL_ID.MENUBAR;
pub const TMT_FIRSTCOLOR = THEME_PROPERTY_SYMBOL_ID.FIRSTCOLOR;
pub const TMT_LASTCOLOR = THEME_PROPERTY_SYMBOL_ID.LASTCOLOR;
pub const TMT_FROMHUE1 = THEME_PROPERTY_SYMBOL_ID.FROMHUE1;
pub const TMT_FROMHUE2 = THEME_PROPERTY_SYMBOL_ID.FROMHUE2;
pub const TMT_FROMHUE3 = THEME_PROPERTY_SYMBOL_ID.FROMHUE3;
pub const TMT_FROMHUE4 = THEME_PROPERTY_SYMBOL_ID.FROMHUE4;
pub const TMT_FROMHUE5 = THEME_PROPERTY_SYMBOL_ID.FROMHUE5;
pub const TMT_TOHUE1 = THEME_PROPERTY_SYMBOL_ID.TOHUE1;
pub const TMT_TOHUE2 = THEME_PROPERTY_SYMBOL_ID.TOHUE2;
pub const TMT_TOHUE3 = THEME_PROPERTY_SYMBOL_ID.TOHUE3;
pub const TMT_TOHUE4 = THEME_PROPERTY_SYMBOL_ID.TOHUE4;
pub const TMT_TOHUE5 = THEME_PROPERTY_SYMBOL_ID.TOHUE5;
pub const TMT_FROMCOLOR1 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR1;
pub const TMT_FROMCOLOR2 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR2;
pub const TMT_FROMCOLOR3 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR3;
pub const TMT_FROMCOLOR4 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR4;
pub const TMT_FROMCOLOR5 = THEME_PROPERTY_SYMBOL_ID.FROMCOLOR5;
pub const TMT_TOCOLOR1 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR1;
pub const TMT_TOCOLOR2 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR2;
pub const TMT_TOCOLOR3 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR3;
pub const TMT_TOCOLOR4 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR4;
pub const TMT_TOCOLOR5 = THEME_PROPERTY_SYMBOL_ID.TOCOLOR5;
pub const TMT_TRANSPARENT = THEME_PROPERTY_SYMBOL_ID.TRANSPARENT;
pub const TMT_AUTOSIZE = THEME_PROPERTY_SYMBOL_ID.AUTOSIZE;
pub const TMT_BORDERONLY = THEME_PROPERTY_SYMBOL_ID.BORDERONLY;
pub const TMT_COMPOSITED = THEME_PROPERTY_SYMBOL_ID.COMPOSITED;
pub const TMT_BGFILL = THEME_PROPERTY_SYMBOL_ID.BGFILL;
pub const TMT_GLYPHTRANSPARENT = THEME_PROPERTY_SYMBOL_ID.GLYPHTRANSPARENT;
pub const TMT_GLYPHONLY = THEME_PROPERTY_SYMBOL_ID.GLYPHONLY;
pub const TMT_ALWAYSSHOWSIZINGBAR = THEME_PROPERTY_SYMBOL_ID.ALWAYSSHOWSIZINGBAR;
pub const TMT_MIRRORIMAGE = THEME_PROPERTY_SYMBOL_ID.MIRRORIMAGE;
pub const TMT_UNIFORMSIZING = THEME_PROPERTY_SYMBOL_ID.UNIFORMSIZING;
pub const TMT_INTEGRALSIZING = THEME_PROPERTY_SYMBOL_ID.INTEGRALSIZING;
pub const TMT_SOURCEGROW = THEME_PROPERTY_SYMBOL_ID.SOURCEGROW;
pub const TMT_SOURCESHRINK = THEME_PROPERTY_SYMBOL_ID.SOURCESHRINK;
pub const TMT_DRAWBORDERS = THEME_PROPERTY_SYMBOL_ID.DRAWBORDERS;
pub const TMT_NOETCHEDEFFECT = THEME_PROPERTY_SYMBOL_ID.NOETCHEDEFFECT;
pub const TMT_TEXTAPPLYOVERLAY = THEME_PROPERTY_SYMBOL_ID.TEXTAPPLYOVERLAY;
pub const TMT_TEXTGLOW = THEME_PROPERTY_SYMBOL_ID.TEXTGLOW;
pub const TMT_TEXTITALIC = THEME_PROPERTY_SYMBOL_ID.TEXTITALIC;
pub const TMT_COMPOSITEDOPAQUE = THEME_PROPERTY_SYMBOL_ID.COMPOSITEDOPAQUE;
pub const TMT_LOCALIZEDMIRRORIMAGE = THEME_PROPERTY_SYMBOL_ID.LOCALIZEDMIRRORIMAGE;
pub const TMT_IMAGECOUNT = THEME_PROPERTY_SYMBOL_ID.IMAGECOUNT;
pub const TMT_ALPHALEVEL = THEME_PROPERTY_SYMBOL_ID.ALPHALEVEL;
pub const TMT_BORDERSIZE = THEME_PROPERTY_SYMBOL_ID.BORDERSIZE;
pub const TMT_ROUNDCORNERWIDTH = THEME_PROPERTY_SYMBOL_ID.ROUNDCORNERWIDTH;
pub const TMT_ROUNDCORNERHEIGHT = THEME_PROPERTY_SYMBOL_ID.ROUNDCORNERHEIGHT;
pub const TMT_GRADIENTRATIO1 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO1;
pub const TMT_GRADIENTRATIO2 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO2;
pub const TMT_GRADIENTRATIO3 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO3;
pub const TMT_GRADIENTRATIO4 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO4;
pub const TMT_GRADIENTRATIO5 = THEME_PROPERTY_SYMBOL_ID.GRADIENTRATIO5;
pub const TMT_PROGRESSCHUNKSIZE = THEME_PROPERTY_SYMBOL_ID.PROGRESSCHUNKSIZE;
pub const TMT_PROGRESSSPACESIZE = THEME_PROPERTY_SYMBOL_ID.PROGRESSSPACESIZE;
pub const TMT_SATURATION = THEME_PROPERTY_SYMBOL_ID.SATURATION;
pub const TMT_TEXTBORDERSIZE = THEME_PROPERTY_SYMBOL_ID.TEXTBORDERSIZE;
pub const TMT_ALPHATHRESHOLD = THEME_PROPERTY_SYMBOL_ID.ALPHATHRESHOLD;
pub const TMT_WIDTH = THEME_PROPERTY_SYMBOL_ID.WIDTH;
pub const TMT_HEIGHT = THEME_PROPERTY_SYMBOL_ID.HEIGHT;
pub const TMT_GLYPHINDEX = THEME_PROPERTY_SYMBOL_ID.GLYPHINDEX;
pub const TMT_TRUESIZESTRETCHMARK = THEME_PROPERTY_SYMBOL_ID.TRUESIZESTRETCHMARK;
pub const TMT_MINDPI1 = THEME_PROPERTY_SYMBOL_ID.MINDPI1;
pub const TMT_MINDPI2 = THEME_PROPERTY_SYMBOL_ID.MINDPI2;
pub const TMT_MINDPI3 = THEME_PROPERTY_SYMBOL_ID.MINDPI3;
pub const TMT_MINDPI4 = THEME_PROPERTY_SYMBOL_ID.MINDPI4;
pub const TMT_MINDPI5 = THEME_PROPERTY_SYMBOL_ID.MINDPI5;
pub const TMT_TEXTGLOWSIZE = THEME_PROPERTY_SYMBOL_ID.TEXTGLOWSIZE;
pub const TMT_FRAMESPERSECOND = THEME_PROPERTY_SYMBOL_ID.FRAMESPERSECOND;
pub const TMT_PIXELSPERFRAME = THEME_PROPERTY_SYMBOL_ID.PIXELSPERFRAME;
pub const TMT_ANIMATIONDELAY = THEME_PROPERTY_SYMBOL_ID.ANIMATIONDELAY;
pub const TMT_GLOWINTENSITY = THEME_PROPERTY_SYMBOL_ID.GLOWINTENSITY;
pub const TMT_OPACITY = THEME_PROPERTY_SYMBOL_ID.OPACITY;
pub const TMT_COLORIZATIONCOLOR = THEME_PROPERTY_SYMBOL_ID.COLORIZATIONCOLOR;
pub const TMT_COLORIZATIONOPACITY = THEME_PROPERTY_SYMBOL_ID.COLORIZATIONOPACITY;
pub const TMT_MINDPI6 = THEME_PROPERTY_SYMBOL_ID.MINDPI6;
pub const TMT_MINDPI7 = THEME_PROPERTY_SYMBOL_ID.MINDPI7;
pub const TMT_GLYPHFONT = THEME_PROPERTY_SYMBOL_ID.GLYPHFONT;
pub const TMT_IMAGEFILE = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE;
pub const TMT_IMAGEFILE1 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE1;
pub const TMT_IMAGEFILE2 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE2;
pub const TMT_IMAGEFILE3 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE3;
pub const TMT_IMAGEFILE4 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE4;
pub const TMT_IMAGEFILE5 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE5;
pub const TMT_GLYPHIMAGEFILE = THEME_PROPERTY_SYMBOL_ID.GLYPHIMAGEFILE;
pub const TMT_IMAGEFILE6 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE6;
pub const TMT_IMAGEFILE7 = THEME_PROPERTY_SYMBOL_ID.IMAGEFILE7;
pub const TMT_TEXT = THEME_PROPERTY_SYMBOL_ID.TEXT;
pub const TMT_CLASSICVALUE = THEME_PROPERTY_SYMBOL_ID.CLASSICVALUE;
pub const TMT_OFFSET = THEME_PROPERTY_SYMBOL_ID.OFFSET;
pub const TMT_TEXTSHADOWOFFSET = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWOFFSET;
pub const TMT_MINSIZE = THEME_PROPERTY_SYMBOL_ID.MINSIZE;
pub const TMT_MINSIZE1 = THEME_PROPERTY_SYMBOL_ID.MINSIZE1;
pub const TMT_MINSIZE2 = THEME_PROPERTY_SYMBOL_ID.MINSIZE2;
pub const TMT_MINSIZE3 = THEME_PROPERTY_SYMBOL_ID.MINSIZE3;
pub const TMT_MINSIZE4 = THEME_PROPERTY_SYMBOL_ID.MINSIZE4;
pub const TMT_MINSIZE5 = THEME_PROPERTY_SYMBOL_ID.MINSIZE5;
pub const TMT_NORMALSIZE = THEME_PROPERTY_SYMBOL_ID.NORMALSIZE;
pub const TMT_MINSIZE6 = THEME_PROPERTY_SYMBOL_ID.MINSIZE6;
pub const TMT_MINSIZE7 = THEME_PROPERTY_SYMBOL_ID.MINSIZE7;
pub const TMT_SIZINGMARGINS = THEME_PROPERTY_SYMBOL_ID.SIZINGMARGINS;
pub const TMT_CONTENTMARGINS = THEME_PROPERTY_SYMBOL_ID.CONTENTMARGINS;
pub const TMT_CAPTIONMARGINS = THEME_PROPERTY_SYMBOL_ID.CAPTIONMARGINS;
pub const TMT_BORDERCOLOR = THEME_PROPERTY_SYMBOL_ID.BORDERCOLOR;
pub const TMT_FILLCOLOR = THEME_PROPERTY_SYMBOL_ID.FILLCOLOR;
pub const TMT_TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTCOLOR;
pub const TMT_EDGELIGHTCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGELIGHTCOLOR;
pub const TMT_EDGEHIGHLIGHTCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEHIGHLIGHTCOLOR;
pub const TMT_EDGESHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGESHADOWCOLOR;
pub const TMT_EDGEDKSHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEDKSHADOWCOLOR;
pub const TMT_EDGEFILLCOLOR = THEME_PROPERTY_SYMBOL_ID.EDGEFILLCOLOR;
pub const TMT_TRANSPARENTCOLOR = THEME_PROPERTY_SYMBOL_ID.TRANSPARENTCOLOR;
pub const TMT_GRADIENTCOLOR1 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR1;
pub const TMT_GRADIENTCOLOR2 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR2;
pub const TMT_GRADIENTCOLOR3 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR3;
pub const TMT_GRADIENTCOLOR4 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR4;
pub const TMT_GRADIENTCOLOR5 = THEME_PROPERTY_SYMBOL_ID.GRADIENTCOLOR5;
pub const TMT_SHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.SHADOWCOLOR;
pub const TMT_GLOWCOLOR = THEME_PROPERTY_SYMBOL_ID.GLOWCOLOR;
pub const TMT_TEXTBORDERCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTBORDERCOLOR;
pub const TMT_TEXTSHADOWCOLOR = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWCOLOR;
pub const TMT_GLYPHTEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.GLYPHTEXTCOLOR;
pub const TMT_GLYPHTRANSPARENTCOLOR = THEME_PROPERTY_SYMBOL_ID.GLYPHTRANSPARENTCOLOR;
pub const TMT_FILLCOLORHINT = THEME_PROPERTY_SYMBOL_ID.FILLCOLORHINT;
pub const TMT_BORDERCOLORHINT = THEME_PROPERTY_SYMBOL_ID.BORDERCOLORHINT;
pub const TMT_ACCENTCOLORHINT = THEME_PROPERTY_SYMBOL_ID.ACCENTCOLORHINT;
pub const TMT_TEXTCOLORHINT = THEME_PROPERTY_SYMBOL_ID.TEXTCOLORHINT;
pub const TMT_HEADING1TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.HEADING1TEXTCOLOR;
pub const TMT_HEADING2TEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.HEADING2TEXTCOLOR;
pub const TMT_BODYTEXTCOLOR = THEME_PROPERTY_SYMBOL_ID.BODYTEXTCOLOR;
pub const TMT_BGTYPE = THEME_PROPERTY_SYMBOL_ID.BGTYPE;
pub const TMT_BORDERTYPE = THEME_PROPERTY_SYMBOL_ID.BORDERTYPE;
pub const TMT_FILLTYPE = THEME_PROPERTY_SYMBOL_ID.FILLTYPE;
pub const TMT_SIZINGTYPE = THEME_PROPERTY_SYMBOL_ID.SIZINGTYPE;
pub const TMT_HALIGN = THEME_PROPERTY_SYMBOL_ID.HALIGN;
pub const TMT_CONTENTALIGNMENT = THEME_PROPERTY_SYMBOL_ID.CONTENTALIGNMENT;
pub const TMT_VALIGN = THEME_PROPERTY_SYMBOL_ID.VALIGN;
pub const TMT_OFFSETTYPE = THEME_PROPERTY_SYMBOL_ID.OFFSETTYPE;
pub const TMT_ICONEFFECT = THEME_PROPERTY_SYMBOL_ID.ICONEFFECT;
pub const TMT_TEXTSHADOWTYPE = THEME_PROPERTY_SYMBOL_ID.TEXTSHADOWTYPE;
pub const TMT_IMAGELAYOUT = THEME_PROPERTY_SYMBOL_ID.IMAGELAYOUT;
pub const TMT_GLYPHTYPE = THEME_PROPERTY_SYMBOL_ID.GLYPHTYPE;
pub const TMT_IMAGESELECTTYPE = THEME_PROPERTY_SYMBOL_ID.IMAGESELECTTYPE;
pub const TMT_GLYPHFONTSIZINGTYPE = THEME_PROPERTY_SYMBOL_ID.GLYPHFONTSIZINGTYPE;
pub const TMT_TRUESIZESCALINGTYPE = THEME_PROPERTY_SYMBOL_ID.TRUESIZESCALINGTYPE;
pub const TMT_USERPICTURE = THEME_PROPERTY_SYMBOL_ID.USERPICTURE;
pub const TMT_DEFAULTPANESIZE = THEME_PROPERTY_SYMBOL_ID.DEFAULTPANESIZE;
pub const TMT_BLENDCOLOR = THEME_PROPERTY_SYMBOL_ID.BLENDCOLOR;
pub const TMT_CUSTOMSPLITRECT = THEME_PROPERTY_SYMBOL_ID.CUSTOMSPLITRECT;
pub const TMT_ANIMATIONBUTTONRECT = THEME_PROPERTY_SYMBOL_ID.ANIMATIONBUTTONRECT;
pub const TMT_ANIMATIONDURATION = THEME_PROPERTY_SYMBOL_ID.ANIMATIONDURATION;
pub const TMT_TRANSITIONDURATIONS = THEME_PROPERTY_SYMBOL_ID.TRANSITIONDURATIONS;
pub const TMT_SCALEDBACKGROUND = THEME_PROPERTY_SYMBOL_ID.SCALEDBACKGROUND;
pub const TMT_ATLASIMAGE = THEME_PROPERTY_SYMBOL_ID.ATLASIMAGE;
pub const TMT_ATLASINPUTIMAGE = THEME_PROPERTY_SYMBOL_ID.ATLASINPUTIMAGE;
pub const TMT_ATLASRECT = THEME_PROPERTY_SYMBOL_ID.ATLASRECT;

pub const TOUCH_FEEDBACK_MODE = extern enum(u32) {
    DEFAULT = 1,
    INDIRECT = 2,
    NONE = 3,
};
pub const TOUCH_FEEDBACK_DEFAULT = TOUCH_FEEDBACK_MODE.DEFAULT;
pub const TOUCH_FEEDBACK_INDIRECT = TOUCH_FEEDBACK_MODE.INDIRECT;
pub const TOUCH_FEEDBACK_NONE = TOUCH_FEEDBACK_MODE.NONE;

pub const SCROLLBAR_OBJID = extern enum(i32) {
    CLIENT = -4,
    HSCROLL = -6,
    VSCROLL = -5,
    MENU = -3,
    SYSMENU = -1,
};
pub const OBJID_CLIENT = SCROLLBAR_OBJID.CLIENT;
pub const OBJID_HSCROLL = SCROLLBAR_OBJID.HSCROLL;
pub const OBJID_VSCROLL = SCROLLBAR_OBJID.VSCROLL;
pub const OBJID_MENU = SCROLLBAR_OBJID.MENU;
pub const OBJID_SYSMENU = SCROLLBAR_OBJID.SYSMENU;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CFM_MASK = extern enum(u32) {
    SUBSCRIPT = 196608,
    EFFECTS = 1073741887,
    ALL = 4160749631,
    BOLD = 1,
    CHARSET = 134217728,
    COLOR = 1073741824,
    FACE = 536870912,
    ITALIC = 2,
    OFFSET = 268435456,
    PROTECTED = 16,
    SIZE = 2147483648,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    LINK = 32,
    SMALLCAPS = 64,
    ALLCAPS = 128,
    HIDDEN = 256,
    OUTLINE = 512,
    SHADOW = 1024,
    EMBOSS = 2048,
    IMPRINT = 4096,
    DISABLED = 8192,
    REVISED = 16384,
    REVAUTHOR = 32768,
    ANIMATION = 262144,
    STYLE = 524288,
    KERNING = 1048576,
    SPACING = 2097152,
    WEIGHT = 4194304,
    UNDERLINETYPE = 8388608,
    COOKIE = 16777216,
    LCID = 33554432,
    BACKCOLOR = 67108864,
    SUPERSCRIPT = 196608,
    EFFECTS2 = 1141080063,
    ALL2 = 4294967295,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    ALLEFFECTS = 2115207167,
    _,
};
pub const CFM_SUBSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS = CFM_MASK.EFFECTS;
pub const CFM_ALL = CFM_MASK.ALL;
pub const CFM_BOLD = CFM_MASK.BOLD;
pub const CFM_CHARSET = CFM_MASK.CHARSET;
pub const CFM_COLOR = CFM_MASK.COLOR;
pub const CFM_FACE = CFM_MASK.FACE;
pub const CFM_ITALIC = CFM_MASK.ITALIC;
pub const CFM_OFFSET = CFM_MASK.OFFSET;
pub const CFM_PROTECTED = CFM_MASK.PROTECTED;
pub const CFM_SIZE = CFM_MASK.SIZE;
pub const CFM_STRIKEOUT = CFM_MASK.STRIKEOUT;
pub const CFM_UNDERLINE = CFM_MASK.UNDERLINE;
pub const CFM_LINK = CFM_MASK.LINK;
pub const CFM_SMALLCAPS = CFM_MASK.SMALLCAPS;
pub const CFM_ALLCAPS = CFM_MASK.ALLCAPS;
pub const CFM_HIDDEN = CFM_MASK.HIDDEN;
pub const CFM_OUTLINE = CFM_MASK.OUTLINE;
pub const CFM_SHADOW = CFM_MASK.SHADOW;
pub const CFM_EMBOSS = CFM_MASK.EMBOSS;
pub const CFM_IMPRINT = CFM_MASK.IMPRINT;
pub const CFM_DISABLED = CFM_MASK.DISABLED;
pub const CFM_REVISED = CFM_MASK.REVISED;
pub const CFM_REVAUTHOR = CFM_MASK.REVAUTHOR;
pub const CFM_ANIMATION = CFM_MASK.ANIMATION;
pub const CFM_STYLE = CFM_MASK.STYLE;
pub const CFM_KERNING = CFM_MASK.KERNING;
pub const CFM_SPACING = CFM_MASK.SPACING;
pub const CFM_WEIGHT = CFM_MASK.WEIGHT;
pub const CFM_UNDERLINETYPE = CFM_MASK.UNDERLINETYPE;
pub const CFM_COOKIE = CFM_MASK.COOKIE;
pub const CFM_LCID = CFM_MASK.LCID;
pub const CFM_BACKCOLOR = CFM_MASK.BACKCOLOR;
pub const CFM_SUPERSCRIPT = CFM_MASK.SUPERSCRIPT;
pub const CFM_EFFECTS2 = CFM_MASK.EFFECTS2;
pub const CFM_ALL2 = CFM_MASK.ALL2;
pub const CFM_FONTBOUND = CFM_MASK.FONTBOUND;
pub const CFM_LINKPROTECTED = CFM_MASK.LINKPROTECTED;
pub const CFM_EXTENDED = CFM_MASK.EXTENDED;
pub const CFM_MATHNOBUILDUP = CFM_MASK.MATHNOBUILDUP;
pub const CFM_MATH = CFM_MASK.MATH;
pub const CFM_MATHORDINARY = CFM_MASK.MATHORDINARY;
pub const CFM_ALLEFFECTS = CFM_MASK.ALLEFFECTS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CFE_EFFECTS = extern enum(u32) {
    ALLCAPS = 128,
    AUTOBACKCOLOR = 67108864,
    DISABLED = 8192,
    EMBOSS = 2048,
    HIDDEN = 256,
    IMPRINT = 4096,
    OUTLINE = 512,
    REVISED = 16384,
    SHADOW = 1024,
    SMALLCAPS = 64,
    AUTOCOLOR = 1073741824,
    BOLD = 1,
    ITALIC = 2,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    PROTECTED = 16,
    LINK = 32,
    SUBSCRIPT = 65536,
    SUPERSCRIPT = 131072,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    _,
};
// TODO: enum 'CFE_EFFECTS' has known issues with its value aliases

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PARAFORMAT_MASK = extern enum(u32) {
    ALIGNMENT = 8,
    NUMBERING = 32,
    OFFSET = 4,
    OFFSETINDENT = 2147483648,
    RIGHTINDENT = 2,
    RTLPARA = 65536,
    STARTINDENT = 1,
    TABSTOPS = 16,
    _,
};
pub const PFM_ALIGNMENT = PARAFORMAT_MASK.ALIGNMENT;
pub const PFM_NUMBERING = PARAFORMAT_MASK.NUMBERING;
pub const PFM_OFFSET = PARAFORMAT_MASK.OFFSET;
pub const PFM_OFFSETINDENT = PARAFORMAT_MASK.OFFSETINDENT;
pub const PFM_RIGHTINDENT = PARAFORMAT_MASK.RIGHTINDENT;
pub const PFM_RTLPARA = PARAFORMAT_MASK.RTLPARA;
pub const PFM_STARTINDENT = PARAFORMAT_MASK.STARTINDENT;
pub const PFM_TABSTOPS = PARAFORMAT_MASK.TABSTOPS;

pub const DRAGLISTINFO_NOTIFICATION_FLAGS = extern enum(u32) {
    BEGINDRAG = 1157,
    CANCELDRAG = 1160,
    DRAGGING = 1158,
    DROPPED = 1159,
};
pub const DL_BEGINDRAG = DRAGLISTINFO_NOTIFICATION_FLAGS.BEGINDRAG;
pub const DL_CANCELDRAG = DRAGLISTINFO_NOTIFICATION_FLAGS.CANCELDRAG;
pub const DL_DRAGGING = DRAGLISTINFO_NOTIFICATION_FLAGS.DRAGGING;
pub const DL_DROPPED = DRAGLISTINFO_NOTIFICATION_FLAGS.DROPPED;

pub const TEXT_ALIGN_OPTIONS = extern enum(u32) {
    TA_NOUPDATECP = 0,
    TA_UPDATECP = 1,
    TA_LEFT = 0,
    TA_RIGHT = 2,
    TA_CENTER = 6,
    TA_TOP = 0,
    TA_BOTTOM = 8,
    TA_BASELINE = 24,
    TA_RTLREADING = 256,
    TA_MASK = 287,
    VTA_BASELINE = 24,
    VTA_LEFT = 8,
    VTA_RIGHT = 0,
    VTA_CENTER = 6,
    VTA_BOTTOM = 2,
    VTA_TOP = 0,
};
pub const TA_NOUPDATECP = TEXT_ALIGN_OPTIONS.TA_NOUPDATECP;
pub const TA_UPDATECP = TEXT_ALIGN_OPTIONS.TA_UPDATECP;
pub const TA_LEFT = TEXT_ALIGN_OPTIONS.TA_LEFT;
pub const TA_RIGHT = TEXT_ALIGN_OPTIONS.TA_RIGHT;
pub const TA_CENTER = TEXT_ALIGN_OPTIONS.TA_CENTER;
pub const TA_TOP = TEXT_ALIGN_OPTIONS.TA_TOP;
pub const TA_BOTTOM = TEXT_ALIGN_OPTIONS.TA_BOTTOM;
pub const TA_BASELINE = TEXT_ALIGN_OPTIONS.TA_BASELINE;
pub const TA_RTLREADING = TEXT_ALIGN_OPTIONS.TA_RTLREADING;
pub const TA_MASK = TEXT_ALIGN_OPTIONS.TA_MASK;
pub const VTA_BASELINE = TEXT_ALIGN_OPTIONS.VTA_BASELINE;
pub const VTA_LEFT = TEXT_ALIGN_OPTIONS.VTA_LEFT;
pub const VTA_RIGHT = TEXT_ALIGN_OPTIONS.VTA_RIGHT;
pub const VTA_CENTER = TEXT_ALIGN_OPTIONS.VTA_CENTER;
pub const VTA_BOTTOM = TEXT_ALIGN_OPTIONS.VTA_BOTTOM;
pub const VTA_TOP = TEXT_ALIGN_OPTIONS.VTA_TOP;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SCROLLBAR_CONSTANTS = extern enum(u32) {
    CTL = 2,
    HORZ = 0,
    VERT = 1,
    BOTH = 3,
    _,
};
pub const SB_CTL = SCROLLBAR_CONSTANTS.CTL;
pub const SB_HORZ = SCROLLBAR_CONSTANTS.HORZ;
pub const SB_VERT = SCROLLBAR_CONSTANTS.VERT;
pub const SB_BOTH = SCROLLBAR_CONSTANTS.BOTH;

pub const WORD_BREAK_ACTION = extern enum(u32) {
    CLASSIFY = 3,
    ISDELIMITER = 2,
    LEFT = 0,
    LEFTBREAK = 6,
    MOVEWORDLEFT = 4,
    MOVEWORDRIGHT = 5,
    RIGHT = 1,
    RIGHTBREAK = 7,
};
pub const WB_CLASSIFY = WORD_BREAK_ACTION.CLASSIFY;
pub const WB_ISDELIMITER = WORD_BREAK_ACTION.ISDELIMITER;
pub const WB_LEFT = WORD_BREAK_ACTION.LEFT;
pub const WB_LEFTBREAK = WORD_BREAK_ACTION.LEFTBREAK;
pub const WB_MOVEWORDLEFT = WORD_BREAK_ACTION.MOVEWORDLEFT;
pub const WB_MOVEWORDRIGHT = WORD_BREAK_ACTION.MOVEWORDRIGHT;
pub const WB_RIGHT = WORD_BREAK_ACTION.RIGHT;
pub const WB_RIGHTBREAK = WORD_BREAK_ACTION.RIGHTBREAK;

pub const DPAMM_MESSAGE = extern enum(u32) {
    MERGE = 1,
    DELETE = 2,
    INSERT = 3,
};
pub const DPAMM_MERGE = DPAMM_MESSAGE.MERGE;
pub const DPAMM_DELETE = DPAMM_MESSAGE.DELETE;
pub const DPAMM_INSERT = DPAMM_MESSAGE.INSERT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const IMAGE_FLAGS = extern enum(u32) {
    CREATEDIBSECTION = 8192,
    DEFAULTCOLOR = 0,
    DEFAULTSIZE = 64,
    LOADFROMFILE = 16,
    LOADMAP3DCOLORS = 4096,
    LOADTRANSPARENT = 32,
    MONOCHROME = 1,
    SHARED = 32768,
    VGACOLOR = 128,
    COPYDELETEORG = 8,
    COPYFROMRESOURCE = 16384,
    COPYRETURNORG = 4,
    _,
};
pub const LR_CREATEDIBSECTION = IMAGE_FLAGS.CREATEDIBSECTION;
pub const LR_DEFAULTCOLOR = IMAGE_FLAGS.DEFAULTCOLOR;
pub const LR_DEFAULTSIZE = IMAGE_FLAGS.DEFAULTSIZE;
pub const LR_LOADFROMFILE = IMAGE_FLAGS.LOADFROMFILE;
pub const LR_LOADMAP3DCOLORS = IMAGE_FLAGS.LOADMAP3DCOLORS;
pub const LR_LOADTRANSPARENT = IMAGE_FLAGS.LOADTRANSPARENT;
pub const LR_MONOCHROME = IMAGE_FLAGS.MONOCHROME;
pub const LR_SHARED = IMAGE_FLAGS.SHARED;
pub const LR_VGACOLOR = IMAGE_FLAGS.VGACOLOR;
pub const LR_COPYDELETEORG = IMAGE_FLAGS.COPYDELETEORG;
pub const LR_COPYFROMRESOURCE = IMAGE_FLAGS.COPYFROMRESOURCE;
pub const LR_COPYRETURNORG = IMAGE_FLAGS.COPYRETURNORG;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DLG_DIR_LIST_FILE_TYPE = extern enum(u32) {
    ARCHIVE = 32,
    DIRECTORY = 16,
    DRIVES = 16384,
    EXCLUSIVE = 32768,
    HIDDEN = 2,
    READONLY = 1,
    READWRITE = 0,
    SYSTEM = 4,
    POSTMSGS = 8192,
    _,
};
pub const DDL_ARCHIVE = DLG_DIR_LIST_FILE_TYPE.ARCHIVE;
pub const DDL_DIRECTORY = DLG_DIR_LIST_FILE_TYPE.DIRECTORY;
pub const DDL_DRIVES = DLG_DIR_LIST_FILE_TYPE.DRIVES;
pub const DDL_EXCLUSIVE = DLG_DIR_LIST_FILE_TYPE.EXCLUSIVE;
pub const DDL_HIDDEN = DLG_DIR_LIST_FILE_TYPE.HIDDEN;
pub const DDL_READONLY = DLG_DIR_LIST_FILE_TYPE.READONLY;
pub const DDL_READWRITE = DLG_DIR_LIST_FILE_TYPE.READWRITE;
pub const DDL_SYSTEM = DLG_DIR_LIST_FILE_TYPE.SYSTEM;
pub const DDL_POSTMSGS = DLG_DIR_LIST_FILE_TYPE.POSTMSGS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const OPEN_THEME_DATA_FLAGS = extern enum(u32) {
    FORCE_RECT_SIZING = 1,
    NONCLIENT = 2,
    _,
};
pub const OTD_FORCE_RECT_SIZING = OPEN_THEME_DATA_FLAGS.FORCE_RECT_SIZING;
pub const OTD_NONCLIENT = OPEN_THEME_DATA_FLAGS.NONCLIENT;

pub const GET_THEME_BITMAP_FLAGS = extern enum(u32) {
    DIRECT = 1,
    COPY = 2,
    VALIDBITS = 3,
};
pub const GBF_DIRECT = GET_THEME_BITMAP_FLAGS.DIRECT;
pub const GBF_COPY = GET_THEME_BITMAP_FLAGS.COPY;
pub const GBF_VALIDBITS = GET_THEME_BITMAP_FLAGS.VALIDBITS;

pub const ENABLE_SCROLL_BAR_ARROWS = extern enum(u32) {
    DISABLE_BOTH = 3,
    DISABLE_DOWN = 2,
    DISABLE_LEFT = 1,
    DISABLE_LTUP = 1,
    DISABLE_RIGHT = 2,
    DISABLE_RTDN = 2,
    DISABLE_UP = 1,
    ENABLE_BOTH = 0,
};
pub const ESB_DISABLE_BOTH = ENABLE_SCROLL_BAR_ARROWS.DISABLE_BOTH;
pub const ESB_DISABLE_DOWN = ENABLE_SCROLL_BAR_ARROWS.DISABLE_DOWN;
pub const ESB_DISABLE_LEFT = ENABLE_SCROLL_BAR_ARROWS.DISABLE_LEFT;
pub const ESB_DISABLE_LTUP = ENABLE_SCROLL_BAR_ARROWS.DISABLE_LTUP;
pub const ESB_DISABLE_RIGHT = ENABLE_SCROLL_BAR_ARROWS.DISABLE_RIGHT;
pub const ESB_DISABLE_RTDN = ENABLE_SCROLL_BAR_ARROWS.DISABLE_RTDN;
pub const ESB_DISABLE_UP = ENABLE_SCROLL_BAR_ARROWS.DISABLE_UP;
pub const ESB_ENABLE_BOTH = ENABLE_SCROLL_BAR_ARROWS.ENABLE_BOTH;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const IMAGE_LIST_DRAW_STYLE = extern enum(u32) {
    BLEND = 4,
    BLEND50 = 4,
    FOCUS = 2,
    MASK = 16,
    NORMAL = 0,
    SELECTED = 4,
    _,
};
pub const ILD_BLEND = IMAGE_LIST_DRAW_STYLE.BLEND;
pub const ILD_BLEND50 = IMAGE_LIST_DRAW_STYLE.BLEND50;
pub const ILD_FOCUS = IMAGE_LIST_DRAW_STYLE.FOCUS;
pub const ILD_MASK = IMAGE_LIST_DRAW_STYLE.MASK;
pub const ILD_NORMAL = IMAGE_LIST_DRAW_STYLE.NORMAL;
pub const ILD_SELECTED = IMAGE_LIST_DRAW_STYLE.SELECTED;

pub const WSB_PROP = extern enum(i32) {
    CXHSCROLL = 2,
    CXHTHUMB = 16,
    CXVSCROLL = 8,
    CYHSCROLL = 4,
    CYVSCROLL = 1,
    CYVTHUMB = 32,
    HBKGCOLOR = 128,
    HSTYLE = 512,
    PALETTE = 2048,
    VBKGCOLOR = 64,
    VSTYLE = 256,
    WINSTYLE = 1024,
};
pub const WSB_PROP_CXHSCROLL = WSB_PROP.CXHSCROLL;
pub const WSB_PROP_CXHTHUMB = WSB_PROP.CXHTHUMB;
pub const WSB_PROP_CXVSCROLL = WSB_PROP.CXVSCROLL;
pub const WSB_PROP_CYHSCROLL = WSB_PROP.CYHSCROLL;
pub const WSB_PROP_CYVSCROLL = WSB_PROP.CYVSCROLL;
pub const WSB_PROP_CYVTHUMB = WSB_PROP.CYVTHUMB;
pub const WSB_PROP_HBKGCOLOR = WSB_PROP.HBKGCOLOR;
pub const WSB_PROP_HSTYLE = WSB_PROP.HSTYLE;
pub const WSB_PROP_PALETTE = WSB_PROP.PALETTE;
pub const WSB_PROP_VBKGCOLOR = WSB_PROP.VBKGCOLOR;
pub const WSB_PROP_VSTYLE = WSB_PROP.VSTYLE;
pub const WSB_PROP_WINSTYLE = WSB_PROP.WINSTYLE;

pub const PSPCB_MESSAGE = extern enum(u32) {
    ADDREF = 0,
    CREATE = 2,
    RELEASE = 1,
    SI_INITDIALOG = 1025,
};
pub const PSPCB_ADDREF = PSPCB_MESSAGE.ADDREF;
pub const PSPCB_CREATE = PSPCB_MESSAGE.CREATE;
pub const PSPCB_RELEASE = PSPCB_MESSAGE.RELEASE;
pub const PSPCB_SI_INITDIALOG = PSPCB_MESSAGE.SI_INITDIALOG;

pub const HEADER_CONTROL_NOTIFICATION_BUTTON = extern enum(u32) {
    None = 0,
    @"1" = 1,
    @"2" = 2,
};
pub const iButton1 = HEADER_CONTROL_NOTIFICATION_BUTTON.@"1";
pub const iButton2 = HEADER_CONTROL_NOTIFICATION_BUTTON.@"2";

pub const IMAGE_LIST_COPY_FLAGS = extern enum(u32) {
    MOVE = 0,
    SWAP = 1,
};
pub const ILCF_MOVE = IMAGE_LIST_COPY_FLAGS.MOVE;
pub const ILCF_SWAP = IMAGE_LIST_COPY_FLAGS.SWAP;

pub const DLG_BUTTON_CHECK_STATE = extern enum(u32) {
    CHECKED = 1,
    INDETERMINATE = 2,
    UNCHECKED = 0,
};
pub const BST_CHECKED = DLG_BUTTON_CHECK_STATE.CHECKED;
pub const BST_INDETERMINATE = DLG_BUTTON_CHECK_STATE.INDETERMINATE;
pub const BST_UNCHECKED = DLG_BUTTON_CHECK_STATE.UNCHECKED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DRAW_THEME_PARENT_BACKGROUND_FLAGS = extern enum(u32) {
    WINDOWDC = 1,
    USECTLCOLORSTATIC = 2,
    USEERASEBKGND = 4,
    _,
};
pub const DTPB_WINDOWDC = DRAW_THEME_PARENT_BACKGROUND_FLAGS.WINDOWDC;
pub const DTPB_USECTLCOLORSTATIC = DRAW_THEME_PARENT_BACKGROUND_FLAGS.USECTLCOLORSTATIC;
pub const DTPB_USEERASEBKGND = DRAW_THEME_PARENT_BACKGROUND_FLAGS.USEERASEBKGND;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE = extern enum(u32) {
    SEL_EMPTY = 0,
    SEL_TEXT = 1,
    SEL_OBJECT = 2,
    SEL_MULTICHAR = 4,
    SEL_MULTIOBJECT = 8,
    GCM_RIGHTMOUSEDROP = 32768,
    _,
};
pub const SEL_EMPTY = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY;
pub const SEL_TEXT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT;
pub const SEL_OBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT;
pub const SEL_MULTICHAR = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR;
pub const SEL_MULTIOBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT;
pub const GCM_RIGHTMOUSEDROP = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const RICH_EDIT_GET_OBJECT_FLAGS = extern enum(u32) {
    POLEOBJ = 1,
    PSTG = 2,
    POLESITE = 4,
    NO_INTERFACES = 0,
    ALL_INTERFACES = 7,
    _,
};
pub const REO_GETOBJ_POLEOBJ = RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ;
pub const REO_GETOBJ_PSTG = RICH_EDIT_GET_OBJECT_FLAGS.PSTG;
pub const REO_GETOBJ_POLESITE = RICH_EDIT_GET_OBJECT_FLAGS.POLESITE;
pub const REO_GETOBJ_NO_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES;
pub const REO_GETOBJ_ALL_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const HDI_MASK = extern enum(u32) {
    WIDTH = 1,
    HEIGHT = 1,
    TEXT = 2,
    FORMAT = 4,
    LPARAM = 8,
    BITMAP = 16,
    IMAGE = 32,
    DI_SETITEM = 64,
    ORDER = 128,
    FILTER = 256,
    STATE = 512,
    _,
};
pub const HDI_WIDTH = HDI_MASK.WIDTH;
pub const HDI_HEIGHT = HDI_MASK.HEIGHT;
pub const HDI_TEXT = HDI_MASK.TEXT;
pub const HDI_FORMAT = HDI_MASK.FORMAT;
pub const HDI_LPARAM = HDI_MASK.LPARAM;
pub const HDI_BITMAP = HDI_MASK.BITMAP;
pub const HDI_IMAGE = HDI_MASK.IMAGE;
pub const HDI_DI_SETITEM = HDI_MASK.DI_SETITEM;
pub const HDI_ORDER = HDI_MASK.ORDER;
pub const HDI_FILTER = HDI_MASK.FILTER;
pub const HDI_STATE = HDI_MASK.STATE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NMREBAR_MASK_FLAGS = extern enum(u32) {
    ID = 1,
    LPARAM = 4,
    STYLE = 2,
    _,
};
pub const RBNM_ID = NMREBAR_MASK_FLAGS.ID;
pub const RBNM_LPARAM = NMREBAR_MASK_FLAGS.LPARAM;
pub const RBNM_STYLE = NMREBAR_MASK_FLAGS.STYLE;

pub const EDITBALLOONTIP_ICON = extern enum(u32) {
    ERROR = 3,
    INFO = 1,
    NONE = 0,
    WARNING = 2,
    INFO_LARGE = 4,
    WARNING_LARGE = 5,
    ERROR_LARGE = 6,
};
pub const TTI_ERROR = EDITBALLOONTIP_ICON.ERROR;
pub const TTI_INFO = EDITBALLOONTIP_ICON.INFO;
pub const TTI_NONE = EDITBALLOONTIP_ICON.NONE;
pub const TTI_WARNING = EDITBALLOONTIP_ICON.WARNING;
pub const TTI_INFO_LARGE = EDITBALLOONTIP_ICON.INFO_LARGE;
pub const TTI_WARNING_LARGE = EDITBALLOONTIP_ICON.WARNING_LARGE;
pub const TTI_ERROR_LARGE = EDITBALLOONTIP_ICON.ERROR_LARGE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LVCOLUMNW_FORMAT = extern enum(u32) {
    LEFT = 0,
    RIGHT = 1,
    CENTER = 2,
    JUSTIFYMASK = 3,
    IMAGE = 2048,
    BITMAP_ON_RIGHT = 4096,
    COL_HAS_IMAGES = 32768,
    FIXED_WIDTH = 256,
    NO_DPI_SCALE = 262144,
    FIXED_RATIO = 524288,
    SPLITBUTTON = 16777216,
    _,
};
pub const LVCFMT_LEFT = LVCOLUMNW_FORMAT.LEFT;
pub const LVCFMT_RIGHT = LVCOLUMNW_FORMAT.RIGHT;
pub const LVCFMT_CENTER = LVCOLUMNW_FORMAT.CENTER;
pub const LVCFMT_JUSTIFYMASK = LVCOLUMNW_FORMAT.JUSTIFYMASK;
pub const LVCFMT_IMAGE = LVCOLUMNW_FORMAT.IMAGE;
pub const LVCFMT_BITMAP_ON_RIGHT = LVCOLUMNW_FORMAT.BITMAP_ON_RIGHT;
pub const LVCFMT_COL_HAS_IMAGES = LVCOLUMNW_FORMAT.COL_HAS_IMAGES;
pub const LVCFMT_FIXED_WIDTH = LVCOLUMNW_FORMAT.FIXED_WIDTH;
pub const LVCFMT_NO_DPI_SCALE = LVCOLUMNW_FORMAT.NO_DPI_SCALE;
pub const LVCFMT_FIXED_RATIO = LVCOLUMNW_FORMAT.FIXED_RATIO;
pub const LVCFMT_SPLITBUTTON = LVCOLUMNW_FORMAT.SPLITBUTTON;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NMPGSCROLL_KEYS = extern enum(u32) {
    None = 0,
    SHIFT = 1,
    CONTROL = 2,
    MENU = 4,
    _,
};
pub const PGK_SHIFT = NMPGSCROLL_KEYS.SHIFT;
pub const PGK_CONTROL = NMPGSCROLL_KEYS.CONTROL;
pub const PGK_MENU = NMPGSCROLL_KEYS.MENU;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const COMBOBOX_EX_ITEM_FLAGS = extern enum(u32) {
    DI_SETITEM = 268435456,
    IMAGE = 2,
    INDENT = 16,
    LPARAM = 32,
    OVERLAY = 8,
    SELECTEDIMAGE = 4,
    TEXT = 1,
    _,
};
pub const CBEIF_DI_SETITEM = COMBOBOX_EX_ITEM_FLAGS.DI_SETITEM;
pub const CBEIF_IMAGE = COMBOBOX_EX_ITEM_FLAGS.IMAGE;
pub const CBEIF_INDENT = COMBOBOX_EX_ITEM_FLAGS.INDENT;
pub const CBEIF_LPARAM = COMBOBOX_EX_ITEM_FLAGS.LPARAM;
pub const CBEIF_OVERLAY = COMBOBOX_EX_ITEM_FLAGS.OVERLAY;
pub const CBEIF_SELECTEDIMAGE = COMBOBOX_EX_ITEM_FLAGS.SELECTEDIMAGE;
pub const CBEIF_TEXT = COMBOBOX_EX_ITEM_FLAGS.TEXT;

pub const TVITEMEXW_CHILDREN = extern enum(i32) {
    ZERO = 0,
    ONE_OR_MORE = 1,
    CHILDRENCALLBACK = -1,
    CHILDRENAUTO = -2,
};
pub const I_ZERO = TVITEMEXW_CHILDREN.ZERO;
pub const I_ONE_OR_MORE = TVITEMEXW_CHILDREN.ONE_OR_MORE;
pub const I_CHILDRENCALLBACK = TVITEMEXW_CHILDREN.CHILDRENCALLBACK;
pub const I_CHILDRENAUTO = TVITEMEXW_CHILDREN.CHILDRENAUTO;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TVITEM_MASK = extern enum(u32) {
    CHILDREN = 64,
    DI_SETITEM = 4096,
    HANDLE = 16,
    IMAGE = 2,
    PARAM = 4,
    SELECTEDIMAGE = 32,
    STATE = 8,
    TEXT = 1,
    EXPANDEDIMAGE = 512,
    INTEGRAL = 128,
    STATEEX = 256,
    _,
};
pub const TVIF_CHILDREN = TVITEM_MASK.CHILDREN;
pub const TVIF_DI_SETITEM = TVITEM_MASK.DI_SETITEM;
pub const TVIF_HANDLE = TVITEM_MASK.HANDLE;
pub const TVIF_IMAGE = TVITEM_MASK.IMAGE;
pub const TVIF_PARAM = TVITEM_MASK.PARAM;
pub const TVIF_SELECTEDIMAGE = TVITEM_MASK.SELECTEDIMAGE;
pub const TVIF_STATE = TVITEM_MASK.STATE;
pub const TVIF_TEXT = TVITEM_MASK.TEXT;
pub const TVIF_EXPANDEDIMAGE = TVITEM_MASK.EXPANDEDIMAGE;
pub const TVIF_INTEGRAL = TVITEM_MASK.INTEGRAL;
pub const TVIF_STATEEX = TVITEM_MASK.STATEEX;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TCITEMHEADERA_MASK = extern enum(u32) {
    IMAGE = 2,
    RTLREADING = 4,
    TEXT = 1,
    PARAM = 8,
    STATE = 16,
    _,
};
pub const TCIF_IMAGE = TCITEMHEADERA_MASK.IMAGE;
pub const TCIF_RTLREADING = TCITEMHEADERA_MASK.RTLREADING;
pub const TCIF_TEXT = TCITEMHEADERA_MASK.TEXT;
pub const TCIF_PARAM = TCITEMHEADERA_MASK.PARAM;
pub const TCIF_STATE = TCITEMHEADERA_MASK.STATE;

pub const TCHITTESTINFO_FLAGS = extern enum(u32) {
    NOWHERE = 1,
    ONITEM = 6,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
};
pub const TCHT_NOWHERE = TCHITTESTINFO_FLAGS.NOWHERE;
pub const TCHT_ONITEM = TCHITTESTINFO_FLAGS.ONITEM;
pub const TCHT_ONITEMICON = TCHITTESTINFO_FLAGS.ONITEMICON;
pub const TCHT_ONITEMLABEL = TCHITTESTINFO_FLAGS.ONITEMLABEL;

pub const COMBOBOXINFO_BUTTON_STATE = extern enum(u32) {
    INVISIBLE = 32768,
    PRESSED = 8,
    FOCUSABLE = 1048576,
    OFFSCREEN = 65536,
    UNAVAILABLE = 1,
};
pub const STATE_SYSTEM_INVISIBLE = COMBOBOXINFO_BUTTON_STATE.INVISIBLE;
pub const STATE_SYSTEM_PRESSED = COMBOBOXINFO_BUTTON_STATE.PRESSED;
pub const STATE_SYSTEM_FOCUSABLE = COMBOBOXINFO_BUTTON_STATE.FOCUSABLE;
pub const STATE_SYSTEM_OFFSCREEN = COMBOBOXINFO_BUTTON_STATE.OFFSCREEN;
pub const STATE_SYSTEM_UNAVAILABLE = COMBOBOXINFO_BUTTON_STATE.UNAVAILABLE;

pub const NMCUSTOMDRAW_DRAW_STAGE = extern enum(u32) {
    POSTPAINT = 2,
    PREERASE = 3,
    PREPAINT = 1,
    ITEMPOSTERASE = 65540,
    ITEMPOSTPAINT = 65538,
    ITEMPREERASE = 65539,
    ITEMPREPAINT = 65537,
    SUBITEM = 131072,
};
pub const CDDS_POSTPAINT = NMCUSTOMDRAW_DRAW_STAGE.POSTPAINT;
pub const CDDS_PREERASE = NMCUSTOMDRAW_DRAW_STAGE.PREERASE;
pub const CDDS_PREPAINT = NMCUSTOMDRAW_DRAW_STAGE.PREPAINT;
pub const CDDS_ITEMPOSTERASE = NMCUSTOMDRAW_DRAW_STAGE.ITEMPOSTERASE;
pub const CDDS_ITEMPOSTPAINT = NMCUSTOMDRAW_DRAW_STAGE.ITEMPOSTPAINT;
pub const CDDS_ITEMPREERASE = NMCUSTOMDRAW_DRAW_STAGE.ITEMPREERASE;
pub const CDDS_ITEMPREPAINT = NMCUSTOMDRAW_DRAW_STAGE.ITEMPREPAINT;
pub const CDDS_SUBITEM = NMCUSTOMDRAW_DRAW_STAGE.SUBITEM;

pub const MCGRIDINFO_PART = extern enum(u32) {
    CALENDARCONTROL = 0,
    NEXT = 1,
    PREV = 2,
    FOOTER = 3,
    CALENDAR = 4,
    CALENDARHEADER = 5,
    CALENDARBODY = 6,
    CALENDARROW = 7,
    CALENDARCELL = 8,
};
pub const MCGIP_CALENDARCONTROL = MCGRIDINFO_PART.CALENDARCONTROL;
pub const MCGIP_NEXT = MCGRIDINFO_PART.NEXT;
pub const MCGIP_PREV = MCGRIDINFO_PART.PREV;
pub const MCGIP_FOOTER = MCGRIDINFO_PART.FOOTER;
pub const MCGIP_CALENDAR = MCGRIDINFO_PART.CALENDAR;
pub const MCGIP_CALENDARHEADER = MCGRIDINFO_PART.CALENDARHEADER;
pub const MCGIP_CALENDARBODY = MCGRIDINFO_PART.CALENDARBODY;
pub const MCGIP_CALENDARROW = MCGRIDINFO_PART.CALENDARROW;
pub const MCGIP_CALENDARCELL = MCGRIDINFO_PART.CALENDARCELL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PARAFORMAT_BORDERS = extern enum(u32) {
    @"1" = 1,
    @"2" = 2,
    @"4" = 4,
    @"8" = 8,
    @"16" = 16,
    @"32" = 32,
    @"64" = 64,
    _,
};
pub const wBorders1 = PARAFORMAT_BORDERS.@"1";
pub const wBorders2 = PARAFORMAT_BORDERS.@"2";
pub const wBorders4 = PARAFORMAT_BORDERS.@"4";
pub const wBorders8 = PARAFORMAT_BORDERS.@"8";
pub const wBorders16 = PARAFORMAT_BORDERS.@"16";
pub const wBorders32 = PARAFORMAT_BORDERS.@"32";
pub const wBorders64 = PARAFORMAT_BORDERS.@"64";

pub const LVITEMA_GROUP_ID = extern enum(i32) {
    CALLBACK = -1,
    NONE = -2,
};
pub const I_GROUPIDCALLBACK = LVITEMA_GROUP_ID.CALLBACK;
pub const I_GROUPIDNONE = LVITEMA_GROUP_ID.NONE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NMTBHOTITEM_FLAGS = extern enum(u32) {
    ACCELERATOR = 4,
    ARROWKEYS = 2,
    DUPACCEL = 8,
    ENTERING = 16,
    LEAVING = 32,
    LMOUSE = 128,
    MOUSE = 1,
    OTHER = 0,
    RESELECT = 64,
    TOGGLEDROPDOWN = 256,
    _,
};
pub const HICF_ACCELERATOR = NMTBHOTITEM_FLAGS.ACCELERATOR;
pub const HICF_ARROWKEYS = NMTBHOTITEM_FLAGS.ARROWKEYS;
pub const HICF_DUPACCEL = NMTBHOTITEM_FLAGS.DUPACCEL;
pub const HICF_ENTERING = NMTBHOTITEM_FLAGS.ENTERING;
pub const HICF_LEAVING = NMTBHOTITEM_FLAGS.LEAVING;
pub const HICF_LMOUSE = NMTBHOTITEM_FLAGS.LMOUSE;
pub const HICF_MOUSE = NMTBHOTITEM_FLAGS.MOUSE;
pub const HICF_OTHER = NMTBHOTITEM_FLAGS.OTHER;
pub const HICF_RESELECT = NMTBHOTITEM_FLAGS.RESELECT;
pub const HICF_TOGGLEDROPDOWN = NMTBHOTITEM_FLAGS.TOGGLEDROPDOWN;

pub const LVTILEVIEWINFO_FLAGS = extern enum(u32) {
    D = 4,
};
pub const LVTVIF_EXTENDED = LVTILEVIEWINFO_FLAGS.D;

pub const NMPGSCROLL_DIR = extern enum(u32) {
    DOWN = 2,
    LEFT = 4,
    RIGHT = 8,
    UP = 1,
};
pub const PGF_SCROLLDOWN = NMPGSCROLL_DIR.DOWN;
pub const PGF_SCROLLLEFT = NMPGSCROLL_DIR.LEFT;
pub const PGF_SCROLLRIGHT = NMPGSCROLL_DIR.RIGHT;
pub const PGF_SCROLLUP = NMPGSCROLL_DIR.UP;

pub const PARAFORMAT_SHADING_STYLE = extern enum(u32) {
    None = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
};
pub const wShadingStyle1 = PARAFORMAT_SHADING_STYLE.@"1";
pub const wShadingStyle2 = PARAFORMAT_SHADING_STYLE.@"2";
pub const wShadingStyle3 = PARAFORMAT_SHADING_STYLE.@"3";
pub const wShadingStyle4 = PARAFORMAT_SHADING_STYLE.@"4";
pub const wShadingStyle5 = PARAFORMAT_SHADING_STYLE.@"5";
pub const wShadingStyle6 = PARAFORMAT_SHADING_STYLE.@"6";
pub const wShadingStyle7 = PARAFORMAT_SHADING_STYLE.@"7";
pub const wShadingStyle8 = PARAFORMAT_SHADING_STYLE.@"8";
pub const wShadingStyle9 = PARAFORMAT_SHADING_STYLE.@"9";
pub const wShadingStyle10 = PARAFORMAT_SHADING_STYLE.@"10";
pub const wShadingStyle11 = PARAFORMAT_SHADING_STYLE.@"11";
pub const wShadingStyle12 = PARAFORMAT_SHADING_STYLE.@"12";

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LVCOLUMNW_MASK = extern enum(u32) {
    FMT = 1,
    WIDTH = 2,
    TEXT = 4,
    SUBITEM = 8,
    IMAGE = 16,
    ORDER = 32,
    MINWIDTH = 64,
    DEFAULTWIDTH = 128,
    IDEALWIDTH = 256,
    _,
};
pub const LVCF_FMT = LVCOLUMNW_MASK.FMT;
pub const LVCF_WIDTH = LVCOLUMNW_MASK.WIDTH;
pub const LVCF_TEXT = LVCOLUMNW_MASK.TEXT;
pub const LVCF_SUBITEM = LVCOLUMNW_MASK.SUBITEM;
pub const LVCF_IMAGE = LVCOLUMNW_MASK.IMAGE;
pub const LVCF_ORDER = LVCOLUMNW_MASK.ORDER;
pub const LVCF_MINWIDTH = LVCOLUMNW_MASK.MINWIDTH;
pub const LVCF_DEFAULTWIDTH = LVCOLUMNW_MASK.DEFAULTWIDTH;
pub const LVCF_IDEALWIDTH = LVCOLUMNW_MASK.IDEALWIDTH;

pub const GETTEXTEX_FLAGS = extern enum(u32) {
    DEFAULT = 0,
    NOHIDDENTEXT = 8,
    RAWTEXT = 4,
    SELECTION = 2,
    USECRLF = 1,
};
pub const GT_DEFAULT = GETTEXTEX_FLAGS.DEFAULT;
pub const GT_NOHIDDENTEXT = GETTEXTEX_FLAGS.NOHIDDENTEXT;
pub const GT_RAWTEXT = GETTEXTEX_FLAGS.RAWTEXT;
pub const GT_SELECTION = GETTEXTEX_FLAGS.SELECTION;
pub const GT_USECRLF = GETTEXTEX_FLAGS.USECRLF;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LVFINDINFOW_FLAGS = extern enum(u32) {
    PARAM = 1,
    PARTIAL = 8,
    STRING = 2,
    SUBSTRING = 4,
    WRAP = 32,
    NEARESTXY = 64,
    _,
};
pub const LVFI_PARAM = LVFINDINFOW_FLAGS.PARAM;
pub const LVFI_PARTIAL = LVFINDINFOW_FLAGS.PARTIAL;
pub const LVFI_STRING = LVFINDINFOW_FLAGS.STRING;
pub const LVFI_SUBSTRING = LVFINDINFOW_FLAGS.SUBSTRING;
pub const LVFI_WRAP = LVFINDINFOW_FLAGS.WRAP;
pub const LVFI_NEARESTXY = LVFINDINFOW_FLAGS.NEARESTXY;

pub const BUTTON_IMAGELIST_ALIGN = extern enum(u32) {
    LEFT = 0,
    RIGHT = 1,
    TOP = 2,
    BOTTOM = 3,
    CENTER = 4,
};
pub const BUTTON_IMAGELIST_ALIGN_LEFT = BUTTON_IMAGELIST_ALIGN.LEFT;
pub const BUTTON_IMAGELIST_ALIGN_RIGHT = BUTTON_IMAGELIST_ALIGN.RIGHT;
pub const BUTTON_IMAGELIST_ALIGN_TOP = BUTTON_IMAGELIST_ALIGN.TOP;
pub const BUTTON_IMAGELIST_ALIGN_BOTTOM = BUTTON_IMAGELIST_ALIGN.BOTTOM;
pub const BUTTON_IMAGELIST_ALIGN_CENTER = BUTTON_IMAGELIST_ALIGN.CENTER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TBBUTTONINFOW_MASK = extern enum(u32) {
    BYINDEX = 2147483648,
    COMMAND = 32,
    IMAGE = 1,
    LPARAM = 16,
    SIZE = 64,
    STATE = 4,
    STYLE = 8,
    TEXT = 2,
    _,
};
pub const TBIF_BYINDEX = TBBUTTONINFOW_MASK.BYINDEX;
pub const TBIF_COMMAND = TBBUTTONINFOW_MASK.COMMAND;
pub const TBIF_IMAGE = TBBUTTONINFOW_MASK.IMAGE;
pub const TBIF_LPARAM = TBBUTTONINFOW_MASK.LPARAM;
pub const TBIF_SIZE = TBBUTTONINFOW_MASK.SIZE;
pub const TBIF_STATE = TBBUTTONINFOW_MASK.STATE;
pub const TBIF_STYLE = TBBUTTONINFOW_MASK.STYLE;
pub const TBIF_TEXT = TBBUTTONINFOW_MASK.TEXT;

pub const TBINSERTMARK_FLAGS = extern enum(u32) {
    None = 0,
    AFTER = 1,
    BACKGROUND = 2,
};
pub const TBIMHT_AFTER = TBINSERTMARK_FLAGS.AFTER;
pub const TBIMHT_BACKGROUND = TBINSERTMARK_FLAGS.BACKGROUND;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LVGROUP_MASK = extern enum(u32) {
    NONE = 0,
    HEADER = 1,
    FOOTER = 2,
    STATE = 4,
    _,
};
pub const LVGF_NONE = LVGROUP_MASK.NONE;
pub const LVGF_HEADER = LVGROUP_MASK.HEADER;
pub const LVGF_FOOTER = LVGROUP_MASK.FOOTER;
pub const LVGF_STATE = LVGROUP_MASK.STATE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const BP_PAINTPARAMS_FLAGS = extern enum(u32) {
    ERASE = 1,
    NOCLIP = 2,
    NONCLIENT = 4,
    _,
};
pub const BPPF_ERASE = BP_PAINTPARAMS_FLAGS.ERASE;
pub const BPPF_NOCLIP = BP_PAINTPARAMS_FLAGS.NOCLIP;
pub const BPPF_NONCLIENT = BP_PAINTPARAMS_FLAGS.NONCLIENT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TVHITTESTINFO_FLAGS = extern enum(u32) {
    ABOVE = 256,
    BELOW = 512,
    NOWHERE = 1,
    ONITEM = 70,
    ONITEMBUTTON = 16,
    ONITEMICON = 2,
    ONITEMINDENT = 8,
    ONITEMLABEL = 4,
    ONITEMRIGHT = 32,
    ONITEMSTATEICON = 64,
    TOLEFT = 2048,
    TORIGHT = 1024,
    _,
};
pub const TVHT_ABOVE = TVHITTESTINFO_FLAGS.ABOVE;
pub const TVHT_BELOW = TVHITTESTINFO_FLAGS.BELOW;
pub const TVHT_NOWHERE = TVHITTESTINFO_FLAGS.NOWHERE;
pub const TVHT_ONITEM = TVHITTESTINFO_FLAGS.ONITEM;
pub const TVHT_ONITEMBUTTON = TVHITTESTINFO_FLAGS.ONITEMBUTTON;
pub const TVHT_ONITEMICON = TVHITTESTINFO_FLAGS.ONITEMICON;
pub const TVHT_ONITEMINDENT = TVHITTESTINFO_FLAGS.ONITEMINDENT;
pub const TVHT_ONITEMLABEL = TVHITTESTINFO_FLAGS.ONITEMLABEL;
pub const TVHT_ONITEMRIGHT = TVHITTESTINFO_FLAGS.ONITEMRIGHT;
pub const TVHT_ONITEMSTATEICON = TVHITTESTINFO_FLAGS.ONITEMSTATEICON;
pub const TVHT_TOLEFT = TVHITTESTINFO_FLAGS.TOLEFT;
pub const TVHT_TORIGHT = TVHITTESTINFO_FLAGS.TORIGHT;

pub const DRAWITEMSTRUCT_CTL_TYPE = extern enum(u32) {
    BUTTON = 4,
    COMBOBOX = 3,
    LISTBOX = 2,
    LISTVIEW = 102,
    MENU = 1,
    STATIC = 5,
    TAB = 101,
};
pub const ODT_BUTTON = DRAWITEMSTRUCT_CTL_TYPE.BUTTON;
pub const ODT_COMBOBOX = DRAWITEMSTRUCT_CTL_TYPE.COMBOBOX;
pub const ODT_LISTBOX = DRAWITEMSTRUCT_CTL_TYPE.LISTBOX;
pub const ODT_LISTVIEW = DRAWITEMSTRUCT_CTL_TYPE.LISTVIEW;
pub const ODT_MENU = DRAWITEMSTRUCT_CTL_TYPE.MENU;
pub const ODT_STATIC = DRAWITEMSTRUCT_CTL_TYPE.STATIC;
pub const ODT_TAB = DRAWITEMSTRUCT_CTL_TYPE.TAB;

pub const NMPGCALCSIZE_FLAGS = extern enum(u32) {
    HEIGHT = 2,
    WIDTH = 1,
};
pub const PGF_CALCHEIGHT = NMPGCALCSIZE_FLAGS.HEIGHT;
pub const PGF_CALCWIDTH = NMPGCALCSIZE_FLAGS.WIDTH;

pub const ENDCOMPOSITIONNOTIFY_CODE = extern enum(u32) {
    ENDCOMPOSITION = 1,
    NEWTEXT = 2,
};
pub const ECN_ENDCOMPOSITION = ENDCOMPOSITIONNOTIFY_CODE.ENDCOMPOSITION;
pub const ECN_NEWTEXT = ENDCOMPOSITIONNOTIFY_CODE.NEWTEXT;

pub const NMLVCUSTOMDRAW_ALIGN = extern enum(u32) {
    CENTER = 2,
    LEFT = 1,
    RIGHT = 4,
};
pub const LVGA_HEADER_CENTER = NMLVCUSTOMDRAW_ALIGN.CENTER;
pub const LVGA_HEADER_LEFT = NMLVCUSTOMDRAW_ALIGN.LEFT;
pub const LVGA_HEADER_RIGHT = NMLVCUSTOMDRAW_ALIGN.RIGHT;

pub const IMECOMPTEXT_FLAGS = extern enum(u32) {
    R = 1,
};
pub const ICT_RESULTREADSTR = IMECOMPTEXT_FLAGS.R;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MCGRIDINFO_FLAGS = extern enum(u32) {
    DATE = 1,
    RECT = 2,
    NAME = 4,
    _,
};
pub const MCGIF_DATE = MCGRIDINFO_FLAGS.DATE;
pub const MCGIF_RECT = MCGRIDINFO_FLAGS.RECT;
pub const MCGIF_NAME = MCGRIDINFO_FLAGS.NAME;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GETTEXTLENGTHEX_FLAGS = extern enum(u32) {
    DEFAULT = 0,
    USECRLF = 1,
    PRECISE = 2,
    CLOSE = 4,
    NUMCHARS = 8,
    NUMBYTES = 16,
    _,
};
pub const GTL_DEFAULT = GETTEXTLENGTHEX_FLAGS.DEFAULT;
pub const GTL_USECRLF = GETTEXTLENGTHEX_FLAGS.USECRLF;
pub const GTL_PRECISE = GETTEXTLENGTHEX_FLAGS.PRECISE;
pub const GTL_CLOSE = GETTEXTLENGTHEX_FLAGS.CLOSE;
pub const GTL_NUMCHARS = GETTEXTLENGTHEX_FLAGS.NUMCHARS;
pub const GTL_NUMBYTES = GETTEXTLENGTHEX_FLAGS.NUMBYTES;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LVHITTESTINFO_FLAGS = extern enum(u32) {
    ABOVE = 8,
    BELOW = 16,
    NOWHERE = 1,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
    ONITEMSTATEICON = 8,
    TOLEFT = 64,
    TORIGHT = 32,
    EX_GROUP_HEADER = 268435456,
    EX_GROUP_FOOTER = 536870912,
    EX_GROUP_COLLAPSE = 1073741824,
    EX_GROUP_BACKGROUND = 2147483648,
    EX_GROUP_STATEICON = 16777216,
    EX_GROUP_SUBSETLINK = 33554432,
    EX_GROUP = 4076863488,
    EX_ONCONTENTS = 67108864,
    EX_FOOTER = 134217728,
    _,
};
pub const LVHT_ABOVE = LVHITTESTINFO_FLAGS.ABOVE;
pub const LVHT_BELOW = LVHITTESTINFO_FLAGS.BELOW;
pub const LVHT_NOWHERE = LVHITTESTINFO_FLAGS.NOWHERE;
pub const LVHT_ONITEMICON = LVHITTESTINFO_FLAGS.ONITEMICON;
pub const LVHT_ONITEMLABEL = LVHITTESTINFO_FLAGS.ONITEMLABEL;
pub const LVHT_ONITEMSTATEICON = LVHITTESTINFO_FLAGS.ONITEMSTATEICON;
pub const LVHT_TOLEFT = LVHITTESTINFO_FLAGS.TOLEFT;
pub const LVHT_TORIGHT = LVHITTESTINFO_FLAGS.TORIGHT;
pub const LVHT_EX_GROUP_HEADER = LVHITTESTINFO_FLAGS.EX_GROUP_HEADER;
pub const LVHT_EX_GROUP_FOOTER = LVHITTESTINFO_FLAGS.EX_GROUP_FOOTER;
pub const LVHT_EX_GROUP_COLLAPSE = LVHITTESTINFO_FLAGS.EX_GROUP_COLLAPSE;
pub const LVHT_EX_GROUP_BACKGROUND = LVHITTESTINFO_FLAGS.EX_GROUP_BACKGROUND;
pub const LVHT_EX_GROUP_STATEICON = LVHITTESTINFO_FLAGS.EX_GROUP_STATEICON;
pub const LVHT_EX_GROUP_SUBSETLINK = LVHITTESTINFO_FLAGS.EX_GROUP_SUBSETLINK;
pub const LVHT_EX_GROUP = LVHITTESTINFO_FLAGS.EX_GROUP;
pub const LVHT_EX_ONCONTENTS = LVHITTESTINFO_FLAGS.EX_ONCONTENTS;
pub const LVHT_EX_FOOTER = LVHITTESTINFO_FLAGS.EX_FOOTER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const INITCOMMONCONTROLSEX_ICC = extern enum(u32) {
    ANIMATE_CLASS = 128,
    BAR_CLASSES = 4,
    COOL_CLASSES = 1024,
    DATE_CLASSES = 256,
    HOTKEY_CLASS = 64,
    INTERNET_CLASSES = 2048,
    LINK_CLASS = 32768,
    LISTVIEW_CLASSES = 1,
    NATIVEFNTCTL_CLASS = 8192,
    PAGESCROLLER_CLASS = 4096,
    PROGRESS_CLASS = 32,
    STANDARD_CLASSES = 16384,
    TAB_CLASSES = 8,
    TREEVIEW_CLASSES = 2,
    UPDOWN_CLASS = 16,
    USEREX_CLASSES = 512,
    WIN95_CLASSES = 255,
    _,
};
pub const ICC_ANIMATE_CLASS = INITCOMMONCONTROLSEX_ICC.ANIMATE_CLASS;
pub const ICC_BAR_CLASSES = INITCOMMONCONTROLSEX_ICC.BAR_CLASSES;
pub const ICC_COOL_CLASSES = INITCOMMONCONTROLSEX_ICC.COOL_CLASSES;
pub const ICC_DATE_CLASSES = INITCOMMONCONTROLSEX_ICC.DATE_CLASSES;
pub const ICC_HOTKEY_CLASS = INITCOMMONCONTROLSEX_ICC.HOTKEY_CLASS;
pub const ICC_INTERNET_CLASSES = INITCOMMONCONTROLSEX_ICC.INTERNET_CLASSES;
pub const ICC_LINK_CLASS = INITCOMMONCONTROLSEX_ICC.LINK_CLASS;
pub const ICC_LISTVIEW_CLASSES = INITCOMMONCONTROLSEX_ICC.LISTVIEW_CLASSES;
pub const ICC_NATIVEFNTCTL_CLASS = INITCOMMONCONTROLSEX_ICC.NATIVEFNTCTL_CLASS;
pub const ICC_PAGESCROLLER_CLASS = INITCOMMONCONTROLSEX_ICC.PAGESCROLLER_CLASS;
pub const ICC_PROGRESS_CLASS = INITCOMMONCONTROLSEX_ICC.PROGRESS_CLASS;
pub const ICC_STANDARD_CLASSES = INITCOMMONCONTROLSEX_ICC.STANDARD_CLASSES;
pub const ICC_TAB_CLASSES = INITCOMMONCONTROLSEX_ICC.TAB_CLASSES;
pub const ICC_TREEVIEW_CLASSES = INITCOMMONCONTROLSEX_ICC.TREEVIEW_CLASSES;
pub const ICC_UPDOWN_CLASS = INITCOMMONCONTROLSEX_ICC.UPDOWN_CLASS;
pub const ICC_USEREX_CLASSES = INITCOMMONCONTROLSEX_ICC.USEREX_CLASSES;
pub const ICC_WIN95_CLASSES = INITCOMMONCONTROLSEX_ICC.WIN95_CLASSES;

pub const NMLVCUSTOMDRAW_ITEM_TYPE = extern enum(u32) {
    ITEM = 0,
    GROUP = 1,
    ITEMSLIST = 2,
};
pub const LVCDI_ITEM = NMLVCUSTOMDRAW_ITEM_TYPE.ITEM;
pub const LVCDI_GROUP = NMLVCUSTOMDRAW_ITEM_TYPE.GROUP;
pub const LVCDI_ITEMSLIST = NMLVCUSTOMDRAW_ITEM_TYPE.ITEMSLIST;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NMTBDISPINFOW_MASK = extern enum(u32) {
    IMAGE = 1,
    TEXT = 2,
    DI_SETITEM = 268435456,
    _,
};
pub const TBNF_IMAGE = NMTBDISPINFOW_MASK.IMAGE;
pub const TBNF_TEXT = NMTBDISPINFOW_MASK.TEXT;
pub const TBNF_DI_SETITEM = NMTBDISPINFOW_MASK.DI_SETITEM;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SCROLLINFO_MASK = extern enum(u32) {
    ALL = 23,
    DISABLENOSCROLL = 8,
    PAGE = 2,
    POS = 4,
    RANGE = 1,
    TRACKPOS = 16,
    _,
};
pub const SIF_ALL = SCROLLINFO_MASK.ALL;
pub const SIF_DISABLENOSCROLL = SCROLLINFO_MASK.DISABLENOSCROLL;
pub const SIF_PAGE = SCROLLINFO_MASK.PAGE;
pub const SIF_POS = SCROLLINFO_MASK.POS;
pub const SIF_RANGE = SCROLLINFO_MASK.RANGE;
pub const SIF_TRACKPOS = SCROLLINFO_MASK.TRACKPOS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const REOBJECT_FLAGS = extern enum(u32) {
    ALIGNTORIGHT = 256,
    BELOWBASELINE = 2,
    BLANK = 16,
    CANROTATE = 128,
    DONTNEEDPALETTE = 32,
    DYNAMICSIZE = 8,
    GETMETAFILE = 4194304,
    HILITED = 16777216,
    INPLACEACTIVE = 33554432,
    INVERTEDSELECT = 4,
    LINK = 2147483648,
    LINKAVAILABLE = 8388608,
    OPEN = 67108864,
    OWNERDRAWSELECT = 64,
    RESIZABLE = 1,
    SELECTED = 134217728,
    STATIC = 1073741824,
    USEASBACKGROUND = 1024,
    WRAPTEXTAROUND = 512,
    _,
};
pub const REO_ALIGNTORIGHT = REOBJECT_FLAGS.ALIGNTORIGHT;
pub const REO_BELOWBASELINE = REOBJECT_FLAGS.BELOWBASELINE;
pub const REO_BLANK = REOBJECT_FLAGS.BLANK;
pub const REO_CANROTATE = REOBJECT_FLAGS.CANROTATE;
pub const REO_DONTNEEDPALETTE = REOBJECT_FLAGS.DONTNEEDPALETTE;
pub const REO_DYNAMICSIZE = REOBJECT_FLAGS.DYNAMICSIZE;
pub const REO_GETMETAFILE = REOBJECT_FLAGS.GETMETAFILE;
pub const REO_HILITED = REOBJECT_FLAGS.HILITED;
pub const REO_INPLACEACTIVE = REOBJECT_FLAGS.INPLACEACTIVE;
pub const REO_INVERTEDSELECT = REOBJECT_FLAGS.INVERTEDSELECT;
pub const REO_LINK = REOBJECT_FLAGS.LINK;
pub const REO_LINKAVAILABLE = REOBJECT_FLAGS.LINKAVAILABLE;
pub const REO_OPEN = REOBJECT_FLAGS.OPEN;
pub const REO_OWNERDRAWSELECT = REOBJECT_FLAGS.OWNERDRAWSELECT;
pub const REO_RESIZABLE = REOBJECT_FLAGS.RESIZABLE;
pub const REO_SELECTED = REOBJECT_FLAGS.SELECTED;
pub const REO_STATIC = REOBJECT_FLAGS.STATIC;
pub const REO_USEASBACKGROUND = REOBJECT_FLAGS.USEASBACKGROUND;
pub const REO_WRAPTEXTAROUND = REOBJECT_FLAGS.WRAPTEXTAROUND;

pub const NMLVEMPTYMARKUP_FLAGS = extern enum(u32) {
    D = 1,
};
pub const EMF_CENTERED = NMLVEMPTYMARKUP_FLAGS.D;

pub const PARAFORMAT_NUMBERING_STYLE = extern enum(u32) {
    PAREN = 0,
    PARENS = 256,
    PERIOD = 512,
    PLAIN = 768,
    NONUMBER = 1024,
    NEWNUMBER = 32768,
};
pub const PFNS_PAREN = PARAFORMAT_NUMBERING_STYLE.PAREN;
pub const PFNS_PARENS = PARAFORMAT_NUMBERING_STYLE.PARENS;
pub const PFNS_PERIOD = PARAFORMAT_NUMBERING_STYLE.PERIOD;
pub const PFNS_PLAIN = PARAFORMAT_NUMBERING_STYLE.PLAIN;
pub const PFNS_NONUMBER = PARAFORMAT_NUMBERING_STYLE.NONUMBER;
pub const PFNS_NEWNUMBER = PARAFORMAT_NUMBERING_STYLE.NEWNUMBER;

pub const LVFOOTERITEM_MASK = extern enum(u32) {
    TEXT = 1,
    STATE = 2,
};
pub const LVFIF_TEXT = LVFOOTERITEM_MASK.TEXT;
pub const LVFIF_STATE = LVFOOTERITEM_MASK.STATE;

pub const PARAFORMAT_ALIGNMENT = extern enum(u32) {
    CENTER = 3,
    LEFT = 1,
    RIGHT = 2,
};
pub const PFA_CENTER = PARAFORMAT_ALIGNMENT.CENTER;
pub const PFA_LEFT = PARAFORMAT_ALIGNMENT.LEFT;
pub const PFA_RIGHT = PARAFORMAT_ALIGNMENT.RIGHT;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const TBBUTTON = extern struct {
    iBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsStyle: u8,
    bReserved: [2]u8,
    dwData: usize,
    iString: isize,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32,
    yHeight: i32,
    Ascent: i32,
    Type: i32,
    pwszAlternateText: [*:0]const u16,
    pIStream: *IStream,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR,
    dwCode: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE,
    lpstrText: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE,
    lpstrText: PWSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const EDITSTREAM = extern struct {
    dwCookie: usize,
    dwError: u32,
    pfnCallback: EDITSTREAMCALLBACK,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
    chrgText: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
    chrgText: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FORMATRANGE = extern struct {
    hdc: HDC,
    hdcTarget: HDC,
    rc: RECT,
    rcPage: RECT,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const MSGFILTER = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const REQRESIZE = extern struct {
    nmhdr: NMHDR,
    rc: RECT,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const SELCHANGE = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR,
    fGroupTyping: BOOL,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR,
    cf: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE,
    dwFlags: u32,
    pt: POINT,
    pvReserved: *c_void,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR,
    hDrop: HANDLE,
    cp: i32,
    fProtected: BOOL,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    cch: i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR,
    iob: i32,
    lOper: i32,
    hr: HRESULT,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    pcpPositions: *i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENLINK = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR,
    szControl: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const PUNCTUATION = extern struct {
    iSize: u32,
    szPunctuation: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const REPASTESPECIAL = extern struct {
    dwAspect: u32,
    dwParam: usize,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const GETTEXTEX = extern struct {
    cb: u32,
    flags: u32,
    codepage: u32,
    lpDefaultChar: [*:0]const u8,
    lpUsedDefChar: *i32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const HYPHENATEINFO = extern struct {
    cbSize: i16,
    dxHyphenateZone: i16,
    pfnHyphenate: isize,
};

}, else => struct { } };

pub const EDITWORDBREAKPROCA = fn(
    lpch: PSTR,
    ichCurrent: i32,
    cch: i32,
    code: WORD_BREAK_ACTION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EDITWORDBREAKPROCW = fn(
    lpch: PWSTR,
    ichCurrent: i32,
    cch: i32,
    code: WORD_BREAK_ACTION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NMHDR = extern struct {
    hwndFrom: HWND,
    idFrom: usize,
    code: u32,
};

pub const MEASUREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemWidth: u32,
    itemHeight: u32,
    itemData: usize,
};

pub const DRAWITEMSTRUCT = extern struct {
    CtlType: DRAWITEMSTRUCT_CTL_TYPE,
    CtlID: u32,
    itemID: u32,
    itemAction: u32,
    itemState: u32,
    hwndItem: HWND,
    hDC: HDC,
    rcItem: RECT,
    itemData: usize,
};

pub const DELETEITEMSTRUCT = extern struct {
    CtlType: DRAWITEMSTRUCT_CTL_TYPE,
    CtlID: u32,
    itemID: u32,
    hwndItem: HWND,
    itemData: usize,
};

pub const COMPAREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    hwndItem: HWND,
    itemID1: u32,
    itemData1: usize,
    itemID2: u32,
    itemData2: usize,
    dwLocaleId: u32,
};

pub const POINTER_FEEDBACK_MODE = extern enum(i32) {
    DEFAULT = 1,
    INDIRECT = 2,
    NONE = 3,
};
pub const POINTER_FEEDBACK_DEFAULT = POINTER_FEEDBACK_MODE.DEFAULT;
pub const POINTER_FEEDBACK_INDIRECT = POINTER_FEEDBACK_MODE.INDIRECT;
pub const POINTER_FEEDBACK_NONE = POINTER_FEEDBACK_MODE.NONE;

pub const USAGE_PROPERTIES = extern struct {
    level: u16,
    page: u16,
    usage: u16,
    logicalMinimum: i32,
    logicalMaximum: i32,
    unit: u16,
    exponent: u16,
    count: u8,
    physicalMinimum: i32,
    physicalMaximum: i32,
};

pub const POINTER_TYPE_INFO = extern struct {
    type: POINTER_INPUT_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const INPUT_INJECTION_VALUE = extern struct {
    page: u16,
    usage: u16,
    value: i32,
    index: u16,
};

pub const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = extern struct {
    score: u16,
    adjustedPoint: POINT,
};

pub const TOUCH_HIT_TESTING_INPUT = extern struct {
    pointerId: u32,
    point: POINT,
    boundingBox: RECT,
    nonOccludedBoundingBox: RECT,
    orientation: u32,
};

pub const FEEDBACK_TYPE = extern enum(i32) {
    TOUCH_CONTACTVISUALIZATION = 1,
    PEN_BARRELVISUALIZATION = 2,
    PEN_TAP = 3,
    PEN_DOUBLETAP = 4,
    PEN_PRESSANDHOLD = 5,
    PEN_RIGHTTAP = 6,
    TOUCH_TAP = 7,
    TOUCH_DOUBLETAP = 8,
    TOUCH_PRESSANDHOLD = 9,
    TOUCH_RIGHTTAP = 10,
    GESTURE_PRESSANDTAP = 11,
    MAX = -1,
};
pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION = FEEDBACK_TYPE.TOUCH_CONTACTVISUALIZATION;
pub const FEEDBACK_PEN_BARRELVISUALIZATION = FEEDBACK_TYPE.PEN_BARRELVISUALIZATION;
pub const FEEDBACK_PEN_TAP = FEEDBACK_TYPE.PEN_TAP;
pub const FEEDBACK_PEN_DOUBLETAP = FEEDBACK_TYPE.PEN_DOUBLETAP;
pub const FEEDBACK_PEN_PRESSANDHOLD = FEEDBACK_TYPE.PEN_PRESSANDHOLD;
pub const FEEDBACK_PEN_RIGHTTAP = FEEDBACK_TYPE.PEN_RIGHTTAP;
pub const FEEDBACK_TOUCH_TAP = FEEDBACK_TYPE.TOUCH_TAP;
pub const FEEDBACK_TOUCH_DOUBLETAP = FEEDBACK_TYPE.TOUCH_DOUBLETAP;
pub const FEEDBACK_TOUCH_PRESSANDHOLD = FEEDBACK_TYPE.TOUCH_PRESSANDHOLD;
pub const FEEDBACK_TOUCH_RIGHTTAP = FEEDBACK_TYPE.TOUCH_RIGHTTAP;
pub const FEEDBACK_GESTURE_PRESSANDTAP = FEEDBACK_TYPE.GESTURE_PRESSANDTAP;
pub const FEEDBACK_MAX = FEEDBACK_TYPE.MAX;

pub const SCROLLINFO = extern struct {
    cbSize: u32,
    fMask: SCROLLINFO_MASK,
    nMin: i32,
    nMax: i32,
    nPage: u32,
    nPos: i32,
    nTrackPos: i32,
};

pub const SCROLLBARINFO = extern struct {
    cbSize: u32,
    rcScrollBar: RECT,
    dxyLineButton: i32,
    xyThumbTop: i32,
    xyThumbBottom: i32,
    reserved: i32,
    rgstate: [6]u32,
};

pub const COMBOBOXINFO = extern struct {
    cbSize: u32,
    rcItem: RECT,
    rcButton: RECT,
    stateButton: COMBOBOXINFO_BUTTON_STATE,
    hwndCombo: HWND,
    hwndItem: HWND,
    hwndList: HWND,
};

pub const POINTER_DEVICE_TYPE = extern enum(i32) {
    INTEGRATED_PEN = 1,
    EXTERNAL_PEN = 2,
    TOUCH = 3,
    TOUCH_PAD = 4,
    MAX = -1,
};
pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN = POINTER_DEVICE_TYPE.INTEGRATED_PEN;
pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN = POINTER_DEVICE_TYPE.EXTERNAL_PEN;
pub const POINTER_DEVICE_TYPE_TOUCH = POINTER_DEVICE_TYPE.TOUCH;
pub const POINTER_DEVICE_TYPE_TOUCH_PAD = POINTER_DEVICE_TYPE.TOUCH_PAD;
pub const POINTER_DEVICE_TYPE_MAX = POINTER_DEVICE_TYPE.MAX;

pub const POINTER_DEVICE_INFO = extern struct {
    displayOrientation: u32,
    device: HANDLE,
    pointerDeviceType: POINTER_DEVICE_TYPE,
    monitor: HMONITOR,
    startingCursorId: u32,
    maxActiveContacts: u16,
    productString: [520]u16,
};

pub const POINTER_DEVICE_PROPERTY = extern struct {
    logicalMin: i32,
    logicalMax: i32,
    physicalMin: i32,
    physicalMax: i32,
    unit: u32,
    unitExponent: u32,
    usagePageId: u16,
    usageId: u16,
};

pub const POINTER_DEVICE_CURSOR_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    TIP = 1,
    ERASER = 2,
    MAX = -1,
};
pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = POINTER_DEVICE_CURSOR_TYPE.UNKNOWN;
pub const POINTER_DEVICE_CURSOR_TYPE_TIP = POINTER_DEVICE_CURSOR_TYPE.TIP;
pub const POINTER_DEVICE_CURSOR_TYPE_ERASER = POINTER_DEVICE_CURSOR_TYPE.ERASER;
pub const POINTER_DEVICE_CURSOR_TYPE_MAX = POINTER_DEVICE_CURSOR_TYPE.MAX;

pub const POINTER_DEVICE_CURSOR_INFO = extern struct {
    cursorId: u32,
    cursor: POINTER_DEVICE_CURSOR_TYPE,
};

pub const INPUT_MESSAGE_DEVICE_TYPE = extern enum(i32) {
    UNAVAILABLE = 0,
    KEYBOARD = 1,
    MOUSE = 2,
    TOUCH = 4,
    PEN = 8,
    TOUCHPAD = 16,
};
pub const IMDT_UNAVAILABLE = INPUT_MESSAGE_DEVICE_TYPE.UNAVAILABLE;
pub const IMDT_KEYBOARD = INPUT_MESSAGE_DEVICE_TYPE.KEYBOARD;
pub const IMDT_MOUSE = INPUT_MESSAGE_DEVICE_TYPE.MOUSE;
pub const IMDT_TOUCH = INPUT_MESSAGE_DEVICE_TYPE.TOUCH;
pub const IMDT_PEN = INPUT_MESSAGE_DEVICE_TYPE.PEN;
pub const IMDT_TOUCHPAD = INPUT_MESSAGE_DEVICE_TYPE.TOUCHPAD;

pub const INPUT_MESSAGE_ORIGIN_ID = extern enum(i32) {
    UNAVAILABLE = 0,
    HARDWARE = 1,
    INJECTED = 2,
    SYSTEM = 4,
};
pub const IMO_UNAVAILABLE = INPUT_MESSAGE_ORIGIN_ID.UNAVAILABLE;
pub const IMO_HARDWARE = INPUT_MESSAGE_ORIGIN_ID.HARDWARE;
pub const IMO_INJECTED = INPUT_MESSAGE_ORIGIN_ID.INJECTED;
pub const IMO_SYSTEM = INPUT_MESSAGE_ORIGIN_ID.SYSTEM;

pub const INPUT_MESSAGE_SOURCE = extern struct {
    deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    originId: INPUT_MESSAGE_ORIGIN_ID,
};


//--------------------------------------------------------------------------------
// Section: Functions (229)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreatePropertySheetPageA(
    constPropSheetPagePointer: *PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreatePropertySheetPageW(
    constPropSheetPagePointer: *PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DestroyPropertySheetPage(
    param0: HPROPSHEETPAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn PropertySheetA(
    param0: *PROPSHEETHEADERA_V2,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn PropertySheetW(
    param0: *PROPSHEETHEADERW_V2,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitCommonControls(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitCommonControlsEx(
    picce: *const INITCOMMONCONTROLSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Create(
    cx: i32,
    cy: i32,
    flags: u32,
    cInitial: i32,
    cGrow: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Destroy(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetImageCount(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetImageCount(
    himl: HIMAGELIST,
    uNewCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Add(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_ReplaceIcon(
    himl: HIMAGELIST,
    i: i32,
    hicon: HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetBkColor(
    himl: HIMAGELIST,
    clrBk: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetBkColor(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetOverlayImage(
    himl: HIMAGELIST,
    iImage: i32,
    iOverlay: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Draw(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    fStyle: IMAGE_LIST_DRAW_STYLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Replace(
    himl: HIMAGELIST,
    i: i32,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_AddMasked(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    crMask: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DrawEx(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: IMAGE_LIST_DRAW_STYLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DrawIndirect(
    pimldp: *IMAGELISTDRAWPARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Remove(
    himl: HIMAGELIST,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetIcon(
    himl: HIMAGELIST,
    i: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_LoadImageA(
    hi: HINSTANCE,
    lpbmp: [*:0]const u8,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: IMAGE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_LoadImageW(
    hi: HINSTANCE,
    lpbmp: [*:0]const u16,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: IMAGE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Copy(
    himlDst: HIMAGELIST,
    iDst: i32,
    himlSrc: HIMAGELIST,
    iSrc: i32,
    uFlags: IMAGE_LIST_COPY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_BeginDrag(
    himlTrack: HIMAGELIST,
    iTrack: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_EndDrag(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragEnter(
    hwndLock: HWND,
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragLeave(
    hwndLock: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragMove(
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetDragCursorImage(
    himlDrag: HIMAGELIST,
    iDrag: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_DragShowNolock(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetDragImage(
    ppt: ?*POINT,
    pptHotspot: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Read(
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Write(
    himl: HIMAGELIST,
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_ReadEx(
    dwFlags: u32,
    pstm: *IStream,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_WriteEx(
    himl: HIMAGELIST,
    dwFlags: u32,
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetIconSize(
    himl: HIMAGELIST,
    cx: ?*i32,
    cy: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_SetIconSize(
    himl: HIMAGELIST,
    cx: i32,
    cy: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_GetImageInfo(
    himl: HIMAGELIST,
    i: i32,
    pImageInfo: *IMAGEINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Merge(
    himl1: HIMAGELIST,
    i1: i32,
    himl2: HIMAGELIST,
    i2: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_Duplicate(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn HIMAGELIST_QueryInterface(
    himl: HIMAGELIST,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateToolbarEx(
    hwnd: HWND,
    ws: u32,
    wID: u32,
    nBitmaps: i32,
    hBMInst: HINSTANCE,
    wBMID: usize,
    lpButtons: *TBBUTTON,
    iNumButtons: i32,
    dxButton: i32,
    dyButton: i32,
    dxBitmap: i32,
    dyBitmap: i32,
    uStructSize: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateMappedBitmap(
    hInstance: HINSTANCE,
    idBitmap: isize,
    wFlags: u32,
    lpColorMap: ?*COLORMAP,
    iNumMaps: i32,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawStatusTextA(
    hDC: HDC,
    lprc: *RECT,
    pszText: [*:0]const u8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawStatusTextW(
    hDC: HDC,
    lprc: *RECT,
    pszText: [*:0]const u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateStatusWindowA(
    style: i32,
    lpszText: [*:0]const u8,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateStatusWindowW(
    style: i32,
    lpszText: [*:0]const u16,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn MenuHelp(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    hMainMenu: HMENU,
    hInst: HINSTANCE,
    hwndStatus: HWND,
    lpwIDs: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ShowHideMenuCtl(
    hWnd: HWND,
    uFlags: usize,
    lpInfo: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn GetEffectiveClientRect(
    hWnd: HWND,
    lprc: *RECT,
    lpInfo: *const i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn MakeDragList(
    hLB: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawInsert(
    handParent: HWND,
    hLB: HWND,
    nItem: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LBItemFromPt(
    hLB: HWND,
    pt: POINT,
    bAutoScroll: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn CreateUpDownControl(
    dwStyle: u32,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    hParent: HWND,
    nID: i32,
    hInst: HINSTANCE,
    hBuddy: HWND,
    nUpper: i32,
    nLower: i32,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn TaskDialogIndirect(
    pTaskConfig: *const TASKDIALOGCONFIG,
    pnButton: ?*i32,
    pnRadioButton: ?*i32,
    pfVerificationFlagChecked: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn TaskDialog(
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    pszWindowTitle: ?[*:0]const u16,
    pszMainInstruction: ?[*:0]const u16,
    pszContent: ?[*:0]const u16,
    dwCommonButtons: i32,
    pszIcon: ?[*:0]const u16,
    pnButton: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitMUILanguage(
    uiLang: u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn GetMUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Create(
    cbItem: i32,
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) *_DSA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Destroy(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DestroyCallback(
    hdsa: ?*_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DeleteItem(
    hdsa: *_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_DeleteAllItems(
    hdsa: *_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_EnumCallback(
    hdsa: *_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_InsertItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetItemPtr(
    hdsa: *_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_SetItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Clone(
    hdsa: *_DSA,
) callconv(@import("std").os.windows.WINAPI) *_DSA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_GetSize(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DSA_Sort(
    pdsa: *_DSA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Create(
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_CreateEx(
    cpGrow: i32,
    hheap: HANDLE,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Clone(
    hdpa: *const _DPA,
    hdpaNew: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Destroy(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DestroyCallback(
    hdpa: ?*_DPA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DeletePtr(
    hdpa: *_DPA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_DeleteAllPtrs(
    hdpa: *_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_EnumCallback(
    hdpa: ?*_DPA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Grow(
    pdpa: *_DPA,
    cp: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_InsertPtr(
    hdpa: *_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_SetPtr(
    hdpa: *_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetPtr(
    hdpa: *_DPA,
    i: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetPtrIndex(
    hdpa: *_DPA,
    p: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_GetSize(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Sort(
    hdpa: *_DPA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_LoadStream(
    phdpa: **_DPA,
    pfn: PFNDPASTREAM,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_SaveStream(
    hdpa: *_DPA,
    pfn: PFNDPASTREAM,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Merge(
    hdpaDest: *_DPA,
    hdpaSrc: *_DPA,
    dwFlags: u32,
    pfnCompare: PFNDACOMPARE,
    pfnMerge: PFNDPAMERGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DPA_Search(
    hdpa: *_DPA,
    pFind: ?*c_void,
    iStart: i32,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn Str_SetPtrW(
    ppsz: *PWSTR,
    psz: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_EnableScrollBar(
    param0: HWND,
    param1: i32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_ShowScrollBar(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollRange(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: *i32,
    param3: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollInfo(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    param2: *SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollPos(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_GetScrollProp(
    param0: HWND,
    propIndex: WSB_PROP,
    param2: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollPos(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    pos: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollInfo(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    psi: *SCROLLINFO,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollRange(
    param0: HWND,
    code: SCROLLBAR_CONSTANTS,
    min: i32,
    max: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn FlatSB_SetScrollProp(
    param0: HWND,
    index: WSB_PROP,
    newValue: isize,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn InitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn UninitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LoadIconMetric(
    hinst: HINSTANCE,
    pszName: [*:0]const u16,
    lims: _LI_METRIC,
    phico: *HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn LoadIconWithScaleDown(
    hinst: HINSTANCE,
    pszName: [*:0]const u16,
    cx: i32,
    cy: i32,
    phico: *HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn DrawShadowText(
    hdc: HDC,
    pszText: [*:0]const u16,
    cch: u32,
    prc: *RECT,
    dwFlags: u32,
    crText: u32,
    crShadow: u32,
    ixOffset: i32,
    iyOffset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "COMCTL32" fn ImageList_CoCreateInstance(
    rclsid: *const Guid,
    punkOuter: ?*IUnknown,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeAnimationProperty(
    hTheme: isize,
    iStoryboardId: i32,
    iTargetId: i32,
    eProperty: TA_PROPERTY,
    // TODO: what to do with BytesParamIndex 5?
    pvProperty: ?*c_void,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeAnimationTransform(
    hTheme: isize,
    iStoryboardId: i32,
    iTargetId: i32,
    dwTransformIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    pTransform: ?*TA_TRANSFORM,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "UXTHEME" fn GetThemeTimingFunction(
    hTheme: isize,
    iTimingFunctionId: i32,
    // TODO: what to do with BytesParamIndex 3?
    pTimingFunction: ?*TA_TIMINGFUNCTION,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn OpenThemeData(
    hwnd: HWND,
    pszClassList: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn OpenThemeDataEx(
    hwnd: HWND,
    pszClassList: [*:0]const u16,
    dwFlags: OPEN_THEME_DATA_FLAGS,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn CloseThemeData(
    hTheme: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeBackground(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pClipRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeBackgroundEx(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pOptions: ?*const DTBGOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeText(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    dwTextFlags2: u32,
    pRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBackgroundContentRect(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pBoundingRect: *RECT,
    pContentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBackgroundExtent(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pContentRect: *RECT,
    pExtentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeBackgroundRegion(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pRegion: *HRGN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemePartSize(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    prc: ?*RECT,
    eSize: THEMESIZE,
    psz: *SIZE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTextExtent(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchCharCount: i32,
    dwTextFlags: u32,
    pBoundingRect: ?*RECT,
    pExtentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTextMetrics(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    ptm: *TEXTMETRICW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn HitTestThemeBackground(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    dwOptions: u32,
    pRect: *RECT,
    hrgn: HRGN,
    ptTest: POINT,
    pwHitTestCode: *u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeEdge(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pDestRect: *RECT,
    uEdge: u32,
    uFlags: u32,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeIcon(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    himl: HIMAGELIST,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsThemePartDefined(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn IsThemeBackgroundPartiallyTransparent(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeColor(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pColor: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeMetric(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeString(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszBuff: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeBool(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    pfVal: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeInt(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeEnumValue(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemePosition(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pPoint: *POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeFont(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pFont: *LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeRect(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeMargins(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    prc: ?*RECT,
    pMargins: *MARGINS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeIntList(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pIntList: *INTLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemePropertyOrigin(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pOrigin: *PROPERTYORIGIN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn SetWindowTheme(
    hwnd: HWND,
    pszSubAppName: ?[*:0]const u16,
    pszSubIdList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeFilename(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszThemeFileName: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysColor(
    hTheme: isize,
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysColorBrush(
    hTheme: isize,
    iColorId: THEME_PROPERTY_SYMBOL_ID,
) callconv(@import("std").os.windows.WINAPI) HBRUSH;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysBool(
    hTheme: isize,
    iBoolId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysSize(
    hTheme: isize,
    iSizeId: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysFont(
    hTheme: isize,
    iFontId: THEME_PROPERTY_SYMBOL_ID,
    plf: *LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysString(
    hTheme: isize,
    iStringId: THEME_PROPERTY_SYMBOL_ID,
    pszStringBuff: [*:0]u16,
    cchMaxStringChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeSysInt(
    hTheme: isize,
    iIntId: i32,
    piValue: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsThemeActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsAppThemed(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetWindowTheme(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EnableThemeDialogTexture(
    hwnd: HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn IsThemeDialogTextureEnabled(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeAppProperties(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn SetThemeAppProperties(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetCurrentThemeName(
    pszThemeFileName: [*:0]u16,
    cchMaxNameChars: i32,
    pszColorBuff: ?[*:0]u16,
    cchMaxColorChars: i32,
    pszSizeBuff: ?[*:0]u16,
    cchMaxSizeChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeDocumentationProperty(
    pszThemeName: [*:0]const u16,
    pszPropertyName: [*:0]const u16,
    pszValueBuff: [*:0]u16,
    cchMaxValChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeParentBackground(
    hwnd: HWND,
    hdc: HDC,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EnableTheming(
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn DrawThemeParentBackgroundEx(
    hwnd: HWND,
    hdc: HDC,
    dwFlags: DRAW_THEME_PARENT_BACKGROUND_FLAGS,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn SetWindowThemeAttribute(
    hwnd: HWND,
    eAttribute: WINDOWTHEMEATTRIBUTETYPE,
    // TODO: what to do with BytesParamIndex 3?
    pvAttribute: *c_void,
    cbAttribute: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn DrawThemeTextEx(
    hTheme: isize,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    pRect: *RECT,
    pOptions: ?*const DTTOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeBitmap(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: THEME_PROPERTY_SYMBOL_ID,
    dwFlags: GET_THEME_BITMAP_FLAGS,
    phBitmap: *HBITMAP,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetThemeStream(
    hTheme: isize,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    ppvStream: **c_void,
    pcbStream: ?*u32,
    hInst: HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintUnInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BeginBufferedPaint(
    hdcTarget: HDC,
    prcTarget: *const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    phdc: *HDC,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn EndBufferedPaint(
    hBufferedPaint: isize,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintTargetRect(
    hBufferedPaint: isize,
    prc: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintTargetDC(
    hBufferedPaint: isize,
) callconv(@import("std").os.windows.WINAPI) HDC;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetBufferedPaintDC(
    hBufferedPaint: isize,
) callconv(@import("std").os.windows.WINAPI) HDC;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn GetBufferedPaintBits(
    hBufferedPaint: isize,
    ppbBuffer: **RGBQUAD,
    pcxRow: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintClear(
    hBufferedPaint: isize,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BufferedPaintSetAlpha(
    hBufferedPaint: isize,
    prc: ?*const RECT,
    alpha: u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn BufferedPaintStopAllAnimations(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BeginBufferedAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
    prcTarget: *const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    pAnimationParams: *BP_ANIMATIONPARAMS,
    phdcFrom: *HDC,
    phdcTo: *HDC,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn EndBufferedAnimation(
    hbpAnimation: isize,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn BufferedPaintRenderAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UXTHEME" fn IsCompositionActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "UxTheme" fn GetThemeTransitionDuration(
    hTheme: isize,
    iPartId: i32,
    iStateIdFrom: i32,
    iStateIdTo: i32,
    iPropId: i32,
    pdwDuration: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn CheckDlgButton(
    hDlg: HWND,
    nIDButton: i32,
    uCheck: DLG_BUTTON_CHECK_STATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn CheckRadioButton(
    hDlg: HWND,
    nIDFirstButton: i32,
    nIDLastButton: i32,
    nIDCheckButton: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn IsDlgButtonChecked(
    hDlg: HWND,
    nIDButton: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn IsCharLowerW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn InitializeTouchInjection(
    maxCount: u32,
    dwMode: TOUCH_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn InjectTouchInput(
    count: u32,
    contacts: [*]const POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn CreateSyntheticPointerDevice(
    pointerType: POINTER_INPUT_TYPE,
    maxCount: u32,
    mode: POINTER_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) HSYNTHETICPOINTERDEVICE;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn InjectSyntheticPointerInput(
    device: HSYNTHETICPOINTERDEVICE,
    pointerInfo: [*]const POINTER_TYPE_INFO,
    count: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "USER32" fn DestroySyntheticPointerDevice(
    device: HSYNTHETICPOINTERDEVICE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn RegisterTouchHitTestingWindow(
    hwnd: HWND,
    value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn EvaluateProximityToRect(
    controlBoundingBox: *const RECT,
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn EvaluateProximityToPolygon(
    numVertices: u32,
    controlPolygon: [*]const POINT,
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn PackTouchHitTestingProximityEvaluation(
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    pSize: *u32,
    // TODO: what to do with BytesParamIndex 3?
    config: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn SetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    size: u32,
    // TODO: what to do with BytesParamIndex 3?
    configuration: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollWindow(
    hWnd: HWND,
    XAmount: i32,
    YAmount: i32,
    lpRect: ?*const RECT,
    lpClipRect: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollDC(
    hDC: HDC,
    dx: i32,
    dy: i32,
    lprcScroll: ?*const RECT,
    lprcClip: ?*const RECT,
    hrgnUpdate: HRGN,
    lprcUpdate: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ScrollWindowEx(
    hWnd: HWND,
    dx: i32,
    dy: i32,
    prcScroll: ?*const RECT,
    prcClip: ?*const RECT,
    hrgnUpdate: HRGN,
    prcUpdate: ?*RECT,
    flags: SHOW_WINDOW_CMD,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollPos(
    hWnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
    nPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollPos(
    hWnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollRange(
    hWnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
    nMinPos: i32,
    nMaxPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollRange(
    hWnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpMinPos: *i32,
    lpMaxPos: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ShowScrollBar(
    hWnd: HWND,
    wBar: SCROLLBAR_CONSTANTS,
    bShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn EnableScrollBar(
    hWnd: HWND,
    wSBflags: SCROLLBAR_CONSTANTS,
    wArrows: ENABLE_SCROLL_BAR_ARROWS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListA(
    hDlg: HWND,
    lpPathSpec: PSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListW(
    hDlg: HWND,
    lpPathSpec: PWSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectExA(
    hwndDlg: HWND,
    lpString: [*:0]u8,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectExW(
    hwndDlg: HWND,
    lpString: [*:0]u16,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListComboBoxA(
    hDlg: HWND,
    lpPathSpec: PSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirListComboBoxW(
    hDlg: HWND,
    lpPathSpec: PWSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: DLG_DIR_LIST_FILE_TYPE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectComboBoxExA(
    hwndDlg: HWND,
    lpString: [*:0]u8,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn DlgDirSelectComboBoxExW(
    hwndDlg: HWND,
    lpString: [*:0]u16,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn SetScrollInfo(
    hwnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpsi: *SCROLLINFO,
    redraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollInfo(
    hwnd: HWND,
    nBar: SCROLLBAR_CONSTANTS,
    lpsi: *SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetScrollBarInfo(
    hwnd: HWND,
    idObject: SCROLLBAR_OBJID,
    psbi: *SCROLLBARINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetComboBoxInfo(
    hwndCombo: HWND,
    pcbi: *COMBOBOXINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn GetListBoxInfo(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDevices(
    deviceCount: *u32,
    pointerDevices: ?[*]POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDevice(
    device: HANDLE,
    pointerDevice: *POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceProperties(
    device: HANDLE,
    propertyCount: *u32,
    pointerProperties: ?[*]POINTER_DEVICE_PROPERTY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn RegisterPointerDeviceNotifications(
    window: HWND,
    notifyRange: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceRects(
    device: HANDLE,
    pointerDeviceRect: *RECT,
    displayRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetPointerDeviceCursors(
    device: HANDLE,
    cursorCount: *u32,
    deviceCursors: ?[*]POINTER_DEVICE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetRawPointerDeviceData(
    pointerId: u32,
    historyCount: u32,
    propertiesCount: u32,
    pProperties: [*]POINTER_DEVICE_PROPERTY,
    pValues: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetCurrentInputMessageSource(
    inputMessageSource: *INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn GetCIMSSM(
    inputMessageSource: *INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (54)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const TEXTRANGE = TEXTRANGEA;
        pub const FINDTEXT = FINDTEXTA;
        pub const FINDTEXTEX = FINDTEXTEXA;
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKA;
        pub const PROPSHEETPAGE = PROPSHEETPAGEA;
        pub const HD_TEXTFILTER = HD_TEXTFILTERA;
        pub const HDITEM = HDITEMA;
        pub const NMHEADER = NMHEADERA;
        pub const NMHDDISPINFO = NMHDDISPINFOA;
        pub const TBSAVEPARAMS = TBSAVEPARAMSA;
        pub const TBBUTTONINFO = TBBUTTONINFOA;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPA;
        pub const NMTBDISPINFO = NMTBDISPINFOA;
        pub const NMTOOLBAR = NMTOOLBARA;
        pub const REBARBANDINFO = REBARBANDINFOA;
        pub const TTTOOLINFO = TTTOOLINFOA;
        pub const TTHITTESTINFO = TTHITTESTINFOA;
        pub const NMTTDISPINFO = NMTTDISPINFOA;
        pub const LVITEM = LVITEMA;
        pub const LVFINDINFO = LVFINDINFOA;
        pub const LVCOLUMN = LVCOLUMNA;
        pub const LVBKIMAGE = LVBKIMAGEA;
        pub const NMLVFINDITEM = NMLVFINDITEMA;
        pub const NMLVDISPINFO = NMLVDISPINFOA;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPA;
        pub const TVITEM = TVITEMA;
        pub const TVITEMEX = TVITEMEXA;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTA;
        pub const NMTREEVIEW = NMTREEVIEWA;
        pub const NMTVDISPINFO = NMTVDISPINFOA;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXA;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPA;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMA;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXA;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINA;
        pub const NMCBEENDEDIT = NMCBEENDEDITA;
        pub const TCITEMHEADER = TCITEMHEADERA;
        pub const TCITEM = TCITEMA;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGA;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNA;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATA;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYA;
        pub const CHARFORMAT = CHARFORMATA;
        pub const CHARFORMAT2 = CHARFORMAT2A;
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
        pub const CreatePropertySheetPage = CreatePropertySheetPageA;
        pub const PropertySheet = PropertySheetA;
        pub const ImageList_LoadImage = ImageList_LoadImageA;
        pub const DrawStatusText = DrawStatusTextA;
        pub const CreateStatusWindow = CreateStatusWindowA;
        pub const DlgDirList = DlgDirListA;
        pub const DlgDirSelectEx = DlgDirSelectExA;
        pub const DlgDirListComboBox = DlgDirListComboBoxA;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
    },
    .wide => struct {
        pub const TEXTRANGE = TEXTRANGEW;
        pub const FINDTEXT = FINDTEXTW;
        pub const FINDTEXTEX = FINDTEXTEXW;
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKW;
        pub const PROPSHEETPAGE = PROPSHEETPAGEW;
        pub const HD_TEXTFILTER = HD_TEXTFILTERW;
        pub const HDITEM = HDITEMW;
        pub const NMHEADER = NMHEADERW;
        pub const NMHDDISPINFO = NMHDDISPINFOW;
        pub const TBSAVEPARAMS = TBSAVEPARAMSW;
        pub const TBBUTTONINFO = TBBUTTONINFOW;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPW;
        pub const NMTBDISPINFO = NMTBDISPINFOW;
        pub const NMTOOLBAR = NMTOOLBARW;
        pub const REBARBANDINFO = REBARBANDINFOW;
        pub const TTTOOLINFO = TTTOOLINFOW;
        pub const TTHITTESTINFO = TTHITTESTINFOW;
        pub const NMTTDISPINFO = NMTTDISPINFOW;
        pub const LVITEM = LVITEMW;
        pub const LVFINDINFO = LVFINDINFOW;
        pub const LVCOLUMN = LVCOLUMNW;
        pub const LVBKIMAGE = LVBKIMAGEW;
        pub const NMLVFINDITEM = NMLVFINDITEMW;
        pub const NMLVDISPINFO = NMLVDISPINFOW;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPW;
        pub const TVITEM = TVITEMW;
        pub const TVITEMEX = TVITEMEXW;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTW;
        pub const NMTREEVIEW = NMTREEVIEWW;
        pub const NMTVDISPINFO = NMTVDISPINFOW;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXW;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPW;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMW;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXW;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINW;
        pub const NMCBEENDEDIT = NMCBEENDEDITW;
        pub const TCITEMHEADER = TCITEMHEADERW;
        pub const TCITEM = TCITEMW;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGW;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNW;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATW;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYW;
        pub const CHARFORMAT = CHARFORMATW;
        pub const CHARFORMAT2 = CHARFORMAT2W;
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
        pub const CreatePropertySheetPage = CreatePropertySheetPageW;
        pub const PropertySheet = PropertySheetW;
        pub const ImageList_LoadImage = ImageList_LoadImageW;
        pub const DrawStatusText = DrawStatusTextW;
        pub const CreateStatusWindow = CreateStatusWindowW;
        pub const DlgDirList = DlgDirListW;
        pub const DlgDirSelectEx = DlgDirSelectExW;
        pub const DlgDirListComboBox = DlgDirListComboBoxW;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const TEXTRANGE = *opaque{};
        pub const FINDTEXT = *opaque{};
        pub const FINDTEXTEX = *opaque{};
        pub const LPFNPSPCALLBACK = *opaque{};
        pub const PROPSHEETPAGE = *opaque{};
        pub const HD_TEXTFILTER = *opaque{};
        pub const HDITEM = *opaque{};
        pub const NMHEADER = *opaque{};
        pub const NMHDDISPINFO = *opaque{};
        pub const TBSAVEPARAMS = *opaque{};
        pub const TBBUTTONINFO = *opaque{};
        pub const NMTBGETINFOTIP = *opaque{};
        pub const NMTBDISPINFO = *opaque{};
        pub const NMTOOLBAR = *opaque{};
        pub const REBARBANDINFO = *opaque{};
        pub const TTTOOLINFO = *opaque{};
        pub const TTHITTESTINFO = *opaque{};
        pub const NMTTDISPINFO = *opaque{};
        pub const LVITEM = *opaque{};
        pub const LVFINDINFO = *opaque{};
        pub const LVCOLUMN = *opaque{};
        pub const LVBKIMAGE = *opaque{};
        pub const NMLVFINDITEM = *opaque{};
        pub const NMLVDISPINFO = *opaque{};
        pub const NMLVGETINFOTIP = *opaque{};
        pub const TVITEM = *opaque{};
        pub const TVITEMEX = *opaque{};
        pub const TVINSERTSTRUCT = *opaque{};
        pub const NMTREEVIEW = *opaque{};
        pub const NMTVDISPINFO = *opaque{};
        pub const NMTVDISPINFOEX = *opaque{};
        pub const NMTVGETINFOTIP = *opaque{};
        pub const COMBOBOXEXITEM = *opaque{};
        pub const NMCOMBOBOXEX = *opaque{};
        pub const NMCBEDRAGBEGIN = *opaque{};
        pub const NMCBEENDEDIT = *opaque{};
        pub const TCITEMHEADER = *opaque{};
        pub const TCITEM = *opaque{};
        pub const NMDATETIMESTRING = *opaque{};
        pub const NMDATETIMEWMKEYDOWN = *opaque{};
        pub const NMDATETIMEFORMAT = *opaque{};
        pub const NMDATETIMEFORMATQUERY = *opaque{};
        pub const CHARFORMAT = *opaque{};
        pub const CHARFORMAT2 = *opaque{};
        pub const EDITWORDBREAKPROC = *opaque{};
        pub const CreatePropertySheetPage = *opaque{};
        pub const PropertySheet = *opaque{};
        pub const ImageList_LoadImage = *opaque{};
        pub const DrawStatusText = *opaque{};
        pub const CreateStatusWindow = *opaque{};
        pub const DlgDirList = *opaque{};
        pub const DlgDirSelectEx = *opaque{};
        pub const DlgDirListComboBox = *opaque{};
        pub const DlgDirSelectComboBoxEx = *opaque{};
    } else struct {
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
        pub const LPFNPSPCALLBACK = @compileError("'LPFNPSPCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const PROPSHEETPAGE = @compileError("'PROPSHEETPAGE' requires that UNICODE be set to true or false in the root module");
        pub const HD_TEXTFILTER = @compileError("'HD_TEXTFILTER' requires that UNICODE be set to true or false in the root module");
        pub const HDITEM = @compileError("'HDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMHEADER = @compileError("'NMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const NMHDDISPINFO = @compileError("'NMHDDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const TBSAVEPARAMS = @compileError("'TBSAVEPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const TBBUTTONINFO = @compileError("'TBBUTTONINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTBGETINFOTIP = @compileError("'NMTBGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const NMTBDISPINFO = @compileError("'NMTBDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTOOLBAR = @compileError("'NMTOOLBAR' requires that UNICODE be set to true or false in the root module");
        pub const REBARBANDINFO = @compileError("'REBARBANDINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTTOOLINFO = @compileError("'TTTOOLINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTHITTESTINFO = @compileError("'TTHITTESTINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTTDISPINFO = @compileError("'NMTTDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVITEM = @compileError("'LVITEM' requires that UNICODE be set to true or false in the root module");
        pub const LVFINDINFO = @compileError("'LVFINDINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVCOLUMN = @compileError("'LVCOLUMN' requires that UNICODE be set to true or false in the root module");
        pub const LVBKIMAGE = @compileError("'LVBKIMAGE' requires that UNICODE be set to true or false in the root module");
        pub const NMLVFINDITEM = @compileError("'NMLVFINDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMLVDISPINFO = @compileError("'NMLVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMLVGETINFOTIP = @compileError("'NMLVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const TVITEM = @compileError("'TVITEM' requires that UNICODE be set to true or false in the root module");
        pub const TVITEMEX = @compileError("'TVITEMEX' requires that UNICODE be set to true or false in the root module");
        pub const TVINSERTSTRUCT = @compileError("'TVINSERTSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const NMTREEVIEW = @compileError("'NMTREEVIEW' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFO = @compileError("'NMTVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFOEX = @compileError("'NMTVDISPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NMTVGETINFOTIP = @compileError("'NMTVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const COMBOBOXEXITEM = @compileError("'COMBOBOXEXITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMCOMBOBOXEX = @compileError("'NMCOMBOBOXEX' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEDRAGBEGIN = @compileError("'NMCBEDRAGBEGIN' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEENDEDIT = @compileError("'NMCBEENDEDIT' requires that UNICODE be set to true or false in the root module");
        pub const TCITEMHEADER = @compileError("'TCITEMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const TCITEM = @compileError("'TCITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMESTRING = @compileError("'NMDATETIMESTRING' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEWMKEYDOWN = @compileError("'NMDATETIMEWMKEYDOWN' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMAT = @compileError("'NMDATETIMEFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMATQUERY = @compileError("'NMDATETIMEFORMATQUERY' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const EDITWORDBREAKPROC = @compileError("'EDITWORDBREAKPROC' requires that UNICODE be set to true or false in the root module");
        pub const CreatePropertySheetPage = @compileError("'CreatePropertySheetPage' requires that UNICODE be set to true or false in the root module");
        pub const PropertySheet = @compileError("'PropertySheet' requires that UNICODE be set to true or false in the root module");
        pub const ImageList_LoadImage = @compileError("'ImageList_LoadImage' requires that UNICODE be set to true or false in the root module");
        pub const DrawStatusText = @compileError("'DrawStatusText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStatusWindow = @compileError("'CreateStatusWindow' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirList = @compileError("'DlgDirList' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectEx = @compileError("'DlgDirSelectEx' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirListComboBox = @compileError("'DlgDirListComboBox' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectComboBoxEx = @compileError("'DlgDirSelectComboBoxEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (59)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const HRGN = @import("gdi.zig").HRGN;
const HPEN = @import("gdi.zig").HPEN;
const LOGFONTW = @import("gdi.zig").LOGFONTW;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const LRESULT = @import("system_services.zig").LRESULT;
const HMENU = @import("menus_and_resources.zig").HMENU;
const HIMC = @import("intl.zig").HIMC;
const IOleClientSite = @import("com.zig").IOleClientSite;
const IRawElementProviderWindowlessSite = @import("windows_accessibility.zig").IRawElementProviderWindowlessSite;
const TTTOOLINFO_FLAGS = @import("system_services.zig").TTTOOLINFO_FLAGS;
const IOleInPlaceFrame = @import("com.zig").IOleInPlaceFrame;
const IStream = @import("structured_storage.zig").IStream;
const DVASPECT = @import("com.zig").DVASPECT;
const PWSTR = @import("system_services.zig").PWSTR;
const HMONITOR = @import("gdi.zig").HMONITOR;
const POINTER_TOUCH_INFO = @import("pointer_input.zig").POINTER_TOUCH_INFO;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const IStorage = @import("structured_storage.zig").IStorage;
const SHOW_WINDOW_CMD = @import("windows_and_messaging.zig").SHOW_WINDOW_CMD;
const BLENDFUNCTION = @import("gdi.zig").BLENDFUNCTION;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const HANDLE = @import("system_services.zig").HANDLE;
const UiaRect = @import("windows_accessibility.zig").UiaRect;
const HCURSOR = @import("menus_and_resources.zig").HCURSOR;
const HDC = @import("gdi.zig").HDC;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const HKEY = @import("windows_programming.zig").HKEY;
const CHAR = @import("system_services.zig").CHAR;
const OIFI = @import("com.zig").OIFI;
const IRawElementProviderSimple = @import("windows_accessibility.zig").IRawElementProviderSimple;
const HRESULT = @import("com.zig").HRESULT;
const ID2D1RenderTarget = @import("direct2d.zig").ID2D1RenderTarget;
const IOleObject = @import("com.zig").IOleObject;
const RGBQUAD = @import("gdi.zig").RGBQUAD;
const BOOL = @import("system_services.zig").BOOL;
const HBRUSH = @import("gdi.zig").HBRUSH;
const IOleInPlaceUIWindow = @import("com.zig").IOleInPlaceUIWindow;
const DLGPROC = @import("windows_and_messaging.zig").DLGPROC;
const HPALETTE = @import("gdi.zig").HPALETTE;
const TEXTMETRICW = @import("gdi.zig").TEXTMETRICW;
const DVTARGETDEVICE = @import("com.zig").DVTARGETDEVICE;
const IMAGE_LIST_ITEM_FLAGS = @import("system_services.zig").IMAGE_LIST_ITEM_FLAGS;
const HICON = @import("menus_and_resources.zig").HICON;
const IUnknown = @import("com.zig").IUnknown;
const IDropTarget = @import("com.zig").IDropTarget;
const HBITMAP = @import("gdi.zig").HBITMAP;
const HWND = @import("windows_and_messaging.zig").HWND;
const WINDOWPOS = @import("windows_and_messaging.zig").WINDOWPOS;
const VARIANT = @import("automation.zig").VARIANT;
const IDataObject = @import("com.zig").IDataObject;
const POINTER_INPUT_TYPE = @import("windows_and_messaging.zig").POINTER_INPUT_TYPE;
const POINT = @import("display_devices.zig").POINT;
const SIZE = @import("display_devices.zig").SIZE;
const RECTL = @import("display_devices.zig").RECTL;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNPSPCALLBACKA")) { _ = LPFNPSPCALLBACKA; }
    if (@hasDecl(@This(), "LPFNPSPCALLBACKW")) { _ = LPFNPSPCALLBACKW; }
    if (@hasDecl(@This(), "PFNPROPSHEETCALLBACK")) { _ = PFNPROPSHEETCALLBACK; }
    if (@hasDecl(@This(), "LPFNSVADDPROPSHEETPAGE")) { _ = LPFNSVADDPROPSHEETPAGE; }
    if (@hasDecl(@This(), "LPFNADDPROPSHEETPAGES")) { _ = LPFNADDPROPSHEETPAGES; }
    if (@hasDecl(@This(), "PFNLVCOMPARE")) { _ = PFNLVCOMPARE; }
    if (@hasDecl(@This(), "PFNLVGROUPCOMPARE")) { _ = PFNLVGROUPCOMPARE; }
    if (@hasDecl(@This(), "PFNTVCOMPARE")) { _ = PFNTVCOMPARE; }
    if (@hasDecl(@This(), "PFTASKDIALOGCALLBACK")) { _ = PFTASKDIALOGCALLBACK; }
    if (@hasDecl(@This(), "PFNDAENUMCALLBACK")) { _ = PFNDAENUMCALLBACK; }
    if (@hasDecl(@This(), "PFNDAENUMCALLBACKCONST")) { _ = PFNDAENUMCALLBACKCONST; }
    if (@hasDecl(@This(), "PFNDACOMPARE")) { _ = PFNDACOMPARE; }
    if (@hasDecl(@This(), "PFNDACOMPARECONST")) { _ = PFNDACOMPARECONST; }
    if (@hasDecl(@This(), "PFNDPASTREAM")) { _ = PFNDPASTREAM; }
    if (@hasDecl(@This(), "PFNDPAMERGE")) { _ = PFNDPAMERGE; }
    if (@hasDecl(@This(), "PFNDPAMERGECONST")) { _ = PFNDPAMERGECONST; }
    if (@hasDecl(@This(), "AutoCorrectProc")) { _ = AutoCorrectProc; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCEX")) { _ = EDITWORDBREAKPROCEX; }
    if (@hasDecl(@This(), "EDITSTREAMCALLBACK")) { _ = EDITSTREAMCALLBACK; }
    if (@hasDecl(@This(), "PCreateTextServices")) { _ = PCreateTextServices; }
    if (@hasDecl(@This(), "PShutdownTextServices")) { _ = PShutdownTextServices; }
    if (@hasDecl(@This(), "DTT_CALLBACK_PROC")) { _ = DTT_CALLBACK_PROC; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCA")) { _ = EDITWORDBREAKPROCA; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCW")) { _ = EDITWORDBREAKPROCW; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
