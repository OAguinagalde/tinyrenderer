//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (817)
//--------------------------------------------------------------------------------
pub const LM_HB_Extension = @as(i32, 128);
pub const LM_HB1_PnP = @as(i32, 1);
pub const LM_HB1_PDA_Palmtop = @as(i32, 2);
pub const LM_HB1_Computer = @as(i32, 4);
pub const LM_HB1_Printer = @as(i32, 8);
pub const LM_HB1_Modem = @as(i32, 16);
pub const LM_HB1_Fax = @as(i32, 32);
pub const LM_HB1_LANAccess = @as(i32, 64);
pub const LM_HB2_Telephony = @as(i32, 1);
pub const LM_HB2_FileServer = @as(i32, 2);
pub const ATMPROTO_AALUSER = @as(u32, 0);
pub const ATMPROTO_AAL1 = @as(u32, 1);
pub const ATMPROTO_AAL2 = @as(u32, 2);
pub const ATMPROTO_AAL34 = @as(u32, 3);
pub const ATMPROTO_AAL5 = @as(u32, 5);
pub const SAP_FIELD_ABSENT = @as(u32, 4294967294);
pub const SAP_FIELD_ANY = @as(u32, 4294967295);
pub const SAP_FIELD_ANY_AESA_SEL = @as(u32, 4294967290);
pub const SAP_FIELD_ANY_AESA_REST = @as(u32, 4294967291);
pub const ATM_E164 = @as(u32, 1);
pub const ATM_NSAP = @as(u32, 2);
pub const ATM_AESA = @as(u32, 2);
pub const ATM_ADDR_SIZE = @as(u32, 20);
pub const BLLI_L2_ISO_1745 = @as(u32, 1);
pub const BLLI_L2_Q921 = @as(u32, 2);
pub const BLLI_L2_X25L = @as(u32, 6);
pub const BLLI_L2_X25M = @as(u32, 7);
pub const BLLI_L2_ELAPB = @as(u32, 8);
pub const BLLI_L2_HDLC_ARM = @as(u32, 9);
pub const BLLI_L2_HDLC_NRM = @as(u32, 10);
pub const BLLI_L2_HDLC_ABM = @as(u32, 11);
pub const BLLI_L2_LLC = @as(u32, 12);
pub const BLLI_L2_X75 = @as(u32, 13);
pub const BLLI_L2_Q922 = @as(u32, 14);
pub const BLLI_L2_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L2_ISO_7776 = @as(u32, 17);
pub const BLLI_L3_X25 = @as(u32, 6);
pub const BLLI_L3_ISO_8208 = @as(u32, 7);
pub const BLLI_L3_X223 = @as(u32, 8);
pub const BLLI_L3_SIO_8473 = @as(u32, 9);
pub const BLLI_L3_T70 = @as(u32, 10);
pub const BLLI_L3_ISO_TR9577 = @as(u32, 11);
pub const BLLI_L3_USER_SPECIFIED = @as(u32, 16);
pub const BLLI_L3_IPI_SNAP = @as(u32, 128);
pub const BLLI_L3_IPI_IP = @as(u32, 204);
pub const BHLI_ISO = @as(u32, 0);
pub const BHLI_UserSpecific = @as(u32, 1);
pub const BHLI_HighLayerProfile = @as(u32, 2);
pub const BHLI_VendorSpecificAppId = @as(u32, 3);
pub const AAL5_MODE_MESSAGE = @as(u32, 1);
pub const AAL5_MODE_STREAMING = @as(u32, 2);
pub const AAL5_SSCS_NULL = @as(u32, 0);
pub const AAL5_SSCS_SSCOP_ASSURED = @as(u32, 1);
pub const AAL5_SSCS_SSCOP_NON_ASSURED = @as(u32, 2);
pub const AAL5_SSCS_FRAME_RELAY = @as(u32, 4);
pub const BCOB_A = @as(u32, 1);
pub const BCOB_C = @as(u32, 3);
pub const BCOB_X = @as(u32, 16);
pub const TT_NOIND = @as(u32, 0);
pub const TT_CBR = @as(u32, 4);
pub const TT_VBR = @as(u32, 8);
pub const TR_NOIND = @as(u32, 0);
pub const TR_END_TO_END = @as(u32, 1);
pub const TR_NO_END_TO_END = @as(u32, 2);
pub const CLIP_NOT = @as(u32, 0);
pub const CLIP_SUS = @as(u32, 32);
pub const UP_P2P = @as(u32, 0);
pub const UP_P2MP = @as(u32, 1);
pub const BLLI_L2_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L2_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_MODE_NORMAL = @as(u32, 64);
pub const BLLI_L3_MODE_EXT = @as(u32, 128);
pub const BLLI_L3_PACKET_16 = @as(u32, 4);
pub const BLLI_L3_PACKET_32 = @as(u32, 5);
pub const BLLI_L3_PACKET_64 = @as(u32, 6);
pub const BLLI_L3_PACKET_128 = @as(u32, 7);
pub const BLLI_L3_PACKET_256 = @as(u32, 8);
pub const BLLI_L3_PACKET_512 = @as(u32, 9);
pub const BLLI_L3_PACKET_1024 = @as(u32, 10);
pub const BLLI_L3_PACKET_2048 = @as(u32, 11);
pub const BLLI_L3_PACKET_4096 = @as(u32, 12);
pub const PI_ALLOWED = @as(u32, 0);
pub const PI_RESTRICTED = @as(u32, 64);
pub const PI_NUMBER_NOT_AVAILABLE = @as(u32, 128);
pub const SI_USER_NOT_SCREENED = @as(u32, 0);
pub const SI_USER_PASSED = @as(u32, 1);
pub const SI_USER_FAILED = @as(u32, 2);
pub const SI_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_USER = @as(u32, 0);
pub const CAUSE_LOC_PRIVATE_LOCAL = @as(u32, 1);
pub const CAUSE_LOC_PUBLIC_LOCAL = @as(u32, 2);
pub const CAUSE_LOC_TRANSIT_NETWORK = @as(u32, 3);
pub const CAUSE_LOC_PUBLIC_REMOTE = @as(u32, 4);
pub const CAUSE_LOC_PRIVATE_REMOTE = @as(u32, 5);
pub const CAUSE_LOC_INTERNATIONAL_NETWORK = @as(u32, 7);
pub const CAUSE_LOC_BEYOND_INTERWORKING = @as(u32, 10);
pub const CAUSE_UNALLOCATED_NUMBER = @as(u32, 1);
pub const CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK = @as(u32, 2);
pub const CAUSE_NO_ROUTE_TO_DESTINATION = @as(u32, 3);
pub const CAUSE_VPI_VCI_UNACCEPTABLE = @as(u32, 10);
pub const CAUSE_NORMAL_CALL_CLEARING = @as(u32, 16);
pub const CAUSE_USER_BUSY = @as(u32, 17);
pub const CAUSE_NO_USER_RESPONDING = @as(u32, 18);
pub const CAUSE_CALL_REJECTED = @as(u32, 21);
pub const CAUSE_NUMBER_CHANGED = @as(u32, 22);
pub const CAUSE_USER_REJECTS_CLIR = @as(u32, 23);
pub const CAUSE_DESTINATION_OUT_OF_ORDER = @as(u32, 27);
pub const CAUSE_INVALID_NUMBER_FORMAT = @as(u32, 28);
pub const CAUSE_STATUS_ENQUIRY_RESPONSE = @as(u32, 30);
pub const CAUSE_NORMAL_UNSPECIFIED = @as(u32, 31);
pub const CAUSE_VPI_VCI_UNAVAILABLE = @as(u32, 35);
pub const CAUSE_NETWORK_OUT_OF_ORDER = @as(u32, 38);
pub const CAUSE_TEMPORARY_FAILURE = @as(u32, 41);
pub const CAUSE_ACCESS_INFORMAION_DISCARDED = @as(u32, 43);
pub const CAUSE_NO_VPI_VCI_AVAILABLE = @as(u32, 45);
pub const CAUSE_RESOURCE_UNAVAILABLE = @as(u32, 47);
pub const CAUSE_QOS_UNAVAILABLE = @as(u32, 49);
pub const CAUSE_USER_CELL_RATE_UNAVAILABLE = @as(u32, 51);
pub const CAUSE_BEARER_CAPABILITY_UNAUTHORIZED = @as(u32, 57);
pub const CAUSE_BEARER_CAPABILITY_UNAVAILABLE = @as(u32, 58);
pub const CAUSE_OPTION_UNAVAILABLE = @as(u32, 63);
pub const CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED = @as(u32, 65);
pub const CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS = @as(u32, 73);
pub const CAUSE_INVALID_CALL_REFERENCE = @as(u32, 81);
pub const CAUSE_CHANNEL_NONEXISTENT = @as(u32, 82);
pub const CAUSE_INCOMPATIBLE_DESTINATION = @as(u32, 88);
pub const CAUSE_INVALID_ENDPOINT_REFERENCE = @as(u32, 89);
pub const CAUSE_INVALID_TRANSIT_NETWORK_SELECTION = @as(u32, 91);
pub const CAUSE_TOO_MANY_PENDING_ADD_PARTY = @as(u32, 92);
pub const CAUSE_AAL_PARAMETERS_UNSUPPORTED = @as(u32, 93);
pub const CAUSE_MANDATORY_IE_MISSING = @as(u32, 96);
pub const CAUSE_UNIMPLEMENTED_MESSAGE_TYPE = @as(u32, 97);
pub const CAUSE_UNIMPLEMENTED_IE = @as(u32, 99);
pub const CAUSE_INVALID_IE_CONTENTS = @as(u32, 100);
pub const CAUSE_INVALID_STATE_FOR_MESSAGE = @as(u32, 101);
pub const CAUSE_RECOVERY_ON_TIMEOUT = @as(u32, 102);
pub const CAUSE_INCORRECT_MESSAGE_LENGTH = @as(u32, 104);
pub const CAUSE_PROTOCOL_ERROR = @as(u32, 111);
pub const CAUSE_COND_UNKNOWN = @as(u32, 0);
pub const CAUSE_COND_PERMANENT = @as(u32, 1);
pub const CAUSE_COND_TRANSIENT = @as(u32, 2);
pub const CAUSE_REASON_USER = @as(u32, 0);
pub const CAUSE_REASON_IE_MISSING = @as(u32, 4);
pub const CAUSE_REASON_IE_INSUFFICIENT = @as(u32, 8);
pub const CAUSE_PU_PROVIDER = @as(u32, 0);
pub const CAUSE_PU_USER = @as(u32, 8);
pub const CAUSE_NA_NORMAL = @as(u32, 0);
pub const CAUSE_NA_ABNORMAL = @as(u32, 4);
pub const QOS_CLASS0 = @as(u32, 0);
pub const QOS_CLASS1 = @as(u32, 1);
pub const QOS_CLASS2 = @as(u32, 2);
pub const QOS_CLASS3 = @as(u32, 3);
pub const QOS_CLASS4 = @as(u32, 4);
pub const TNS_TYPE_NATIONAL = @as(u32, 64);
pub const TNS_PLAN_CARRIER_ID_CODE = @as(u32, 1);
pub const SIO_GET_NUMBER_OF_ATM_DEVICES = @as(u32, 1343619073);
pub const SIO_GET_ATM_ADDRESS = @as(u32, 3491102722);
pub const SIO_ASSOCIATE_PVC = @as(u32, 2417360899);
pub const SIO_GET_ATM_CONNECTION_ID = @as(u32, 1343619076);
pub const RIO_MSG_DONT_NOTIFY = @as(u32, 1);
pub const RIO_MSG_DEFER = @as(u32, 2);
pub const RIO_MSG_WAITALL = @as(u32, 4);
pub const RIO_MSG_COMMIT_ONLY = @as(u32, 8);
pub const RIO_MAX_CQ_SIZE = @as(u32, 134217728);
pub const RIO_CORRUPT_CQ = @as(u32, 4294967295);
pub const WINDOWS_AF_IRDA = @as(u32, 26);
pub const WCE_AF_IRDA = @as(u32, 22);
pub const IRDA_PROTO_SOCK_STREAM = @as(u32, 1);
pub const SOL_IRLMP = @as(u32, 255);
pub const IRLMP_ENUMDEVICES = @as(u32, 16);
pub const IRLMP_IAS_SET = @as(u32, 17);
pub const IRLMP_IAS_QUERY = @as(u32, 18);
pub const IRLMP_SEND_PDU_LEN = @as(u32, 19);
pub const IRLMP_EXCLUSIVE_MODE = @as(u32, 20);
pub const IRLMP_IRLPT_MODE = @as(u32, 21);
pub const IRLMP_9WIRE_MODE = @as(u32, 22);
pub const IRLMP_TINYTP_MODE = @as(u32, 23);
pub const IRLMP_PARAMETERS = @as(u32, 24);
pub const IRLMP_DISCOVERY_MODE = @as(u32, 25);
pub const IRLMP_SHARP_MODE = @as(u32, 32);
pub const IAS_ATTRIB_NO_CLASS = @as(u32, 16);
pub const IAS_ATTRIB_NO_ATTRIB = @as(u32, 0);
pub const IAS_ATTRIB_INT = @as(u32, 1);
pub const IAS_ATTRIB_OCTETSEQ = @as(u32, 2);
pub const IAS_ATTRIB_STR = @as(u32, 3);
pub const IAS_MAX_USER_STRING = @as(u32, 256);
pub const IAS_MAX_OCTET_STRING = @as(u32, 1024);
pub const IAS_MAX_CLASSNAME = @as(u32, 64);
pub const IAS_MAX_ATTRIBNAME = @as(u32, 256);
pub const LmCharSetASCII = @as(u32, 0);
pub const LmCharSetISO_8859_1 = @as(u32, 1);
pub const LmCharSetISO_8859_2 = @as(u32, 2);
pub const LmCharSetISO_8859_3 = @as(u32, 3);
pub const LmCharSetISO_8859_4 = @as(u32, 4);
pub const LmCharSetISO_8859_5 = @as(u32, 5);
pub const LmCharSetISO_8859_6 = @as(u32, 6);
pub const LmCharSetISO_8859_7 = @as(u32, 7);
pub const LmCharSetISO_8859_8 = @as(u32, 8);
pub const LmCharSetISO_8859_9 = @as(u32, 9);
pub const LmCharSetUNICODE = @as(u32, 255);
pub const LM_BAUD_1200 = @as(u32, 1200);
pub const LM_BAUD_2400 = @as(u32, 2400);
pub const LM_BAUD_9600 = @as(u32, 9600);
pub const LM_BAUD_19200 = @as(u32, 19200);
pub const LM_BAUD_38400 = @as(u32, 38400);
pub const LM_BAUD_57600 = @as(u32, 57600);
pub const LM_BAUD_115200 = @as(u32, 115200);
pub const LM_BAUD_576K = @as(u32, 576000);
pub const LM_BAUD_1152K = @as(u32, 1152000);
pub const LM_BAUD_4M = @as(u32, 4000000);
pub const LM_BAUD_16M = @as(u32, 16000000);
pub const IPX_PTYPE = @as(u32, 16384);
pub const IPX_FILTERPTYPE = @as(u32, 16385);
pub const IPX_STOPFILTERPTYPE = @as(u32, 16387);
pub const IPX_DSTYPE = @as(u32, 16386);
pub const IPX_EXTENDED_ADDRESS = @as(u32, 16388);
pub const IPX_RECVHDR = @as(u32, 16389);
pub const IPX_MAXSIZE = @as(u32, 16390);
pub const IPX_ADDRESS = @as(u32, 16391);
pub const IPX_GETNETINFO = @as(u32, 16392);
pub const IPX_GETNETINFO_NORIP = @as(u32, 16393);
pub const IPX_SPXGETCONNECTIONSTATUS = @as(u32, 16395);
pub const IPX_ADDRESS_NOTIFY = @as(u32, 16396);
pub const IPX_MAX_ADAPTER_NUM = @as(u32, 16397);
pub const IPX_RERIPNETNUMBER = @as(u32, 16398);
pub const IPX_RECEIVE_BROADCAST = @as(u32, 16399);
pub const IPX_IMMEDIATESPXACK = @as(u32, 16400);
pub const IPPROTO_RM = @as(u32, 113);
pub const MAX_MCAST_TTL = @as(u32, 255);
pub const RM_OPTIONSBASE = @as(u32, 1000);
pub const RM_RATE_WINDOW_SIZE = @as(u32, 1001);
pub const RM_SET_MESSAGE_BOUNDARY = @as(u32, 1002);
pub const RM_FLUSHCACHE = @as(u32, 1003);
pub const RM_SENDER_WINDOW_ADVANCE_METHOD = @as(u32, 1004);
pub const RM_SENDER_STATISTICS = @as(u32, 1005);
pub const RM_LATEJOIN = @as(u32, 1006);
pub const RM_SET_SEND_IF = @as(u32, 1007);
pub const RM_ADD_RECEIVE_IF = @as(u32, 1008);
pub const RM_DEL_RECEIVE_IF = @as(u32, 1009);
pub const RM_SEND_WINDOW_ADV_RATE = @as(u32, 1010);
pub const RM_USE_FEC = @as(u32, 1011);
pub const RM_SET_MCAST_TTL = @as(u32, 1012);
pub const RM_RECEIVER_STATISTICS = @as(u32, 1013);
pub const RM_HIGH_SPEED_INTRANET_OPT = @as(u32, 1014);
pub const SENDER_DEFAULT_RATE_KBITS_PER_SEC = @as(u32, 56);
pub const SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE = @as(u32, 15);
pub const MAX_WINDOW_INCREMENT_PERCENTAGE = @as(u32, 25);
pub const SENDER_DEFAULT_LATE_JOINER_PERCENTAGE = @as(u32, 0);
pub const SENDER_MAX_LATE_JOINER_PERCENTAGE = @as(u32, 75);
pub const BITS_PER_BYTE = @as(u32, 8);
pub const LOG2_BITS_PER_BYTE = @as(u32, 3);
pub const SOCKET_DEFAULT2_QM_POLICY = Guid.initString("aec2ef9c-3a4d-4d3e-8842-239942e39a47");
pub const REAL_TIME_NOTIFICATION_CAPABILITY = Guid.initString("6b59819a-5cae-492d-a901-2a3c2c50164f");
pub const REAL_TIME_NOTIFICATION_CAPABILITY_EX = Guid.initString("6843da03-154a-4616-a508-44371295f96b");
pub const ASSOCIATE_NAMERES_CONTEXT = Guid.initString("59a38b67-d4fe-46e1-ba3c-87ea74ca3049");
pub const TCP_INITIAL_RTO_DEFAULT_RTT = @as(u32, 0);
pub const TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS = @as(u32, 0);
pub const SOCKET_SETTINGS_GUARANTEE_ENCRYPTION = @as(u32, 1);
pub const SOCKET_SETTINGS_ALLOW_INSECURE = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION = @as(u32, 1);
pub const SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION = @as(u32, 2);
pub const SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED = @as(u32, 4);
pub const SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT = @as(u32, 8);
pub const SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID = @as(u32, 1);
pub const SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_SECURED = @as(u32, 1);
pub const SOCKET_INFO_CONNECTION_ENCRYPTED = @as(u32, 2);
pub const SOCKET_INFO_CONNECTION_IMPERSONATED = @as(u32, 4);
pub const IN4ADDR_LOOPBACK = @as(u32, 16777343);
pub const IN4ADDR_LOOPBACKPREFIX_LENGTH = @as(u32, 8);
pub const IN4ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 16);
pub const IN4ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 4);
pub const IFF_UP = @as(u32, 1);
pub const IFF_BROADCAST = @as(u32, 2);
pub const IFF_LOOPBACK = @as(u32, 4);
pub const IFF_POINTTOPOINT = @as(u32, 8);
pub const IFF_MULTICAST = @as(u32, 16);
pub const IP_OPTIONS = @as(u32, 1);
pub const IP_HDRINCL = @as(u32, 2);
pub const IP_TOS = @as(u32, 3);
pub const IP_TTL = @as(u32, 4);
pub const IP_MULTICAST_IF = @as(u32, 9);
pub const IP_MULTICAST_TTL = @as(u32, 10);
pub const IP_MULTICAST_LOOP = @as(u32, 11);
pub const IP_ADD_MEMBERSHIP = @as(u32, 12);
pub const IP_DROP_MEMBERSHIP = @as(u32, 13);
pub const IP_DONTFRAGMENT = @as(u32, 14);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(u32, 15);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(u32, 16);
pub const IP_BLOCK_SOURCE = @as(u32, 17);
pub const IP_UNBLOCK_SOURCE = @as(u32, 18);
pub const IP_PKTINFO = @as(u32, 19);
pub const IP_HOPLIMIT = @as(u32, 21);
pub const IP_RECVTTL = @as(u32, 21);
pub const IP_RECEIVE_BROADCAST = @as(u32, 22);
pub const IP_RECVIF = @as(u32, 24);
pub const IP_RECVDSTADDR = @as(u32, 25);
pub const IP_IFLIST = @as(u32, 28);
pub const IP_ADD_IFLIST = @as(u32, 29);
pub const IP_DEL_IFLIST = @as(u32, 30);
pub const IP_UNICAST_IF = @as(u32, 31);
pub const IP_RTHDR = @as(u32, 32);
pub const IP_GET_IFLIST = @as(u32, 33);
pub const IP_RECVRTHDR = @as(u32, 38);
pub const IP_TCLASS = @as(u32, 39);
pub const IP_RECVTCLASS = @as(u32, 40);
pub const IP_RECVTOS = @as(u32, 40);
pub const IP_ORIGINAL_ARRIVAL_IF = @as(u32, 47);
pub const IP_ECN = @as(u32, 50);
pub const IP_PKTINFO_EX = @as(u32, 51);
pub const IP_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IP_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IP_MTU_DISCOVER = @as(u32, 71);
pub const IP_MTU = @as(u32, 73);
pub const IP_NRT_INTERFACE = @as(u32, 74);
pub const IP_RECVERR = @as(u32, 75);
pub const IP_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_TYPE_OF_SERVICE = @as(i32, -1);
pub const IN6ADDR_LINKLOCALPREFIX_LENGTH = @as(u32, 64);
pub const IN6ADDR_MULTICASTPREFIX_LENGTH = @as(u32, 8);
pub const IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH = @as(u32, 104);
pub const IN6ADDR_V4MAPPEDPREFIX_LENGTH = @as(u32, 96);
pub const IN6ADDR_6TO4PREFIX_LENGTH = @as(u32, 16);
pub const IN6ADDR_TEREDOPREFIX_LENGTH = @as(u32, 32);
pub const MCAST_JOIN_GROUP = @as(u32, 41);
pub const MCAST_LEAVE_GROUP = @as(u32, 42);
pub const MCAST_BLOCK_SOURCE = @as(u32, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(u32, 44);
pub const MCAST_JOIN_SOURCE_GROUP = @as(u32, 45);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(u32, 46);
pub const IPV6_HOPOPTS = @as(u32, 1);
pub const IPV6_HDRINCL = @as(u32, 2);
pub const IPV6_UNICAST_HOPS = @as(u32, 4);
pub const IPV6_MULTICAST_IF = @as(u32, 9);
pub const IPV6_MULTICAST_HOPS = @as(u32, 10);
pub const IPV6_MULTICAST_LOOP = @as(u32, 11);
pub const IPV6_ADD_MEMBERSHIP = @as(u32, 12);
pub const IPV6_DROP_MEMBERSHIP = @as(u32, 13);
pub const IPV6_DONTFRAG = @as(u32, 14);
pub const IPV6_PKTINFO = @as(u32, 19);
pub const IPV6_HOPLIMIT = @as(u32, 21);
pub const IPV6_PROTECTION_LEVEL = @as(u32, 23);
pub const IPV6_RECVIF = @as(u32, 24);
pub const IPV6_RECVDSTADDR = @as(u32, 25);
pub const IPV6_CHECKSUM = @as(u32, 26);
pub const IPV6_V6ONLY = @as(u32, 27);
pub const IPV6_IFLIST = @as(u32, 28);
pub const IPV6_ADD_IFLIST = @as(u32, 29);
pub const IPV6_DEL_IFLIST = @as(u32, 30);
pub const IPV6_UNICAST_IF = @as(u32, 31);
pub const IPV6_RTHDR = @as(u32, 32);
pub const IPV6_GET_IFLIST = @as(u32, 33);
pub const IPV6_RECVRTHDR = @as(u32, 38);
pub const IPV6_TCLASS = @as(u32, 39);
pub const IPV6_RECVTCLASS = @as(u32, 40);
pub const IPV6_ECN = @as(u32, 50);
pub const IPV6_PKTINFO_EX = @as(u32, 51);
pub const IPV6_WFP_REDIRECT_RECORDS = @as(u32, 60);
pub const IPV6_WFP_REDIRECT_CONTEXT = @as(u32, 70);
pub const IPV6_MTU_DISCOVER = @as(u32, 71);
pub const IPV6_MTU = @as(u32, 72);
pub const IPV6_NRT_INTERFACE = @as(u32, 74);
pub const IPV6_RECVERR = @as(u32, 75);
pub const IPV6_USER_MTU = @as(u32, 76);
pub const IP_UNSPECIFIED_HOP_LIMIT = @as(i32, -1);
pub const PROTECTION_LEVEL_UNRESTRICTED = @as(u32, 10);
pub const PROTECTION_LEVEL_EDGERESTRICTED = @as(u32, 20);
pub const PROTECTION_LEVEL_RESTRICTED = @as(u32, 30);
pub const INET_ADDRSTRLEN = @as(u32, 22);
pub const INET6_ADDRSTRLEN = @as(u32, 65);
pub const TCP_OFFLOAD_NO_PREFERENCE = @as(u32, 0);
pub const TCP_OFFLOAD_NOT_PREFERRED = @as(u32, 1);
pub const TCP_OFFLOAD_PREFERRED = @as(u32, 2);
pub const TCP_EXPEDITED_1122 = @as(u32, 2);
pub const TCP_KEEPALIVE = @as(u32, 3);
pub const TCP_MAXSEG = @as(u32, 4);
pub const TCP_MAXRT = @as(u32, 5);
pub const TCP_STDURG = @as(u32, 6);
pub const TCP_NOURG = @as(u32, 7);
pub const TCP_ATMARK = @as(u32, 8);
pub const TCP_NOSYNRETRIES = @as(u32, 9);
pub const TCP_TIMESTAMPS = @as(u32, 10);
pub const TCP_OFFLOAD_PREFERENCE = @as(u32, 11);
pub const TCP_CONGESTION_ALGORITHM = @as(u32, 12);
pub const TCP_DELAY_FIN_ACK = @as(u32, 13);
pub const TCP_MAXRTMS = @as(u32, 14);
pub const TCP_FASTOPEN = @as(u32, 15);
pub const TCP_KEEPCNT = @as(u32, 16);
pub const TCP_KEEPINTVL = @as(u32, 17);
pub const TCP_FAIL_CONNECT_ON_ICMP_ERROR = @as(u32, 18);
pub const TCP_ICMP_ERROR_INFO = @as(u32, 19);
pub const UDP_SEND_MSG_SIZE = @as(u32, 2);
pub const UDP_RECV_MAX_COALESCED_SIZE = @as(u32, 3);
pub const UDP_COALESCED_INFO = @as(u32, 3);
pub const AF_UNIX = @as(u32, 1);
pub const AF_IMPLINK = @as(u32, 3);
pub const AF_PUP = @as(u32, 4);
pub const AF_CHAOS = @as(u32, 5);
pub const AF_NS = @as(u32, 6);
pub const AF_ISO = @as(u32, 7);
pub const AF_ECMA = @as(u32, 8);
pub const AF_DATAKIT = @as(u32, 9);
pub const AF_CCITT = @as(u32, 10);
pub const AF_SNA = @as(u32, 11);
pub const AF_DECnet = @as(u32, 12);
pub const AF_DLI = @as(u32, 13);
pub const AF_LAT = @as(u32, 14);
pub const AF_HYLINK = @as(u32, 15);
pub const AF_APPLETALK = @as(u32, 16);
pub const AF_NETBIOS = @as(u32, 17);
pub const AF_VOICEVIEW = @as(u32, 18);
pub const AF_FIREFOX = @as(u32, 19);
pub const AF_UNKNOWN1 = @as(u32, 20);
pub const AF_BAN = @as(u32, 21);
pub const AF_ATM = @as(u32, 22);
pub const AF_CLUSTER = @as(u32, 24);
pub const AF_12844 = @as(u32, 25);
pub const AF_IRDA = @as(u32, 26);
pub const AF_NETDES = @as(u32, 28);
pub const AF_MAX = @as(u32, 29);
pub const AF_TCNPROCESS = @as(u32, 29);
pub const AF_TCNMESSAGE = @as(u32, 30);
pub const AF_ICLFXBM = @as(u32, 31);
pub const AF_LINK = @as(u32, 33);
pub const AF_HYPERV = @as(u32, 34);
pub const SOCK_STREAM = @as(u32, 1);
pub const SOCK_DGRAM = @as(u32, 2);
pub const SOCK_RAW = @as(u32, 3);
pub const SOCK_RDM = @as(u32, 4);
pub const SOCK_SEQPACKET = @as(u32, 5);
pub const SOL_SOCKET = @as(u32, 65535);
pub const SO_DEBUG = @as(u32, 1);
pub const SO_ACCEPTCONN = @as(u32, 2);
pub const SO_REUSEADDR = @as(u32, 4);
pub const SO_KEEPALIVE = @as(u32, 8);
pub const SO_DONTROUTE = @as(u32, 16);
pub const SO_BROADCAST = @as(u32, 32);
pub const SO_USELOOPBACK = @as(u32, 64);
pub const SO_LINGER = @as(u32, 128);
pub const SO_OOBINLINE = @as(u32, 256);
pub const SO_SNDBUF = @as(u32, 4097);
pub const SO_RCVBUF = @as(u32, 4098);
pub const SO_SNDLOWAT = @as(u32, 4099);
pub const SO_RCVLOWAT = @as(u32, 4100);
pub const SO_SNDTIMEO = @as(u32, 4101);
pub const SO_RCVTIMEO = @as(u32, 4102);
pub const SO_ERROR = @as(u32, 4103);
pub const SO_TYPE = @as(u32, 4104);
pub const SO_BSP_STATE = @as(u32, 4105);
pub const SO_GROUP_ID = @as(u32, 8193);
pub const SO_GROUP_PRIORITY = @as(u32, 8194);
pub const SO_MAX_MSG_SIZE = @as(u32, 8195);
pub const SO_CONDITIONAL_ACCEPT = @as(u32, 12290);
pub const SO_PAUSE_ACCEPT = @as(u32, 12291);
pub const SO_COMPARTMENT_ID = @as(u32, 12292);
pub const SO_RANDOMIZE_PORT = @as(u32, 12293);
pub const SO_PORT_SCALABILITY = @as(u32, 12294);
pub const SO_REUSE_UNICASTPORT = @as(u32, 12295);
pub const SO_REUSE_MULTICASTPORT = @as(u32, 12296);
pub const SO_ORIGINAL_DST = @as(u32, 12303);
pub const WSK_SO_BASE = @as(u32, 16384);
pub const TCP_NODELAY = @as(u32, 1);
pub const IOC_UNIX = @as(u32, 0);
pub const IOC_WS2 = @as(u32, 134217728);
pub const IOC_PROTOCOL = @as(u32, 268435456);
pub const IOC_VENDOR = @as(u32, 402653184);
pub const IPPROTO_IP = @as(u32, 0);
pub const IPPORT_TCPMUX = @as(u32, 1);
pub const IPPORT_ECHO = @as(u32, 7);
pub const IPPORT_DISCARD = @as(u32, 9);
pub const IPPORT_SYSTAT = @as(u32, 11);
pub const IPPORT_DAYTIME = @as(u32, 13);
pub const IPPORT_NETSTAT = @as(u32, 15);
pub const IPPORT_QOTD = @as(u32, 17);
pub const IPPORT_MSP = @as(u32, 18);
pub const IPPORT_CHARGEN = @as(u32, 19);
pub const IPPORT_FTP_DATA = @as(u32, 20);
pub const IPPORT_FTP = @as(u32, 21);
pub const IPPORT_TELNET = @as(u32, 23);
pub const IPPORT_SMTP = @as(u32, 25);
pub const IPPORT_TIMESERVER = @as(u32, 37);
pub const IPPORT_NAMESERVER = @as(u32, 42);
pub const IPPORT_WHOIS = @as(u32, 43);
pub const IPPORT_MTP = @as(u32, 57);
pub const IPPORT_TFTP = @as(u32, 69);
pub const IPPORT_RJE = @as(u32, 77);
pub const IPPORT_FINGER = @as(u32, 79);
pub const IPPORT_TTYLINK = @as(u32, 87);
pub const IPPORT_SUPDUP = @as(u32, 95);
pub const IPPORT_POP3 = @as(u32, 110);
pub const IPPORT_NTP = @as(u32, 123);
pub const IPPORT_EPMAP = @as(u32, 135);
pub const IPPORT_NETBIOS_NS = @as(u32, 137);
pub const IPPORT_NETBIOS_DGM = @as(u32, 138);
pub const IPPORT_NETBIOS_SSN = @as(u32, 139);
pub const IPPORT_IMAP = @as(u32, 143);
pub const IPPORT_SNMP = @as(u32, 161);
pub const IPPORT_SNMP_TRAP = @as(u32, 162);
pub const IPPORT_IMAP3 = @as(u32, 220);
pub const IPPORT_LDAP = @as(u32, 389);
pub const IPPORT_HTTPS = @as(u32, 443);
pub const IPPORT_MICROSOFT_DS = @as(u32, 445);
pub const IPPORT_EXECSERVER = @as(u32, 512);
pub const IPPORT_LOGINSERVER = @as(u32, 513);
pub const IPPORT_CMDSERVER = @as(u32, 514);
pub const IPPORT_EFSSERVER = @as(u32, 520);
pub const IPPORT_BIFFUDP = @as(u32, 512);
pub const IPPORT_WHOSERVER = @as(u32, 513);
pub const IPPORT_ROUTESERVER = @as(u32, 520);
pub const IPPORT_RESERVED = @as(u32, 1024);
pub const IPPORT_REGISTERED_MAX = @as(u32, 49151);
pub const IPPORT_DYNAMIC_MIN = @as(u32, 49152);
pub const IPPORT_DYNAMIC_MAX = @as(u32, 65535);
pub const IN_CLASSA_NET = @as(u32, 4278190080);
pub const IN_CLASSA_NSHIFT = @as(u32, 24);
pub const IN_CLASSA_HOST = @as(u32, 16777215);
pub const IN_CLASSA_MAX = @as(u32, 128);
pub const IN_CLASSB_NET = @as(u32, 4294901760);
pub const IN_CLASSB_NSHIFT = @as(u32, 16);
pub const IN_CLASSB_HOST = @as(u32, 65535);
pub const IN_CLASSB_MAX = @as(u32, 65536);
pub const IN_CLASSC_NET = @as(u32, 4294967040);
pub const IN_CLASSC_NSHIFT = @as(u32, 8);
pub const IN_CLASSC_HOST = @as(u32, 255);
pub const IN_CLASSD_NET = @as(u32, 4026531840);
pub const IN_CLASSD_NSHIFT = @as(u32, 28);
pub const IN_CLASSD_HOST = @as(u32, 268435455);
pub const INADDR_LOOPBACK = @as(u32, 2130706433);
pub const INADDR_NONE = @as(u32, 4294967295);
pub const IOCPARM_MASK = @as(u32, 127);
pub const IOC_VOID = @as(u32, 536870912);
pub const IOC_OUT = @as(u32, 1073741824);
pub const IOC_IN = @as(u32, 2147483648);
pub const MSG_TRUNC = @as(u32, 256);
pub const MSG_CTRUNC = @as(u32, 512);
pub const MSG_BCAST = @as(u32, 1024);
pub const MSG_MCAST = @as(u32, 2048);
pub const MSG_ERRQUEUE = @as(u32, 4096);
pub const AI_PASSIVE = @as(u32, 1);
pub const AI_CANONNAME = @as(u32, 2);
pub const AI_NUMERICHOST = @as(u32, 4);
pub const AI_NUMERICSERV = @as(u32, 8);
pub const AI_DNS_ONLY = @as(u32, 16);
pub const AI_ALL = @as(u32, 256);
pub const AI_ADDRCONFIG = @as(u32, 1024);
pub const AI_V4MAPPED = @as(u32, 2048);
pub const AI_NON_AUTHORITATIVE = @as(u32, 16384);
pub const AI_SECURE = @as(u32, 32768);
pub const AI_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const AI_FQDN = @as(u32, 131072);
pub const AI_FILESERVER = @as(u32, 262144);
pub const AI_DISABLE_IDN_ENCODING = @as(u32, 524288);
pub const AI_EXTENDED = @as(u32, 2147483648);
pub const AI_RESOLUTION_HANDLE = @as(u32, 1073741824);
pub const ADDRINFOEX_VERSION_2 = @as(u32, 2);
pub const ADDRINFOEX_VERSION_3 = @as(u32, 3);
pub const ADDRINFOEX_VERSION_4 = @as(u32, 4);
pub const NS_ALL = @as(u32, 0);
pub const NS_SAP = @as(u32, 1);
pub const NS_NDS = @as(u32, 2);
pub const NS_PEER_BROWSE = @as(u32, 3);
pub const NS_SLP = @as(u32, 5);
pub const NS_DHCP = @as(u32, 6);
pub const NS_TCPIP_LOCAL = @as(u32, 10);
pub const NS_TCPIP_HOSTS = @as(u32, 11);
pub const NS_DNS = @as(u32, 12);
pub const NS_NETBT = @as(u32, 13);
pub const NS_WINS = @as(u32, 14);
pub const NS_NLA = @as(u32, 15);
pub const NS_NBP = @as(u32, 20);
pub const NS_MS = @as(u32, 30);
pub const NS_STDA = @as(u32, 31);
pub const NS_NTDS = @as(u32, 32);
pub const NS_EMAIL = @as(u32, 37);
pub const NS_X500 = @as(u32, 40);
pub const NS_NIS = @as(u32, 41);
pub const NS_NISPLUS = @as(u32, 42);
pub const NS_WRQ = @as(u32, 50);
pub const NS_NETDES = @as(u32, 60);
pub const NI_NOFQDN = @as(u32, 1);
pub const NI_NUMERICHOST = @as(u32, 2);
pub const NI_NAMEREQD = @as(u32, 4);
pub const NI_NUMERICSERV = @as(u32, 8);
pub const NI_DGRAM = @as(u32, 16);
pub const NI_MAXHOST = @as(u32, 1025);
pub const NI_MAXSERV = @as(u32, 32);
pub const INCL_WINSOCK_API_PROTOTYPES = @as(u32, 1);
pub const INCL_WINSOCK_API_TYPEDEFS = @as(u32, 0);
pub const FD_SETSIZE = @as(u32, 64);
pub const IMPLINK_IP = @as(u32, 155);
pub const IMPLINK_LOWEXPER = @as(u32, 156);
pub const IMPLINK_HIGHEXPER = @as(u32, 158);
pub const WSADESCRIPTION_LEN = @as(u32, 256);
pub const WSASYS_STATUS_LEN = @as(u32, 128);
pub const SOCKET_ERROR = @as(i32, -1);
pub const FROM_PROTOCOL_INFO = @as(i32, -1);
pub const SO_PROTOCOL_INFOA = @as(u32, 8196);
pub const SO_PROTOCOL_INFOW = @as(u32, 8197);
pub const PVD_CONFIG = @as(u32, 12289);
pub const SOMAXCONN = @as(u32, 2147483647);
pub const MSG_PEEK = @as(u32, 2);
pub const MSG_WAITALL = @as(u32, 8);
pub const MSG_PUSH_IMMEDIATE = @as(u32, 32);
pub const MSG_PARTIAL = @as(u32, 32768);
pub const MSG_INTERRUPT = @as(u32, 16);
pub const MSG_MAXIOVLEN = @as(u32, 16);
pub const MAXGETHOSTSTRUCT = @as(u32, 1024);
pub const FD_READ_BIT = @as(u32, 0);
pub const FD_WRITE_BIT = @as(u32, 1);
pub const FD_OOB_BIT = @as(u32, 2);
pub const FD_ACCEPT_BIT = @as(u32, 3);
pub const FD_CONNECT_BIT = @as(u32, 4);
pub const FD_CLOSE_BIT = @as(u32, 5);
pub const FD_QOS_BIT = @as(u32, 6);
pub const FD_GROUP_QOS_BIT = @as(u32, 7);
pub const FD_ROUTING_INTERFACE_CHANGE_BIT = @as(u32, 8);
pub const FD_ADDRESS_LIST_CHANGE_BIT = @as(u32, 9);
pub const FD_MAX_EVENTS = @as(u32, 10);
pub const CF_ACCEPT = @as(u32, 0);
pub const CF_REJECT = @as(u32, 1);
pub const CF_DEFER = @as(u32, 2);
pub const SD_RECEIVE = @as(u32, 0);
pub const SD_SEND = @as(u32, 1);
pub const SD_BOTH = @as(u32, 2);
pub const SG_UNCONSTRAINED_GROUP = @as(u32, 1);
pub const SG_CONSTRAINED_GROUP = @as(u32, 2);
pub const MAX_PROTOCOL_CHAIN = @as(u32, 7);
pub const BASE_PROTOCOL = @as(u32, 1);
pub const LAYERED_PROTOCOL = @as(u32, 0);
pub const WSAPROTOCOL_LEN = @as(u32, 255);
pub const PFL_MULTIPLE_PROTO_ENTRIES = @as(u32, 1);
pub const PFL_RECOMMENDED_PROTO_ENTRY = @as(u32, 2);
pub const PFL_HIDDEN = @as(u32, 4);
pub const PFL_MATCHES_PROTOCOL_ZERO = @as(u32, 8);
pub const PFL_NETWORKDIRECT_PROVIDER = @as(u32, 16);
pub const XP1_CONNECTIONLESS = @as(u32, 1);
pub const XP1_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP1_GUARANTEED_ORDER = @as(u32, 4);
pub const XP1_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP1_PSEUDO_STREAM = @as(u32, 16);
pub const XP1_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP1_EXPEDITED_DATA = @as(u32, 64);
pub const XP1_CONNECT_DATA = @as(u32, 128);
pub const XP1_DISCONNECT_DATA = @as(u32, 256);
pub const XP1_SUPPORT_BROADCAST = @as(u32, 512);
pub const XP1_SUPPORT_MULTIPOINT = @as(u32, 1024);
pub const XP1_MULTIPOINT_CONTROL_PLANE = @as(u32, 2048);
pub const XP1_MULTIPOINT_DATA_PLANE = @as(u32, 4096);
pub const XP1_QOS_SUPPORTED = @as(u32, 8192);
pub const XP1_INTERRUPT = @as(u32, 16384);
pub const XP1_UNI_SEND = @as(u32, 32768);
pub const XP1_UNI_RECV = @as(u32, 65536);
pub const XP1_IFS_HANDLES = @as(u32, 131072);
pub const XP1_PARTIAL_MESSAGE = @as(u32, 262144);
pub const XP1_SAN_SUPPORT_SDP = @as(u32, 524288);
pub const BIGENDIAN = @as(u32, 0);
pub const LITTLEENDIAN = @as(u32, 1);
pub const SECURITY_PROTOCOL_NONE = @as(u32, 0);
pub const JL_SENDER_ONLY = @as(u32, 1);
pub const JL_RECEIVER_ONLY = @as(u32, 2);
pub const JL_BOTH = @as(u32, 4);
pub const WSA_FLAG_OVERLAPPED = @as(u32, 1);
pub const WSA_FLAG_MULTIPOINT_C_ROOT = @as(u32, 2);
pub const WSA_FLAG_MULTIPOINT_C_LEAF = @as(u32, 4);
pub const WSA_FLAG_MULTIPOINT_D_ROOT = @as(u32, 8);
pub const WSA_FLAG_MULTIPOINT_D_LEAF = @as(u32, 16);
pub const WSA_FLAG_ACCESS_SYSTEM_SECURITY = @as(u32, 64);
pub const WSA_FLAG_NO_HANDLE_INHERIT = @as(u32, 128);
pub const WSA_FLAG_REGISTERED_IO = @as(u32, 256);
pub const TH_NETDEV = @as(u32, 1);
pub const TH_TAPI = @as(u32, 2);
pub const SERVICE_MULTIPLE = @as(u32, 1);
pub const NS_LOCALNAME = @as(u32, 19);
pub const RES_UNUSED_1 = @as(u32, 1);
pub const RES_FLUSH_CACHE = @as(u32, 2);
pub const RES_SERVICE = @as(u32, 4);
pub const LUP_DEEP = @as(u32, 1);
pub const LUP_CONTAINERS = @as(u32, 2);
pub const LUP_NOCONTAINERS = @as(u32, 4);
pub const LUP_NEAREST = @as(u32, 8);
pub const LUP_RETURN_NAME = @as(u32, 16);
pub const LUP_RETURN_TYPE = @as(u32, 32);
pub const LUP_RETURN_VERSION = @as(u32, 64);
pub const LUP_RETURN_COMMENT = @as(u32, 128);
pub const LUP_RETURN_ADDR = @as(u32, 256);
pub const LUP_RETURN_BLOB = @as(u32, 512);
pub const LUP_RETURN_ALIASES = @as(u32, 1024);
pub const LUP_RETURN_QUERY_STRING = @as(u32, 2048);
pub const LUP_RETURN_ALL = @as(u32, 4080);
pub const LUP_RES_SERVICE = @as(u32, 32768);
pub const LUP_FLUSHCACHE = @as(u32, 4096);
pub const LUP_FLUSHPREVIOUS = @as(u32, 8192);
pub const LUP_NON_AUTHORITATIVE = @as(u32, 16384);
pub const LUP_SECURE = @as(u32, 32768);
pub const LUP_RETURN_PREFERRED_NAMES = @as(u32, 65536);
pub const LUP_DNS_ONLY = @as(u32, 131072);
pub const LUP_ADDRCONFIG = @as(u32, 1048576);
pub const LUP_DUAL_ADDR = @as(u32, 2097152);
pub const LUP_FILESERVER = @as(u32, 4194304);
pub const LUP_DISABLE_IDN_ENCODING = @as(u32, 8388608);
pub const LUP_API_ANSI = @as(u32, 16777216);
pub const LUP_RESOLUTION_HANDLE = @as(u32, 2147483648);
pub const RESULT_IS_ALIAS = @as(u32, 1);
pub const RESULT_IS_ADDED = @as(u32, 16);
pub const RESULT_IS_CHANGED = @as(u32, 32);
pub const RESULT_IS_DELETED = @as(u32, 64);
pub const POLLRDNORM = @as(u32, 256);
pub const POLLRDBAND = @as(u32, 512);
pub const POLLPRI = @as(u32, 1024);
pub const POLLWRNORM = @as(u32, 16);
pub const POLLWRBAND = @as(u32, 32);
pub const POLLERR = @as(u32, 1);
pub const POLLHUP = @as(u32, 2);
pub const POLLNVAL = @as(u32, 4);
pub const SO_CONNDATA = @as(u32, 28672);
pub const SO_CONNOPT = @as(u32, 28673);
pub const SO_DISCDATA = @as(u32, 28674);
pub const SO_DISCOPT = @as(u32, 28675);
pub const SO_CONNDATALEN = @as(u32, 28676);
pub const SO_CONNOPTLEN = @as(u32, 28677);
pub const SO_DISCDATALEN = @as(u32, 28678);
pub const SO_DISCOPTLEN = @as(u32, 28679);
pub const SO_OPENTYPE = @as(u32, 28680);
pub const SO_SYNCHRONOUS_ALERT = @as(u32, 16);
pub const SO_SYNCHRONOUS_NONALERT = @as(u32, 32);
pub const SO_MAXDG = @as(u32, 28681);
pub const SO_MAXPATHDG = @as(u32, 28682);
pub const SO_UPDATE_ACCEPT_CONTEXT = @as(u32, 28683);
pub const SO_CONNECT_TIME = @as(u32, 28684);
pub const SO_UPDATE_CONNECT_CONTEXT = @as(u32, 28688);
pub const TCP_BSDURGENT = @as(u32, 28672);
pub const TF_DISCONNECT = @as(u32, 1);
pub const TF_REUSE_SOCKET = @as(u32, 2);
pub const TF_WRITE_BEHIND = @as(u32, 4);
pub const TF_USE_DEFAULT_WORKER = @as(u32, 0);
pub const TF_USE_SYSTEM_THREAD = @as(u32, 16);
pub const TF_USE_KERNEL_APC = @as(u32, 32);
pub const TP_ELEMENT_MEMORY = @as(u32, 1);
pub const TP_ELEMENT_FILE = @as(u32, 2);
pub const TP_ELEMENT_EOP = @as(u32, 4);
pub const NLA_ALLUSERS_NETWORK = @as(u32, 1);
pub const NLA_FRIENDLY_NAME = @as(u32, 2);
pub const WSPDESCRIPTION_LEN = @as(u32, 255);
pub const WSS_OPERATION_IN_PROGRESS = @as(i32, 259);
pub const LSP_SYSTEM = @as(u32, 2147483648);
pub const LSP_INSPECTOR = @as(u32, 1);
pub const LSP_REDIRECTOR = @as(u32, 2);
pub const LSP_PROXY = @as(u32, 4);
pub const LSP_FIREWALL = @as(u32, 8);
pub const LSP_INBOUND_MODIFY = @as(u32, 16);
pub const LSP_OUTBOUND_MODIFY = @as(u32, 32);
pub const LSP_CRYPTO_COMPRESS = @as(u32, 64);
pub const LSP_LOCAL_CACHE = @as(u32, 128);
pub const IPPROTO_ICMP = @as(u32, 1);
pub const IPPROTO_IGMP = @as(u32, 2);
pub const IPPROTO_GGP = @as(u32, 3);
pub const IPPROTO_TCP = @as(u32, 6);
pub const IPPROTO_PUP = @as(u32, 12);
pub const IPPROTO_UDP = @as(u32, 17);
pub const IPPROTO_IDP = @as(u32, 22);
pub const IPPROTO_ND = @as(u32, 77);
pub const IPPROTO_RAW = @as(u32, 255);
pub const IPPROTO_MAX = @as(u32, 256);
pub const IP_DEFAULT_MULTICAST_TTL = @as(u32, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(u32, 1);
pub const IP_MAX_MEMBERSHIPS = @as(u32, 20);
pub const AF_IPX = @as(u32, 6);
pub const FD_READ = @as(u32, 1);
pub const FD_WRITE = @as(u32, 2);
pub const FD_OOB = @as(u32, 4);
pub const FD_ACCEPT = @as(u32, 8);
pub const FD_CONNECT = @as(u32, 16);
pub const FD_CLOSE = @as(u32, 32);
pub const SERVICE_RESOURCE = @as(u32, 1);
pub const SERVICE_SERVICE = @as(u32, 2);
pub const SERVICE_LOCAL = @as(u32, 4);
pub const SERVICE_FLAG_DEFER = @as(u32, 1);
pub const SERVICE_FLAG_HARD = @as(u32, 2);
pub const PROP_COMMENT = @as(u32, 1);
pub const PROP_LOCALE = @as(u32, 2);
pub const PROP_DISPLAY_HINT = @as(u32, 4);
pub const PROP_VERSION = @as(u32, 8);
pub const PROP_START_TIME = @as(u32, 16);
pub const PROP_MACHINE = @as(u32, 32);
pub const PROP_ADDRESSES = @as(u32, 256);
pub const PROP_SD = @as(u32, 512);
pub const PROP_ALL = @as(u32, 2147483648);
pub const SERVICE_ADDRESS_FLAG_RPC_CN = @as(u32, 1);
pub const SERVICE_ADDRESS_FLAG_RPC_DG = @as(u32, 2);
pub const SERVICE_ADDRESS_FLAG_RPC_NB = @as(u32, 4);
pub const NS_DEFAULT = @as(u32, 0);
pub const NS_VNS = @as(u32, 50);
pub const NSTYPE_HIERARCHICAL = @as(u32, 1);
pub const NSTYPE_DYNAMIC = @as(u32, 2);
pub const NSTYPE_ENUMERABLE = @as(u32, 4);
pub const NSTYPE_WORKGROUP = @as(u32, 8);
pub const XP_CONNECTIONLESS = @as(u32, 1);
pub const XP_GUARANTEED_DELIVERY = @as(u32, 2);
pub const XP_GUARANTEED_ORDER = @as(u32, 4);
pub const XP_MESSAGE_ORIENTED = @as(u32, 8);
pub const XP_PSEUDO_STREAM = @as(u32, 16);
pub const XP_GRACEFUL_CLOSE = @as(u32, 32);
pub const XP_EXPEDITED_DATA = @as(u32, 64);
pub const XP_CONNECT_DATA = @as(u32, 128);
pub const XP_DISCONNECT_DATA = @as(u32, 256);
pub const XP_SUPPORTS_BROADCAST = @as(u32, 512);
pub const XP_SUPPORTS_MULTICAST = @as(u32, 1024);
pub const XP_BANDWIDTH_ALLOCATION = @as(u32, 2048);
pub const XP_FRAGMENTATION = @as(u32, 4096);
pub const XP_ENCRYPTS = @as(u32, 8192);
pub const RES_SOFT_SEARCH = @as(u32, 1);
pub const RES_FIND_MULTIPLE = @as(u32, 2);
pub const SET_SERVICE_PARTIAL_SUCCESS = @as(u32, 1);
pub const UDP_NOCHECKSUM = @as(u32, 1);
pub const UDP_CHECKSUM_COVERAGE = @as(u32, 20);
pub const GAI_STRERROR_BUFFER_SIZE = @as(u32, 1024);

//--------------------------------------------------------------------------------
// Section: Types (304)
//--------------------------------------------------------------------------------
pub const SOCKADDR = extern struct {
    sa_family: u16,
    sa_data: [14]CHAR,
};

pub const SOCKET_ADDRESS = extern struct {
    lpSockaddr: *SOCKADDR,
    iSockaddrLength: i32,
};

pub const CSADDR_INFO = extern struct {
    LocalAddr: SOCKET_ADDRESS,
    RemoteAddr: SOCKET_ADDRESS,
    iSocketType: i32,
    iProtocol: i32,
};

pub const SOCKADDR_STORAGE = extern struct {
    ss_family: u16,
    __ss_pad1: [6]CHAR,
    __ss_align: i64,
    __ss_pad2: [112]CHAR,
};

pub const SOCKET_PROCESSOR_AFFINITY = extern struct {
    Processor: PROCESSOR_NUMBER,
    NumaNodeId: u16,
    Reserved: u16,
};

pub const IPPROTO = extern enum(i32) {
    HOPOPTS = 0,
    ICMP = 1,
    IGMP = 2,
    GGP = 3,
    IPV4 = 4,
    ST = 5,
    TCP = 6,
    CBT = 7,
    EGP = 8,
    IGP = 9,
    PUP = 12,
    UDP = 17,
    IDP = 22,
    RDP = 27,
    IPV6 = 41,
    ROUTING = 43,
    FRAGMENT = 44,
    ESP = 50,
    AH = 51,
    ICMPV6 = 58,
    NONE = 59,
    DSTOPTS = 60,
    ND = 77,
    ICLFXBM = 78,
    PIM = 103,
    PGM = 113,
    L2TP = 115,
    SCTP = 132,
    RAW = 255,
    MAX = 256,
    RESERVED_RAW = 257,
    RESERVED_IPSEC = 258,
    RESERVED_IPSECOFFLOAD = 259,
    RESERVED_WNV = 260,
    RESERVED_MAX = 261,
};
// TODO: enum 'IPPROTO' has known issues with its value aliases

pub const SCOPE_ID = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SOCKADDR_IN = extern struct {
    sin_family: u16,
    sin_port: u16,
    sin_addr: IN_ADDR,
    sin_zero: [8]CHAR,
};

pub const SOCKADDR_DL = extern struct {
    sdl_family: u16,
    sdl_data: [8]u8,
    sdl_zero: [4]u8,
};

pub const WSABUF = extern struct {
    len: u32,
    buf: PSTR,
};

pub const WSAMSG = extern struct {
    name: *SOCKADDR,
    namelen: i32,
    lpBuffers: *WSABUF,
    dwBufferCount: u32,
    Control: WSABUF,
    dwFlags: u32,
};

pub const cmsghdr = extern struct {
    cmsg_len: usize,
    cmsg_level: i32,
    cmsg_type: i32,
};

pub const ADDRINFOA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PSTR,
    ai_addr: *SOCKADDR,
    ai_next: *ADDRINFOA,
};

pub const addrinfoW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_next: *addrinfoW,
};

pub const addrinfoexA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoexA,
};

pub const addrinfoexW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoexW,
};

pub const addrinfoex2A = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoex2A,
    ai_version: i32,
    ai_fqdn: PSTR,
};

pub const addrinfoex2W = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoex2W,
    ai_version: i32,
    ai_fqdn: PWSTR,
};

pub const addrinfoex3 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoex3,
    ai_version: i32,
    ai_fqdn: PWSTR,
    ai_interfaceindex: i32,
};

pub const addrinfoex4 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: usize,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: usize,
    ai_provider: *Guid,
    ai_next: *addrinfoex4,
    ai_version: i32,
    ai_fqdn: PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: HANDLE,
};

pub const fd_set = extern struct {
    fd_count: u32,
    fd_array: [64]usize,
};

pub const timeval = extern struct {
    tv_sec: i32,
    tv_usec: i32,
};

pub const hostent = extern struct {
    h_name: PSTR,
    h_aliases: **i8,
    h_addrtype: i16,
    h_length: i16,
    h_addr_list: **i8,
};

pub const netent = extern struct {
    n_name: PSTR,
    n_aliases: **i8,
    n_addrtype: i16,
    n_net: u32,
};

pub const protoent = extern struct {
    p_name: PSTR,
    p_aliases: **i8,
    p_proto: i16,
};

pub const sockproto = extern struct {
    sp_family: u16,
    sp_protocol: u16,
};

pub const linger = extern struct {
    l_onoff: u16,
    l_linger: u16,
};

pub const WSANETWORKEVENTS = extern struct {
    lNetworkEvents: i32,
    iErrorCode: [10]i32,
};

pub const WSAPROTOCOLCHAIN = extern struct {
    ChainLen: i32,
    ChainEntries: [7]u32,
};

pub const WSAPROTOCOL_INFOA = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]CHAR,
};

pub const WSAPROTOCOL_INFOW = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]u16,
};

pub const LPCONDITIONPROC = fn(
    lpCallerId: *WSABUF,
    lpCallerData: *WSABUF,
    lpSQOS: *QOS,
    lpGQOS: *QOS,
    lpCalleeId: *WSABUF,
    lpCalleeData: *WSABUF,
    g: *u32,
    dwCallbackData: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSAOVERLAPPED_COMPLETION_ROUTINE = fn(
    dwError: u32,
    cbTransferred: u32,
    lpOverlapped: *OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSACOMPLETIONTYPE = extern enum(i32) {
    IMMEDIATELY = 0,
    HWND = 1,
    EVENT = 2,
    PORT = 3,
    APC = 4,
};
pub const NSP_NOTIFY_IMMEDIATELY = WSACOMPLETIONTYPE.IMMEDIATELY;
pub const NSP_NOTIFY_HWND = WSACOMPLETIONTYPE.HWND;
pub const NSP_NOTIFY_EVENT = WSACOMPLETIONTYPE.EVENT;
pub const NSP_NOTIFY_PORT = WSACOMPLETIONTYPE.PORT;
pub const NSP_NOTIFY_APC = WSACOMPLETIONTYPE.APC;

pub const WSACOMPLETION = extern struct {
    Type: WSACOMPLETIONTYPE,
    Parameters: _Parameters_e__Union,
    const _Parameters_e__Union = u32; // TODO: generate this nested type!
};

pub const AFPROTOCOLS = extern struct {
    iAddressFamily: i32,
    iProtocol: i32,
};

pub const WSAECOMPARATOR = extern enum(i32) {
    EQUAL = 0,
    NOTLESS = 1,
};
pub const COMP_EQUAL = WSAECOMPARATOR.EQUAL;
pub const COMP_NOTLESS = WSAECOMPARATOR.NOTLESS;

pub const WSAVERSION = extern struct {
    dwVersion: u32,
    ecHow: WSAECOMPARATOR,
};

pub const WSAQUERYSETA = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PSTR,
    lpServiceClassId: *Guid,
    lpVersion: *WSAVERSION,
    lpszComment: PSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSETW = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PWSTR,
    lpServiceClassId: *Guid,
    lpVersion: *WSAVERSION,
    lpszComment: PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSET2A = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PSTR,
    lpVersion: *WSAVERSION,
    lpszComment: PSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSET2W = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PWSTR,
    lpVersion: *WSAVERSION,
    lpszComment: PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAESETSERVICEOP = extern enum(i32) {
    REGISTER = 0,
    DEREGISTER = 1,
    DELETE = 2,
};
pub const RNRSERVICE_REGISTER = WSAESETSERVICEOP.REGISTER;
pub const RNRSERVICE_DEREGISTER = WSAESETSERVICEOP.DEREGISTER;
pub const RNRSERVICE_DELETE = WSAESETSERVICEOP.DELETE;

pub const WSANSCLASSINFOA = extern struct {
    lpszName: PSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: *c_void,
};

pub const WSANSCLASSINFOW = extern struct {
    lpszName: PWSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: *c_void,
};

pub const WSASERVICECLASSINFOA = extern struct {
    lpServiceClassId: *Guid,
    lpszServiceClassName: PSTR,
    dwCount: u32,
    lpClassInfos: *WSANSCLASSINFOA,
};

pub const WSASERVICECLASSINFOW = extern struct {
    lpServiceClassId: *Guid,
    lpszServiceClassName: PWSTR,
    dwCount: u32,
    lpClassInfos: *WSANSCLASSINFOW,
};

pub const WSANAMESPACE_INFOA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PSTR,
};

pub const WSANAMESPACE_INFOW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PWSTR,
};

pub const WSANAMESPACE_INFOEXA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PSTR,
    ProviderSpecific: BLOB,
};

pub const WSANAMESPACE_INFOEXW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PWSTR,
    ProviderSpecific: BLOB,
};

pub const WSAPOLLFD = extern struct {
    fd: usize,
    events: i16,
    revents: i16,
};

pub const sockaddr_in6_old = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
};

pub const sockaddr_gen = extern union {
    Address: SOCKADDR,
    AddressIn: SOCKADDR_IN,
    AddressIn6: sockaddr_in6_old,
};

pub const INTERFACE_INFO = extern struct {
    iiFlags: u32,
    iiAddress: sockaddr_gen,
    iiBroadcastAddress: sockaddr_gen,
    iiNetmask: sockaddr_gen,
};

pub const INTERFACE_INFO_EX = extern struct {
    iiFlags: u32,
    iiAddress: SOCKET_ADDRESS,
    iiBroadcastAddress: SOCKET_ADDRESS,
    iiNetmask: SOCKET_ADDRESS,
};

pub const PMTUD_STATE = extern enum(i32) {
    NOT_SET = 0,
    DO = 1,
    DONT = 2,
    PROBE = 3,
    MAX = 4,
};
pub const IP_PMTUDISC_NOT_SET = PMTUD_STATE.NOT_SET;
pub const IP_PMTUDISC_DO = PMTUD_STATE.DO;
pub const IP_PMTUDISC_DONT = PMTUD_STATE.DONT;
pub const IP_PMTUDISC_PROBE = PMTUD_STATE.PROBE;
pub const IP_PMTUDISC_MAX = PMTUD_STATE.MAX;

pub const SOCKADDR_IN6 = extern struct {
    sin6_family: u16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: IN6_ADDR,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MULTICAST_MODE_TYPE = extern enum(i32) {
    INCLUDE = 0,
    EXCLUDE = 1,
};
pub const MCAST_INCLUDE = MULTICAST_MODE_TYPE.INCLUDE;
pub const MCAST_EXCLUDE = MULTICAST_MODE_TYPE.EXCLUDE;

pub const IP_MREQ = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MREQ_SOURCE = extern struct {
    imr_multiaddr: IN_ADDR,
    imr_sourceaddr: IN_ADDR,
    imr_interface: IN_ADDR,
};

pub const IP_MSFILTER = extern struct {
    imsf_multiaddr: IN_ADDR,
    imsf_interface: IN_ADDR,
    imsf_fmode: MULTICAST_MODE_TYPE,
    imsf_numsrc: u32,
    imsf_slist: [1]IN_ADDR,
};

pub const IPV6_MREQ = extern struct {
    ipv6mr_multiaddr: IN6_ADDR,
    ipv6mr_interface: u32,
};

pub const GROUP_REQ = extern struct {
    gr_interface: u32,
    gr_group: SOCKADDR_STORAGE,
};

pub const GROUP_SOURCE_REQ = extern struct {
    gsr_interface: u32,
    gsr_group: SOCKADDR_STORAGE,
    gsr_source: SOCKADDR_STORAGE,
};

pub const GROUP_FILTER = extern struct {
    gf_interface: u32,
    gf_group: SOCKADDR_STORAGE,
    gf_fmode: MULTICAST_MODE_TYPE,
    gf_numsrc: u32,
    gf_slist: [1]SOCKADDR_STORAGE,
};

pub const IN_PKTINFO = extern struct {
    ipi_addr: IN_ADDR,
    ipi_ifindex: u32,
};

pub const IN6_PKTINFO = extern struct {
    ipi6_addr: IN6_ADDR,
    ipi6_ifindex: u32,
};

pub const IN_PKTINFO_EX = extern struct {
    pkt_info: IN_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const in6_pktinfo_ex = extern struct {
    pkt_info: IN6_PKTINFO,
    scope_id: SCOPE_ID,
};

pub const IN_RECVERR = extern struct {
    protocol: IPPROTO,
    info: u32,
    type: u8,
    code: u8,
};

pub const ICMP_ERROR_INFO = extern struct {
    srcaddress: SOCKADDR_INET,
    protocol: IPPROTO,
    type: u8,
    code: u8,
};

pub const eWINDOW_ADVANCE_METHOD = extern enum(i32) {
    ADVANCE_BY_TIME = 1,
    USE_AS_DATA_CACHE = 2,
};
pub const E_WINDOW_ADVANCE_BY_TIME = eWINDOW_ADVANCE_METHOD.ADVANCE_BY_TIME;
pub const E_WINDOW_USE_AS_DATA_CACHE = eWINDOW_ADVANCE_METHOD.USE_AS_DATA_CACHE;

pub const RM_SEND_WINDOW = extern struct {
    RateKbitsPerSec: u32,
    WindowSizeInMSecs: u32,
    WindowSizeInBytes: u32,
};

pub const RM_SENDER_STATS = extern struct {
    DataBytesSent: u64,
    TotalBytesSent: u64,
    NaksReceived: u64,
    NaksReceivedTooLate: u64,
    NumOutstandingNaks: u64,
    NumNaksAfterRData: u64,
    RepairPacketsSent: u64,
    BufferSpaceAvailable: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TotalODataPacketsSent: u64,
};

pub const RM_RECEIVER_STATS = extern struct {
    NumODataPacketsReceived: u64,
    NumRDataPacketsReceived: u64,
    NumDuplicateDataPackets: u64,
    DataBytesReceived: u64,
    TotalBytesReceived: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    AverageSequencesInWindow: u64,
    MinSequencesInWindow: u64,
    MaxSequencesInWindow: u64,
    FirstNakSequenceNumber: u64,
    NumPendingNaks: u64,
    NumOutstandingNaks: u64,
    NumDataPacketsBuffered: u64,
    TotalSelectiveNaksSent: u64,
    TotalParityNaksSent: u64,
};

pub const RM_FEC_INFO = extern struct {
    FECBlockSize: u16,
    FECProActivePackets: u16,
    FECGroupSize: u8,
    fFECOnDemandParityEnabled: u8,
};

pub const IPX_ADDRESS_DATA = extern struct {
    adapternum: i32,
    netnum: [4]u8,
    nodenum: [6]u8,
    wan: u8,
    status: u8,
    maxpkt: i32,
    linkspeed: u32,
};

pub const IPX_NETNUM_DATA = extern struct {
    netnum: [4]u8,
    hopcount: u16,
    netdelay: u16,
    cardnum: i32,
    router: [6]u8,
};

pub const IPX_SPXCONNSTATUS_DATA = extern struct {
    ConnectionState: u8,
    WatchDogActive: u8,
    LocalConnectionId: u16,
    RemoteConnectionId: u16,
    LocalSequenceNumber: u16,
    LocalAckNumber: u16,
    LocalAllocNumber: u16,
    RemoteAckNumber: u16,
    RemoteAllocNumber: u16,
    LocalSocket: u16,
    ImmediateAddress: [6]u8,
    RemoteNetwork: [4]u8,
    RemoteNode: [6]u8,
    RemoteSocket: u16,
    RetransmissionCount: u16,
    EstimatedRoundTripDelay: u16,
    RetransmittedPackets: u16,
    SuppressedPacket: u16,
};

pub const LM_IRPARMS = extern struct {
    nTXDataBytes: u32,
    nRXDataBytes: u32,
    nBaudRate: u32,
    thresholdTime: u32,
    discTime: u32,
    nMSLinkTurn: u16,
    nTXPackets: u8,
    nRXPackets: u8,
};

pub const SOCKADDR_IRDA = extern struct {
    irdaAddressFamily: u16,
    irdaDeviceID: [4]u8,
    irdaServiceName: [25]CHAR,
};

pub const WINDOWS_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    irdaDeviceHints1: u8,
    irdaDeviceHints2: u8,
    irdaCharSet: u8,
};

pub const WCE_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]CHAR,
    Reserved: [2]u8,
};

pub const WINDOWS_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WINDOWS_IRDA_DEVICE_INFO,
};

pub const WCE_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WCE_IRDA_DEVICE_INFO,
};

pub const WINDOWS_IAS_SET = extern struct {
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: _irdaAttribute_e__Union,
    const _irdaAttribute_e__Union = u32; // TODO: generate this nested type!
};

pub const WINDOWS_IAS_QUERY = extern struct {
    irdaDeviceID: [4]u8,
    irdaClassName: [64]CHAR,
    irdaAttribName: [256]CHAR,
    irdaAttribType: u32,
    irdaAttribute: _irdaAttribute_e__Union,
    const _irdaAttribute_e__Union = u32; // TODO: generate this nested type!
};

pub const NL_BANDWIDTH_FLAG = extern enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const NlbwDisabled = NL_BANDWIDTH_FLAG.Disabled;
pub const NlbwEnabled = NL_BANDWIDTH_FLAG.Enabled;
pub const NlbwUnchanged = NL_BANDWIDTH_FLAG.Unchanged;

pub const NL_PATH_BANDWIDTH_ROD = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

pub const NL_NETWORK_CATEGORY = extern enum(i32) {
    Public = 0,
    Private = 1,
    DomainAuthenticated = 2,
    Unchanged = -1,
    Unknown = -1,
};
pub const NetworkCategoryPublic = NL_NETWORK_CATEGORY.Public;
pub const NetworkCategoryPrivate = NL_NETWORK_CATEGORY.Private;
pub const NetworkCategoryDomainAuthenticated = NL_NETWORK_CATEGORY.DomainAuthenticated;
pub const NetworkCategoryUnchanged = NL_NETWORK_CATEGORY.Unchanged;
pub const NetworkCategoryUnknown = NL_NETWORK_CATEGORY.Unknown;

pub const NL_INTERFACE_NETWORK_CATEGORY_STATE = extern enum(i32) {
    CategoryUnknown = 0,
    Public = 1,
    Private = 2,
    DomainAuthenticated = 3,
    CategoryStateMax = 4,
};
pub const NlincCategoryUnknown = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryUnknown;
pub const NlincPublic = NL_INTERFACE_NETWORK_CATEGORY_STATE.Public;
pub const NlincPrivate = NL_INTERFACE_NETWORK_CATEGORY_STATE.Private;
pub const NlincDomainAuthenticated = NL_INTERFACE_NETWORK_CATEGORY_STATE.DomainAuthenticated;
pub const NlincCategoryStateMax = NL_INTERFACE_NETWORK_CATEGORY_STATE.CategoryStateMax;

pub const TCPSTATE = extern enum(i32) {
    CLOSED = 0,
    LISTEN = 1,
    SYN_SENT = 2,
    SYN_RCVD = 3,
    ESTABLISHED = 4,
    FIN_WAIT_1 = 5,
    FIN_WAIT_2 = 6,
    CLOSE_WAIT = 7,
    CLOSING = 8,
    LAST_ACK = 9,
    TIME_WAIT = 10,
    MAX = 11,
};
pub const TCPSTATE_CLOSED = TCPSTATE.CLOSED;
pub const TCPSTATE_LISTEN = TCPSTATE.LISTEN;
pub const TCPSTATE_SYN_SENT = TCPSTATE.SYN_SENT;
pub const TCPSTATE_SYN_RCVD = TCPSTATE.SYN_RCVD;
pub const TCPSTATE_ESTABLISHED = TCPSTATE.ESTABLISHED;
pub const TCPSTATE_FIN_WAIT_1 = TCPSTATE.FIN_WAIT_1;
pub const TCPSTATE_FIN_WAIT_2 = TCPSTATE.FIN_WAIT_2;
pub const TCPSTATE_CLOSE_WAIT = TCPSTATE.CLOSE_WAIT;
pub const TCPSTATE_CLOSING = TCPSTATE.CLOSING;
pub const TCPSTATE_LAST_ACK = TCPSTATE.LAST_ACK;
pub const TCPSTATE_TIME_WAIT = TCPSTATE.TIME_WAIT;
pub const TCPSTATE_MAX = TCPSTATE.MAX;

pub const TRANSPORT_SETTING_ID = extern struct {
    Guid: Guid,
};

pub const tcp_keepalive = extern struct {
    onoff: u32,
    keepalivetime: u32,
    keepaliveinterval: u32,
};

pub const CONTROL_CHANNEL_TRIGGER_STATUS = extern enum(i32) {
    INVALID = 0,
    SOFTWARE_SLOT_ALLOCATED = 1,
    HARDWARE_SLOT_ALLOCATED = 2,
    POLICY_ERROR = 3,
    SYSTEM_ERROR = 4,
    TRANSPORT_DISCONNECTED = 5,
    SERVICE_UNAVAILABLE = 6,
};
pub const CONTROL_CHANNEL_TRIGGER_STATUS_INVALID = CONTROL_CHANNEL_TRIGGER_STATUS.INVALID;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.SOFTWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.HARDWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.POLICY_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.SYSTEM_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED = CONTROL_CHANNEL_TRIGGER_STATUS.TRANSPORT_DISCONNECTED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE = CONTROL_CHANNEL_TRIGGER_STATUS.SERVICE_UNAVAILABLE;

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
};

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT_EX = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
    Unmark: u8,
};

pub const REAL_TIME_NOTIFICATION_SETTING_OUTPUT = extern struct {
    ChannelStatus: CONTROL_CHANNEL_TRIGGER_STATUS,
};

pub const ASSOCIATE_NAMERES_CONTEXT_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    Handle: u64,
};

pub const RCVALL_VALUE = extern enum(i32) {
    OFF = 0,
    ON = 1,
    SOCKETLEVELONLY = 2,
    IPLEVEL = 3,
};
pub const RCVALL_OFF = RCVALL_VALUE.OFF;
pub const RCVALL_ON = RCVALL_VALUE.ON;
pub const RCVALL_SOCKETLEVELONLY = RCVALL_VALUE.SOCKETLEVELONLY;
pub const RCVALL_IPLEVEL = RCVALL_VALUE.IPLEVEL;

pub const RCVALL_IF = extern struct {
    Mode: RCVALL_VALUE,
    Interface: u32,
};

pub const TCP_INITIAL_RTO_PARAMETERS = extern struct {
    Rtt: u16,
    MaxSynRetransmissions: u8,
};

pub const TCP_ICW_LEVEL = extern enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
    VERY_HIGH = 2,
    AGGRESSIVE = 3,
    EXPERIMENTAL = 4,
    COMPAT = 254,
    MAX = 255,
};
pub const TCP_ICW_LEVEL_DEFAULT = TCP_ICW_LEVEL.DEFAULT;
pub const TCP_ICW_LEVEL_HIGH = TCP_ICW_LEVEL.HIGH;
pub const TCP_ICW_LEVEL_VERY_HIGH = TCP_ICW_LEVEL.VERY_HIGH;
pub const TCP_ICW_LEVEL_AGGRESSIVE = TCP_ICW_LEVEL.AGGRESSIVE;
pub const TCP_ICW_LEVEL_EXPERIMENTAL = TCP_ICW_LEVEL.EXPERIMENTAL;
pub const TCP_ICW_LEVEL_COMPAT = TCP_ICW_LEVEL.COMPAT;
pub const TCP_ICW_LEVEL_MAX = TCP_ICW_LEVEL.MAX;

pub const TCP_ICW_PARAMETERS = extern struct {
    Level: TCP_ICW_LEVEL,
};

pub const TCP_ACK_FREQUENCY_PARAMETERS = extern struct {
    TcpDelayedAckFrequency: u8,
};

pub const TCP_INFO_v0 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: u8,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
};

pub const TCP_INFO_v1 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: u8,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: u64,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: u64,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: u64,
};

pub const INET_PORT_RANGE = extern struct {
    StartPort: u16,
    NumberOfPorts: u16,
};

pub const INET_PORT_RESERVATION_TOKEN = extern struct {
    Token: u64,
};

pub const INET_PORT_RESERVATION_INSTANCE = extern struct {
    Reservation: INET_PORT_RANGE,
    Token: INET_PORT_RESERVATION_TOKEN,
};

pub const INET_PORT_RESERVATION_INFORMATION = extern struct {
    OwningPid: u32,
};

pub const SOCKET_USAGE_TYPE = extern enum(i32) {
    T = 1,
};
pub const SYSTEM_CRITICAL_SOCKET = SOCKET_USAGE_TYPE.T;

pub const SOCKET_SECURITY_PROTOCOL = extern enum(i32) {
    DEFAULT = 0,
    IPSEC = 1,
    IPSEC2 = 2,
    INVALID = 3,
};
pub const SOCKET_SECURITY_PROTOCOL_DEFAULT = SOCKET_SECURITY_PROTOCOL.DEFAULT;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC = SOCKET_SECURITY_PROTOCOL.IPSEC;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC2 = SOCKET_SECURITY_PROTOCOL.IPSEC2;
pub const SOCKET_SECURITY_PROTOCOL_INVALID = SOCKET_SECURITY_PROTOCOL.INVALID;

pub const SOCKET_SECURITY_SETTINGS = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
};

pub const SOCKET_SECURITY_SETTINGS_IPSEC = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
    IpsecFlags: u32,
    AuthipMMPolicyKey: Guid,
    AuthipQMPolicyKey: Guid,
    Reserved: Guid,
    Reserved2: u64,
    UserNameStringLen: u32,
    DomainNameStringLen: u32,
    PasswordStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_PEER_TARGET_NAME = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTargetNameStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE,
    PeerTokenAccessMask: u32,
    Flags: u32,
    FieldMask: u32,
};

pub const SOCKET_SECURITY_QUERY_INFO = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
};

pub const SOCKET_SECURITY_QUERY_INFO_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
    MmSaId: u64,
    QmSaId: u64,
    NegotiationWinerr: u32,
    SaLookupContext: Guid,
};

pub const RSS_SCALABILITY_INFO = extern struct {
    RssEnabled: u8,
};

pub const WSA_COMPATIBILITY_BEHAVIOR_ID = extern enum(i32) {
    All = 0,
    ReceiveBuffering = 1,
    AutoTuning = 2,
};
pub const WsaBehaviorAll = WSA_COMPATIBILITY_BEHAVIOR_ID.All;
pub const WsaBehaviorReceiveBuffering = WSA_COMPATIBILITY_BEHAVIOR_ID.ReceiveBuffering;
pub const WsaBehaviorAutoTuning = WSA_COMPATIBILITY_BEHAVIOR_ID.AutoTuning;

pub const WSA_COMPATIBILITY_MODE = extern struct {
    BehaviorId: WSA_COMPATIBILITY_BEHAVIOR_ID,
    TargetOsVersion: u32,
};

pub const RIO_BUFFERID_t = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const RIO_CQ_t = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const RIO_RQ_t = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const RIORESULT = extern struct {
    Status: i32,
    BytesTransferred: u32,
    SocketContext: u64,
    RequestContext: u64,
};

pub const RIO_BUF = extern struct {
    BufferId: *RIO_BUFFERID_t,
    Offset: u32,
    Length: u32,
};

pub const RIO_CMSG_BUFFER = extern struct {
    TotalLength: u32,
};

pub const ATM_ADDRESS = extern struct {
    AddressType: u32,
    NumofDigits: u32,
    Addr: [20]u8,
};

pub const ATM_BLLI = extern struct {
    Layer2Protocol: u32,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_BHLI = extern struct {
    HighLayerInfoType: u32,
    HighLayerInfoLength: u32,
    HighLayerInfo: [8]u8,
};

pub const sockaddr_atm = extern struct {
    satm_family: u16,
    satm_number: ATM_ADDRESS,
    satm_blli: ATM_BLLI,
    satm_bhli: ATM_BHLI,
};

pub const Q2931_IE_TYPE = extern enum(i32) {
    AALParameters = 0,
    TrafficDescriptor = 1,
    BroadbandBearerCapability = 2,
    BHLI = 3,
    BLLI = 4,
    CalledPartyNumber = 5,
    CalledPartySubaddress = 6,
    CallingPartyNumber = 7,
    CallingPartySubaddress = 8,
    Cause = 9,
    QOSClass = 10,
    TransitNetworkSelection = 11,
};
pub const IE_AALParameters = Q2931_IE_TYPE.AALParameters;
pub const IE_TrafficDescriptor = Q2931_IE_TYPE.TrafficDescriptor;
pub const IE_BroadbandBearerCapability = Q2931_IE_TYPE.BroadbandBearerCapability;
pub const IE_BHLI = Q2931_IE_TYPE.BHLI;
pub const IE_BLLI = Q2931_IE_TYPE.BLLI;
pub const IE_CalledPartyNumber = Q2931_IE_TYPE.CalledPartyNumber;
pub const IE_CalledPartySubaddress = Q2931_IE_TYPE.CalledPartySubaddress;
pub const IE_CallingPartyNumber = Q2931_IE_TYPE.CallingPartyNumber;
pub const IE_CallingPartySubaddress = Q2931_IE_TYPE.CallingPartySubaddress;
pub const IE_Cause = Q2931_IE_TYPE.Cause;
pub const IE_QOSClass = Q2931_IE_TYPE.QOSClass;
pub const IE_TransitNetworkSelection = Q2931_IE_TYPE.TransitNetworkSelection;

pub const Q2931_IE = extern struct {
    IEType: Q2931_IE_TYPE,
    IELength: u32,
    IE: [1]u8,
};

pub const AAL_TYPE = extern enum(i32) {
    @"5" = 5,
    USER = 16,
};
pub const AALTYPE_5 = AAL_TYPE.@"5";
pub const AALTYPE_USER = AAL_TYPE.USER;

pub const AAL5_PARAMETERS = extern struct {
    ForwardMaxCPCSSDUSize: u32,
    BackwardMaxCPCSSDUSize: u32,
    Mode: u8,
    SSCSType: u8,
};

pub const AALUSER_PARAMETERS = extern struct {
    UserDefined: u32,
};

pub const AAL_PARAMETERS_IE = extern struct {
    AALType: AAL_TYPE,
    AALSpecificParameters: _AALSpecificParameters_e__Union,
    const _AALSpecificParameters_e__Union = u32; // TODO: generate this nested type!
};

pub const ATM_TD = extern struct {
    PeakCellRate_CLP0: u32,
    PeakCellRate_CLP01: u32,
    SustainableCellRate_CLP0: u32,
    SustainableCellRate_CLP01: u32,
    MaxBurstSize_CLP0: u32,
    MaxBurstSize_CLP01: u32,
    Tagging: BOOL,
};

pub const ATM_TRAFFIC_DESCRIPTOR_IE = extern struct {
    Forward: ATM_TD,
    Backward: ATM_TD,
    BestEffort: BOOL,
};

pub const ATM_BROADBAND_BEARER_CAPABILITY_IE = extern struct {
    BearerClass: u8,
    TrafficType: u8,
    TimingRequirements: u8,
    ClippingSusceptability: u8,
    UserPlaneConnectionConfig: u8,
};

pub const ATM_BLLI_IE = extern struct {
    Layer2Protocol: u32,
    Layer2Mode: u8,
    Layer2WindowSize: u8,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3Mode: u8,
    Layer3DefaultPacketSize: u8,
    Layer3PacketWindowSize: u8,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_CALLING_PARTY_NUMBER_IE = extern struct {
    ATM_Number: ATM_ADDRESS,
    Presentation_Indication: u8,
    Screening_Indicator: u8,
};

pub const ATM_CAUSE_IE = extern struct {
    Location: u8,
    Cause: u8,
    DiagnosticsLength: u8,
    Diagnostics: [4]u8,
};

pub const ATM_QOS_CLASS_IE = extern struct {
    QOSClassForward: u8,
    QOSClassBackward: u8,
};

pub const ATM_TRANSIT_NETWORK_SELECTION_IE = extern struct {
    TypeOfNetworkId: u8,
    NetworkIdPlan: u8,
    NetworkIdLength: u8,
    NetworkId: [1]u8,
};

pub const ATM_CONNECTION_ID = extern struct {
    DeviceNumber: u32,
    VPI: u32,
    VCI: u32,
};

pub const NAPI_PROVIDER_TYPE = extern enum(i32) {
    Application = 1,
    Service = 2,
};
pub const ProviderType_Application = NAPI_PROVIDER_TYPE.Application;
pub const ProviderType_Service = NAPI_PROVIDER_TYPE.Service;

pub const NAPI_PROVIDER_LEVEL = extern enum(i32) {
    None = 0,
    Secondary = 1,
    Primary = 2,
};
pub const ProviderLevel_None = NAPI_PROVIDER_LEVEL.None;
pub const ProviderLevel_Secondary = NAPI_PROVIDER_LEVEL.Secondary;
pub const ProviderLevel_Primary = NAPI_PROVIDER_LEVEL.Primary;

pub const NAPI_DOMAIN_DESCRIPTION_BLOB = extern struct {
    AuthLevel: u32,
    cchDomainName: u32,
    OffsetNextDomainDescription: u32,
    OffsetThisDomainName: u32,
};

pub const NAPI_PROVIDER_INSTALLATION_BLOB = extern struct {
    dwVersion: u32,
    dwProviderType: u32,
    fSupportsWildCard: u32,
    cDomains: u32,
    OffsetFirstDomain: u32,
};

pub const TRANSMIT_FILE_BUFFERS = extern struct {
    Head: *c_void,
    HeadLength: u32,
    Tail: *c_void,
    TailLength: u32,
};

pub const LPFN_TRANSMITFILE = fn(
    hSocket: usize,
    hFile: HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_ACCEPTEX = fn(
    sListenSocket: usize,
    sAcceptSocket: usize,
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_GETACCEPTEXSOCKADDRS = fn(
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: **SOCKADDR,
    LocalSockaddrLength: *i32,
    RemoteSockaddr: **SOCKADDR,
    RemoteSockaddrLength: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TRANSMIT_PACKETS_ELEMENT = extern struct {
    dwElFlags: u32,
    cLength: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFN_TRANSMITPACKETS = fn(
    hSocket: usize,
    lpPacketArray: ?*TRANSMIT_PACKETS_ELEMENT,
    nElementCount: u32,
    nSendSize: u32,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_CONNECTEX = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    // TODO: what to do with BytesParamIndex 4?
    lpSendBuffer: ?*c_void,
    dwSendDataLength: u32,
    lpdwBytesSent: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_DISCONNECTEX = fn(
    s: usize,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NLA_BLOB_DATA_TYPE = extern enum(i32) {
    RAW_DATA = 0,
    INTERFACE = 1,
    @"802_1X_LOCATION" = 2,
    CONNECTIVITY = 3,
    ICS = 4,
};
pub const NLA_RAW_DATA = NLA_BLOB_DATA_TYPE.RAW_DATA;
pub const NLA_INTERFACE = NLA_BLOB_DATA_TYPE.INTERFACE;
pub const NLA_802_1X_LOCATION = NLA_BLOB_DATA_TYPE.@"802_1X_LOCATION";
pub const NLA_CONNECTIVITY = NLA_BLOB_DATA_TYPE.CONNECTIVITY;
pub const NLA_ICS = NLA_BLOB_DATA_TYPE.ICS;

pub const NLA_CONNECTIVITY_TYPE = extern enum(i32) {
    AD_HOC = 0,
    MANAGED = 1,
    UNMANAGED = 2,
    UNKNOWN = 3,
};
pub const NLA_NETWORK_AD_HOC = NLA_CONNECTIVITY_TYPE.AD_HOC;
pub const NLA_NETWORK_MANAGED = NLA_CONNECTIVITY_TYPE.MANAGED;
pub const NLA_NETWORK_UNMANAGED = NLA_CONNECTIVITY_TYPE.UNMANAGED;
pub const NLA_NETWORK_UNKNOWN = NLA_CONNECTIVITY_TYPE.UNKNOWN;

pub const NLA_INTERNET = extern enum(i32) {
    UNKNOWN = 0,
    NO = 1,
    YES = 2,
};
pub const NLA_INTERNET_UNKNOWN = NLA_INTERNET.UNKNOWN;
pub const NLA_INTERNET_NO = NLA_INTERNET.NO;
pub const NLA_INTERNET_YES = NLA_INTERNET.YES;

pub const NLA_BLOB = extern struct {
    header: _header_e__Struct,
    data: _data_e__Union,
    const _data_e__Union = u32; // TODO: generate this nested type!
    const _header_e__Struct = u32; // TODO: generate this nested type!
};

pub const LPFN_WSARECVMSG = fn(
    s: usize,
    lpMsg: *WSAMSG,
    lpdwNumberOfBytesRecvd: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSAPOLLDATA = extern struct {
    result: i32,
    fds: u32,
    timeout: i32,
    fdArray: [1]WSAPOLLFD,
};

pub const WSASENDMSG = extern struct {
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: *u32,
    lpOverlapped: *OVERLAPPED,
    lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,
};

pub const LPFN_WSASENDMSG = fn(
    s: usize,
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_WSAPOLL = fn(
    fdarray: *WSAPOLLFD,
    nfds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIORECEIVE = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORECEIVEEX = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOSEND = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOSENDEX = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOCLOSECOMPLETIONQUEUE = fn(
    CQ: *RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RIO_NOTIFICATION_COMPLETION_TYPE = extern enum(i32) {
    EVENT_COMPLETION = 1,
    IOCP_COMPLETION = 2,
};
pub const RIO_EVENT_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.EVENT_COMPLETION;
pub const RIO_IOCP_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.IOCP_COMPLETION;

pub const RIO_NOTIFICATION_COMPLETION = extern struct {
    Type: RIO_NOTIFICATION_COMPLETION_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFN_RIOCREATECOMPLETIONQUEUE = fn(
    QueueSize: u32,
    NotificationCompletion: ?*RIO_NOTIFICATION_COMPLETION,
) callconv(@import("std").os.windows.WINAPI) *RIO_CQ_t;

pub const LPFN_RIOCREATEREQUESTQUEUE = fn(
    Socket: usize,
    MaxOutstandingReceive: u32,
    MaxReceiveDataBuffers: u32,
    MaxOutstandingSend: u32,
    MaxSendDataBuffers: u32,
    ReceiveCQ: *RIO_CQ_t,
    SendCQ: *RIO_CQ_t,
    SocketContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) *RIO_RQ_t;

pub const LPFN_RIODEQUEUECOMPLETION = fn(
    CQ: *RIO_CQ_t,
    Array: [*]RIORESULT,
    ArraySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFN_RIODEREGISTERBUFFER = fn(
    BufferId: *RIO_BUFFERID_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFN_RIONOTIFY = fn(
    CQ: *RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOREGISTERBUFFER = fn(
    DataBuffer: [*]u8,
    DataLength: u32,
) callconv(@import("std").os.windows.WINAPI) *RIO_BUFFERID_t;

pub const LPFN_RIORESIZECOMPLETIONQUEUE = fn(
    CQ: *RIO_CQ_t,
    QueueSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORESIZEREQUESTQUEUE = fn(
    RQ: *RIO_RQ_t,
    MaxOutstandingReceive: u32,
    MaxOutstandingSend: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RIO_EXTENSION_FUNCTION_TABLE = extern struct {
    cbSize: u32,
    RIOReceive: LPFN_RIORECEIVE,
    RIOReceiveEx: LPFN_RIORECEIVEEX,
    RIOSend: LPFN_RIOSEND,
    RIOSendEx: LPFN_RIOSENDEX,
    RIOCloseCompletionQueue: LPFN_RIOCLOSECOMPLETIONQUEUE,
    RIOCreateCompletionQueue: LPFN_RIOCREATECOMPLETIONQUEUE,
    RIOCreateRequestQueue: LPFN_RIOCREATEREQUESTQUEUE,
    RIODequeueCompletion: LPFN_RIODEQUEUECOMPLETION,
    RIODeregisterBuffer: LPFN_RIODEREGISTERBUFFER,
    RIONotify: LPFN_RIONOTIFY,
    RIORegisterBuffer: LPFN_RIOREGISTERBUFFER,
    RIOResizeCompletionQueue: LPFN_RIORESIZECOMPLETIONQUEUE,
    RIOResizeRequestQueue: LPFN_RIORESIZEREQUESTQUEUE,
};

pub const WSPData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [256]u16,
};

pub const WSATHREADID = extern struct {
    ThreadHandle: HANDLE,
    Reserved: usize,
};

pub const LPBLOCKINGCALLBACK = fn(
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSAUSERAPC = fn(
    dwContext: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSPACCEPT = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPWSPADDRESSTOSTRING = fn(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: *SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPASYNCSELECT = fn(
    s: usize,
    hWnd: HWND,
    wMsg: u32,
    lEvent: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPBIND = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCANCELBLOCKINGCALL = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLEANUP = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLOSESOCKET = fn(
    s: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCONNECT = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPDUPLICATESOCKET = fn(
    s: usize,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPENUMNETWORKEVENTS = fn(
    s: usize,
    hEventObject: HANDLE,
    lpNetworkEvents: *WSANETWORKEVENTS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPEVENTSELECT = fn(
    s: usize,
    hEventObject: HANDLE,
    lNetworkEvents: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETOVERLAPPEDRESULT = fn(
    s: usize,
    lpOverlapped: *OVERLAPPED,
    lpcbTransfer: *u32,
    fWait: BOOL,
    lpdwFlags: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPGETPEERNAME = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *SOCKADDR,
    namelen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKNAME = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *SOCKADDR,
    namelen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKOPT = fn(
    s: usize,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: PSTR,
    optlen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETQOSBYNAME = fn(
    s: usize,
    lpQOSName: *WSABUF,
    lpQOS: *QOS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPIOCTL = fn(
    s: usize,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*c_void,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*c_void,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPJOINLEAF = fn(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPWSPLISTEN = fn(
    s: usize,
    backlog: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECV = fn(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVDISCONNECT = fn(
    s: usize,
    lpInboundDisconnectData: ?*WSABUF,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVFROM = fn(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    // TODO: what to do with BytesParamIndex 6?
    lpFrom: ?*SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSELECT = fn(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSEND = fn(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDDISCONNECT = fn(
    s: usize,
    lpOutboundDisconnectData: ?*WSABUF,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDTO = fn(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpTo: ?*const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSETSOCKOPT = fn(
    s: usize,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?[*:0]const u8,
    optlen: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSHUTDOWN = fn(
    s: usize,
    how: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSOCKET = fn(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPWSPSTRINGTOADDRESS = fn(
    AddressString: PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: *SOCKADDR,
    lpAddressLength: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPPROC_TABLE = extern struct {
    lpWSPAccept: LPWSPACCEPT,
    lpWSPAddressToString: LPWSPADDRESSTOSTRING,
    lpWSPAsyncSelect: LPWSPASYNCSELECT,
    lpWSPBind: LPWSPBIND,
    lpWSPCancelBlockingCall: LPWSPCANCELBLOCKINGCALL,
    lpWSPCleanup: LPWSPCLEANUP,
    lpWSPCloseSocket: LPWSPCLOSESOCKET,
    lpWSPConnect: LPWSPCONNECT,
    lpWSPDuplicateSocket: LPWSPDUPLICATESOCKET,
    lpWSPEnumNetworkEvents: LPWSPENUMNETWORKEVENTS,
    lpWSPEventSelect: LPWSPEVENTSELECT,
    lpWSPGetOverlappedResult: LPWSPGETOVERLAPPEDRESULT,
    lpWSPGetPeerName: LPWSPGETPEERNAME,
    lpWSPGetSockName: LPWSPGETSOCKNAME,
    lpWSPGetSockOpt: LPWSPGETSOCKOPT,
    lpWSPGetQOSByName: LPWSPGETQOSBYNAME,
    lpWSPIoctl: LPWSPIOCTL,
    lpWSPJoinLeaf: LPWSPJOINLEAF,
    lpWSPListen: LPWSPLISTEN,
    lpWSPRecv: LPWSPRECV,
    lpWSPRecvDisconnect: LPWSPRECVDISCONNECT,
    lpWSPRecvFrom: LPWSPRECVFROM,
    lpWSPSelect: LPWSPSELECT,
    lpWSPSend: LPWSPSEND,
    lpWSPSendDisconnect: LPWSPSENDDISCONNECT,
    lpWSPSendTo: LPWSPSENDTO,
    lpWSPSetSockOpt: LPWSPSETSOCKOPT,
    lpWSPShutdown: LPWSPSHUTDOWN,
    lpWSPSocket: LPWSPSOCKET,
    lpWSPStringToAddress: LPWSPSTRINGTOADDRESS,
};

pub const LPWPUCLOSEEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUCLOSESOCKETHANDLE = fn(
    s: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCREATEEVENT = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const LPWPUCREATESOCKETHANDLE = fn(
    dwCatalogEntryId: u32,
    dwContext: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPWPUFDISSET = fn(
    s: usize,
    fdset: *fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUGETPROVIDERPATH = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUMODIFYIFSHANDLE = fn(
    dwCatalogEntryId: u32,
    ProposedHandle: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const LPWPUPOSTMESSAGE = fn(
    hWnd: HWND,
    Msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUQUERYBLOCKINGCALLBACK = fn(
    dwCatalogEntryId: u32,
    lplpfnCallback: *LPBLOCKINGCALLBACK,
    lpdwContext: *usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUERYSOCKETHANDLECONTEXT = fn(
    s: usize,
    lpContext: *usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUEUEAPC = fn(
    lpThreadId: *WSATHREADID,
    lpfnUserApc: LPWSAUSERAPC,
    dwContext: usize,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPURESETEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUSETEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUOPENCURRENTTHREAD = fn(
    lpThreadId: *WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCLOSETHREAD = fn(
    lpThreadId: *WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCOMPLETEOVERLAPPEDREQUEST = fn(
    s: usize,
    lpOverlapped: *OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPUPCALLTABLE = extern struct {
    lpWPUCloseEvent: LPWPUCLOSEEVENT,
    lpWPUCloseSocketHandle: LPWPUCLOSESOCKETHANDLE,
    lpWPUCreateEvent: LPWPUCREATEEVENT,
    lpWPUCreateSocketHandle: LPWPUCREATESOCKETHANDLE,
    lpWPUFDIsSet: LPWPUFDISSET,
    lpWPUGetProviderPath: LPWPUGETPROVIDERPATH,
    lpWPUModifyIFSHandle: LPWPUMODIFYIFSHANDLE,
    lpWPUPostMessage: LPWPUPOSTMESSAGE,
    lpWPUQueryBlockingCallback: LPWPUQUERYBLOCKINGCALLBACK,
    lpWPUQuerySocketHandleContext: LPWPUQUERYSOCKETHANDLECONTEXT,
    lpWPUQueueApc: LPWPUQUEUEAPC,
    lpWPUResetEvent: LPWPURESETEVENT,
    lpWPUSetEvent: LPWPUSETEVENT,
    lpWPUOpenCurrentThread: LPWPUOPENCURRENTTHREAD,
    lpWPUCloseThread: LPWPUCLOSETHREAD,
};

pub const LPWSPSTARTUP = fn(
    wVersionRequested: u16,
    lpWSPData: *WSPData,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
    UpcallTable: WSPUPCALLTABLE,
    lpProcTable: *WSPPROC_TABLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENUMPROTOCOLS = fn(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCDEINSTALLPROVIDER = fn(
    lpProviderId: *Guid,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCINSTALLPROVIDER = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCGETPROVIDERPATH = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUPDATEPROVIDER = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSC_PROVIDER_INFO_TYPE = extern enum(i32) {
    LspCategories = 0,
    Audit = 1,
};
pub const ProviderInfoLspCategories = WSC_PROVIDER_INFO_TYPE.LspCategories;
pub const ProviderInfoAudit = WSC_PROVIDER_INFO_TYPE.Audit;

pub const WSC_PROVIDER_AUDIT_INFO = extern struct {
    RecordSize: u32,
    Reserved: *c_void,
};

pub const LPWSCINSTALLNAMESPACE = fn(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUNINSTALLNAMESPACE = fn(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENABLENSPROVIDER = fn(
    lpProviderId: *Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPCLEANUP = fn(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEBEGIN = fn(
    lpProviderId: *Guid,
    lpqsRestrictions: *WSAQUERYSETW,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICENEXT = fn(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: *WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPIOCTL = fn(
    hLookup: HANDLE,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: *c_void,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: *c_void,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpCompletion: ?*WSACOMPLETION,
    lpThreadId: *WSATHREADID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEEND = fn(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPSETSERVICE = fn(
    lpProviderId: *Guid,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
    lpqsRegInfo: *WSAQUERYSETW,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPINSTALLSERVICECLASS = fn(
    lpProviderId: *Guid,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPREMOVESERVICECLASS = fn(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPGETSERVICECLASSINFO = fn(
    lpProviderId: *Guid,
    lpdwBufSize: *u32,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NSP_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPCleanup: LPNSPCLEANUP,
    NSPLookupServiceBegin: LPNSPLOOKUPSERVICEBEGIN,
    NSPLookupServiceNext: LPNSPLOOKUPSERVICENEXT,
    NSPLookupServiceEnd: LPNSPLOOKUPSERVICEEND,
    NSPSetService: LPNSPSETSERVICE,
    NSPInstallServiceClass: LPNSPINSTALLSERVICECLASS,
    NSPRemoveServiceClass: LPNSPREMOVESERVICECLASS,
    NSPGetServiceClassInfo: LPNSPGETSERVICECLASSINFO,
    NSPIoctl: LPNSPIOCTL,
};

pub const LPNSPSTARTUP = fn(
    lpProviderId: *Guid,
    lpnspRoutines: *NSP_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2STARTUP = fn(
    lpProviderId: *Guid,
    ppvClientSessionArg: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2CLEANUP = fn(
    lpProviderId: *Guid,
    pvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICEBEGIN = fn(
    lpProviderId: *Guid,
    lpqsRestrictions: *WSAQUERYSET2W,
    dwControlFlags: u32,
    lpvClientSessionArg: *c_void,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICENEXTEX = fn(
    hAsyncCall: HANDLE,
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    lpqsResults: *WSAQUERYSET2W,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2LOOKUPSERVICEEND = fn(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2SETSERVICEEX = fn(
    hAsyncCall: HANDLE,
    lpProviderId: *Guid,
    lpqsRegInfo: *WSAQUERYSET2W,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
    lpvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2CLIENTSESSIONRUNDOWN = fn(
    lpProviderId: *Guid,
    pvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NSPV2_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPv2Startup: LPNSPV2STARTUP,
    NSPv2Cleanup: LPNSPV2CLEANUP,
    NSPv2LookupServiceBegin: LPNSPV2LOOKUPSERVICEBEGIN,
    NSPv2LookupServiceNextEx: LPNSPV2LOOKUPSERVICENEXTEX,
    NSPv2LookupServiceEnd: LPNSPV2LOOKUPSERVICEEND,
    NSPv2SetServiceEx: LPNSPV2SETSERVICEEX,
    NSPv2ClientSessionRundown: LPNSPV2CLIENTSESSIONRUNDOWN,
};

pub const NS_INFOA = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: PSTR,
};

pub const NS_INFOW = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: PWSTR,
};

pub const SERVICE_TYPE_VALUE = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    dwValueNameOffset: u32,
    dwValueOffset: u32,
};

pub const SERVICE_TYPE_VALUE_ABSA = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: PSTR,
    lpValue: *c_void,
};

pub const SERVICE_TYPE_VALUE_ABSW = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: PWSTR,
    lpValue: *c_void,
};

pub const SERVICE_TYPE_INFO = extern struct {
    dwTypeNameOffset: u32,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE,
};

pub const SERVICE_TYPE_INFO_ABSA = extern struct {
    lpTypeName: PSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSA,
};

pub const SERVICE_TYPE_INFO_ABSW = extern struct {
    lpTypeName: PWSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSW,
};

pub const SERVICE_ADDRESS = extern struct {
    dwAddressType: u32,
    dwAddressFlags: u32,
    dwAddressLength: u32,
    dwPrincipalLength: u32,
    lpAddress: *u8,
    lpPrincipal: *u8,
};

pub const SERVICE_ADDRESSES = extern struct {
    dwAddressCount: u32,
    Addresses: [1]SERVICE_ADDRESS,
};

pub const SERVICE_INFOA = extern struct {
    lpServiceType: *Guid,
    lpServiceName: PSTR,
    lpComment: PSTR,
    lpLocale: PSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: PSTR,
    lpServiceAddress: *SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const SERVICE_INFOW = extern struct {
    lpServiceType: *Guid,
    lpServiceName: PWSTR,
    lpComment: PWSTR,
    lpLocale: PWSTR,
    dwDisplayHint: RESOURCE_DISPLAY_TYPE,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: PWSTR,
    lpServiceAddress: *SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const NS_SERVICE_INFOA = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOA,
};

pub const NS_SERVICE_INFOW = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOW,
};

pub const PROTOCOL_INFOA = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: PSTR,
};

pub const PROTOCOL_INFOW = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: PWSTR,
};

pub const NETRESOURCE2A = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: PSTR,
    lpRemoteName: PSTR,
    lpComment: PSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: *i32,
};

pub const NETRESOURCE2W = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: PWSTR,
    lpRemoteName: PWSTR,
    lpComment: PWSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: *i32,
};

pub const LPFN_NSPAPI = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPSERVICE_CALLBACK_PROC = fn(
    lParam: LPARAM,
    hAsyncTaskHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_ASYNC_INFO = extern struct {
    lpServiceCallbackProc: LPSERVICE_CALLBACK_PROC,
    lParam: LPARAM,
    hAsyncTaskHandle: HANDLE,
};

pub const LPLOOKUPSERVICE_COMPLETION_ROUTINE = fn(
    dwError: u32,
    dwBytes: u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSCWRITEPROVIDERORDER = fn(
    lpwdCatalogEntryId: *u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCWRITENAMESPACEORDER = fn(
    lpProviderId: *Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSA_ERROR = extern enum(i32) {
    _IO_PENDING = 997,
    _IO_INCOMPLETE = 996,
    _INVALID_HANDLE = 6,
    _INVALID_PARAMETER = 87,
    _NOT_ENOUGH_MEMORY = 8,
    _OPERATION_ABORTED = 995,
    BASEERR = 10000,
    EINTR = 10004,
    EBADF = 10009,
    EACCES = 10013,
    EFAULT = 10014,
    EINVAL = 10022,
    EMFILE = 10024,
    EWOULDBLOCK = 10035,
    EINPROGRESS = 10036,
    EALREADY = 10037,
    ENOTSOCK = 10038,
    EDESTADDRREQ = 10039,
    EMSGSIZE = 10040,
    EPROTOTYPE = 10041,
    ENOPROTOOPT = 10042,
    EPROTONOSUPPORT = 10043,
    ESOCKTNOSUPPORT = 10044,
    EOPNOTSUPP = 10045,
    EPFNOSUPPORT = 10046,
    EAFNOSUPPORT = 10047,
    EADDRINUSE = 10048,
    EADDRNOTAVAIL = 10049,
    ENETDOWN = 10050,
    ENETUNREACH = 10051,
    ENETRESET = 10052,
    ECONNABORTED = 10053,
    ECONNRESET = 10054,
    ENOBUFS = 10055,
    EISCONN = 10056,
    ENOTCONN = 10057,
    ESHUTDOWN = 10058,
    ETOOMANYREFS = 10059,
    ETIMEDOUT = 10060,
    ECONNREFUSED = 10061,
    ELOOP = 10062,
    ENAMETOOLONG = 10063,
    EHOSTDOWN = 10064,
    EHOSTUNREACH = 10065,
    ENOTEMPTY = 10066,
    EPROCLIM = 10067,
    EUSERS = 10068,
    EDQUOT = 10069,
    ESTALE = 10070,
    EREMOTE = 10071,
    SYSNOTREADY = 10091,
    VERNOTSUPPORTED = 10092,
    NOTINITIALISED = 10093,
    EDISCON = 10101,
    ENOMORE = 10102,
    ECANCELLED = 10103,
    EINVALIDPROCTABLE = 10104,
    EINVALIDPROVIDER = 10105,
    EPROVIDERFAILEDINIT = 10106,
    SYSCALLFAILURE = 10107,
    SERVICE_NOT_FOUND = 10108,
    TYPE_NOT_FOUND = 10109,
    _E_NO_MORE = 10110,
    _E_CANCELLED = 10111,
    EREFUSED = 10112,
    HOST_NOT_FOUND = 11001,
    TRY_AGAIN = 11002,
    NO_RECOVERY = 11003,
    NO_DATA = 11004,
    _QOS_RECEIVERS = 11005,
    _QOS_SENDERS = 11006,
    _QOS_NO_SENDERS = 11007,
    _QOS_NO_RECEIVERS = 11008,
    _QOS_REQUEST_CONFIRMED = 11009,
    _QOS_ADMISSION_FAILURE = 11010,
    _QOS_POLICY_FAILURE = 11011,
    _QOS_BAD_STYLE = 11012,
    _QOS_BAD_OBJECT = 11013,
    _QOS_TRAFFIC_CTRL_ERROR = 11014,
    _QOS_GENERIC_ERROR = 11015,
    _QOS_ESERVICETYPE = 11016,
    _QOS_EFLOWSPEC = 11017,
    _QOS_EPROVSPECBUF = 11018,
    _QOS_EFILTERSTYLE = 11019,
    _QOS_EFILTERTYPE = 11020,
    _QOS_EFILTERCOUNT = 11021,
    _QOS_EOBJLENGTH = 11022,
    _QOS_EFLOWCOUNT = 11023,
    _QOS_EUNKOWNPSOBJ = 11024,
    _QOS_EPOLICYOBJ = 11025,
    _QOS_EFLOWDESC = 11026,
    _QOS_EPSFLOWSPEC = 11027,
    _QOS_EPSFILTERSPEC = 11028,
    _QOS_ESDMODEOBJ = 11029,
    _QOS_ESHAPERATEOBJ = 11030,
    _QOS_RESERVED_PETYPE = 11031,
    _SECURE_HOST_NOT_FOUND = 11032,
    _IPSEC_NAME_POLICY_ERROR = 11033,
};
pub const WSA_IO_PENDING = WSA_ERROR._IO_PENDING;
pub const WSA_IO_INCOMPLETE = WSA_ERROR._IO_INCOMPLETE;
pub const WSA_INVALID_HANDLE = WSA_ERROR._INVALID_HANDLE;
pub const WSA_INVALID_PARAMETER = WSA_ERROR._INVALID_PARAMETER;
pub const WSA_NOT_ENOUGH_MEMORY = WSA_ERROR._NOT_ENOUGH_MEMORY;
pub const WSA_OPERATION_ABORTED = WSA_ERROR._OPERATION_ABORTED;
pub const WSABASEERR = WSA_ERROR.BASEERR;
pub const WSAEINTR = WSA_ERROR.EINTR;
pub const WSAEBADF = WSA_ERROR.EBADF;
pub const WSAEACCES = WSA_ERROR.EACCES;
pub const WSAEFAULT = WSA_ERROR.EFAULT;
pub const WSAEINVAL = WSA_ERROR.EINVAL;
pub const WSAEMFILE = WSA_ERROR.EMFILE;
pub const WSAEWOULDBLOCK = WSA_ERROR.EWOULDBLOCK;
pub const WSAEINPROGRESS = WSA_ERROR.EINPROGRESS;
pub const WSAEALREADY = WSA_ERROR.EALREADY;
pub const WSAENOTSOCK = WSA_ERROR.ENOTSOCK;
pub const WSAEDESTADDRREQ = WSA_ERROR.EDESTADDRREQ;
pub const WSAEMSGSIZE = WSA_ERROR.EMSGSIZE;
pub const WSAEPROTOTYPE = WSA_ERROR.EPROTOTYPE;
pub const WSAENOPROTOOPT = WSA_ERROR.ENOPROTOOPT;
pub const WSAEPROTONOSUPPORT = WSA_ERROR.EPROTONOSUPPORT;
pub const WSAESOCKTNOSUPPORT = WSA_ERROR.ESOCKTNOSUPPORT;
pub const WSAEOPNOTSUPP = WSA_ERROR.EOPNOTSUPP;
pub const WSAEPFNOSUPPORT = WSA_ERROR.EPFNOSUPPORT;
pub const WSAEAFNOSUPPORT = WSA_ERROR.EAFNOSUPPORT;
pub const WSAEADDRINUSE = WSA_ERROR.EADDRINUSE;
pub const WSAEADDRNOTAVAIL = WSA_ERROR.EADDRNOTAVAIL;
pub const WSAENETDOWN = WSA_ERROR.ENETDOWN;
pub const WSAENETUNREACH = WSA_ERROR.ENETUNREACH;
pub const WSAENETRESET = WSA_ERROR.ENETRESET;
pub const WSAECONNABORTED = WSA_ERROR.ECONNABORTED;
pub const WSAECONNRESET = WSA_ERROR.ECONNRESET;
pub const WSAENOBUFS = WSA_ERROR.ENOBUFS;
pub const WSAEISCONN = WSA_ERROR.EISCONN;
pub const WSAENOTCONN = WSA_ERROR.ENOTCONN;
pub const WSAESHUTDOWN = WSA_ERROR.ESHUTDOWN;
pub const WSAETOOMANYREFS = WSA_ERROR.ETOOMANYREFS;
pub const WSAETIMEDOUT = WSA_ERROR.ETIMEDOUT;
pub const WSAECONNREFUSED = WSA_ERROR.ECONNREFUSED;
pub const WSAELOOP = WSA_ERROR.ELOOP;
pub const WSAENAMETOOLONG = WSA_ERROR.ENAMETOOLONG;
pub const WSAEHOSTDOWN = WSA_ERROR.EHOSTDOWN;
pub const WSAEHOSTUNREACH = WSA_ERROR.EHOSTUNREACH;
pub const WSAENOTEMPTY = WSA_ERROR.ENOTEMPTY;
pub const WSAEPROCLIM = WSA_ERROR.EPROCLIM;
pub const WSAEUSERS = WSA_ERROR.EUSERS;
pub const WSAEDQUOT = WSA_ERROR.EDQUOT;
pub const WSAESTALE = WSA_ERROR.ESTALE;
pub const WSAEREMOTE = WSA_ERROR.EREMOTE;
pub const WSASYSNOTREADY = WSA_ERROR.SYSNOTREADY;
pub const WSAVERNOTSUPPORTED = WSA_ERROR.VERNOTSUPPORTED;
pub const WSANOTINITIALISED = WSA_ERROR.NOTINITIALISED;
pub const WSAEDISCON = WSA_ERROR.EDISCON;
pub const WSAENOMORE = WSA_ERROR.ENOMORE;
pub const WSAECANCELLED = WSA_ERROR.ECANCELLED;
pub const WSAEINVALIDPROCTABLE = WSA_ERROR.EINVALIDPROCTABLE;
pub const WSAEINVALIDPROVIDER = WSA_ERROR.EINVALIDPROVIDER;
pub const WSAEPROVIDERFAILEDINIT = WSA_ERROR.EPROVIDERFAILEDINIT;
pub const WSASYSCALLFAILURE = WSA_ERROR.SYSCALLFAILURE;
pub const WSASERVICE_NOT_FOUND = WSA_ERROR.SERVICE_NOT_FOUND;
pub const WSATYPE_NOT_FOUND = WSA_ERROR.TYPE_NOT_FOUND;
pub const WSA_E_NO_MORE = WSA_ERROR._E_NO_MORE;
pub const WSA_E_CANCELLED = WSA_ERROR._E_CANCELLED;
pub const WSAEREFUSED = WSA_ERROR.EREFUSED;
pub const WSAHOST_NOT_FOUND = WSA_ERROR.HOST_NOT_FOUND;
pub const WSATRY_AGAIN = WSA_ERROR.TRY_AGAIN;
pub const WSANO_RECOVERY = WSA_ERROR.NO_RECOVERY;
pub const WSANO_DATA = WSA_ERROR.NO_DATA;
pub const WSA_QOS_RECEIVERS = WSA_ERROR._QOS_RECEIVERS;
pub const WSA_QOS_SENDERS = WSA_ERROR._QOS_SENDERS;
pub const WSA_QOS_NO_SENDERS = WSA_ERROR._QOS_NO_SENDERS;
pub const WSA_QOS_NO_RECEIVERS = WSA_ERROR._QOS_NO_RECEIVERS;
pub const WSA_QOS_REQUEST_CONFIRMED = WSA_ERROR._QOS_REQUEST_CONFIRMED;
pub const WSA_QOS_ADMISSION_FAILURE = WSA_ERROR._QOS_ADMISSION_FAILURE;
pub const WSA_QOS_POLICY_FAILURE = WSA_ERROR._QOS_POLICY_FAILURE;
pub const WSA_QOS_BAD_STYLE = WSA_ERROR._QOS_BAD_STYLE;
pub const WSA_QOS_BAD_OBJECT = WSA_ERROR._QOS_BAD_OBJECT;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR = WSA_ERROR._QOS_TRAFFIC_CTRL_ERROR;
pub const WSA_QOS_GENERIC_ERROR = WSA_ERROR._QOS_GENERIC_ERROR;
pub const WSA_QOS_ESERVICETYPE = WSA_ERROR._QOS_ESERVICETYPE;
pub const WSA_QOS_EFLOWSPEC = WSA_ERROR._QOS_EFLOWSPEC;
pub const WSA_QOS_EPROVSPECBUF = WSA_ERROR._QOS_EPROVSPECBUF;
pub const WSA_QOS_EFILTERSTYLE = WSA_ERROR._QOS_EFILTERSTYLE;
pub const WSA_QOS_EFILTERTYPE = WSA_ERROR._QOS_EFILTERTYPE;
pub const WSA_QOS_EFILTERCOUNT = WSA_ERROR._QOS_EFILTERCOUNT;
pub const WSA_QOS_EOBJLENGTH = WSA_ERROR._QOS_EOBJLENGTH;
pub const WSA_QOS_EFLOWCOUNT = WSA_ERROR._QOS_EFLOWCOUNT;
pub const WSA_QOS_EUNKOWNPSOBJ = WSA_ERROR._QOS_EUNKOWNPSOBJ;
pub const WSA_QOS_EPOLICYOBJ = WSA_ERROR._QOS_EPOLICYOBJ;
pub const WSA_QOS_EFLOWDESC = WSA_ERROR._QOS_EFLOWDESC;
pub const WSA_QOS_EPSFLOWSPEC = WSA_ERROR._QOS_EPSFLOWSPEC;
pub const WSA_QOS_EPSFILTERSPEC = WSA_ERROR._QOS_EPSFILTERSPEC;
pub const WSA_QOS_ESDMODEOBJ = WSA_ERROR._QOS_ESDMODEOBJ;
pub const WSA_QOS_ESHAPERATEOBJ = WSA_ERROR._QOS_ESHAPERATEOBJ;
pub const WSA_QOS_RESERVED_PETYPE = WSA_ERROR._QOS_RESERVED_PETYPE;
pub const WSA_SECURE_HOST_NOT_FOUND = WSA_ERROR._SECURE_HOST_NOT_FOUND;
pub const WSA_IPSEC_NAME_POLICY_ERROR = WSA_ERROR._IPSEC_NAME_POLICY_ERROR;

pub const SET_SERVICE_OPERATION = extern enum(u32) {
    REGISTER = 1,
    DEREGISTER = 2,
    FLUSH = 3,
    ADD_TYPE = 4,
    DELETE_TYPE = 5,
};
pub const SERVICE_REGISTER = SET_SERVICE_OPERATION.REGISTER;
pub const SERVICE_DEREGISTER = SET_SERVICE_OPERATION.DEREGISTER;
pub const SERVICE_FLUSH = SET_SERVICE_OPERATION.FLUSH;
pub const SERVICE_ADD_TYPE = SET_SERVICE_OPERATION.ADD_TYPE;
pub const SERVICE_DELETE_TYPE = SET_SERVICE_OPERATION.DELETE_TYPE;

pub const SEND_FLAGS = extern enum(u32) {
    DONTROUTE = 4,
    OOB = 1,
    _,
};
pub const MSG_DONTROUTE = SEND_FLAGS.DONTROUTE;
pub const MSG_OOB = SEND_FLAGS.OOB;

pub const RESOURCE_DISPLAY_TYPE = extern enum(u32) {
    DOMAIN = 1,
    FILE = 4,
    GENERIC = 0,
    GROUP = 5,
    SERVER = 2,
    SHARE = 3,
    TREE = 10,
};
pub const RESOURCEDISPLAYTYPE_DOMAIN = RESOURCE_DISPLAY_TYPE.DOMAIN;
pub const RESOURCEDISPLAYTYPE_FILE = RESOURCE_DISPLAY_TYPE.FILE;
pub const RESOURCEDISPLAYTYPE_GENERIC = RESOURCE_DISPLAY_TYPE.GENERIC;
pub const RESOURCEDISPLAYTYPE_GROUP = RESOURCE_DISPLAY_TYPE.GROUP;
pub const RESOURCEDISPLAYTYPE_SERVER = RESOURCE_DISPLAY_TYPE.SERVER;
pub const RESOURCEDISPLAYTYPE_SHARE = RESOURCE_DISPLAY_TYPE.SHARE;
pub const RESOURCEDISPLAYTYPE_TREE = RESOURCE_DISPLAY_TYPE.TREE;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const servent = extern struct {
    s_name: PSTR,
    s_aliases: **i8,
    s_proto: PSTR,
    s_port: i16,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const WSAData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    iMaxSockets: u16,
    iMaxUdpDg: u16,
    lpVendorInfo: PSTR,
    szDescription: [257]CHAR,
    szSystemStatus: [129]CHAR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const ATM_PVC_PARAMS = extern struct {
    PvcConnectionId: ATM_CONNECTION_ID,
    PvcQos: QOS,
};

}, else => struct { } };

// TODO: this type has a FreeFunc 'WSACloseEvent', what can Zig do with this information?
pub const HWSAEVENT = ?*opaque{};

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: *u8,
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const servent = extern struct {
    s_name: PSTR,
    s_aliases: **i8,
    s_port: i16,
    s_proto: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const WSAData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [257]CHAR,
    szSystemStatus: [129]CHAR,
    iMaxSockets: u16,
    iMaxUdpDg: u16,
    lpVendorInfo: PSTR,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const ATM_PVC_PARAMS = extern struct {
    PvcConnectionId: ATM_CONNECTION_ID,
    PvcQos: QOS,
};

}, else => struct { } };


//--------------------------------------------------------------------------------
// Section: Functions (186)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn __WSAFDIsSet(
    fd: usize,
    param1: *fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn accept(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn bind(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn closesocket(
    s: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn connect(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn ioctlsocket(
    s: usize,
    cmd: i32,
    argp: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getpeername(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *SOCKADDR,
    namelen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getsockname(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *SOCKADDR,
    namelen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getsockopt(
    s: usize,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: PSTR,
    optlen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn htonl(
    hostlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn htons(
    hostshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn inet_addr(
    cp: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn inet_ntoa(
    in: IN_ADDR,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn listen(
    s: usize,
    backlog: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn ntohl(
    netlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn ntohs(
    netshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn recv(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    buf: PSTR,
    len: i32,
    flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn recvfrom(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    buf: PSTR,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    from: ?*SOCKADDR,
    fromlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn select(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn send(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    buf: [*:0]const u8,
    len: i32,
    flags: SEND_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn sendto(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    buf: [*:0]const u8,
    len: i32,
    flags: i32,
    // TODO: what to do with BytesParamIndex 5?
    to: *const SOCKADDR,
    tolen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn setsockopt(
    s: usize,
    level: i32,
    optname: i32,
    // TODO: what to do with BytesParamIndex 4?
    optval: ?[*:0]const u8,
    optlen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn shutdown(
    s: usize,
    how: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn socket(
    af: i32,
    type: i32,
    protocol: i32,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn gethostbyaddr(
    // TODO: what to do with BytesParamIndex 1?
    addr: [*:0]const u8,
    len: i32,
    type: i32,
) callconv(@import("std").os.windows.WINAPI) *hostent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn gethostbyname(
    name: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) *hostent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn gethostname(
    // TODO: what to do with BytesParamIndex 1?
    name: PSTR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn GetHostNameW(
    name: [*:0]u16,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getservbyport(
    port: i32,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) *servent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getservbyname(
    name: [*:0]const u8,
    proto: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) *servent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getprotobynumber(
    number: i32,
) callconv(@import("std").os.windows.WINAPI) *protoent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getprotobyname(
    name: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) *protoent;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAStartup(
    wVersionRequested: u16,
    lpWSAData: *WSAData,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSACleanup(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASetLastError(
    iError: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAGetLastError(
) callconv(@import("std").os.windows.WINAPI) WSA_ERROR;

pub extern "WS2_32" fn WSAIsBlocking(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAUnhookBlockingHook(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetBlockingHook(
    lpBlockFunc: FARPROC,
) callconv(@import("std").os.windows.WINAPI) FARPROC;

pub extern "WS2_32" fn WSACancelBlockingCall(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetServByName(
    hWnd: HWND,
    wMsg: u32,
    name: [*:0]const u8,
    proto: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetServByPort(
    hWnd: HWND,
    wMsg: u32,
    port: i32,
    proto: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 5?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetProtoByName(
    hWnd: HWND,
    wMsg: u32,
    name: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetProtoByNumber(
    hWnd: HWND,
    wMsg: u32,
    number: i32,
    // TODO: what to do with BytesParamIndex 4?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetHostByName(
    hWnd: HWND,
    wMsg: u32,
    name: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncGetHostByAddr(
    hWnd: HWND,
    wMsg: u32,
    // TODO: what to do with BytesParamIndex 3?
    addr: [*:0]const u8,
    len: i32,
    type: i32,
    // TODO: what to do with BytesParamIndex 6?
    buf: PSTR,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSACancelAsyncRequest(
    hAsyncTaskHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAAsyncSelect(
    s: usize,
    hWnd: HWND,
    wMsg: u32,
    lEvent: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAAccept(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    addr: ?*SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSACloseEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAConnect(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAConnectByNameW(
    s: usize,
    nodename: PWSTR,
    servicename: PWSTR,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAConnectByNameA(
    s: usize,
    nodename: [*:0]const u8,
    servicename: [*:0]const u8,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAConnectByList(
    s: usize,
    SocketAddress: *SOCKET_ADDRESS_LIST,
    LocalAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    LocalAddress: ?*SOCKADDR,
    RemoteAddressLength: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    RemoteAddress: ?*SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSACreateEvent(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSADuplicateSocketA(
    s: usize,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSADuplicateSocketW(
    s: usize,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumNetworkEvents(
    s: usize,
    hEventObject: HANDLE,
    lpNetworkEvents: *WSANETWORKEVENTS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOA,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEventSelect(
    s: usize,
    hEventObject: HANDLE,
    lNetworkEvents: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAGetOverlappedResult(
    s: usize,
    lpOverlapped: *OVERLAPPED,
    lpcbTransfer: *u32,
    fWait: BOOL,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAGetQOSByName(
    s: usize,
    lpQOSName: *WSABUF,
    lpQOS: *QOS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAHtonl(
    s: usize,
    hostlong: u32,
    lpnetlong: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAHtons(
    s: usize,
    hostshort: u16,
    lpnetshort: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAIoctl(
    s: usize,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*c_void,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*c_void,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAJoinLeaf(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    name: *const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSANtohl(
    s: usize,
    netlong: u32,
    lphostlong: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSANtohs(
    s: usize,
    netshort: u16,
    lphostshort: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSARecv(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSARecvDisconnect(
    s: usize,
    lpInboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSARecvFrom(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    // TODO: what to do with BytesParamIndex 6?
    lpFrom: ?*SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAResetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASend(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASendMsg(
    Handle: usize,
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSASendDisconnect(
    s: usize,
    lpOutboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASendTo(
    s: usize,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpTo: ?*const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASocketA(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASocketW(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAWaitForMultipleEvents(
    cEvents: u32,
    lphEvents: [*]const HANDLE,
    fWaitAll: BOOL,
    dwTimeout: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAAddressToStringA(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: *SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    lpszAddressString: [*:0]u8,
    lpdwAddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAAddressToStringW(
    // TODO: what to do with BytesParamIndex 1?
    lpsaAddress: *SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAStringToAddressA(
    AddressString: PSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: *SOCKADDR,
    lpAddressLength: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAStringToAddressW(
    AddressString: PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    // TODO: what to do with BytesParamIndex 4?
    lpAddress: *SOCKADDR,
    lpAddressLength: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSALookupServiceBeginA(
    lpqsRestrictions: *WSAQUERYSETA,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSALookupServiceBeginW(
    lpqsRestrictions: *WSAQUERYSETW,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSALookupServiceNextA(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: *WSAQUERYSETA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSALookupServiceNextW(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpqsResults: ?*WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSANSPIoctl(
    hLookup: HANDLE,
    dwControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpvInBuffer: ?*c_void,
    cbInBuffer: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpvOutBuffer: ?*c_void,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpCompletion: ?*WSACOMPLETION,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSALookupServiceEnd(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAInstallServiceClassA(
    lpServiceClassInfo: *WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAInstallServiceClassW(
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSARemoveServiceClass(
    lpServiceClassId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAGetServiceClassInfoA(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
    lpdwBufSize: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: *WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAGetServiceClassInfoW(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
    lpdwBufSize: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumNameSpaceProvidersA(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumNameSpaceProvidersW(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumNameSpaceProvidersExA(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOEXA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAEnumNameSpaceProvidersExW(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAGetServiceClassNameByClassIdA(
    lpServiceClassId: *Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: PSTR,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSAGetServiceClassNameByClassIdW(
    lpServiceClassId: *Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpszServiceClassName: PWSTR,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASetServiceA(
    lpqsRegInfo: *WSAQUERYSETA,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSASetServiceW(
    lpqsRegInfo: *WSAQUERYSETW,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAProviderConfigChange(
    lpNotificationHandle: *HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn WSAPoll(
    fdArray: *WSAPOLLFD,
    fds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4AddressToStringExA(
    Address: *const IN_ADDR,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExA(
    AddressString: [*:0]const u8,
    Strict: u8,
    Address: *IN_ADDR,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6AddressToStringExA(
    Address: *const IN6_ADDR,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExA(
    AddressString: [*:0]const u8,
    Address: *IN6_ADDR,
    ScopeId: *u32,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn WSARecvEx(
    s: usize,
    // TODO: what to do with BytesParamIndex 2?
    buf: PSTR,
    len: i32,
    flags: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "MSWSOCK" fn TransmitFile(
    hSocket: usize,
    hFile: HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "MSWSOCK" fn AcceptEx(
    sListenSocket: usize,
    sAcceptSocket: usize,
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "MSWSOCK" fn GetAcceptExSockaddrs(
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: **SOCKADDR,
    LocalSockaddrLength: *i32,
    RemoteSockaddr: **SOCKADDR,
    RemoteSockaddrLength: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCEnumProtocols(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: ?*WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCDeinstallProvider(
    lpProviderId: *Guid,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCInstallProvider(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCGetProviderPath(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WS2_32" fn WSCUpdateProvider(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCSetProviderInfo(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: *u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCGetProviderInfo(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: *u8,
    InfoSize: *usize,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCSetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    PermittedLspCategories: u32,
    pPrevPermLspCat: ?*u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCGetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    pPermittedLspCategories: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WPUCompleteOverlappedRequest(
    s: usize,
    lpOverlapped: *OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCInstallNameSpace(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCUnInstallNameSpace(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCInstallNameSpaceEx(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
    lpProviderSpecific: *BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCEnableNSProvider(
    lpProviderId: *Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSAAdvertiseProvider(
    puuidProviderId: *const Guid,
    pNSPv2Routine: *const NSPV2_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSAUnadvertiseProvider(
    puuidProviderId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSAProviderCompleteAsyncCall(
    hAsyncCall: HANDLE,
    iRetCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn EnumProtocolsA(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: *c_void,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn EnumProtocolsW(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: *c_void,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetAddressByNameA(
    dwNameSpace: u32,
    lpServiceType: *Guid,
    lpServiceName: ?PSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: *c_void,
    lpdwBufferLength: *u32,
    lpAliasBuffer: ?[*:0]u8,
    lpdwAliasBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetAddressByNameW(
    dwNameSpace: u32,
    lpServiceType: *Guid,
    lpServiceName: ?PWSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    // TODO: what to do with BytesParamIndex 7?
    lpCsaddrBuffer: *c_void,
    lpdwBufferLength: *u32,
    lpAliasBuffer: ?[*:0]u16,
    lpdwAliasBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetTypeByNameA(
    lpServiceName: PSTR,
    lpServiceType: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetTypeByNameW(
    lpServiceName: PWSTR,
    lpServiceType: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetNameByTypeA(
    lpServiceType: *Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: PSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetNameByTypeW(
    lpServiceType: *Guid,
    // TODO: what to do with BytesParamIndex 2?
    lpServiceName: PWSTR,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn SetServiceA(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: *SERVICE_INFOA,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn SetServiceW(
    dwNameSpace: u32,
    dwOperation: SET_SERVICE_OPERATION,
    dwFlags: u32,
    lpServiceInfo: *SERVICE_INFOW,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetServiceA(
    dwNameSpace: u32,
    lpGuid: *Guid,
    lpServiceName: PSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: *c_void,
    lpdwBufferSize: *u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSWSOCK" fn GetServiceW(
    dwNameSpace: u32,
    lpGuid: *Guid,
    lpServiceName: PWSTR,
    dwProperties: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpBuffer: *c_void,
    lpdwBufferSize: *u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getaddrinfo(
    pNodeName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pHints: ?*const ADDRINFOA,
    ppResult: **ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn GetAddrInfoW(
    pNodeName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pHints: ?*const addrinfoW,
    ppResult: **addrinfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn GetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexA,
    ppResult: **addrinfoexA,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn GetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexW,
    ppResult: **addrinfoexW,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn GetAddrInfoExCancel(
    lpHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn GetAddrInfoExOverlappedResult(
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn SetAddrInfoExA(
    pName: [*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn SetAddrInfoExW(
    pName: [*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn freeaddrinfo(
    pAddrInfo: ?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn FreeAddrInfoW(
    pAddrInfo: ?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn FreeAddrInfoEx(
    pAddrInfoEx: ?*addrinfoexA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn FreeAddrInfoExW(
    pAddrInfoEx: ?*addrinfoexW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn getnameinfo(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: *const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u8,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u8,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn GetNameInfoW(
    // TODO: what to do with BytesParamIndex 1?
    pSockaddr: *const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u16,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u16,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn inet_pton(
    Family: i32,
    pszAddrString: [*:0]const u8,
    pAddrBuf: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn InetPtonW(
    Family: i32,
    pszAddrString: [*:0]const u16,
    pAddrBuf: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn inet_ntop(
    Family: i32,
    pAddr: *const c_void,
    pStringBuf: [*:0]u8,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WS2_32" fn InetNtopW(
    Family: i32,
    pAddr: *const c_void,
    pStringBuf: [*:0]u16,
    StringBufSize: usize,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketSecurity(
    Socket: usize,
    // TODO: what to do with BytesParamIndex 2?
    SecuritySettings: ?*const SOCKET_SECURITY_SETTINGS,
    SecuritySettingsLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAQuerySocketSecurity(
    Socket: usize,
    // TODO: what to do with BytesParamIndex 2?
    SecurityQueryTemplate: ?*const SOCKET_SECURITY_QUERY_TEMPLATE,
    SecurityQueryTemplateLen: u32,
    // TODO: what to do with BytesParamIndex 4?
    SecurityQueryInfo: ?*SOCKET_SECURITY_QUERY_INFO,
    SecurityQueryInfoLen: *u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSASetSocketPeerTargetName(
    Socket: usize,
    // TODO: what to do with BytesParamIndex 2?
    PeerTargetName: *const SOCKET_PEER_TARGET_NAME,
    PeerTargetNameLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSADeleteSocketPeerTargetName(
    Socket: usize,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: *const SOCKADDR,
    PeerAddrLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSAImpersonateSocketPeer(
    Socket: usize,
    // TODO: what to do with BytesParamIndex 2?
    PeerAddr: ?*const SOCKADDR,
    PeerAddrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "fwpuclnt" fn WSARevertImpersonation(
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "Windows.Networking" fn SetSocketMediaStreamingMode(
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCWriteProviderOrder(
    lpwdCatalogEntryId: *u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WS2_32" fn WSCWriteNameSpaceOrder(
    lpProviderId: *Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCEnumProtocols32(
    lpiProtocols: ?*i32,
    // TODO: what to do with BytesParamIndex 2?
    lpProtocolBuffer: *WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCDeinstallProvider32(
    lpProviderId: *Guid,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WS2_32" fn WSCInstallProvider64_32(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCGetProviderPath32(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCUpdateProvider32(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCSetProviderInfo32(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: *u8,
    InfoSize: usize,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCGetProviderInfo32(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    Info: *u8,
    InfoSize: *usize,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCEnumNameSpaceProviders32(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCEnumNameSpaceProvidersEx32(
    lpdwBufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    lpnspBuffer: *WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCInstallNameSpace32(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCInstallNameSpaceEx32(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
    lpProviderSpecific: *BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCUnInstallNameSpace32(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCEnableNSProvider32(
    lpProviderId: *Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCInstallProviderAndChains64_32(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpszProviderDllPath32: [*:0]const u16,
    lpszLspName: [*:0]const u16,
    dwServiceFlags: u32,
    lpProtocolInfoList: [*]WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpdwCatalogEntryId: ?*u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCWriteProviderOrder32(
    lpwdCatalogEntryId: *u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WS2_32" fn WSCWriteNameSpaceOrder32(
    lpProviderId: *Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (38)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const addrinfoex = addrinfoexA;
        pub const addrinfoex2 = addrinfoex2A;
        pub const WSAPROTOCOL_INFO = WSAPROTOCOL_INFOA;
        pub const WSAQUERYSET = WSAQUERYSETA;
        pub const WSAQUERYSET2 = WSAQUERYSET2A;
        pub const WSANSCLASSINFO = WSANSCLASSINFOA;
        pub const WSASERVICECLASSINFO = WSASERVICECLASSINFOA;
        pub const WSANAMESPACE_INFO = WSANAMESPACE_INFOA;
        pub const WSANAMESPACE_INFOEX = WSANAMESPACE_INFOEXA;
        pub const NS_INFO = NS_INFOA;
        pub const SERVICE_TYPE_VALUE_ABS = SERVICE_TYPE_VALUE_ABSA;
        pub const SERVICE_TYPE_INFO_ABS = SERVICE_TYPE_INFO_ABSA;
        pub const SERVICE_INFO = SERVICE_INFOA;
        pub const NS_SERVICE_INFO = NS_SERVICE_INFOA;
        pub const PROTOCOL_INFO = PROTOCOL_INFOA;
        pub const NETRESOURCE2 = NETRESOURCE2A;
        pub const WSAConnectByName = WSAConnectByNameA;
        pub const WSADuplicateSocket = WSADuplicateSocketA;
        pub const WSAEnumProtocols = WSAEnumProtocolsA;
        pub const WSASocket = WSASocketA;
        pub const WSAAddressToString = WSAAddressToStringA;
        pub const WSAStringToAddress = WSAStringToAddressA;
        pub const WSALookupServiceBegin = WSALookupServiceBeginA;
        pub const WSALookupServiceNext = WSALookupServiceNextA;
        pub const WSAInstallServiceClass = WSAInstallServiceClassA;
        pub const WSAGetServiceClassInfo = WSAGetServiceClassInfoA;
        pub const WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersA;
        pub const WSAEnumNameSpaceProvidersEx = WSAEnumNameSpaceProvidersExA;
        pub const WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdA;
        pub const WSASetService = WSASetServiceA;
        pub const EnumProtocols = EnumProtocolsA;
        pub const GetAddressByName = GetAddressByNameA;
        pub const GetTypeByName = GetTypeByNameA;
        pub const GetNameByType = GetNameByTypeA;
        pub const SetService = SetServiceA;
        pub const GetService = GetServiceA;
        pub const GetAddrInfoEx = GetAddrInfoExA;
        pub const SetAddrInfoEx = SetAddrInfoExA;
    },
    .wide => struct {
        pub const addrinfoex = addrinfoexW;
        pub const addrinfoex2 = addrinfoex2W;
        pub const WSAPROTOCOL_INFO = WSAPROTOCOL_INFOW;
        pub const WSAQUERYSET = WSAQUERYSETW;
        pub const WSAQUERYSET2 = WSAQUERYSET2W;
        pub const WSANSCLASSINFO = WSANSCLASSINFOW;
        pub const WSASERVICECLASSINFO = WSASERVICECLASSINFOW;
        pub const WSANAMESPACE_INFO = WSANAMESPACE_INFOW;
        pub const WSANAMESPACE_INFOEX = WSANAMESPACE_INFOEXW;
        pub const NS_INFO = NS_INFOW;
        pub const SERVICE_TYPE_VALUE_ABS = SERVICE_TYPE_VALUE_ABSW;
        pub const SERVICE_TYPE_INFO_ABS = SERVICE_TYPE_INFO_ABSW;
        pub const SERVICE_INFO = SERVICE_INFOW;
        pub const NS_SERVICE_INFO = NS_SERVICE_INFOW;
        pub const PROTOCOL_INFO = PROTOCOL_INFOW;
        pub const NETRESOURCE2 = NETRESOURCE2W;
        pub const WSAConnectByName = WSAConnectByNameW;
        pub const WSADuplicateSocket = WSADuplicateSocketW;
        pub const WSAEnumProtocols = WSAEnumProtocolsW;
        pub const WSASocket = WSASocketW;
        pub const WSAAddressToString = WSAAddressToStringW;
        pub const WSAStringToAddress = WSAStringToAddressW;
        pub const WSALookupServiceBegin = WSALookupServiceBeginW;
        pub const WSALookupServiceNext = WSALookupServiceNextW;
        pub const WSAInstallServiceClass = WSAInstallServiceClassW;
        pub const WSAGetServiceClassInfo = WSAGetServiceClassInfoW;
        pub const WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersW;
        pub const WSAEnumNameSpaceProvidersEx = WSAEnumNameSpaceProvidersExW;
        pub const WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdW;
        pub const WSASetService = WSASetServiceW;
        pub const EnumProtocols = EnumProtocolsW;
        pub const GetAddressByName = GetAddressByNameW;
        pub const GetTypeByName = GetTypeByNameW;
        pub const GetNameByType = GetNameByTypeW;
        pub const SetService = SetServiceW;
        pub const GetService = GetServiceW;
        pub const GetAddrInfoEx = GetAddrInfoExW;
        pub const SetAddrInfoEx = SetAddrInfoExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const addrinfoex = *opaque{};
        pub const addrinfoex2 = *opaque{};
        pub const WSAPROTOCOL_INFO = *opaque{};
        pub const WSAQUERYSET = *opaque{};
        pub const WSAQUERYSET2 = *opaque{};
        pub const WSANSCLASSINFO = *opaque{};
        pub const WSASERVICECLASSINFO = *opaque{};
        pub const WSANAMESPACE_INFO = *opaque{};
        pub const WSANAMESPACE_INFOEX = *opaque{};
        pub const NS_INFO = *opaque{};
        pub const SERVICE_TYPE_VALUE_ABS = *opaque{};
        pub const SERVICE_TYPE_INFO_ABS = *opaque{};
        pub const SERVICE_INFO = *opaque{};
        pub const NS_SERVICE_INFO = *opaque{};
        pub const PROTOCOL_INFO = *opaque{};
        pub const NETRESOURCE2 = *opaque{};
        pub const WSAConnectByName = *opaque{};
        pub const WSADuplicateSocket = *opaque{};
        pub const WSAEnumProtocols = *opaque{};
        pub const WSASocket = *opaque{};
        pub const WSAAddressToString = *opaque{};
        pub const WSAStringToAddress = *opaque{};
        pub const WSALookupServiceBegin = *opaque{};
        pub const WSALookupServiceNext = *opaque{};
        pub const WSAInstallServiceClass = *opaque{};
        pub const WSAGetServiceClassInfo = *opaque{};
        pub const WSAEnumNameSpaceProviders = *opaque{};
        pub const WSAEnumNameSpaceProvidersEx = *opaque{};
        pub const WSAGetServiceClassNameByClassId = *opaque{};
        pub const WSASetService = *opaque{};
        pub const EnumProtocols = *opaque{};
        pub const GetAddressByName = *opaque{};
        pub const GetTypeByName = *opaque{};
        pub const GetNameByType = *opaque{};
        pub const SetService = *opaque{};
        pub const GetService = *opaque{};
        pub const GetAddrInfoEx = *opaque{};
        pub const SetAddrInfoEx = *opaque{};
    } else struct {
        pub const addrinfoex = @compileError("'addrinfoex' requires that UNICODE be set to true or false in the root module");
        pub const addrinfoex2 = @compileError("'addrinfoex2' requires that UNICODE be set to true or false in the root module");
        pub const WSAPROTOCOL_INFO = @compileError("'WSAPROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET = @compileError("'WSAQUERYSET' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET2 = @compileError("'WSAQUERYSET2' requires that UNICODE be set to true or false in the root module");
        pub const WSANSCLASSINFO = @compileError("'WSANSCLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSASERVICECLASSINFO = @compileError("'WSASERVICECLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFO = @compileError("'WSANAMESPACE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFOEX = @compileError("'WSANAMESPACE_INFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NS_INFO = @compileError("'NS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_VALUE_ABS = @compileError("'SERVICE_TYPE_VALUE_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_INFO_ABS = @compileError("'SERVICE_TYPE_INFO_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_INFO = @compileError("'SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NS_SERVICE_INFO = @compileError("'NS_SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const PROTOCOL_INFO = @compileError("'PROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NETRESOURCE2 = @compileError("'NETRESOURCE2' requires that UNICODE be set to true or false in the root module");
        pub const WSAConnectByName = @compileError("'WSAConnectByName' requires that UNICODE be set to true or false in the root module");
        pub const WSADuplicateSocket = @compileError("'WSADuplicateSocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumProtocols = @compileError("'WSAEnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const WSASocket = @compileError("'WSASocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAAddressToString = @compileError("'WSAAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const WSAStringToAddress = @compileError("'WSAStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceBegin = @compileError("'WSALookupServiceBegin' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceNext = @compileError("'WSALookupServiceNext' requires that UNICODE be set to true or false in the root module");
        pub const WSAInstallServiceClass = @compileError("'WSAInstallServiceClass' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassInfo = @compileError("'WSAGetServiceClassInfo' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProviders = @compileError("'WSAEnumNameSpaceProviders' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProvidersEx = @compileError("'WSAEnumNameSpaceProvidersEx' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassNameByClassId = @compileError("'WSAGetServiceClassNameByClassId' requires that UNICODE be set to true or false in the root module");
        pub const WSASetService = @compileError("'WSASetService' requires that UNICODE be set to true or false in the root module");
        pub const EnumProtocols = @compileError("'EnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const GetAddressByName = @compileError("'GetAddressByName' requires that UNICODE be set to true or false in the root module");
        pub const GetTypeByName = @compileError("'GetTypeByName' requires that UNICODE be set to true or false in the root module");
        pub const GetNameByType = @compileError("'GetNameByType' requires that UNICODE be set to true or false in the root module");
        pub const SetService = @compileError("'SetService' requires that UNICODE be set to true or false in the root module");
        pub const GetService = @compileError("'GetService' requires that UNICODE be set to true or false in the root module");
        pub const GetAddrInfoEx = @compileError("'GetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const SetAddrInfoEx = @compileError("'SetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const PWSTR = @import("system_services.zig").PWSTR;
const CHAR = @import("system_services.zig").CHAR;
const PROCESSOR_NUMBER = @import("system_services.zig").PROCESSOR_NUMBER;
const HRESULT = @import("com.zig").HRESULT;
const SOCKET_ADDRESS_LIST = @import("network_drivers.zig").SOCKET_ADDRESS_LIST;
const IN_ADDR = @import("ip_helper.zig").IN_ADDR;
const PSTR = @import("system_services.zig").PSTR;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const QOS = @import("quality_of_service.zig").QOS;
const IN6_ADDR = @import("network_drivers.zig").IN6_ADDR;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const FARPROC = @import("system_services.zig").FARPROC;
const HANDLE = @import("system_services.zig").HANDLE;
const SOCKADDR_INET = @import("ip_helper.zig").SOCKADDR_INET;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPCONDITIONPROC")) { _ = LPCONDITIONPROC; }
    if (@hasDecl(@This(), "LPWSAOVERLAPPED_COMPLETION_ROUTINE")) { _ = LPWSAOVERLAPPED_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPFN_TRANSMITFILE")) { _ = LPFN_TRANSMITFILE; }
    if (@hasDecl(@This(), "LPFN_ACCEPTEX")) { _ = LPFN_ACCEPTEX; }
    if (@hasDecl(@This(), "LPFN_GETACCEPTEXSOCKADDRS")) { _ = LPFN_GETACCEPTEXSOCKADDRS; }
    if (@hasDecl(@This(), "LPFN_TRANSMITPACKETS")) { _ = LPFN_TRANSMITPACKETS; }
    if (@hasDecl(@This(), "LPFN_CONNECTEX")) { _ = LPFN_CONNECTEX; }
    if (@hasDecl(@This(), "LPFN_DISCONNECTEX")) { _ = LPFN_DISCONNECTEX; }
    if (@hasDecl(@This(), "LPFN_WSARECVMSG")) { _ = LPFN_WSARECVMSG; }
    if (@hasDecl(@This(), "LPFN_WSASENDMSG")) { _ = LPFN_WSASENDMSG; }
    if (@hasDecl(@This(), "LPFN_WSAPOLL")) { _ = LPFN_WSAPOLL; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVE")) { _ = LPFN_RIORECEIVE; }
    if (@hasDecl(@This(), "LPFN_RIORECEIVEEX")) { _ = LPFN_RIORECEIVEEX; }
    if (@hasDecl(@This(), "LPFN_RIOSEND")) { _ = LPFN_RIOSEND; }
    if (@hasDecl(@This(), "LPFN_RIOSENDEX")) { _ = LPFN_RIOSENDEX; }
    if (@hasDecl(@This(), "LPFN_RIOCLOSECOMPLETIONQUEUE")) { _ = LPFN_RIOCLOSECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATECOMPLETIONQUEUE")) { _ = LPFN_RIOCREATECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIOCREATEREQUESTQUEUE")) { _ = LPFN_RIOCREATEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIODEQUEUECOMPLETION")) { _ = LPFN_RIODEQUEUECOMPLETION; }
    if (@hasDecl(@This(), "LPFN_RIODEREGISTERBUFFER")) { _ = LPFN_RIODEREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIONOTIFY")) { _ = LPFN_RIONOTIFY; }
    if (@hasDecl(@This(), "LPFN_RIOREGISTERBUFFER")) { _ = LPFN_RIOREGISTERBUFFER; }
    if (@hasDecl(@This(), "LPFN_RIORESIZECOMPLETIONQUEUE")) { _ = LPFN_RIORESIZECOMPLETIONQUEUE; }
    if (@hasDecl(@This(), "LPFN_RIORESIZEREQUESTQUEUE")) { _ = LPFN_RIORESIZEREQUESTQUEUE; }
    if (@hasDecl(@This(), "LPBLOCKINGCALLBACK")) { _ = LPBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWSAUSERAPC")) { _ = LPWSAUSERAPC; }
    if (@hasDecl(@This(), "LPWSPACCEPT")) { _ = LPWSPACCEPT; }
    if (@hasDecl(@This(), "LPWSPADDRESSTOSTRING")) { _ = LPWSPADDRESSTOSTRING; }
    if (@hasDecl(@This(), "LPWSPASYNCSELECT")) { _ = LPWSPASYNCSELECT; }
    if (@hasDecl(@This(), "LPWSPBIND")) { _ = LPWSPBIND; }
    if (@hasDecl(@This(), "LPWSPCANCELBLOCKINGCALL")) { _ = LPWSPCANCELBLOCKINGCALL; }
    if (@hasDecl(@This(), "LPWSPCLEANUP")) { _ = LPWSPCLEANUP; }
    if (@hasDecl(@This(), "LPWSPCLOSESOCKET")) { _ = LPWSPCLOSESOCKET; }
    if (@hasDecl(@This(), "LPWSPCONNECT")) { _ = LPWSPCONNECT; }
    if (@hasDecl(@This(), "LPWSPDUPLICATESOCKET")) { _ = LPWSPDUPLICATESOCKET; }
    if (@hasDecl(@This(), "LPWSPENUMNETWORKEVENTS")) { _ = LPWSPENUMNETWORKEVENTS; }
    if (@hasDecl(@This(), "LPWSPEVENTSELECT")) { _ = LPWSPEVENTSELECT; }
    if (@hasDecl(@This(), "LPWSPGETOVERLAPPEDRESULT")) { _ = LPWSPGETOVERLAPPEDRESULT; }
    if (@hasDecl(@This(), "LPWSPGETPEERNAME")) { _ = LPWSPGETPEERNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKNAME")) { _ = LPWSPGETSOCKNAME; }
    if (@hasDecl(@This(), "LPWSPGETSOCKOPT")) { _ = LPWSPGETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPGETQOSBYNAME")) { _ = LPWSPGETQOSBYNAME; }
    if (@hasDecl(@This(), "LPWSPIOCTL")) { _ = LPWSPIOCTL; }
    if (@hasDecl(@This(), "LPWSPJOINLEAF")) { _ = LPWSPJOINLEAF; }
    if (@hasDecl(@This(), "LPWSPLISTEN")) { _ = LPWSPLISTEN; }
    if (@hasDecl(@This(), "LPWSPRECV")) { _ = LPWSPRECV; }
    if (@hasDecl(@This(), "LPWSPRECVDISCONNECT")) { _ = LPWSPRECVDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPRECVFROM")) { _ = LPWSPRECVFROM; }
    if (@hasDecl(@This(), "LPWSPSELECT")) { _ = LPWSPSELECT; }
    if (@hasDecl(@This(), "LPWSPSEND")) { _ = LPWSPSEND; }
    if (@hasDecl(@This(), "LPWSPSENDDISCONNECT")) { _ = LPWSPSENDDISCONNECT; }
    if (@hasDecl(@This(), "LPWSPSENDTO")) { _ = LPWSPSENDTO; }
    if (@hasDecl(@This(), "LPWSPSETSOCKOPT")) { _ = LPWSPSETSOCKOPT; }
    if (@hasDecl(@This(), "LPWSPSHUTDOWN")) { _ = LPWSPSHUTDOWN; }
    if (@hasDecl(@This(), "LPWSPSOCKET")) { _ = LPWSPSOCKET; }
    if (@hasDecl(@This(), "LPWSPSTRINGTOADDRESS")) { _ = LPWSPSTRINGTOADDRESS; }
    if (@hasDecl(@This(), "LPWPUCLOSEEVENT")) { _ = LPWPUCLOSEEVENT; }
    if (@hasDecl(@This(), "LPWPUCLOSESOCKETHANDLE")) { _ = LPWPUCLOSESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUCREATEEVENT")) { _ = LPWPUCREATEEVENT; }
    if (@hasDecl(@This(), "LPWPUCREATESOCKETHANDLE")) { _ = LPWPUCREATESOCKETHANDLE; }
    if (@hasDecl(@This(), "LPWPUFDISSET")) { _ = LPWPUFDISSET; }
    if (@hasDecl(@This(), "LPWPUGETPROVIDERPATH")) { _ = LPWPUGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWPUMODIFYIFSHANDLE")) { _ = LPWPUMODIFYIFSHANDLE; }
    if (@hasDecl(@This(), "LPWPUPOSTMESSAGE")) { _ = LPWPUPOSTMESSAGE; }
    if (@hasDecl(@This(), "LPWPUQUERYBLOCKINGCALLBACK")) { _ = LPWPUQUERYBLOCKINGCALLBACK; }
    if (@hasDecl(@This(), "LPWPUQUERYSOCKETHANDLECONTEXT")) { _ = LPWPUQUERYSOCKETHANDLECONTEXT; }
    if (@hasDecl(@This(), "LPWPUQUEUEAPC")) { _ = LPWPUQUEUEAPC; }
    if (@hasDecl(@This(), "LPWPURESETEVENT")) { _ = LPWPURESETEVENT; }
    if (@hasDecl(@This(), "LPWPUSETEVENT")) { _ = LPWPUSETEVENT; }
    if (@hasDecl(@This(), "LPWPUOPENCURRENTTHREAD")) { _ = LPWPUOPENCURRENTTHREAD; }
    if (@hasDecl(@This(), "LPWPUCLOSETHREAD")) { _ = LPWPUCLOSETHREAD; }
    if (@hasDecl(@This(), "LPWPUCOMPLETEOVERLAPPEDREQUEST")) { _ = LPWPUCOMPLETEOVERLAPPEDREQUEST; }
    if (@hasDecl(@This(), "LPWSPSTARTUP")) { _ = LPWSPSTARTUP; }
    if (@hasDecl(@This(), "LPWSCENUMPROTOCOLS")) { _ = LPWSCENUMPROTOCOLS; }
    if (@hasDecl(@This(), "LPWSCDEINSTALLPROVIDER")) { _ = LPWSCDEINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLPROVIDER")) { _ = LPWSCINSTALLPROVIDER; }
    if (@hasDecl(@This(), "LPWSCGETPROVIDERPATH")) { _ = LPWSCGETPROVIDERPATH; }
    if (@hasDecl(@This(), "LPWSCUPDATEPROVIDER")) { _ = LPWSCUPDATEPROVIDER; }
    if (@hasDecl(@This(), "LPWSCINSTALLNAMESPACE")) { _ = LPWSCINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCUNINSTALLNAMESPACE")) { _ = LPWSCUNINSTALLNAMESPACE; }
    if (@hasDecl(@This(), "LPWSCENABLENSPROVIDER")) { _ = LPWSCENABLENSPROVIDER; }
    if (@hasDecl(@This(), "LPNSPCLEANUP")) { _ = LPNSPCLEANUP; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEBEGIN")) { _ = LPNSPLOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICENEXT")) { _ = LPNSPLOOKUPSERVICENEXT; }
    if (@hasDecl(@This(), "LPNSPIOCTL")) { _ = LPNSPIOCTL; }
    if (@hasDecl(@This(), "LPNSPLOOKUPSERVICEEND")) { _ = LPNSPLOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPSETSERVICE")) { _ = LPNSPSETSERVICE; }
    if (@hasDecl(@This(), "LPNSPINSTALLSERVICECLASS")) { _ = LPNSPINSTALLSERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPREMOVESERVICECLASS")) { _ = LPNSPREMOVESERVICECLASS; }
    if (@hasDecl(@This(), "LPNSPGETSERVICECLASSINFO")) { _ = LPNSPGETSERVICECLASSINFO; }
    if (@hasDecl(@This(), "LPNSPSTARTUP")) { _ = LPNSPSTARTUP; }
    if (@hasDecl(@This(), "LPNSPV2STARTUP")) { _ = LPNSPV2STARTUP; }
    if (@hasDecl(@This(), "LPNSPV2CLEANUP")) { _ = LPNSPV2CLEANUP; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEBEGIN")) { _ = LPNSPV2LOOKUPSERVICEBEGIN; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICENEXTEX")) { _ = LPNSPV2LOOKUPSERVICENEXTEX; }
    if (@hasDecl(@This(), "LPNSPV2LOOKUPSERVICEEND")) { _ = LPNSPV2LOOKUPSERVICEEND; }
    if (@hasDecl(@This(), "LPNSPV2SETSERVICEEX")) { _ = LPNSPV2SETSERVICEEX; }
    if (@hasDecl(@This(), "LPNSPV2CLIENTSESSIONRUNDOWN")) { _ = LPNSPV2CLIENTSESSIONRUNDOWN; }
    if (@hasDecl(@This(), "LPFN_NSPAPI")) { _ = LPFN_NSPAPI; }
    if (@hasDecl(@This(), "LPSERVICE_CALLBACK_PROC")) { _ = LPSERVICE_CALLBACK_PROC; }
    if (@hasDecl(@This(), "LPLOOKUPSERVICE_COMPLETION_ROUTINE")) { _ = LPLOOKUPSERVICE_COMPLETION_ROUTINE; }
    if (@hasDecl(@This(), "LPWSCWRITEPROVIDERORDER")) { _ = LPWSCWRITEPROVIDERORDER; }
    if (@hasDecl(@This(), "LPWSCWRITENAMESPACEORDER")) { _ = LPWSCWRITENAMESPACEORDER; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
