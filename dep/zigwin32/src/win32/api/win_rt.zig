//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (8)
//--------------------------------------------------------------------------------
pub const CastingSourceInfo_Property_PreferredSourceUriScheme = "PreferredSourceUriScheme";
pub const CastingSourceInfo_Property_CastingTypes = "CastingTypes";
pub const CastingSourceInfo_Property_ProtectedMedia = "ProtectedMedia";
pub const CLSID_SoftwareBitmapNativeFactory = Guid.initString("84e65691-8602-4a84-be46-708be9cd4b74");
pub const CLSID_AudioFrameNativeFactory = Guid.initString("16a0a3b9-9f65-4102-9367-2cda3a4f372a");
pub const CLSID_VideoFrameNativeFactory = Guid.initString("d194386a-04e3-4814-8100-b2b0ae6d78c7");
pub const E_SURFACE_CONTENTS_LOST = @as(u32, 2150301728);
pub const MAX_ERROR_MESSAGE_CHARS = @as(u32, 512);

//--------------------------------------------------------------------------------
// Section: Types (86)
//--------------------------------------------------------------------------------
pub const EventRegistrationToken = extern struct {
    value: i64,
};

pub const HSTRING_HEADER = extern struct {
    Reserved: _Reserved_e__Union,
    const _Reserved_e__Union = u32; // TODO: generate this nested type!
};

pub const TrustLevel = extern enum(i32) {
    BaseTrust = 0,
    PartialTrust = 1,
    FullTrust = 2,
};
pub const BaseTrust = TrustLevel.BaseTrust;
pub const PartialTrust = TrustLevel.PartialTrust;
pub const FullTrust = TrustLevel.FullTrust;

// TODO: this type is limited to platform 'windows8.0'
const IID_IInspectable_Value = @import("../zig.zig").Guid.initString("af86e2e0-b12d-4c6a-9c5a-d7aa65101e90");
pub const IID_IInspectable = &IID_IInspectable_Value;
pub const IInspectable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIids: fn(
            self: *const IInspectable,
            iidCount: *u32,
            iids: ?[*]?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRuntimeClassName: fn(
            self: *const IInspectable,
            className: ?*HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrustLevel: fn(
            self: *const IInspectable,
            trustLevel: *TrustLevel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetIids(self: *const T, iidCount: *u32, iids: ?[*]?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetIids(@ptrCast(*const IInspectable, self), iidCount, iids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetRuntimeClassName(self: *const T, className: ?*HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetRuntimeClassName(@ptrCast(*const IInspectable, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInspectable_GetTrustLevel(self: *const T, trustLevel: *TrustLevel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInspectable.VTable, self.vtable).GetTrustLevel(@ptrCast(*const IInspectable, self), trustLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccountsSettingsPaneInterop_Value = @import("../zig.zig").Guid.initString("d3ee12ad-3865-4362-9746-b75a682df0e6");
pub const IID_IAccountsSettingsPaneInterop = &IID_IAccountsSettingsPaneInterop_Value;
pub const IAccountsSettingsPaneInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IAccountsSettingsPaneInterop,
            appWindow: HWND,
            riid: *const Guid,
            accountsSettingsPane: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowManageAccountsForWindowAsync: fn(
            self: *const IAccountsSettingsPaneInterop,
            appWindow: HWND,
            riid: *const Guid,
            asyncAction: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowAddAccountForWindowAsync: fn(
            self: *const IAccountsSettingsPaneInterop,
            appWindow: HWND,
            riid: *const Guid,
            asyncAction: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, accountsSettingsPane: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, accountsSettingsPane);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_ShowManageAccountsForWindowAsync(self: *const T, appWindow: HWND, riid: *const Guid, asyncAction: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).ShowManageAccountsForWindowAsync(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, asyncAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccountsSettingsPaneInterop_ShowAddAccountForWindowAsync(self: *const T, appWindow: HWND, riid: *const Guid, asyncAction: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccountsSettingsPaneInterop.VTable, self.vtable).ShowAddAccountForWindowAsync(@ptrCast(*const IAccountsSettingsPaneInterop, self), appWindow, riid, asyncAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppServiceConnectionExtendedExecution_Value = @import("../zig.zig").Guid.initString("65219584-f9cb-4ae3-81f9-a28a6ca450d9");
pub const IID_IAppServiceConnectionExtendedExecution = &IID_IAppServiceConnectionExtendedExecution_Value;
pub const IAppServiceConnectionExtendedExecution = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenForExtendedExecutionAsync: fn(
            self: *const IAppServiceConnectionExtendedExecution,
            riid: *const Guid,
            operation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppServiceConnectionExtendedExecution_OpenForExtendedExecutionAsync(self: *const T, riid: *const Guid, operation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppServiceConnectionExtendedExecution.VTable, self.vtable).OpenForExtendedExecutionAsync(@ptrCast(*const IAppServiceConnectionExtendedExecution, self), riid, operation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorrelationVectorSource_Value = @import("../zig.zig").Guid.initString("152b8a3b-b9b9-4685-b56e-974847bc7545");
pub const IID_ICorrelationVectorSource = &IID_ICorrelationVectorSource_Value;
pub const ICorrelationVectorSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CorrelationVector: fn(
            self: *const ICorrelationVectorSource,
            cv: *HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorSource_get_CorrelationVector(self: *const T, cv: *HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorSource.VTable, self.vtable).get_CorrelationVector(@ptrCast(*const ICorrelationVectorSource, self), cv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CASTING_CONNECTION_ERROR_STATUS = extern enum(i32) {
    SUCCEEDED = 0,
    DEVICE_DID_NOT_RESPOND = 1,
    DEVICE_ERROR = 2,
    DEVICE_LOCKED = 3,
    PROTECTED_PLAYBACK_FAILED = 4,
    INVALID_CASTING_SOURCE = 5,
    UNKNOWN = 6,
};
pub const CASTING_CONNECTION_ERROR_STATUS_SUCCEEDED = CASTING_CONNECTION_ERROR_STATUS.SUCCEEDED;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_DID_NOT_RESPOND = CASTING_CONNECTION_ERROR_STATUS.DEVICE_DID_NOT_RESPOND;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_ERROR = CASTING_CONNECTION_ERROR_STATUS.DEVICE_ERROR;
pub const CASTING_CONNECTION_ERROR_STATUS_DEVICE_LOCKED = CASTING_CONNECTION_ERROR_STATUS.DEVICE_LOCKED;
pub const CASTING_CONNECTION_ERROR_STATUS_PROTECTED_PLAYBACK_FAILED = CASTING_CONNECTION_ERROR_STATUS.PROTECTED_PLAYBACK_FAILED;
pub const CASTING_CONNECTION_ERROR_STATUS_INVALID_CASTING_SOURCE = CASTING_CONNECTION_ERROR_STATUS.INVALID_CASTING_SOURCE;
pub const CASTING_CONNECTION_ERROR_STATUS_UNKNOWN = CASTING_CONNECTION_ERROR_STATUS.UNKNOWN;

pub const CASTING_CONNECTION_STATE = extern enum(i32) {
    DISCONNECTED = 0,
    CONNECTED = 1,
    RENDERING = 2,
    DISCONNECTING = 3,
    CONNECTING = 4,
};
pub const CASTING_CONNECTION_STATE_DISCONNECTED = CASTING_CONNECTION_STATE.DISCONNECTED;
pub const CASTING_CONNECTION_STATE_CONNECTED = CASTING_CONNECTION_STATE.CONNECTED;
pub const CASTING_CONNECTION_STATE_RENDERING = CASTING_CONNECTION_STATE.RENDERING;
pub const CASTING_CONNECTION_STATE_DISCONNECTING = CASTING_CONNECTION_STATE.DISCONNECTING;
pub const CASTING_CONNECTION_STATE_CONNECTING = CASTING_CONNECTION_STATE.CONNECTING;

const IID_ICastingEventHandler_Value = @import("../zig.zig").Guid.initString("c79a6cb7-bebd-47a6-a2ad-4d45ad79c7bc");
pub const IID_ICastingEventHandler = &IID_ICastingEventHandler_Value;
pub const ICastingEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: fn(
            self: *const ICastingEventHandler,
            newState: CASTING_CONNECTION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnError: fn(
            self: *const ICastingEventHandler,
            errorStatus: CASTING_CONNECTION_ERROR_STATUS,
            errorMessage: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingEventHandler_OnStateChanged(self: *const T, newState: CASTING_CONNECTION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingEventHandler.VTable, self.vtable).OnStateChanged(@ptrCast(*const ICastingEventHandler, self), newState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingEventHandler_OnError(self: *const T, errorStatus: CASTING_CONNECTION_ERROR_STATUS, errorMessage: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingEventHandler.VTable, self.vtable).OnError(@ptrCast(*const ICastingEventHandler, self), errorStatus, errorMessage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICastingController_Value = @import("../zig.zig").Guid.initString("f0a56423-a664-4fbd-8b43-409a45e8d9a1");
pub const IID_ICastingController = &IID_ICastingController_Value;
pub const ICastingController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ICastingController,
            castingEngine: *IUnknown,
            castingSource: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const ICastingController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const ICastingController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const ICastingController,
            eventHandler: *ICastingEventHandler,
            cookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: fn(
            self: *const ICastingController,
            cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Initialize(self: *const T, castingEngine: *IUnknown, castingSource: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Initialize(@ptrCast(*const ICastingController, self), castingEngine, castingSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Connect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Connect(@ptrCast(*const ICastingController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Disconnect(@ptrCast(*const ICastingController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_Advise(self: *const T, eventHandler: *ICastingEventHandler, cookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).Advise(@ptrCast(*const ICastingController, self), eventHandler, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingController_UnAdvise(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingController.VTable, self.vtable).UnAdvise(@ptrCast(*const ICastingController, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICastingSourceInfo_Value = @import("../zig.zig").Guid.initString("45101ab7-7c3a-4bce-9500-12c09024b298");
pub const IID_ICastingSourceInfo = &IID_ICastingSourceInfo_Value;
pub const ICastingSourceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetController: fn(
            self: *const ICastingSourceInfo,
            controller: **ICastingController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const ICastingSourceInfo,
            props: **INamedPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingSourceInfo_GetController(self: *const T, controller: **ICastingController) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingSourceInfo.VTable, self.vtable).GetController(@ptrCast(*const ICastingSourceInfo, self), controller);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICastingSourceInfo_GetProperties(self: *const T, props: **INamedPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICastingSourceInfo.VTable, self.vtable).GetProperties(@ptrCast(*const ICastingSourceInfo, self), props);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDragDropManagerInterop_Value = @import("../zig.zig").Guid.initString("5ad8cba7-4c01-4dac-9074-827894292d63");
pub const IID_IDragDropManagerInterop = &IID_IDragDropManagerInterop_Value;
pub const IDragDropManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IDragDropManagerInterop,
            hwnd: HWND,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragDropManagerInterop_GetForWindow(self: *const T, hwnd: HWND, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragDropManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IDragDropManagerInterop, self), hwnd, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IInputPaneInterop_Value = @import("../zig.zig").Guid.initString("75cf2c57-9195-4931-8332-f0b409e916af");
pub const IID_IInputPaneInterop = &IID_IInputPaneInterop_Value;
pub const IInputPaneInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IInputPaneInterop,
            appWindow: HWND,
            riid: *const Guid,
            inputPane: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputPaneInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, inputPane: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputPaneInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IInputPaneInterop, self), appWindow, riid, inputPane);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPlayToManagerInterop_Value = @import("../zig.zig").Guid.initString("24394699-1f2c-4eb3-8cd7-0ec1da42a540");
pub const IID_IPlayToManagerInterop = &IID_IPlayToManagerInterop_Value;
pub const IPlayToManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IPlayToManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            playToManager: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowPlayToUIForWindow: fn(
            self: *const IPlayToManagerInterop,
            appWindow: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToManagerInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, playToManager: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IPlayToManagerInterop, self), appWindow, riid, playToManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToManagerInterop_ShowPlayToUIForWindow(self: *const T, appWindow: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToManagerInterop.VTable, self.vtable).ShowPlayToUIForWindow(@ptrCast(*const IPlayToManagerInterop, self), appWindow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrinting3DManagerInterop_Value = @import("../zig.zig").Guid.initString("9ca31010-1484-4587-b26b-dddf9f9caecd");
pub const IID_IPrinting3DManagerInterop = &IID_IPrinting3DManagerInterop_Value;
pub const IPrinting3DManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IPrinting3DManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            printManager: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowPrintUIForWindowAsync: fn(
            self: *const IPrinting3DManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrinting3DManagerInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, printManager: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrinting3DManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IPrinting3DManagerInterop, self), appWindow, riid, printManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrinting3DManagerInterop_ShowPrintUIForWindowAsync(self: *const T, appWindow: HWND, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrinting3DManagerInterop.VTable, self.vtable).ShowPrintUIForWindowAsync(@ptrCast(*const IPrinting3DManagerInterop, self), appWindow, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPrintManagerInterop_Value = @import("../zig.zig").Guid.initString("c5435a42-8d43-4e7b-a68a-ef311e392087");
pub const IID_IPrintManagerInterop = &IID_IPrintManagerInterop_Value;
pub const IPrintManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IPrintManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            printManager: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowPrintUIForWindowAsync: fn(
            self: *const IPrintManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, printManager: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IPrintManagerInterop, self), appWindow, riid, printManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerInterop_ShowPrintUIForWindowAsync(self: *const T, appWindow: HWND, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerInterop.VTable, self.vtable).ShowPrintUIForWindowAsync(@ptrCast(*const IPrintManagerInterop, self), appWindow, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorrelationVectorInformation_Value = @import("../zig.zig").Guid.initString("83c78b3c-d88b-4950-aa6e-22b8d22aabd3");
pub const IID_ICorrelationVectorInformation = &IID_ICorrelationVectorInformation_Value;
pub const ICorrelationVectorInformation = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastCorrelationVectorForThread: fn(
            self: *const ICorrelationVectorInformation,
            cv: *HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextCorrelationVectorForThread: fn(
            self: *const ICorrelationVectorInformation,
            cv: *HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NextCorrelationVectorForThread: fn(
            self: *const ICorrelationVectorInformation,
            cv: HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_get_LastCorrelationVectorForThread(self: *const T, cv: *HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).get_LastCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_get_NextCorrelationVectorForThread(self: *const T, cv: *HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).get_NextCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorrelationVectorInformation_put_NextCorrelationVectorForThread(self: *const T, cv: HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICorrelationVectorInformation.VTable, self.vtable).put_NextCorrelationVectorForThread(@ptrCast(*const ICorrelationVectorInformation, self), cv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIViewSettingsInterop_Value = @import("../zig.zig").Guid.initString("3694dbf9-8f68-44be-8ff5-195c98ede8a6");
pub const IID_IUIViewSettingsInterop = &IID_IUIViewSettingsInterop_Value;
pub const IUIViewSettingsInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IUIViewSettingsInterop,
            hwnd: HWND,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIViewSettingsInterop_GetForWindow(self: *const T, hwnd: HWND, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIViewSettingsInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IUIViewSettingsInterop, self), hwnd, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivityInterop_Value = @import("../zig.zig").Guid.initString("1ade314d-0e0a-40d9-824c-9a088a50059f");
pub const IID_IUserActivityInterop = &IID_IUserActivityInterop_Value;
pub const IUserActivityInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateSessionForWindow: fn(
            self: *const IUserActivityInterop,
            window: HWND,
            iid: *const Guid,
            value: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivityInterop_CreateSessionForWindow(self: *const T, window: HWND, iid: *const Guid, value: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivityInterop.VTable, self.vtable).CreateSessionForWindow(@ptrCast(*const IUserActivityInterop, self), window, iid, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivitySourceHostInterop_Value = @import("../zig.zig").Guid.initString("c15df8bc-8844-487a-b85b-7578e0f61419");
pub const IID_IUserActivitySourceHostInterop = &IID_IUserActivitySourceHostInterop_Value;
pub const IUserActivitySourceHostInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        SetActivitySourceHost: fn(
            self: *const IUserActivitySourceHostInterop,
            activitySourceHost: HSTRING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivitySourceHostInterop_SetActivitySourceHost(self: *const T, activitySourceHost: HSTRING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivitySourceHostInterop.VTable, self.vtable).SetActivitySourceHost(@ptrCast(*const IUserActivitySourceHostInterop, self), activitySourceHost);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserActivityRequestManagerInterop_Value = @import("../zig.zig").Guid.initString("dd69f876-9699-4715-9095-e37ea30dfa1b");
pub const IID_IUserActivityRequestManagerInterop = &IID_IUserActivityRequestManagerInterop_Value;
pub const IUserActivityRequestManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const IUserActivityRequestManagerInterop,
            window: HWND,
            iid: *const Guid,
            value: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserActivityRequestManagerInterop_GetForWindow(self: *const T, window: HWND, iid: *const Guid, value: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserActivityRequestManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IUserActivityRequestManagerInterop, self), window, iid, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUserConsentVerifierInterop_Value = @import("../zig.zig").Guid.initString("39e050c3-4e74-441a-8dc0-b81104df949c");
pub const IID_IUserConsentVerifierInterop = &IID_IUserConsentVerifierInterop_Value;
pub const IUserConsentVerifierInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestVerificationForWindowAsync: fn(
            self: *const IUserConsentVerifierInterop,
            appWindow: HWND,
            message: HSTRING,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserConsentVerifierInterop_RequestVerificationForWindowAsync(self: *const T, appWindow: HWND, message: HSTRING, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserConsentVerifierInterop.VTable, self.vtable).RequestVerificationForWindowAsync(@ptrCast(*const IUserConsentVerifierInterop, self), appWindow, message, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAuthenticationCoreManagerInterop_Value = @import("../zig.zig").Guid.initString("f4b8e804-811e-4436-b69c-44cb67b72084");
pub const IID_IWebAuthenticationCoreManagerInterop = &IID_IWebAuthenticationCoreManagerInterop_Value;
pub const IWebAuthenticationCoreManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestTokenForWindowAsync: fn(
            self: *const IWebAuthenticationCoreManagerInterop,
            appWindow: HWND,
            request: *IInspectable,
            riid: *const Guid,
            asyncInfo: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestTokenWithWebAccountForWindowAsync: fn(
            self: *const IWebAuthenticationCoreManagerInterop,
            appWindow: HWND,
            request: *IInspectable,
            webAccount: *IInspectable,
            riid: *const Guid,
            asyncInfo: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAuthenticationCoreManagerInterop_RequestTokenForWindowAsync(self: *const T, appWindow: HWND, request: *IInspectable, riid: *const Guid, asyncInfo: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebAuthenticationCoreManagerInterop.VTable, self.vtable).RequestTokenForWindowAsync(@ptrCast(*const IWebAuthenticationCoreManagerInterop, self), appWindow, request, riid, asyncInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAuthenticationCoreManagerInterop_RequestTokenWithWebAccountForWindowAsync(self: *const T, appWindow: HWND, request: *IInspectable, webAccount: *IInspectable, riid: *const Guid, asyncInfo: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebAuthenticationCoreManagerInterop.VTable, self.vtable).RequestTokenWithWebAccountForWindowAsync(@ptrCast(*const IWebAuthenticationCoreManagerInterop, self), appWindow, request, webAccount, riid, asyncInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PFN_PDF_CREATE_RENDERER = fn(
    param0: *IDXGIDevice,
    param1: **IPdfRendererNative,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDF_RENDER_PARAMS = extern struct {
    SourceRect: D2D_RECT_F,
    DestinationWidth: u32,
    DestinationHeight: u32,
    BackgroundColor: D2D_COLOR_F,
    IgnoreHighContrast: u8,
};

const IID_IPdfRendererNative_Value = @import("../zig.zig").Guid.initString("7d9dcd91-d277-4947-8527-07a0daeda94a");
pub const IID_IPdfRendererNative = &IID_IPdfRendererNative_Value;
pub const IPdfRendererNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenderPageToSurface: fn(
            self: *const IPdfRendererNative,
            pdfPage: *IUnknown,
            pSurface: *IDXGISurface,
            offset: POINT,
            pRenderParams: ?*PDF_RENDER_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderPageToDeviceContext: fn(
            self: *const IPdfRendererNative,
            pdfPage: *IUnknown,
            pD2DDeviceContext: *ID2D1DeviceContext,
            pRenderParams: ?*PDF_RENDER_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPdfRendererNative_RenderPageToSurface(self: *const T, pdfPage: *IUnknown, pSurface: *IDXGISurface, offset: POINT, pRenderParams: ?*PDF_RENDER_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPdfRendererNative.VTable, self.vtable).RenderPageToSurface(@ptrCast(*const IPdfRendererNative, self), pdfPage, pSurface, offset, pRenderParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPdfRendererNative_RenderPageToDeviceContext(self: *const T, pdfPage: *IUnknown, pD2DDeviceContext: *ID2D1DeviceContext, pRenderParams: ?*PDF_RENDER_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPdfRendererNative.VTable, self.vtable).RenderPageToDeviceContext(@ptrCast(*const IPdfRendererNative, self), pdfPage, pD2DDeviceContext, pRenderParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayDeviceInterop_Value = @import("../zig.zig").Guid.initString("64338358-366a-471b-bd56-dd8ef48e439b");
pub const IID_IDisplayDeviceInterop = &IID_IDisplayDeviceInterop_Value;
pub const IDisplayDeviceInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSharedHandle: fn(
            self: *const IDisplayDeviceInterop,
            pObject: *IInspectable,
            pSecurityAttributes: *const SECURITY_ATTRIBUTES,
            Access: u32,
            Name: HSTRING,
            pHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenSharedHandle: fn(
            self: *const IDisplayDeviceInterop,
            NTHandle: HANDLE,
            riid: Guid,
            ppvObj: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayDeviceInterop_CreateSharedHandle(self: *const T, pObject: *IInspectable, pSecurityAttributes: *const SECURITY_ATTRIBUTES, Access: u32, Name: HSTRING, pHandle: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayDeviceInterop.VTable, self.vtable).CreateSharedHandle(@ptrCast(*const IDisplayDeviceInterop, self), pObject, pSecurityAttributes, Access, Name, pHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayDeviceInterop_OpenSharedHandle(self: *const T, NTHandle: HANDLE, riid: Guid, ppvObj: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayDeviceInterop.VTable, self.vtable).OpenSharedHandle(@ptrCast(*const IDisplayDeviceInterop, self), NTHandle, riid, ppvObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayPathInterop_Value = @import("../zig.zig").Guid.initString("a6ba4205-e59e-4e71-b25b-4e436d21ee3d");
pub const IID_IDisplayPathInterop = &IID_IDisplayPathInterop_Value;
pub const IDisplayPathInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSourcePresentationHandle: fn(
            self: *const IDisplayPathInterop,
            pValue: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceId: fn(
            self: *const IDisplayPathInterop,
            pSourceId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPathInterop_CreateSourcePresentationHandle(self: *const T, pValue: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPathInterop.VTable, self.vtable).CreateSourcePresentationHandle(@ptrCast(*const IDisplayPathInterop, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPathInterop_GetSourceId(self: *const T, pSourceId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPathInterop.VTable, self.vtable).GetSourceId(@ptrCast(*const IDisplayPathInterop, self), pSourceId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PINSPECT_HSTRING_CALLBACK = fn(
    context: *c_void,
    readAddress: usize,
    length: u32,
    buffer: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PINSPECT_HSTRING_CALLBACK2 = fn(
    context: *c_void,
    readAddress: u64,
    length: u32,
    buffer: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

const IID_IGraphicsCaptureItemInterop_Value = @import("../zig.zig").Guid.initString("3628e81b-3cac-4c60-b7f4-23ce0e0c3356");
pub const IID_IGraphicsCaptureItemInterop = &IID_IGraphicsCaptureItemInterop_Value;
pub const IGraphicsCaptureItemInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateForWindow: fn(
            self: *const IGraphicsCaptureItemInterop,
            window: HWND,
            riid: *const Guid,
            result: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateForMonitor: fn(
            self: *const IGraphicsCaptureItemInterop,
            monitor: HMONITOR,
            riid: *const Guid,
            result: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsCaptureItemInterop_CreateForWindow(self: *const T, window: HWND, riid: *const Guid, result: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsCaptureItemInterop.VTable, self.vtable).CreateForWindow(@ptrCast(*const IGraphicsCaptureItemInterop, self), window, riid, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsCaptureItemInterop_CreateForMonitor(self: *const T, monitor: HMONITOR, riid: *const Guid, result: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsCaptureItemInterop.VTable, self.vtable).CreateForMonitor(@ptrCast(*const IGraphicsCaptureItemInterop, self), monitor, riid, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirect3DDxgiInterfaceAccess_Value = @import("../zig.zig").Guid.initString("a9b3d012-3df2-4ee3-b8d1-8695f457d3c1");
pub const IID_IDirect3DDxgiInterfaceAccess = &IID_IDirect3DDxgiInterfaceAccess_Value;
pub const IDirect3DDxgiInterfaceAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterface: fn(
            self: *const IDirect3DDxgiInterfaceAccess,
            iid: *const Guid,
            p: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDxgiInterfaceAccess_GetInterface(self: *const T, iid: *const Guid, p: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDxgiInterfaceAccess.VTable, self.vtable).GetInterface(@ptrCast(*const IDirect3DDxgiInterfaceAccess, self), iid, p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISoftwareBitmapNative_Value = @import("../zig.zig").Guid.initString("94bc8415-04ea-4b2e-af13-4de95aa898eb");
pub const IID_ISoftwareBitmapNative = &IID_ISoftwareBitmapNative_Value;
pub const ISoftwareBitmapNative = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetData: fn(
            self: *const ISoftwareBitmapNative,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftwareBitmapNative_GetData(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftwareBitmapNative.VTable, self.vtable).GetData(@ptrCast(*const ISoftwareBitmapNative, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISoftwareBitmapNativeFactory_Value = @import("../zig.zig").Guid.initString("c3c181ec-2914-4791-af02-02d224a10b43");
pub const IID_ISoftwareBitmapNativeFactory = &IID_ISoftwareBitmapNativeFactory_Value;
pub const ISoftwareBitmapNativeFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateFromWICBitmap: fn(
            self: *const ISoftwareBitmapNativeFactory,
            data: *IWICBitmap,
            forceReadOnly: BOOL,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFromMF2DBuffer2: fn(
            self: *const ISoftwareBitmapNativeFactory,
            data: *IMF2DBuffer2,
            subtype: *const Guid,
            width: u32,
            height: u32,
            forceReadOnly: BOOL,
            minDisplayAperture: ?*const MFVideoArea,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftwareBitmapNativeFactory_CreateFromWICBitmap(self: *const T, data: *IWICBitmap, forceReadOnly: BOOL, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftwareBitmapNativeFactory.VTable, self.vtable).CreateFromWICBitmap(@ptrCast(*const ISoftwareBitmapNativeFactory, self), data, forceReadOnly, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftwareBitmapNativeFactory_CreateFromMF2DBuffer2(self: *const T, data: *IMF2DBuffer2, subtype: *const Guid, width: u32, height: u32, forceReadOnly: BOOL, minDisplayAperture: ?*const MFVideoArea, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftwareBitmapNativeFactory.VTable, self.vtable).CreateFromMF2DBuffer2(@ptrCast(*const ISoftwareBitmapNativeFactory, self), data, subtype, width, height, forceReadOnly, minDisplayAperture, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioFrameNative_Value = @import("../zig.zig").Guid.initString("20be1e2e-930f-4746-9335-3c332f255093");
pub const IID_IAudioFrameNative = &IID_IAudioFrameNative_Value;
pub const IAudioFrameNative = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetData: fn(
            self: *const IAudioFrameNative,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioFrameNative_GetData(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioFrameNative.VTable, self.vtable).GetData(@ptrCast(*const IAudioFrameNative, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVideoFrameNative_Value = @import("../zig.zig").Guid.initString("26ba702b-314a-4620-aaf6-7a51aa58fa18");
pub const IID_IVideoFrameNative = &IID_IVideoFrameNative_Value;
pub const IVideoFrameNative = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetData: fn(
            self: *const IVideoFrameNative,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevice: fn(
            self: *const IVideoFrameNative,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameNative_GetData(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameNative.VTable, self.vtable).GetData(@ptrCast(*const IVideoFrameNative, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameNative_GetDevice(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameNative.VTable, self.vtable).GetDevice(@ptrCast(*const IVideoFrameNative, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioFrameNativeFactory_Value = @import("../zig.zig").Guid.initString("7bd67cf8-bf7d-43e6-af8d-b170ee0c0110");
pub const IID_IAudioFrameNativeFactory = &IID_IAudioFrameNativeFactory_Value;
pub const IAudioFrameNativeFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateFromMFSample: fn(
            self: *const IAudioFrameNativeFactory,
            data: *IMFSample,
            forceReadOnly: BOOL,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioFrameNativeFactory_CreateFromMFSample(self: *const T, data: *IMFSample, forceReadOnly: BOOL, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioFrameNativeFactory.VTable, self.vtable).CreateFromMFSample(@ptrCast(*const IAudioFrameNativeFactory, self), data, forceReadOnly, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVideoFrameNativeFactory_Value = @import("../zig.zig").Guid.initString("69e3693e-8e1e-4e63-ac4c-7fdc21d9731d");
pub const IID_IVideoFrameNativeFactory = &IID_IVideoFrameNativeFactory_Value;
pub const IVideoFrameNativeFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        CreateFromMFSample: fn(
            self: *const IVideoFrameNativeFactory,
            data: *IMFSample,
            subtype: *const Guid,
            width: u32,
            height: u32,
            forceReadOnly: BOOL,
            minDisplayAperture: ?*const MFVideoArea,
            device: ?*IMFDXGIDeviceManager,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameNativeFactory_CreateFromMFSample(self: *const T, data: *IMFSample, subtype: *const Guid, width: u32, height: u32, forceReadOnly: BOOL, minDisplayAperture: ?*const MFVideoArea, device: ?*IMFDXGIDeviceManager, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameNativeFactory.VTable, self.vtable).CreateFromMFSample(@ptrCast(*const IVideoFrameNativeFactory, self), data, subtype, width, height, forceReadOnly, minDisplayAperture, device, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfaceImageSourceNative_Value = @import("../zig.zig").Guid.initString("f2e9edc1-d307-4525-9886-0fafaa44163c");
pub const IID_ISurfaceImageSourceNative = &IID_ISurfaceImageSourceNative_Value;
pub const ISurfaceImageSourceNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDevice: fn(
            self: *const ISurfaceImageSourceNative,
            device: *IDXGIDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDraw: fn(
            self: *const ISurfaceImageSourceNative,
            updateRect: RECT,
            surface: **IDXGISurface,
            offset: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDraw: fn(
            self: *const ISurfaceImageSourceNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_SetDevice(self: *const T, device: *IDXGIDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).SetDevice(@ptrCast(*const ISurfaceImageSourceNative, self), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_BeginDraw(self: *const T, updateRect: RECT, surface: **IDXGISurface, offset: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).BeginDraw(@ptrCast(*const ISurfaceImageSourceNative, self), updateRect, surface, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).EndDraw(@ptrCast(*const ISurfaceImageSourceNative, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVirtualSurfaceUpdatesCallbackNative_Value = @import("../zig.zig").Guid.initString("dbf2e947-8e6c-4254-9eee-7738f71386c9");
pub const IID_IVirtualSurfaceUpdatesCallbackNative = &IID_IVirtualSurfaceUpdatesCallbackNative_Value;
pub const IVirtualSurfaceUpdatesCallbackNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdatesNeeded: fn(
            self: *const IVirtualSurfaceUpdatesCallbackNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceUpdatesCallbackNative_UpdatesNeeded(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceUpdatesCallbackNative.VTable, self.vtable).UpdatesNeeded(@ptrCast(*const IVirtualSurfaceUpdatesCallbackNative, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVirtualSurfaceImageSourceNative_Value = @import("../zig.zig").Guid.initString("e9550983-360b-4f53-b391-afd695078691");
pub const IID_IVirtualSurfaceImageSourceNative = &IID_IVirtualSurfaceImageSourceNative_Value;
pub const IVirtualSurfaceImageSourceNative = extern struct {
    pub const VTable = extern struct {
        base: ISurfaceImageSourceNative.VTable,
        Invalidate: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            updateRect: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateRectCount: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateRects: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            updates: [*]RECT,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVisibleBounds: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            bounds: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForUpdatesNeeded: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            callback: ?*IVirtualSurfaceUpdatesCallbackNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resize: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            newWidth: i32,
            newHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISurfaceImageSourceNative.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_Invalidate(self: *const T, updateRect: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).Invalidate(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), updateRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetUpdateRectCount(self: *const T, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetUpdateRectCount(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetUpdateRects(self: *const T, updates: [*]RECT, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetUpdateRects(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), updates, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetVisibleBounds(self: *const T, bounds: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetVisibleBounds(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), bounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_RegisterForUpdatesNeeded(self: *const T, callback: ?*IVirtualSurfaceUpdatesCallbackNative) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).RegisterForUpdatesNeeded(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_Resize(self: *const T, newWidth: i32, newHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).Resize(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), newWidth, newHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainBackgroundPanelNative_Value = @import("../zig.zig").Guid.initString("43bebd4e-add5-4035-8f85-5608d08e9dc9");
pub const IID_ISwapChainBackgroundPanelNative = &IID_ISwapChainBackgroundPanelNative_Value;
pub const ISwapChainBackgroundPanelNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSwapChain: fn(
            self: *const ISwapChainBackgroundPanelNative,
            swapChain: *IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainBackgroundPanelNative_SetSwapChain(self: *const T, swapChain: *IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainBackgroundPanelNative.VTable, self.vtable).SetSwapChain(@ptrCast(*const ISwapChainBackgroundPanelNative, self), swapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfaceImageSourceManagerNative_Value = @import("../zig.zig").Guid.initString("4c8798b7-1d88-4a0f-b59b-b93f600de8c8");
pub const IID_ISurfaceImageSourceManagerNative = &IID_ISurfaceImageSourceManagerNative_Value;
pub const ISurfaceImageSourceManagerNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FlushAllSurfacesWithDevice: fn(
            self: *const ISurfaceImageSourceManagerNative,
            device: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceManagerNative_FlushAllSurfacesWithDevice(self: *const T, device: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceManagerNative.VTable, self.vtable).FlushAllSurfacesWithDevice(@ptrCast(*const ISurfaceImageSourceManagerNative, self), device);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfaceImageSourceNativeWithD2D_Value = @import("../zig.zig").Guid.initString("54298223-41e1-4a41-9c08-02e8256864a1");
pub const IID_ISurfaceImageSourceNativeWithD2D = &IID_ISurfaceImageSourceNativeWithD2D_Value;
pub const ISurfaceImageSourceNativeWithD2D = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDevice: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
            device: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
            updateRect: *const RECT,
            iid: *const Guid,
            updateObject: **c_void,
            offset: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_SetDevice(self: *const T, device: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).SetDevice(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_BeginDraw(self: *const T, updateRect: *const RECT, iid: *const Guid, updateObject: **c_void, offset: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).BeginDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self), updateRect, iid, updateObject, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).EndDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_SuspendDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).SuspendDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_ResumeDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).ResumeDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainPanelNative_Value = @import("../zig.zig").Guid.initString("f92f19d2-3ade-45a6-a20c-f6f1ea90554b");
pub const IID_ISwapChainPanelNative = &IID_ISwapChainPanelNative_Value;
pub const ISwapChainPanelNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSwapChain: fn(
            self: *const ISwapChainPanelNative,
            swapChain: *IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainPanelNative_SetSwapChain(self: *const T, swapChain: *IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainPanelNative.VTable, self.vtable).SetSwapChain(@ptrCast(*const ISwapChainPanelNative, self), swapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainPanelNative2_Value = @import("../zig.zig").Guid.initString("d5a2f60c-37b2-44a2-937b-8d8eb9726821");
pub const IID_ISwapChainPanelNative2 = &IID_ISwapChainPanelNative2_Value;
pub const ISwapChainPanelNative2 = extern struct {
    pub const VTable = extern struct {
        base: ISwapChainPanelNative.VTable,
        SetSwapChainHandle: fn(
            self: *const ISwapChainPanelNative2,
            swapChainHandle: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISwapChainPanelNative.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainPanelNative2_SetSwapChainHandle(self: *const T, swapChainHandle: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainPanelNative2.VTable, self.vtable).SetSwapChainHandle(@ptrCast(*const ISwapChainPanelNative2, self), swapChainHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const GRAPHICS_EFFECT_PROPERTY_MAPPING = extern enum(i32) {
    UNKNOWN = 0,
    DIRECT = 1,
    VECTORX = 2,
    VECTORY = 3,
    VECTORZ = 4,
    VECTORW = 5,
    RECT_TO_VECTOR4 = 6,
    RADIANS_TO_DEGREES = 7,
    COLORMATRIX_ALPHA_MODE = 8,
    COLOR_TO_VECTOR3 = 9,
    COLOR_TO_VECTOR4 = 10,
};
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_UNKNOWN = GRAPHICS_EFFECT_PROPERTY_MAPPING.UNKNOWN;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_DIRECT = GRAPHICS_EFFECT_PROPERTY_MAPPING.DIRECT;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_VECTORX = GRAPHICS_EFFECT_PROPERTY_MAPPING.VECTORX;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_VECTORY = GRAPHICS_EFFECT_PROPERTY_MAPPING.VECTORY;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_VECTORZ = GRAPHICS_EFFECT_PROPERTY_MAPPING.VECTORZ;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_VECTORW = GRAPHICS_EFFECT_PROPERTY_MAPPING.VECTORW;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_RECT_TO_VECTOR4 = GRAPHICS_EFFECT_PROPERTY_MAPPING.RECT_TO_VECTOR4;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_RADIANS_TO_DEGREES = GRAPHICS_EFFECT_PROPERTY_MAPPING.RADIANS_TO_DEGREES;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_COLORMATRIX_ALPHA_MODE = GRAPHICS_EFFECT_PROPERTY_MAPPING.COLORMATRIX_ALPHA_MODE;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_COLOR_TO_VECTOR3 = GRAPHICS_EFFECT_PROPERTY_MAPPING.COLOR_TO_VECTOR3;
pub const GRAPHICS_EFFECT_PROPERTY_MAPPING_COLOR_TO_VECTOR4 = GRAPHICS_EFFECT_PROPERTY_MAPPING.COLOR_TO_VECTOR4;

const IID_IGraphicsEffectD2D1Interop_Value = @import("../zig.zig").Guid.initString("2fc57384-a068-44d7-a331-30982fcf7177");
pub const IID_IGraphicsEffectD2D1Interop = &IID_IGraphicsEffectD2D1Interop_Value;
pub const IGraphicsEffectD2D1Interop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEffectId: fn(
            self: *const IGraphicsEffectD2D1Interop,
            id: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedPropertyMapping: fn(
            self: *const IGraphicsEffectD2D1Interop,
            name: [*:0]const u16,
            index: *u32,
            mapping: *GRAPHICS_EFFECT_PROPERTY_MAPPING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyCount: fn(
            self: *const IGraphicsEffectD2D1Interop,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IGraphicsEffectD2D1Interop,
            index: u32,
            value: **struct{comment: []const u8 = "MissingClrType IPropertyValue.Windows.Foundation"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: fn(
            self: *const IGraphicsEffectD2D1Interop,
            index: u32,
            source: **struct{comment: []const u8 = "MissingClrType IGraphicsEffectSource.Windows.Graphics.Effects"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceCount: fn(
            self: *const IGraphicsEffectD2D1Interop,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetEffectId(self: *const T, id: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetEffectId(@ptrCast(*const IGraphicsEffectD2D1Interop, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetNamedPropertyMapping(self: *const T, name: [*:0]const u16, index: *u32, mapping: *GRAPHICS_EFFECT_PROPERTY_MAPPING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetNamedPropertyMapping(@ptrCast(*const IGraphicsEffectD2D1Interop, self), name, index, mapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetPropertyCount(self: *const T, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetPropertyCount(@ptrCast(*const IGraphicsEffectD2D1Interop, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetProperty(self: *const T, index: u32, value: **struct{comment: []const u8 = "MissingClrType IPropertyValue.Windows.Foundation"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetProperty(@ptrCast(*const IGraphicsEffectD2D1Interop, self), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetSource(self: *const T, index: u32, source: **struct{comment: []const u8 = "MissingClrType IGraphicsEffectSource.Windows.Graphics.Effects"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetSource(@ptrCast(*const IGraphicsEffectD2D1Interop, self), index, source);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphicsEffectD2D1Interop_GetSourceCount(self: *const T, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphicsEffectD2D1Interop.VTable, self.vtable).GetSourceCount(@ptrCast(*const IGraphicsEffectD2D1Interop, self), count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGeometrySource2DInterop_Value = @import("../zig.zig").Guid.initString("0657af73-53fd-47cf-84ff-c8492d2a80a3");
pub const IID_IGeometrySource2DInterop = &IID_IGeometrySource2DInterop_Value;
pub const IGeometrySource2DInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGeometry: fn(
            self: *const IGeometrySource2DInterop,
            value: **ID2D1Geometry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TryGetGeometryUsingFactory: fn(
            self: *const IGeometrySource2DInterop,
            factory: *ID2D1Factory,
            value: ?*?*ID2D1Geometry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGeometrySource2DInterop_GetGeometry(self: *const T, value: **ID2D1Geometry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGeometrySource2DInterop.VTable, self.vtable).GetGeometry(@ptrCast(*const IGeometrySource2DInterop, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGeometrySource2DInterop_TryGetGeometryUsingFactory(self: *const T, factory: *ID2D1Factory, value: ?*?*ID2D1Geometry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGeometrySource2DInterop.VTable, self.vtable).TryGetGeometryUsingFactory(@ptrCast(*const IGeometrySource2DInterop, self), factory, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositionDrawingSurfaceInterop_Value = @import("../zig.zig").Guid.initString("fd04e6e3-fe0c-4c3c-ab19-a07601a576ee");
pub const IID_ICompositionDrawingSurfaceInterop = &IID_ICompositionDrawingSurfaceInterop_Value;
pub const ICompositionDrawingSurfaceInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginDraw: fn(
            self: *const ICompositionDrawingSurfaceInterop,
            updateRect: ?*const RECT,
            iid: *const Guid,
            updateObject: **c_void,
            updateOffset: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDraw: fn(
            self: *const ICompositionDrawingSurfaceInterop,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resize: fn(
            self: *const ICompositionDrawingSurfaceInterop,
            sizePixels: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Scroll: fn(
            self: *const ICompositionDrawingSurfaceInterop,
            scrollRect: ?*const RECT,
            clipRect: ?*const RECT,
            offsetX: i32,
            offsetY: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeDraw: fn(
            self: *const ICompositionDrawingSurfaceInterop,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendDraw: fn(
            self: *const ICompositionDrawingSurfaceInterop,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_BeginDraw(self: *const T, updateRect: ?*const RECT, iid: *const Guid, updateObject: **c_void, updateOffset: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).BeginDraw(@ptrCast(*const ICompositionDrawingSurfaceInterop, self), updateRect, iid, updateObject, updateOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).EndDraw(@ptrCast(*const ICompositionDrawingSurfaceInterop, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_Resize(self: *const T, sizePixels: SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).Resize(@ptrCast(*const ICompositionDrawingSurfaceInterop, self), sizePixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_Scroll(self: *const T, scrollRect: ?*const RECT, clipRect: ?*const RECT, offsetX: i32, offsetY: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).Scroll(@ptrCast(*const ICompositionDrawingSurfaceInterop, self), scrollRect, clipRect, offsetX, offsetY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_ResumeDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).ResumeDraw(@ptrCast(*const ICompositionDrawingSurfaceInterop, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop_SuspendDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop.VTable, self.vtable).SuspendDraw(@ptrCast(*const ICompositionDrawingSurfaceInterop, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositionDrawingSurfaceInterop2_Value = @import("../zig.zig").Guid.initString("41e64aae-98c0-4239-8e95-a330dd6aa18b");
pub const IID_ICompositionDrawingSurfaceInterop2 = &IID_ICompositionDrawingSurfaceInterop2_Value;
pub const ICompositionDrawingSurfaceInterop2 = extern struct {
    pub const VTable = extern struct {
        base: ICompositionDrawingSurfaceInterop.VTable,
        CopySurface: fn(
            self: *const ICompositionDrawingSurfaceInterop2,
            destinationResource: *IUnknown,
            destinationOffsetX: i32,
            destinationOffsetY: i32,
            sourceRectangle: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICompositionDrawingSurfaceInterop.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionDrawingSurfaceInterop2_CopySurface(self: *const T, destinationResource: *IUnknown, destinationOffsetX: i32, destinationOffsetY: i32, sourceRectangle: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionDrawingSurfaceInterop2.VTable, self.vtable).CopySurface(@ptrCast(*const ICompositionDrawingSurfaceInterop2, self), destinationResource, destinationOffsetX, destinationOffsetY, sourceRectangle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositionGraphicsDeviceInterop_Value = @import("../zig.zig").Guid.initString("a116ff71-f8bf-4c8a-9c98-70779a32a9c8");
pub const IID_ICompositionGraphicsDeviceInterop = &IID_ICompositionGraphicsDeviceInterop_Value;
pub const ICompositionGraphicsDeviceInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRenderingDevice: fn(
            self: *const ICompositionGraphicsDeviceInterop,
            value: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingDevice: fn(
            self: *const ICompositionGraphicsDeviceInterop,
            value: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionGraphicsDeviceInterop_GetRenderingDevice(self: *const T, value: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionGraphicsDeviceInterop.VTable, self.vtable).GetRenderingDevice(@ptrCast(*const ICompositionGraphicsDeviceInterop, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionGraphicsDeviceInterop_SetRenderingDevice(self: *const T, value: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionGraphicsDeviceInterop.VTable, self.vtable).SetRenderingDevice(@ptrCast(*const ICompositionGraphicsDeviceInterop, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositorInterop_Value = @import("../zig.zig").Guid.initString("25297d5c-3ad4-4c9c-b5cf-e36a38512330");
pub const IID_ICompositorInterop = &IID_ICompositorInterop_Value;
pub const ICompositorInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCompositionSurfaceForHandle: fn(
            self: *const ICompositorInterop,
            swapChain: HANDLE,
            result: **struct{comment: []const u8 = "MissingClrType ICompositionSurface.Windows.UI.Composition"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompositionSurfaceForSwapChain: fn(
            self: *const ICompositorInterop,
            swapChain: *IUnknown,
            result: **struct{comment: []const u8 = "MissingClrType ICompositionSurface.Windows.UI.Composition"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateGraphicsDevice: fn(
            self: *const ICompositorInterop,
            renderingDevice: *IUnknown,
            result: **struct{comment: []const u8 = "MissingClrType CompositionGraphicsDevice.Windows.UI.Composition"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositorInterop_CreateCompositionSurfaceForHandle(self: *const T, swapChain: HANDLE, result: **struct{comment: []const u8 = "MissingClrType ICompositionSurface.Windows.UI.Composition"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositorInterop.VTable, self.vtable).CreateCompositionSurfaceForHandle(@ptrCast(*const ICompositorInterop, self), swapChain, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositorInterop_CreateCompositionSurfaceForSwapChain(self: *const T, swapChain: *IUnknown, result: **struct{comment: []const u8 = "MissingClrType ICompositionSurface.Windows.UI.Composition"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositorInterop.VTable, self.vtable).CreateCompositionSurfaceForSwapChain(@ptrCast(*const ICompositorInterop, self), swapChain, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositorInterop_CreateGraphicsDevice(self: *const T, renderingDevice: *IUnknown, result: **struct{comment: []const u8 = "MissingClrType CompositionGraphicsDevice.Windows.UI.Composition"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositorInterop.VTable, self.vtable).CreateGraphicsDevice(@ptrCast(*const ICompositorInterop, self), renderingDevice, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainInterop_Value = @import("../zig.zig").Guid.initString("26f496a0-7f38-45fb-88f7-faaabe67dd59");
pub const IID_ISwapChainInterop = &IID_ISwapChainInterop_Value;
pub const ISwapChainInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSwapChain: fn(
            self: *const ISwapChainInterop,
            swapChain: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainInterop_SetSwapChain(self: *const T, swapChain: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainInterop.VTable, self.vtable).SetSwapChain(@ptrCast(*const ISwapChainInterop, self), swapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVisualInteractionSourceInterop_Value = @import("../zig.zig").Guid.initString("11f62cd1-2f9d-42d3-b05f-d6790d9e9f8e");
pub const IID_IVisualInteractionSourceInterop = &IID_IVisualInteractionSourceInterop_Value;
pub const IVisualInteractionSourceInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TryRedirectForManipulation: fn(
            self: *const IVisualInteractionSourceInterop,
            pointerInfo: *const POINTER_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualInteractionSourceInterop_TryRedirectForManipulation(self: *const T, pointerInfo: *const POINTER_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualInteractionSourceInterop.VTable, self.vtable).TryRedirectForManipulation(@ptrCast(*const IVisualInteractionSourceInterop, self), pointerInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositionCapabilitiesInteropFactory_Value = @import("../zig.zig").Guid.initString("2c9db356-e70d-4642-8298-bc4aa5b4865c");
pub const IID_ICompositionCapabilitiesInteropFactory = &IID_ICompositionCapabilitiesInteropFactory_Value;
pub const ICompositionCapabilitiesInteropFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        GetForWindow: fn(
            self: *const ICompositionCapabilitiesInteropFactory,
            hwnd: HWND,
            result: **struct{comment: []const u8 = "MissingClrType CompositionCapabilities.Windows.UI.Composition"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositionCapabilitiesInteropFactory_GetForWindow(self: *const T, hwnd: HWND, result: **struct{comment: []const u8 = "MissingClrType CompositionCapabilities.Windows.UI.Composition"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositionCapabilitiesInteropFactory.VTable, self.vtable).GetForWindow(@ptrCast(*const ICompositionCapabilitiesInteropFactory, self), hwnd, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICompositorDesktopInterop_Value = @import("../zig.zig").Guid.initString("29e691fa-4567-4dca-b319-d0f207eb6807");
pub const IID_ICompositorDesktopInterop = &IID_ICompositorDesktopInterop_Value;
pub const ICompositorDesktopInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDesktopWindowTarget: fn(
            self: *const ICompositorDesktopInterop,
            hwndTarget: HWND,
            isTopmost: BOOL,
            result: **struct{comment: []const u8 = "MissingClrType DesktopWindowTarget.Windows.UI.Composition.Desktop"},
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnsureOnThread: fn(
            self: *const ICompositorDesktopInterop,
            threadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositorDesktopInterop_CreateDesktopWindowTarget(self: *const T, hwndTarget: HWND, isTopmost: BOOL, result: **struct{comment: []const u8 = "MissingClrType DesktopWindowTarget.Windows.UI.Composition.Desktop"}) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositorDesktopInterop.VTable, self.vtable).CreateDesktopWindowTarget(@ptrCast(*const ICompositorDesktopInterop, self), hwndTarget, isTopmost, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICompositorDesktopInterop_EnsureOnThread(self: *const T, threadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICompositorDesktopInterop.VTable, self.vtable).EnsureOnThread(@ptrCast(*const ICompositorDesktopInterop, self), threadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDesktopWindowTargetInterop_Value = @import("../zig.zig").Guid.initString("35dbf59e-e3f9-45b0-81e7-fe75f4145dc9");
pub const IID_IDesktopWindowTargetInterop = &IID_IDesktopWindowTargetInterop_Value;
pub const IDesktopWindowTargetInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hwnd: fn(
            self: *const IDesktopWindowTargetInterop,
            value: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowTargetInterop_get_Hwnd(self: *const T, value: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowTargetInterop.VTable, self.vtable).get_Hwnd(@ptrCast(*const IDesktopWindowTargetInterop, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDesktopWindowContentBridgeInterop_Value = @import("../zig.zig").Guid.initString("37642806-f421-4fd0-9f82-23ae7c776182");
pub const IID_IDesktopWindowContentBridgeInterop = &IID_IDesktopWindowContentBridgeInterop_Value;
pub const IDesktopWindowContentBridgeInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDesktopWindowContentBridgeInterop,
            compositor: *struct{comment: []const u8 = "MissingClrType Compositor.Windows.UI.Composition"},
            parentHwnd: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hwnd: fn(
            self: *const IDesktopWindowContentBridgeInterop,
            value: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppliedScaleFactor: fn(
            self: *const IDesktopWindowContentBridgeInterop,
            value: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowContentBridgeInterop_Initialize(self: *const T, compositor: *struct{comment: []const u8 = "MissingClrType Compositor.Windows.UI.Composition"}, parentHwnd: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowContentBridgeInterop.VTable, self.vtable).Initialize(@ptrCast(*const IDesktopWindowContentBridgeInterop, self), compositor, parentHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowContentBridgeInterop_get_Hwnd(self: *const T, value: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowContentBridgeInterop.VTable, self.vtable).get_Hwnd(@ptrCast(*const IDesktopWindowContentBridgeInterop, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowContentBridgeInterop_get_AppliedScaleFactor(self: *const T, value: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowContentBridgeInterop.VTable, self.vtable).get_AppliedScaleFactor(@ptrCast(*const IDesktopWindowContentBridgeInterop, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IRestrictedErrorInfo_Value = @import("../zig.zig").Guid.initString("82ba7092-4c88-427d-a7bc-16dd93feb67e");
pub const IID_IRestrictedErrorInfo = &IID_IRestrictedErrorInfo_Value;
pub const IRestrictedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDetails: fn(
            self: *const IRestrictedErrorInfo,
            description: *BSTR,
            @"error": *HRESULT,
            restrictedDescription: *BSTR,
            capabilitySid: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReference: fn(
            self: *const IRestrictedErrorInfo,
            reference: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRestrictedErrorInfo_GetErrorDetails(self: *const T, description: *BSTR, @"error": *HRESULT, restrictedDescription: *BSTR, capabilitySid: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRestrictedErrorInfo.VTable, self.vtable).GetErrorDetails(@ptrCast(*const IRestrictedErrorInfo, self), description, @"error", restrictedDescription, capabilitySid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRestrictedErrorInfo_GetReference(self: *const T, reference: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRestrictedErrorInfo.VTable, self.vtable).GetReference(@ptrCast(*const IRestrictedErrorInfo, self), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ILanguageExceptionErrorInfo_Value = @import("../zig.zig").Guid.initString("04a2dbf3-df83-116c-0946-0812abf6e07d");
pub const IID_ILanguageExceptionErrorInfo = &IID_ILanguageExceptionErrorInfo_Value;
pub const ILanguageExceptionErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLanguageException: fn(
            self: *const ILanguageExceptionErrorInfo,
            languageException: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo_GetLanguageException(self: *const T, languageException: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo.VTable, self.vtable).GetLanguageException(@ptrCast(*const ILanguageExceptionErrorInfo, self), languageException);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionTransform_Value = @import("../zig.zig").Guid.initString("feb5a271-a6cd-45ce-880a-696706badc65");
pub const IID_ILanguageExceptionTransform = &IID_ILanguageExceptionTransform_Value;
pub const ILanguageExceptionTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransformedRestrictedErrorInfo: fn(
            self: *const ILanguageExceptionTransform,
            restrictedErrorInfo: **IRestrictedErrorInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionTransform_GetTransformedRestrictedErrorInfo(self: *const T, restrictedErrorInfo: **IRestrictedErrorInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionTransform.VTable, self.vtable).GetTransformedRestrictedErrorInfo(@ptrCast(*const ILanguageExceptionTransform, self), restrictedErrorInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionStackBackTrace_Value = @import("../zig.zig").Guid.initString("cbe53fb5-f967-4258-8d34-42f5e25833de");
pub const IID_ILanguageExceptionStackBackTrace = &IID_ILanguageExceptionStackBackTrace_Value;
pub const ILanguageExceptionStackBackTrace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStackBackTrace: fn(
            self: *const ILanguageExceptionStackBackTrace,
            maxFramesToCapture: u32,
            stackBackTrace: *usize,
            framesCaptured: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionStackBackTrace_GetStackBackTrace(self: *const T, maxFramesToCapture: u32, stackBackTrace: *usize, framesCaptured: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionStackBackTrace.VTable, self.vtable).GetStackBackTrace(@ptrCast(*const ILanguageExceptionStackBackTrace, self), maxFramesToCapture, stackBackTrace, framesCaptured);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ILanguageExceptionErrorInfo2_Value = @import("../zig.zig").Guid.initString("5746e5c4-5b97-424c-b620-2822915734dd");
pub const IID_ILanguageExceptionErrorInfo2 = &IID_ILanguageExceptionErrorInfo2_Value;
pub const ILanguageExceptionErrorInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ILanguageExceptionErrorInfo.VTable,
        GetPreviousLanguageExceptionErrorInfo: fn(
            self: *const ILanguageExceptionErrorInfo2,
            previousLanguageExceptionErrorInfo: **ILanguageExceptionErrorInfo2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CapturePropagationContext: fn(
            self: *const ILanguageExceptionErrorInfo2,
            languageException: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropagationContextHead: fn(
            self: *const ILanguageExceptionErrorInfo2,
            propagatedLanguageExceptionErrorInfoHead: **ILanguageExceptionErrorInfo2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILanguageExceptionErrorInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_GetPreviousLanguageExceptionErrorInfo(self: *const T, previousLanguageExceptionErrorInfo: **ILanguageExceptionErrorInfo2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).GetPreviousLanguageExceptionErrorInfo(@ptrCast(*const ILanguageExceptionErrorInfo2, self), previousLanguageExceptionErrorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_CapturePropagationContext(self: *const T, languageException: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).CapturePropagationContext(@ptrCast(*const ILanguageExceptionErrorInfo2, self), languageException);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageExceptionErrorInfo2_GetPropagationContextHead(self: *const T, propagatedLanguageExceptionErrorInfoHead: **ILanguageExceptionErrorInfo2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageExceptionErrorInfo2.VTable, self.vtable).GetPropagationContextHead(@ptrCast(*const ILanguageExceptionErrorInfo2, self), propagatedLanguageExceptionErrorInfoHead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivationFactory_Value = @import("../zig.zig").Guid.initString("00000035-0000-0000-c000-000000000046");
pub const IID_IActivationFactory = &IID_IActivationFactory_Value;
pub const IActivationFactory = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        ActivateInstance: fn(
            self: *const IActivationFactory,
            instance: ?*?*IInspectable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivationFactory_ActivateInstance(self: *const T, instance: ?*?*IInspectable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivationFactory.VTable, self.vtable).ActivateInstance(@ptrCast(*const IActivationFactory, self), instance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RO_INIT_TYPE = extern enum(i32) {
    SINGLETHREADED = 0,
    MULTITHREADED = 1,
};
pub const RO_INIT_SINGLETHREADED = RO_INIT_TYPE.SINGLETHREADED;
pub const RO_INIT_MULTITHREADED = RO_INIT_TYPE.MULTITHREADED;

pub const __AnonymousRecord_roapi_L45_C9 = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

const IID_IBufferByteAccess_Value = @import("../zig.zig").Guid.initString("905a0fef-bc53-11df-8c49-001e4fc686da");
pub const IID_IBufferByteAccess = &IID_IBufferByteAccess_Value;
pub const IBufferByteAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Buffer: fn(
            self: *const IBufferByteAccess,
            value: **u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferByteAccess_Buffer(self: *const T, value: **u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBufferByteAccess.VTable, self.vtable).Buffer(@ptrCast(*const IBufferByteAccess, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const RO_ERROR_REPORTING_FLAGS = extern enum(u32) {
    NONE = 0,
    SUPPRESSEXCEPTIONS = 1,
    FORCEEXCEPTIONS = 2,
    USESETERRORINFO = 4,
    SUPPRESSSETERRORINFO = 8,
    _,
};
pub const RO_ERROR_REPORTING_NONE = RO_ERROR_REPORTING_FLAGS.NONE;
pub const RO_ERROR_REPORTING_SUPPRESSEXCEPTIONS = RO_ERROR_REPORTING_FLAGS.SUPPRESSEXCEPTIONS;
pub const RO_ERROR_REPORTING_FORCEEXCEPTIONS = RO_ERROR_REPORTING_FLAGS.FORCEEXCEPTIONS;
pub const RO_ERROR_REPORTING_USESETERRORINFO = RO_ERROR_REPORTING_FLAGS.USESETERRORINFO;
pub const RO_ERROR_REPORTING_SUPPRESSSETERRORINFO = RO_ERROR_REPORTING_FLAGS.SUPPRESSSETERRORINFO;

pub const PINSPECT_MEMORY_CALLBACK = fn(
    context: ?*c_void,
    readAddress: usize,
    length: u32,
    buffer: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IRoSimpleMetaDataBuilder = extern struct {
    pub const VTable = extern struct {
        SetWinRtInterface: fn(
            self: *const IRoSimpleMetaDataBuilder,
            iid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDelegate: fn(
            self: *const IRoSimpleMetaDataBuilder,
            iid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterfaceGroupSimpleDefault: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            defaultInterfaceName: [*:0]const u16,
            defaultInterfaceIID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterfaceGroupParameterizedDefault: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            elementCount: u32,
            defaultInterfaceNameElements: [*]PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRuntimeClassSimpleDefault: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            defaultInterfaceName: [*:0]const u16,
            defaultInterfaceIID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRuntimeClassParameterizedDefault: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            elementCount: u32,
            defaultInterfaceNameElements: [*]const [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStruct: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            numFields: u32,
            fieldTypeNames: [*]const [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnum: fn(
            self: *const IRoSimpleMetaDataBuilder,
            name: [*:0]const u16,
            baseType: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameterizedInterface: fn(
            self: *const IRoSimpleMetaDataBuilder,
            piid: Guid,
            numArgs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameterizedDelegate: fn(
            self: *const IRoSimpleMetaDataBuilder,
            piid: Guid,
            numArgs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetWinRtInterface(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetWinRtInterface(@ptrCast(*const IRoSimpleMetaDataBuilder, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetDelegate(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetDelegate(@ptrCast(*const IRoSimpleMetaDataBuilder, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupSimpleDefault(self: *const T, name: [*:0]const u16, defaultInterfaceName: [*:0]const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetInterfaceGroupSimpleDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupParameterizedDefault(self: *const T, name: [*:0]const u16, elementCount: u32, defaultInterfaceNameElements: [*]PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetInterfaceGroupParameterizedDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassSimpleDefault(self: *const T, name: [*:0]const u16, defaultInterfaceName: [*:0]const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetRuntimeClassSimpleDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassParameterizedDefault(self: *const T, name: [*:0]const u16, elementCount: u32, defaultInterfaceNameElements: [*]const [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetRuntimeClassParameterizedDefault(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetStruct(self: *const T, name: [*:0]const u16, numFields: u32, fieldTypeNames: [*]const [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetStruct(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, numFields, fieldTypeNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetEnum(self: *const T, name: [*:0]const u16, baseType: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetEnum(@ptrCast(*const IRoSimpleMetaDataBuilder, self), name, baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedInterface(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetParameterizedInterface(@ptrCast(*const IRoSimpleMetaDataBuilder, self), piid, numArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedDelegate(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoSimpleMetaDataBuilder.VTable, self.vtable).SetParameterizedDelegate(@ptrCast(*const IRoSimpleMetaDataBuilder, self), piid, numArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRoMetaDataLocator = extern struct {
    pub const VTable = extern struct {
        Locate: fn(
            self: *const IRoMetaDataLocator,
            nameElement: [*:0]const u16,
            metaDataDestination: *IRoSimpleMetaDataBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoMetaDataLocator_Locate(self: *const T, nameElement: [*:0]const u16, metaDataDestination: *IRoSimpleMetaDataBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRoMetaDataLocator.VTable, self.vtable).Locate(@ptrCast(*const IRoMetaDataLocator, self), nameElement, metaDataDestination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BSOS_OPTIONS = extern enum(i32) {
    DEFAULT = 0,
    PREFERDESTINATIONSTREAM = 1,
};
pub const BSOS_DEFAULT = BSOS_OPTIONS.DEFAULT;
pub const BSOS_PREFERDESTINATIONSTREAM = BSOS_OPTIONS.PREFERDESTINATIONSTREAM;

const IID_IMemoryBufferByteAccess_Value = @import("../zig.zig").Guid.initString("5b0d3235-4dba-4d44-865e-8f1d0e4fd04d");
pub const IID_IMemoryBufferByteAccess = &IID_IMemoryBufferByteAccess_Value;
pub const IMemoryBufferByteAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const IMemoryBufferByteAccess,
            value: **u8,
            capacity: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryBufferByteAccess_GetBuffer(self: *const T, value: **u8, capacity: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemoryBufferByteAccess.VTable, self.vtable).GetBuffer(@ptrCast(*const IMemoryBufferByteAccess, self), value, capacity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWeakReference_Value = @import("../zig.zig").Guid.initString("00000037-0000-0000-c000-000000000046");
pub const IID_IWeakReference = &IID_IWeakReference_Value;
pub const IWeakReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: fn(
            self: *const IWeakReference,
            riid: *const Guid,
            objectReference: **IInspectable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeakReference_Resolve(self: *const T, riid: *const Guid, objectReference: **IInspectable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeakReference.VTable, self.vtable).Resolve(@ptrCast(*const IWeakReference, self), riid, objectReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWeakReferenceSource_Value = @import("../zig.zig").Guid.initString("00000038-0000-0000-c000-000000000046");
pub const IID_IWeakReferenceSource = &IID_IWeakReferenceSource_Value;
pub const IWeakReferenceSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWeakReference: fn(
            self: *const IWeakReferenceSource,
            weakReference: ?*?*IWeakReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeakReferenceSource_GetWeakReference(self: *const T, weakReference: ?*?*IWeakReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeakReferenceSource.VTable, self.vtable).GetWeakReference(@ptrCast(*const IWeakReferenceSource, self), weakReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type has a FreeFunc 'WindowsDeleteString', what can Zig do with this information?
pub const HSTRING = ?*opaque{};

pub const HSTRING_BUFFER = isize;

pub const ROPARAMIIDHANDLE = isize;

pub const APARTMENT_SHUTDOWN_REGISTRATION_COOKIE = isize;

pub const ACTIVATIONTYPE = extern enum(i32) {
    UNCATEGORIZED = 0,
    FROM_MONIKER = 1,
    FROM_DATA = 2,
    FROM_STORAGE = 4,
    FROM_STREAM = 8,
    FROM_FILE = 16,
};
pub const ACTIVATIONTYPE_UNCATEGORIZED = ACTIVATIONTYPE.UNCATEGORIZED;
pub const ACTIVATIONTYPE_FROM_MONIKER = ACTIVATIONTYPE.FROM_MONIKER;
pub const ACTIVATIONTYPE_FROM_DATA = ACTIVATIONTYPE.FROM_DATA;
pub const ACTIVATIONTYPE_FROM_STORAGE = ACTIVATIONTYPE.FROM_STORAGE;
pub const ACTIVATIONTYPE_FROM_STREAM = ACTIVATIONTYPE.FROM_STREAM;
pub const ACTIVATIONTYPE_FROM_FILE = ACTIVATIONTYPE.FROM_FILE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IAgileReference_Value = @import("../zig.zig").Guid.initString("c03f6a43-65a4-9818-987e-e0b810d2a6f2");
pub const IID_IAgileReference = &IID_IAgileReference_Value;
pub const IAgileReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: fn(
            self: *const IAgileReference,
            riid: *const Guid,
            ppvObjectReference: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAgileReference_Resolve(self: *const T, riid: *const Guid, ppvObjectReference: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAgileReference.VTable, self.vtable).Resolve(@ptrCast(*const IAgileReference, self), riid, ppvObjectReference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IApartmentShutdown_Value = @import("../zig.zig").Guid.initString("a2f05a09-27a2-42b5-bc0e-ac163ef49d9b");
pub const IID_IApartmentShutdown = &IID_IApartmentShutdown_Value;
pub const IApartmentShutdown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUninitialize: fn(
            self: *const IApartmentShutdown,
            ui64ApartmentIdentifier: u64,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApartmentShutdown_OnUninitialize(self: *const T, ui64ApartmentIdentifier: u64) callconv(.Inline) void {
            return @ptrCast(*const IApartmentShutdown.VTable, self.vtable).OnUninitialize(@ptrCast(*const IApartmentShutdown, self), ui64ApartmentIdentifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ServerInformation = extern struct {
    dwServerPid: u32,
    dwServerTid: u32,
    ui64ServerAddress: u64,
};

pub const AgileReferenceOptions = extern enum(i32) {
    FAULT = 0,
    LAYEDMARSHAL = 1,
};
pub const AGILEREFERENCE_DEFAULT = AgileReferenceOptions.FAULT;
pub const AGILEREFERENCE_DELAYEDMARSHAL = AgileReferenceOptions.LAYEDMARSHAL;


//--------------------------------------------------------------------------------
// Section: Functions (70)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize(
    param0: *u32,
    param1: u32,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal(
    param0: *u32,
    param1: *u8,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal(
    param0: *u32,
    param1: [*:0]u8,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree(
    param0: *u32,
    param1: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserSize64(
    param0: *u32,
    param1: u32,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserMarshal64(
    param0: *u32,
    param1: *u8,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserUnmarshal64(
    param0: *u32,
    param1: [*:0]u8,
    param2: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) *u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn HSTRING_UserFree64(
    param0: *u32,
    param1: *HSTRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "Windows.Data.Pdf" fn PdfCreateRenderer(
    pDevice: *IDXGIDevice,
    ppRenderer: **IPdfRendererNative,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateString(
    sourceString: ?[*:0]const u16,
    length: u32,
    string: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCreateStringReference(
    sourceString: ?[*:0]const u16,
    length: u32,
    hstringHeader: *HSTRING_HEADER,
    string: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteString(
    string: HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDuplicateString(
    string: HSTRING,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringLen(
    string: HSTRING,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsGetStringRawBuffer(
    string: HSTRING,
    length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsIsStringEmpty(
    string: HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsStringHasEmbeddedNull(
    string: HSTRING,
    hasEmbedNull: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsCompareStringOrdinal(
    string1: HSTRING,
    string2: HSTRING,
    result: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstring(
    string: HSTRING,
    startIndex: u32,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsSubstringWithSpecifiedLength(
    string: HSTRING,
    startIndex: u32,
    length: u32,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsConcatString(
    string1: HSTRING,
    string2: HSTRING,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsReplaceString(
    string: HSTRING,
    stringReplaced: HSTRING,
    stringReplaceWith: HSTRING,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringStart(
    string: HSTRING,
    trimString: HSTRING,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsTrimStringEnd(
    string: HSTRING,
    trimString: HSTRING,
    newString: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPreallocateStringBuffer(
    length: u32,
    charBuffer: **u16,
    bufferHandle: *HSTRING_BUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsPromoteStringBuffer(
    bufferHandle: HSTRING_BUFFER,
    string: ?*HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsDeleteStringBuffer(
    bufferHandle: HSTRING_BUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-0" fn WindowsInspectString(
    targetHString: usize,
    machine: u16,
    callback: PINSPECT_HSTRING_CALLBACK,
    context: ?*c_void,
    length: *u32,
    targetStringAddress: *usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-string-l1-1-1" fn WindowsInspectString2(
    targetHString: u64,
    machine: u16,
    callback: PINSPECT_HSTRING_CALLBACK2,
    context: ?*c_void,
    length: *u32,
    targetStringAddress: *u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d11" fn CreateDirect3D11DeviceFromDXGIDevice(
    dxgiDevice: *IDXGIDevice,
    graphicsDevice: **IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d3d11" fn CreateDirect3D11SurfaceFromDXGISurface(
    dgxiSurface: *IDXGISurface,
    graphicsSurface: **IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoInitialize(
    initType: RO_INIT_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoActivateInstance(
    activatableClassId: HSTRING,
    instance: **IInspectable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterActivationFactories(
    activatableClassIds: [*]HSTRING,
    activationFactoryCallbacks: [*]isize,
    count: u32,
    cookie: *isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRevokeActivationFactories(
    cookie: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetActivationFactory(
    activatableClassId: HSTRING,
    iid: *const Guid,
    factory: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoRegisterForApartmentShutdown(
    callbackObject: *IApartmentShutdown,
    apartmentIdentifier: *u64,
    regCookie: *APARTMENT_SHUTDOWN_REGISTRATION_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoUnregisterForApartmentShutdown(
    regCookie: APARTMENT_SHUTDOWN_REGISTRATION_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-l1-1-0" fn RoGetApartmentIdentifier(
    apartmentIdentifier: *u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-robuffer-l1-1-0" fn RoGetBufferMarshaler(
    bufferMarshaler: **IMarshal,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoGetErrorReportingFlags(
    pflags: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoSetErrorReportingFlags(
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoResolveRestrictedErrorInfoReference(
    reference: [*:0]const u16,
    ppRestrictedErrorInfo: **IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn SetRestrictedErrorInfo(
    pRestrictedErrorInfo: ?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn GetRestrictedErrorInfo(
    ppRestrictedErrorInfo: ?*?*IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateErrorW(
    @"error": HRESULT,
    cchMax: u32,
    message: ?*[512]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoOriginateError(
    @"error": HRESULT,
    message: HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformErrorW(
    oldError: HRESULT,
    newError: HRESULT,
    cchMax: u32,
    message: ?*[512]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoTransformError(
    oldError: HRESULT,
    newError: HRESULT,
    message: HSTRING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoCaptureErrorContext(
    hr: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-0" fn RoFailFastWithErrorContext(
    hrError: HRESULT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoOriginateLanguageException(
    @"error": HRESULT,
    message: HSTRING,
    languageException: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoClearError(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportUnhandledError(
    pRestrictedErrorInfo: *IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectThreadErrorInfo(
    targetTebAddress: usize,
    machine: u16,
    readMemoryCallback: PINSPECT_MEMORY_CALLBACK,
    context: ?*c_void,
    targetErrorInfoAddress: *usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoInspectCapturedStackBackTrace(
    targetErrorInfoAddress: usize,
    machine: u16,
    readMemoryCallback: PINSPECT_MEMORY_CALLBACK,
    context: ?*c_void,
    frameCount: *u32,
    targetBackTraceAddress: *usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoGetMatchingRestrictedErrorInfo(
    hrIn: HRESULT,
    ppRestrictedErrorInfo: **IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-winrt-error-l1-1-1" fn RoReportFailedDelegate(
    punkDelegate: *IUnknown,
    pRestrictedErrorInfo: *IRestrictedErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-error-l1-1-1" fn IsErrorPropagationEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "RoMetadata" fn MetaDataGetDispenser(
    rclsid: *const Guid,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoGetParameterizedTypeInstanceIID(
    nameElementCount: u32,
    nameElements: [*]PWSTR,
    metaDataLocator: *IRoMetaDataLocator,
    iid: *Guid,
    pExtra: ?*ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoFreeParameterizedTypeExtra(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoParameterizedTypeExtraGetTypeSignature(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-registration-l1-1-0" fn RoGetServerActivatableClasses(
    serverName: HSTRING,
    activatableClassIds: **HSTRING,
    count: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOnFile(
    filePath: [*:0]const u16,
    accessMode: u32,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateRandomAccessStreamOverStream(
    stream: *IStream,
    options: BSOS_OPTIONS,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-stream-winrt-l1-1-0" fn CreateStreamOverRandomAccessStream(
    randomAccessStream: *IUnknown,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoDecodeProxy(
    dwClientPid: u32,
    ui64ProxyAddress: u64,
    pServerInformation: *ServerInformation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "OLE32" fn RoGetAgileReference(
    options: AgileReferenceOptions,
    riid: *const Guid,
    pUnk: *IUnknown,
    ppAgileReference: **IAgileReference,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (31)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IMarshal = @import("com.zig").IMarshal;
const HRESULT = @import("com.zig").HRESULT;
const IWICBitmap = @import("windows_imaging_component.zig").IWICBitmap;
const BOOL = @import("system_services.zig").BOOL;
const ID2D1Geometry = @import("direct2d.zig").ID2D1Geometry;
const IDXGIDevice = @import("dxgi.zig").IDXGIDevice;
const D2D_RECT_F = @import("direct2d.zig").D2D_RECT_F;
const INamedPropertyStore = @import("shell.zig").INamedPropertyStore;
const IDXGISurface = @import("dxgi.zig").IDXGISurface;
const IMFDXGIDeviceManager = @import("media_foundation.zig").IMFDXGIDeviceManager;
const ID2D1DeviceContext = @import("direct2d.zig").ID2D1DeviceContext;
const IStream = @import("structured_storage.zig").IStream;
const HMONITOR = @import("gdi.zig").HMONITOR;
const PWSTR = @import("system_services.zig").PWSTR;
const D2D_COLOR_F = @import("direct2d.zig").D2D_COLOR_F;
const IUnknown = @import("com.zig").IUnknown;
const POINTER_INFO = @import("pointer_input.zig").POINTER_INFO;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const BSTR = @import("automation.zig").BSTR;
const RECT = @import("display_devices.zig").RECT;
const IDXGISwapChain = @import("dxgi.zig").IDXGISwapChain;
const PSTR = @import("system_services.zig").PSTR;
const HWND = @import("windows_and_messaging.zig").HWND;
const MFVideoArea = @import("media_foundation.zig").MFVideoArea;
const IMFSample = @import("media_foundation.zig").IMFSample;
const ID2D1Factory = @import("direct2d.zig").ID2D1Factory;
const IMF2DBuffer2 = @import("media_foundation.zig").IMF2DBuffer2;
const POINT = @import("display_devices.zig").POINT;
const SIZE = @import("display_devices.zig").SIZE;
const HANDLE = @import("system_services.zig").HANDLE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_PDF_CREATE_RENDERER")) { _ = PFN_PDF_CREATE_RENDERER; }
    if (@hasDecl(@This(), "PINSPECT_HSTRING_CALLBACK")) { _ = PINSPECT_HSTRING_CALLBACK; }
    if (@hasDecl(@This(), "PINSPECT_HSTRING_CALLBACK2")) { _ = PINSPECT_HSTRING_CALLBACK2; }
    if (@hasDecl(@This(), "PINSPECT_MEMORY_CALLBACK")) { _ = PINSPECT_MEMORY_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
