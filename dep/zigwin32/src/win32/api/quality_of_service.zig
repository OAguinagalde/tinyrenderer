//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (199)
//--------------------------------------------------------------------------------
pub const QOS_MAX_OBJECT_STRING_LENGTH = @as(u32, 256);
pub const QOS_TRAFFIC_GENERAL_ID_BASE = @as(u32, 4000);
pub const SERVICETYPE_NOTRAFFIC = @as(u32, 0);
pub const SERVICETYPE_BESTEFFORT = @as(u32, 1);
pub const SERVICETYPE_CONTROLLEDLOAD = @as(u32, 2);
pub const SERVICETYPE_GUARANTEED = @as(u32, 3);
pub const SERVICETYPE_NETWORK_UNAVAILABLE = @as(u32, 4);
pub const SERVICETYPE_GENERAL_INFORMATION = @as(u32, 5);
pub const SERVICETYPE_NOCHANGE = @as(u32, 6);
pub const SERVICETYPE_NONCONFORMING = @as(u32, 9);
pub const SERVICETYPE_NETWORK_CONTROL = @as(u32, 10);
pub const SERVICETYPE_QUALITATIVE = @as(u32, 13);
pub const SERVICE_BESTEFFORT = @as(u32, 2147549184);
pub const SERVICE_CONTROLLEDLOAD = @as(u32, 2147614720);
pub const SERVICE_GUARANTEED = @as(u32, 2147745792);
pub const SERVICE_QUALITATIVE = @as(u32, 2149580800);
pub const SERVICE_NO_TRAFFIC_CONTROL = @as(u32, 2164260864);
pub const SERVICE_NO_QOS_SIGNALING = @as(u32, 1073741824);
pub const QOS_NOT_SPECIFIED = @as(u32, 4294967295);
pub const POSITIVE_INFINITY_RATE = @as(u32, 4294967294);
pub const QOS_GENERAL_ID_BASE = @as(u32, 2000);
pub const TC_NONCONF_BORROW = @as(u32, 0);
pub const TC_NONCONF_SHAPE = @as(u32, 1);
pub const TC_NONCONF_DISCARD = @as(u32, 2);
pub const TC_NONCONF_BORROW_PLUS = @as(u32, 3);
pub const SESSFLG_E_Police = @as(u32, 1);
pub const Opt_Share_mask = @as(u32, 24);
pub const Opt_Distinct = @as(u32, 8);
pub const Opt_Shared = @as(u32, 16);
pub const Opt_SndSel_mask = @as(u32, 7);
pub const Opt_Wildcard = @as(u32, 1);
pub const Opt_Explicit = @as(u32, 2);
pub const ERROR_SPECF_InPlace = @as(u32, 1);
pub const ERROR_SPECF_NotGuilty = @as(u32, 2);
pub const ERR_FORWARD_OK = @as(u32, 32768);
pub const ERR_Usage_globl = @as(u32, 0);
pub const ERR_Usage_local = @as(u32, 16);
pub const ERR_Usage_serv = @as(u32, 17);
pub const ERR_global_mask = @as(u32, 4095);
pub const GENERAL_INFO = @as(u32, 1);
pub const GUARANTEED_SERV = @as(u32, 2);
pub const PREDICTIVE_SERV = @as(u32, 3);
pub const CONTROLLED_DELAY_SERV = @as(u32, 4);
pub const CONTROLLED_LOAD_SERV = @as(u32, 5);
pub const QUALITATIVE_SERV = @as(u32, 6);
pub const INTSERV_VERS_MASK = @as(u32, 240);
pub const INTSERV_VERSION0 = @as(u32, 0);
pub const ISSH_BREAK_BIT = @as(u32, 128);
pub const ISPH_FLG_INV = @as(u32, 128);
pub const RSVP_PATH = @as(u32, 1);
pub const RSVP_RESV = @as(u32, 2);
pub const RSVP_PATH_ERR = @as(u32, 3);
pub const RSVP_RESV_ERR = @as(u32, 4);
pub const RSVP_PATH_TEAR = @as(u32, 5);
pub const RSVP_RESV_TEAR = @as(u32, 6);
pub const RSVP_Err_NONE = @as(u32, 0);
pub const RSVP_Erv_Nonev = @as(u32, 0);
pub const RSVP_Err_ADMISSION = @as(u32, 1);
pub const RSVP_Erv_Other = @as(u32, 0);
pub const RSVP_Erv_DelayBnd = @as(u32, 1);
pub const RSVP_Erv_Bandwidth = @as(u32, 2);
pub const RSVP_Erv_MTU = @as(u32, 3);
pub const RSVP_Erv_Flow_Rate = @as(u32, 32769);
pub const RSVP_Erv_Bucket_szie = @as(u32, 32770);
pub const RSVP_Erv_Peak_Rate = @as(u32, 32771);
pub const RSVP_Erv_Min_Policied_size = @as(u32, 32772);
pub const RSVP_Err_POLICY = @as(u32, 2);
pub const POLICY_ERRV_NO_MORE_INFO = @as(u32, 1);
pub const POLICY_ERRV_UNSUPPORTED_CREDENTIAL_TYPE = @as(u32, 2);
pub const POLICY_ERRV_INSUFFICIENT_PRIVILEGES = @as(u32, 3);
pub const POLICY_ERRV_EXPIRED_CREDENTIALS = @as(u32, 4);
pub const POLICY_ERRV_IDENTITY_CHANGED = @as(u32, 5);
pub const POLICY_ERRV_UNKNOWN = @as(u32, 0);
pub const POLICY_ERRV_GLOBAL_DEF_FLOW_COUNT = @as(u32, 1);
pub const POLICY_ERRV_GLOBAL_GRP_FLOW_COUNT = @as(u32, 2);
pub const POLICY_ERRV_GLOBAL_USER_FLOW_COUNT = @as(u32, 3);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_COUNT = @as(u32, 4);
pub const POLICY_ERRV_SUBNET_DEF_FLOW_COUNT = @as(u32, 5);
pub const POLICY_ERRV_SUBNET_GRP_FLOW_COUNT = @as(u32, 6);
pub const POLICY_ERRV_SUBNET_USER_FLOW_COUNT = @as(u32, 7);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_COUNT = @as(u32, 8);
pub const POLICY_ERRV_GLOBAL_DEF_FLOW_DURATION = @as(u32, 9);
pub const POLICY_ERRV_GLOBAL_GRP_FLOW_DURATION = @as(u32, 10);
pub const POLICY_ERRV_GLOBAL_USER_FLOW_DURATION = @as(u32, 11);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_DURATION = @as(u32, 12);
pub const POLICY_ERRV_SUBNET_DEF_FLOW_DURATION = @as(u32, 13);
pub const POLICY_ERRV_SUBNET_GRP_FLOW_DURATION = @as(u32, 14);
pub const POLICY_ERRV_SUBNET_USER_FLOW_DURATION = @as(u32, 15);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_DURATION = @as(u32, 16);
pub const POLICY_ERRV_GLOBAL_DEF_FLOW_RATE = @as(u32, 17);
pub const POLICY_ERRV_GLOBAL_GRP_FLOW_RATE = @as(u32, 18);
pub const POLICY_ERRV_GLOBAL_USER_FLOW_RATE = @as(u32, 19);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_RATE = @as(u32, 20);
pub const POLICY_ERRV_SUBNET_DEF_FLOW_RATE = @as(u32, 21);
pub const POLICY_ERRV_SUBNET_GRP_FLOW_RATE = @as(u32, 22);
pub const POLICY_ERRV_SUBNET_USER_FLOW_RATE = @as(u32, 23);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_RATE = @as(u32, 24);
pub const POLICY_ERRV_GLOBAL_DEF_PEAK_RATE = @as(u32, 25);
pub const POLICY_ERRV_GLOBAL_GRP_PEAK_RATE = @as(u32, 26);
pub const POLICY_ERRV_GLOBAL_USER_PEAK_RATE = @as(u32, 27);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_PEAK_RATE = @as(u32, 28);
pub const POLICY_ERRV_SUBNET_DEF_PEAK_RATE = @as(u32, 29);
pub const POLICY_ERRV_SUBNET_GRP_PEAK_RATE = @as(u32, 30);
pub const POLICY_ERRV_SUBNET_USER_PEAK_RATE = @as(u32, 31);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_PEAK_RATE = @as(u32, 32);
pub const POLICY_ERRV_GLOBAL_DEF_SUM_FLOW_RATE = @as(u32, 33);
pub const POLICY_ERRV_GLOBAL_GRP_SUM_FLOW_RATE = @as(u32, 34);
pub const POLICY_ERRV_GLOBAL_USER_SUM_FLOW_RATE = @as(u32, 35);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_FLOW_RATE = @as(u32, 36);
pub const POLICY_ERRV_SUBNET_DEF_SUM_FLOW_RATE = @as(u32, 37);
pub const POLICY_ERRV_SUBNET_GRP_SUM_FLOW_RATE = @as(u32, 38);
pub const POLICY_ERRV_SUBNET_USER_SUM_FLOW_RATE = @as(u32, 39);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_FLOW_RATE = @as(u32, 40);
pub const POLICY_ERRV_GLOBAL_DEF_SUM_PEAK_RATE = @as(u32, 41);
pub const POLICY_ERRV_GLOBAL_GRP_SUM_PEAK_RATE = @as(u32, 42);
pub const POLICY_ERRV_GLOBAL_USER_SUM_PEAK_RATE = @as(u32, 43);
pub const POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_PEAK_RATE = @as(u32, 44);
pub const POLICY_ERRV_SUBNET_DEF_SUM_PEAK_RATE = @as(u32, 45);
pub const POLICY_ERRV_SUBNET_GRP_SUM_PEAK_RATE = @as(u32, 46);
pub const POLICY_ERRV_SUBNET_USER_SUM_PEAK_RATE = @as(u32, 47);
pub const POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_PEAK_RATE = @as(u32, 48);
pub const POLICY_ERRV_UNKNOWN_USER = @as(u32, 49);
pub const POLICY_ERRV_NO_PRIVILEGES = @as(u32, 50);
pub const POLICY_ERRV_EXPIRED_USER_TOKEN = @as(u32, 51);
pub const POLICY_ERRV_NO_RESOURCES = @as(u32, 52);
pub const POLICY_ERRV_PRE_EMPTED = @as(u32, 53);
pub const POLICY_ERRV_USER_CHANGED = @as(u32, 54);
pub const POLICY_ERRV_NO_ACCEPTS = @as(u32, 55);
pub const POLICY_ERRV_NO_MEMORY = @as(u32, 56);
pub const POLICY_ERRV_CRAZY_FLOWSPEC = @as(u32, 57);
pub const RSVP_Err_NO_PATH = @as(u32, 3);
pub const RSVP_Err_NO_SENDER = @as(u32, 4);
pub const RSVP_Err_BAD_STYLE = @as(u32, 5);
pub const RSVP_Err_UNKNOWN_STYLE = @as(u32, 6);
pub const RSVP_Err_BAD_DSTPORT = @as(u32, 7);
pub const RSVP_Err_BAD_SNDPORT = @as(u32, 8);
pub const RSVP_Err_AMBIG_FILTER = @as(u32, 9);
pub const RSVP_Err_PREEMPTED = @as(u32, 12);
pub const RSVP_Err_UNKN_OBJ_CLASS = @as(u32, 13);
pub const RSVP_Err_UNKNOWN_CTYPE = @as(u32, 14);
pub const RSVP_Err_API_ERROR = @as(u32, 20);
pub const RSVP_Err_TC_ERROR = @as(u32, 21);
pub const RSVP_Erv_Conflict_Serv = @as(u32, 1);
pub const RSVP_Erv_No_Serv = @as(u32, 2);
pub const RSVP_Erv_Crazy_Flowspec = @as(u32, 3);
pub const RSVP_Erv_Crazy_Tspec = @as(u32, 4);
pub const RSVP_Err_TC_SYS_ERROR = @as(u32, 22);
pub const RSVP_Err_RSVP_SYS_ERROR = @as(u32, 23);
pub const RSVP_Erv_MEMORY = @as(u32, 1);
pub const RSVP_Erv_API = @as(u32, 2);
pub const LPM_PE_USER_IDENTITY = @as(u32, 2);
pub const LPM_PE_APP_IDENTITY = @as(u32, 3);
pub const ERROR_NO_MORE_INFO = @as(u32, 1);
pub const UNSUPPORTED_CREDENTIAL_TYPE = @as(u32, 2);
pub const INSUFFICIENT_PRIVILEGES = @as(u32, 3);
pub const EXPIRED_CREDENTIAL = @as(u32, 4);
pub const IDENTITY_CHANGED = @as(u32, 5);
pub const LPM_OK = @as(u32, 0);
pub const INV_LPM_HANDLE = @as(u32, 1);
pub const LPM_TIME_OUT = @as(u32, 2);
pub const INV_REQ_HANDLE = @as(u32, 3);
pub const DUP_RESULTS = @as(u32, 4);
pub const INV_RESULTS = @as(u32, 5);
pub const LPM_PE_ALL_TYPES = @as(u32, 0);
pub const LPM_API_VERSION_1 = @as(u32, 1);
pub const PCM_VERSION_1 = @as(u32, 1);
pub const LPV_RESERVED = @as(u32, 0);
pub const LPV_MIN_PRIORITY = @as(u32, 1);
pub const LPV_MAX_PRIORITY = @as(u32, 65280);
pub const LPV_DROP_MSG = @as(u32, 65533);
pub const LPV_DONT_CARE = @as(u32, 65534);
pub const LPV_REJECT = @as(u32, 65535);
pub const FORCE_IMMEDIATE_REFRESH = @as(u32, 1);
pub const LPM_RESULT_READY = @as(u32, 0);
pub const LPM_RESULT_DEFER = @as(u32, 1);
pub const RCVD_PATH_TEAR = @as(u32, 1);
pub const RCVD_RESV_TEAR = @as(u32, 2);
pub const ADM_CTRL_FAILED = @as(u32, 3);
pub const STATE_TIMEOUT = @as(u32, 4);
pub const FLOW_DURATION = @as(u32, 5);
pub const RESOURCES_ALLOCATED = @as(u32, 1);
pub const RESOURCES_MODIFIED = @as(u32, 2);
pub const CURRENT_TCI_VERSION = @as(u32, 2);
pub const TC_NOTIFY_IFC_UP = @as(u32, 1);
pub const TC_NOTIFY_IFC_CLOSE = @as(u32, 2);
pub const TC_NOTIFY_IFC_CHANGE = @as(u32, 3);
pub const TC_NOTIFY_PARAM_CHANGED = @as(u32, 4);
pub const TC_NOTIFY_FLOW_CLOSE = @as(u32, 5);
pub const MAX_STRING_LENGTH = @as(u32, 256);
pub const QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH = @as(u32, 4294967295);
pub const QOS_QUERYFLOW_FRESH = @as(u32, 1);
pub const QOS_NON_ADAPTIVE_FLOW = @as(u32, 2);
pub const IS_GUAR_RSPEC = @as(i32, 130);
pub const GUAR_ADSPARM_C = @as(i32, 131);
pub const GUAR_ADSPARM_D = @as(i32, 132);
pub const GUAR_ADSPARM_Ctot = @as(i32, 133);
pub const GUAR_ADSPARM_Dtot = @as(i32, 134);
pub const GUAR_ADSPARM_Csum = @as(i32, 135);
pub const GUAR_ADSPARM_Dsum = @as(i32, 136);

//--------------------------------------------------------------------------------
// Section: Types (81)
//--------------------------------------------------------------------------------
pub const QOS = extern struct {
    SendingFlowspec: FLOWSPEC,
    ReceivingFlowspec: FLOWSPEC,
    ProviderSpecific: WSABUF,
};

pub const LPM_HANDLE = isize;

pub const RHANDLE = isize;

pub const FLOWSPEC = extern struct {
    TokenRate: u32,
    TokenBucketSize: u32,
    PeakBandwidth: u32,
    Latency: u32,
    DelayVariation: u32,
    ServiceType: u32,
    MaxSduSize: u32,
    MinimumPolicedSize: u32,
};

pub const QOS_OBJECT_HDR = extern struct {
    ObjectType: u32,
    ObjectLength: u32,
};

pub const QOS_SD_MODE = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    ShapeDiscardMode: u32,
};

pub const QOS_SHAPING_RATE = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    ShapingRate: u32,
};

pub const RsvpObjHdr = extern struct {
    obj_length: u16,
    obj_class: u8,
    obj_ctype: u8,
};

pub const Session_IPv4 = extern struct {
    sess_destaddr: IN_ADDR,
    sess_protid: u8,
    sess_flags: u8,
    sess_destport: u16,
};

pub const RSVP_SESSION = extern struct {
    sess_header: RsvpObjHdr,
    sess_u: _sess_u_e__Union,
    const _sess_u_e__Union = u32; // TODO: generate this nested type!
};

pub const Rsvp_Hop_IPv4 = extern struct {
    hop_ipaddr: IN_ADDR,
    hop_LIH: u32,
};

pub const RSVP_HOP = extern struct {
    hop_header: RsvpObjHdr,
    hop_u: _hop_u_e__Union,
    const _hop_u_e__Union = u32; // TODO: generate this nested type!
};

pub const RESV_STYLE = extern struct {
    style_header: RsvpObjHdr,
    style_word: u32,
};

pub const Filter_Spec_IPv4 = extern struct {
    filt_ipaddr: IN_ADDR,
    filt_unused: u16,
    filt_port: u16,
};

pub const Filter_Spec_IPv4GPI = extern struct {
    filt_ipaddr: IN_ADDR,
    filt_gpi: u32,
};

pub const FILTER_SPEC = extern struct {
    filt_header: RsvpObjHdr,
    filt_u: _filt_u_e__Union,
    const _filt_u_e__Union = u32; // TODO: generate this nested type!
};

pub const Scope_list_ipv4 = extern struct {
    scopl_ipaddr: [1]IN_ADDR,
};

pub const RSVP_SCOPE = extern struct {
    scopl_header: RsvpObjHdr,
    scope_u: _scope_u_e__Union,
    const _scope_u_e__Union = u32; // TODO: generate this nested type!
};

pub const Error_Spec_IPv4 = extern struct {
    errs_errnode: IN_ADDR,
    errs_flags: u8,
    errs_code: u8,
    errs_value: u16,
};

pub const ERROR_SPEC = extern struct {
    errs_header: RsvpObjHdr,
    errs_u: _errs_u_e__Union,
    const _errs_u_e__Union = u32; // TODO: generate this nested type!
};

pub const POLICY_DATA = extern struct {
    PolicyObjHdr: RsvpObjHdr,
    usPeOffset: u16,
    usReserved: u16,
};

pub const POLICY_ELEMENT = extern struct {
    usPeLength: u16,
    usPeType: u16,
    ucPeData: [4]u8,
};

pub const int_serv_wkp = extern enum(i32) {
    HOP_CNT = 4,
    PATH_BW = 6,
    MIN_LATENCY = 8,
    COMPOSED_MTU = 10,
    TB_TSPEC = 127,
    Q_TSPEC = 128,
};
pub const IS_WKP_HOP_CNT = int_serv_wkp.HOP_CNT;
pub const IS_WKP_PATH_BW = int_serv_wkp.PATH_BW;
pub const IS_WKP_MIN_LATENCY = int_serv_wkp.MIN_LATENCY;
pub const IS_WKP_COMPOSED_MTU = int_serv_wkp.COMPOSED_MTU;
pub const IS_WKP_TB_TSPEC = int_serv_wkp.TB_TSPEC;
pub const IS_WKP_Q_TSPEC = int_serv_wkp.Q_TSPEC;

pub const IntServMainHdr = extern struct {
    ismh_version: u8,
    ismh_unused: u8,
    ismh_len32b: u16,
};

pub const IntServServiceHdr = extern struct {
    issh_service: u8,
    issh_flags: u8,
    issh_len32b: u16,
};

pub const IntServParmHdr = extern struct {
    isph_parm_num: u8,
    isph_flags: u8,
    isph_len32b: u16,
};

pub const GenTspecParms = extern struct {
    TB_Tspec_r: f32,
    TB_Tspec_b: f32,
    TB_Tspec_p: f32,
    TB_Tspec_m: u32,
    TB_Tspec_M: u32,
};

pub const GenTspec = extern struct {
    gen_Tspec_serv_hdr: IntServServiceHdr,
    gen_Tspec_parm_hdr: IntServParmHdr,
    gen_Tspec_parms: GenTspecParms,
};

pub const QualTspecParms = extern struct {
    TB_Tspec_M: u32,
};

pub const QualTspec = extern struct {
    qual_Tspec_serv_hdr: IntServServiceHdr,
    qual_Tspec_parm_hdr: IntServParmHdr,
    qual_Tspec_parms: QualTspecParms,
};

pub const QualAppFlowSpec = extern struct {
    Q_spec_serv_hdr: IntServServiceHdr,
    Q_spec_parm_hdr: IntServParmHdr,
    Q_spec_parms: QualTspecParms,
};

pub const IntServTspecBody = extern struct {
    st_mh: IntServMainHdr,
    tspec_u: _tspec_u_e__Union,
    const _tspec_u_e__Union = u32; // TODO: generate this nested type!
};

pub const SENDER_TSPEC = extern struct {
    stspec_header: RsvpObjHdr,
    stspec_body: IntServTspecBody,
};

pub const CtrlLoadFlowspec = extern struct {
    CL_spec_serv_hdr: IntServServiceHdr,
    CL_spec_parm_hdr: IntServParmHdr,
    CL_spec_parms: GenTspecParms,
};

pub const GuarRspec = extern struct {
    Guar_R: f32,
    Guar_S: u32,
};

pub const GuarFlowSpec = extern struct {
    Guar_serv_hdr: IntServServiceHdr,
    Guar_Tspec_hdr: IntServParmHdr,
    Guar_Tspec_parms: GenTspecParms,
    Guar_Rspec_hdr: IntServParmHdr,
    Guar_Rspec: GuarRspec,
};

pub const IntServFlowSpec = extern struct {
    spec_mh: IntServMainHdr,
    spec_u: _spec_u_e__Union,
    const _spec_u_e__Union = u32; // TODO: generate this nested type!
};

pub const IS_FLOWSPEC = extern struct {
    flow_header: RsvpObjHdr,
    flow_body: IntServFlowSpec,
};

pub const flow_desc = extern struct {
    u1: _u1_e__Union,
    u2: _u2_e__Union,
    const _u1_e__Union = u32; // TODO: generate this nested type!
    const _u2_e__Union = u32; // TODO: generate this nested type!
};

pub const Gads_parms_t = extern struct {
    Gads_serv_hdr: IntServServiceHdr,
    Gads_Ctot_hdr: IntServParmHdr,
    Gads_Ctot: u32,
    Gads_Dtot_hdr: IntServParmHdr,
    Gads_Dtot: u32,
    Gads_Csum_hdr: IntServParmHdr,
    Gads_Csum: u32,
    Gads_Dsum_hdr: IntServParmHdr,
    Gads_Dsum: u32,
};

pub const GenAdspecParams = extern struct {
    gen_parm_hdr: IntServServiceHdr,
    gen_parm_hopcnt_hdr: IntServParmHdr,
    gen_parm_hopcnt: u32,
    gen_parm_pathbw_hdr: IntServParmHdr,
    gen_parm_path_bw: f32,
    gen_parm_minlat_hdr: IntServParmHdr,
    gen_parm_min_latency: u32,
    gen_parm_compmtu_hdr: IntServParmHdr,
    gen_parm_composed_MTU: u32,
};

pub const IS_ADSPEC_BODY = extern struct {
    adspec_mh: IntServMainHdr,
    adspec_genparms: GenAdspecParams,
};

pub const ADSPEC = extern struct {
    adspec_header: RsvpObjHdr,
    adspec_body: IS_ADSPEC_BODY,
};

pub const ID_ERROR_OBJECT = extern struct {
    usIdErrLength: u16,
    ucAType: u8,
    ucSubType: u8,
    usReserved: u16,
    usIdErrorValue: u16,
    ucIdErrData: [4]u8,
};

pub const RSVP_MSG_OBJS = extern struct {
    RsvpMsgType: i32,
    pRsvpSession: *RSVP_SESSION,
    pRsvpFromHop: *RSVP_HOP,
    pRsvpToHop: *RSVP_HOP,
    pResvStyle: *RESV_STYLE,
    pRsvpScope: *RSVP_SCOPE,
    FlowDescCount: i32,
    pFlowDescs: *flow_desc,
    PdObjectCount: i32,
    ppPdObjects: **POLICY_DATA,
    pErrorSpec: *ERROR_SPEC,
    pAdspec: *ADSPEC,
};

pub const PALLOCMEM = fn(
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFREEMEM = fn(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const policy_decision = extern struct {
    lpvResult: u32,
    wPolicyErrCode: u16,
    wPolicyErrValue: u16,
};

pub const CBADMITRESULT = fn(
    LpmHandle: LPM_HANDLE,
    RequestHandle: RHANDLE,
    ulPcmActionFlags: u32,
    LpmError: i32,
    PolicyDecisionsCount: i32,
    pPolicyDecisions: *policy_decision,
) callconv(@import("std").os.windows.WINAPI) *u32;

pub const CBGETRSVPOBJECTS = fn(
    LpmHandle: LPM_HANDLE,
    RequestHandle: RHANDLE,
    LpmError: i32,
    RsvpObjectsCount: i32,
    ppRsvpObjects: **RsvpObjHdr,
) callconv(@import("std").os.windows.WINAPI) *u32;

pub const LPM_INIT_INFO = extern struct {
    PcmVersionNumber: u32,
    ResultTimeLimit: u32,
    ConfiguredLpmCount: i32,
    AllocMemory: PALLOCMEM,
    FreeMemory: PFREEMEM,
    PcmAdmitResultCallback: CBADMITRESULT,
    GetRsvpObjectsCallback: CBGETRSVPOBJECTS,
};

pub const lpmiptable = extern struct {
    ulIfIndex: u32,
    MediaType: u32,
    IfIpAddr: IN_ADDR,
    IfNetMask: IN_ADDR,
};

pub const QOS_TRAFFIC_TYPE = extern enum(i32) {
    BestEffort = 0,
    Background = 1,
    ExcellentEffort = 2,
    AudioVideo = 3,
    Voice = 4,
    Control = 5,
};
pub const QOSTrafficTypeBestEffort = QOS_TRAFFIC_TYPE.BestEffort;
pub const QOSTrafficTypeBackground = QOS_TRAFFIC_TYPE.Background;
pub const QOSTrafficTypeExcellentEffort = QOS_TRAFFIC_TYPE.ExcellentEffort;
pub const QOSTrafficTypeAudioVideo = QOS_TRAFFIC_TYPE.AudioVideo;
pub const QOSTrafficTypeVoice = QOS_TRAFFIC_TYPE.Voice;
pub const QOSTrafficTypeControl = QOS_TRAFFIC_TYPE.Control;

pub const QOS_SET_FLOW = extern enum(i32) {
    TrafficType = 0,
    OutgoingRate = 1,
    OutgoingDSCPValue = 2,
};
pub const QOSSetTrafficType = QOS_SET_FLOW.TrafficType;
pub const QOSSetOutgoingRate = QOS_SET_FLOW.OutgoingRate;
pub const QOSSetOutgoingDSCPValue = QOS_SET_FLOW.OutgoingDSCPValue;

pub const QOS_PACKET_PRIORITY = extern struct {
    ConformantDSCPValue: u32,
    NonConformantDSCPValue: u32,
    ConformantL2Value: u32,
    NonConformantL2Value: u32,
};

pub const QOS_FLOW_FUNDAMENTALS = extern struct {
    BottleneckBandwidthSet: BOOL,
    BottleneckBandwidth: u64,
    AvailableBandwidthSet: BOOL,
    AvailableBandwidth: u64,
    RTTSet: BOOL,
    RTT: u32,
};

pub const QOS_FLOWRATE_REASON = extern enum(i32) {
    NotApplicable = 0,
    ContentChange = 1,
    Congestion = 2,
    HigherContentEncoding = 3,
    UserCaused = 4,
};
pub const QOSFlowRateNotApplicable = QOS_FLOWRATE_REASON.NotApplicable;
pub const QOSFlowRateContentChange = QOS_FLOWRATE_REASON.ContentChange;
pub const QOSFlowRateCongestion = QOS_FLOWRATE_REASON.Congestion;
pub const QOSFlowRateHigherContentEncoding = QOS_FLOWRATE_REASON.HigherContentEncoding;
pub const QOSFlowRateUserCaused = QOS_FLOWRATE_REASON.UserCaused;

pub const QOS_SHAPING = extern enum(i32) {
    ShapeOnly = 0,
    ShapeAndMark = 1,
    UseNonConformantMarkings = 2,
};
pub const QOSShapeOnly = QOS_SHAPING.ShapeOnly;
pub const QOSShapeAndMark = QOS_SHAPING.ShapeAndMark;
pub const QOSUseNonConformantMarkings = QOS_SHAPING.UseNonConformantMarkings;

pub const QOS_FLOWRATE_OUTGOING = extern struct {
    Bandwidth: u64,
    ShapingBehavior: QOS_SHAPING,
    Reason: QOS_FLOWRATE_REASON,
};

pub const QOS_QUERY_FLOW = extern enum(i32) {
    FlowFundamentals = 0,
    PacketPriority = 1,
    OutgoingRate = 2,
};
pub const QOSQueryFlowFundamentals = QOS_QUERY_FLOW.FlowFundamentals;
pub const QOSQueryPacketPriority = QOS_QUERY_FLOW.PacketPriority;
pub const QOSQueryOutgoingRate = QOS_QUERY_FLOW.OutgoingRate;

pub const QOS_NOTIFY_FLOW = extern enum(i32) {
    Congested = 0,
    Uncongested = 1,
    Available = 2,
};
pub const QOSNotifyCongested = QOS_NOTIFY_FLOW.Congested;
pub const QOSNotifyUncongested = QOS_NOTIFY_FLOW.Uncongested;
pub const QOSNotifyAvailable = QOS_NOTIFY_FLOW.Available;

pub const QOS_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const QOS_FRIENDLY_NAME = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    FriendlyName: [256]u16,
};

pub const QOS_TRAFFIC_CLASS = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    TrafficClass: u32,
};

pub const QOS_DS_CLASS = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    DSField: u32,
};

pub const QOS_DIFFSERV = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
    DSFieldCount: u32,
    DiffservRule: [1]u8,
};

pub const QOS_DIFFSERV_RULE = extern struct {
    InboundDSField: u8,
    ConformingOutboundDSField: u8,
    NonConformingOutboundDSField: u8,
    ConformingUserPriority: u8,
    NonConformingUserPriority: u8,
};

pub const QOS_TCP_TRAFFIC = extern struct {
    ObjectHdr: QOS_OBJECT_HDR,
};

pub const TCI_NOTIFY_HANDLER = fn(
    ClRegCtx: HANDLE,
    ClIfcCtx: HANDLE,
    Event: u32,
    SubCode: HANDLE,
    BufSize: u32,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TCI_ADD_FLOW_COMPLETE_HANDLER = fn(
    ClFlowCtx: HANDLE,
    Status: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TCI_MOD_FLOW_COMPLETE_HANDLER = fn(
    ClFlowCtx: HANDLE,
    Status: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TCI_DEL_FLOW_COMPLETE_HANDLER = fn(
    ClFlowCtx: HANDLE,
    Status: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TCI_CLIENT_FUNC_LIST = extern struct {
    ClNotifyHandler: TCI_NOTIFY_HANDLER,
    ClAddFlowCompleteHandler: TCI_ADD_FLOW_COMPLETE_HANDLER,
    ClModifyFlowCompleteHandler: TCI_MOD_FLOW_COMPLETE_HANDLER,
    ClDeleteFlowCompleteHandler: TCI_DEL_FLOW_COMPLETE_HANDLER,
};

pub const ADDRESS_LIST_DESCRIPTOR = extern struct {
    MediaType: u32,
    AddressList: NETWORK_ADDRESS_LIST,
};

pub const TC_IFC_DESCRIPTOR = extern struct {
    Length: u32,
    pInterfaceName: PWSTR,
    pInterfaceID: PWSTR,
    AddressListDesc: ADDRESS_LIST_DESCRIPTOR,
};

pub const TC_SUPPORTED_INFO_BUFFER = extern struct {
    InstanceIDLength: u16,
    InstanceID: [256]u16,
    InterfaceLuid: u64,
    AddrListDesc: ADDRESS_LIST_DESCRIPTOR,
};

pub const TC_GEN_FILTER = extern struct {
    AddressType: u16,
    PatternSize: u32,
    Pattern: *c_void,
    Mask: *c_void,
};

pub const TC_GEN_FLOW = extern struct {
    SendingFlowspec: FLOWSPEC,
    ReceivingFlowspec: FLOWSPEC,
    TcObjectsLength: u32,
    TcObjects: [1]QOS_OBJECT_HDR,
};

pub const IP_PATTERN = extern struct {
    Reserved1: u32,
    Reserved2: u32,
    SrcAddr: u32,
    DstAddr: u32,
    S_un: _S_un_e__Union,
    ProtocolId: u8,
    Reserved3: [3]u8,
    const _S_un_e__Union = u32; // TODO: generate this nested type!
};

pub const IPX_PATTERN = extern struct {
    Src: _Src_e__Struct,
    Dest: _Src_e__Struct,
    const _Src_e__Struct = u32; // TODO: generate this nested type!
};

pub const ENUMERATION_BUFFER = extern struct {
    Length: u32,
    OwnerProcessId: u32,
    FlowNameLength: u16,
    FlowName: [256]u16,
    pFlow: *TC_GEN_FLOW,
    NumberOfFilters: u32,
    GenericFilter: [1]TC_GEN_FILTER,
};


//--------------------------------------------------------------------------------
// Section: Functions (31)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSCreateHandle(
    Version: *QOS_VERSION,
    QOSHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSCloseHandle(
    QOSHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSStartTrackingClient(
    QOSHandle: HANDLE,
    DestAddr: *SOCKADDR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSStopTrackingClient(
    QOSHandle: HANDLE,
    DestAddr: *SOCKADDR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSEnumerateFlows(
    QOSHandle: HANDLE,
    Size: *u32,
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSAddSocketToFlow(
    QOSHandle: HANDLE,
    Socket: usize,
    DestAddr: ?*SOCKADDR,
    TrafficType: QOS_TRAFFIC_TYPE,
    Flags: u32,
    FlowId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSRemoveSocketFromFlow(
    QOSHandle: HANDLE,
    Socket: usize,
    FlowId: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSSetFlow(
    QOSHandle: HANDLE,
    FlowId: u32,
    Operation: QOS_SET_FLOW,
    Size: u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *c_void,
    Flags: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSQueryFlow(
    QOSHandle: HANDLE,
    FlowId: u32,
    Operation: QOS_QUERY_FLOW,
    Size: *u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *c_void,
    Flags: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSNotifyFlow(
    QOSHandle: HANDLE,
    FlowId: u32,
    Operation: QOS_NOTIFY_FLOW,
    Size: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    Flags: u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "qwave" fn QOSCancel(
    QOSHandle: HANDLE,
    Overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcRegisterClient(
    TciVersion: u32,
    ClRegCtx: HANDLE,
    ClientHandlerList: *TCI_CLIENT_FUNC_LIST,
    pClientHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcEnumerateInterfaces(
    ClientHandle: HANDLE,
    pBufferSize: *u32,
    InterfaceBuffer: *TC_IFC_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcOpenInterfaceA(
    pInterfaceName: PSTR,
    ClientHandle: HANDLE,
    ClIfcCtx: HANDLE,
    pIfcHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcOpenInterfaceW(
    pInterfaceName: PWSTR,
    ClientHandle: HANDLE,
    ClIfcCtx: HANDLE,
    pIfcHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcCloseInterface(
    IfcHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcQueryInterface(
    IfcHandle: HANDLE,
    pGuidParam: *Guid,
    NotifyChange: u8,
    pBufferSize: *u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcSetInterface(
    IfcHandle: HANDLE,
    pGuidParam: *Guid,
    BufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcQueryFlowA(
    pFlowName: PSTR,
    pGuidParam: *Guid,
    pBufferSize: *u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcQueryFlowW(
    pFlowName: PWSTR,
    pGuidParam: *Guid,
    pBufferSize: *u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcSetFlowA(
    pFlowName: PSTR,
    pGuidParam: *Guid,
    BufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcSetFlowW(
    pFlowName: PWSTR,
    pGuidParam: *Guid,
    BufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcAddFlow(
    IfcHandle: HANDLE,
    ClFlowCtx: HANDLE,
    Flags: u32,
    pGenericFlow: *TC_GEN_FLOW,
    pFlowHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcGetFlowNameA(
    FlowHandle: HANDLE,
    StrSize: u32,
    pFlowName: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcGetFlowNameW(
    FlowHandle: HANDLE,
    StrSize: u32,
    pFlowName: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcModifyFlow(
    FlowHandle: HANDLE,
    pGenericFlow: *TC_GEN_FLOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcAddFilter(
    FlowHandle: HANDLE,
    pGenericFilter: *TC_GEN_FILTER,
    pFilterHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcDeregisterClient(
    ClientHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcDeleteFlow(
    FlowHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcDeleteFilter(
    FilterHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "TRAFFIC" fn TcEnumerateFlows(
    IfcHandle: HANDLE,
    pEnumHandle: *HANDLE,
    pFlowCount: *u32,
    pBufSize: *u32,
    Buffer: *ENUMERATION_BUFFER,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (4)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const TcOpenInterface = TcOpenInterfaceA;
        pub const TcQueryFlow = TcQueryFlowA;
        pub const TcSetFlow = TcSetFlowA;
        pub const TcGetFlowName = TcGetFlowNameA;
    },
    .wide => struct {
        pub const TcOpenInterface = TcOpenInterfaceW;
        pub const TcQueryFlow = TcQueryFlowW;
        pub const TcSetFlow = TcSetFlowW;
        pub const TcGetFlowName = TcGetFlowNameW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const TcOpenInterface = *opaque{};
        pub const TcQueryFlow = *opaque{};
        pub const TcSetFlow = *opaque{};
        pub const TcGetFlowName = *opaque{};
    } else struct {
        pub const TcOpenInterface = @compileError("'TcOpenInterface' requires that UNICODE be set to true or false in the root module");
        pub const TcQueryFlow = @compileError("'TcQueryFlow' requires that UNICODE be set to true or false in the root module");
        pub const TcSetFlow = @compileError("'TcSetFlow' requires that UNICODE be set to true or false in the root module");
        pub const TcGetFlowName = @compileError("'TcGetFlowName' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (10)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const PWSTR = @import("system_services.zig").PWSTR;
const NETWORK_ADDRESS_LIST = @import("native_wi_fi.zig").NETWORK_ADDRESS_LIST;
const WSABUF = @import("win_sock.zig").WSABUF;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const IN_ADDR = @import("ip_helper.zig").IN_ADDR;
const HANDLE = @import("system_services.zig").HANDLE;
const PSTR = @import("system_services.zig").PSTR;
const BOOL = @import("system_services.zig").BOOL;
const SOCKADDR = @import("win_sock.zig").SOCKADDR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PALLOCMEM")) { _ = PALLOCMEM; }
    if (@hasDecl(@This(), "PFREEMEM")) { _ = PFREEMEM; }
    if (@hasDecl(@This(), "CBADMITRESULT")) { _ = CBADMITRESULT; }
    if (@hasDecl(@This(), "CBGETRSVPOBJECTS")) { _ = CBGETRSVPOBJECTS; }
    if (@hasDecl(@This(), "TCI_NOTIFY_HANDLER")) { _ = TCI_NOTIFY_HANDLER; }
    if (@hasDecl(@This(), "TCI_ADD_FLOW_COMPLETE_HANDLER")) { _ = TCI_ADD_FLOW_COMPLETE_HANDLER; }
    if (@hasDecl(@This(), "TCI_MOD_FLOW_COMPLETE_HANDLER")) { _ = TCI_MOD_FLOW_COMPLETE_HANDLER; }
    if (@hasDecl(@This(), "TCI_DEL_FLOW_COMPLETE_HANDLER")) { _ = TCI_DEL_FLOW_COMPLETE_HANDLER; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
