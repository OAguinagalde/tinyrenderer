//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (6)
//--------------------------------------------------------------------------------
const IID_IProtectionPolicyManagerInterop_Value = @import("../zig.zig").Guid.initString("4652651d-c1fe-4ba1-9f0a-c0f56596f721");
pub const IID_IProtectionPolicyManagerInterop = &IID_IProtectionPolicyManagerInterop_Value;
pub const IProtectionPolicyManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestAccessForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            targetIdentity: HSTRING,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForWindow: fn(
            self: *const IProtectionPolicyManagerInterop,
            appWindow: HWND,
            riid: *const Guid,
            result: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop_RequestAccessForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, targetIdentity: HSTRING, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop.VTable, self.vtable).RequestAccessForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop, self), appWindow, sourceIdentity, targetIdentity, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop_GetForWindow(self: *const T, appWindow: HWND, riid: *const Guid, result: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IProtectionPolicyManagerInterop, self), appWindow, riid, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectionPolicyManagerInterop2_Value = @import("../zig.zig").Guid.initString("157cfbe4-a78d-4156-b384-61fdac41e686");
pub const IID_IProtectionPolicyManagerInterop2 = &IID_IProtectionPolicyManagerInterop2_Value;
pub const IProtectionPolicyManagerInterop2 = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestAccessForAppWithWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop2,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            appPackageFamilyName: HSTRING,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessWithAuditingInfoForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop2,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            targetIdentity: HSTRING,
            auditInfoUnk: *IUnknown,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessWithMessageForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop2,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            targetIdentity: HSTRING,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessForAppWithAuditingInfoForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop2,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            appPackageFamilyName: HSTRING,
            auditInfoUnk: *IUnknown,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessForAppWithMessageForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop2,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            appPackageFamilyName: HSTRING,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop2_RequestAccessForAppWithWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, appPackageFamilyName: HSTRING, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop2.VTable, self.vtable).RequestAccessForAppWithWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop2, self), appWindow, sourceIdentity, appPackageFamilyName, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop2_RequestAccessWithAuditingInfoForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, targetIdentity: HSTRING, auditInfoUnk: *IUnknown, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop2.VTable, self.vtable).RequestAccessWithAuditingInfoForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop2, self), appWindow, sourceIdentity, targetIdentity, auditInfoUnk, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop2_RequestAccessWithMessageForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, targetIdentity: HSTRING, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop2.VTable, self.vtable).RequestAccessWithMessageForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop2, self), appWindow, sourceIdentity, targetIdentity, auditInfoUnk, messageFromApp, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop2_RequestAccessForAppWithAuditingInfoForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, appPackageFamilyName: HSTRING, auditInfoUnk: *IUnknown, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop2.VTable, self.vtable).RequestAccessForAppWithAuditingInfoForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop2, self), appWindow, sourceIdentity, appPackageFamilyName, auditInfoUnk, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop2_RequestAccessForAppWithMessageForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, appPackageFamilyName: HSTRING, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop2.VTable, self.vtable).RequestAccessForAppWithMessageForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop2, self), appWindow, sourceIdentity, appPackageFamilyName, auditInfoUnk, messageFromApp, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtectionPolicyManagerInterop3_Value = @import("../zig.zig").Guid.initString("c1c03933-b398-4d93-b0fd-2972adf802c2");
pub const IID_IProtectionPolicyManagerInterop3 = &IID_IProtectionPolicyManagerInterop3_Value;
pub const IProtectionPolicyManagerInterop3 = extern struct {
    pub const VTable = extern struct {
        base: IInspectable.VTable,
        RequestAccessWithBehaviorForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            targetIdentity: HSTRING,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            behavior: u32,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessForAppWithBehaviorForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceIdentity: HSTRING,
            appPackageFamilyName: HSTRING,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            behavior: u32,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessToFilesForAppForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceItemListUnk: *IUnknown,
            appPackageFamilyName: HSTRING,
            auditInfoUnk: *IUnknown,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessToFilesForAppWithMessageAndBehaviorForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceItemListUnk: *IUnknown,
            appPackageFamilyName: HSTRING,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            behavior: u32,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessToFilesForProcessForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceItemListUnk: *IUnknown,
            processId: u32,
            auditInfoUnk: *IUnknown,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccessToFilesForProcessWithMessageAndBehaviorForWindowAsync: fn(
            self: *const IProtectionPolicyManagerInterop3,
            appWindow: HWND,
            sourceItemListUnk: *IUnknown,
            processId: u32,
            auditInfoUnk: *IUnknown,
            messageFromApp: HSTRING,
            behavior: u32,
            riid: *const Guid,
            asyncOperation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInspectable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessWithBehaviorForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, targetIdentity: HSTRING, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, behavior: u32, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessWithBehaviorForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceIdentity, targetIdentity, auditInfoUnk, messageFromApp, behavior, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessForAppWithBehaviorForWindowAsync(self: *const T, appWindow: HWND, sourceIdentity: HSTRING, appPackageFamilyName: HSTRING, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, behavior: u32, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessForAppWithBehaviorForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceIdentity, appPackageFamilyName, auditInfoUnk, messageFromApp, behavior, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessToFilesForAppForWindowAsync(self: *const T, appWindow: HWND, sourceItemListUnk: *IUnknown, appPackageFamilyName: HSTRING, auditInfoUnk: *IUnknown, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessToFilesForAppForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceItemListUnk, appPackageFamilyName, auditInfoUnk, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessToFilesForAppWithMessageAndBehaviorForWindowAsync(self: *const T, appWindow: HWND, sourceItemListUnk: *IUnknown, appPackageFamilyName: HSTRING, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, behavior: u32, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessToFilesForAppWithMessageAndBehaviorForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceItemListUnk, appPackageFamilyName, auditInfoUnk, messageFromApp, behavior, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessToFilesForProcessForWindowAsync(self: *const T, appWindow: HWND, sourceItemListUnk: *IUnknown, processId: u32, auditInfoUnk: *IUnknown, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessToFilesForProcessForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceItemListUnk, processId, auditInfoUnk, riid, asyncOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtectionPolicyManagerInterop3_RequestAccessToFilesForProcessWithMessageAndBehaviorForWindowAsync(self: *const T, appWindow: HWND, sourceItemListUnk: *IUnknown, processId: u32, auditInfoUnk: *IUnknown, messageFromApp: HSTRING, behavior: u32, riid: *const Guid, asyncOperation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtectionPolicyManagerInterop3.VTable, self.vtable).RequestAccessToFilesForProcessWithMessageAndBehaviorForWindowAsync(@ptrCast(*const IProtectionPolicyManagerInterop3, self), appWindow, sourceItemListUnk, processId, auditInfoUnk, messageFromApp, behavior, riid, asyncOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HTHREAD_NETWORK_CONTEXT = extern struct {
    ThreadId: u32,
    ThreadContext: HANDLE,
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ENTERPRISE_DATA_POLICIES = extern enum(u32) {
    NONE = 0,
    ALLOWED = 1,
    ENLIGHTENED = 2,
    EXEMPT = 4,
    _,
};
pub const ENTERPRISE_POLICY_NONE = ENTERPRISE_DATA_POLICIES.NONE;
pub const ENTERPRISE_POLICY_ALLOWED = ENTERPRISE_DATA_POLICIES.ALLOWED;
pub const ENTERPRISE_POLICY_ENLIGHTENED = ENTERPRISE_DATA_POLICIES.ENLIGHTENED;
pub const ENTERPRISE_POLICY_EXEMPT = ENTERPRISE_DATA_POLICIES.EXEMPT;

pub const FILE_UNPROTECT_OPTIONS = extern struct {
    audit: bool,
};


//--------------------------------------------------------------------------------
// Section: Functions (11)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpCreateThreadNetworkContext(
    enterpriseId: [*:0]const u16,
    threadNetworkContext: *HTHREAD_NETWORK_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpCloseThreadNetworkContext(
    threadNetworkContext: *HTHREAD_NETWORK_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpSetTokenEnterpriseId(
    tokenHandle: HANDLE,
    enterpriseId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpGetEnterpriseIds(
    tokenHandle: HANDLE,
    numberOfBytes: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    enterpriseIds: ?*?PWSTR,
    enterpriseIdCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpEnablePermissiveModeFileEncryption(
    enterpriseId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpDisablePermissiveModeFileEncryption(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpGetEnterprisePolicy(
    tokenHandle: HANDLE,
    policyFlags: *ENTERPRISE_DATA_POLICIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpIsTokenService(
    TokenHandle: HANDLE,
    IsTokenService: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "srpapi" fn SrpDoesPolicyAllowAppExecution(
    packageId: *const PACKAGE_ID,
    isAllowed: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "efswrt" fn ProtectFileToEnterpriseIdentity(
    fileOrFolderPath: [*:0]const u16,
    identity: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "efswrt" fn UnprotectFile(
    fileOrFolderPath: [*:0]const u16,
    options: ?*const FILE_UNPROTECT_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const NTSTATUS = @import("system_services.zig").NTSTATUS;
const HSTRING = @import("win_rt.zig").HSTRING;
const PWSTR = @import("system_services.zig").PWSTR;
const PACKAGE_ID = @import("appx_packaging.zig").PACKAGE_ID;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const HANDLE = @import("system_services.zig").HANDLE;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const IInspectable = @import("win_rt.zig").IInspectable;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
