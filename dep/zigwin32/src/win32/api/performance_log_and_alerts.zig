//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (7)
//--------------------------------------------------------------------------------
pub const PLA_CAPABILITY_LOCAL = @as(u32, 268435456);
pub const PLA_CAPABILITY_V1_SVC = @as(u32, 1);
pub const PLA_CAPABILITY_V1_SESSION = @as(u32, 2);
pub const PLA_CAPABILITY_V1_SYSTEM = @as(u32, 4);
pub const PLA_CAPABILITY_LEGACY_SESSION = @as(u32, 8);
pub const PLA_CAPABILITY_LEGACY_SVC = @as(u32, 16);
pub const PLA_CAPABILITY_AUTOLOGGER = @as(u32, 32);

//--------------------------------------------------------------------------------
// Section: Types (47)
//--------------------------------------------------------------------------------
const CLSID_DataCollectorSet_Value = @import("../zig.zig").Guid.initString("03837521-098b-11d8-9414-505054503030");
pub const CLSID_DataCollectorSet = &CLSID_DataCollectorSet_Value;

const CLSID_TraceSession_Value = @import("../zig.zig").Guid.initString("0383751c-098b-11d8-9414-505054503030");
pub const CLSID_TraceSession = &CLSID_TraceSession_Value;

const CLSID_TraceSessionCollection_Value = @import("../zig.zig").Guid.initString("03837530-098b-11d8-9414-505054503030");
pub const CLSID_TraceSessionCollection = &CLSID_TraceSessionCollection_Value;

const CLSID_TraceDataProvider_Value = @import("../zig.zig").Guid.initString("03837513-098b-11d8-9414-505054503030");
pub const CLSID_TraceDataProvider = &CLSID_TraceDataProvider_Value;

const CLSID_TraceDataProviderCollection_Value = @import("../zig.zig").Guid.initString("03837511-098b-11d8-9414-505054503030");
pub const CLSID_TraceDataProviderCollection = &CLSID_TraceDataProviderCollection_Value;

const CLSID_DataCollectorSetCollection_Value = @import("../zig.zig").Guid.initString("03837525-098b-11d8-9414-505054503030");
pub const CLSID_DataCollectorSetCollection = &CLSID_DataCollectorSetCollection_Value;

const CLSID_LegacyDataCollectorSet_Value = @import("../zig.zig").Guid.initString("03837526-098b-11d8-9414-505054503030");
pub const CLSID_LegacyDataCollectorSet = &CLSID_LegacyDataCollectorSet_Value;

const CLSID_LegacyDataCollectorSetCollection_Value = @import("../zig.zig").Guid.initString("03837527-098b-11d8-9414-505054503030");
pub const CLSID_LegacyDataCollectorSetCollection = &CLSID_LegacyDataCollectorSetCollection_Value;

const CLSID_LegacyTraceSession_Value = @import("../zig.zig").Guid.initString("03837528-098b-11d8-9414-505054503030");
pub const CLSID_LegacyTraceSession = &CLSID_LegacyTraceSession_Value;

const CLSID_LegacyTraceSessionCollection_Value = @import("../zig.zig").Guid.initString("03837529-098b-11d8-9414-505054503030");
pub const CLSID_LegacyTraceSessionCollection = &CLSID_LegacyTraceSessionCollection_Value;

const CLSID_ServerDataCollectorSet_Value = @import("../zig.zig").Guid.initString("03837531-098b-11d8-9414-505054503030");
pub const CLSID_ServerDataCollectorSet = &CLSID_ServerDataCollectorSet_Value;

const CLSID_ServerDataCollectorSetCollection_Value = @import("../zig.zig").Guid.initString("03837532-098b-11d8-9414-505054503030");
pub const CLSID_ServerDataCollectorSetCollection = &CLSID_ServerDataCollectorSetCollection_Value;

const CLSID_SystemDataCollectorSet_Value = @import("../zig.zig").Guid.initString("03837546-098b-11d8-9414-505054503030");
pub const CLSID_SystemDataCollectorSet = &CLSID_SystemDataCollectorSet_Value;

const CLSID_SystemDataCollectorSetCollection_Value = @import("../zig.zig").Guid.initString("03837547-098b-11d8-9414-505054503030");
pub const CLSID_SystemDataCollectorSetCollection = &CLSID_SystemDataCollectorSetCollection_Value;

const CLSID_BootTraceSession_Value = @import("../zig.zig").Guid.initString("03837538-098b-11d8-9414-505054503030");
pub const CLSID_BootTraceSession = &CLSID_BootTraceSession_Value;

const CLSID_BootTraceSessionCollection_Value = @import("../zig.zig").Guid.initString("03837539-098b-11d8-9414-505054503030");
pub const CLSID_BootTraceSessionCollection = &CLSID_BootTraceSessionCollection_Value;

pub const DataCollectorType = extern enum(i32) {
    PerformanceCounter = 0,
    Trace = 1,
    Configuration = 2,
    Alert = 3,
    ApiTrace = 4,
};
pub const plaPerformanceCounter = DataCollectorType.PerformanceCounter;
pub const plaTrace = DataCollectorType.Trace;
pub const plaConfiguration = DataCollectorType.Configuration;
pub const plaAlert = DataCollectorType.Alert;
pub const plaApiTrace = DataCollectorType.ApiTrace;

pub const FileFormat = extern enum(i32) {
    CommaSeparated = 0,
    TabSeparated = 1,
    Sql = 2,
    Binary = 3,
};
pub const plaCommaSeparated = FileFormat.CommaSeparated;
pub const plaTabSeparated = FileFormat.TabSeparated;
pub const plaSql = FileFormat.Sql;
pub const plaBinary = FileFormat.Binary;

pub const AutoPathFormat = extern enum(i32) {
    None = 0,
    Pattern = 1,
    Computer = 2,
    MonthDayHour = 256,
    SerialNumber = 512,
    YearDayOfYear = 1024,
    YearMonth = 2048,
    YearMonthDay = 4096,
    YearMonthDayHour = 8192,
    MonthDayHourMinute = 16384,
};
pub const plaNone = AutoPathFormat.None;
pub const plaPattern = AutoPathFormat.Pattern;
pub const plaComputer = AutoPathFormat.Computer;
pub const plaMonthDayHour = AutoPathFormat.MonthDayHour;
pub const plaSerialNumber = AutoPathFormat.SerialNumber;
pub const plaYearDayOfYear = AutoPathFormat.YearDayOfYear;
pub const plaYearMonth = AutoPathFormat.YearMonth;
pub const plaYearMonthDay = AutoPathFormat.YearMonthDay;
pub const plaYearMonthDayHour = AutoPathFormat.YearMonthDayHour;
pub const plaMonthDayHourMinute = AutoPathFormat.MonthDayHourMinute;

pub const DataCollectorSetStatus = extern enum(i32) {
    Stopped = 0,
    Running = 1,
    Compiling = 2,
    Pending = 3,
    Undefined = 4,
};
pub const plaStopped = DataCollectorSetStatus.Stopped;
pub const plaRunning = DataCollectorSetStatus.Running;
pub const plaCompiling = DataCollectorSetStatus.Compiling;
pub const plaPending = DataCollectorSetStatus.Pending;
pub const plaUndefined = DataCollectorSetStatus.Undefined;

pub const ClockType = extern enum(i32) {
    TimeStamp = 0,
    Performance = 1,
    System = 2,
    Cycle = 3,
};
pub const plaTimeStamp = ClockType.TimeStamp;
pub const plaPerformance = ClockType.Performance;
pub const plaSystem = ClockType.System;
pub const plaCycle = ClockType.Cycle;

pub const StreamMode = extern enum(i32) {
    File = 1,
    RealTime = 2,
    Both = 3,
    Buffering = 4,
};
pub const plaFile = StreamMode.File;
pub const plaRealTime = StreamMode.RealTime;
pub const plaBoth = StreamMode.Both;
pub const plaBuffering = StreamMode.Buffering;

pub const CommitMode = extern enum(i32) {
    CreateNew = 1,
    Modify = 2,
    CreateOrModify = 3,
    UpdateRunningInstance = 16,
    FlushTrace = 32,
    ValidateOnly = 4096,
};
pub const plaCreateNew = CommitMode.CreateNew;
pub const plaModify = CommitMode.Modify;
pub const plaCreateOrModify = CommitMode.CreateOrModify;
pub const plaUpdateRunningInstance = CommitMode.UpdateRunningInstance;
pub const plaFlushTrace = CommitMode.FlushTrace;
pub const plaValidateOnly = CommitMode.ValidateOnly;

pub const ValueMapType = extern enum(i32) {
    Index = 1,
    Flag = 2,
    FlagArray = 3,
    Validation = 4,
};
pub const plaIndex = ValueMapType.Index;
pub const plaFlag = ValueMapType.Flag;
pub const plaFlagArray = ValueMapType.FlagArray;
pub const plaValidation = ValueMapType.Validation;

pub const WeekDays = extern enum(i32) {
    RunOnce = 0,
    Sunday = 1,
    Monday = 2,
    Tuesday = 4,
    Wednesday = 8,
    Thursday = 16,
    Friday = 32,
    Saturday = 64,
    Everyday = 127,
};
pub const plaRunOnce = WeekDays.RunOnce;
pub const plaSunday = WeekDays.Sunday;
pub const plaMonday = WeekDays.Monday;
pub const plaTuesday = WeekDays.Tuesday;
pub const plaWednesday = WeekDays.Wednesday;
pub const plaThursday = WeekDays.Thursday;
pub const plaFriday = WeekDays.Friday;
pub const plaSaturday = WeekDays.Saturday;
pub const plaEveryday = WeekDays.Everyday;

pub const ResourcePolicy = extern enum(i32) {
    Largest = 0,
    Oldest = 1,
};
pub const plaDeleteLargest = ResourcePolicy.Largest;
pub const plaDeleteOldest = ResourcePolicy.Oldest;

pub const DataManagerSteps = extern enum(i32) {
    CreateReport = 1,
    RunRules = 2,
    CreateHtml = 4,
    FolderActions = 8,
    ResourceFreeing = 16,
};
pub const plaCreateReport = DataManagerSteps.CreateReport;
pub const plaRunRules = DataManagerSteps.RunRules;
pub const plaCreateHtml = DataManagerSteps.CreateHtml;
pub const plaFolderActions = DataManagerSteps.FolderActions;
pub const plaResourceFreeing = DataManagerSteps.ResourceFreeing;

pub const FolderActionSteps = extern enum(i32) {
    CreateCab = 1,
    DeleteData = 2,
    SendCab = 4,
    DeleteCab = 8,
    DeleteReport = 16,
};
pub const plaCreateCab = FolderActionSteps.CreateCab;
pub const plaDeleteData = FolderActionSteps.DeleteData;
pub const plaSendCab = FolderActionSteps.SendCab;
pub const plaDeleteCab = FolderActionSteps.DeleteCab;
pub const plaDeleteReport = FolderActionSteps.DeleteReport;

pub const PLA_CABEXTRACT_CALLBACK = fn(
    FileName: [*:0]const u16,
    Context: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDataCollectorSet_Value = @import("../zig.zig").Guid.initString("03837520-098b-11d8-9414-505054503030");
pub const IID_IDataCollectorSet = &IID_IDataCollectorSet_Value;
pub const IDataCollectorSet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataCollectors: fn(
            self: *const IDataCollectorSet,
            collectors: ?*?*IDataCollectorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: fn(
            self: *const IDataCollectorSet,
            seconds: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Duration: fn(
            self: *const IDataCollectorSet,
            seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IDataCollectorSet,
            description: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IDataCollectorSet,
            description: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DescriptionUnresolved: fn(
            self: *const IDataCollectorSet,
            Descr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const IDataCollectorSet,
            DisplayName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: fn(
            self: *const IDataCollectorSet,
            DisplayName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayNameUnresolved: fn(
            self: *const IDataCollectorSet,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Keywords: fn(
            self: *const IDataCollectorSet,
            keywords: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Keywords: fn(
            self: *const IDataCollectorSet,
            keywords: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LatestOutputLocation: fn(
            self: *const IDataCollectorSet,
            path: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LatestOutputLocation: fn(
            self: *const IDataCollectorSet,
            path: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IDataCollectorSet,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputLocation: fn(
            self: *const IDataCollectorSet,
            path: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootPath: fn(
            self: *const IDataCollectorSet,
            folder: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RootPath: fn(
            self: *const IDataCollectorSet,
            folder: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Segment: fn(
            self: *const IDataCollectorSet,
            segment: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Segment: fn(
            self: *const IDataCollectorSet,
            segment: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SegmentMaxDuration: fn(
            self: *const IDataCollectorSet,
            seconds: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SegmentMaxDuration: fn(
            self: *const IDataCollectorSet,
            seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SegmentMaxSize: fn(
            self: *const IDataCollectorSet,
            size: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SegmentMaxSize: fn(
            self: *const IDataCollectorSet,
            size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SerialNumber: fn(
            self: *const IDataCollectorSet,
            index: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SerialNumber: fn(
            self: *const IDataCollectorSet,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Server: fn(
            self: *const IDataCollectorSet,
            server: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IDataCollectorSet,
            status: *DataCollectorSetStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subdirectory: fn(
            self: *const IDataCollectorSet,
            folder: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Subdirectory: fn(
            self: *const IDataCollectorSet,
            folder: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubdirectoryFormat: fn(
            self: *const IDataCollectorSet,
            format: *AutoPathFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubdirectoryFormat: fn(
            self: *const IDataCollectorSet,
            format: AutoPathFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubdirectoryFormatPattern: fn(
            self: *const IDataCollectorSet,
            pattern: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubdirectoryFormatPattern: fn(
            self: *const IDataCollectorSet,
            pattern: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Task: fn(
            self: *const IDataCollectorSet,
            task: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Task: fn(
            self: *const IDataCollectorSet,
            task: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskRunAsSelf: fn(
            self: *const IDataCollectorSet,
            RunAsSelf: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskRunAsSelf: fn(
            self: *const IDataCollectorSet,
            RunAsSelf: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskArguments: fn(
            self: *const IDataCollectorSet,
            task: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskArguments: fn(
            self: *const IDataCollectorSet,
            task: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskUserTextArguments: fn(
            self: *const IDataCollectorSet,
            UserText: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskUserTextArguments: fn(
            self: *const IDataCollectorSet,
            UserText: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Schedules: fn(
            self: *const IDataCollectorSet,
            ppSchedules: ?*?*IScheduleCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SchedulesEnabled: fn(
            self: *const IDataCollectorSet,
            enabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SchedulesEnabled: fn(
            self: *const IDataCollectorSet,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAccount: fn(
            self: *const IDataCollectorSet,
            user: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Xml: fn(
            self: *const IDataCollectorSet,
            xml: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Security: fn(
            self: *const IDataCollectorSet,
            pbstrSecurity: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Security: fn(
            self: *const IDataCollectorSet,
            bstrSecurity: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopOnCompletion: fn(
            self: *const IDataCollectorSet,
            Stop: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopOnCompletion: fn(
            self: *const IDataCollectorSet,
            Stop: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataManager: fn(
            self: *const IDataCollectorSet,
            DataManager: ?*?*IDataManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCredentials: fn(
            self: *const IDataCollectorSet,
            user: BSTR,
            password: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IDataCollectorSet,
            name: BSTR,
            server: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IDataCollectorSet,
            name: BSTR,
            server: BSTR,
            mode: CommitMode,
            validation: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IDataCollectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IDataCollectorSet,
            Synchronous: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IDataCollectorSet,
            Synchronous: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetXml: fn(
            self: *const IDataCollectorSet,
            xml: BSTR,
            validation: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IDataCollectorSet,
            key: BSTR,
            value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDataCollectorSet,
            key: BSTR,
            value: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_DataCollectors(self: *const T, collectors: ?*?*IDataCollectorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_DataCollectors(@ptrCast(*const IDataCollectorSet, self), collectors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Duration(self: *const T, seconds: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Duration(@ptrCast(*const IDataCollectorSet, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Duration(self: *const T, seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Duration(@ptrCast(*const IDataCollectorSet, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Description(self: *const T, description: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Description(@ptrCast(*const IDataCollectorSet, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Description(self: *const T, description: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Description(@ptrCast(*const IDataCollectorSet, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_DescriptionUnresolved(self: *const T, Descr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_DescriptionUnresolved(@ptrCast(*const IDataCollectorSet, self), Descr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_DisplayName(self: *const T, DisplayName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_DisplayName(@ptrCast(*const IDataCollectorSet, self), DisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_DisplayName(self: *const T, DisplayName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_DisplayName(@ptrCast(*const IDataCollectorSet, self), DisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_DisplayNameUnresolved(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_DisplayNameUnresolved(@ptrCast(*const IDataCollectorSet, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Keywords(self: *const T, keywords: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Keywords(@ptrCast(*const IDataCollectorSet, self), keywords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Keywords(self: *const T, keywords: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Keywords(@ptrCast(*const IDataCollectorSet, self), keywords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_LatestOutputLocation(self: *const T, path: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_LatestOutputLocation(@ptrCast(*const IDataCollectorSet, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_LatestOutputLocation(self: *const T, path: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_LatestOutputLocation(@ptrCast(*const IDataCollectorSet, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Name(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Name(@ptrCast(*const IDataCollectorSet, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_OutputLocation(self: *const T, path: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_OutputLocation(@ptrCast(*const IDataCollectorSet, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_RootPath(self: *const T, folder: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_RootPath(@ptrCast(*const IDataCollectorSet, self), folder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_RootPath(self: *const T, folder: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_RootPath(@ptrCast(*const IDataCollectorSet, self), folder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Segment(self: *const T, segment: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Segment(@ptrCast(*const IDataCollectorSet, self), segment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Segment(self: *const T, segment: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Segment(@ptrCast(*const IDataCollectorSet, self), segment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SegmentMaxDuration(self: *const T, seconds: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SegmentMaxDuration(@ptrCast(*const IDataCollectorSet, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SegmentMaxDuration(self: *const T, seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SegmentMaxDuration(@ptrCast(*const IDataCollectorSet, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SegmentMaxSize(self: *const T, size: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SegmentMaxSize(@ptrCast(*const IDataCollectorSet, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SegmentMaxSize(self: *const T, size: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SegmentMaxSize(@ptrCast(*const IDataCollectorSet, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SerialNumber(self: *const T, index: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SerialNumber(@ptrCast(*const IDataCollectorSet, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SerialNumber(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SerialNumber(@ptrCast(*const IDataCollectorSet, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Server(self: *const T, server: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Server(@ptrCast(*const IDataCollectorSet, self), server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Status(self: *const T, status: *DataCollectorSetStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Status(@ptrCast(*const IDataCollectorSet, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Subdirectory(self: *const T, folder: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Subdirectory(@ptrCast(*const IDataCollectorSet, self), folder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Subdirectory(self: *const T, folder: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Subdirectory(@ptrCast(*const IDataCollectorSet, self), folder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SubdirectoryFormat(self: *const T, format: *AutoPathFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SubdirectoryFormat(@ptrCast(*const IDataCollectorSet, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SubdirectoryFormat(self: *const T, format: AutoPathFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SubdirectoryFormat(@ptrCast(*const IDataCollectorSet, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SubdirectoryFormatPattern(self: *const T, pattern: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SubdirectoryFormatPattern(@ptrCast(*const IDataCollectorSet, self), pattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SubdirectoryFormatPattern(self: *const T, pattern: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SubdirectoryFormatPattern(@ptrCast(*const IDataCollectorSet, self), pattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Task(self: *const T, task: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Task(@ptrCast(*const IDataCollectorSet, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Task(self: *const T, task: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Task(@ptrCast(*const IDataCollectorSet, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_TaskRunAsSelf(self: *const T, RunAsSelf: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_TaskRunAsSelf(@ptrCast(*const IDataCollectorSet, self), RunAsSelf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_TaskRunAsSelf(self: *const T, RunAsSelf: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_TaskRunAsSelf(@ptrCast(*const IDataCollectorSet, self), RunAsSelf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_TaskArguments(self: *const T, task: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_TaskArguments(@ptrCast(*const IDataCollectorSet, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_TaskArguments(self: *const T, task: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_TaskArguments(@ptrCast(*const IDataCollectorSet, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_TaskUserTextArguments(self: *const T, UserText: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_TaskUserTextArguments(@ptrCast(*const IDataCollectorSet, self), UserText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_TaskUserTextArguments(self: *const T, UserText: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_TaskUserTextArguments(@ptrCast(*const IDataCollectorSet, self), UserText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Schedules(self: *const T, ppSchedules: ?*?*IScheduleCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Schedules(@ptrCast(*const IDataCollectorSet, self), ppSchedules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_SchedulesEnabled(self: *const T, enabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_SchedulesEnabled(@ptrCast(*const IDataCollectorSet, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_SchedulesEnabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_SchedulesEnabled(@ptrCast(*const IDataCollectorSet, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_UserAccount(self: *const T, user: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_UserAccount(@ptrCast(*const IDataCollectorSet, self), user);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Xml(self: *const T, xml: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Xml(@ptrCast(*const IDataCollectorSet, self), xml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_Security(self: *const T, pbstrSecurity: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_Security(@ptrCast(*const IDataCollectorSet, self), pbstrSecurity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_Security(self: *const T, bstrSecurity: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_Security(@ptrCast(*const IDataCollectorSet, self), bstrSecurity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_StopOnCompletion(self: *const T, Stop: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_StopOnCompletion(@ptrCast(*const IDataCollectorSet, self), Stop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_put_StopOnCompletion(self: *const T, Stop: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).put_StopOnCompletion(@ptrCast(*const IDataCollectorSet, self), Stop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_get_DataManager(self: *const T, DataManager: ?*?*IDataManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).get_DataManager(@ptrCast(*const IDataCollectorSet, self), DataManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_SetCredentials(self: *const T, user: BSTR, password: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).SetCredentials(@ptrCast(*const IDataCollectorSet, self), user, password);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_Query(self: *const T, name: BSTR, server: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).Query(@ptrCast(*const IDataCollectorSet, self), name, server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_Commit(self: *const T, name: BSTR, server: BSTR, mode: CommitMode, validation: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).Commit(@ptrCast(*const IDataCollectorSet, self), name, server, mode, validation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).Delete(@ptrCast(*const IDataCollectorSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_Start(self: *const T, Synchronous: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).Start(@ptrCast(*const IDataCollectorSet, self), Synchronous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_Stop(self: *const T, Synchronous: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).Stop(@ptrCast(*const IDataCollectorSet, self), Synchronous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_SetXml(self: *const T, xml: BSTR, validation: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).SetXml(@ptrCast(*const IDataCollectorSet, self), xml, validation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_SetValue(self: *const T, key: BSTR, value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).SetValue(@ptrCast(*const IDataCollectorSet, self), key, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSet_GetValue(self: *const T, key: BSTR, value: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSet.VTable, self.vtable).GetValue(@ptrCast(*const IDataCollectorSet, self), key, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDataManager_Value = @import("../zig.zig").Guid.initString("03837541-098b-11d8-9414-505054503030");
pub const IID_IDataManager = &IID_IDataManager_Value;
pub const IDataManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IDataManager,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IDataManager,
            fEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CheckBeforeRunning: fn(
            self: *const IDataManager,
            pfCheck: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CheckBeforeRunning: fn(
            self: *const IDataManager,
            fCheck: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinFreeDisk: fn(
            self: *const IDataManager,
            MinFreeDisk: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinFreeDisk: fn(
            self: *const IDataManager,
            MinFreeDisk: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxSize: fn(
            self: *const IDataManager,
            pulMaxSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxSize: fn(
            self: *const IDataManager,
            ulMaxSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxFolderCount: fn(
            self: *const IDataManager,
            pulMaxFolderCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxFolderCount: fn(
            self: *const IDataManager,
            ulMaxFolderCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResourcePolicy: fn(
            self: *const IDataManager,
            pPolicy: *ResourcePolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResourcePolicy: fn(
            self: *const IDataManager,
            Policy: ResourcePolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FolderActions: fn(
            self: *const IDataManager,
            Actions: ?*?*IFolderActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReportSchema: fn(
            self: *const IDataManager,
            ReportSchema: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReportSchema: fn(
            self: *const IDataManager,
            ReportSchema: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReportFileName: fn(
            self: *const IDataManager,
            pbstrFilename: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReportFileName: fn(
            self: *const IDataManager,
            pbstrFilename: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuleTargetFileName: fn(
            self: *const IDataManager,
            Filename: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RuleTargetFileName: fn(
            self: *const IDataManager,
            Filename: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventsFileName: fn(
            self: *const IDataManager,
            pbstrFilename: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventsFileName: fn(
            self: *const IDataManager,
            pbstrFilename: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: fn(
            self: *const IDataManager,
            pbstrXml: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rules: fn(
            self: *const IDataManager,
            bstrXml: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IDataManager,
            Steps: DataManagerSteps,
            bstrFolder: BSTR,
            Errors: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extract: fn(
            self: *const IDataManager,
            CabFilename: BSTR,
            DestinationPath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_Enabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_Enabled(@ptrCast(*const IDataManager, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_Enabled(self: *const T, fEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_Enabled(@ptrCast(*const IDataManager, self), fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_CheckBeforeRunning(self: *const T, pfCheck: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_CheckBeforeRunning(@ptrCast(*const IDataManager, self), pfCheck);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_CheckBeforeRunning(self: *const T, fCheck: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_CheckBeforeRunning(@ptrCast(*const IDataManager, self), fCheck);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_MinFreeDisk(self: *const T, MinFreeDisk: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_MinFreeDisk(@ptrCast(*const IDataManager, self), MinFreeDisk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_MinFreeDisk(self: *const T, MinFreeDisk: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_MinFreeDisk(@ptrCast(*const IDataManager, self), MinFreeDisk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_MaxSize(self: *const T, pulMaxSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_MaxSize(@ptrCast(*const IDataManager, self), pulMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_MaxSize(self: *const T, ulMaxSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_MaxSize(@ptrCast(*const IDataManager, self), ulMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_MaxFolderCount(self: *const T, pulMaxFolderCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_MaxFolderCount(@ptrCast(*const IDataManager, self), pulMaxFolderCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_MaxFolderCount(self: *const T, ulMaxFolderCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_MaxFolderCount(@ptrCast(*const IDataManager, self), ulMaxFolderCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_ResourcePolicy(self: *const T, pPolicy: *ResourcePolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_ResourcePolicy(@ptrCast(*const IDataManager, self), pPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_ResourcePolicy(self: *const T, Policy: ResourcePolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_ResourcePolicy(@ptrCast(*const IDataManager, self), Policy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_FolderActions(self: *const T, Actions: ?*?*IFolderActionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_FolderActions(@ptrCast(*const IDataManager, self), Actions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_ReportSchema(self: *const T, ReportSchema: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_ReportSchema(@ptrCast(*const IDataManager, self), ReportSchema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_ReportSchema(self: *const T, ReportSchema: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_ReportSchema(@ptrCast(*const IDataManager, self), ReportSchema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_ReportFileName(self: *const T, pbstrFilename: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_ReportFileName(@ptrCast(*const IDataManager, self), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_ReportFileName(self: *const T, pbstrFilename: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_ReportFileName(@ptrCast(*const IDataManager, self), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_RuleTargetFileName(self: *const T, Filename: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_RuleTargetFileName(@ptrCast(*const IDataManager, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_RuleTargetFileName(self: *const T, Filename: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_RuleTargetFileName(@ptrCast(*const IDataManager, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_EventsFileName(self: *const T, pbstrFilename: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_EventsFileName(@ptrCast(*const IDataManager, self), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_EventsFileName(self: *const T, pbstrFilename: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_EventsFileName(@ptrCast(*const IDataManager, self), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_get_Rules(self: *const T, pbstrXml: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).get_Rules(@ptrCast(*const IDataManager, self), pbstrXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_put_Rules(self: *const T, bstrXml: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).put_Rules(@ptrCast(*const IDataManager, self), bstrXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_Run(self: *const T, Steps: DataManagerSteps, bstrFolder: BSTR, Errors: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).Run(@ptrCast(*const IDataManager, self), Steps, bstrFolder, Errors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataManager_Extract(self: *const T, CabFilename: BSTR, DestinationPath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataManager.VTable, self.vtable).Extract(@ptrCast(*const IDataManager, self), CabFilename, DestinationPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderAction_Value = @import("../zig.zig").Guid.initString("03837543-098b-11d8-9414-505054503030");
pub const IID_IFolderAction = &IID_IFolderAction_Value;
pub const IFolderAction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Age: fn(
            self: *const IFolderAction,
            pulAge: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Age: fn(
            self: *const IFolderAction,
            ulAge: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: fn(
            self: *const IFolderAction,
            pulAge: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Size: fn(
            self: *const IFolderAction,
            ulAge: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Actions: fn(
            self: *const IFolderAction,
            Steps: *FolderActionSteps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Actions: fn(
            self: *const IFolderAction,
            Steps: FolderActionSteps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SendCabTo: fn(
            self: *const IFolderAction,
            pbstrDestination: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SendCabTo: fn(
            self: *const IFolderAction,
            bstrDestination: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_get_Age(self: *const T, pulAge: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).get_Age(@ptrCast(*const IFolderAction, self), pulAge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_put_Age(self: *const T, ulAge: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).put_Age(@ptrCast(*const IFolderAction, self), ulAge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_get_Size(self: *const T, pulAge: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).get_Size(@ptrCast(*const IFolderAction, self), pulAge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_put_Size(self: *const T, ulAge: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).put_Size(@ptrCast(*const IFolderAction, self), ulAge);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_get_Actions(self: *const T, Steps: *FolderActionSteps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).get_Actions(@ptrCast(*const IFolderAction, self), Steps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_put_Actions(self: *const T, Steps: FolderActionSteps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).put_Actions(@ptrCast(*const IFolderAction, self), Steps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_get_SendCabTo(self: *const T, pbstrDestination: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).get_SendCabTo(@ptrCast(*const IFolderAction, self), pbstrDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderAction_put_SendCabTo(self: *const T, bstrDestination: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderAction.VTable, self.vtable).put_SendCabTo(@ptrCast(*const IFolderAction, self), bstrDestination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderActionCollection_Value = @import("../zig.zig").Guid.initString("03837544-098b-11d8-9414-505054503030");
pub const IID_IFolderActionCollection = &IID_IFolderActionCollection_Value;
pub const IFolderActionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IFolderActionCollection,
            Count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IFolderActionCollection,
            Index: VARIANT,
            Action: ?*?*IFolderAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IFolderActionCollection,
            Enum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IFolderActionCollection,
            Action: ?*IFolderAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IFolderActionCollection,
            Index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IFolderActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IFolderActionCollection,
            Actions: ?*IFolderActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFolderAction: fn(
            self: *const IFolderActionCollection,
            FolderAction: ?*?*IFolderAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_get_Count(self: *const T, Count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).get_Count(@ptrCast(*const IFolderActionCollection, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_get_Item(self: *const T, Index: VARIANT, Action: ?*?*IFolderAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).get_Item(@ptrCast(*const IFolderActionCollection, self), Index, Action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_get__NewEnum(self: *const T, Enum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFolderActionCollection, self), Enum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_Add(self: *const T, Action: ?*IFolderAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).Add(@ptrCast(*const IFolderActionCollection, self), Action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).Remove(@ptrCast(*const IFolderActionCollection, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).Clear(@ptrCast(*const IFolderActionCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_AddRange(self: *const T, Actions: ?*IFolderActionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).AddRange(@ptrCast(*const IFolderActionCollection, self), Actions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderActionCollection_CreateFolderAction(self: *const T, FolderAction: ?*?*IFolderAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderActionCollection.VTable, self.vtable).CreateFolderAction(@ptrCast(*const IFolderActionCollection, self), FolderAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDataCollector_Value = @import("../zig.zig").Guid.initString("038374ff-098b-11d8-9414-505054503030");
pub const IID_IDataCollector = &IID_IDataCollector_Value;
pub const IDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataCollectorSet: fn(
            self: *const IDataCollector,
            group: ?*?*IDataCollectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataCollectorSet: fn(
            self: *const IDataCollector,
            group: ?*IDataCollectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataCollectorType: fn(
            self: *const IDataCollector,
            type: *DataCollectorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileName: fn(
            self: *const IDataCollector,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileName: fn(
            self: *const IDataCollector,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileNameFormat: fn(
            self: *const IDataCollector,
            format: *AutoPathFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileNameFormat: fn(
            self: *const IDataCollector,
            format: AutoPathFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileNameFormatPattern: fn(
            self: *const IDataCollector,
            pattern: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileNameFormatPattern: fn(
            self: *const IDataCollector,
            pattern: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LatestOutputLocation: fn(
            self: *const IDataCollector,
            path: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LatestOutputLocation: fn(
            self: *const IDataCollector,
            path: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogAppend: fn(
            self: *const IDataCollector,
            append: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogAppend: fn(
            self: *const IDataCollector,
            append: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogCircular: fn(
            self: *const IDataCollector,
            circular: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogCircular: fn(
            self: *const IDataCollector,
            circular: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogOverwrite: fn(
            self: *const IDataCollector,
            overwrite: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogOverwrite: fn(
            self: *const IDataCollector,
            overwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IDataCollector,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IDataCollector,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputLocation: fn(
            self: *const IDataCollector,
            path: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Index: fn(
            self: *const IDataCollector,
            index: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Index: fn(
            self: *const IDataCollector,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Xml: fn(
            self: *const IDataCollector,
            Xml: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetXml: fn(
            self: *const IDataCollector,
            Xml: BSTR,
            Validation: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOutputLocation: fn(
            self: *const IDataCollector,
            Latest: i16,
            Location: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_DataCollectorSet(self: *const T, group: ?*?*IDataCollectorSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_DataCollectorSet(@ptrCast(*const IDataCollector, self), group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_DataCollectorSet(self: *const T, group: ?*IDataCollectorSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_DataCollectorSet(@ptrCast(*const IDataCollector, self), group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_DataCollectorType(self: *const T, type: *DataCollectorType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_DataCollectorType(@ptrCast(*const IDataCollector, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_FileName(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_FileName(@ptrCast(*const IDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_FileName(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_FileName(@ptrCast(*const IDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_FileNameFormat(self: *const T, format: *AutoPathFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_FileNameFormat(@ptrCast(*const IDataCollector, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_FileNameFormat(self: *const T, format: AutoPathFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_FileNameFormat(@ptrCast(*const IDataCollector, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_FileNameFormatPattern(self: *const T, pattern: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_FileNameFormatPattern(@ptrCast(*const IDataCollector, self), pattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_FileNameFormatPattern(self: *const T, pattern: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_FileNameFormatPattern(@ptrCast(*const IDataCollector, self), pattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_LatestOutputLocation(self: *const T, path: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_LatestOutputLocation(@ptrCast(*const IDataCollector, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_LatestOutputLocation(self: *const T, path: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_LatestOutputLocation(@ptrCast(*const IDataCollector, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_LogAppend(self: *const T, append: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_LogAppend(@ptrCast(*const IDataCollector, self), append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_LogAppend(self: *const T, append: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_LogAppend(@ptrCast(*const IDataCollector, self), append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_LogCircular(self: *const T, circular: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_LogCircular(@ptrCast(*const IDataCollector, self), circular);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_LogCircular(self: *const T, circular: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_LogCircular(@ptrCast(*const IDataCollector, self), circular);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_LogOverwrite(self: *const T, overwrite: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_LogOverwrite(@ptrCast(*const IDataCollector, self), overwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_LogOverwrite(self: *const T, overwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_LogOverwrite(@ptrCast(*const IDataCollector, self), overwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_Name(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_Name(@ptrCast(*const IDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_Name(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_Name(@ptrCast(*const IDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_OutputLocation(self: *const T, path: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_OutputLocation(@ptrCast(*const IDataCollector, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_Index(self: *const T, index: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_Index(@ptrCast(*const IDataCollector, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_put_Index(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).put_Index(@ptrCast(*const IDataCollector, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_get_Xml(self: *const T, Xml: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).get_Xml(@ptrCast(*const IDataCollector, self), Xml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_SetXml(self: *const T, Xml: BSTR, Validation: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).SetXml(@ptrCast(*const IDataCollector, self), Xml, Validation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollector_CreateOutputLocation(self: *const T, Latest: i16, Location: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollector.VTable, self.vtable).CreateOutputLocation(@ptrCast(*const IDataCollector, self), Latest, Location);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPerformanceCounterDataCollector_Value = @import("../zig.zig").Guid.initString("03837506-098b-11d8-9414-505054503030");
pub const IID_IPerformanceCounterDataCollector = &IID_IPerformanceCounterDataCollector_Value;
pub const IPerformanceCounterDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDataCollector.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSourceName: fn(
            self: *const IPerformanceCounterDataCollector,
            dsn: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataSourceName: fn(
            self: *const IPerformanceCounterDataCollector,
            dsn: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PerformanceCounters: fn(
            self: *const IPerformanceCounterDataCollector,
            counters: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PerformanceCounters: fn(
            self: *const IPerformanceCounterDataCollector,
            counters: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogFileFormat: fn(
            self: *const IPerformanceCounterDataCollector,
            format: *FileFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogFileFormat: fn(
            self: *const IPerformanceCounterDataCollector,
            format: FileFormat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SampleInterval: fn(
            self: *const IPerformanceCounterDataCollector,
            interval: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SampleInterval: fn(
            self: *const IPerformanceCounterDataCollector,
            interval: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SegmentMaxRecords: fn(
            self: *const IPerformanceCounterDataCollector,
            records: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SegmentMaxRecords: fn(
            self: *const IPerformanceCounterDataCollector,
            records: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataCollector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_get_DataSourceName(self: *const T, dsn: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).get_DataSourceName(@ptrCast(*const IPerformanceCounterDataCollector, self), dsn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_put_DataSourceName(self: *const T, dsn: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).put_DataSourceName(@ptrCast(*const IPerformanceCounterDataCollector, self), dsn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_get_PerformanceCounters(self: *const T, counters: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).get_PerformanceCounters(@ptrCast(*const IPerformanceCounterDataCollector, self), counters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_put_PerformanceCounters(self: *const T, counters: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).put_PerformanceCounters(@ptrCast(*const IPerformanceCounterDataCollector, self), counters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_get_LogFileFormat(self: *const T, format: *FileFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).get_LogFileFormat(@ptrCast(*const IPerformanceCounterDataCollector, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_put_LogFileFormat(self: *const T, format: FileFormat) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).put_LogFileFormat(@ptrCast(*const IPerformanceCounterDataCollector, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_get_SampleInterval(self: *const T, interval: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).get_SampleInterval(@ptrCast(*const IPerformanceCounterDataCollector, self), interval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_put_SampleInterval(self: *const T, interval: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).put_SampleInterval(@ptrCast(*const IPerformanceCounterDataCollector, self), interval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_get_SegmentMaxRecords(self: *const T, records: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).get_SegmentMaxRecords(@ptrCast(*const IPerformanceCounterDataCollector, self), records);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerformanceCounterDataCollector_put_SegmentMaxRecords(self: *const T, records: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerformanceCounterDataCollector.VTable, self.vtable).put_SegmentMaxRecords(@ptrCast(*const IPerformanceCounterDataCollector, self), records);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITraceDataCollector_Value = @import("../zig.zig").Guid.initString("0383750b-098b-11d8-9414-505054503030");
pub const IID_ITraceDataCollector = &IID_ITraceDataCollector_Value;
pub const ITraceDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDataCollector.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferSize: fn(
            self: *const ITraceDataCollector,
            size: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferSize: fn(
            self: *const ITraceDataCollector,
            size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BuffersLost: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BuffersLost: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BuffersWritten: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BuffersWritten: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClockType: fn(
            self: *const ITraceDataCollector,
            clock: *ClockType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClockType: fn(
            self: *const ITraceDataCollector,
            clock: ClockType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventsLost: fn(
            self: *const ITraceDataCollector,
            events: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventsLost: fn(
            self: *const ITraceDataCollector,
            events: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedModes: fn(
            self: *const ITraceDataCollector,
            mode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtendedModes: fn(
            self: *const ITraceDataCollector,
            mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FlushTimer: fn(
            self: *const ITraceDataCollector,
            seconds: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FlushTimer: fn(
            self: *const ITraceDataCollector,
            seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FreeBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: fn(
            self: *const ITraceDataCollector,
            guid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guid: fn(
            self: *const ITraceDataCollector,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsKernelTrace: fn(
            self: *const ITraceDataCollector,
            kernel: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaximumBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaximumBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinimumBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinimumBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NumberOfBuffers: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreallocateFile: fn(
            self: *const ITraceDataCollector,
            allocate: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreallocateFile: fn(
            self: *const ITraceDataCollector,
            allocate: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProcessMode: fn(
            self: *const ITraceDataCollector,
            process: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProcessMode: fn(
            self: *const ITraceDataCollector,
            process: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RealTimeBuffersLost: fn(
            self: *const ITraceDataCollector,
            buffers: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RealTimeBuffersLost: fn(
            self: *const ITraceDataCollector,
            buffers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionId: fn(
            self: *const ITraceDataCollector,
            id: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionId: fn(
            self: *const ITraceDataCollector,
            id: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionName: fn(
            self: *const ITraceDataCollector,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionName: fn(
            self: *const ITraceDataCollector,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionThreadId: fn(
            self: *const ITraceDataCollector,
            tid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionThreadId: fn(
            self: *const ITraceDataCollector,
            tid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamMode: fn(
            self: *const ITraceDataCollector,
            mode: *StreamMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StreamMode: fn(
            self: *const ITraceDataCollector,
            mode: StreamMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TraceDataProviders: fn(
            self: *const ITraceDataCollector,
            providers: ?*?*ITraceDataProviderCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataCollector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_BufferSize(self: *const T, size: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_BufferSize(@ptrCast(*const ITraceDataCollector, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_BufferSize(self: *const T, size: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_BufferSize(@ptrCast(*const ITraceDataCollector, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_BuffersLost(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_BuffersLost(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_BuffersLost(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_BuffersLost(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_BuffersWritten(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_BuffersWritten(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_BuffersWritten(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_BuffersWritten(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_ClockType(self: *const T, clock: *ClockType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_ClockType(@ptrCast(*const ITraceDataCollector, self), clock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_ClockType(self: *const T, clock: ClockType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_ClockType(@ptrCast(*const ITraceDataCollector, self), clock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_EventsLost(self: *const T, events: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_EventsLost(@ptrCast(*const ITraceDataCollector, self), events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_EventsLost(self: *const T, events: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_EventsLost(@ptrCast(*const ITraceDataCollector, self), events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_ExtendedModes(self: *const T, mode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_ExtendedModes(@ptrCast(*const ITraceDataCollector, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_ExtendedModes(self: *const T, mode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_ExtendedModes(@ptrCast(*const ITraceDataCollector, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_FlushTimer(self: *const T, seconds: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_FlushTimer(@ptrCast(*const ITraceDataCollector, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_FlushTimer(self: *const T, seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_FlushTimer(@ptrCast(*const ITraceDataCollector, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_FreeBuffers(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_FreeBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_FreeBuffers(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_FreeBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_Guid(self: *const T, guid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_Guid(@ptrCast(*const ITraceDataCollector, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_Guid(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_Guid(@ptrCast(*const ITraceDataCollector, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_IsKernelTrace(self: *const T, kernel: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_IsKernelTrace(@ptrCast(*const ITraceDataCollector, self), kernel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_MaximumBuffers(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_MaximumBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_MaximumBuffers(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_MaximumBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_MinimumBuffers(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_MinimumBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_MinimumBuffers(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_MinimumBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_NumberOfBuffers(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_NumberOfBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_NumberOfBuffers(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_NumberOfBuffers(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_PreallocateFile(self: *const T, allocate: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_PreallocateFile(@ptrCast(*const ITraceDataCollector, self), allocate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_PreallocateFile(self: *const T, allocate: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_PreallocateFile(@ptrCast(*const ITraceDataCollector, self), allocate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_ProcessMode(self: *const T, process: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_ProcessMode(@ptrCast(*const ITraceDataCollector, self), process);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_ProcessMode(self: *const T, process: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_ProcessMode(@ptrCast(*const ITraceDataCollector, self), process);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_RealTimeBuffersLost(self: *const T, buffers: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_RealTimeBuffersLost(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_RealTimeBuffersLost(self: *const T, buffers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_RealTimeBuffersLost(@ptrCast(*const ITraceDataCollector, self), buffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_SessionId(self: *const T, id: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_SessionId(@ptrCast(*const ITraceDataCollector, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_SessionId(self: *const T, id: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_SessionId(@ptrCast(*const ITraceDataCollector, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_SessionName(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_SessionName(@ptrCast(*const ITraceDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_SessionName(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_SessionName(@ptrCast(*const ITraceDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_SessionThreadId(self: *const T, tid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_SessionThreadId(@ptrCast(*const ITraceDataCollector, self), tid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_SessionThreadId(self: *const T, tid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_SessionThreadId(@ptrCast(*const ITraceDataCollector, self), tid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_StreamMode(self: *const T, mode: *StreamMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_StreamMode(@ptrCast(*const ITraceDataCollector, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_put_StreamMode(self: *const T, mode: StreamMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).put_StreamMode(@ptrCast(*const ITraceDataCollector, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataCollector_get_TraceDataProviders(self: *const T, providers: ?*?*ITraceDataProviderCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataCollector.VTable, self.vtable).get_TraceDataProviders(@ptrCast(*const ITraceDataCollector, self), providers);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConfigurationDataCollector_Value = @import("../zig.zig").Guid.initString("03837514-098b-11d8-9414-505054503030");
pub const IID_IConfigurationDataCollector = &IID_IConfigurationDataCollector_Value;
pub const IConfigurationDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDataCollector.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileMaxCount: fn(
            self: *const IConfigurationDataCollector,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileMaxCount: fn(
            self: *const IConfigurationDataCollector,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileMaxRecursiveDepth: fn(
            self: *const IConfigurationDataCollector,
            depth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileMaxRecursiveDepth: fn(
            self: *const IConfigurationDataCollector,
            depth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileMaxTotalSize: fn(
            self: *const IConfigurationDataCollector,
            size: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileMaxTotalSize: fn(
            self: *const IConfigurationDataCollector,
            size: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Files: fn(
            self: *const IConfigurationDataCollector,
            Files: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Files: fn(
            self: *const IConfigurationDataCollector,
            Files: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ManagementQueries: fn(
            self: *const IConfigurationDataCollector,
            Queries: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ManagementQueries: fn(
            self: *const IConfigurationDataCollector,
            Queries: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryNetworkAdapters: fn(
            self: *const IConfigurationDataCollector,
            network: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QueryNetworkAdapters: fn(
            self: *const IConfigurationDataCollector,
            network: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegistryKeys: fn(
            self: *const IConfigurationDataCollector,
            query: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegistryKeys: fn(
            self: *const IConfigurationDataCollector,
            query: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegistryMaxRecursiveDepth: fn(
            self: *const IConfigurationDataCollector,
            depth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegistryMaxRecursiveDepth: fn(
            self: *const IConfigurationDataCollector,
            depth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SystemStateFile: fn(
            self: *const IConfigurationDataCollector,
            FileName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SystemStateFile: fn(
            self: *const IConfigurationDataCollector,
            FileName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataCollector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_FileMaxCount(self: *const T, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_FileMaxCount(@ptrCast(*const IConfigurationDataCollector, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_FileMaxCount(self: *const T, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_FileMaxCount(@ptrCast(*const IConfigurationDataCollector, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_FileMaxRecursiveDepth(self: *const T, depth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_FileMaxRecursiveDepth(@ptrCast(*const IConfigurationDataCollector, self), depth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_FileMaxRecursiveDepth(self: *const T, depth: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_FileMaxRecursiveDepth(@ptrCast(*const IConfigurationDataCollector, self), depth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_FileMaxTotalSize(self: *const T, size: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_FileMaxTotalSize(@ptrCast(*const IConfigurationDataCollector, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_FileMaxTotalSize(self: *const T, size: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_FileMaxTotalSize(@ptrCast(*const IConfigurationDataCollector, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_Files(self: *const T, Files: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_Files(@ptrCast(*const IConfigurationDataCollector, self), Files);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_Files(self: *const T, Files: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_Files(@ptrCast(*const IConfigurationDataCollector, self), Files);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_ManagementQueries(self: *const T, Queries: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_ManagementQueries(@ptrCast(*const IConfigurationDataCollector, self), Queries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_ManagementQueries(self: *const T, Queries: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_ManagementQueries(@ptrCast(*const IConfigurationDataCollector, self), Queries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_QueryNetworkAdapters(self: *const T, network: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_QueryNetworkAdapters(@ptrCast(*const IConfigurationDataCollector, self), network);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_QueryNetworkAdapters(self: *const T, network: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_QueryNetworkAdapters(@ptrCast(*const IConfigurationDataCollector, self), network);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_RegistryKeys(self: *const T, query: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_RegistryKeys(@ptrCast(*const IConfigurationDataCollector, self), query);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_RegistryKeys(self: *const T, query: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_RegistryKeys(@ptrCast(*const IConfigurationDataCollector, self), query);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_RegistryMaxRecursiveDepth(self: *const T, depth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_RegistryMaxRecursiveDepth(@ptrCast(*const IConfigurationDataCollector, self), depth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_RegistryMaxRecursiveDepth(self: *const T, depth: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_RegistryMaxRecursiveDepth(@ptrCast(*const IConfigurationDataCollector, self), depth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_get_SystemStateFile(self: *const T, FileName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).get_SystemStateFile(@ptrCast(*const IConfigurationDataCollector, self), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigurationDataCollector_put_SystemStateFile(self: *const T, FileName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigurationDataCollector.VTable, self.vtable).put_SystemStateFile(@ptrCast(*const IConfigurationDataCollector, self), FileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAlertDataCollector_Value = @import("../zig.zig").Guid.initString("03837516-098b-11d8-9414-505054503030");
pub const IID_IAlertDataCollector = &IID_IAlertDataCollector_Value;
pub const IAlertDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDataCollector.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AlertThresholds: fn(
            self: *const IAlertDataCollector,
            alerts: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AlertThresholds: fn(
            self: *const IAlertDataCollector,
            alerts: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventLog: fn(
            self: *const IAlertDataCollector,
            log: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventLog: fn(
            self: *const IAlertDataCollector,
            log: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SampleInterval: fn(
            self: *const IAlertDataCollector,
            interval: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SampleInterval: fn(
            self: *const IAlertDataCollector,
            interval: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Task: fn(
            self: *const IAlertDataCollector,
            task: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Task: fn(
            self: *const IAlertDataCollector,
            task: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskRunAsSelf: fn(
            self: *const IAlertDataCollector,
            RunAsSelf: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskRunAsSelf: fn(
            self: *const IAlertDataCollector,
            RunAsSelf: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskArguments: fn(
            self: *const IAlertDataCollector,
            task: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskArguments: fn(
            self: *const IAlertDataCollector,
            task: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskUserTextArguments: fn(
            self: *const IAlertDataCollector,
            task: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TaskUserTextArguments: fn(
            self: *const IAlertDataCollector,
            task: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TriggerDataCollectorSet: fn(
            self: *const IAlertDataCollector,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TriggerDataCollectorSet: fn(
            self: *const IAlertDataCollector,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataCollector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_AlertThresholds(self: *const T, alerts: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_AlertThresholds(@ptrCast(*const IAlertDataCollector, self), alerts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_AlertThresholds(self: *const T, alerts: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_AlertThresholds(@ptrCast(*const IAlertDataCollector, self), alerts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_EventLog(self: *const T, log: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_EventLog(@ptrCast(*const IAlertDataCollector, self), log);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_EventLog(self: *const T, log: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_EventLog(@ptrCast(*const IAlertDataCollector, self), log);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_SampleInterval(self: *const T, interval: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_SampleInterval(@ptrCast(*const IAlertDataCollector, self), interval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_SampleInterval(self: *const T, interval: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_SampleInterval(@ptrCast(*const IAlertDataCollector, self), interval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_Task(self: *const T, task: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_Task(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_Task(self: *const T, task: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_Task(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_TaskRunAsSelf(self: *const T, RunAsSelf: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_TaskRunAsSelf(@ptrCast(*const IAlertDataCollector, self), RunAsSelf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_TaskRunAsSelf(self: *const T, RunAsSelf: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_TaskRunAsSelf(@ptrCast(*const IAlertDataCollector, self), RunAsSelf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_TaskArguments(self: *const T, task: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_TaskArguments(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_TaskArguments(self: *const T, task: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_TaskArguments(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_TaskUserTextArguments(self: *const T, task: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_TaskUserTextArguments(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_TaskUserTextArguments(self: *const T, task: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_TaskUserTextArguments(@ptrCast(*const IAlertDataCollector, self), task);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_get_TriggerDataCollectorSet(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).get_TriggerDataCollectorSet(@ptrCast(*const IAlertDataCollector, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlertDataCollector_put_TriggerDataCollectorSet(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlertDataCollector.VTable, self.vtable).put_TriggerDataCollectorSet(@ptrCast(*const IAlertDataCollector, self), name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IApiTracingDataCollector_Value = @import("../zig.zig").Guid.initString("0383751a-098b-11d8-9414-505054503030");
pub const IID_IApiTracingDataCollector = &IID_IApiTracingDataCollector_Value;
pub const IApiTracingDataCollector = extern struct {
    pub const VTable = extern struct {
        base: IDataCollector.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogApiNamesOnly: fn(
            self: *const IApiTracingDataCollector,
            logapinames: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogApiNamesOnly: fn(
            self: *const IApiTracingDataCollector,
            logapinames: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogApisRecursively: fn(
            self: *const IApiTracingDataCollector,
            logrecursively: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogApisRecursively: fn(
            self: *const IApiTracingDataCollector,
            logrecursively: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExePath: fn(
            self: *const IApiTracingDataCollector,
            exepath: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExePath: fn(
            self: *const IApiTracingDataCollector,
            exepath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogFilePath: fn(
            self: *const IApiTracingDataCollector,
            logfilepath: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogFilePath: fn(
            self: *const IApiTracingDataCollector,
            logfilepath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludeModules: fn(
            self: *const IApiTracingDataCollector,
            includemodules: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludeModules: fn(
            self: *const IApiTracingDataCollector,
            includemodules: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludeApis: fn(
            self: *const IApiTracingDataCollector,
            includeapis: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludeApis: fn(
            self: *const IApiTracingDataCollector,
            includeapis: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExcludeApis: fn(
            self: *const IApiTracingDataCollector,
            excludeapis: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExcludeApis: fn(
            self: *const IApiTracingDataCollector,
            excludeapis: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataCollector.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_LogApiNamesOnly(self: *const T, logapinames: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_LogApiNamesOnly(@ptrCast(*const IApiTracingDataCollector, self), logapinames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_LogApiNamesOnly(self: *const T, logapinames: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_LogApiNamesOnly(@ptrCast(*const IApiTracingDataCollector, self), logapinames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_LogApisRecursively(self: *const T, logrecursively: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_LogApisRecursively(@ptrCast(*const IApiTracingDataCollector, self), logrecursively);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_LogApisRecursively(self: *const T, logrecursively: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_LogApisRecursively(@ptrCast(*const IApiTracingDataCollector, self), logrecursively);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_ExePath(self: *const T, exepath: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_ExePath(@ptrCast(*const IApiTracingDataCollector, self), exepath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_ExePath(self: *const T, exepath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_ExePath(@ptrCast(*const IApiTracingDataCollector, self), exepath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_LogFilePath(self: *const T, logfilepath: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_LogFilePath(@ptrCast(*const IApiTracingDataCollector, self), logfilepath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_LogFilePath(self: *const T, logfilepath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_LogFilePath(@ptrCast(*const IApiTracingDataCollector, self), logfilepath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_IncludeModules(self: *const T, includemodules: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_IncludeModules(@ptrCast(*const IApiTracingDataCollector, self), includemodules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_IncludeModules(self: *const T, includemodules: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_IncludeModules(@ptrCast(*const IApiTracingDataCollector, self), includemodules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_IncludeApis(self: *const T, includeapis: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_IncludeApis(@ptrCast(*const IApiTracingDataCollector, self), includeapis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_IncludeApis(self: *const T, includeapis: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_IncludeApis(@ptrCast(*const IApiTracingDataCollector, self), includeapis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_get_ExcludeApis(self: *const T, excludeapis: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).get_ExcludeApis(@ptrCast(*const IApiTracingDataCollector, self), excludeapis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApiTracingDataCollector_put_ExcludeApis(self: *const T, excludeapis: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApiTracingDataCollector.VTable, self.vtable).put_ExcludeApis(@ptrCast(*const IApiTracingDataCollector, self), excludeapis);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDataCollectorCollection_Value = @import("../zig.zig").Guid.initString("03837502-098b-11d8-9414-505054503030");
pub const IID_IDataCollectorCollection = &IID_IDataCollectorCollection_Value;
pub const IDataCollectorCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IDataCollectorCollection,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IDataCollectorCollection,
            index: VARIANT,
            collector: ?*?*IDataCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IDataCollectorCollection,
            retVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IDataCollectorCollection,
            collector: ?*IDataCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IDataCollectorCollection,
            collector: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IDataCollectorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IDataCollectorCollection,
            collectors: ?*IDataCollectorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDataCollectorFromXml: fn(
            self: *const IDataCollectorCollection,
            bstrXml: BSTR,
            pValidation: ?*?*IValueMap,
            pCollector: ?*?*IDataCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDataCollector: fn(
            self: *const IDataCollectorCollection,
            Type: DataCollectorType,
            Collector: ?*?*IDataCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_get_Count(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).get_Count(@ptrCast(*const IDataCollectorCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_get_Item(self: *const T, index: VARIANT, collector: ?*?*IDataCollector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).get_Item(@ptrCast(*const IDataCollectorCollection, self), index, collector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_get__NewEnum(self: *const T, retVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IDataCollectorCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_Add(self: *const T, collector: ?*IDataCollector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).Add(@ptrCast(*const IDataCollectorCollection, self), collector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_Remove(self: *const T, collector: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).Remove(@ptrCast(*const IDataCollectorCollection, self), collector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).Clear(@ptrCast(*const IDataCollectorCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_AddRange(self: *const T, collectors: ?*IDataCollectorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).AddRange(@ptrCast(*const IDataCollectorCollection, self), collectors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_CreateDataCollectorFromXml(self: *const T, bstrXml: BSTR, pValidation: ?*?*IValueMap, pCollector: ?*?*IDataCollector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).CreateDataCollectorFromXml(@ptrCast(*const IDataCollectorCollection, self), bstrXml, pValidation, pCollector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorCollection_CreateDataCollector(self: *const T, Type: DataCollectorType, Collector: ?*?*IDataCollector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorCollection.VTable, self.vtable).CreateDataCollector(@ptrCast(*const IDataCollectorCollection, self), Type, Collector);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDataCollectorSetCollection_Value = @import("../zig.zig").Guid.initString("03837524-098b-11d8-9414-505054503030");
pub const IID_IDataCollectorSetCollection = &IID_IDataCollectorSetCollection_Value;
pub const IDataCollectorSetCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IDataCollectorSetCollection,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IDataCollectorSetCollection,
            index: VARIANT,
            set: ?*?*IDataCollectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IDataCollectorSetCollection,
            retVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IDataCollectorSetCollection,
            set: ?*IDataCollectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IDataCollectorSetCollection,
            set: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IDataCollectorSetCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IDataCollectorSetCollection,
            sets: ?*IDataCollectorSetCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataCollectorSets: fn(
            self: *const IDataCollectorSetCollection,
            server: BSTR,
            filter: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_get_Count(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).get_Count(@ptrCast(*const IDataCollectorSetCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_get_Item(self: *const T, index: VARIANT, set: ?*?*IDataCollectorSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).get_Item(@ptrCast(*const IDataCollectorSetCollection, self), index, set);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_get__NewEnum(self: *const T, retVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IDataCollectorSetCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_Add(self: *const T, set: ?*IDataCollectorSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).Add(@ptrCast(*const IDataCollectorSetCollection, self), set);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_Remove(self: *const T, set: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).Remove(@ptrCast(*const IDataCollectorSetCollection, self), set);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).Clear(@ptrCast(*const IDataCollectorSetCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_AddRange(self: *const T, sets: ?*IDataCollectorSetCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).AddRange(@ptrCast(*const IDataCollectorSetCollection, self), sets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataCollectorSetCollection_GetDataCollectorSets(self: *const T, server: BSTR, filter: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataCollectorSetCollection.VTable, self.vtable).GetDataCollectorSets(@ptrCast(*const IDataCollectorSetCollection, self), server, filter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITraceDataProvider_Value = @import("../zig.zig").Guid.initString("03837512-098b-11d8-9414-505054503030");
pub const IID_ITraceDataProvider = &IID_ITraceDataProvider_Value;
pub const ITraceDataProvider = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const ITraceDataProvider,
            name: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: fn(
            self: *const ITraceDataProvider,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: fn(
            self: *const ITraceDataProvider,
            guid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guid: fn(
            self: *const ITraceDataProvider,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Level: fn(
            self: *const ITraceDataProvider,
            ppLevel: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeywordsAny: fn(
            self: *const ITraceDataProvider,
            ppKeywords: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeywordsAll: fn(
            self: *const ITraceDataProvider,
            ppKeywords: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: fn(
            self: *const ITraceDataProvider,
            ppProperties: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterEnabled: fn(
            self: *const ITraceDataProvider,
            FilterEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FilterEnabled: fn(
            self: *const ITraceDataProvider,
            FilterEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterType: fn(
            self: *const ITraceDataProvider,
            pulType: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FilterType: fn(
            self: *const ITraceDataProvider,
            ulType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterData: fn(
            self: *const ITraceDataProvider,
            ppData: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FilterData: fn(
            self: *const ITraceDataProvider,
            pData: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const ITraceDataProvider,
            bstrName: BSTR,
            bstrServer: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const ITraceDataProvider,
            pFrom: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSecurity: fn(
            self: *const ITraceDataProvider,
            Sddl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurity: fn(
            self: *const ITraceDataProvider,
            SecurityInfo: u32,
            Sddl: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisteredProcesses: fn(
            self: *const ITraceDataProvider,
            Processes: ?*?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_DisplayName(self: *const T, name: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_DisplayName(@ptrCast(*const ITraceDataProvider, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_put_DisplayName(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).put_DisplayName(@ptrCast(*const ITraceDataProvider, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_Guid(self: *const T, guid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_Guid(@ptrCast(*const ITraceDataProvider, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_put_Guid(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).put_Guid(@ptrCast(*const ITraceDataProvider, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_Level(self: *const T, ppLevel: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_Level(@ptrCast(*const ITraceDataProvider, self), ppLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_KeywordsAny(self: *const T, ppKeywords: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_KeywordsAny(@ptrCast(*const ITraceDataProvider, self), ppKeywords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_KeywordsAll(self: *const T, ppKeywords: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_KeywordsAll(@ptrCast(*const ITraceDataProvider, self), ppKeywords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_Properties(self: *const T, ppProperties: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_Properties(@ptrCast(*const ITraceDataProvider, self), ppProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_FilterEnabled(self: *const T, FilterEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_FilterEnabled(@ptrCast(*const ITraceDataProvider, self), FilterEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_put_FilterEnabled(self: *const T, FilterEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).put_FilterEnabled(@ptrCast(*const ITraceDataProvider, self), FilterEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_FilterType(self: *const T, pulType: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_FilterType(@ptrCast(*const ITraceDataProvider, self), pulType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_put_FilterType(self: *const T, ulType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).put_FilterType(@ptrCast(*const ITraceDataProvider, self), ulType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_get_FilterData(self: *const T, ppData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).get_FilterData(@ptrCast(*const ITraceDataProvider, self), ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_put_FilterData(self: *const T, pData: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).put_FilterData(@ptrCast(*const ITraceDataProvider, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_Query(self: *const T, bstrName: BSTR, bstrServer: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).Query(@ptrCast(*const ITraceDataProvider, self), bstrName, bstrServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_Resolve(self: *const T, pFrom: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).Resolve(@ptrCast(*const ITraceDataProvider, self), pFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_SetSecurity(self: *const T, Sddl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).SetSecurity(@ptrCast(*const ITraceDataProvider, self), Sddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_GetSecurity(self: *const T, SecurityInfo: u32, Sddl: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).GetSecurity(@ptrCast(*const ITraceDataProvider, self), SecurityInfo, Sddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProvider_GetRegisteredProcesses(self: *const T, Processes: ?*?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProvider.VTable, self.vtable).GetRegisteredProcesses(@ptrCast(*const ITraceDataProvider, self), Processes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITraceDataProviderCollection_Value = @import("../zig.zig").Guid.initString("03837510-098b-11d8-9414-505054503030");
pub const IID_ITraceDataProviderCollection = &IID_ITraceDataProviderCollection_Value;
pub const ITraceDataProviderCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITraceDataProviderCollection,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITraceDataProviderCollection,
            index: VARIANT,
            ppProvider: ?*?*ITraceDataProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITraceDataProviderCollection,
            retVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITraceDataProviderCollection,
            pProvider: ?*ITraceDataProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITraceDataProviderCollection,
            vProvider: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ITraceDataProviderCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const ITraceDataProviderCollection,
            providers: ?*ITraceDataProviderCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTraceDataProvider: fn(
            self: *const ITraceDataProviderCollection,
            Provider: ?*?*ITraceDataProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTraceDataProviders: fn(
            self: *const ITraceDataProviderCollection,
            server: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTraceDataProvidersByProcess: fn(
            self: *const ITraceDataProviderCollection,
            Server: BSTR,
            Pid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_get_Count(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).get_Count(@ptrCast(*const ITraceDataProviderCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_get_Item(self: *const T, index: VARIANT, ppProvider: ?*?*ITraceDataProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).get_Item(@ptrCast(*const ITraceDataProviderCollection, self), index, ppProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_get__NewEnum(self: *const T, retVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITraceDataProviderCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_Add(self: *const T, pProvider: ?*ITraceDataProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).Add(@ptrCast(*const ITraceDataProviderCollection, self), pProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_Remove(self: *const T, vProvider: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).Remove(@ptrCast(*const ITraceDataProviderCollection, self), vProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).Clear(@ptrCast(*const ITraceDataProviderCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_AddRange(self: *const T, providers: ?*ITraceDataProviderCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).AddRange(@ptrCast(*const ITraceDataProviderCollection, self), providers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_CreateTraceDataProvider(self: *const T, Provider: ?*?*ITraceDataProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).CreateTraceDataProvider(@ptrCast(*const ITraceDataProviderCollection, self), Provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_GetTraceDataProviders(self: *const T, server: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).GetTraceDataProviders(@ptrCast(*const ITraceDataProviderCollection, self), server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITraceDataProviderCollection_GetTraceDataProvidersByProcess(self: *const T, Server: BSTR, Pid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITraceDataProviderCollection.VTable, self.vtable).GetTraceDataProvidersByProcess(@ptrCast(*const ITraceDataProviderCollection, self), Server, Pid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISchedule_Value = @import("../zig.zig").Guid.initString("0383753a-098b-11d8-9414-505054503030");
pub const IID_ISchedule = &IID_ISchedule_Value;
pub const ISchedule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartDate: fn(
            self: *const ISchedule,
            start: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartDate: fn(
            self: *const ISchedule,
            start: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndDate: fn(
            self: *const ISchedule,
            end: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EndDate: fn(
            self: *const ISchedule,
            end: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: fn(
            self: *const ISchedule,
            start: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartTime: fn(
            self: *const ISchedule,
            start: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Days: fn(
            self: *const ISchedule,
            days: *WeekDays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Days: fn(
            self: *const ISchedule,
            days: WeekDays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_get_StartDate(self: *const T, start: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).get_StartDate(@ptrCast(*const ISchedule, self), start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_put_StartDate(self: *const T, start: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).put_StartDate(@ptrCast(*const ISchedule, self), start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_get_EndDate(self: *const T, end: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).get_EndDate(@ptrCast(*const ISchedule, self), end);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_put_EndDate(self: *const T, end: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).put_EndDate(@ptrCast(*const ISchedule, self), end);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_get_StartTime(self: *const T, start: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).get_StartTime(@ptrCast(*const ISchedule, self), start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_put_StartTime(self: *const T, start: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).put_StartTime(@ptrCast(*const ISchedule, self), start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_get_Days(self: *const T, days: *WeekDays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).get_Days(@ptrCast(*const ISchedule, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchedule_put_Days(self: *const T, days: WeekDays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchedule.VTable, self.vtable).put_Days(@ptrCast(*const ISchedule, self), days);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IScheduleCollection_Value = @import("../zig.zig").Guid.initString("0383753d-098b-11d8-9414-505054503030");
pub const IID_IScheduleCollection = &IID_IScheduleCollection_Value;
pub const IScheduleCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IScheduleCollection,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IScheduleCollection,
            index: VARIANT,
            ppSchedule: ?*?*ISchedule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IScheduleCollection,
            ienum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IScheduleCollection,
            pSchedule: ?*ISchedule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IScheduleCollection,
            vSchedule: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IScheduleCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IScheduleCollection,
            pSchedules: ?*IScheduleCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSchedule: fn(
            self: *const IScheduleCollection,
            Schedule: ?*?*ISchedule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_get_Count(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).get_Count(@ptrCast(*const IScheduleCollection, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_get_Item(self: *const T, index: VARIANT, ppSchedule: ?*?*ISchedule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).get_Item(@ptrCast(*const IScheduleCollection, self), index, ppSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_get__NewEnum(self: *const T, ienum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IScheduleCollection, self), ienum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_Add(self: *const T, pSchedule: ?*ISchedule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).Add(@ptrCast(*const IScheduleCollection, self), pSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_Remove(self: *const T, vSchedule: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).Remove(@ptrCast(*const IScheduleCollection, self), vSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).Clear(@ptrCast(*const IScheduleCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_AddRange(self: *const T, pSchedules: ?*IScheduleCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).AddRange(@ptrCast(*const IScheduleCollection, self), pSchedules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduleCollection_CreateSchedule(self: *const T, Schedule: ?*?*ISchedule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduleCollection.VTable, self.vtable).CreateSchedule(@ptrCast(*const IScheduleCollection, self), Schedule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IValueMapItem_Value = @import("../zig.zig").Guid.initString("03837533-098b-11d8-9414-505054503030");
pub const IID_IValueMapItem = &IID_IValueMapItem_Value;
pub const IValueMapItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IValueMapItem,
            description: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IValueMapItem,
            description: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IValueMapItem,
            enabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IValueMapItem,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Key: fn(
            self: *const IValueMapItem,
            key: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Key: fn(
            self: *const IValueMapItem,
            key: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IValueMapItem,
            Value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IValueMapItem,
            Value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueMapType: fn(
            self: *const IValueMapItem,
            type: *ValueMapType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ValueMapType: fn(
            self: *const IValueMapItem,
            type: ValueMapType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_get_Description(self: *const T, description: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).get_Description(@ptrCast(*const IValueMapItem, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_put_Description(self: *const T, description: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).put_Description(@ptrCast(*const IValueMapItem, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_get_Enabled(self: *const T, enabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).get_Enabled(@ptrCast(*const IValueMapItem, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).put_Enabled(@ptrCast(*const IValueMapItem, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_get_Key(self: *const T, key: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).get_Key(@ptrCast(*const IValueMapItem, self), key);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_put_Key(self: *const T, key: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).put_Key(@ptrCast(*const IValueMapItem, self), key);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_get_Value(self: *const T, Value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).get_Value(@ptrCast(*const IValueMapItem, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_put_Value(self: *const T, Value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).put_Value(@ptrCast(*const IValueMapItem, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_get_ValueMapType(self: *const T, type: *ValueMapType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).get_ValueMapType(@ptrCast(*const IValueMapItem, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMapItem_put_ValueMapType(self: *const T, type: ValueMapType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMapItem.VTable, self.vtable).put_ValueMapType(@ptrCast(*const IValueMapItem, self), type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IValueMap_Value = @import("../zig.zig").Guid.initString("03837534-098b-11d8-9414-505054503030");
pub const IID_IValueMap = &IID_IValueMap_Value;
pub const IValueMap = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IValueMap,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IValueMap,
            index: VARIANT,
            value: ?*?*IValueMapItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IValueMap,
            retVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IValueMap,
            description: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IValueMap,
            description: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IValueMap,
            Value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IValueMap,
            Value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueMapType: fn(
            self: *const IValueMap,
            type: *ValueMapType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ValueMapType: fn(
            self: *const IValueMap,
            type: ValueMapType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IValueMap,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IValueMap,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRange: fn(
            self: *const IValueMap,
            map: ?*IValueMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateValueMapItem: fn(
            self: *const IValueMap,
            Item: ?*?*IValueMapItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get_Count(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get_Count(@ptrCast(*const IValueMap, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get_Item(self: *const T, index: VARIANT, value: ?*?*IValueMapItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get_Item(@ptrCast(*const IValueMap, self), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get__NewEnum(self: *const T, retVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get__NewEnum(@ptrCast(*const IValueMap, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get_Description(self: *const T, description: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get_Description(@ptrCast(*const IValueMap, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_put_Description(self: *const T, description: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).put_Description(@ptrCast(*const IValueMap, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get_Value(self: *const T, Value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get_Value(@ptrCast(*const IValueMap, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_put_Value(self: *const T, Value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).put_Value(@ptrCast(*const IValueMap, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_get_ValueMapType(self: *const T, type: *ValueMapType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).get_ValueMapType(@ptrCast(*const IValueMap, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_put_ValueMapType(self: *const T, type: ValueMapType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).put_ValueMapType(@ptrCast(*const IValueMap, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_Add(self: *const T, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).Add(@ptrCast(*const IValueMap, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_Remove(self: *const T, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).Remove(@ptrCast(*const IValueMap, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).Clear(@ptrCast(*const IValueMap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_AddRange(self: *const T, map: ?*IValueMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).AddRange(@ptrCast(*const IValueMap, self), map);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueMap_CreateValueMapItem(self: *const T, Item: ?*?*IValueMapItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueMap.VTable, self.vtable).CreateValueMapItem(@ptrCast(*const IValueMap, self), Item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const SAFEARRAY = @import("automation.zig").SAFEARRAY;
const PWSTR = @import("system_services.zig").PWSTR;
const VARIANT = @import("automation.zig").VARIANT;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const BSTR = @import("automation.zig").BSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PLA_CABEXTRACT_CALLBACK")) { _ = PLA_CABEXTRACT_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
