//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1020)
//--------------------------------------------------------------------------------
pub const MARSHALINTERFACE_MIN = @as(u32, 500);
pub const ASYNC_MODE_COMPATIBILITY = @as(i32, 1);
pub const ASYNC_MODE_DEFAULT = @as(i32, 0);
pub const STGTY_REPEAT = @as(i32, 256);
pub const STG_TOEND = @as(i32, -1);
pub const STG_LAYOUT_SEQUENTIAL = @as(i32, 0);
pub const STG_LAYOUT_INTERLEAVED = @as(i32, 1);
pub const PROPSETFLAG_DEFAULT = @as(u32, 0);
pub const PROPSETFLAG_NONSIMPLE = @as(u32, 1);
pub const PROPSETFLAG_ANSI = @as(u32, 2);
pub const PROPSETFLAG_UNBUFFERED = @as(u32, 4);
pub const PROPSETFLAG_CASE_SENSITIVE = @as(u32, 8);
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE = @as(u32, 1);
pub const PID_DICTIONARY = @as(u32, 0);
pub const PID_CODEPAGE = @as(u32, 1);
pub const PID_FIRST_NAME_DEFAULT = @as(u32, 4095);
pub const PID_LOCALE = @as(u32, 2147483648);
pub const PID_MODIFY_TIME = @as(u32, 2147483649);
pub const PID_SECURITY = @as(u32, 2147483650);
pub const PID_BEHAVIOR = @as(u32, 2147483651);
pub const PID_ILLEGAL = @as(u32, 4294967295);
pub const PID_MIN_READONLY = @as(u32, 2147483648);
pub const PID_MAX_READONLY = @as(u32, 3221225471);
pub const PRSPEC_INVALID = @as(u32, 4294967295);
pub const PROPSETHDR_OSVERSION_UNKNOWN = @as(u32, 4294967295);
pub const PIDDI_THUMBNAIL = @as(i32, 2);
pub const PIDSI_TITLE = @as(i32, 2);
pub const PIDSI_SUBJECT = @as(i32, 3);
pub const PIDSI_AUTHOR = @as(i32, 4);
pub const PIDSI_KEYWORDS = @as(i32, 5);
pub const PIDSI_COMMENTS = @as(i32, 6);
pub const PIDSI_TEMPLATE = @as(i32, 7);
pub const PIDSI_LASTAUTHOR = @as(i32, 8);
pub const PIDSI_REVNUMBER = @as(i32, 9);
pub const PIDSI_EDITTIME = @as(i32, 10);
pub const PIDSI_LASTPRINTED = @as(i32, 11);
pub const PIDSI_CREATE_DTM = @as(i32, 12);
pub const PIDSI_LASTSAVE_DTM = @as(i32, 13);
pub const PIDSI_PAGECOUNT = @as(i32, 14);
pub const PIDSI_WORDCOUNT = @as(i32, 15);
pub const PIDSI_CHARCOUNT = @as(i32, 16);
pub const PIDSI_THUMBNAIL = @as(i32, 17);
pub const PIDSI_APPNAME = @as(i32, 18);
pub const PIDSI_DOC_SECURITY = @as(i32, 19);
pub const PIDDSI_CATEGORY = @as(u32, 2);
pub const PIDDSI_PRESFORMAT = @as(u32, 3);
pub const PIDDSI_BYTECOUNT = @as(u32, 4);
pub const PIDDSI_LINECOUNT = @as(u32, 5);
pub const PIDDSI_PARCOUNT = @as(u32, 6);
pub const PIDDSI_SLIDECOUNT = @as(u32, 7);
pub const PIDDSI_NOTECOUNT = @as(u32, 8);
pub const PIDDSI_HIDDENCOUNT = @as(u32, 9);
pub const PIDDSI_MMCLIPCOUNT = @as(u32, 10);
pub const PIDDSI_SCALE = @as(u32, 11);
pub const PIDDSI_HEADINGPAIR = @as(u32, 12);
pub const PIDDSI_DOCPARTS = @as(u32, 13);
pub const PIDDSI_MANAGER = @as(u32, 14);
pub const PIDDSI_COMPANY = @as(u32, 15);
pub const PIDDSI_LINKSDIRTY = @as(u32, 16);
pub const PIDMSI_EDITOR = @as(i32, 2);
pub const PIDMSI_SUPPLIER = @as(i32, 3);
pub const PIDMSI_SOURCE = @as(i32, 4);
pub const PIDMSI_SEQUENCE_NO = @as(i32, 5);
pub const PIDMSI_PROJECT = @as(i32, 6);
pub const PIDMSI_STATUS = @as(i32, 7);
pub const PIDMSI_OWNER = @as(i32, 8);
pub const PIDMSI_RATING = @as(i32, 9);
pub const PIDMSI_PRODUCTION = @as(i32, 10);
pub const PIDMSI_COPYRIGHT = @as(i32, 11);
pub const CWCSTORAGENAME = @as(u32, 32);
pub const STGM_DIRECT = @as(i32, 0);
pub const STGM_TRANSACTED = @as(i32, 65536);
pub const STGM_SIMPLE = @as(i32, 134217728);
pub const STGM_READ = @as(i32, 0);
pub const STGM_WRITE = @as(i32, 1);
pub const STGM_READWRITE = @as(i32, 2);
pub const STGM_SHARE_DENY_NONE = @as(i32, 64);
pub const STGM_SHARE_DENY_READ = @as(i32, 48);
pub const STGM_SHARE_DENY_WRITE = @as(i32, 32);
pub const STGM_SHARE_EXCLUSIVE = @as(i32, 16);
pub const STGM_PRIORITY = @as(i32, 262144);
pub const STGM_DELETEONRELEASE = @as(i32, 67108864);
pub const STGM_NOSCRATCH = @as(i32, 1048576);
pub const STGM_CREATE = @as(i32, 4096);
pub const STGM_CONVERT = @as(i32, 131072);
pub const STGM_FAILIFTHERE = @as(i32, 0);
pub const STGM_NOSNAPSHOT = @as(i32, 2097152);
pub const STGM_DIRECT_SWMR = @as(i32, 4194304);
pub const STGFMT_STORAGE = @as(u32, 0);
pub const STGFMT_NATIVE = @as(u32, 1);
pub const STGFMT_FILE = @as(u32, 3);
pub const STGFMT_ANY = @as(u32, 4);
pub const STGFMT_DOCFILE = @as(u32, 5);
pub const STGFMT_DOCUMENT = @as(u32, 0);
pub const STGOPTIONS_VERSION = @as(u32, 1);
pub const CCH_MAX_PROPSTG_NAME = @as(u32, 31);
pub const JET_bitConfigStoreReadControlInhibitRead = @as(u32, 1);
pub const JET_bitConfigStoreReadControlDisableAll = @as(u32, 2);
pub const JET_bitConfigStoreReadControlDefault = @as(u32, 0);
pub const JET_bitDefragmentBatchStart = @as(u32, 1);
pub const JET_bitDefragmentBatchStop = @as(u32, 2);
pub const JET_bitDefragmentAvailSpaceTreesOnly = @as(u32, 64);
pub const JET_bitDefragmentNoPartialMerges = @as(u32, 128);
pub const JET_bitDefragmentBTree = @as(u32, 256);
pub const JET_cbtypNull = @as(u32, 0);
pub const JET_cbtypFinalize = @as(u32, 1);
pub const JET_cbtypBeforeInsert = @as(u32, 2);
pub const JET_cbtypAfterInsert = @as(u32, 4);
pub const JET_cbtypBeforeReplace = @as(u32, 8);
pub const JET_cbtypAfterReplace = @as(u32, 16);
pub const JET_cbtypBeforeDelete = @as(u32, 32);
pub const JET_cbtypAfterDelete = @as(u32, 64);
pub const JET_cbtypUserDefinedDefaultValue = @as(u32, 128);
pub const JET_cbtypOnlineDefragCompleted = @as(u32, 256);
pub const JET_cbtypFreeCursorLS = @as(u32, 512);
pub const JET_cbtypFreeTableLS = @as(u32, 1024);
pub const JET_bitTableInfoUpdatable = @as(u32, 1);
pub const JET_bitTableInfoBookmark = @as(u32, 2);
pub const JET_bitTableInfoRollback = @as(u32, 4);
pub const JET_bitObjectSystem = @as(u32, 2147483648);
pub const JET_bitObjectTableFixedDDL = @as(u32, 1073741824);
pub const JET_bitObjectTableTemplate = @as(u32, 536870912);
pub const JET_bitObjectTableDerived = @as(u32, 268435456);
pub const JET_bitObjectTableNoFixedVarColumnsInDerivedTables = @as(u32, 67108864);
pub const JET_MAX_COMPUTERNAME_LENGTH = @as(u32, 15);
pub const JET_bitDurableCommitCallbackLogUnavailable = @as(u32, 1);
pub const JET_cbBookmarkMost = @as(u32, 256);
pub const JET_cbNameMost = @as(u32, 64);
pub const JET_cbFullNameMost = @as(u32, 255);
pub const JET_cbColumnLVPageOverhead = @as(u32, 82);
pub const JET_cbLVDefaultValueMost = @as(u32, 255);
pub const JET_cbColumnMost = @as(u32, 255);
pub const JET_cbLVColumnMost = @as(u32, 2147483647);
pub const JET_cbKeyMost8KBytePage = @as(u32, 2000);
pub const JET_cbKeyMost4KBytePage = @as(u32, 1000);
pub const JET_cbKeyMost2KBytePage = @as(u32, 500);
pub const JET_cbKeyMostMin = @as(u32, 255);
pub const JET_cbKeyMost = @as(u32, 255);
pub const JET_cbLimitKeyMost = @as(u32, 256);
pub const JET_cbPrimaryKeyMost = @as(u32, 255);
pub const JET_cbSecondaryKeyMost = @as(u32, 255);
pub const JET_ccolKeyMost = @as(u32, 16);
pub const JET_ccolMost = @as(u32, 65248);
pub const JET_ccolFixedMost = @as(u32, 127);
pub const JET_ccolVarMost = @as(u32, 128);
pub const JET_EventLoggingDisable = @as(u32, 0);
pub const JET_EventLoggingLevelMin = @as(u32, 1);
pub const JET_EventLoggingLevelLow = @as(u32, 25);
pub const JET_EventLoggingLevelMedium = @as(u32, 50);
pub const JET_EventLoggingLevelHigh = @as(u32, 75);
pub const JET_EventLoggingLevelMax = @as(u32, 100);
pub const JET_IOPriorityNormal = @as(u32, 0);
pub const JET_IOPriorityLow = @as(u32, 1);
pub const JET_configDefault = @as(u32, 1);
pub const JET_configRemoveQuotas = @as(u32, 2);
pub const JET_configLowDiskFootprint = @as(u32, 4);
pub const JET_configMediumDiskFootprint = @as(u32, 8);
pub const JET_configLowMemory = @as(u32, 16);
pub const JET_configDynamicMediumMemory = @as(u32, 32);
pub const JET_configLowPower = @as(u32, 64);
pub const JET_configSSDProfileIO = @as(u32, 128);
pub const JET_configRunSilent = @as(u32, 256);
pub const JET_configUnthrottledMemory = @as(u32, 512);
pub const JET_configHighConcurrencyScaling = @as(u32, 1024);
pub const JET_paramSystemPath = @as(u32, 0);
pub const JET_paramTempPath = @as(u32, 1);
pub const JET_paramLogFilePath = @as(u32, 2);
pub const JET_paramBaseName = @as(u32, 3);
pub const JET_paramEventSource = @as(u32, 4);
pub const JET_paramMaxSessions = @as(u32, 5);
pub const JET_paramMaxOpenTables = @as(u32, 6);
pub const JET_paramPreferredMaxOpenTables = @as(u32, 7);
pub const JET_paramCachedClosedTables = @as(u32, 125);
pub const JET_paramMaxCursors = @as(u32, 8);
pub const JET_paramMaxVerPages = @as(u32, 9);
pub const JET_paramPreferredVerPages = @as(u32, 63);
pub const JET_paramGlobalMinVerPages = @as(u32, 81);
pub const JET_paramVersionStoreTaskQueueMax = @as(u32, 105);
pub const JET_paramMaxTemporaryTables = @as(u32, 10);
pub const JET_paramLogFileSize = @as(u32, 11);
pub const JET_paramLogBuffers = @as(u32, 12);
pub const JET_paramWaitLogFlush = @as(u32, 13);
pub const JET_paramLogCheckpointPeriod = @as(u32, 14);
pub const JET_paramLogWaitingUserMax = @as(u32, 15);
pub const JET_paramCommitDefault = @as(u32, 16);
pub const JET_paramCircularLog = @as(u32, 17);
pub const JET_paramDbExtensionSize = @as(u32, 18);
pub const JET_paramPageTempDBMin = @as(u32, 19);
pub const JET_paramPageFragment = @as(u32, 20);
pub const JET_paramEnableFileCache = @as(u32, 126);
pub const JET_paramVerPageSize = @as(u32, 128);
pub const JET_paramConfiguration = @as(u32, 129);
pub const JET_paramEnableAdvanced = @as(u32, 130);
pub const JET_paramMaxColtyp = @as(u32, 131);
pub const JET_paramBatchIOBufferMax = @as(u32, 22);
pub const JET_paramCacheSize = @as(u32, 41);
pub const JET_paramCacheSizeMin = @as(u32, 60);
pub const JET_paramCacheSizeMax = @as(u32, 23);
pub const JET_paramCheckpointDepthMax = @as(u32, 24);
pub const JET_paramLRUKCorrInterval = @as(u32, 25);
pub const JET_paramLRUKHistoryMax = @as(u32, 26);
pub const JET_paramLRUKPolicy = @as(u32, 27);
pub const JET_paramLRUKTimeout = @as(u32, 28);
pub const JET_paramLRUKTrxCorrInterval = @as(u32, 29);
pub const JET_paramOutstandingIOMax = @as(u32, 30);
pub const JET_paramStartFlushThreshold = @as(u32, 31);
pub const JET_paramStopFlushThreshold = @as(u32, 32);
pub const JET_paramEnableViewCache = @as(u32, 127);
pub const JET_paramCheckpointIOMax = @as(u32, 135);
pub const JET_paramTableClass1Name = @as(u32, 137);
pub const JET_paramTableClass2Name = @as(u32, 138);
pub const JET_paramTableClass3Name = @as(u32, 139);
pub const JET_paramTableClass4Name = @as(u32, 140);
pub const JET_paramTableClass5Name = @as(u32, 141);
pub const JET_paramTableClass6Name = @as(u32, 142);
pub const JET_paramTableClass7Name = @as(u32, 143);
pub const JET_paramTableClass8Name = @as(u32, 144);
pub const JET_paramTableClass9Name = @as(u32, 145);
pub const JET_paramTableClass10Name = @as(u32, 146);
pub const JET_paramTableClass11Name = @as(u32, 147);
pub const JET_paramTableClass12Name = @as(u32, 148);
pub const JET_paramTableClass13Name = @as(u32, 149);
pub const JET_paramTableClass14Name = @as(u32, 150);
pub const JET_paramTableClass15Name = @as(u32, 151);
pub const JET_paramIOPriority = @as(u32, 152);
pub const JET_paramRecovery = @as(u32, 34);
pub const JET_paramEnableOnlineDefrag = @as(u32, 35);
pub const JET_paramCheckFormatWhenOpenFail = @as(u32, 44);
pub const JET_paramEnableTempTableVersioning = @as(u32, 46);
pub const JET_paramIgnoreLogVersion = @as(u32, 47);
pub const JET_paramDeleteOldLogs = @as(u32, 48);
pub const JET_paramEventSourceKey = @as(u32, 49);
pub const JET_paramNoInformationEvent = @as(u32, 50);
pub const JET_paramEventLoggingLevel = @as(u32, 51);
pub const JET_paramDeleteOutOfRangeLogs = @as(u32, 52);
pub const JET_paramAccessDeniedRetryPeriod = @as(u32, 53);
pub const JET_paramEnableIndexChecking = @as(u32, 45);
pub const JET_paramEnableIndexCleanup = @as(u32, 54);
pub const JET_paramDatabasePageSize = @as(u32, 64);
pub const JET_paramDisableCallbacks = @as(u32, 65);
pub const JET_paramLogFileCreateAsynch = @as(u32, 69);
pub const JET_paramErrorToString = @as(u32, 70);
pub const JET_paramZeroDatabaseDuringBackup = @as(u32, 71);
pub const JET_paramUnicodeIndexDefault = @as(u32, 72);
pub const JET_paramRuntimeCallback = @as(u32, 73);
pub const JET_paramCleanupMismatchedLogFiles = @as(u32, 77);
pub const JET_paramRecordUpgradeDirtyLevel = @as(u32, 78);
pub const JET_paramOSSnapshotTimeout = @as(u32, 82);
pub const JET_paramExceptionAction = @as(u32, 98);
pub const JET_paramEventLogCache = @as(u32, 99);
pub const JET_paramCreatePathIfNotExist = @as(u32, 100);
pub const JET_paramPageHintCacheSize = @as(u32, 101);
pub const JET_paramOneDatabasePerSession = @as(u32, 102);
pub const JET_paramMaxInstances = @as(u32, 104);
pub const JET_paramDisablePerfmon = @as(u32, 107);
pub const JET_paramIndexTuplesLengthMin = @as(u32, 110);
pub const JET_paramIndexTuplesLengthMax = @as(u32, 111);
pub const JET_paramIndexTuplesToIndexMax = @as(u32, 112);
pub const JET_paramAlternateDatabaseRecoveryPath = @as(u32, 113);
pub const JET_paramIndexTupleIncrement = @as(u32, 132);
pub const JET_paramIndexTupleStart = @as(u32, 133);
pub const JET_paramKeyMost = @as(u32, 134);
pub const JET_paramLegacyFileNames = @as(u32, 136);
pub const JET_paramEnablePersistedCallbacks = @as(u32, 156);
pub const JET_paramWaypointLatency = @as(u32, 153);
pub const JET_paramDefragmentSequentialBTrees = @as(u32, 160);
pub const JET_paramDefragmentSequentialBTreesDensityCheckFrequency = @as(u32, 161);
pub const JET_paramIOThrottlingTimeQuanta = @as(u32, 162);
pub const JET_paramLVChunkSizeMost = @as(u32, 163);
pub const JET_paramMaxCoalesceReadSize = @as(u32, 164);
pub const JET_paramMaxCoalesceWriteSize = @as(u32, 165);
pub const JET_paramMaxCoalesceReadGapSize = @as(u32, 166);
pub const JET_paramMaxCoalesceWriteGapSize = @as(u32, 167);
pub const JET_paramEnableDBScanInRecovery = @as(u32, 169);
pub const JET_paramDbScanThrottle = @as(u32, 170);
pub const JET_paramDbScanIntervalMinSec = @as(u32, 171);
pub const JET_paramDbScanIntervalMaxSec = @as(u32, 172);
pub const JET_paramCachePriority = @as(u32, 177);
pub const JET_paramMaxTransactionSize = @as(u32, 178);
pub const JET_paramPrereadIOMax = @as(u32, 179);
pub const JET_paramEnableDBScanSerialization = @as(u32, 180);
pub const JET_paramHungIOThreshold = @as(u32, 181);
pub const JET_paramHungIOActions = @as(u32, 182);
pub const JET_paramMinDataForXpress = @as(u32, 183);
pub const JET_paramEnableShrinkDatabase = @as(u32, 184);
pub const JET_paramProcessFriendlyName = @as(u32, 186);
pub const JET_paramDurableCommitCallback = @as(u32, 187);
pub const JET_paramEnableSqm = @as(u32, 188);
pub const JET_paramConfigStoreSpec = @as(u32, 189);
pub const JET_paramMaxValueInvalid = @as(u32, 212);
pub const JET_sesparamCommitDefault = @as(u32, 4097);
pub const JET_sesparamTransactionLevel = @as(u32, 4099);
pub const JET_sesparamOperationContext = @as(u32, 4100);
pub const JET_sesparamCorrelationID = @as(u32, 4101);
pub const JET_sesparamMaxValueInvalid = @as(u32, 4109);
pub const JET_bitESE98FileNames = @as(u32, 1);
pub const JET_bitEightDotThreeSoftCompat = @as(u32, 2);
pub const JET_bitHungIOEvent = @as(u32, 1);
pub const JET_bitShrinkDatabaseOff = @as(u32, 0);
pub const JET_bitShrinkDatabaseOn = @as(u32, 1);
pub const JET_bitShrinkDatabaseRealtime = @as(u32, 2);
pub const JET_bitShrinkDatabaseTrim = @as(u32, 1);
pub const JET_bitReplayIgnoreMissingDB = @as(u32, 4);
pub const JET_bitRecoveryWithoutUndo = @as(u32, 8);
pub const JET_bitTruncateLogsAfterRecovery = @as(u32, 16);
pub const JET_bitReplayMissingMapEntryDB = @as(u32, 32);
pub const JET_bitLogStreamMustExist = @as(u32, 64);
pub const JET_bitReplayIgnoreLostLogs = @as(u32, 128);
pub const JET_bitKeepDbAttachedAtEndOfRecovery = @as(u32, 4096);
pub const JET_bitTermComplete = @as(u32, 1);
pub const JET_bitTermAbrupt = @as(u32, 2);
pub const JET_bitTermStopBackup = @as(u32, 4);
pub const JET_bitTermDirty = @as(u32, 8);
pub const JET_bitIdleFlushBuffers = @as(u32, 1);
pub const JET_bitIdleCompact = @as(u32, 2);
pub const JET_bitIdleStatus = @as(u32, 4);
pub const JET_bitDbReadOnly = @as(u32, 1);
pub const JET_bitDbExclusive = @as(u32, 2);
pub const JET_bitDbDeleteCorruptIndexes = @as(u32, 16);
pub const JET_bitDbDeleteUnicodeIndexes = @as(u32, 1024);
pub const JET_bitDbUpgrade = @as(u32, 512);
pub const JET_bitDbEnableBackgroundMaintenance = @as(u32, 2048);
pub const JET_bitDbPurgeCacheOnAttach = @as(u32, 4096);
pub const JET_bitForceDetach = @as(u32, 1);
pub const JET_bitDbRecoveryOff = @as(u32, 8);
pub const JET_bitDbShadowingOff = @as(u32, 128);
pub const JET_bitDbOverwriteExisting = @as(u32, 512);
pub const JET_bitBackupIncremental = @as(u32, 1);
pub const JET_bitBackupAtomic = @as(u32, 4);
pub const JET_bitBackupSnapshot = @as(u32, 16);
pub const JET_bitBackupEndNormal = @as(u32, 1);
pub const JET_bitBackupEndAbort = @as(u32, 2);
pub const JET_bitBackupTruncateDone = @as(u32, 256);
pub const JET_bitTableCreateFixedDDL = @as(u32, 1);
pub const JET_bitTableCreateTemplateTable = @as(u32, 2);
pub const JET_bitTableCreateNoFixedVarColumnsInDerivedTables = @as(u32, 4);
pub const JET_bitTableCreateImmutableStructure = @as(u32, 8);
pub const JET_bitColumnFixed = @as(u32, 1);
pub const JET_bitColumnTagged = @as(u32, 2);
pub const JET_bitColumnNotNULL = @as(u32, 4);
pub const JET_bitColumnVersion = @as(u32, 8);
pub const JET_bitColumnAutoincrement = @as(u32, 16);
pub const JET_bitColumnUpdatable = @as(u32, 32);
pub const JET_bitColumnTTKey = @as(u32, 64);
pub const JET_bitColumnTTDescending = @as(u32, 128);
pub const JET_bitColumnMultiValued = @as(u32, 1024);
pub const JET_bitColumnEscrowUpdate = @as(u32, 2048);
pub const JET_bitColumnUnversioned = @as(u32, 4096);
pub const JET_bitColumnMaybeNull = @as(u32, 8192);
pub const JET_bitColumnFinalize = @as(u32, 16384);
pub const JET_bitColumnUserDefinedDefault = @as(u32, 32768);
pub const JET_bitColumnDeleteOnZero = @as(u32, 131072);
pub const JET_bitColumnCompressed = @as(u32, 524288);
pub const JET_bitDeleteColumnIgnoreTemplateColumns = @as(u32, 1);
pub const JET_bitMoveFirst = @as(u32, 0);
pub const JET_bitNoMove = @as(u32, 2);
pub const JET_bitNewKey = @as(u32, 1);
pub const JET_bitStrLimit = @as(u32, 2);
pub const JET_bitSubStrLimit = @as(u32, 4);
pub const JET_bitNormalizedKey = @as(u32, 8);
pub const JET_bitKeyDataZeroLength = @as(u32, 16);
pub const JET_bitFullColumnStartLimit = @as(u32, 256);
pub const JET_bitFullColumnEndLimit = @as(u32, 512);
pub const JET_bitPartialColumnStartLimit = @as(u32, 1024);
pub const JET_bitPartialColumnEndLimit = @as(u32, 2048);
pub const JET_bitRangeInclusive = @as(u32, 1);
pub const JET_bitRangeUpperLimit = @as(u32, 2);
pub const JET_bitRangeInstantDuration = @as(u32, 4);
pub const JET_bitRangeRemove = @as(u32, 8);
pub const JET_bitReadLock = @as(u32, 1);
pub const JET_bitWriteLock = @as(u32, 2);
pub const JET_MoveFirst = @as(u32, 2147483648);
pub const JET_MovePrevious = @as(i32, -1);
pub const JET_MoveLast = @as(u32, 2147483647);
pub const JET_bitMoveKeyNE = @as(u32, 1);
pub const JET_bitSeekEQ = @as(u32, 1);
pub const JET_bitSeekLT = @as(u32, 2);
pub const JET_bitSeekLE = @as(u32, 4);
pub const JET_bitSeekGE = @as(u32, 8);
pub const JET_bitSeekGT = @as(u32, 16);
pub const JET_bitSetIndexRange = @as(u32, 32);
pub const JET_bitCheckUniqueness = @as(u32, 64);
pub const JET_bitBookmarkPermitVirtualCurrency = @as(u32, 1);
pub const JET_bitIndexColumnMustBeNull = @as(u32, 1);
pub const JET_bitIndexColumnMustBeNonNull = @as(u32, 2);
pub const JET_bitRecordInIndex = @as(u32, 1);
pub const JET_bitRecordNotInIndex = @as(u32, 2);
pub const JET_bitIndexUnique = @as(u32, 1);
pub const JET_bitIndexPrimary = @as(u32, 2);
pub const JET_bitIndexDisallowNull = @as(u32, 4);
pub const JET_bitIndexIgnoreNull = @as(u32, 8);
pub const JET_bitIndexIgnoreAnyNull = @as(u32, 32);
pub const JET_bitIndexIgnoreFirstNull = @as(u32, 64);
pub const JET_bitIndexLazyFlush = @as(u32, 128);
pub const JET_bitIndexEmpty = @as(u32, 256);
pub const JET_bitIndexUnversioned = @as(u32, 512);
pub const JET_bitIndexSortNullsHigh = @as(u32, 1024);
pub const JET_bitIndexUnicode = @as(u32, 2048);
pub const JET_bitIndexTuples = @as(u32, 4096);
pub const JET_bitIndexTupleLimits = @as(u32, 8192);
pub const JET_bitIndexCrossProduct = @as(u32, 16384);
pub const JET_bitIndexKeyMost = @as(u32, 32768);
pub const JET_bitIndexDisallowTruncation = @as(u32, 65536);
pub const JET_bitIndexNestedTable = @as(u32, 131072);
pub const JET_bitIndexDotNetGuid = @as(u32, 262144);
pub const JET_bitIndexImmutableStructure = @as(u32, 524288);
pub const JET_bitKeyAscending = @as(u32, 0);
pub const JET_bitKeyDescending = @as(u32, 1);
pub const JET_bitTableDenyWrite = @as(u32, 1);
pub const JET_bitTableDenyRead = @as(u32, 2);
pub const JET_bitTableReadOnly = @as(u32, 4);
pub const JET_bitTableUpdatable = @as(u32, 8);
pub const JET_bitTablePermitDDL = @as(u32, 16);
pub const JET_bitTableNoCache = @as(u32, 32);
pub const JET_bitTablePreread = @as(u32, 64);
pub const JET_bitTableOpportuneRead = @as(u32, 128);
pub const JET_bitTableSequential = @as(u32, 32768);
pub const JET_bitTableClassMask = @as(u32, 2031616);
pub const JET_bitTableClassNone = @as(u32, 0);
pub const JET_bitTableClass1 = @as(u32, 65536);
pub const JET_bitTableClass2 = @as(u32, 131072);
pub const JET_bitTableClass3 = @as(u32, 196608);
pub const JET_bitTableClass4 = @as(u32, 262144);
pub const JET_bitTableClass5 = @as(u32, 327680);
pub const JET_bitTableClass6 = @as(u32, 393216);
pub const JET_bitTableClass7 = @as(u32, 458752);
pub const JET_bitTableClass8 = @as(u32, 524288);
pub const JET_bitTableClass9 = @as(u32, 589824);
pub const JET_bitTableClass10 = @as(u32, 655360);
pub const JET_bitTableClass11 = @as(u32, 720896);
pub const JET_bitTableClass12 = @as(u32, 786432);
pub const JET_bitTableClass13 = @as(u32, 851968);
pub const JET_bitTableClass14 = @as(u32, 917504);
pub const JET_bitTableClass15 = @as(u32, 983040);
pub const JET_bitLSReset = @as(u32, 1);
pub const JET_bitLSCursor = @as(u32, 2);
pub const JET_bitLSTable = @as(u32, 4);
pub const JET_bitPrereadForward = @as(u32, 1);
pub const JET_bitPrereadBackward = @as(u32, 2);
pub const JET_bitPrereadFirstPage = @as(u32, 4);
pub const JET_bitPrereadNormalizedKey = @as(u32, 8);
pub const JET_bitTTIndexed = @as(u32, 1);
pub const JET_bitTTUnique = @as(u32, 2);
pub const JET_bitTTUpdatable = @as(u32, 4);
pub const JET_bitTTScrollable = @as(u32, 8);
pub const JET_bitTTSortNullsHigh = @as(u32, 16);
pub const JET_bitTTForceMaterialization = @as(u32, 32);
pub const JET_bitTTForwardOnly = @as(u32, 64);
pub const JET_bitTTIntrinsicLVsOnly = @as(u32, 128);
pub const JET_bitTTDotNetGuid = @as(u32, 256);
pub const JET_bitSetAppendLV = @as(u32, 1);
pub const JET_bitSetOverwriteLV = @as(u32, 4);
pub const JET_bitSetSizeLV = @as(u32, 8);
pub const JET_bitSetZeroLength = @as(u32, 32);
pub const JET_bitSetSeparateLV = @as(u32, 64);
pub const JET_bitSetUniqueMultiValues = @as(u32, 128);
pub const JET_bitSetUniqueNormalizedMultiValues = @as(u32, 256);
pub const JET_bitSetRevertToDefaultValue = @as(u32, 512);
pub const JET_bitSetIntrinsicLV = @as(u32, 1024);
pub const JET_bitSetUncompressed = @as(u32, 65536);
pub const JET_bitSetCompressed = @as(u32, 131072);
pub const JET_bitSetContiguousLV = @as(u32, 262144);
pub const JET_bitSpaceHintsUtilizeParentSpace = @as(u32, 1);
pub const JET_bitCreateHintAppendSequential = @as(u32, 2);
pub const JET_bitCreateHintHotpointSequential = @as(u32, 4);
pub const JET_bitRetrieveHintReserve1 = @as(u32, 8);
pub const JET_bitRetrieveHintTableScanForward = @as(u32, 16);
pub const JET_bitRetrieveHintTableScanBackward = @as(u32, 32);
pub const JET_bitRetrieveHintReserve2 = @as(u32, 64);
pub const JET_bitRetrieveHintReserve3 = @as(u32, 128);
pub const JET_bitDeleteHintTableSequential = @as(u32, 256);
pub const JET_prepInsert = @as(u32, 0);
pub const JET_prepReplace = @as(u32, 2);
pub const JET_prepCancel = @as(u32, 3);
pub const JET_prepReplaceNoLock = @as(u32, 4);
pub const JET_prepInsertCopy = @as(u32, 5);
pub const JET_prepInsertCopyDeleteOriginal = @as(u32, 7);
pub const JET_prepInsertCopyReplaceOriginal = @as(u32, 9);
pub const JET_sqmDisable = @as(u32, 0);
pub const JET_sqmEnable = @as(u32, 1);
pub const JET_sqmFromCEIP = @as(u32, 2);
pub const JET_bitUpdateCheckESE97Compatibility = @as(u32, 1);
pub const JET_bitEscrowNoRollback = @as(u32, 1);
pub const JET_bitRetrieveCopy = @as(u32, 1);
pub const JET_bitRetrieveFromIndex = @as(u32, 2);
pub const JET_bitRetrieveFromPrimaryBookmark = @as(u32, 4);
pub const JET_bitRetrieveTag = @as(u32, 8);
pub const JET_bitRetrieveNull = @as(u32, 16);
pub const JET_bitRetrieveIgnoreDefault = @as(u32, 32);
pub const JET_bitRetrieveTuple = @as(u32, 2048);
pub const JET_bitZeroLength = @as(u32, 1);
pub const JET_bitEnumeratePresenceOnly = @as(u32, 131072);
pub const JET_bitEnumerateTaggedOnly = @as(u32, 262144);
pub const JET_bitEnumerateCompressOutput = @as(u32, 524288);
pub const JET_bitEnumerateIgnoreUserDefinedDefault = @as(u32, 1048576);
pub const JET_bitEnumerateInRecordOnly = @as(u32, 2097152);
pub const JET_bitRecordSizeInCopyBuffer = @as(u32, 1);
pub const JET_bitRecordSizeRunningTotal = @as(u32, 2);
pub const JET_bitRecordSizeLocal = @as(u32, 4);
pub const JET_bitTransactionReadOnly = @as(u32, 1);
pub const JET_bitCommitLazyFlush = @as(u32, 1);
pub const JET_bitWaitLastLevel0Commit = @as(u32, 2);
pub const JET_bitWaitAllLevel0Commit = @as(u32, 8);
pub const JET_bitForceNewLog = @as(u32, 16);
pub const JET_bitRollbackAll = @as(u32, 1);
pub const JET_bitIncrementalSnapshot = @as(u32, 1);
pub const JET_bitCopySnapshot = @as(u32, 2);
pub const JET_bitContinueAfterThaw = @as(u32, 4);
pub const JET_bitExplicitPrepare = @as(u32, 8);
pub const JET_bitAllDatabasesSnapshot = @as(u32, 1);
pub const JET_bitAbortSnapshot = @as(u32, 1);
pub const JET_DbInfoFilename = @as(u32, 0);
pub const JET_DbInfoConnect = @as(u32, 1);
pub const JET_DbInfoCountry = @as(u32, 2);
pub const JET_DbInfoLCID = @as(u32, 3);
pub const JET_DbInfoLangid = @as(u32, 3);
pub const JET_DbInfoCp = @as(u32, 4);
pub const JET_DbInfoCollate = @as(u32, 5);
pub const JET_DbInfoOptions = @as(u32, 6);
pub const JET_DbInfoTransactions = @as(u32, 7);
pub const JET_DbInfoVersion = @as(u32, 8);
pub const JET_DbInfoIsam = @as(u32, 9);
pub const JET_DbInfoFilesize = @as(u32, 10);
pub const JET_DbInfoSpaceOwned = @as(u32, 11);
pub const JET_DbInfoSpaceAvailable = @as(u32, 12);
pub const JET_DbInfoUpgrade = @as(u32, 13);
pub const JET_DbInfoMisc = @as(u32, 14);
pub const JET_DbInfoDBInUse = @as(u32, 15);
pub const JET_DbInfoPageSize = @as(u32, 17);
pub const JET_DbInfoFileType = @as(u32, 19);
pub const JET_DbInfoFilesizeOnDisk = @as(u32, 21);
pub const JET_dbstateJustCreated = @as(u32, 1);
pub const JET_dbstateDirtyShutdown = @as(u32, 2);
pub const JET_dbstateCleanShutdown = @as(u32, 3);
pub const JET_dbstateBeingConverted = @as(u32, 4);
pub const JET_dbstateForceDetach = @as(u32, 5);
pub const JET_filetypeUnknown = @as(u32, 0);
pub const JET_filetypeDatabase = @as(u32, 1);
pub const JET_filetypeLog = @as(u32, 3);
pub const JET_filetypeCheckpoint = @as(u32, 4);
pub const JET_filetypeTempDatabase = @as(u32, 5);
pub const JET_filetypeFlushMap = @as(u32, 7);
pub const JET_coltypNil = @as(u32, 0);
pub const JET_coltypBit = @as(u32, 1);
pub const JET_coltypUnsignedByte = @as(u32, 2);
pub const JET_coltypShort = @as(u32, 3);
pub const JET_coltypLong = @as(u32, 4);
pub const JET_coltypCurrency = @as(u32, 5);
pub const JET_coltypIEEESingle = @as(u32, 6);
pub const JET_coltypIEEEDouble = @as(u32, 7);
pub const JET_coltypDateTime = @as(u32, 8);
pub const JET_coltypBinary = @as(u32, 9);
pub const JET_coltypText = @as(u32, 10);
pub const JET_coltypLongBinary = @as(u32, 11);
pub const JET_coltypLongText = @as(u32, 12);
pub const JET_coltypMax = @as(u32, 13);
pub const JET_coltypSLV = @as(u32, 13);
pub const JET_coltypUnsignedLong = @as(u32, 14);
pub const JET_coltypLongLong = @as(u32, 15);
pub const JET_coltypGUID = @as(u32, 16);
pub const JET_coltypUnsignedShort = @as(u32, 17);
pub const JET_coltypUnsignedLongLong = @as(u32, 18);
pub const JET_ColInfoGrbitNonDerivedColumnsOnly = @as(u32, 2147483648);
pub const JET_ColInfoGrbitMinimalInfo = @as(u32, 1073741824);
pub const JET_ColInfoGrbitSortByColumnid = @as(u32, 536870912);
pub const JET_objtypNil = @as(u32, 0);
pub const JET_objtypTable = @as(u32, 1);
pub const JET_bitCompactStats = @as(u32, 32);
pub const JET_bitCompactRepair = @as(u32, 64);
pub const JET_snpRepair = @as(u32, 2);
pub const JET_snpCompact = @as(u32, 4);
pub const JET_snpRestore = @as(u32, 8);
pub const JET_snpBackup = @as(u32, 9);
pub const JET_snpUpgrade = @as(u32, 10);
pub const JET_snpScrub = @as(u32, 11);
pub const JET_snpUpgradeRecordFormat = @as(u32, 12);
pub const JET_sntBegin = @as(u32, 5);
pub const JET_sntRequirements = @as(u32, 7);
pub const JET_sntProgress = @as(u32, 0);
pub const JET_sntComplete = @as(u32, 6);
pub const JET_sntFail = @as(u32, 3);
pub const JET_ExceptionMsgBox = @as(u32, 1);
pub const JET_ExceptionNone = @as(u32, 2);
pub const JET_ExceptionFailFast = @as(u32, 4);
pub const JET_OnlineDefragDisable = @as(u32, 0);
pub const JET_OnlineDefragAllOBSOLETE = @as(u32, 1);
pub const JET_OnlineDefragDatabases = @as(u32, 2);
pub const JET_OnlineDefragSpaceTrees = @as(u32, 4);
pub const JET_OnlineDefragAll = @as(u32, 65535);
pub const JET_bitResizeDatabaseOnlyGrow = @as(u32, 1);
pub const JET_bitResizeDatabaseOnlyShrink = @as(u32, 2);
pub const JET_bitStopServiceAll = @as(u32, 0);
pub const JET_bitStopServiceBackgroundUserTasks = @as(u32, 2);
pub const JET_bitStopServiceQuiesceCaches = @as(u32, 4);
pub const JET_bitStopServiceResume = @as(u32, 2147483648);
pub const JET_errSuccess = @as(u32, 0);
pub const JET_wrnNyi = @as(i32, -1);
pub const JET_errRfsFailure = @as(i32, -100);
pub const JET_errRfsNotArmed = @as(i32, -101);
pub const JET_errFileClose = @as(i32, -102);
pub const JET_errOutOfThreads = @as(i32, -103);
pub const JET_errTooManyIO = @as(i32, -105);
pub const JET_errTaskDropped = @as(i32, -106);
pub const JET_errInternalError = @as(i32, -107);
pub const JET_errDisabledFunctionality = @as(i32, -112);
pub const JET_errUnloadableOSFunctionality = @as(i32, -113);
pub const JET_errDatabaseBufferDependenciesCorrupted = @as(i32, -255);
pub const JET_wrnRemainingVersions = @as(u32, 321);
pub const JET_errPreviousVersion = @as(i32, -322);
pub const JET_errPageBoundary = @as(i32, -323);
pub const JET_errKeyBoundary = @as(i32, -324);
pub const JET_errBadPageLink = @as(i32, -327);
pub const JET_errBadBookmark = @as(i32, -328);
pub const JET_errNTSystemCallFailed = @as(i32, -334);
pub const JET_errBadParentPageLink = @as(i32, -338);
pub const JET_errSPAvailExtCacheOutOfSync = @as(i32, -340);
pub const JET_errSPAvailExtCorrupted = @as(i32, -341);
pub const JET_errSPAvailExtCacheOutOfMemory = @as(i32, -342);
pub const JET_errSPOwnExtCorrupted = @as(i32, -343);
pub const JET_errDbTimeCorrupted = @as(i32, -344);
pub const JET_wrnUniqueKey = @as(u32, 345);
pub const JET_errKeyTruncated = @as(i32, -346);
pub const JET_errDatabaseLeakInSpace = @as(i32, -348);
pub const JET_errBadEmptyPage = @as(i32, -351);
pub const JET_errBadLineCount = @as(i32, -354);
pub const JET_wrnSeparateLongValue = @as(u32, 406);
pub const JET_errKeyTooBig = @as(i32, -408);
pub const JET_errCannotSeparateIntrinsicLV = @as(i32, -416);
pub const JET_errSeparatedLongValue = @as(i32, -421);
pub const JET_errMustBeSeparateLongValue = @as(i32, -423);
pub const JET_errInvalidPreread = @as(i32, -424);
pub const JET_errInvalidLoggedOperation = @as(i32, -500);
pub const JET_errLogFileCorrupt = @as(i32, -501);
pub const JET_errNoBackupDirectory = @as(i32, -503);
pub const JET_errBackupDirectoryNotEmpty = @as(i32, -504);
pub const JET_errBackupInProgress = @as(i32, -505);
pub const JET_errRestoreInProgress = @as(i32, -506);
pub const JET_errMissingPreviousLogFile = @as(i32, -509);
pub const JET_errLogWriteFail = @as(i32, -510);
pub const JET_errLogDisabledDueToRecoveryFailure = @as(i32, -511);
pub const JET_errCannotLogDuringRecoveryRedo = @as(i32, -512);
pub const JET_errLogGenerationMismatch = @as(i32, -513);
pub const JET_errBadLogVersion = @as(i32, -514);
pub const JET_errInvalidLogSequence = @as(i32, -515);
pub const JET_errLoggingDisabled = @as(i32, -516);
pub const JET_errLogBufferTooSmall = @as(i32, -517);
pub const JET_errLogSequenceEnd = @as(i32, -519);
pub const JET_errNoBackup = @as(i32, -520);
pub const JET_errInvalidBackupSequence = @as(i32, -521);
pub const JET_errBackupNotAllowedYet = @as(i32, -523);
pub const JET_errDeleteBackupFileFail = @as(i32, -524);
pub const JET_errMakeBackupDirectoryFail = @as(i32, -525);
pub const JET_errInvalidBackup = @as(i32, -526);
pub const JET_errRecoveredWithErrors = @as(i32, -527);
pub const JET_errMissingLogFile = @as(i32, -528);
pub const JET_errLogDiskFull = @as(i32, -529);
pub const JET_errBadLogSignature = @as(i32, -530);
pub const JET_errBadDbSignature = @as(i32, -531);
pub const JET_errBadCheckpointSignature = @as(i32, -532);
pub const JET_errCheckpointCorrupt = @as(i32, -533);
pub const JET_errMissingPatchPage = @as(i32, -534);
pub const JET_errBadPatchPage = @as(i32, -535);
pub const JET_errRedoAbruptEnded = @as(i32, -536);
pub const JET_errPatchFileMissing = @as(i32, -538);
pub const JET_errDatabaseLogSetMismatch = @as(i32, -539);
pub const JET_errDatabaseStreamingFileMismatch = @as(i32, -540);
pub const JET_errLogFileSizeMismatch = @as(i32, -541);
pub const JET_errCheckpointFileNotFound = @as(i32, -542);
pub const JET_errRequiredLogFilesMissing = @as(i32, -543);
pub const JET_errSoftRecoveryOnBackupDatabase = @as(i32, -544);
pub const JET_errLogFileSizeMismatchDatabasesConsistent = @as(i32, -545);
pub const JET_errLogSectorSizeMismatch = @as(i32, -546);
pub const JET_errLogSectorSizeMismatchDatabasesConsistent = @as(i32, -547);
pub const JET_errLogSequenceEndDatabasesConsistent = @as(i32, -548);
pub const JET_errStreamingDataNotLogged = @as(i32, -549);
pub const JET_errDatabaseDirtyShutdown = @as(i32, -550);
pub const JET_errConsistentTimeMismatch = @as(i32, -551);
pub const JET_errDatabasePatchFileMismatch = @as(i32, -552);
pub const JET_errEndingRestoreLogTooLow = @as(i32, -553);
pub const JET_errStartingRestoreLogTooHigh = @as(i32, -554);
pub const JET_errGivenLogFileHasBadSignature = @as(i32, -555);
pub const JET_errGivenLogFileIsNotContiguous = @as(i32, -556);
pub const JET_errMissingRestoreLogFiles = @as(i32, -557);
pub const JET_wrnExistingLogFileHasBadSignature = @as(u32, 558);
pub const JET_wrnExistingLogFileIsNotContiguous = @as(u32, 559);
pub const JET_errMissingFullBackup = @as(i32, -560);
pub const JET_errBadBackupDatabaseSize = @as(i32, -561);
pub const JET_errDatabaseAlreadyUpgraded = @as(i32, -562);
pub const JET_errDatabaseIncompleteUpgrade = @as(i32, -563);
pub const JET_wrnSkipThisRecord = @as(u32, 564);
pub const JET_errMissingCurrentLogFiles = @as(i32, -565);
pub const JET_errDbTimeTooOld = @as(i32, -566);
pub const JET_errDbTimeTooNew = @as(i32, -567);
pub const JET_errMissingFileToBackup = @as(i32, -569);
pub const JET_errLogTornWriteDuringHardRestore = @as(i32, -570);
pub const JET_errLogTornWriteDuringHardRecovery = @as(i32, -571);
pub const JET_errLogCorruptDuringHardRestore = @as(i32, -573);
pub const JET_errLogCorruptDuringHardRecovery = @as(i32, -574);
pub const JET_errMustDisableLoggingForDbUpgrade = @as(i32, -575);
pub const JET_errBadRestoreTargetInstance = @as(i32, -577);
pub const JET_wrnTargetInstanceRunning = @as(u32, 578);
pub const JET_errRecoveredWithoutUndo = @as(i32, -579);
pub const JET_errDatabasesNotFromSameSnapshot = @as(i32, -580);
pub const JET_errSoftRecoveryOnSnapshot = @as(i32, -581);
pub const JET_errCommittedLogFilesMissing = @as(i32, -582);
pub const JET_errSectorSizeNotSupported = @as(i32, -583);
pub const JET_errRecoveredWithoutUndoDatabasesConsistent = @as(i32, -584);
pub const JET_wrnCommittedLogFilesLost = @as(u32, 585);
pub const JET_errCommittedLogFileCorrupt = @as(i32, -586);
pub const JET_wrnCommittedLogFilesRemoved = @as(u32, 587);
pub const JET_wrnFinishWithUndo = @as(u32, 588);
pub const JET_errLogSequenceChecksumMismatch = @as(i32, -590);
pub const JET_wrnDatabaseRepaired = @as(u32, 595);
pub const JET_errPageInitializedMismatch = @as(i32, -596);
pub const JET_errUnicodeTranslationBufferTooSmall = @as(i32, -601);
pub const JET_errUnicodeTranslationFail = @as(i32, -602);
pub const JET_errUnicodeNormalizationNotSupported = @as(i32, -603);
pub const JET_errUnicodeLanguageValidationFailure = @as(i32, -604);
pub const JET_errExistingLogFileHasBadSignature = @as(i32, -610);
pub const JET_errExistingLogFileIsNotContiguous = @as(i32, -611);
pub const JET_errLogReadVerifyFailure = @as(i32, -612);
pub const JET_errCheckpointDepthTooDeep = @as(i32, -614);
pub const JET_errRestoreOfNonBackupDatabase = @as(i32, -615);
pub const JET_errLogFileNotCopied = @as(i32, -616);
pub const JET_errTransactionTooLong = @as(i32, -618);
pub const JET_errEngineFormatVersionNoLongerSupportedTooLow = @as(i32, -619);
pub const JET_errEngineFormatVersionNotYetImplementedTooHigh = @as(i32, -620);
pub const JET_errEngineFormatVersionParamTooLowForRequestedFeature = @as(i32, -621);
pub const JET_errEngineFormatVersionSpecifiedTooLowForLogVersion = @as(i32, -622);
pub const JET_errEngineFormatVersionSpecifiedTooLowForDatabaseVersion = @as(i32, -623);
pub const JET_errBackupAbortByServer = @as(i32, -801);
pub const JET_errInvalidGrbit = @as(i32, -900);
pub const JET_errTermInProgress = @as(i32, -1000);
pub const JET_errFeatureNotAvailable = @as(i32, -1001);
pub const JET_errInvalidName = @as(i32, -1002);
pub const JET_errInvalidParameter = @as(i32, -1003);
pub const JET_wrnColumnNull = @as(u32, 1004);
pub const JET_wrnBufferTruncated = @as(u32, 1006);
pub const JET_wrnDatabaseAttached = @as(u32, 1007);
pub const JET_errDatabaseFileReadOnly = @as(i32, -1008);
pub const JET_wrnSortOverflow = @as(u32, 1009);
pub const JET_errInvalidDatabaseId = @as(i32, -1010);
pub const JET_errOutOfMemory = @as(i32, -1011);
pub const JET_errOutOfDatabaseSpace = @as(i32, -1012);
pub const JET_errOutOfCursors = @as(i32, -1013);
pub const JET_errOutOfBuffers = @as(i32, -1014);
pub const JET_errTooManyIndexes = @as(i32, -1015);
pub const JET_errTooManyKeys = @as(i32, -1016);
pub const JET_errRecordDeleted = @as(i32, -1017);
pub const JET_errReadVerifyFailure = @as(i32, -1018);
pub const JET_errPageNotInitialized = @as(i32, -1019);
pub const JET_errOutOfFileHandles = @as(i32, -1020);
pub const JET_errDiskReadVerificationFailure = @as(i32, -1021);
pub const JET_errDiskIO = @as(i32, -1022);
pub const JET_errInvalidPath = @as(i32, -1023);
pub const JET_errInvalidSystemPath = @as(i32, -1024);
pub const JET_errInvalidLogDirectory = @as(i32, -1025);
pub const JET_errRecordTooBig = @as(i32, -1026);
pub const JET_errTooManyOpenDatabases = @as(i32, -1027);
pub const JET_errInvalidDatabase = @as(i32, -1028);
pub const JET_errNotInitialized = @as(i32, -1029);
pub const JET_errAlreadyInitialized = @as(i32, -1030);
pub const JET_errInitInProgress = @as(i32, -1031);
pub const JET_errFileAccessDenied = @as(i32, -1032);
pub const JET_errBufferTooSmall = @as(i32, -1038);
pub const JET_wrnSeekNotEqual = @as(u32, 1039);
pub const JET_errTooManyColumns = @as(i32, -1040);
pub const JET_errContainerNotEmpty = @as(i32, -1043);
pub const JET_errInvalidFilename = @as(i32, -1044);
pub const JET_errInvalidBookmark = @as(i32, -1045);
pub const JET_errColumnInUse = @as(i32, -1046);
pub const JET_errInvalidBufferSize = @as(i32, -1047);
pub const JET_errColumnNotUpdatable = @as(i32, -1048);
pub const JET_errIndexInUse = @as(i32, -1051);
pub const JET_errLinkNotSupported = @as(i32, -1052);
pub const JET_errNullKeyDisallowed = @as(i32, -1053);
pub const JET_errNotInTransaction = @as(i32, -1054);
pub const JET_wrnNoErrorInfo = @as(u32, 1055);
pub const JET_errMustRollback = @as(i32, -1057);
pub const JET_wrnNoIdleActivity = @as(u32, 1058);
pub const JET_errTooManyActiveUsers = @as(i32, -1059);
pub const JET_errInvalidCountry = @as(i32, -1061);
pub const JET_errInvalidLanguageId = @as(i32, -1062);
pub const JET_errInvalidCodePage = @as(i32, -1063);
pub const JET_errInvalidLCMapStringFlags = @as(i32, -1064);
pub const JET_errVersionStoreEntryTooBig = @as(i32, -1065);
pub const JET_errVersionStoreOutOfMemoryAndCleanupTimedOut = @as(i32, -1066);
pub const JET_wrnNoWriteLock = @as(u32, 1067);
pub const JET_wrnColumnSetNull = @as(u32, 1068);
pub const JET_errVersionStoreOutOfMemory = @as(i32, -1069);
pub const JET_errCannotIndex = @as(i32, -1071);
pub const JET_errRecordNotDeleted = @as(i32, -1072);
pub const JET_errTooManyMempoolEntries = @as(i32, -1073);
pub const JET_errOutOfObjectIDs = @as(i32, -1074);
pub const JET_errOutOfLongValueIDs = @as(i32, -1075);
pub const JET_errOutOfAutoincrementValues = @as(i32, -1076);
pub const JET_errOutOfDbtimeValues = @as(i32, -1077);
pub const JET_errOutOfSequentialIndexValues = @as(i32, -1078);
pub const JET_errRunningInOneInstanceMode = @as(i32, -1080);
pub const JET_errRunningInMultiInstanceMode = @as(i32, -1081);
pub const JET_errSystemParamsAlreadySet = @as(i32, -1082);
pub const JET_errSystemPathInUse = @as(i32, -1083);
pub const JET_errLogFilePathInUse = @as(i32, -1084);
pub const JET_errTempPathInUse = @as(i32, -1085);
pub const JET_errInstanceNameInUse = @as(i32, -1086);
pub const JET_errSystemParameterConflict = @as(i32, -1087);
pub const JET_errInstanceUnavailable = @as(i32, -1090);
pub const JET_errDatabaseUnavailable = @as(i32, -1091);
pub const JET_errInstanceUnavailableDueToFatalLogDiskFull = @as(i32, -1092);
pub const JET_errInvalidSesparamId = @as(i32, -1093);
pub const JET_errTooManyRecords = @as(i32, -1094);
pub const JET_errInvalidDbparamId = @as(i32, -1095);
pub const JET_errOutOfSessions = @as(i32, -1101);
pub const JET_errWriteConflict = @as(i32, -1102);
pub const JET_errTransTooDeep = @as(i32, -1103);
pub const JET_errInvalidSesid = @as(i32, -1104);
pub const JET_errWriteConflictPrimaryIndex = @as(i32, -1105);
pub const JET_errInTransaction = @as(i32, -1108);
pub const JET_errRollbackRequired = @as(i32, -1109);
pub const JET_errTransReadOnly = @as(i32, -1110);
pub const JET_errSessionWriteConflict = @as(i32, -1111);
pub const JET_errRecordTooBigForBackwardCompatibility = @as(i32, -1112);
pub const JET_errCannotMaterializeForwardOnlySort = @as(i32, -1113);
pub const JET_errSesidTableIdMismatch = @as(i32, -1114);
pub const JET_errInvalidInstance = @as(i32, -1115);
pub const JET_errDirtyShutdown = @as(i32, -1116);
pub const JET_errReadPgnoVerifyFailure = @as(i32, -1118);
pub const JET_errReadLostFlushVerifyFailure = @as(i32, -1119);
pub const JET_errFileSystemCorruption = @as(i32, -1121);
pub const JET_wrnShrinkNotPossible = @as(u32, 1122);
pub const JET_errRecoveryVerifyFailure = @as(i32, -1123);
pub const JET_errFilteredMoveNotSupported = @as(i32, -1124);
pub const JET_errDatabaseDuplicate = @as(i32, -1201);
pub const JET_errDatabaseInUse = @as(i32, -1202);
pub const JET_errDatabaseNotFound = @as(i32, -1203);
pub const JET_errDatabaseInvalidName = @as(i32, -1204);
pub const JET_errDatabaseInvalidPages = @as(i32, -1205);
pub const JET_errDatabaseCorrupted = @as(i32, -1206);
pub const JET_errDatabaseLocked = @as(i32, -1207);
pub const JET_errCannotDisableVersioning = @as(i32, -1208);
pub const JET_errInvalidDatabaseVersion = @as(i32, -1209);
pub const JET_errDatabase200Format = @as(i32, -1210);
pub const JET_errDatabase400Format = @as(i32, -1211);
pub const JET_errDatabase500Format = @as(i32, -1212);
pub const JET_errPageSizeMismatch = @as(i32, -1213);
pub const JET_errTooManyInstances = @as(i32, -1214);
pub const JET_errDatabaseSharingViolation = @as(i32, -1215);
pub const JET_errAttachedDatabaseMismatch = @as(i32, -1216);
pub const JET_errDatabaseInvalidPath = @as(i32, -1217);
pub const JET_errDatabaseIdInUse = @as(i32, -1218);
pub const JET_errForceDetachNotAllowed = @as(i32, -1219);
pub const JET_errCatalogCorrupted = @as(i32, -1220);
pub const JET_errPartiallyAttachedDB = @as(i32, -1221);
pub const JET_errDatabaseSignInUse = @as(i32, -1222);
pub const JET_errDatabaseCorruptedNoRepair = @as(i32, -1224);
pub const JET_errInvalidCreateDbVersion = @as(i32, -1225);
pub const JET_errDatabaseNotReady = @as(i32, -1230);
pub const JET_errDatabaseAttachedForRecovery = @as(i32, -1231);
pub const JET_errTransactionsNotReadyDuringRecovery = @as(i32, -1232);
pub const JET_wrnTableEmpty = @as(u32, 1301);
pub const JET_errTableLocked = @as(i32, -1302);
pub const JET_errTableDuplicate = @as(i32, -1303);
pub const JET_errTableInUse = @as(i32, -1304);
pub const JET_errObjectNotFound = @as(i32, -1305);
pub const JET_errDensityInvalid = @as(i32, -1307);
pub const JET_errTableNotEmpty = @as(i32, -1308);
pub const JET_errInvalidTableId = @as(i32, -1310);
pub const JET_errTooManyOpenTables = @as(i32, -1311);
pub const JET_errIllegalOperation = @as(i32, -1312);
pub const JET_errTooManyOpenTablesAndCleanupTimedOut = @as(i32, -1313);
pub const JET_errObjectDuplicate = @as(i32, -1314);
pub const JET_errInvalidObject = @as(i32, -1316);
pub const JET_errCannotDeleteTempTable = @as(i32, -1317);
pub const JET_errCannotDeleteSystemTable = @as(i32, -1318);
pub const JET_errCannotDeleteTemplateTable = @as(i32, -1319);
pub const JET_errExclusiveTableLockRequired = @as(i32, -1322);
pub const JET_errFixedDDL = @as(i32, -1323);
pub const JET_errFixedInheritedDDL = @as(i32, -1324);
pub const JET_errCannotNestDDL = @as(i32, -1325);
pub const JET_errDDLNotInheritable = @as(i32, -1326);
pub const JET_wrnTableInUseBySystem = @as(u32, 1327);
pub const JET_errInvalidSettings = @as(i32, -1328);
pub const JET_errClientRequestToStopJetService = @as(i32, -1329);
pub const JET_errCannotAddFixedVarColumnToDerivedTable = @as(i32, -1330);
pub const JET_errIndexCantBuild = @as(i32, -1401);
pub const JET_errIndexHasPrimary = @as(i32, -1402);
pub const JET_errIndexDuplicate = @as(i32, -1403);
pub const JET_errIndexNotFound = @as(i32, -1404);
pub const JET_errIndexMustStay = @as(i32, -1405);
pub const JET_errIndexInvalidDef = @as(i32, -1406);
pub const JET_errInvalidCreateIndex = @as(i32, -1409);
pub const JET_errTooManyOpenIndexes = @as(i32, -1410);
pub const JET_errMultiValuedIndexViolation = @as(i32, -1411);
pub const JET_errIndexBuildCorrupted = @as(i32, -1412);
pub const JET_errPrimaryIndexCorrupted = @as(i32, -1413);
pub const JET_errSecondaryIndexCorrupted = @as(i32, -1414);
pub const JET_wrnCorruptIndexDeleted = @as(u32, 1415);
pub const JET_errInvalidIndexId = @as(i32, -1416);
pub const JET_wrnPrimaryIndexOutOfDate = @as(u32, 1417);
pub const JET_wrnSecondaryIndexOutOfDate = @as(u32, 1418);
pub const JET_errIndexTuplesSecondaryIndexOnly = @as(i32, -1430);
pub const JET_errIndexTuplesTooManyColumns = @as(i32, -1431);
pub const JET_errIndexTuplesNonUniqueOnly = @as(i32, -1432);
pub const JET_errIndexTuplesTextBinaryColumnsOnly = @as(i32, -1433);
pub const JET_errIndexTuplesVarSegMacNotAllowed = @as(i32, -1434);
pub const JET_errIndexTuplesInvalidLimits = @as(i32, -1435);
pub const JET_errIndexTuplesCannotRetrieveFromIndex = @as(i32, -1436);
pub const JET_errIndexTuplesKeyTooSmall = @as(i32, -1437);
pub const JET_errInvalidLVChunkSize = @as(i32, -1438);
pub const JET_errColumnCannotBeEncrypted = @as(i32, -1439);
pub const JET_errCannotIndexOnEncryptedColumn = @as(i32, -1440);
pub const JET_errColumnLong = @as(i32, -1501);
pub const JET_errColumnNoChunk = @as(i32, -1502);
pub const JET_errColumnDoesNotFit = @as(i32, -1503);
pub const JET_errNullInvalid = @as(i32, -1504);
pub const JET_errColumnIndexed = @as(i32, -1505);
pub const JET_errColumnTooBig = @as(i32, -1506);
pub const JET_errColumnNotFound = @as(i32, -1507);
pub const JET_errColumnDuplicate = @as(i32, -1508);
pub const JET_errMultiValuedColumnMustBeTagged = @as(i32, -1509);
pub const JET_errColumnRedundant = @as(i32, -1510);
pub const JET_errInvalidColumnType = @as(i32, -1511);
pub const JET_wrnColumnMaxTruncated = @as(u32, 1512);
pub const JET_errTaggedNotNULL = @as(i32, -1514);
pub const JET_errNoCurrentIndex = @as(i32, -1515);
pub const JET_errKeyIsMade = @as(i32, -1516);
pub const JET_errBadColumnId = @as(i32, -1517);
pub const JET_errBadItagSequence = @as(i32, -1518);
pub const JET_errColumnInRelationship = @as(i32, -1519);
pub const JET_wrnCopyLongValue = @as(u32, 1520);
pub const JET_errCannotBeTagged = @as(i32, -1521);
pub const JET_errDefaultValueTooBig = @as(i32, -1524);
pub const JET_errMultiValuedDuplicate = @as(i32, -1525);
pub const JET_errLVCorrupted = @as(i32, -1526);
pub const JET_errMultiValuedDuplicateAfterTruncation = @as(i32, -1528);
pub const JET_errDerivedColumnCorruption = @as(i32, -1529);
pub const JET_errInvalidPlaceholderColumn = @as(i32, -1530);
pub const JET_wrnColumnSkipped = @as(u32, 1531);
pub const JET_wrnColumnNotLocal = @as(u32, 1532);
pub const JET_wrnColumnMoreTags = @as(u32, 1533);
pub const JET_wrnColumnTruncated = @as(u32, 1534);
pub const JET_wrnColumnPresent = @as(u32, 1535);
pub const JET_wrnColumnSingleValue = @as(u32, 1536);
pub const JET_wrnColumnDefault = @as(u32, 1537);
pub const JET_errColumnCannotBeCompressed = @as(i32, -1538);
pub const JET_wrnColumnNotInRecord = @as(u32, 1539);
pub const JET_errColumnNoEncryptionKey = @as(i32, -1540);
pub const JET_wrnColumnReference = @as(u32, 1541);
pub const JET_errRecordNotFound = @as(i32, -1601);
pub const JET_errRecordNoCopy = @as(i32, -1602);
pub const JET_errNoCurrentRecord = @as(i32, -1603);
pub const JET_errRecordPrimaryChanged = @as(i32, -1604);
pub const JET_errKeyDuplicate = @as(i32, -1605);
pub const JET_errAlreadyPrepared = @as(i32, -1607);
pub const JET_errKeyNotMade = @as(i32, -1608);
pub const JET_errUpdateNotPrepared = @as(i32, -1609);
pub const JET_wrnDataHasChanged = @as(u32, 1610);
pub const JET_errDataHasChanged = @as(i32, -1611);
pub const JET_wrnKeyChanged = @as(u32, 1618);
pub const JET_errLanguageNotSupported = @as(i32, -1619);
pub const JET_errDecompressionFailed = @as(i32, -1620);
pub const JET_errUpdateMustVersion = @as(i32, -1621);
pub const JET_errDecryptionFailed = @as(i32, -1622);
pub const JET_errEncryptionBadItag = @as(i32, -1623);
pub const JET_errTooManySorts = @as(i32, -1701);
pub const JET_errInvalidOnSort = @as(i32, -1702);
pub const JET_errTempFileOpenError = @as(i32, -1803);
pub const JET_errTooManyAttachedDatabases = @as(i32, -1805);
pub const JET_errDiskFull = @as(i32, -1808);
pub const JET_errPermissionDenied = @as(i32, -1809);
pub const JET_errFileNotFound = @as(i32, -1811);
pub const JET_errFileInvalidType = @as(i32, -1812);
pub const JET_wrnFileOpenReadOnly = @as(u32, 1813);
pub const JET_errFileAlreadyExists = @as(i32, -1814);
pub const JET_errAfterInitialization = @as(i32, -1850);
pub const JET_errLogCorrupted = @as(i32, -1852);
pub const JET_errInvalidOperation = @as(i32, -1906);
pub const JET_errAccessDenied = @as(i32, -1907);
pub const JET_wrnIdleFull = @as(u32, 1908);
pub const JET_errTooManySplits = @as(i32, -1909);
pub const JET_errSessionSharingViolation = @as(i32, -1910);
pub const JET_errEntryPointNotFound = @as(i32, -1911);
pub const JET_errSessionContextAlreadySet = @as(i32, -1912);
pub const JET_errSessionContextNotSetByThisThread = @as(i32, -1913);
pub const JET_errSessionInUse = @as(i32, -1914);
pub const JET_errRecordFormatConversionFailed = @as(i32, -1915);
pub const JET_errOneDatabasePerSession = @as(i32, -1916);
pub const JET_errRollbackError = @as(i32, -1917);
pub const JET_errFlushMapVersionUnsupported = @as(i32, -1918);
pub const JET_errFlushMapDatabaseMismatch = @as(i32, -1919);
pub const JET_errFlushMapUnrecoverable = @as(i32, -1920);
pub const JET_wrnDefragAlreadyRunning = @as(u32, 2000);
pub const JET_wrnDefragNotRunning = @as(u32, 2001);
pub const JET_errDatabaseAlreadyRunningMaintenance = @as(i32, -2004);
pub const JET_wrnCallbackNotRegistered = @as(u32, 2100);
pub const JET_errCallbackFailed = @as(i32, -2101);
pub const JET_errCallbackNotResolved = @as(i32, -2102);
pub const JET_errSpaceHintsInvalid = @as(i32, -2103);
pub const JET_errOSSnapshotInvalidSequence = @as(i32, -2401);
pub const JET_errOSSnapshotTimeOut = @as(i32, -2402);
pub const JET_errOSSnapshotNotAllowed = @as(i32, -2403);
pub const JET_errOSSnapshotInvalidSnapId = @as(i32, -2404);
pub const JET_errLSCallbackNotSpecified = @as(i32, -3000);
pub const JET_errLSAlreadySet = @as(i32, -3001);
pub const JET_errLSNotSet = @as(i32, -3002);
pub const JET_errFileIOSparse = @as(i32, -4000);
pub const JET_errFileIOBeyondEOF = @as(i32, -4001);
pub const JET_errFileIOAbort = @as(i32, -4002);
pub const JET_errFileIORetry = @as(i32, -4003);
pub const JET_errFileIOFail = @as(i32, -4004);
pub const JET_errFileCompressed = @as(i32, -4005);
pub const JET_BASE_NAME_LENGTH = @as(u32, 3);
pub const JET_bitDumpMinimum = @as(u32, 1);
pub const JET_bitDumpMaximum = @as(u32, 2);
pub const JET_bitDumpCacheMinimum = @as(u32, 4);
pub const JET_bitDumpCacheMaximum = @as(u32, 8);
pub const JET_bitDumpCacheIncludeDirtyPages = @as(u32, 16);
pub const JET_bitDumpCacheIncludeCachedPages = @as(u32, 32);
pub const JET_bitDumpCacheIncludeCorruptedPages = @as(u32, 64);
pub const JET_bitDumpCacheNoDecommit = @as(u32, 128);

//--------------------------------------------------------------------------------
// Section: Types (152)
//--------------------------------------------------------------------------------
pub const PMemoryAllocator = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_INDEXID = extern struct {
    cbStruct: u32,
    rgbIndexId: [16]u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_PFNSTATUS = fn(
    sesid: JET_SESID,
    snp: u32,
    snt: u32,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_CALLBACK = fn(
    sesid: JET_SESID,
    dbid: u32,
    tableid: JET_TABLEID,
    cbtyp: u32,
    pvArg1: ?*c_void,
    pvArg2: ?*c_void,
    pvContext: ?*c_void,
    ulUnused: JET_API_PTR,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_OBJECTINFO = extern struct {
    cbStruct: u32,
    objtyp: u32,
    dtCreate: f64,
    dtUpdate: f64,
    grbit: u32,
    flags: u32,
    cRecord: u32,
    cPage: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_THREADSTATS2 = extern struct {
    cbStruct: u32,
    cPageReferenced: u32,
    cPageRead: u32,
    cPagePreread: u32,
    cPageDirtied: u32,
    cPageRedirtied: u32,
    cLogRecord: u32,
    cbLogRecord: u32,
    cusecPageCacheMiss: u64,
    cPageCacheMiss: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_COMMIT_ID = extern struct {
    signLog: JET_SIGNATURE,
    reserved: i32,
    commitId: i64,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_PFNDURABLECOMMITCALLBACK = fn(
    instance: JET_INSTANCE,
    pCommitIdSeen: *JET_COMMIT_ID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_RECSIZE = extern struct {
    cbData: u64,
    cbLongValueData: u64,
    cbOverhead: u64,
    cbLongValueOverhead: u64,
    cNonTaggedColumns: u64,
    cTaggedColumns: u64,
    cLongValues: u64,
    cMultiValues: u64,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const JET_RECSIZE2 = extern struct {
    cbData: u64,
    cbLongValueData: u64,
    cbOverhead: u64,
    cbLongValueOverhead: u64,
    cNonTaggedColumns: u64,
    cTaggedColumns: u64,
    cLongValues: u64,
    cMultiValues: u64,
    cCompressedColumns: u64,
    cbDataCompressed: u64,
    cbLongValueDataCompressed: u64,
};

}, else => struct { } };

pub const JET_HANDLE = usize;

pub const JET_INSTANCE = usize;

pub const JET_SESID = usize;

pub const JET_TABLEID = usize;

pub const JET_API_PTR = usize;

pub const JET_OSSNAPID = usize;

pub const JET_LS = usize;

pub const STGC = extern enum(i32) {
    DEFAULT = 0,
    OVERWRITE = 1,
    ONLYIFCURRENT = 2,
    DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    CONSOLIDATE = 8,
};
pub const STGC_DEFAULT = STGC.DEFAULT;
pub const STGC_OVERWRITE = STGC.OVERWRITE;
pub const STGC_ONLYIFCURRENT = STGC.ONLYIFCURRENT;
pub const STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = STGC.DANGEROUSLYCOMMITMERELYTODISKCACHE;
pub const STGC_CONSOLIDATE = STGC.CONSOLIDATE;

pub const STGMOVE = extern enum(i32) {
    MOVE = 0,
    COPY = 1,
    SHALLOWCOPY = 2,
};
pub const STGMOVE_MOVE = STGMOVE.MOVE;
pub const STGMOVE_COPY = STGMOVE.COPY;
pub const STGMOVE_SHALLOWCOPY = STGMOVE.SHALLOWCOPY;

pub const STATFLAG = extern enum(i32) {
    DEFAULT = 0,
    NONAME = 1,
    NOOPEN = 2,
};
pub const STATFLAG_DEFAULT = STATFLAG.DEFAULT;
pub const STATFLAG_NONAME = STATFLAG.NONAME;
pub const STATFLAG_NOOPEN = STATFLAG.NOOPEN;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISequentialStream_Value = @import("../zig.zig").Guid.initString("0c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISequentialStream = &IID_ISequentialStream_Value;
pub const ISequentialStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: fn(
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: *c_void,
            cb: u32,
            pcbRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: *const c_void,
            cb: u32,
            pcbWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequentialStream_Read(self: *const T, pv: *c_void, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequentialStream.VTable, self.vtable).Read(@ptrCast(*const ISequentialStream, self), pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequentialStream_Write(self: *const T, pv: *const c_void, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequentialStream.VTable, self.vtable).Write(@ptrCast(*const ISequentialStream, self), pv, cb, pcbWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STATSTG = extern struct {
    pwcsName: PWSTR,
    type: u32,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: u32,
    grfLocksSupported: u32,
    clsid: Guid,
    grfStateBits: u32,
    reserved: u32,
};

pub const STGTY = extern enum(i32) {
    STORAGE = 1,
    STREAM = 2,
    LOCKBYTES = 3,
    PROPERTY = 4,
};
pub const STGTY_STORAGE = STGTY.STORAGE;
pub const STGTY_STREAM = STGTY.STREAM;
pub const STGTY_LOCKBYTES = STGTY.LOCKBYTES;
pub const STGTY_PROPERTY = STGTY.PROPERTY;

pub const STREAM_SEEK = extern enum(u32) {
    SET = 0,
    CUR = 1,
    END = 2,
};
pub const STREAM_SEEK_SET = STREAM_SEEK.SET;
pub const STREAM_SEEK_CUR = STREAM_SEEK.CUR;
pub const STREAM_SEEK_END = STREAM_SEEK.END;

pub const LOCKTYPE = extern enum(i32) {
    WRITE = 1,
    EXCLUSIVE = 2,
    ONLYONCE = 4,
};
pub const LOCK_WRITE = LOCKTYPE.WRITE;
pub const LOCK_EXCLUSIVE = LOCKTYPE.EXCLUSIVE;
pub const LOCK_ONLYONCE = LOCKTYPE.ONLYONCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IStream_Value = @import("../zig.zig").Guid.initString("0000000c-0000-0000-c000-000000000046");
pub const IID_IStream = &IID_IStream_Value;
pub const IStream = extern struct {
    pub const VTable = extern struct {
        base: ISequentialStream.VTable,
        Seek: fn(
            self: *const IStream,
            dlibMove: LARGE_INTEGER,
            dwOrigin: STREAM_SEEK,
            plibNewPosition: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const IStream,
            libNewSize: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: fn(
            self: *const IStream,
            pstm: *IStream,
            cb: ULARGE_INTEGER,
            pcbRead: ?*ULARGE_INTEGER,
            pcbWritten: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IStream,
            grfCommitFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: fn(
            self: *const IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRegion: fn(
            self: *const IStream,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRegion: fn(
            self: *const IStream,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: fn(
            self: *const IStream,
            pstatstg: *STATSTG,
            grfStatFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IStream,
            ppstm: **IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISequentialStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Seek(self: *const T, dlibMove: LARGE_INTEGER, dwOrigin: STREAM_SEEK, plibNewPosition: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Seek(@ptrCast(*const IStream, self), dlibMove, dwOrigin, plibNewPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_SetSize(self: *const T, libNewSize: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).SetSize(@ptrCast(*const IStream, self), libNewSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_CopyTo(self: *const T, pstm: *IStream, cb: ULARGE_INTEGER, pcbRead: ?*ULARGE_INTEGER, pcbWritten: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).CopyTo(@ptrCast(*const IStream, self), pstm, cb, pcbRead, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Commit(@ptrCast(*const IStream, self), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Revert(@ptrCast(*const IStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_LockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).LockRegion(@ptrCast(*const IStream, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_UnlockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).UnlockRegion(@ptrCast(*const IStream, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Stat(self: *const T, pstatstg: *STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Stat(@ptrCast(*const IStream, self), pstatstg, grfStatFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Clone(self: *const T, ppstm: **IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Clone(@ptrCast(*const IStream, self), ppstm);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATSTG_Value = @import("../zig.zig").Guid.initString("0000000d-0000-0000-c000-000000000046");
pub const IID_IEnumSTATSTG = &IID_IEnumSTATSTG_Value;
pub const IEnumSTATSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSTATSTG,
            celt: u32,
            rgelt: [*]STATSTG,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSTATSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSTATSTG,
            ppenum: **IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Next(self: *const T, celt: u32, rgelt: [*]STATSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATSTG.VTable, self.vtable).Next(@ptrCast(*const IEnumSTATSTG, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATSTG.VTable, self.vtable).Skip(@ptrCast(*const IEnumSTATSTG, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATSTG.VTable, self.vtable).Reset(@ptrCast(*const IEnumSTATSTG, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Clone(self: *const T, ppenum: **IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATSTG.VTable, self.vtable).Clone(@ptrCast(*const IEnumSTATSTG, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RemSNB = extern struct {
    ulCntStr: u32,
    ulCntChar: u32,
    rgString: [1]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStorage_Value = @import("../zig.zig").Guid.initString("0000000b-0000-0000-c000-000000000046");
pub const IID_IStorage = &IID_IStorage_Value;
pub const IStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            grfMode: u32,
            reserved1: u32,
            reserved2: u32,
            ppstm: **IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStream: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            reserved1: *c_void,
            grfMode: u32,
            reserved2: u32,
            ppstm: **IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStorage: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            grfMode: u32,
            reserved1: u32,
            reserved2: u32,
            ppstg: **IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStorage: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            pstgPriority: *IStorage,
            grfMode: u32,
            snbExclude: **u16,
            reserved: u32,
            ppstg: **IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: fn(
            self: *const IStorage,
            ciidExclude: u32,
            rgiidExclude: ?[*]const Guid,
            snbExclude: ?*?*u16,
            pstgDest: *IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveElementTo: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            pstgDest: *IStorage,
            pwcsNewName: [*:0]const u16,
            grfFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IStorage,
            grfCommitFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: fn(
            self: *const IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumElements: fn(
            self: *const IStorage,
            reserved1: u32,
            reserved2: *c_void,
            reserved3: u32,
            ppenum: **IEnumSTATSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyElement: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameElement: fn(
            self: *const IStorage,
            pwcsOldName: [*:0]const u16,
            pwcsNewName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetElementTimes: fn(
            self: *const IStorage,
            pwcsName: [*:0]const u16,
            pctime: *const FILETIME,
            patime: *const FILETIME,
            pmtime: *const FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClass: fn(
            self: *const IStorage,
            clsid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStateBits: fn(
            self: *const IStorage,
            grfStateBits: u32,
            grfMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: fn(
            self: *const IStorage,
            pstatstg: *STATSTG,
            grfStatFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStream(self: *const T, pwcsName: [*:0]const u16, grfMode: u32, reserved1: u32, reserved2: u32, ppstm: **IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).CreateStream(@ptrCast(*const IStorage, self), pwcsName, grfMode, reserved1, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStream(self: *const T, pwcsName: [*:0]const u16, reserved1: *c_void, grfMode: u32, reserved2: u32, ppstm: **IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).OpenStream(@ptrCast(*const IStorage, self), pwcsName, reserved1, grfMode, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStorage(self: *const T, pwcsName: [*:0]const u16, grfMode: u32, reserved1: u32, reserved2: u32, ppstg: **IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).CreateStorage(@ptrCast(*const IStorage, self), pwcsName, grfMode, reserved1, reserved2, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStorage(self: *const T, pwcsName: [*:0]const u16, pstgPriority: *IStorage, grfMode: u32, snbExclude: **u16, reserved: u32, ppstg: **IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).OpenStorage(@ptrCast(*const IStorage, self), pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CopyTo(self: *const T, ciidExclude: u32, rgiidExclude: ?[*]const Guid, snbExclude: ?*?*u16, pstgDest: *IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).CopyTo(@ptrCast(*const IStorage, self), ciidExclude, rgiidExclude, snbExclude, pstgDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_MoveElementTo(self: *const T, pwcsName: [*:0]const u16, pstgDest: *IStorage, pwcsNewName: [*:0]const u16, grfFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).MoveElementTo(@ptrCast(*const IStorage, self), pwcsName, pstgDest, pwcsNewName, grfFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).Commit(@ptrCast(*const IStorage, self), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).Revert(@ptrCast(*const IStorage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_EnumElements(self: *const T, reserved1: u32, reserved2: *c_void, reserved3: u32, ppenum: **IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).EnumElements(@ptrCast(*const IStorage, self), reserved1, reserved2, reserved3, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_DestroyElement(self: *const T, pwcsName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).DestroyElement(@ptrCast(*const IStorage, self), pwcsName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_RenameElement(self: *const T, pwcsOldName: [*:0]const u16, pwcsNewName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).RenameElement(@ptrCast(*const IStorage, self), pwcsOldName, pwcsNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetElementTimes(self: *const T, pwcsName: [*:0]const u16, pctime: *const FILETIME, patime: *const FILETIME, pmtime: *const FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).SetElementTimes(@ptrCast(*const IStorage, self), pwcsName, pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetClass(self: *const T, clsid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).SetClass(@ptrCast(*const IStorage, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetStateBits(self: *const T, grfStateBits: u32, grfMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).SetStateBits(@ptrCast(*const IStorage, self), grfStateBits, grfMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Stat(self: *const T, pstatstg: *STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorage.VTable, self.vtable).Stat(@ptrCast(*const IStorage, self), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILockBytes_Value = @import("../zig.zig").Guid.initString("0000000a-0000-0000-c000-000000000046");
pub const IID_ILockBytes = &IID_ILockBytes_Value;
pub const ILockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadAt: fn(
            self: *const ILockBytes,
            ulOffset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: *c_void,
            cb: u32,
            pcbRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAt: fn(
            self: *const ILockBytes,
            ulOffset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: *const c_void,
            cb: u32,
            pcbWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const ILockBytes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const ILockBytes,
            cb: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRegion: fn(
            self: *const ILockBytes,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRegion: fn(
            self: *const ILockBytes,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: fn(
            self: *const ILockBytes,
            pstatstg: *STATSTG,
            grfStatFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_ReadAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: *c_void, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).ReadAt(@ptrCast(*const ILockBytes, self), ulOffset, pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_WriteAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: *const c_void, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).WriteAt(@ptrCast(*const ILockBytes, self), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).Flush(@ptrCast(*const ILockBytes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_SetSize(self: *const T, cb: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).SetSize(@ptrCast(*const ILockBytes, self), cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_LockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).LockRegion(@ptrCast(*const ILockBytes, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_UnlockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).UnlockRegion(@ptrCast(*const ILockBytes, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Stat(self: *const T, pstatstg: *STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILockBytes.VTable, self.vtable).Stat(@ptrCast(*const ILockBytes, self), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRootStorage_Value = @import("../zig.zig").Guid.initString("00000012-0000-0000-c000-000000000046");
pub const IID_IRootStorage = &IID_IRootStorage_Value;
pub const IRootStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchToFile: fn(
            self: *const IRootStorage,
            pszFile: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRootStorage_SwitchToFile(self: *const T, pszFile: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRootStorage.VTable, self.vtable).SwitchToFile(@ptrCast(*const IRootStorage, self), pszFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFillLockBytes_Value = @import("../zig.zig").Guid.initString("99caf010-415e-11cf-8814-00aa00b569f5");
pub const IID_IFillLockBytes = &IID_IFillLockBytes_Value;
pub const IFillLockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FillAppend: fn(
            self: *const IFillLockBytes,
            // TODO: what to do with BytesParamIndex 1?
            pv: *const c_void,
            cb: u32,
            pcbWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillAt: fn(
            self: *const IFillLockBytes,
            ulOffset: ULARGE_INTEGER,
            // TODO: what to do with BytesParamIndex 2?
            pv: *const c_void,
            cb: u32,
            pcbWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFillSize: fn(
            self: *const IFillLockBytes,
            ulSize: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IFillLockBytes,
            bCanceled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAppend(self: *const T, pv: *const c_void, cb: u32, pcbWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFillLockBytes.VTable, self.vtable).FillAppend(@ptrCast(*const IFillLockBytes, self), pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: *const c_void, cb: u32, pcbWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFillLockBytes.VTable, self.vtable).FillAt(@ptrCast(*const IFillLockBytes, self), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_SetFillSize(self: *const T, ulSize: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFillLockBytes.VTable, self.vtable).SetFillSize(@ptrCast(*const IFillLockBytes, self), ulSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_Terminate(self: *const T, bCanceled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFillLockBytes.VTable, self.vtable).Terminate(@ptrCast(*const IFillLockBytes, self), bCanceled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const StorageLayout = extern struct {
    LayoutType: u32,
    pwcsElementName: PWSTR,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILayoutStorage_Value = @import("../zig.zig").Guid.initString("0e6d4d90-6738-11cf-9608-00aa00680db4");
pub const IID_ILayoutStorage = &IID_ILayoutStorage_Value;
pub const ILayoutStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LayoutScript: fn(
            self: *const ILayoutStorage,
            pStorageLayout: [*]StorageLayout,
            nEntries: u32,
            glfInterleavedFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginMonitor: fn(
            self: *const ILayoutStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndMonitor: fn(
            self: *const ILayoutStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReLayoutDocfile: fn(
            self: *const ILayoutStorage,
            pwcsNewDfName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReLayoutDocfileOnILockBytes: fn(
            self: *const ILayoutStorage,
            pILockBytes: *ILockBytes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_LayoutScript(self: *const T, pStorageLayout: [*]StorageLayout, nEntries: u32, glfInterleavedFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILayoutStorage.VTable, self.vtable).LayoutScript(@ptrCast(*const ILayoutStorage, self), pStorageLayout, nEntries, glfInterleavedFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_BeginMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILayoutStorage.VTable, self.vtable).BeginMonitor(@ptrCast(*const ILayoutStorage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_EndMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILayoutStorage.VTable, self.vtable).EndMonitor(@ptrCast(*const ILayoutStorage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfile(self: *const T, pwcsNewDfName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILayoutStorage.VTable, self.vtable).ReLayoutDocfile(@ptrCast(*const ILayoutStorage, self), pwcsNewDfName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfileOnILockBytes(self: *const T, pILockBytes: *ILockBytes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILayoutStorage.VTable, self.vtable).ReLayoutDocfileOnILockBytes(@ptrCast(*const ILayoutStorage, self), pILockBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectWriterLock_Value = @import("../zig.zig").Guid.initString("0e6d4d92-6738-11cf-9608-00aa00680db4");
pub const IID_IDirectWriterLock = &IID_IDirectWriterLock_Value;
pub const IDirectWriterLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForWriteAccess: fn(
            self: *const IDirectWriterLock,
            dwTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseWriteAccess: fn(
            self: *const IDirectWriterLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HaveWriteAccess: fn(
            self: *const IDirectWriterLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_WaitForWriteAccess(self: *const T, dwTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectWriterLock.VTable, self.vtable).WaitForWriteAccess(@ptrCast(*const IDirectWriterLock, self), dwTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_ReleaseWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectWriterLock.VTable, self.vtable).ReleaseWriteAccess(@ptrCast(*const IDirectWriterLock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_HaveWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectWriterLock.VTable, self.vtable).HaveWriteAccess(@ptrCast(*const IDirectWriterLock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_INDEXID = extern struct {
    cbStruct: u32,
    rgbIndexId: [12]u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_PFNSTATUS = fn(
    sesid: JET_SESID,
    snp: u32,
    snt: u32,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_CALLBACK = fn(
    sesid: JET_SESID,
    dbid: u32,
    tableid: JET_TABLEID,
    cbtyp: u32,
    pvArg1: ?*c_void,
    pvArg2: ?*c_void,
    pvContext: ?*c_void,
    ulUnused: JET_API_PTR,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_OBJECTINFO = extern struct {
    cbStruct: u32,
    objtyp: u32,
    dtCreate: f64,
    dtUpdate: f64,
    grbit: u32,
    flags: u32,
    cRecord: u32,
    cPage: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_THREADSTATS2 = extern struct {
    cbStruct: u32,
    cPageReferenced: u32,
    cPageRead: u32,
    cPagePreread: u32,
    cPageDirtied: u32,
    cPageRedirtied: u32,
    cLogRecord: u32,
    cbLogRecord: u32,
    cusecPageCacheMiss: u64,
    cPageCacheMiss: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_COMMIT_ID = extern struct {
    signLog: JET_SIGNATURE,
    reserved: i32,
    commitId: i64,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_PFNDURABLECOMMITCALLBACK = fn(
    instance: JET_INSTANCE,
    pCommitIdSeen: *JET_COMMIT_ID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_RECSIZE = extern struct {
    cbData: u64,
    cbLongValueData: u64,
    cbOverhead: u64,
    cbLongValueOverhead: u64,
    cNonTaggedColumns: u64,
    cTaggedColumns: u64,
    cLongValues: u64,
    cMultiValues: u64,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const JET_RECSIZE2 = extern struct {
    cbData: u64,
    cbLongValueData: u64,
    cbOverhead: u64,
    cbLongValueOverhead: u64,
    cNonTaggedColumns: u64,
    cTaggedColumns: u64,
    cLongValues: u64,
    cMultiValues: u64,
    cCompressedColumns: u64,
    cbDataCompressed: u64,
    cbLongValueDataCompressed: u64,
};

}, else => struct { } };

pub const VERSIONEDSTREAM = extern struct {
    guidVersion: Guid,
    pStream: *IStream,
};

pub const CAC = extern struct {
    cElems: u32,
    pElems: PSTR,
};

pub const CAUB = extern struct {
    cElems: u32,
    pElems: *u8,
};

pub const CAI = extern struct {
    cElems: u32,
    pElems: *i16,
};

pub const CAUI = extern struct {
    cElems: u32,
    pElems: *u16,
};

pub const CAL = extern struct {
    cElems: u32,
    pElems: *i32,
};

pub const CAUL = extern struct {
    cElems: u32,
    pElems: *u32,
};

pub const CAFLT = extern struct {
    cElems: u32,
    pElems: *f32,
};

pub const CADBL = extern struct {
    cElems: u32,
    pElems: *f64,
};

pub const CACY = extern struct {
    cElems: u32,
    pElems: *CY,
};

pub const CADATE = extern struct {
    cElems: u32,
    pElems: *f64,
};

pub const CABSTR = extern struct {
    cElems: u32,
    pElems: *BSTR,
};

pub const CABSTRBLOB = extern struct {
    cElems: u32,
    pElems: *BSTRBLOB,
};

pub const CABOOL = extern struct {
    cElems: u32,
    pElems: *i16,
};

pub const CASCODE = extern struct {
    cElems: u32,
    pElems: *i32,
};

pub const CAPROPVARIANT = extern struct {
    cElems: u32,
    pElems: *PROPVARIANT,
};

pub const CAH = extern struct {
    cElems: u32,
    pElems: *LARGE_INTEGER,
};

pub const CAUH = extern struct {
    cElems: u32,
    pElems: *ULARGE_INTEGER,
};

pub const CALPSTR = extern struct {
    cElems: u32,
    pElems: *PSTR,
};

pub const CALPWSTR = extern struct {
    cElems: u32,
    pElems: *PWSTR,
};

pub const CAFILETIME = extern struct {
    cElems: u32,
    pElems: *FILETIME,
};

pub const CACLIPDATA = extern struct {
    cElems: u32,
    pElems: *CLIPDATA,
};

pub const CACLSID = extern struct {
    cElems: u32,
    pElems: *Guid,
};

pub const PROPVARIANT = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSPEC = extern struct {
    ulKind: PROPSPEC_KIND,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const STATPROPSTG = extern struct {
    lpwstrName: PWSTR,
    propid: u32,
    vt: u16,
};

pub const STATPROPSETSTG = extern struct {
    fmtid: Guid,
    clsid: Guid,
    grfFlags: u32,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyStorage_Value = @import("../zig.zig").Guid.initString("00000138-0000-0000-c000-000000000046");
pub const IID_IPropertyStorage = &IID_IPropertyStorage_Value;
pub const IPropertyStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMultiple: fn(
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
            rgpropvar: [*]PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMultiple: fn(
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
            rgpropvar: [*]const PROPVARIANT,
            propidNameFirst: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMultiple: fn(
            self: *const IPropertyStorage,
            cpspec: u32,
            rgpspec: [*]const PROPSPEC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPropertyNames: fn(
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
            rglpwstrName: [*]PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePropertyNames: fn(
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
            rglpwstrName: [*]const [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePropertyNames: fn(
            self: *const IPropertyStorage,
            cpropid: u32,
            rgpropid: [*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IPropertyStorage,
            grfCommitFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: fn(
            self: *const IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: fn(
            self: *const IPropertyStorage,
            ppenum: **IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimes: fn(
            self: *const IPropertyStorage,
            pctime: *const FILETIME,
            patime: *const FILETIME,
            pmtime: *const FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClass: fn(
            self: *const IPropertyStorage,
            clsid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: fn(
            self: *const IPropertyStorage,
            pstatpsstg: *STATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).ReadMultiple(@ptrCast(*const IPropertyStorage, self), cpspec, rgpspec, rgpropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WriteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]const PROPVARIANT, propidNameFirst: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).WriteMultiple(@ptrCast(*const IPropertyStorage, self), cpspec, rgpspec, rgpropvar, propidNameFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeleteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).DeleteMultiple(@ptrCast(*const IPropertyStorage, self), cpspec, rgpspec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadPropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).ReadPropertyNames(@ptrCast(*const IPropertyStorage, self), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WritePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]const [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).WritePropertyNames(@ptrCast(*const IPropertyStorage, self), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeletePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).DeletePropertyNames(@ptrCast(*const IPropertyStorage, self), cpropid, rgpropid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).Commit(@ptrCast(*const IPropertyStorage, self), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).Revert(@ptrCast(*const IPropertyStorage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Enum(self: *const T, ppenum: **IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).Enum(@ptrCast(*const IPropertyStorage, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetTimes(self: *const T, pctime: *const FILETIME, patime: *const FILETIME, pmtime: *const FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).SetTimes(@ptrCast(*const IPropertyStorage, self), pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetClass(self: *const T, clsid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).SetClass(@ptrCast(*const IPropertyStorage, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Stat(self: *const T, pstatpsstg: *STATPROPSETSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStorage.VTable, self.vtable).Stat(@ptrCast(*const IPropertyStorage, self), pstatpsstg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertySetStorage_Value = @import("../zig.zig").Guid.initString("0000013a-0000-0000-c000-000000000046");
pub const IID_IPropertySetStorage = &IID_IPropertySetStorage_Value;
pub const IPropertySetStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IPropertySetStorage,
            rfmtid: *const Guid,
            pclsid: *const Guid,
            grfFlags: u32,
            grfMode: u32,
            ppprstg: **IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const IPropertySetStorage,
            rfmtid: *const Guid,
            grfMode: u32,
            ppprstg: **IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IPropertySetStorage,
            rfmtid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: fn(
            self: *const IPropertySetStorage,
            ppenum: **IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Create(self: *const T, rfmtid: *const Guid, pclsid: *const Guid, grfFlags: u32, grfMode: u32, ppprstg: **IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySetStorage.VTable, self.vtable).Create(@ptrCast(*const IPropertySetStorage, self), rfmtid, pclsid, grfFlags, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Open(self: *const T, rfmtid: *const Guid, grfMode: u32, ppprstg: **IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySetStorage.VTable, self.vtable).Open(@ptrCast(*const IPropertySetStorage, self), rfmtid, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Delete(self: *const T, rfmtid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySetStorage.VTable, self.vtable).Delete(@ptrCast(*const IPropertySetStorage, self), rfmtid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Enum(self: *const T, ppenum: **IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySetStorage.VTable, self.vtable).Enum(@ptrCast(*const IPropertySetStorage, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSTG_Value = @import("../zig.zig").Guid.initString("00000139-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSTG = &IID_IEnumSTATPROPSTG_Value;
pub const IEnumSTATPROPSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSTATPROPSTG,
            celt: u32,
            rgelt: [*]STATPROPSTG,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSTATPROPSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSTATPROPSTG,
            ppenum: **IEnumSTATPROPSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSTG.VTable, self.vtable).Next(@ptrCast(*const IEnumSTATPROPSTG, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSTG.VTable, self.vtable).Skip(@ptrCast(*const IEnumSTATPROPSTG, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSTG.VTable, self.vtable).Reset(@ptrCast(*const IEnumSTATPROPSTG, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Clone(self: *const T, ppenum: **IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSTG.VTable, self.vtable).Clone(@ptrCast(*const IEnumSTATPROPSTG, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSETSTG_Value = @import("../zig.zig").Guid.initString("0000013b-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSETSTG = &IID_IEnumSTATPROPSETSTG_Value;
pub const IEnumSTATPROPSETSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSTATPROPSETSTG,
            celt: u32,
            rgelt: [*]STATPROPSETSTG,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSTATPROPSETSTG,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSTATPROPSETSTG,
            ppenum: **IEnumSTATPROPSETSTG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSETSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSETSTG.VTable, self.vtable).Next(@ptrCast(*const IEnumSTATPROPSETSTG, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSETSTG.VTable, self.vtable).Skip(@ptrCast(*const IEnumSTATPROPSETSTG, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSETSTG.VTable, self.vtable).Reset(@ptrCast(*const IEnumSTATPROPSETSTG, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Clone(self: *const T, ppenum: **IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATPROPSETSTG.VTable, self.vtable).Clone(@ptrCast(*const IEnumSTATPROPSETSTG, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STGOPTIONS = extern struct {
    usVersion: u16,
    reserved: u16,
    ulSectorSize: u32,
    pwcsTemplateFile: [*:0]const u16,
};

pub const PIDMSI_STATUS_VALUE = extern enum(i32) {
    NORMAL = 0,
    NEW = 1,
    PRELIM = 2,
    DRAFT = 3,
    INPROGRESS = 4,
    EDIT = 5,
    REVIEW = 6,
    PROOF = 7,
    FINAL = 8,
    OTHER = 32767,
};
pub const PIDMSI_STATUS_NORMAL = PIDMSI_STATUS_VALUE.NORMAL;
pub const PIDMSI_STATUS_NEW = PIDMSI_STATUS_VALUE.NEW;
pub const PIDMSI_STATUS_PRELIM = PIDMSI_STATUS_VALUE.PRELIM;
pub const PIDMSI_STATUS_DRAFT = PIDMSI_STATUS_VALUE.DRAFT;
pub const PIDMSI_STATUS_INPROGRESS = PIDMSI_STATUS_VALUE.INPROGRESS;
pub const PIDMSI_STATUS_EDIT = PIDMSI_STATUS_VALUE.EDIT;
pub const PIDMSI_STATUS_REVIEW = PIDMSI_STATUS_VALUE.REVIEW;
pub const PIDMSI_STATUS_PROOF = PIDMSI_STATUS_VALUE.PROOF;
pub const PIDMSI_STATUS_FINAL = PIDMSI_STATUS_VALUE.FINAL;
pub const PIDMSI_STATUS_OTHER = PIDMSI_STATUS_VALUE.OTHER;

pub const JET_RSTMAP_A = extern struct {
    szDatabaseName: PSTR,
    szNewDatabaseName: PSTR,
};

pub const JET_RSTMAP_W = extern struct {
    szDatabaseName: PWSTR,
    szNewDatabaseName: PWSTR,
};

pub const CONVERT_A = extern struct {
    szOldDll: PSTR,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CONVERT_W = extern struct {
    szOldDll: PWSTR,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_SNPROG = extern struct {
    cbStruct: u32,
    cunitDone: u32,
    cunitTotal: u32,
};

pub const JET_DBINFOUPGRADE = extern struct {
    cbStruct: u32,
    cbFilesizeLow: u32,
    cbFilesizeHigh: u32,
    cbFreeSpaceRequiredLow: u32,
    cbFreeSpaceRequiredHigh: u32,
    csecToUpgrade: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_OBJECTLIST = extern struct {
    cbStruct: u32,
    tableid: JET_TABLEID,
    cRecord: u32,
    columnidcontainername: u32,
    columnidobjectname: u32,
    columnidobjtyp: u32,
    columniddtCreate: u32,
    columniddtUpdate: u32,
    columnidgrbit: u32,
    columnidflags: u32,
    columnidcRecord: u32,
    columnidcPage: u32,
};

pub const JET_COLUMNLIST = extern struct {
    cbStruct: u32,
    tableid: JET_TABLEID,
    cRecord: u32,
    columnidPresentationOrder: u32,
    columnidcolumnname: u32,
    columnidcolumnid: u32,
    columnidcoltyp: u32,
    columnidCountry: u32,
    columnidLangid: u32,
    columnidCp: u32,
    columnidCollate: u32,
    columnidcbMax: u32,
    columnidgrbit: u32,
    columnidDefault: u32,
    columnidBaseTableName: u32,
    columnidBaseColumnName: u32,
    columnidDefinitionName: u32,
};

pub const JET_COLUMNDEF = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wCollate: u16,
    cbMax: u32,
    grbit: u32,
};

pub const JET_COLUMNBASE_A = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wFiller: u16,
    cbMax: u32,
    grbit: u32,
    szBaseTableName: [256]CHAR,
    szBaseColumnName: [256]CHAR,
};

pub const JET_COLUMNBASE_W = extern struct {
    cbStruct: u32,
    columnid: u32,
    coltyp: u32,
    wCountry: u16,
    langid: u16,
    cp: u16,
    wFiller: u16,
    cbMax: u32,
    grbit: u32,
    szBaseTableName: [256]u16,
    szBaseColumnName: [256]u16,
};

pub const JET_INDEXLIST = extern struct {
    cbStruct: u32,
    tableid: JET_TABLEID,
    cRecord: u32,
    columnidindexname: u32,
    columnidgrbitIndex: u32,
    columnidcKey: u32,
    columnidcEntry: u32,
    columnidcPage: u32,
    columnidcColumn: u32,
    columnidiColumn: u32,
    columnidcolumnid: u32,
    columnidcoltyp: u32,
    columnidCountry: u32,
    columnidLangid: u32,
    columnidCp: u32,
    columnidCollate: u32,
    columnidgrbitColumn: u32,
    columnidcolumnname: u32,
    columnidLCMapFlags: u32,
};

pub const JET_COLUMNCREATE_A = extern struct {
    cbStruct: u32,
    szColumnName: PSTR,
    coltyp: u32,
    cbMax: u32,
    grbit: u32,
    pvDefault: *c_void,
    cbDefault: u32,
    cp: u32,
    columnid: u32,
    err: i32,
};

pub const JET_COLUMNCREATE_W = extern struct {
    cbStruct: u32,
    szColumnName: PWSTR,
    coltyp: u32,
    cbMax: u32,
    grbit: u32,
    pvDefault: *c_void,
    cbDefault: u32,
    cp: u32,
    columnid: u32,
    err: i32,
};

pub const JET_USERDEFINEDDEFAULT_A = extern struct {
    szCallback: PSTR,
    pbUserData: *u8,
    cbUserData: u32,
    szDependantColumns: PSTR,
};

pub const JET_USERDEFINEDDEFAULT_W = extern struct {
    szCallback: PWSTR,
    pbUserData: *u8,
    cbUserData: u32,
    szDependantColumns: PWSTR,
};

pub const JET_CONDITIONALCOLUMN_A = extern struct {
    cbStruct: u32,
    szColumnName: PSTR,
    grbit: u32,
};

pub const JET_CONDITIONALCOLUMN_W = extern struct {
    cbStruct: u32,
    szColumnName: PWSTR,
    grbit: u32,
};

pub const JET_UNICODEINDEX = extern struct {
    lcid: u32,
    dwMapFlags: u32,
};

pub const JET_UNICODEINDEX2 = extern struct {
    szLocaleName: PWSTR,
    dwMapFlags: u32,
};

pub const JET_TUPLELIMITS = extern struct {
    chLengthMin: u32,
    chLengthMax: u32,
    chToIndexMax: u32,
    cchIncrement: u32,
    ichStart: u32,
};

pub const JET_SPACEHINTS = extern struct {
    cbStruct: u32,
    ulInitialDensity: u32,
    cbInitial: u32,
    grbit: u32,
    ulMaintDensity: u32,
    ulGrowth: u32,
    cbMinExtent: u32,
    cbMaxExtent: u32,
};

pub const JET_INDEXCREATE_A = extern struct {
    cbStruct: u32,
    szIndexName: PSTR,
    szKey: PSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_INDEXCREATE_W = extern struct {
    cbStruct: u32,
    szIndexName: PWSTR,
    szKey: PWSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_INDEXCREATE2_A = extern struct {
    cbStruct: u32,
    szIndexName: PSTR,
    szKey: PSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: *JET_SPACEHINTS,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_INDEXCREATE2_W = extern struct {
    cbStruct: u32,
    szIndexName: PWSTR,
    szKey: PWSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: *JET_SPACEHINTS,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_INDEXCREATE3_A = extern struct {
    cbStruct: u32,
    szIndexName: PSTR,
    szKey: PSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    pidxunicode: *JET_UNICODEINDEX2,
    Anonymous: _Anonymous_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_A,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: *JET_SPACEHINTS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_INDEXCREATE3_W = extern struct {
    cbStruct: u32,
    szIndexName: PWSTR,
    szKey: PWSTR,
    cbKey: u32,
    grbit: u32,
    ulDensity: u32,
    pidxunicode: *JET_UNICODEINDEX2,
    Anonymous: _Anonymous_e__Union,
    rgconditionalcolumn: *JET_CONDITIONALCOLUMN_W,
    cConditionalColumn: u32,
    err: i32,
    cbKeyMost: u32,
    pSpacehints: *JET_SPACEHINTS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_TABLECREATE_A = extern struct {
    cbStruct: u32,
    szTableName: PSTR,
    szTemplateTableName: PSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE_A,
    cIndexes: u32,
    grbit: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE_W = extern struct {
    cbStruct: u32,
    szTableName: PWSTR,
    szTemplateTableName: PWSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE_W,
    cIndexes: u32,
    grbit: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE2_A = extern struct {
    cbStruct: u32,
    szTableName: PSTR,
    szTemplateTableName: PSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE_A,
    cIndexes: u32,
    szCallback: PSTR,
    cbtyp: u32,
    grbit: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE2_W = extern struct {
    cbStruct: u32,
    szTableName: PWSTR,
    szTemplateTableName: PWSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE_W,
    cIndexes: u32,
    szCallback: PWSTR,
    cbtyp: u32,
    grbit: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE3_A = extern struct {
    cbStruct: u32,
    szTableName: PSTR,
    szTemplateTableName: PSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE2_A,
    cIndexes: u32,
    szCallback: PSTR,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: *JET_SPACEHINTS,
    pLVSpacehints: *JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE3_W = extern struct {
    cbStruct: u32,
    szTableName: PWSTR,
    szTemplateTableName: PWSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE2_W,
    cIndexes: u32,
    szCallback: PWSTR,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: *JET_SPACEHINTS,
    pLVSpacehints: *JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE4_A = extern struct {
    cbStruct: u32,
    szTableName: PSTR,
    szTemplateTableName: PSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_A,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE3_A,
    cIndexes: u32,
    szCallback: PSTR,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: *JET_SPACEHINTS,
    pLVSpacehints: *JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_TABLECREATE4_W = extern struct {
    cbStruct: u32,
    szTableName: PWSTR,
    szTemplateTableName: PWSTR,
    ulPages: u32,
    ulDensity: u32,
    rgcolumncreate: *JET_COLUMNCREATE_W,
    cColumns: u32,
    rgindexcreate: *JET_INDEXCREATE3_W,
    cIndexes: u32,
    szCallback: PWSTR,
    cbtyp: u32,
    grbit: u32,
    pSeqSpacehints: *JET_SPACEHINTS,
    pLVSpacehints: *JET_SPACEHINTS,
    cbSeparateLV: u32,
    tableid: JET_TABLEID,
    cCreated: u32,
};

pub const JET_OPENTEMPORARYTABLE = extern struct {
    cbStruct: u32,
    prgcolumndef: *const JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: *JET_UNICODEINDEX,
    grbit: u32,
    prgcolumnid: *u32,
    cbKeyMost: u32,
    cbVarSegMac: u32,
    tableid: JET_TABLEID,
};

pub const JET_OPENTEMPORARYTABLE2 = extern struct {
    cbStruct: u32,
    prgcolumndef: *const JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: *JET_UNICODEINDEX2,
    grbit: u32,
    prgcolumnid: *u32,
    cbKeyMost: u32,
    cbVarSegMac: u32,
    tableid: JET_TABLEID,
};

pub const JET_RETINFO = extern struct {
    cbStruct: u32,
    ibLongValue: u32,
    itagSequence: u32,
    columnidNextTagged: u32,
};

pub const JET_SETINFO = extern struct {
    cbStruct: u32,
    ibLongValue: u32,
    itagSequence: u32,
};

pub const JET_RECPOS = extern struct {
    cbStruct: u32,
    centriesLT: u32,
    centriesInRange: u32,
    centriesTotal: u32,
};

pub const JET_RECORDLIST = extern struct {
    cbStruct: u32,
    tableid: JET_TABLEID,
    cRecord: u32,
    columnidBookmark: u32,
};

pub const JET_INDEXRANGE = extern struct {
    cbStruct: u32,
    tableid: JET_TABLEID,
    grbit: u32,
};

pub const JET_RELOP = extern enum(i32) {
    Equals = 0,
    PrefixEquals = 1,
    NotEquals = 2,
    LessThanOrEqual = 3,
    LessThan = 4,
    GreaterThanOrEqual = 5,
    GreaterThan = 6,
    BitmaskEqualsZero = 7,
    BitmaskNotEqualsZero = 8,
};
pub const JET_relopEquals = JET_RELOP.Equals;
pub const JET_relopPrefixEquals = JET_RELOP.PrefixEquals;
pub const JET_relopNotEquals = JET_RELOP.NotEquals;
pub const JET_relopLessThanOrEqual = JET_RELOP.LessThanOrEqual;
pub const JET_relopLessThan = JET_RELOP.LessThan;
pub const JET_relopGreaterThanOrEqual = JET_RELOP.GreaterThanOrEqual;
pub const JET_relopGreaterThan = JET_RELOP.GreaterThan;
pub const JET_relopBitmaskEqualsZero = JET_RELOP.BitmaskEqualsZero;
pub const JET_relopBitmaskNotEqualsZero = JET_RELOP.BitmaskNotEqualsZero;

pub const JET_INDEX_COLUMN = extern struct {
    columnid: u32,
    relop: JET_RELOP,
    pv: *c_void,
    cb: u32,
    grbit: u32,
};

pub const JET_INDEX_RANGE = extern struct {
    rgStartColumns: *JET_INDEX_COLUMN,
    cStartColumns: u32,
    rgEndColumns: *JET_INDEX_COLUMN,
    cEndColumns: u32,
};

pub const JET_LOGTIME = extern struct {
    bSeconds: CHAR,
    bMinutes: CHAR,
    bHours: CHAR,
    bDay: CHAR,
    bMonth: CHAR,
    bYear: CHAR,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_BKLOGTIME = extern struct {
    bSeconds: CHAR,
    bMinutes: CHAR,
    bHours: CHAR,
    bDay: CHAR,
    bMonth: CHAR,
    bYear: CHAR,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_LGPOS = extern struct {
    ib: u16,
    isec: u16,
    lGeneration: i32,
};

pub const JET_SIGNATURE = extern struct {
    ulRandom: u32,
    logtimeCreate: JET_LOGTIME,
    szComputerName: [16]CHAR,
};

pub const JET_BKINFO = extern struct {
    lgposMark: JET_LGPOS,
    Anonymous: _Anonymous_e__Union,
    genLow: u32,
    genHigh: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_DBINFOMISC = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
};

pub const JET_DBINFOMISC2 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
};

pub const JET_DBINFOMISC3 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
    genCommitted: u32,
};

pub const JET_DBINFOMISC4 = extern struct {
    ulVersion: u32,
    ulUpdate: u32,
    signDb: JET_SIGNATURE,
    dbstate: u32,
    lgposConsistent: JET_LGPOS,
    logtimeConsistent: JET_LOGTIME,
    logtimeAttach: JET_LOGTIME,
    lgposAttach: JET_LGPOS,
    logtimeDetach: JET_LOGTIME,
    lgposDetach: JET_LGPOS,
    signLog: JET_SIGNATURE,
    bkinfoFullPrev: JET_BKINFO,
    bkinfoIncPrev: JET_BKINFO,
    bkinfoFullCur: JET_BKINFO,
    fShadowingDisabled: u32,
    fUpgradeDb: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    lSPNumber: i32,
    cbPageSize: u32,
    genMinRequired: u32,
    genMaxRequired: u32,
    logtimeGenMaxCreate: JET_LOGTIME,
    ulRepairCount: u32,
    logtimeRepair: JET_LOGTIME,
    ulRepairCountOld: u32,
    ulECCFixSuccess: u32,
    logtimeECCFixSuccess: JET_LOGTIME,
    ulECCFixSuccessOld: u32,
    ulECCFixFail: u32,
    logtimeECCFixFail: JET_LOGTIME,
    ulECCFixFailOld: u32,
    ulBadChecksum: u32,
    logtimeBadChecksum: JET_LOGTIME,
    ulBadChecksumOld: u32,
    genCommitted: u32,
    bkinfoCopyPrev: JET_BKINFO,
    bkinfoDiffPrev: JET_BKINFO,
};

pub const JET_THREADSTATS = extern struct {
    cbStruct: u32,
    cPageReferenced: u32,
    cPageRead: u32,
    cPagePreread: u32,
    cPageDirtied: u32,
    cPageRedirtied: u32,
    cLogRecord: u32,
    cbLogRecord: u32,
};

pub const JET_RSTINFO_A = extern struct {
    cbStruct: u32,
    rgrstmap: *JET_RSTMAP_A,
    crstmap: i32,
    lgposStop: JET_LGPOS,
    logtimeStop: JET_LOGTIME,
    pfnStatus: JET_PFNSTATUS,
};

pub const JET_RSTINFO_W = extern struct {
    cbStruct: u32,
    rgrstmap: *JET_RSTMAP_W,
    crstmap: i32,
    lgposStop: JET_LGPOS,
    logtimeStop: JET_LOGTIME,
    pfnStatus: JET_PFNSTATUS,
};

pub const JET_ERRCAT = extern enum(i32) {
    Unknown = 0,
    Error = 1,
    Operation = 2,
    Fatal = 3,
    IO = 4,
    Resource = 5,
    Memory = 6,
    Quota = 7,
    Disk = 8,
    Data = 9,
    Corruption = 10,
    Inconsistent = 11,
    Fragmentation = 12,
    Api = 13,
    Usage = 14,
    State = 15,
    Obsolete = 16,
    Max = 17,
};
pub const JET_errcatUnknown = JET_ERRCAT.Unknown;
pub const JET_errcatError = JET_ERRCAT.Error;
pub const JET_errcatOperation = JET_ERRCAT.Operation;
pub const JET_errcatFatal = JET_ERRCAT.Fatal;
pub const JET_errcatIO = JET_ERRCAT.IO;
pub const JET_errcatResource = JET_ERRCAT.Resource;
pub const JET_errcatMemory = JET_ERRCAT.Memory;
pub const JET_errcatQuota = JET_ERRCAT.Quota;
pub const JET_errcatDisk = JET_ERRCAT.Disk;
pub const JET_errcatData = JET_ERRCAT.Data;
pub const JET_errcatCorruption = JET_ERRCAT.Corruption;
pub const JET_errcatInconsistent = JET_ERRCAT.Inconsistent;
pub const JET_errcatFragmentation = JET_ERRCAT.Fragmentation;
pub const JET_errcatApi = JET_ERRCAT.Api;
pub const JET_errcatUsage = JET_ERRCAT.Usage;
pub const JET_errcatState = JET_ERRCAT.State;
pub const JET_errcatObsolete = JET_ERRCAT.Obsolete;
pub const JET_errcatMax = JET_ERRCAT.Max;

pub const JET_ERRINFOBASIC_W = extern struct {
    cbStruct: u32,
    errValue: i32,
    errcatMostSpecific: JET_ERRCAT,
    rgCategoricalHierarchy: [8]u8,
    lSourceLine: u32,
    rgszSourceFile: [64]u16,
};

pub const JET_INDEXCHECKING = extern enum(i32) {
    Off = 0,
    On = 1,
    DeferToOpenTable = 2,
    Max = 3,
};
pub const JET_IndexCheckingOff = JET_INDEXCHECKING.Off;
pub const JET_IndexCheckingOn = JET_INDEXCHECKING.On;
pub const JET_IndexCheckingDeferToOpenTable = JET_INDEXCHECKING.DeferToOpenTable;
pub const JET_IndexCheckingMax = JET_INDEXCHECKING.Max;

pub const JET_OPERATIONCONTEXT = extern struct {
    ulUserID: u32,
    nOperationID: u8,
    nOperationType: u8,
    nClientType: u8,
    fFlags: u8,
};

pub const JET_SETCOLUMN = extern struct {
    columnid: u32,
    pvData: *const c_void,
    cbData: u32,
    grbit: u32,
    ibLongValue: u32,
    itagSequence: u32,
    err: i32,
};

pub const JET_SETSYSPARAM_A = extern struct {
    paramid: u32,
    lParam: JET_API_PTR,
    sz: [*:0]const u8,
    err: i32,
};

pub const JET_SETSYSPARAM_W = extern struct {
    paramid: u32,
    lParam: JET_API_PTR,
    sz: [*:0]const u16,
    err: i32,
};

pub const JET_RETRIEVECOLUMN = extern struct {
    columnid: u32,
    pvData: *c_void,
    cbData: u32,
    cbActual: u32,
    grbit: u32,
    ibLongValue: u32,
    itagSequence: u32,
    columnidNextTagged: u32,
    err: i32,
};

pub const JET_ENUMCOLUMNID = extern struct {
    columnid: u32,
    ctagSequence: u32,
    rgtagSequence: *u32,
};

pub const JET_ENUMCOLUMNVALUE = extern struct {
    itagSequence: u32,
    err: i32,
    cbData: u32,
    pvData: *c_void,
};

pub const JET_ENUMCOLUMN = extern struct {
    columnid: u32,
    err: i32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JET_PFNREALLOC = fn(
    pvContext: ?*c_void,
    pv: ?*c_void,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const JET_LOGINFO_A = extern struct {
    cbSize: u32,
    ulGenLow: u32,
    ulGenHigh: u32,
    szBaseName: [4]CHAR,
};

pub const JET_LOGINFO_W = extern struct {
    cbSize: u32,
    ulGenLow: u32,
    ulGenHigh: u32,
    szBaseName: [4]u16,
};

pub const JET_INSTANCE_INFO_A = extern struct {
    hInstanceId: JET_INSTANCE,
    szInstanceName: PSTR,
    cDatabases: JET_API_PTR,
    szDatabaseFileName: **i8,
    szDatabaseDisplayName: **i8,
    szDatabaseSLVFileName_Obsolete: **i8,
};

pub const JET_INSTANCE_INFO_W = extern struct {
    hInstanceId: JET_INSTANCE,
    szInstanceName: PWSTR,
    cDatabases: JET_API_PTR,
    szDatabaseFileName: **u16,
    szDatabaseDisplayName: **u16,
    szDatabaseSLVFileName_Obsolete: **u16,
};

pub const PROPSPEC_KIND = extern enum(u32) {
    LPWSTR = 0,
    PROPID = 1,
};
pub const PRSPEC_LPWSTR = PROPSPEC_KIND.LPWSTR;
pub const PRSPEC_PROPID = PROPSPEC_KIND.PROPID;


//--------------------------------------------------------------------------------
// Section: Functions (274)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn WriteFmtUserTypeStg(
    pstg: *IStorage,
    cf: u16,
    lpszUserType: PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ReadFmtUserTypeStg(
    pstg: *IStorage,
    pcf: *u16,
    lplpszUserType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(
    lpolestream: *OLESTREAM,
    pstg: *IStorage,
    ptd: *const DVTARGETDEVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(
    pstg: *IStorage,
    lpolestream: *OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn SetConvertStg(
    pStg: *IStorage,
    fConvert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(
    pstg: *IStorage,
    cfFormat: u16,
    lWidth: i32,
    lHeight: i32,
    dwSize: u32,
    pmedium: *STGMEDIUM,
    polestm: *OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(
    polestm: *OLESTREAM,
    pstg: *IStorage,
    pcfFormat: *u16,
    plwWidth: *i32,
    plHeight: *i32,
    pdwSize: *u32,
    pmedium: *STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateStreamOnHGlobal(
    hGlobal: isize,
    fDeleteOnRelease: BOOL,
    ppstm: **IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetHGlobalFromStream(
    pstm: *IStream,
    phglobal: *isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn PropVariantCopy(
    pvarDest: *PROPVARIANT,
    pvarSrc: *const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn PropVariantClear(
    pvar: *PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn FreePropVariantArray(
    cVariants: u32,
    rgvars: [*]PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "PROPSYS" fn StgSerializePropVariant(
    ppropvar: *const PROPVARIANT,
    ppProp: **SERIALIZEDPROPERTYVALUE,
    pcb: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "PROPSYS" fn StgDeserializePropVariant(
    pprop: *const SERIALIZEDPROPERTYVALUE,
    cbMax: u32,
    ppropvar: *PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgCreateDocfile(
    pwcsName: ?[*:0]const u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgCreateDocfileOnILockBytes(
    plkbyt: *ILockBytes,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgOpenStorage(
    pwcsName: ?[*:0]const u16,
    pstgPriority: ?*IStorage,
    grfMode: u32,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgOpenStorageOnILockBytes(
    plkbyt: *ILockBytes,
    pstgPriority: ?*IStorage,
    grfMode: u32,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgIsStorageFile(
    pwcsName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgIsStorageILockBytes(
    plkbyt: *ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgSetTimes(
    lpszName: [*:0]const u16,
    pctime: ?*const FILETIME,
    patime: ?*const FILETIME,
    pmtime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgCreateStorageEx(
    pwcsName: ?[*:0]const u16,
    grfMode: u32,
    stgfmt: u32,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    riid: *const Guid,
    ppObjectOpen: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgOpenStorageEx(
    pwcsName: [*:0]const u16,
    grfMode: u32,
    stgfmt: u32,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    riid: *const Guid,
    ppObjectOpen: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgCreatePropStg(
    pUnk: *IUnknown,
    fmtid: *const Guid,
    pclsid: *const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: **IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgOpenPropStg(
    pUnk: *IUnknown,
    fmtid: *const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: **IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StgCreatePropSetStg(
    pStorage: *IStorage,
    dwReserved: u32,
    ppPropSetStg: **IPropertySetStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn FmtIdToPropStgName(
    pfmtid: *const Guid,
    oszName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn PropStgNameToFmtId(
    oszName: [*:0]const u16,
    pfmtid: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ReadClassStg(
    pStg: *IStorage,
    pclsid: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn WriteClassStg(
    pStg: *IStorage,
    rclsid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ReadClassStm(
    pStm: *IStream,
    pclsid: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn WriteClassStm(
    pStm: *IStream,
    rclsid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetHGlobalFromILockBytes(
    plkbyt: *ILockBytes,
    phglobal: *isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateILockBytesOnHGlobal(
    hGlobal: isize,
    fDeleteOnRelease: BOOL,
    pplkbyt: **ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetConvertStg(
    pStg: *IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn DcomChannelSetHResult(
    pvReserved: ?*c_void,
    pulReserved: ?*u32,
    appsHR: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(
    pflb: *IFillLockBytes,
    grfMode: u32,
    asyncFlags: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(
    pilb: *ILockBytes,
    ppflb: **IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnFile(
    pwcsName: [*:0]const u16,
    ppflb: **IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dflayout" fn StgOpenLayoutDocfile(
    pwcsDfName: [*:0]const u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: **IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertVariantToProperty(
    pvar: *const PROPVARIANT,
    CodePage: u16,
    // TODO: what to do with BytesParamIndex 3?
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    pcb: *u32,
    pid: u32,
    fReserved: u8,
    pcIndirect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) *SERIALIZEDPROPERTYVALUE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertPropertyToVariant(
    pprop: *const SERIALIZEDPROPERTYVALUE,
    CodePage: u16,
    pvar: *PROPVARIANT,
    pma: *PMemoryAllocator,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ole32" fn CreateStdProgressIndicator(
    hwndParent: HWND,
    pszTitle: [*:0]const u16,
    pIbscCaller: *IBindStatusCallback,
    ppIbsc: **IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgPropertyLengthAsVariant(
    // TODO: what to do with BytesParamIndex 1?
    pProp: *const SERIALIZEDPROPERTYVALUE,
    cbProp: u32,
    CodePage: u16,
    bReserved: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ESENT" fn JetInit(
    pinstance: ?*JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetInit2(
    pinstance: ?*JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetInit3A(
    pinstance: ?*JET_INSTANCE,
    prstInfo: ?*JET_RSTINFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetInit3W(
    pinstance: ?*JET_INSTANCE,
    prstInfo: ?*JET_RSTINFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateInstanceA(
    pinstance: *JET_INSTANCE,
    szInstanceName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateInstanceW(
    pinstance: *JET_INSTANCE,
    szInstanceName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateInstance2A(
    pinstance: *JET_INSTANCE,
    szInstanceName: ?*i8,
    szDisplayName: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateInstance2W(
    pinstance: *JET_INSTANCE,
    szInstanceName: ?*u16,
    szDisplayName: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetInstanceMiscInfo(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetTerm(
    instance: JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetTerm2(
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetStopService(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetStopServiceInstance(
    instance: JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetStopServiceInstance2(
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetStopBackup(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetStopBackupInstance(
    instance: JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetSystemParameterA(
    pinstance: ?*JET_INSTANCE,
    sesid: JET_SESID,
    paramid: u32,
    lParam: JET_API_PTR,
    szParam: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetSystemParameterW(
    pinstance: ?*JET_INSTANCE,
    sesid: JET_SESID,
    paramid: u32,
    lParam: JET_API_PTR,
    szParam: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetSystemParameterA(
    instance: JET_INSTANCE,
    sesid: JET_SESID,
    paramid: u32,
    plParam: ?*JET_API_PTR,
    // TODO: what to do with BytesParamIndex 5?
    szParam: ?*i8,
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetSystemParameterW(
    instance: JET_INSTANCE,
    sesid: JET_SESID,
    paramid: u32,
    plParam: ?*JET_API_PTR,
    // TODO: what to do with BytesParamIndex 5?
    szParam: ?*u16,
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEnableMultiInstanceA(
    psetsysparam: ?[*]JET_SETSYSPARAM_A,
    csetsysparam: u32,
    pcsetsucceed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEnableMultiInstanceW(
    psetsysparam: ?[*]JET_SETSYSPARAM_W,
    csetsysparam: u32,
    pcsetsucceed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetThreadStats(
    // TODO: what to do with BytesParamIndex 1?
    pvResult: *c_void,
    cbMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginSessionA(
    instance: JET_INSTANCE,
    psesid: *JET_SESID,
    szUserName: ?*i8,
    szPassword: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginSessionW(
    instance: JET_INSTANCE,
    psesid: *JET_SESID,
    szUserName: ?*u16,
    szPassword: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDupSession(
    sesid: JET_SESID,
    psesid: *JET_SESID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEndSession(
    sesid: JET_SESID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetVersion(
    sesid: JET_SESID,
    pwVersion: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetIdle(
    sesid: JET_SESID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateDatabaseA(
    sesid: JET_SESID,
    szFilename: *i8,
    szConnect: ?*i8,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateDatabaseW(
    sesid: JET_SESID,
    szFilename: *u16,
    szConnect: ?*u16,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateDatabase2A(
    sesid: JET_SESID,
    szFilename: *i8,
    cpgDatabaseSizeMax: u32,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateDatabase2W(
    sesid: JET_SESID,
    szFilename: *u16,
    cpgDatabaseSizeMax: u32,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAttachDatabaseA(
    sesid: JET_SESID,
    szFilename: *i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAttachDatabaseW(
    sesid: JET_SESID,
    szFilename: *u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAttachDatabase2A(
    sesid: JET_SESID,
    szFilename: *i8,
    cpgDatabaseSizeMax: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAttachDatabase2W(
    sesid: JET_SESID,
    szFilename: *u16,
    cpgDatabaseSizeMax: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDetachDatabaseA(
    sesid: JET_SESID,
    szFilename: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDetachDatabaseW(
    sesid: JET_SESID,
    szFilename: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDetachDatabase2A(
    sesid: JET_SESID,
    szFilename: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDetachDatabase2W(
    sesid: JET_SESID,
    szFilename: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetObjectInfoA(
    sesid: JET_SESID,
    dbid: u32,
    objtyp: u32,
    szContainerName: ?*i8,
    szObjectName: ?*i8,
    // TODO: what to do with BytesParamIndex 6?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetObjectInfoW(
    sesid: JET_SESID,
    dbid: u32,
    objtyp: u32,
    szContainerName: ?*u16,
    szObjectName: ?*u16,
    // TODO: what to do with BytesParamIndex 6?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableInfoA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableInfoW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
    lPages: u32,
    lDensity: u32,
    ptableid: *JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
    lPages: u32,
    lDensity: u32,
    ptableid: *JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndexA(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndexW(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex2A(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE2_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex2W(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE2_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex3A(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE3_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex3W(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE3_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex4A(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE4_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateTableColumnIndex4W(
    sesid: JET_SESID,
    dbid: u32,
    ptablecreate: *JET_TABLECREATE4_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteTableA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteTableW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRenameTableA(
    sesid: JET_SESID,
    dbid: u32,
    szName: *i8,
    szNameNew: *i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRenameTableW(
    sesid: JET_SESID,
    dbid: u32,
    szName: *u16,
    szNameNew: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableColumnInfoA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: ?*i8,
    // TODO: what to do with BytesParamIndex 4?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableColumnInfoW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: ?*u16,
    // TODO: what to do with BytesParamIndex 4?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetColumnInfoA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
    pColumnNameOrId: ?*i8,
    // TODO: what to do with BytesParamIndex 5?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetColumnInfoW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
    pwColumnNameOrId: ?*u16,
    // TODO: what to do with BytesParamIndex 5?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAddColumnA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *i8,
    pcolumndef: *const JET_COLUMNDEF,
    // TODO: what to do with BytesParamIndex 5?
    pvDefault: ?*const c_void,
    cbDefault: u32,
    pcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetAddColumnW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *u16,
    pcolumndef: *const JET_COLUMNDEF,
    // TODO: what to do with BytesParamIndex 5?
    pvDefault: ?*const c_void,
    cbDefault: u32,
    pcolumnid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteColumnA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteColumnW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteColumn2A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteColumn2W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szColumnName: *u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRenameColumnA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szName: *i8,
    szNameNew: *i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRenameColumnW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szName: *u16,
    szNameNew: *u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetColumnDefaultValueA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
    szColumnName: *i8,
    // TODO: what to do with BytesParamIndex 5?
    pvData: *const c_void,
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetColumnDefaultValueW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
    szColumnName: *u16,
    // TODO: what to do with BytesParamIndex 5?
    pvData: *const c_void,
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableIndexInfoA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*i8,
    // TODO: what to do with BytesParamIndex 4?
    pvResult: *c_void,
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTableIndexInfoW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*u16,
    // TODO: what to do with BytesParamIndex 4?
    pvResult: *c_void,
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetIndexInfoA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
    szIndexName: ?*i8,
    // TODO: what to do with BytesParamIndex 5?
    pvResult: *c_void,
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetIndexInfoW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
    szIndexName: ?*u16,
    // TODO: what to do with BytesParamIndex 5?
    pvResult: *c_void,
    cbResult: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndexA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: *i8,
    grbit: u32,
    // TODO: what to do with BytesParamIndex 5?
    szKey: [*:0]const u8,
    cbKey: u32,
    lDensity: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndexW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: *u16,
    grbit: u32,
    // TODO: what to do with BytesParamIndex 5?
    szKey: [*:0]const u16,
    cbKey: u32,
    lDensity: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex2A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex2W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex3A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE2_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex3W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE2_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex4A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE3_A,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCreateIndex4W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pindexcreate: [*]JET_INDEXCREATE3_W,
    cIndexCreate: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteIndexA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: *i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDeleteIndexW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginTransaction(
    sesid: JET_SESID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginTransaction2(
    sesid: JET_SESID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginTransaction3(
    sesid: JET_SESID,
    trxid: i64,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCommitTransaction(
    sesid: JET_SESID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCommitTransaction2(
    sesid: JET_SESID,
    grbit: u32,
    cmsecDurableCommit: u32,
    pCommitId: ?*JET_COMMIT_ID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRollback(
    sesid: JET_SESID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetDatabaseInfoA(
    sesid: JET_SESID,
    dbid: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetDatabaseInfoW(
    sesid: JET_SESID,
    dbid: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetDatabaseFileInfoA(
    szDatabaseName: *i8,
    // TODO: what to do with BytesParamIndex 2?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetDatabaseFileInfoW(
    szDatabaseName: *u16,
    // TODO: what to do with BytesParamIndex 2?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenDatabaseA(
    sesid: JET_SESID,
    szFilename: *i8,
    szConnect: ?*i8,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenDatabaseW(
    sesid: JET_SESID,
    szFilename: *u16,
    szConnect: ?*u16,
    pdbid: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCloseDatabase(
    sesid: JET_SESID,
    dbid: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTableA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *i8,
    // TODO: what to do with BytesParamIndex 4?
    pvParameters: ?*const c_void,
    cbParameters: u32,
    grbit: u32,
    ptableid: *JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTableW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: *u16,
    // TODO: what to do with BytesParamIndex 4?
    pvParameters: ?*const c_void,
    cbParameters: u32,
    grbit: u32,
    ptableid: *JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetTableSequential(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetResetTableSequential(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCloseTable(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDelete(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetUpdate(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvBookmark: ?*c_void,
    cbBookmark: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetUpdate2(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvBookmark: ?*c_void,
    cbBookmark: u32,
    pcbActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEscrowUpdate(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    columnid: u32,
    // TODO: what to do with BytesParamIndex 4?
    pv: *c_void,
    cbMax: u32,
    // TODO: what to do with BytesParamIndex 6?
    pvOld: ?*c_void,
    cbOldMax: u32,
    pcbOldActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRetrieveColumn(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    columnid: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*c_void,
    cbData: u32,
    pcbActual: ?*u32,
    grbit: u32,
    pretinfo: ?*JET_RETINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRetrieveColumns(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pretrievecolumn: ?[*]JET_RETRIEVECOLUMN,
    cretrievecolumn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEnumerateColumns(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    cEnumColumnId: u32,
    rgEnumColumnId: ?[*]JET_ENUMCOLUMNID,
    pcEnumColumn: *u32,
    prgEnumColumn: **JET_ENUMCOLUMN,
    pfnRealloc: JET_PFNREALLOC,
    pvReallocContext: ?*c_void,
    cbDataMost: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetRecordSize(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    precsize: *JET_RECSIZE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetRecordSize2(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    precsize: *JET_RECSIZE2,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetColumn(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    columnid: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const c_void,
    cbData: u32,
    grbit: u32,
    psetinfo: ?*JET_SETINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetColumns(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    psetcolumn: ?[*]JET_SETCOLUMN,
    csetcolumn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetPrepareUpdate(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    prep: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetRecordPosition(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    precpos: *JET_RECPOS,
    cbRecpos: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGotoPosition(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    precpos: *JET_RECPOS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetCursorInfo(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDupCursor(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    ptableid: *JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetCurrentIndexA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    szIndexName: *i8,
    cbIndexName: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetCurrentIndexW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    szIndexName: *u16,
    cbIndexName: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndexA(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndexW(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex2A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*i8,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex2W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*u16,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex3A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*i8,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex3W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*u16,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex4A(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*i8,
    pindexid: ?*JET_INDEXID,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCurrentIndex4W(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    szIndexName: ?*u16,
    pindexid: ?*JET_INDEXID,
    grbit: u32,
    itagSequence: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetMove(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    cRow: i32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetCursorFilter(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    rgColumnFilters: [*]JET_INDEX_COLUMN,
    cColumnFilters: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLock(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetMakeKey(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*const c_void,
    cbData: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSeek(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetPrereadKeys(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    rgpvKeys: [*]const *const c_void,
    rgcbKeys: [*]const u32,
    ckeys: i32,
    pckeysPreread: ?*i32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetPrereadIndexRanges(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    rgIndexRanges: [*]const JET_INDEX_RANGE,
    cIndexRanges: u32,
    pcRangesPreread: ?*u32,
    rgcolumnidPreread: [*]const u32,
    ccolumnidPreread: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetBookmark(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvBookmark: ?*c_void,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetSecondaryIndexBookmark(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvSecondaryKey: ?*c_void,
    cbSecondaryKeyMax: u32,
    pcbSecondaryKeyActual: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvPrimaryBookmark: ?*c_void,
    cbPrimaryBookmarkMax: u32,
    pcbPrimaryBookmarkActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCompactA(
    sesid: JET_SESID,
    szDatabaseSrc: *i8,
    szDatabaseDest: *i8,
    pfnStatus: JET_PFNSTATUS,
    pconvert: ?*CONVERT_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCompactW(
    sesid: JET_SESID,
    szDatabaseSrc: *u16,
    szDatabaseDest: *u16,
    pfnStatus: JET_PFNSTATUS,
    pconvert: ?*CONVERT_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragmentA(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragmentW(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragment2A(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragment2W(
    sesid: JET_SESID,
    dbid: u32,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragment3A(
    sesid: JET_SESID,
    szDatabaseName: *i8,
    szTableName: ?*i8,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    pvContext: *c_void,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetDefragment3W(
    sesid: JET_SESID,
    szDatabaseName: *u16,
    szTableName: ?*u16,
    pcPasses: ?*u32,
    pcSeconds: ?*u32,
    callback: JET_CALLBACK,
    pvContext: *c_void,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetDatabaseSizeA(
    sesid: JET_SESID,
    szDatabaseName: *i8,
    cpg: u32,
    pcpgReal: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetDatabaseSizeW(
    sesid: JET_SESID,
    szDatabaseName: *u16,
    cpg: u32,
    pcpgReal: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGrowDatabase(
    sesid: JET_SESID,
    dbid: u32,
    cpg: u32,
    pcpgReal: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetResizeDatabase(
    sesid: JET_SESID,
    dbid: u32,
    cpgTarget: u32,
    pcpgActual: *u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetSessionContext(
    sesid: JET_SESID,
    ulContext: JET_API_PTR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetResetSessionContext(
    sesid: JET_SESID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGotoBookmark(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvBookmark: *c_void,
    cbBookmark: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGotoSecondaryIndexBookmark(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvSecondaryKey: *c_void,
    cbSecondaryKey: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvPrimaryBookmark: ?*c_void,
    cbPrimaryBookmark: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetIntersectIndexes(
    sesid: JET_SESID,
    rgindexrange: [*]JET_INDEXRANGE,
    cindexrange: u32,
    precordlist: *JET_RECORDLIST,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetComputeStats(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTempTable(
    sesid: JET_SESID,
    prgcolumndef: [*]const JET_COLUMNDEF,
    ccolumn: u32,
    grbit: u32,
    ptableid: *JET_TABLEID,
    prgcolumnid: [*]u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTempTable2(
    sesid: JET_SESID,
    prgcolumndef: [*]const JET_COLUMNDEF,
    ccolumn: u32,
    lcid: u32,
    grbit: u32,
    ptableid: *JET_TABLEID,
    prgcolumnid: [*]u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTempTable3(
    sesid: JET_SESID,
    prgcolumndef: [*]const JET_COLUMNDEF,
    ccolumn: u32,
    pidxunicode: ?*JET_UNICODEINDEX,
    grbit: u32,
    ptableid: *JET_TABLEID,
    prgcolumnid: [*]u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTemporaryTable(
    sesid: JET_SESID,
    popentemporarytable: *JET_OPENTEMPORARYTABLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenTemporaryTable2(
    sesid: JET_SESID,
    popentemporarytable: *JET_OPENTEMPORARYTABLE2,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBackupA(
    szBackupPath: *i8,
    grbit: u32,
    pfnStatus: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBackupW(
    szBackupPath: *u16,
    grbit: u32,
    pfnStatus: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBackupInstanceA(
    instance: JET_INSTANCE,
    szBackupPath: *i8,
    grbit: u32,
    pfnStatus: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBackupInstanceW(
    instance: JET_INSTANCE,
    szBackupPath: *u16,
    grbit: u32,
    pfnStatus: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestoreA(
    szSource: *i8,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestoreW(
    szSource: *u16,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestore2A(
    sz: *i8,
    szDest: ?*i8,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestore2W(
    sz: *u16,
    szDest: ?*u16,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestoreInstanceA(
    instance: JET_INSTANCE,
    sz: *i8,
    szDest: ?*i8,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRestoreInstanceW(
    instance: JET_INSTANCE,
    sz: *u16,
    szDest: ?*u16,
    pfn: ?JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetIndexRange(
    sesid: JET_SESID,
    tableidSrc: JET_TABLEID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetIndexRecordCount(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pcrec: *u32,
    crecMax: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRetrieveKey(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    // TODO: what to do with BytesParamIndex 3?
    pvKey: ?*c_void,
    cbMax: u32,
    pcbActual: ?*u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginExternalBackup(
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetBeginExternalBackupInstance(
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetAttachInfoA(
    // TODO: what to do with BytesParamIndex 1?
    szzDatabases: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetAttachInfoW(
    // TODO: what to do with BytesParamIndex 1?
    wszzDatabases: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetAttachInfoInstanceA(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    szzDatabases: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetAttachInfoInstanceW(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    szzDatabases: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenFileA(
    szFileName: *i8,
    phfFile: *JET_HANDLE,
    pulFileSizeLow: *u32,
    pulFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenFileW(
    szFileName: *u16,
    phfFile: *JET_HANDLE,
    pulFileSizeLow: *u32,
    pulFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenFileInstanceA(
    instance: JET_INSTANCE,
    szFileName: *i8,
    phfFile: *JET_HANDLE,
    pulFileSizeLow: *u32,
    pulFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOpenFileInstanceW(
    instance: JET_INSTANCE,
    szFileName: *u16,
    phfFile: *JET_HANDLE,
    pulFileSizeLow: *u32,
    pulFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetReadFile(
    hfFile: JET_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pv: *c_void,
    cb: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetReadFileInstance(
    instance: JET_INSTANCE,
    hfFile: JET_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pv: *c_void,
    cb: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCloseFile(
    hfFile: JET_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetCloseFileInstance(
    instance: JET_INSTANCE,
    hfFile: JET_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoA(
    // TODO: what to do with BytesParamIndex 1?
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoW(
    // TODO: what to do with BytesParamIndex 1?
    szzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoInstanceA(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoInstanceW(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoInstance2A(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
    pLogInfo: ?*JET_LOGINFO_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLogInfoInstance2W(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
    pLogInfo: ?*JET_LOGINFO_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTruncateLogInfoInstanceA(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    szzLogs: ?*i8,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetTruncateLogInfoInstanceW(
    instance: JET_INSTANCE,
    // TODO: what to do with BytesParamIndex 2?
    wszzLogs: ?*u16,
    cbMax: u32,
    pcbActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetTruncateLog(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetTruncateLogInstance(
    instance: JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEndExternalBackup(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEndExternalBackupInstance(
    instance: JET_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetEndExternalBackupInstance2(
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetExternalRestoreA(
    szCheckpointFilePath: *i8,
    szLogPath: *i8,
    rgrstmap: ?[*]JET_RSTMAP_A,
    crstfilemap: i32,
    szBackupLogPath: *i8,
    genLow: i32,
    genHigh: i32,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetExternalRestoreW(
    szCheckpointFilePath: *u16,
    szLogPath: *u16,
    rgrstmap: ?[*]JET_RSTMAP_W,
    crstfilemap: i32,
    szBackupLogPath: *u16,
    genLow: i32,
    genHigh: i32,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetExternalRestore2A(
    szCheckpointFilePath: *i8,
    szLogPath: *i8,
    rgrstmap: ?[*]JET_RSTMAP_A,
    crstfilemap: i32,
    szBackupLogPath: *i8,
    pLogInfo: *JET_LOGINFO_A,
    szTargetInstanceName: ?*i8,
    szTargetInstanceLogPath: ?*i8,
    szTargetInstanceCheckpointPath: ?*i8,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetExternalRestore2W(
    szCheckpointFilePath: *u16,
    szLogPath: *u16,
    rgrstmap: ?[*]JET_RSTMAP_W,
    crstfilemap: i32,
    szBackupLogPath: *u16,
    pLogInfo: *JET_LOGINFO_W,
    szTargetInstanceName: ?*u16,
    szTargetInstanceLogPath: ?*u16,
    szTargetInstanceCheckpointPath: ?*u16,
    pfn: JET_PFNSTATUS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetRegisterCallback(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    cbtyp: u32,
    pCallback: JET_CALLBACK,
    pvContext: ?*c_void,
    phCallbackId: *JET_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetUnregisterCallback(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    cbtyp: u32,
    hCallbackId: JET_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetInstanceInfoA(
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_A,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetInstanceInfoW(
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_W,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetFreeBuffer(
    pbBuf: PSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetLS(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    ls: JET_LS,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetLS(
    sesid: JET_SESID,
    tableid: JET_TABLEID,
    pls: *JET_LS,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotPrepare(
    psnapId: *JET_OSSNAPID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotPrepareInstance(
    snapId: JET_OSSNAPID,
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotFreezeA(
    snapId: JET_OSSNAPID,
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotFreezeW(
    snapId: JET_OSSNAPID,
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotThaw(
    snapId: JET_OSSNAPID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotAbort(
    snapId: JET_OSSNAPID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotTruncateLog(
    snapId: JET_OSSNAPID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotTruncateLogInstance(
    snapId: JET_OSSNAPID,
    instance: JET_INSTANCE,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotGetFreezeInfoA(
    snapId: JET_OSSNAPID,
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_A,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotGetFreezeInfoW(
    snapId: JET_OSSNAPID,
    pcInstanceInfo: *u32,
    paInstanceInfo: **JET_INSTANCE_INFO_W,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetOSSnapshotEnd(
    snapId: JET_OSSNAPID,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetConfigureProcessForCrashDump(
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetErrorInfoW(
    pvContext: ?*c_void,
    // TODO: what to do with BytesParamIndex 2?
    pvResult: *c_void,
    cbMax: u32,
    InfoLevel: u32,
    grbit: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetSetSessionParameter(
    sesid: JET_SESID,
    sesparamid: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvParam: ?*c_void,
    cbParam: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ESENT" fn JetGetSessionParameter(
    sesid: JET_SESID,
    sesparamid: u32,
    pvParam: [*]u8,
    cbParamMax: u32,
    pcbParamActual: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (85)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const JET_RSTMAP_ = JET_RSTMAP_A;
        pub const CONVERT_ = CONVERT_A;
        pub const JET_COLUMNBASE_ = JET_COLUMNBASE_A;
        pub const JET_COLUMNCREATE_ = JET_COLUMNCREATE_A;
        pub const JET_USERDEFINEDDEFAULT_ = JET_USERDEFINEDDEFAULT_A;
        pub const JET_CONDITIONALCOLUMN_ = JET_CONDITIONALCOLUMN_A;
        pub const JET_INDEXCREATE_ = JET_INDEXCREATE_A;
        pub const JET_INDEXCREATE2_ = JET_INDEXCREATE2_A;
        pub const JET_INDEXCREATE3_ = JET_INDEXCREATE3_A;
        pub const JET_TABLECREATE_ = JET_TABLECREATE_A;
        pub const JET_TABLECREATE2_ = JET_TABLECREATE2_A;
        pub const JET_TABLECREATE3_ = JET_TABLECREATE3_A;
        pub const JET_TABLECREATE4_ = JET_TABLECREATE4_A;
        pub const JET_RSTINFO_ = JET_RSTINFO_A;
        pub const JET_SETSYSPARAM_ = JET_SETSYSPARAM_A;
        pub const JET_LOGINFO_ = JET_LOGINFO_A;
        pub const JET_INSTANCE_INFO_ = JET_INSTANCE_INFO_A;
        pub const JetInit3 = JetInit3A;
        pub const JetCreateInstance = JetCreateInstanceA;
        pub const JetCreateInstance2 = JetCreateInstance2A;
        pub const JetSetSystemParameter = JetSetSystemParameterA;
        pub const JetGetSystemParameter = JetGetSystemParameterA;
        pub const JetEnableMultiInstance = JetEnableMultiInstanceA;
        pub const JetBeginSession = JetBeginSessionA;
        pub const JetCreateDatabase = JetCreateDatabaseA;
        pub const JetCreateDatabase2 = JetCreateDatabase2A;
        pub const JetAttachDatabase = JetAttachDatabaseA;
        pub const JetAttachDatabase2 = JetAttachDatabase2A;
        pub const JetDetachDatabase = JetDetachDatabaseA;
        pub const JetDetachDatabase2 = JetDetachDatabase2A;
        pub const JetGetObjectInfo = JetGetObjectInfoA;
        pub const JetGetTableInfo = JetGetTableInfoA;
        pub const JetCreateTable = JetCreateTableA;
        pub const JetCreateTableColumnIndex = JetCreateTableColumnIndexA;
        pub const JetCreateTableColumnIndex2 = JetCreateTableColumnIndex2A;
        pub const JetCreateTableColumnIndex3 = JetCreateTableColumnIndex3A;
        pub const JetCreateTableColumnIndex4 = JetCreateTableColumnIndex4A;
        pub const JetDeleteTable = JetDeleteTableA;
        pub const JetRenameTable = JetRenameTableA;
        pub const JetGetTableColumnInfo = JetGetTableColumnInfoA;
        pub const JetGetColumnInfo = JetGetColumnInfoA;
        pub const JetAddColumn = JetAddColumnA;
        pub const JetDeleteColumn = JetDeleteColumnA;
        pub const JetDeleteColumn2 = JetDeleteColumn2A;
        pub const JetRenameColumn = JetRenameColumnA;
        pub const JetSetColumnDefaultValue = JetSetColumnDefaultValueA;
        pub const JetGetTableIndexInfo = JetGetTableIndexInfoA;
        pub const JetGetIndexInfo = JetGetIndexInfoA;
        pub const JetCreateIndex = JetCreateIndexA;
        pub const JetCreateIndex2 = JetCreateIndex2A;
        pub const JetCreateIndex3 = JetCreateIndex3A;
        pub const JetCreateIndex4 = JetCreateIndex4A;
        pub const JetDeleteIndex = JetDeleteIndexA;
        pub const JetGetDatabaseInfo = JetGetDatabaseInfoA;
        pub const JetGetDatabaseFileInfo = JetGetDatabaseFileInfoA;
        pub const JetOpenDatabase = JetOpenDatabaseA;
        pub const JetOpenTable = JetOpenTableA;
        pub const JetGetCurrentIndex = JetGetCurrentIndexA;
        pub const JetSetCurrentIndex = JetSetCurrentIndexA;
        pub const JetSetCurrentIndex2 = JetSetCurrentIndex2A;
        pub const JetSetCurrentIndex3 = JetSetCurrentIndex3A;
        pub const JetSetCurrentIndex4 = JetSetCurrentIndex4A;
        pub const JetCompact = JetCompactA;
        pub const JetDefragment = JetDefragmentA;
        pub const JetDefragment2 = JetDefragment2A;
        pub const JetDefragment3 = JetDefragment3A;
        pub const JetSetDatabaseSize = JetSetDatabaseSizeA;
        pub const JetBackup = JetBackupA;
        pub const JetBackupInstance = JetBackupInstanceA;
        pub const JetRestore = JetRestoreA;
        pub const JetRestore2 = JetRestore2A;
        pub const JetRestoreInstance = JetRestoreInstanceA;
        pub const JetGetAttachInfo = JetGetAttachInfoA;
        pub const JetGetAttachInfoInstance = JetGetAttachInfoInstanceA;
        pub const JetOpenFile = JetOpenFileA;
        pub const JetOpenFileInstance = JetOpenFileInstanceA;
        pub const JetGetLogInfo = JetGetLogInfoA;
        pub const JetGetLogInfoInstance = JetGetLogInfoInstanceA;
        pub const JetGetLogInfoInstance2 = JetGetLogInfoInstance2A;
        pub const JetGetTruncateLogInfoInstance = JetGetTruncateLogInfoInstanceA;
        pub const JetExternalRestore = JetExternalRestoreA;
        pub const JetExternalRestore2 = JetExternalRestore2A;
        pub const JetGetInstanceInfo = JetGetInstanceInfoA;
        pub const JetOSSnapshotFreeze = JetOSSnapshotFreezeA;
        pub const JetOSSnapshotGetFreezeInfo = JetOSSnapshotGetFreezeInfoA;
    },
    .wide => struct {
        pub const JET_RSTMAP_ = JET_RSTMAP_W;
        pub const CONVERT_ = CONVERT_W;
        pub const JET_COLUMNBASE_ = JET_COLUMNBASE_W;
        pub const JET_COLUMNCREATE_ = JET_COLUMNCREATE_W;
        pub const JET_USERDEFINEDDEFAULT_ = JET_USERDEFINEDDEFAULT_W;
        pub const JET_CONDITIONALCOLUMN_ = JET_CONDITIONALCOLUMN_W;
        pub const JET_INDEXCREATE_ = JET_INDEXCREATE_W;
        pub const JET_INDEXCREATE2_ = JET_INDEXCREATE2_W;
        pub const JET_INDEXCREATE3_ = JET_INDEXCREATE3_W;
        pub const JET_TABLECREATE_ = JET_TABLECREATE_W;
        pub const JET_TABLECREATE2_ = JET_TABLECREATE2_W;
        pub const JET_TABLECREATE3_ = JET_TABLECREATE3_W;
        pub const JET_TABLECREATE4_ = JET_TABLECREATE4_W;
        pub const JET_RSTINFO_ = JET_RSTINFO_W;
        pub const JET_SETSYSPARAM_ = JET_SETSYSPARAM_W;
        pub const JET_LOGINFO_ = JET_LOGINFO_W;
        pub const JET_INSTANCE_INFO_ = JET_INSTANCE_INFO_W;
        pub const JetInit3 = JetInit3W;
        pub const JetCreateInstance = JetCreateInstanceW;
        pub const JetCreateInstance2 = JetCreateInstance2W;
        pub const JetSetSystemParameter = JetSetSystemParameterW;
        pub const JetGetSystemParameter = JetGetSystemParameterW;
        pub const JetEnableMultiInstance = JetEnableMultiInstanceW;
        pub const JetBeginSession = JetBeginSessionW;
        pub const JetCreateDatabase = JetCreateDatabaseW;
        pub const JetCreateDatabase2 = JetCreateDatabase2W;
        pub const JetAttachDatabase = JetAttachDatabaseW;
        pub const JetAttachDatabase2 = JetAttachDatabase2W;
        pub const JetDetachDatabase = JetDetachDatabaseW;
        pub const JetDetachDatabase2 = JetDetachDatabase2W;
        pub const JetGetObjectInfo = JetGetObjectInfoW;
        pub const JetGetTableInfo = JetGetTableInfoW;
        pub const JetCreateTable = JetCreateTableW;
        pub const JetCreateTableColumnIndex = JetCreateTableColumnIndexW;
        pub const JetCreateTableColumnIndex2 = JetCreateTableColumnIndex2W;
        pub const JetCreateTableColumnIndex3 = JetCreateTableColumnIndex3W;
        pub const JetCreateTableColumnIndex4 = JetCreateTableColumnIndex4W;
        pub const JetDeleteTable = JetDeleteTableW;
        pub const JetRenameTable = JetRenameTableW;
        pub const JetGetTableColumnInfo = JetGetTableColumnInfoW;
        pub const JetGetColumnInfo = JetGetColumnInfoW;
        pub const JetAddColumn = JetAddColumnW;
        pub const JetDeleteColumn = JetDeleteColumnW;
        pub const JetDeleteColumn2 = JetDeleteColumn2W;
        pub const JetRenameColumn = JetRenameColumnW;
        pub const JetSetColumnDefaultValue = JetSetColumnDefaultValueW;
        pub const JetGetTableIndexInfo = JetGetTableIndexInfoW;
        pub const JetGetIndexInfo = JetGetIndexInfoW;
        pub const JetCreateIndex = JetCreateIndexW;
        pub const JetCreateIndex2 = JetCreateIndex2W;
        pub const JetCreateIndex3 = JetCreateIndex3W;
        pub const JetCreateIndex4 = JetCreateIndex4W;
        pub const JetDeleteIndex = JetDeleteIndexW;
        pub const JetGetDatabaseInfo = JetGetDatabaseInfoW;
        pub const JetGetDatabaseFileInfo = JetGetDatabaseFileInfoW;
        pub const JetOpenDatabase = JetOpenDatabaseW;
        pub const JetOpenTable = JetOpenTableW;
        pub const JetGetCurrentIndex = JetGetCurrentIndexW;
        pub const JetSetCurrentIndex = JetSetCurrentIndexW;
        pub const JetSetCurrentIndex2 = JetSetCurrentIndex2W;
        pub const JetSetCurrentIndex3 = JetSetCurrentIndex3W;
        pub const JetSetCurrentIndex4 = JetSetCurrentIndex4W;
        pub const JetCompact = JetCompactW;
        pub const JetDefragment = JetDefragmentW;
        pub const JetDefragment2 = JetDefragment2W;
        pub const JetDefragment3 = JetDefragment3W;
        pub const JetSetDatabaseSize = JetSetDatabaseSizeW;
        pub const JetBackup = JetBackupW;
        pub const JetBackupInstance = JetBackupInstanceW;
        pub const JetRestore = JetRestoreW;
        pub const JetRestore2 = JetRestore2W;
        pub const JetRestoreInstance = JetRestoreInstanceW;
        pub const JetGetAttachInfo = JetGetAttachInfoW;
        pub const JetGetAttachInfoInstance = JetGetAttachInfoInstanceW;
        pub const JetOpenFile = JetOpenFileW;
        pub const JetOpenFileInstance = JetOpenFileInstanceW;
        pub const JetGetLogInfo = JetGetLogInfoW;
        pub const JetGetLogInfoInstance = JetGetLogInfoInstanceW;
        pub const JetGetLogInfoInstance2 = JetGetLogInfoInstance2W;
        pub const JetGetTruncateLogInfoInstance = JetGetTruncateLogInfoInstanceW;
        pub const JetExternalRestore = JetExternalRestoreW;
        pub const JetExternalRestore2 = JetExternalRestore2W;
        pub const JetGetInstanceInfo = JetGetInstanceInfoW;
        pub const JetOSSnapshotFreeze = JetOSSnapshotFreezeW;
        pub const JetOSSnapshotGetFreezeInfo = JetOSSnapshotGetFreezeInfoW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const JET_RSTMAP_ = *opaque{};
        pub const CONVERT_ = *opaque{};
        pub const JET_COLUMNBASE_ = *opaque{};
        pub const JET_COLUMNCREATE_ = *opaque{};
        pub const JET_USERDEFINEDDEFAULT_ = *opaque{};
        pub const JET_CONDITIONALCOLUMN_ = *opaque{};
        pub const JET_INDEXCREATE_ = *opaque{};
        pub const JET_INDEXCREATE2_ = *opaque{};
        pub const JET_INDEXCREATE3_ = *opaque{};
        pub const JET_TABLECREATE_ = *opaque{};
        pub const JET_TABLECREATE2_ = *opaque{};
        pub const JET_TABLECREATE3_ = *opaque{};
        pub const JET_TABLECREATE4_ = *opaque{};
        pub const JET_RSTINFO_ = *opaque{};
        pub const JET_SETSYSPARAM_ = *opaque{};
        pub const JET_LOGINFO_ = *opaque{};
        pub const JET_INSTANCE_INFO_ = *opaque{};
        pub const JetInit3 = *opaque{};
        pub const JetCreateInstance = *opaque{};
        pub const JetCreateInstance2 = *opaque{};
        pub const JetSetSystemParameter = *opaque{};
        pub const JetGetSystemParameter = *opaque{};
        pub const JetEnableMultiInstance = *opaque{};
        pub const JetBeginSession = *opaque{};
        pub const JetCreateDatabase = *opaque{};
        pub const JetCreateDatabase2 = *opaque{};
        pub const JetAttachDatabase = *opaque{};
        pub const JetAttachDatabase2 = *opaque{};
        pub const JetDetachDatabase = *opaque{};
        pub const JetDetachDatabase2 = *opaque{};
        pub const JetGetObjectInfo = *opaque{};
        pub const JetGetTableInfo = *opaque{};
        pub const JetCreateTable = *opaque{};
        pub const JetCreateTableColumnIndex = *opaque{};
        pub const JetCreateTableColumnIndex2 = *opaque{};
        pub const JetCreateTableColumnIndex3 = *opaque{};
        pub const JetCreateTableColumnIndex4 = *opaque{};
        pub const JetDeleteTable = *opaque{};
        pub const JetRenameTable = *opaque{};
        pub const JetGetTableColumnInfo = *opaque{};
        pub const JetGetColumnInfo = *opaque{};
        pub const JetAddColumn = *opaque{};
        pub const JetDeleteColumn = *opaque{};
        pub const JetDeleteColumn2 = *opaque{};
        pub const JetRenameColumn = *opaque{};
        pub const JetSetColumnDefaultValue = *opaque{};
        pub const JetGetTableIndexInfo = *opaque{};
        pub const JetGetIndexInfo = *opaque{};
        pub const JetCreateIndex = *opaque{};
        pub const JetCreateIndex2 = *opaque{};
        pub const JetCreateIndex3 = *opaque{};
        pub const JetCreateIndex4 = *opaque{};
        pub const JetDeleteIndex = *opaque{};
        pub const JetGetDatabaseInfo = *opaque{};
        pub const JetGetDatabaseFileInfo = *opaque{};
        pub const JetOpenDatabase = *opaque{};
        pub const JetOpenTable = *opaque{};
        pub const JetGetCurrentIndex = *opaque{};
        pub const JetSetCurrentIndex = *opaque{};
        pub const JetSetCurrentIndex2 = *opaque{};
        pub const JetSetCurrentIndex3 = *opaque{};
        pub const JetSetCurrentIndex4 = *opaque{};
        pub const JetCompact = *opaque{};
        pub const JetDefragment = *opaque{};
        pub const JetDefragment2 = *opaque{};
        pub const JetDefragment3 = *opaque{};
        pub const JetSetDatabaseSize = *opaque{};
        pub const JetBackup = *opaque{};
        pub const JetBackupInstance = *opaque{};
        pub const JetRestore = *opaque{};
        pub const JetRestore2 = *opaque{};
        pub const JetRestoreInstance = *opaque{};
        pub const JetGetAttachInfo = *opaque{};
        pub const JetGetAttachInfoInstance = *opaque{};
        pub const JetOpenFile = *opaque{};
        pub const JetOpenFileInstance = *opaque{};
        pub const JetGetLogInfo = *opaque{};
        pub const JetGetLogInfoInstance = *opaque{};
        pub const JetGetLogInfoInstance2 = *opaque{};
        pub const JetGetTruncateLogInfoInstance = *opaque{};
        pub const JetExternalRestore = *opaque{};
        pub const JetExternalRestore2 = *opaque{};
        pub const JetGetInstanceInfo = *opaque{};
        pub const JetOSSnapshotFreeze = *opaque{};
        pub const JetOSSnapshotGetFreezeInfo = *opaque{};
    } else struct {
        pub const JET_RSTMAP_ = @compileError("'JET_RSTMAP_' requires that UNICODE be set to true or false in the root module");
        pub const CONVERT_ = @compileError("'CONVERT_' requires that UNICODE be set to true or false in the root module");
        pub const JET_COLUMNBASE_ = @compileError("'JET_COLUMNBASE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_COLUMNCREATE_ = @compileError("'JET_COLUMNCREATE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_USERDEFINEDDEFAULT_ = @compileError("'JET_USERDEFINEDDEFAULT_' requires that UNICODE be set to true or false in the root module");
        pub const JET_CONDITIONALCOLUMN_ = @compileError("'JET_CONDITIONALCOLUMN_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE_ = @compileError("'JET_INDEXCREATE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE2_ = @compileError("'JET_INDEXCREATE2_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INDEXCREATE3_ = @compileError("'JET_INDEXCREATE3_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE_ = @compileError("'JET_TABLECREATE_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE2_ = @compileError("'JET_TABLECREATE2_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE3_ = @compileError("'JET_TABLECREATE3_' requires that UNICODE be set to true or false in the root module");
        pub const JET_TABLECREATE4_ = @compileError("'JET_TABLECREATE4_' requires that UNICODE be set to true or false in the root module");
        pub const JET_RSTINFO_ = @compileError("'JET_RSTINFO_' requires that UNICODE be set to true or false in the root module");
        pub const JET_SETSYSPARAM_ = @compileError("'JET_SETSYSPARAM_' requires that UNICODE be set to true or false in the root module");
        pub const JET_LOGINFO_ = @compileError("'JET_LOGINFO_' requires that UNICODE be set to true or false in the root module");
        pub const JET_INSTANCE_INFO_ = @compileError("'JET_INSTANCE_INFO_' requires that UNICODE be set to true or false in the root module");
        pub const JetInit3 = @compileError("'JetInit3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateInstance = @compileError("'JetCreateInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateInstance2 = @compileError("'JetCreateInstance2' requires that UNICODE be set to true or false in the root module");
        pub const JetSetSystemParameter = @compileError("'JetSetSystemParameter' requires that UNICODE be set to true or false in the root module");
        pub const JetGetSystemParameter = @compileError("'JetGetSystemParameter' requires that UNICODE be set to true or false in the root module");
        pub const JetEnableMultiInstance = @compileError("'JetEnableMultiInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetBeginSession = @compileError("'JetBeginSession' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateDatabase = @compileError("'JetCreateDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateDatabase2 = @compileError("'JetCreateDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetAttachDatabase = @compileError("'JetAttachDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetAttachDatabase2 = @compileError("'JetAttachDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetDetachDatabase = @compileError("'JetDetachDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetDetachDatabase2 = @compileError("'JetDetachDatabase2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetObjectInfo = @compileError("'JetGetObjectInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableInfo = @compileError("'JetGetTableInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTable = @compileError("'JetCreateTable' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex = @compileError("'JetCreateTableColumnIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex2 = @compileError("'JetCreateTableColumnIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex3 = @compileError("'JetCreateTableColumnIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateTableColumnIndex4 = @compileError("'JetCreateTableColumnIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteTable = @compileError("'JetDeleteTable' requires that UNICODE be set to true or false in the root module");
        pub const JetRenameTable = @compileError("'JetRenameTable' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableColumnInfo = @compileError("'JetGetTableColumnInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetColumnInfo = @compileError("'JetGetColumnInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetAddColumn = @compileError("'JetAddColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteColumn = @compileError("'JetDeleteColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteColumn2 = @compileError("'JetDeleteColumn2' requires that UNICODE be set to true or false in the root module");
        pub const JetRenameColumn = @compileError("'JetRenameColumn' requires that UNICODE be set to true or false in the root module");
        pub const JetSetColumnDefaultValue = @compileError("'JetSetColumnDefaultValue' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTableIndexInfo = @compileError("'JetGetTableIndexInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetIndexInfo = @compileError("'JetGetIndexInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex = @compileError("'JetCreateIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex2 = @compileError("'JetCreateIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex3 = @compileError("'JetCreateIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetCreateIndex4 = @compileError("'JetCreateIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetDeleteIndex = @compileError("'JetDeleteIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetGetDatabaseInfo = @compileError("'JetGetDatabaseInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetDatabaseFileInfo = @compileError("'JetGetDatabaseFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenDatabase = @compileError("'JetOpenDatabase' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenTable = @compileError("'JetOpenTable' requires that UNICODE be set to true or false in the root module");
        pub const JetGetCurrentIndex = @compileError("'JetGetCurrentIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex = @compileError("'JetSetCurrentIndex' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex2 = @compileError("'JetSetCurrentIndex2' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex3 = @compileError("'JetSetCurrentIndex3' requires that UNICODE be set to true or false in the root module");
        pub const JetSetCurrentIndex4 = @compileError("'JetSetCurrentIndex4' requires that UNICODE be set to true or false in the root module");
        pub const JetCompact = @compileError("'JetCompact' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment = @compileError("'JetDefragment' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment2 = @compileError("'JetDefragment2' requires that UNICODE be set to true or false in the root module");
        pub const JetDefragment3 = @compileError("'JetDefragment3' requires that UNICODE be set to true or false in the root module");
        pub const JetSetDatabaseSize = @compileError("'JetSetDatabaseSize' requires that UNICODE be set to true or false in the root module");
        pub const JetBackup = @compileError("'JetBackup' requires that UNICODE be set to true or false in the root module");
        pub const JetBackupInstance = @compileError("'JetBackupInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetRestore = @compileError("'JetRestore' requires that UNICODE be set to true or false in the root module");
        pub const JetRestore2 = @compileError("'JetRestore2' requires that UNICODE be set to true or false in the root module");
        pub const JetRestoreInstance = @compileError("'JetRestoreInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetAttachInfo = @compileError("'JetGetAttachInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetAttachInfoInstance = @compileError("'JetGetAttachInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenFile = @compileError("'JetOpenFile' requires that UNICODE be set to true or false in the root module");
        pub const JetOpenFileInstance = @compileError("'JetOpenFileInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfo = @compileError("'JetGetLogInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfoInstance = @compileError("'JetGetLogInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetGetLogInfoInstance2 = @compileError("'JetGetLogInfoInstance2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetTruncateLogInfoInstance = @compileError("'JetGetTruncateLogInfoInstance' requires that UNICODE be set to true or false in the root module");
        pub const JetExternalRestore = @compileError("'JetExternalRestore' requires that UNICODE be set to true or false in the root module");
        pub const JetExternalRestore2 = @compileError("'JetExternalRestore2' requires that UNICODE be set to true or false in the root module");
        pub const JetGetInstanceInfo = @compileError("'JetGetInstanceInfo' requires that UNICODE be set to true or false in the root module");
        pub const JetOSSnapshotFreeze = @compileError("'JetOSSnapshotFreeze' requires that UNICODE be set to true or false in the root module");
        pub const JetOSSnapshotGetFreezeInfo = @compileError("'JetOSSnapshotGetFreezeInfo' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const SECURITY_DESCRIPTOR = @import("security.zig").SECURITY_DESCRIPTOR;
const ULARGE_INTEGER = @import("system_services.zig").ULARGE_INTEGER;
const PWSTR = @import("system_services.zig").PWSTR;
const FILETIME = @import("windows_programming.zig").FILETIME;
const CHAR = @import("system_services.zig").CHAR;
const IUnknown = @import("com.zig").IUnknown;
const CY = @import("system_services.zig").CY;
const HRESULT = @import("com.zig").HRESULT;
const BSTRBLOB = @import("system_services.zig").BSTRBLOB;
const SERIALIZEDPROPERTYVALUE = @import("shell.zig").SERIALIZEDPROPERTYVALUE;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const STGMEDIUM = @import("com.zig").STGMEDIUM;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const OLESTREAM = @import("com.zig").OLESTREAM;
const IBindStatusCallback = @import("com.zig").IBindStatusCallback;
const DVTARGETDEVICE = @import("com.zig").DVTARGETDEVICE;
const CLIPDATA = @import("system_services.zig").CLIPDATA;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "JET_PFNSTATUS")) { _ = JET_PFNSTATUS; }
    if (@hasDecl(@This(), "JET_CALLBACK")) { _ = JET_CALLBACK; }
    if (@hasDecl(@This(), "JET_PFNDURABLECOMMITCALLBACK")) { _ = JET_PFNDURABLECOMMITCALLBACK; }
    if (@hasDecl(@This(), "JET_PFNSTATUS")) { _ = JET_PFNSTATUS; }
    if (@hasDecl(@This(), "JET_CALLBACK")) { _ = JET_CALLBACK; }
    if (@hasDecl(@This(), "JET_PFNDURABLECOMMITCALLBACK")) { _ = JET_PFNDURABLECOMMITCALLBACK; }
    if (@hasDecl(@This(), "JET_PFNREALLOC")) { _ = JET_PFNREALLOC; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
