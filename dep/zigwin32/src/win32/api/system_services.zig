//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (11502)
//--------------------------------------------------------------------------------
pub const TRUE = @import("../zig.zig").typedConst(BOOL, @as(i32, 1));
pub const FALSE = @import("../zig.zig").typedConst(BOOL, @as(i32, 0));
pub const INVALID_HANDLE_VALUE = @import("../zig.zig").typedConst(HANDLE, @as(i32, -1));
pub const _MM_HINT_T0 = @as(u32, 1);
pub const _MM_HINT_T1 = @as(u32, 2);
pub const _MM_HINT_T2 = @as(u32, 3);
pub const _MM_HINT_NTA = @as(u32, 0);
pub const PWM_IOCTL_ID_CONTROLLER_GET_INFO = @as(i32, 0);
pub const PWM_IOCTL_ID_CONTROLLER_GET_ACTUAL_PERIOD = @as(i32, 1);
pub const PWM_IOCTL_ID_CONTROLLER_SET_DESIRED_PERIOD = @as(i32, 2);
pub const PWM_IOCTL_ID_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE = @as(i32, 100);
pub const PWM_IOCTL_ID_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE = @as(i32, 101);
pub const PWM_IOCTL_ID_PIN_GET_POLARITY = @as(i32, 102);
pub const PWM_IOCTL_ID_PIN_SET_POLARITY = @as(i32, 103);
pub const PWM_IOCTL_ID_PIN_START = @as(i32, 104);
pub const PWM_IOCTL_ID_PIN_STOP = @as(i32, 105);
pub const PWM_IOCTL_ID_PIN_IS_STARTED = @as(i32, 106);
pub const CREATE_MUTEX_INITIAL_OWNER = @as(u32, 1);
pub const CREATE_WAITABLE_TIMER_MANUAL_RESET = @as(u32, 1);
pub const CREATE_WAITABLE_TIMER_HIGH_RESOLUTION = @as(u32, 2);
pub const SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY = @as(u32, 1);
pub const SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY = @as(u32, 2);
pub const SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE = @as(u32, 4);
pub const PRIVATE_NAMESPACE_FLAG_DESTROY = @as(u32, 1);
pub const WINVER = @as(u32, 1280);
pub const APP_LOCAL_DEVICE_ID_SIZE = @as(u32, 32);
pub const DM_UPDATE = @as(u32, 1);
pub const DM_COPY = @as(u32, 2);
pub const DM_PROMPT = @as(u32, 4);
pub const DM_MODIFY = @as(u32, 8);
pub const STRICT = @as(u32, 1);
pub const MAX_PATH = @as(u32, 260);
pub const NULL = @as(u32, 0);
pub const ANYSIZE_ARRAY = @as(u32, 1);
pub const MEMORY_ALLOCATION_ALIGNMENT = @as(u32, 16);
pub const SYSTEM_CACHE_ALIGNMENT_SIZE = @as(u32, 64);
pub const PRAGMA_DEPRECATED_DDK = @as(u32, 1);
pub const UCSCHAR_INVALID_CHARACTER = @as(u32, 4294967295);
pub const MIN_UCSCHAR = @as(u32, 0);
pub const MAX_UCSCHAR = @as(u32, 1114111);
pub const ALL_PROCESSOR_GROUPS = @as(u32, 65535);
pub const MAXIMUM_PROC_PER_GROUP = @as(u32, 64);
pub const APPLICATION_ERROR_MASK = @as(u32, 536870912);
pub const ERROR_SEVERITY_SUCCESS = @as(u32, 0);
pub const ERROR_SEVERITY_INFORMATIONAL = @as(u32, 1073741824);
pub const ERROR_SEVERITY_WARNING = @as(u32, 2147483648);
pub const ERROR_SEVERITY_ERROR = @as(u32, 3221225472);
pub const MAXLONGLONG = @as(u64, 9223372036854775807);
pub const UNICODE_STRING_MAX_CHARS = @as(u32, 32767);
pub const MINCHAR = @as(u32, 128);
pub const MAXCHAR = @as(u32, 127);
pub const MINSHORT = @as(u32, 32768);
pub const MAXSHORT = @as(u32, 32767);
pub const MINLONG = @as(u32, 2147483648);
pub const MAXLONG = @as(u32, 2147483647);
pub const MAXBYTE = @as(u32, 255);
pub const MAXWORD = @as(u32, 65535);
pub const MAXDWORD = @as(u32, 4294967295);
pub const ENCLAVE_SHORT_ID_LENGTH = @as(u32, 16);
pub const ENCLAVE_LONG_ID_LENGTH = @as(u32, 32);
pub const VER_SERVER_NT = @as(u32, 2147483648);
pub const VER_WORKSTATION_NT = @as(u32, 1073741824);
pub const VER_SUITE_SMALLBUSINESS = @as(u32, 1);
pub const VER_SUITE_ENTERPRISE = @as(u32, 2);
pub const VER_SUITE_BACKOFFICE = @as(u32, 4);
pub const VER_SUITE_COMMUNICATIONS = @as(u32, 8);
pub const VER_SUITE_TERMINAL = @as(u32, 16);
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED = @as(u32, 32);
pub const VER_SUITE_EMBEDDEDNT = @as(u32, 64);
pub const VER_SUITE_DATACENTER = @as(u32, 128);
pub const VER_SUITE_SINGLEUSERTS = @as(u32, 256);
pub const VER_SUITE_PERSONAL = @as(u32, 512);
pub const VER_SUITE_BLADE = @as(u32, 1024);
pub const VER_SUITE_EMBEDDED_RESTRICTED = @as(u32, 2048);
pub const VER_SUITE_SECURITY_APPLIANCE = @as(u32, 4096);
pub const VER_SUITE_STORAGE_SERVER = @as(u32, 8192);
pub const VER_SUITE_COMPUTE_SERVER = @as(u32, 16384);
pub const VER_SUITE_WH_SERVER = @as(u32, 32768);
pub const VER_SUITE_MULTIUSERTS = @as(u32, 131072);
pub const PRODUCT_STANDARD_SERVER_CORE = @as(u32, 13);
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE = @as(u32, 57);
pub const PRODUCT_PROFESSIONAL_EMBEDDED = @as(u32, 58);
pub const PRODUCT_EMBEDDED = @as(u32, 65);
pub const PRODUCT_EMBEDDED_AUTOMOTIVE = @as(u32, 85);
pub const PRODUCT_EMBEDDED_INDUSTRY_A = @as(u32, 86);
pub const PRODUCT_THINPC = @as(u32, 87);
pub const PRODUCT_EMBEDDED_A = @as(u32, 88);
pub const PRODUCT_EMBEDDED_INDUSTRY = @as(u32, 89);
pub const PRODUCT_EMBEDDED_E = @as(u32, 90);
pub const PRODUCT_EMBEDDED_INDUSTRY_E = @as(u32, 91);
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E = @as(u32, 92);
pub const PRODUCT_CORE_ARM = @as(u32, 97);
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL = @as(u32, 105);
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL = @as(u32, 106);
pub const PRODUCT_EMBEDDED_EVAL = @as(u32, 107);
pub const PRODUCT_EMBEDDED_E_EVAL = @as(u32, 108);
pub const PRODUCT_NANO_SERVER = @as(u32, 109);
pub const PRODUCT_CLOUD_STORAGE_SERVER = @as(u32, 110);
pub const PRODUCT_CORE_CONNECTED = @as(u32, 111);
pub const PRODUCT_PROFESSIONAL_STUDENT = @as(u32, 112);
pub const PRODUCT_CORE_CONNECTED_N = @as(u32, 113);
pub const PRODUCT_PROFESSIONAL_STUDENT_N = @as(u32, 114);
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE = @as(u32, 115);
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC = @as(u32, 116);
pub const PRODUCT_CONNECTED_CAR = @as(u32, 117);
pub const PRODUCT_INDUSTRY_HANDHELD = @as(u32, 118);
pub const PRODUCT_PPI_PRO = @as(u32, 119);
pub const PRODUCT_ARM64_SERVER = @as(u32, 120);
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER = @as(u32, 124);
pub const PRODUCT_PROFESSIONAL_S = @as(u32, 127);
pub const PRODUCT_PROFESSIONAL_S_N = @as(u32, 128);
pub const PRODUCT_HOLOGRAPHIC = @as(u32, 135);
pub const PRODUCT_HOLOGRAPHIC_BUSINESS = @as(u32, 136);
pub const PRODUCT_PRO_SINGLE_LANGUAGE = @as(u32, 138);
pub const PRODUCT_PRO_CHINA = @as(u32, 139);
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION = @as(u32, 140);
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N = @as(u32, 141);
pub const PRODUCT_DATACENTER_NANO_SERVER = @as(u32, 143);
pub const PRODUCT_STANDARD_NANO_SERVER = @as(u32, 144);
pub const PRODUCT_DATACENTER_WS_SERVER_CORE = @as(u32, 147);
pub const PRODUCT_STANDARD_WS_SERVER_CORE = @as(u32, 148);
pub const PRODUCT_UTILITY_VM = @as(u32, 149);
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE = @as(u32, 159);
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE = @as(u32, 160);
pub const PRODUCT_PRO_FOR_EDUCATION = @as(u32, 164);
pub const PRODUCT_PRO_FOR_EDUCATION_N = @as(u32, 165);
pub const PRODUCT_AZURE_SERVER_CORE = @as(u32, 168);
pub const PRODUCT_AZURE_NANO_SERVER = @as(u32, 169);
pub const PRODUCT_ENTERPRISEG = @as(u32, 171);
pub const PRODUCT_ENTERPRISEGN = @as(u32, 172);
pub const PRODUCT_SERVERRDSH = @as(u32, 175);
pub const PRODUCT_CLOUD = @as(u32, 178);
pub const PRODUCT_CLOUDN = @as(u32, 179);
pub const PRODUCT_HUBOS = @as(u32, 180);
pub const PRODUCT_ONECOREUPDATEOS = @as(u32, 182);
pub const PRODUCT_CLOUDE = @as(u32, 183);
pub const PRODUCT_ANDROMEDA = @as(u32, 184);
pub const PRODUCT_IOTOS = @as(u32, 185);
pub const PRODUCT_CLOUDEN = @as(u32, 186);
pub const PRODUCT_IOTEDGEOS = @as(u32, 187);
pub const PRODUCT_IOTENTERPRISE = @as(u32, 188);
pub const PRODUCT_LITE = @as(u32, 189);
pub const PRODUCT_IOTENTERPRISES = @as(u32, 191);
pub const PRODUCT_XBOX_SYSTEMOS = @as(u32, 192);
pub const PRODUCT_XBOX_NATIVEOS = @as(u32, 193);
pub const PRODUCT_XBOX_GAMEOS = @as(u32, 194);
pub const PRODUCT_XBOX_ERAOS = @as(u32, 195);
pub const PRODUCT_XBOX_DURANGOHOSTOS = @as(u32, 196);
pub const PRODUCT_XBOX_SCARLETTHOSTOS = @as(u32, 197);
pub const PRODUCT_UNLICENSED = @as(u32, 2882382797);
pub const LANG_NEUTRAL = @as(u32, 0);
pub const LANG_INVARIANT = @as(u32, 127);
pub const LANG_AFRIKAANS = @as(u32, 54);
pub const LANG_ALBANIAN = @as(u32, 28);
pub const LANG_ALSATIAN = @as(u32, 132);
pub const LANG_AMHARIC = @as(u32, 94);
pub const LANG_ARABIC = @as(u32, 1);
pub const LANG_ARMENIAN = @as(u32, 43);
pub const LANG_ASSAMESE = @as(u32, 77);
pub const LANG_AZERI = @as(u32, 44);
pub const LANG_AZERBAIJANI = @as(u32, 44);
pub const LANG_BANGLA = @as(u32, 69);
pub const LANG_BASHKIR = @as(u32, 109);
pub const LANG_BASQUE = @as(u32, 45);
pub const LANG_BELARUSIAN = @as(u32, 35);
pub const LANG_BENGALI = @as(u32, 69);
pub const LANG_BRETON = @as(u32, 126);
pub const LANG_BOSNIAN = @as(u32, 26);
pub const LANG_BOSNIAN_NEUTRAL = @as(u32, 30746);
pub const LANG_BULGARIAN = @as(u32, 2);
pub const LANG_CATALAN = @as(u32, 3);
pub const LANG_CENTRAL_KURDISH = @as(u32, 146);
pub const LANG_CHEROKEE = @as(u32, 92);
pub const LANG_CHINESE = @as(u32, 4);
pub const LANG_CHINESE_SIMPLIFIED = @as(u32, 4);
pub const LANG_CHINESE_TRADITIONAL = @as(u32, 31748);
pub const LANG_CORSICAN = @as(u32, 131);
pub const LANG_CROATIAN = @as(u32, 26);
pub const LANG_CZECH = @as(u32, 5);
pub const LANG_DANISH = @as(u32, 6);
pub const LANG_DARI = @as(u32, 140);
pub const LANG_DIVEHI = @as(u32, 101);
pub const LANG_DUTCH = @as(u32, 19);
pub const LANG_ENGLISH = @as(u32, 9);
pub const LANG_ESTONIAN = @as(u32, 37);
pub const LANG_FAEROESE = @as(u32, 56);
pub const LANG_FARSI = @as(u32, 41);
pub const LANG_FILIPINO = @as(u32, 100);
pub const LANG_FINNISH = @as(u32, 11);
pub const LANG_FRENCH = @as(u32, 12);
pub const LANG_FRISIAN = @as(u32, 98);
pub const LANG_FULAH = @as(u32, 103);
pub const LANG_GALICIAN = @as(u32, 86);
pub const LANG_GEORGIAN = @as(u32, 55);
pub const LANG_GERMAN = @as(u32, 7);
pub const LANG_GREEK = @as(u32, 8);
pub const LANG_GREENLANDIC = @as(u32, 111);
pub const LANG_GUJARATI = @as(u32, 71);
pub const LANG_HAUSA = @as(u32, 104);
pub const LANG_HAWAIIAN = @as(u32, 117);
pub const LANG_HEBREW = @as(u32, 13);
pub const LANG_HINDI = @as(u32, 57);
pub const LANG_HUNGARIAN = @as(u32, 14);
pub const LANG_ICELANDIC = @as(u32, 15);
pub const LANG_IGBO = @as(u32, 112);
pub const LANG_INDONESIAN = @as(u32, 33);
pub const LANG_INUKTITUT = @as(u32, 93);
pub const LANG_IRISH = @as(u32, 60);
pub const LANG_ITALIAN = @as(u32, 16);
pub const LANG_JAPANESE = @as(u32, 17);
pub const LANG_KANNADA = @as(u32, 75);
pub const LANG_KASHMIRI = @as(u32, 96);
pub const LANG_KAZAK = @as(u32, 63);
pub const LANG_KHMER = @as(u32, 83);
pub const LANG_KICHE = @as(u32, 134);
pub const LANG_KINYARWANDA = @as(u32, 135);
pub const LANG_KONKANI = @as(u32, 87);
pub const LANG_KOREAN = @as(u32, 18);
pub const LANG_KYRGYZ = @as(u32, 64);
pub const LANG_LAO = @as(u32, 84);
pub const LANG_LATVIAN = @as(u32, 38);
pub const LANG_LITHUANIAN = @as(u32, 39);
pub const LANG_LOWER_SORBIAN = @as(u32, 46);
pub const LANG_LUXEMBOURGISH = @as(u32, 110);
pub const LANG_MACEDONIAN = @as(u32, 47);
pub const LANG_MALAY = @as(u32, 62);
pub const LANG_MALAYALAM = @as(u32, 76);
pub const LANG_MALTESE = @as(u32, 58);
pub const LANG_MANIPURI = @as(u32, 88);
pub const LANG_MAORI = @as(u32, 129);
pub const LANG_MAPUDUNGUN = @as(u32, 122);
pub const LANG_MARATHI = @as(u32, 78);
pub const LANG_MOHAWK = @as(u32, 124);
pub const LANG_MONGOLIAN = @as(u32, 80);
pub const LANG_NEPALI = @as(u32, 97);
pub const LANG_NORWEGIAN = @as(u32, 20);
pub const LANG_OCCITAN = @as(u32, 130);
pub const LANG_ODIA = @as(u32, 72);
pub const LANG_ORIYA = @as(u32, 72);
pub const LANG_PASHTO = @as(u32, 99);
pub const LANG_PERSIAN = @as(u32, 41);
pub const LANG_POLISH = @as(u32, 21);
pub const LANG_PORTUGUESE = @as(u32, 22);
pub const LANG_PULAR = @as(u32, 103);
pub const LANG_PUNJABI = @as(u32, 70);
pub const LANG_QUECHUA = @as(u32, 107);
pub const LANG_ROMANIAN = @as(u32, 24);
pub const LANG_ROMANSH = @as(u32, 23);
pub const LANG_RUSSIAN = @as(u32, 25);
pub const LANG_SAKHA = @as(u32, 133);
pub const LANG_SAMI = @as(u32, 59);
pub const LANG_SANSKRIT = @as(u32, 79);
pub const LANG_SCOTTISH_GAELIC = @as(u32, 145);
pub const LANG_SERBIAN = @as(u32, 26);
pub const LANG_SERBIAN_NEUTRAL = @as(u32, 31770);
pub const LANG_SINDHI = @as(u32, 89);
pub const LANG_SINHALESE = @as(u32, 91);
pub const LANG_SLOVAK = @as(u32, 27);
pub const LANG_SLOVENIAN = @as(u32, 36);
pub const LANG_SOTHO = @as(u32, 108);
pub const LANG_SPANISH = @as(u32, 10);
pub const LANG_SWAHILI = @as(u32, 65);
pub const LANG_SWEDISH = @as(u32, 29);
pub const LANG_SYRIAC = @as(u32, 90);
pub const LANG_TAJIK = @as(u32, 40);
pub const LANG_TAMAZIGHT = @as(u32, 95);
pub const LANG_TAMIL = @as(u32, 73);
pub const LANG_TATAR = @as(u32, 68);
pub const LANG_TELUGU = @as(u32, 74);
pub const LANG_THAI = @as(u32, 30);
pub const LANG_TIBETAN = @as(u32, 81);
pub const LANG_TIGRIGNA = @as(u32, 115);
pub const LANG_TIGRINYA = @as(u32, 115);
pub const LANG_TSWANA = @as(u32, 50);
pub const LANG_TURKISH = @as(u32, 31);
pub const LANG_TURKMEN = @as(u32, 66);
pub const LANG_UIGHUR = @as(u32, 128);
pub const LANG_UKRAINIAN = @as(u32, 34);
pub const LANG_UPPER_SORBIAN = @as(u32, 46);
pub const LANG_URDU = @as(u32, 32);
pub const LANG_UZBEK = @as(u32, 67);
pub const LANG_VALENCIAN = @as(u32, 3);
pub const LANG_VIETNAMESE = @as(u32, 42);
pub const LANG_WELSH = @as(u32, 82);
pub const LANG_WOLOF = @as(u32, 136);
pub const LANG_XHOSA = @as(u32, 52);
pub const LANG_YAKUT = @as(u32, 133);
pub const LANG_YI = @as(u32, 120);
pub const LANG_YORUBA = @as(u32, 106);
pub const LANG_ZULU = @as(u32, 53);
pub const SUBLANG_NEUTRAL = @as(u32, 0);
pub const SUBLANG_DEFAULT = @as(u32, 1);
pub const SUBLANG_SYS_DEFAULT = @as(u32, 2);
pub const SUBLANG_CUSTOM_DEFAULT = @as(u32, 3);
pub const SUBLANG_CUSTOM_UNSPECIFIED = @as(u32, 4);
pub const SUBLANG_UI_CUSTOM_DEFAULT = @as(u32, 5);
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA = @as(u32, 1);
pub const SUBLANG_ALBANIAN_ALBANIA = @as(u32, 1);
pub const SUBLANG_ALSATIAN_FRANCE = @as(u32, 1);
pub const SUBLANG_AMHARIC_ETHIOPIA = @as(u32, 1);
pub const SUBLANG_ARABIC_SAUDI_ARABIA = @as(u32, 1);
pub const SUBLANG_ARABIC_IRAQ = @as(u32, 2);
pub const SUBLANG_ARABIC_EGYPT = @as(u32, 3);
pub const SUBLANG_ARABIC_LIBYA = @as(u32, 4);
pub const SUBLANG_ARABIC_ALGERIA = @as(u32, 5);
pub const SUBLANG_ARABIC_MOROCCO = @as(u32, 6);
pub const SUBLANG_ARABIC_TUNISIA = @as(u32, 7);
pub const SUBLANG_ARABIC_OMAN = @as(u32, 8);
pub const SUBLANG_ARABIC_YEMEN = @as(u32, 9);
pub const SUBLANG_ARABIC_SYRIA = @as(u32, 10);
pub const SUBLANG_ARABIC_JORDAN = @as(u32, 11);
pub const SUBLANG_ARABIC_LEBANON = @as(u32, 12);
pub const SUBLANG_ARABIC_KUWAIT = @as(u32, 13);
pub const SUBLANG_ARABIC_UAE = @as(u32, 14);
pub const SUBLANG_ARABIC_BAHRAIN = @as(u32, 15);
pub const SUBLANG_ARABIC_QATAR = @as(u32, 16);
pub const SUBLANG_ARMENIAN_ARMENIA = @as(u32, 1);
pub const SUBLANG_ASSAMESE_INDIA = @as(u32, 1);
pub const SUBLANG_AZERI_LATIN = @as(u32, 1);
pub const SUBLANG_AZERI_CYRILLIC = @as(u32, 2);
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN = @as(u32, 1);
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC = @as(u32, 2);
pub const SUBLANG_BANGLA_INDIA = @as(u32, 1);
pub const SUBLANG_BANGLA_BANGLADESH = @as(u32, 2);
pub const SUBLANG_BASHKIR_RUSSIA = @as(u32, 1);
pub const SUBLANG_BASQUE_BASQUE = @as(u32, 1);
pub const SUBLANG_BELARUSIAN_BELARUS = @as(u32, 1);
pub const SUBLANG_BENGALI_INDIA = @as(u32, 1);
pub const SUBLANG_BENGALI_BANGLADESH = @as(u32, 2);
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN = @as(u32, 5);
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = @as(u32, 8);
pub const SUBLANG_BRETON_FRANCE = @as(u32, 1);
pub const SUBLANG_BULGARIAN_BULGARIA = @as(u32, 1);
pub const SUBLANG_CATALAN_CATALAN = @as(u32, 1);
pub const SUBLANG_CENTRAL_KURDISH_IRAQ = @as(u32, 1);
pub const SUBLANG_CHEROKEE_CHEROKEE = @as(u32, 1);
pub const SUBLANG_CHINESE_TRADITIONAL = @as(u32, 1);
pub const SUBLANG_CHINESE_SIMPLIFIED = @as(u32, 2);
pub const SUBLANG_CHINESE_HONGKONG = @as(u32, 3);
pub const SUBLANG_CHINESE_SINGAPORE = @as(u32, 4);
pub const SUBLANG_CHINESE_MACAU = @as(u32, 5);
pub const SUBLANG_CORSICAN_FRANCE = @as(u32, 1);
pub const SUBLANG_CZECH_CZECH_REPUBLIC = @as(u32, 1);
pub const SUBLANG_CROATIAN_CROATIA = @as(u32, 1);
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN = @as(u32, 4);
pub const SUBLANG_DANISH_DENMARK = @as(u32, 1);
pub const SUBLANG_DARI_AFGHANISTAN = @as(u32, 1);
pub const SUBLANG_DIVEHI_MALDIVES = @as(u32, 1);
pub const SUBLANG_DUTCH = @as(u32, 1);
pub const SUBLANG_DUTCH_BELGIAN = @as(u32, 2);
pub const SUBLANG_ENGLISH_US = @as(u32, 1);
pub const SUBLANG_ENGLISH_UK = @as(u32, 2);
pub const SUBLANG_ENGLISH_AUS = @as(u32, 3);
pub const SUBLANG_ENGLISH_CAN = @as(u32, 4);
pub const SUBLANG_ENGLISH_NZ = @as(u32, 5);
pub const SUBLANG_ENGLISH_EIRE = @as(u32, 6);
pub const SUBLANG_ENGLISH_SOUTH_AFRICA = @as(u32, 7);
pub const SUBLANG_ENGLISH_JAMAICA = @as(u32, 8);
pub const SUBLANG_ENGLISH_CARIBBEAN = @as(u32, 9);
pub const SUBLANG_ENGLISH_BELIZE = @as(u32, 10);
pub const SUBLANG_ENGLISH_TRINIDAD = @as(u32, 11);
pub const SUBLANG_ENGLISH_ZIMBABWE = @as(u32, 12);
pub const SUBLANG_ENGLISH_PHILIPPINES = @as(u32, 13);
pub const SUBLANG_ENGLISH_INDIA = @as(u32, 16);
pub const SUBLANG_ENGLISH_MALAYSIA = @as(u32, 17);
pub const SUBLANG_ENGLISH_SINGAPORE = @as(u32, 18);
pub const SUBLANG_ESTONIAN_ESTONIA = @as(u32, 1);
pub const SUBLANG_FAEROESE_FAROE_ISLANDS = @as(u32, 1);
pub const SUBLANG_FILIPINO_PHILIPPINES = @as(u32, 1);
pub const SUBLANG_FINNISH_FINLAND = @as(u32, 1);
pub const SUBLANG_FRENCH = @as(u32, 1);
pub const SUBLANG_FRENCH_BELGIAN = @as(u32, 2);
pub const SUBLANG_FRENCH_CANADIAN = @as(u32, 3);
pub const SUBLANG_FRENCH_SWISS = @as(u32, 4);
pub const SUBLANG_FRENCH_LUXEMBOURG = @as(u32, 5);
pub const SUBLANG_FRENCH_MONACO = @as(u32, 6);
pub const SUBLANG_FRISIAN_NETHERLANDS = @as(u32, 1);
pub const SUBLANG_FULAH_SENEGAL = @as(u32, 2);
pub const SUBLANG_GALICIAN_GALICIAN = @as(u32, 1);
pub const SUBLANG_GEORGIAN_GEORGIA = @as(u32, 1);
pub const SUBLANG_GERMAN = @as(u32, 1);
pub const SUBLANG_GERMAN_SWISS = @as(u32, 2);
pub const SUBLANG_GERMAN_AUSTRIAN = @as(u32, 3);
pub const SUBLANG_GERMAN_LUXEMBOURG = @as(u32, 4);
pub const SUBLANG_GERMAN_LIECHTENSTEIN = @as(u32, 5);
pub const SUBLANG_GREEK_GREECE = @as(u32, 1);
pub const SUBLANG_GREENLANDIC_GREENLAND = @as(u32, 1);
pub const SUBLANG_GUJARATI_INDIA = @as(u32, 1);
pub const SUBLANG_HAUSA_NIGERIA_LATIN = @as(u32, 1);
pub const SUBLANG_HAWAIIAN_US = @as(u32, 1);
pub const SUBLANG_HEBREW_ISRAEL = @as(u32, 1);
pub const SUBLANG_HINDI_INDIA = @as(u32, 1);
pub const SUBLANG_HUNGARIAN_HUNGARY = @as(u32, 1);
pub const SUBLANG_ICELANDIC_ICELAND = @as(u32, 1);
pub const SUBLANG_IGBO_NIGERIA = @as(u32, 1);
pub const SUBLANG_INDONESIAN_INDONESIA = @as(u32, 1);
pub const SUBLANG_INUKTITUT_CANADA = @as(u32, 1);
pub const SUBLANG_INUKTITUT_CANADA_LATIN = @as(u32, 2);
pub const SUBLANG_IRISH_IRELAND = @as(u32, 2);
pub const SUBLANG_ITALIAN = @as(u32, 1);
pub const SUBLANG_ITALIAN_SWISS = @as(u32, 2);
pub const SUBLANG_JAPANESE_JAPAN = @as(u32, 1);
pub const SUBLANG_KANNADA_INDIA = @as(u32, 1);
pub const SUBLANG_KASHMIRI_SASIA = @as(u32, 2);
pub const SUBLANG_KASHMIRI_INDIA = @as(u32, 2);
pub const SUBLANG_KAZAK_KAZAKHSTAN = @as(u32, 1);
pub const SUBLANG_KHMER_CAMBODIA = @as(u32, 1);
pub const SUBLANG_KICHE_GUATEMALA = @as(u32, 1);
pub const SUBLANG_KINYARWANDA_RWANDA = @as(u32, 1);
pub const SUBLANG_KONKANI_INDIA = @as(u32, 1);
pub const SUBLANG_KOREAN = @as(u32, 1);
pub const SUBLANG_KYRGYZ_KYRGYZSTAN = @as(u32, 1);
pub const SUBLANG_LAO_LAO = @as(u32, 1);
pub const SUBLANG_LATVIAN_LATVIA = @as(u32, 1);
pub const SUBLANG_LITHUANIAN = @as(u32, 1);
pub const SUBLANG_LOWER_SORBIAN_GERMANY = @as(u32, 2);
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG = @as(u32, 1);
pub const SUBLANG_MACEDONIAN_MACEDONIA = @as(u32, 1);
pub const SUBLANG_MALAY_MALAYSIA = @as(u32, 1);
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM = @as(u32, 2);
pub const SUBLANG_MALAYALAM_INDIA = @as(u32, 1);
pub const SUBLANG_MALTESE_MALTA = @as(u32, 1);
pub const SUBLANG_MAORI_NEW_ZEALAND = @as(u32, 1);
pub const SUBLANG_MAPUDUNGUN_CHILE = @as(u32, 1);
pub const SUBLANG_MARATHI_INDIA = @as(u32, 1);
pub const SUBLANG_MOHAWK_MOHAWK = @as(u32, 1);
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA = @as(u32, 1);
pub const SUBLANG_MONGOLIAN_PRC = @as(u32, 2);
pub const SUBLANG_NEPALI_INDIA = @as(u32, 2);
pub const SUBLANG_NEPALI_NEPAL = @as(u32, 1);
pub const SUBLANG_NORWEGIAN_BOKMAL = @as(u32, 1);
pub const SUBLANG_NORWEGIAN_NYNORSK = @as(u32, 2);
pub const SUBLANG_OCCITAN_FRANCE = @as(u32, 1);
pub const SUBLANG_ODIA_INDIA = @as(u32, 1);
pub const SUBLANG_ORIYA_INDIA = @as(u32, 1);
pub const SUBLANG_PASHTO_AFGHANISTAN = @as(u32, 1);
pub const SUBLANG_PERSIAN_IRAN = @as(u32, 1);
pub const SUBLANG_POLISH_POLAND = @as(u32, 1);
pub const SUBLANG_PORTUGUESE = @as(u32, 2);
pub const SUBLANG_PORTUGUESE_BRAZILIAN = @as(u32, 1);
pub const SUBLANG_PULAR_SENEGAL = @as(u32, 2);
pub const SUBLANG_PUNJABI_INDIA = @as(u32, 1);
pub const SUBLANG_PUNJABI_PAKISTAN = @as(u32, 2);
pub const SUBLANG_QUECHUA_BOLIVIA = @as(u32, 1);
pub const SUBLANG_QUECHUA_ECUADOR = @as(u32, 2);
pub const SUBLANG_QUECHUA_PERU = @as(u32, 3);
pub const SUBLANG_ROMANIAN_ROMANIA = @as(u32, 1);
pub const SUBLANG_ROMANSH_SWITZERLAND = @as(u32, 1);
pub const SUBLANG_RUSSIAN_RUSSIA = @as(u32, 1);
pub const SUBLANG_SAKHA_RUSSIA = @as(u32, 1);
pub const SUBLANG_SAMI_NORTHERN_NORWAY = @as(u32, 1);
pub const SUBLANG_SAMI_NORTHERN_SWEDEN = @as(u32, 2);
pub const SUBLANG_SAMI_NORTHERN_FINLAND = @as(u32, 3);
pub const SUBLANG_SAMI_LULE_NORWAY = @as(u32, 4);
pub const SUBLANG_SAMI_LULE_SWEDEN = @as(u32, 5);
pub const SUBLANG_SAMI_SOUTHERN_NORWAY = @as(u32, 6);
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN = @as(u32, 7);
pub const SUBLANG_SAMI_SKOLT_FINLAND = @as(u32, 8);
pub const SUBLANG_SAMI_INARI_FINLAND = @as(u32, 9);
pub const SUBLANG_SANSKRIT_INDIA = @as(u32, 1);
pub const SUBLANG_SCOTTISH_GAELIC = @as(u32, 1);
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN = @as(u32, 6);
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = @as(u32, 7);
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN = @as(u32, 11);
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC = @as(u32, 12);
pub const SUBLANG_SERBIAN_SERBIA_LATIN = @as(u32, 9);
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC = @as(u32, 10);
pub const SUBLANG_SERBIAN_CROATIA = @as(u32, 1);
pub const SUBLANG_SERBIAN_LATIN = @as(u32, 2);
pub const SUBLANG_SERBIAN_CYRILLIC = @as(u32, 3);
pub const SUBLANG_SINDHI_INDIA = @as(u32, 1);
pub const SUBLANG_SINDHI_PAKISTAN = @as(u32, 2);
pub const SUBLANG_SINDHI_AFGHANISTAN = @as(u32, 2);
pub const SUBLANG_SINHALESE_SRI_LANKA = @as(u32, 1);
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA = @as(u32, 1);
pub const SUBLANG_SLOVAK_SLOVAKIA = @as(u32, 1);
pub const SUBLANG_SLOVENIAN_SLOVENIA = @as(u32, 1);
pub const SUBLANG_SPANISH = @as(u32, 1);
pub const SUBLANG_SPANISH_MEXICAN = @as(u32, 2);
pub const SUBLANG_SPANISH_MODERN = @as(u32, 3);
pub const SUBLANG_SPANISH_GUATEMALA = @as(u32, 4);
pub const SUBLANG_SPANISH_COSTA_RICA = @as(u32, 5);
pub const SUBLANG_SPANISH_PANAMA = @as(u32, 6);
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC = @as(u32, 7);
pub const SUBLANG_SPANISH_VENEZUELA = @as(u32, 8);
pub const SUBLANG_SPANISH_COLOMBIA = @as(u32, 9);
pub const SUBLANG_SPANISH_PERU = @as(u32, 10);
pub const SUBLANG_SPANISH_ARGENTINA = @as(u32, 11);
pub const SUBLANG_SPANISH_ECUADOR = @as(u32, 12);
pub const SUBLANG_SPANISH_CHILE = @as(u32, 13);
pub const SUBLANG_SPANISH_URUGUAY = @as(u32, 14);
pub const SUBLANG_SPANISH_PARAGUAY = @as(u32, 15);
pub const SUBLANG_SPANISH_BOLIVIA = @as(u32, 16);
pub const SUBLANG_SPANISH_EL_SALVADOR = @as(u32, 17);
pub const SUBLANG_SPANISH_HONDURAS = @as(u32, 18);
pub const SUBLANG_SPANISH_NICARAGUA = @as(u32, 19);
pub const SUBLANG_SPANISH_PUERTO_RICO = @as(u32, 20);
pub const SUBLANG_SPANISH_US = @as(u32, 21);
pub const SUBLANG_SWAHILI_KENYA = @as(u32, 1);
pub const SUBLANG_SWEDISH = @as(u32, 1);
pub const SUBLANG_SWEDISH_FINLAND = @as(u32, 2);
pub const SUBLANG_SYRIAC_SYRIA = @as(u32, 1);
pub const SUBLANG_TAJIK_TAJIKISTAN = @as(u32, 1);
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN = @as(u32, 2);
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH = @as(u32, 4);
pub const SUBLANG_TAMIL_INDIA = @as(u32, 1);
pub const SUBLANG_TAMIL_SRI_LANKA = @as(u32, 2);
pub const SUBLANG_TATAR_RUSSIA = @as(u32, 1);
pub const SUBLANG_TELUGU_INDIA = @as(u32, 1);
pub const SUBLANG_THAI_THAILAND = @as(u32, 1);
pub const SUBLANG_TIBETAN_PRC = @as(u32, 1);
pub const SUBLANG_TIGRIGNA_ERITREA = @as(u32, 2);
pub const SUBLANG_TIGRINYA_ERITREA = @as(u32, 2);
pub const SUBLANG_TIGRINYA_ETHIOPIA = @as(u32, 1);
pub const SUBLANG_TSWANA_BOTSWANA = @as(u32, 2);
pub const SUBLANG_TSWANA_SOUTH_AFRICA = @as(u32, 1);
pub const SUBLANG_TURKISH_TURKEY = @as(u32, 1);
pub const SUBLANG_TURKMEN_TURKMENISTAN = @as(u32, 1);
pub const SUBLANG_UIGHUR_PRC = @as(u32, 1);
pub const SUBLANG_UKRAINIAN_UKRAINE = @as(u32, 1);
pub const SUBLANG_UPPER_SORBIAN_GERMANY = @as(u32, 1);
pub const SUBLANG_URDU_PAKISTAN = @as(u32, 1);
pub const SUBLANG_URDU_INDIA = @as(u32, 2);
pub const SUBLANG_UZBEK_LATIN = @as(u32, 1);
pub const SUBLANG_UZBEK_CYRILLIC = @as(u32, 2);
pub const SUBLANG_VALENCIAN_VALENCIA = @as(u32, 2);
pub const SUBLANG_VIETNAMESE_VIETNAM = @as(u32, 1);
pub const SUBLANG_WELSH_UNITED_KINGDOM = @as(u32, 1);
pub const SUBLANG_WOLOF_SENEGAL = @as(u32, 1);
pub const SUBLANG_XHOSA_SOUTH_AFRICA = @as(u32, 1);
pub const SUBLANG_YAKUT_RUSSIA = @as(u32, 1);
pub const SUBLANG_YI_PRC = @as(u32, 1);
pub const SUBLANG_YORUBA_NIGERIA = @as(u32, 1);
pub const SUBLANG_ZULU_SOUTH_AFRICA = @as(u32, 1);
pub const SORT_DEFAULT = @as(u32, 0);
pub const SORT_INVARIANT_MATH = @as(u32, 1);
pub const SORT_JAPANESE_XJIS = @as(u32, 0);
pub const SORT_JAPANESE_UNICODE = @as(u32, 1);
pub const SORT_JAPANESE_RADICALSTROKE = @as(u32, 4);
pub const SORT_CHINESE_BIG5 = @as(u32, 0);
pub const SORT_CHINESE_PRCP = @as(u32, 0);
pub const SORT_CHINESE_UNICODE = @as(u32, 1);
pub const SORT_CHINESE_PRC = @as(u32, 2);
pub const SORT_CHINESE_BOPOMOFO = @as(u32, 3);
pub const SORT_CHINESE_RADICALSTROKE = @as(u32, 4);
pub const SORT_KOREAN_KSC = @as(u32, 0);
pub const SORT_KOREAN_UNICODE = @as(u32, 1);
pub const SORT_GERMAN_PHONE_BOOK = @as(u32, 1);
pub const SORT_HUNGARIAN_DEFAULT = @as(u32, 0);
pub const SORT_HUNGARIAN_TECHNICAL = @as(u32, 1);
pub const SORT_GEORGIAN_TRADITIONAL = @as(u32, 0);
pub const SORT_GEORGIAN_MODERN = @as(u32, 1);
pub const NLS_VALID_LOCALE_MASK = @as(u32, 1048575);
pub const LOCALE_NAME_MAX_LENGTH = @as(u32, 85);
pub const LOCALE_TRANSIENT_KEYBOARD1 = @as(u32, 8192);
pub const LOCALE_TRANSIENT_KEYBOARD2 = @as(u32, 9216);
pub const LOCALE_TRANSIENT_KEYBOARD3 = @as(u32, 10240);
pub const LOCALE_TRANSIENT_KEYBOARD4 = @as(u32, 11264);
pub const MAXIMUM_WAIT_OBJECTS = @as(u32, 64);
pub const EXCEPTION_READ_FAULT = @as(u32, 0);
pub const EXCEPTION_WRITE_FAULT = @as(u32, 1);
pub const EXCEPTION_EXECUTE_FAULT = @as(u32, 8);
pub const CONTEXT_AMD64 = @as(i32, 1048576);
pub const CONTEXT_KERNEL_DEBUGGER = @as(i32, 67108864);
pub const CONTEXT_EXCEPTION_ACTIVE = @as(i32, 134217728);
pub const CONTEXT_SERVICE_ACTIVE = @as(i32, 268435456);
pub const CONTEXT_EXCEPTION_REQUEST = @as(i32, 1073741824);
pub const CONTEXT_EXCEPTION_REPORTING = @as(i32, -2147483648);
pub const INITIAL_MXCSR = @as(u32, 8064);
pub const INITIAL_FPCSR = @as(u32, 639);
pub const RUNTIME_FUNCTION_INDIRECT = @as(u32, 1);
pub const UNW_FLAG_NO_EPILOGUE = @as(u32, 2147483648);
pub const UNWIND_CHAIN_LIMIT = @as(u32, 32);
pub const UNWIND_HISTORY_TABLE_SIZE = @as(u32, 12);
pub const PF_TEMPORAL_LEVEL_1 = @as(u32, 0);
pub const PF_TEMPORAL_LEVEL_2 = @as(u32, 1);
pub const PF_TEMPORAL_LEVEL_3 = @as(u32, 2);
pub const PF_NON_TEMPORAL_LEVEL_ALL = @as(u32, 3);
pub const CONTEXT_ARM = @as(i32, 2097152);
pub const CONTEXT_UNWOUND_TO_CALL = @as(u32, 536870912);
pub const INITIAL_CPSR = @as(u32, 16);
pub const INITIAL_FPSCR = @as(u32, 0);
pub const ARM_MAX_BREAKPOINTS = @as(u32, 8);
pub const ARM_MAX_WATCHPOINTS = @as(u32, 1);
pub const CONTEXT_ARM64 = @as(i32, 4194304);
pub const CONTEXT_RET_TO_GUEST = @as(u32, 67108864);
pub const ARM64_MAX_BREAKPOINTS = @as(u32, 8);
pub const ARM64_MAX_WATCHPOINTS = @as(u32, 2);
pub const BREAK_DEBUG_BASE = @as(u32, 524288);
pub const ASSERT_BREAKPOINT = @as(u32, 524291);
pub const SIZE_OF_80387_REGISTERS = @as(u32, 80);
pub const CONTEXT_i386 = @as(i32, 65536);
pub const CONTEXT_i486 = @as(i32, 65536);
pub const MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const WOW64_CONTEXT_i386 = @as(u32, 65536);
pub const WOW64_CONTEXT_i486 = @as(u32, 65536);
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE = @as(u32, 134217728);
pub const WOW64_CONTEXT_SERVICE_ACTIVE = @as(u32, 268435456);
pub const WOW64_CONTEXT_EXCEPTION_REQUEST = @as(u32, 1073741824);
pub const WOW64_CONTEXT_EXCEPTION_REPORTING = @as(u32, 2147483648);
pub const WOW64_SIZE_OF_80387_REGISTERS = @as(u32, 80);
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const EXCEPTION_NONCONTINUABLE = @as(u32, 1);
pub const EXCEPTION_UNWINDING = @as(u32, 2);
pub const EXCEPTION_EXIT_UNWIND = @as(u32, 4);
pub const EXCEPTION_STACK_INVALID = @as(u32, 8);
pub const EXCEPTION_NESTED_CALL = @as(u32, 16);
pub const EXCEPTION_TARGET_UNWIND = @as(u32, 32);
pub const EXCEPTION_COLLIDED_UNWIND = @as(u32, 64);
pub const EXCEPTION_MAXIMUM_PARAMETERS = @as(u32, 15);
pub const MAXIMUM_ALLOWED = @as(u32, 33554432);
pub const GENERIC_READ = @as(u32, 2147483648);
pub const GENERIC_WRITE = @as(u32, 1073741824);
pub const GENERIC_EXECUTE = @as(u32, 536870912);
pub const GENERIC_ALL = @as(u32, 268435456);
pub const SID_REVISION = @as(u32, 1);
pub const SID_MAX_SUB_AUTHORITIES = @as(u32, 15);
pub const SID_RECOMMENDED_SUB_AUTHORITIES = @as(u32, 1);
pub const SID_HASH_SIZE = @as(u32, 32);
pub const SECURITY_NULL_RID = @as(i32, 0);
pub const SECURITY_WORLD_RID = @as(i32, 0);
pub const SECURITY_LOCAL_RID = @as(i32, 0);
pub const SECURITY_LOCAL_LOGON_RID = @as(i32, 1);
pub const SECURITY_CREATOR_OWNER_RID = @as(i32, 0);
pub const SECURITY_CREATOR_GROUP_RID = @as(i32, 1);
pub const SECURITY_CREATOR_OWNER_SERVER_RID = @as(i32, 2);
pub const SECURITY_CREATOR_GROUP_SERVER_RID = @as(i32, 3);
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID = @as(i32, 4);
pub const SECURITY_DIALUP_RID = @as(i32, 1);
pub const SECURITY_NETWORK_RID = @as(i32, 2);
pub const SECURITY_BATCH_RID = @as(i32, 3);
pub const SECURITY_INTERACTIVE_RID = @as(i32, 4);
pub const SECURITY_LOGON_IDS_RID = @as(i32, 5);
pub const SECURITY_LOGON_IDS_RID_COUNT = @as(i32, 3);
pub const SECURITY_SERVICE_RID = @as(i32, 6);
pub const SECURITY_ANONYMOUS_LOGON_RID = @as(i32, 7);
pub const SECURITY_PROXY_RID = @as(i32, 8);
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID = @as(i32, 9);
pub const SECURITY_PRINCIPAL_SELF_RID = @as(i32, 10);
pub const SECURITY_AUTHENTICATED_USER_RID = @as(i32, 11);
pub const SECURITY_RESTRICTED_CODE_RID = @as(i32, 12);
pub const SECURITY_TERMINAL_SERVER_RID = @as(i32, 13);
pub const SECURITY_REMOTE_LOGON_RID = @as(i32, 14);
pub const SECURITY_THIS_ORGANIZATION_RID = @as(i32, 15);
pub const SECURITY_IUSER_RID = @as(i32, 17);
pub const SECURITY_LOCAL_SYSTEM_RID = @as(i32, 18);
pub const SECURITY_LOCAL_SERVICE_RID = @as(i32, 19);
pub const SECURITY_NETWORK_SERVICE_RID = @as(i32, 20);
pub const SECURITY_NT_NON_UNIQUE = @as(i32, 21);
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT = @as(i32, 3);
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID = @as(i32, 22);
pub const SECURITY_BUILTIN_DOMAIN_RID = @as(i32, 32);
pub const SECURITY_WRITE_RESTRICTED_CODE_RID = @as(i32, 33);
pub const SECURITY_PACKAGE_BASE_RID = @as(i32, 64);
pub const SECURITY_PACKAGE_RID_COUNT = @as(i32, 2);
pub const SECURITY_PACKAGE_NTLM_RID = @as(i32, 10);
pub const SECURITY_PACKAGE_SCHANNEL_RID = @as(i32, 14);
pub const SECURITY_PACKAGE_DIGEST_RID = @as(i32, 21);
pub const SECURITY_CRED_TYPE_BASE_RID = @as(i32, 65);
pub const SECURITY_CRED_TYPE_RID_COUNT = @as(i32, 2);
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID = @as(i32, 1);
pub const SECURITY_MIN_BASE_RID = @as(i32, 80);
pub const SECURITY_SERVICE_ID_BASE_RID = @as(i32, 80);
pub const SECURITY_SERVICE_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_RESERVED_ID_BASE_RID = @as(i32, 81);
pub const SECURITY_APPPOOL_ID_BASE_RID = @as(i32, 82);
pub const SECURITY_APPPOOL_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID = @as(i32, 83);
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID = @as(i32, 84);
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID = @as(i32, 85);
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_WMIHOST_ID_BASE_RID = @as(i32, 86);
pub const SECURITY_WMIHOST_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_TASK_ID_BASE_RID = @as(i32, 87);
pub const SECURITY_NFS_ID_BASE_RID = @as(i32, 88);
pub const SECURITY_COM_ID_BASE_RID = @as(i32, 89);
pub const SECURITY_WINDOW_MANAGER_BASE_RID = @as(i32, 90);
pub const SECURITY_RDV_GFX_BASE_RID = @as(i32, 91);
pub const SECURITY_DASHOST_ID_BASE_RID = @as(i32, 92);
pub const SECURITY_DASHOST_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_USERMANAGER_ID_BASE_RID = @as(i32, 93);
pub const SECURITY_USERMANAGER_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_WINRM_ID_BASE_RID = @as(i32, 94);
pub const SECURITY_WINRM_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_CCG_ID_BASE_RID = @as(i32, 95);
pub const SECURITY_UMFD_BASE_RID = @as(i32, 96);
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT = @as(i32, 6);
pub const SECURITY_MAX_BASE_RID = @as(i32, 111);
pub const SECURITY_MAX_ALWAYS_FILTERED = @as(i32, 999);
pub const SECURITY_MIN_NEVER_FILTERED = @as(i32, 1000);
pub const SECURITY_OTHER_ORGANIZATION_RID = @as(i32, 1000);
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID = @as(i32, 112);
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE = @as(u32, 32);
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT = @as(u32, 9);
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT = @as(u32, 10);
pub const SECURITY_LOCAL_ACCOUNT_RID = @as(i32, 113);
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID = @as(i32, 114);
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED = @as(i32, 496);
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS = @as(i32, 497);
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS = @as(i32, 498);
pub const FOREST_USER_RID_MAX = @as(i32, 499);
pub const DOMAIN_USER_RID_ADMIN = @as(i32, 500);
pub const DOMAIN_USER_RID_GUEST = @as(i32, 501);
pub const DOMAIN_USER_RID_KRBTGT = @as(i32, 502);
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT = @as(i32, 503);
pub const DOMAIN_USER_RID_WDAG_ACCOUNT = @as(i32, 504);
pub const DOMAIN_USER_RID_MAX = @as(i32, 999);
pub const DOMAIN_GROUP_RID_ADMINS = @as(i32, 512);
pub const DOMAIN_GROUP_RID_USERS = @as(i32, 513);
pub const DOMAIN_GROUP_RID_GUESTS = @as(i32, 514);
pub const DOMAIN_GROUP_RID_COMPUTERS = @as(i32, 515);
pub const DOMAIN_GROUP_RID_CONTROLLERS = @as(i32, 516);
pub const DOMAIN_GROUP_RID_CERT_ADMINS = @as(i32, 517);
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS = @as(i32, 518);
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = @as(i32, 519);
pub const DOMAIN_GROUP_RID_POLICY_ADMINS = @as(i32, 520);
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS = @as(i32, 521);
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS = @as(i32, 522);
pub const DOMAIN_GROUP_RID_CDC_RESERVED = @as(i32, 524);
pub const DOMAIN_GROUP_RID_PROTECTED_USERS = @as(i32, 525);
pub const DOMAIN_GROUP_RID_KEY_ADMINS = @as(i32, 526);
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS = @as(i32, 527);
pub const DOMAIN_ALIAS_RID_ADMINS = @as(i32, 544);
pub const DOMAIN_ALIAS_RID_USERS = @as(i32, 545);
pub const DOMAIN_ALIAS_RID_GUESTS = @as(i32, 546);
pub const DOMAIN_ALIAS_RID_POWER_USERS = @as(i32, 547);
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS = @as(i32, 548);
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS = @as(i32, 549);
pub const DOMAIN_ALIAS_RID_PRINT_OPS = @as(i32, 550);
pub const DOMAIN_ALIAS_RID_BACKUP_OPS = @as(i32, 551);
pub const DOMAIN_ALIAS_RID_REPLICATOR = @as(i32, 552);
pub const DOMAIN_ALIAS_RID_RAS_SERVERS = @as(i32, 553);
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = @as(i32, 554);
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS = @as(i32, 555);
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS = @as(i32, 556);
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = @as(i32, 557);
pub const DOMAIN_ALIAS_RID_MONITORING_USERS = @as(i32, 558);
pub const DOMAIN_ALIAS_RID_LOGGING_USERS = @as(i32, 559);
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS = @as(i32, 560);
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS = @as(i32, 561);
pub const DOMAIN_ALIAS_RID_DCOM_USERS = @as(i32, 562);
pub const DOMAIN_ALIAS_RID_IUSERS = @as(i32, 568);
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS = @as(i32, 569);
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP = @as(i32, 571);
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = @as(i32, 572);
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP = @as(i32, 573);
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP = @as(i32, 574);
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS = @as(i32, 575);
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS = @as(i32, 576);
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS = @as(i32, 577);
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS = @as(i32, 578);
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS = @as(i32, 579);
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS = @as(i32, 580);
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT = @as(i32, 581);
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS = @as(i32, 582);
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS = @as(i32, 583);
pub const SECURITY_APP_PACKAGE_BASE_RID = @as(i32, 2);
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT = @as(i32, 2);
pub const SECURITY_APP_PACKAGE_RID_COUNT = @as(i32, 8);
pub const SECURITY_CAPABILITY_BASE_RID = @as(i32, 3);
pub const SECURITY_CAPABILITY_APP_RID = @as(u64, 1024);
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT = @as(i32, 2);
pub const SECURITY_CAPABILITY_RID_COUNT = @as(i32, 5);
pub const SECURITY_CHILD_PACKAGE_RID_COUNT = @as(i32, 12);
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE = @as(i32, 1);
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE = @as(i32, 2);
pub const SECURITY_CAPABILITY_INTERNET_CLIENT = @as(i32, 1);
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER = @as(i32, 2);
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER = @as(i32, 3);
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY = @as(i32, 4);
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY = @as(i32, 5);
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY = @as(i32, 6);
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY = @as(i32, 7);
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION = @as(i32, 8);
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES = @as(i32, 9);
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE = @as(i32, 10);
pub const SECURITY_CAPABILITY_APPOINTMENTS = @as(i32, 11);
pub const SECURITY_CAPABILITY_CONTACTS = @as(i32, 12);
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER = @as(i32, 4096);
pub const SECURITY_MANDATORY_UNTRUSTED_RID = @as(i32, 0);
pub const SECURITY_MANDATORY_LOW_RID = @as(i32, 4096);
pub const SECURITY_MANDATORY_MEDIUM_RID = @as(i32, 8192);
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID = @as(u32, 8448);
pub const SECURITY_MANDATORY_HIGH_RID = @as(i32, 12288);
pub const SECURITY_MANDATORY_SYSTEM_RID = @as(i32, 16384);
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID = @as(i32, 20480);
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT = @as(i32, 1);
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID = @as(i32, 1);
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID = @as(i32, 2);
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID = @as(i32, 3);
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID = @as(i32, 4);
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID = @as(i32, 5);
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID = @as(i32, 6);
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT = @as(i32, 2);
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID = @as(i32, 1024);
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID = @as(i32, 512);
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID = @as(i32, 0);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID = @as(i32, 8192);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID = @as(i32, 4096);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID = @as(i32, 2048);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID = @as(i32, 1536);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID = @as(i32, 1024);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID = @as(i32, 0);
pub const SECURITY_TRUSTED_INSTALLER_RID1 = @as(u32, 956008885);
pub const SECURITY_TRUSTED_INSTALLER_RID2 = @as(u32, 3418522649);
pub const SECURITY_TRUSTED_INSTALLER_RID3 = @as(u32, 1831038044);
pub const SECURITY_TRUSTED_INSTALLER_RID4 = @as(u32, 1853292631);
pub const SECURITY_TRUSTED_INSTALLER_RID5 = @as(u32, 2271478464);
pub const SE_GROUP_MANDATORY = @as(i32, 1);
pub const SE_GROUP_ENABLED_BY_DEFAULT = @as(i32, 2);
pub const SE_GROUP_ENABLED = @as(i32, 4);
pub const SE_GROUP_OWNER = @as(i32, 8);
pub const SE_GROUP_USE_FOR_DENY_ONLY = @as(i32, 16);
pub const SE_GROUP_INTEGRITY = @as(i32, 32);
pub const SE_GROUP_INTEGRITY_ENABLED = @as(i32, 64);
pub const SE_GROUP_LOGON_ID = @as(i32, -1073741824);
pub const SE_GROUP_RESOURCE = @as(i32, 536870912);
pub const ACL_REVISION1 = @as(u32, 1);
pub const ACL_REVISION2 = @as(u32, 2);
pub const ACL_REVISION3 = @as(u32, 3);
pub const ACL_REVISION4 = @as(u32, 4);
pub const ACCESS_MIN_MS_ACE_TYPE = @as(u32, 0);
pub const ACCESS_ALLOWED_ACE_TYPE = @as(u32, 0);
pub const ACCESS_DENIED_ACE_TYPE = @as(u32, 1);
pub const SYSTEM_AUDIT_ACE_TYPE = @as(u32, 2);
pub const SYSTEM_ALARM_ACE_TYPE = @as(u32, 3);
pub const ACCESS_MAX_MS_V2_ACE_TYPE = @as(u32, 3);
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE = @as(u32, 4);
pub const ACCESS_MAX_MS_V3_ACE_TYPE = @as(u32, 4);
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE = @as(u32, 5);
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE = @as(u32, 5);
pub const ACCESS_DENIED_OBJECT_ACE_TYPE = @as(u32, 6);
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE = @as(u32, 7);
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE = @as(u32, 8);
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE = @as(u32, 8);
pub const ACCESS_MAX_MS_V4_ACE_TYPE = @as(u32, 8);
pub const ACCESS_MAX_MS_ACE_TYPE = @as(u32, 8);
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE = @as(u32, 9);
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE = @as(u32, 10);
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE = @as(u32, 11);
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE = @as(u32, 12);
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE = @as(u32, 13);
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE = @as(u32, 14);
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE = @as(u32, 15);
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE = @as(u32, 16);
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE = @as(u32, 17);
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE = @as(u32, 18);
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE = @as(u32, 19);
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE = @as(u32, 20);
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE = @as(u32, 21);
pub const ACCESS_MAX_MS_V5_ACE_TYPE = @as(u32, 21);
pub const VALID_INHERIT_FLAGS = @as(u32, 31);
pub const CRITICAL_ACE_FLAG = @as(u32, 32);
pub const TRUST_PROTECTED_FILTER_ACE_FLAG = @as(u32, 64);
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP = @as(u32, 1);
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP = @as(u32, 2);
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP = @as(u32, 4);
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK = @as(u32, 16777215);
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK = @as(u32, 4294967295);
pub const SYSTEM_ACCESS_FILTER_VALID_MASK = @as(u32, 16777215);
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK = @as(u32, 4294967295);
pub const SECURITY_DESCRIPTOR_REVISION = @as(u32, 1);
pub const SECURITY_DESCRIPTOR_REVISION1 = @as(u32, 1);
pub const SE_OWNER_DEFAULTED = @as(u32, 1);
pub const SE_GROUP_DEFAULTED = @as(u32, 2);
pub const SE_DACL_PRESENT = @as(u32, 4);
pub const SE_DACL_DEFAULTED = @as(u32, 8);
pub const SE_SACL_PRESENT = @as(u32, 16);
pub const SE_SACL_DEFAULTED = @as(u32, 32);
pub const SE_DACL_AUTO_INHERIT_REQ = @as(u32, 256);
pub const SE_SACL_AUTO_INHERIT_REQ = @as(u32, 512);
pub const SE_DACL_AUTO_INHERITED = @as(u32, 1024);
pub const SE_SACL_AUTO_INHERITED = @as(u32, 2048);
pub const SE_DACL_PROTECTED = @as(u32, 4096);
pub const SE_SACL_PROTECTED = @as(u32, 8192);
pub const SE_RM_CONTROL_VALID = @as(u32, 16384);
pub const SE_SELF_RELATIVE = @as(u32, 32768);
pub const ACCESS_OBJECT_GUID = @as(u32, 0);
pub const ACCESS_PROPERTY_SET_GUID = @as(u32, 1);
pub const ACCESS_PROPERTY_GUID = @as(u32, 2);
pub const ACCESS_MAX_LEVEL = @as(u32, 4);
pub const AUDIT_ALLOW_NO_PRIVILEGE = @as(u32, 1);
pub const PRIVILEGE_SET_ALL_NECESSARY = @as(u32, 1);
pub const ACCESS_REASON_TYPE_MASK = @as(u32, 16711680);
pub const ACCESS_REASON_DATA_MASK = @as(u32, 65535);
pub const ACCESS_REASON_STAGING_MASK = @as(u32, 2147483648);
pub const ACCESS_REASON_EXDATA_MASK = @as(u32, 2130706432);
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE = @as(u32, 1);
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE = @as(u32, 2);
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE = @as(u32, 4);
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS = @as(u32, 7);
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING = @as(u32, 8);
pub const SE_ACCESS_CHECK_VALID_FLAGS = @as(u32, 8);
pub const POLICY_AUDIT_SUBCATEGORY_COUNT = @as(u32, 59);
pub const TOKEN_SOURCE_LENGTH = @as(u32, 8);
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID = @as(u32, 0);
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS = @as(u32, 4294901760);
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 = @as(u32, 1);
pub const LABEL_SECURITY_INFORMATION = @as(i32, 16);
pub const ATTRIBUTE_SECURITY_INFORMATION = @as(i32, 32);
pub const SCOPE_SECURITY_INFORMATION = @as(i32, 64);
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION = @as(i32, 128);
pub const ACCESS_FILTER_SECURITY_INFORMATION = @as(i32, 256);
pub const BACKUP_SECURITY_INFORMATION = @as(i32, 65536);
pub const PROTECTED_DACL_SECURITY_INFORMATION = @as(i32, -2147483648);
pub const PROTECTED_SACL_SECURITY_INFORMATION = @as(i32, 1073741824);
pub const UNPROTECTED_DACL_SECURITY_INFORMATION = @as(i32, 536870912);
pub const UNPROTECTED_SACL_SECURITY_INFORMATION = @as(i32, 268435456);
pub const SE_SIGNING_LEVEL_UNCHECKED = @as(u32, 0);
pub const SE_SIGNING_LEVEL_UNSIGNED = @as(u32, 1);
pub const SE_SIGNING_LEVEL_ENTERPRISE = @as(u32, 2);
pub const SE_SIGNING_LEVEL_CUSTOM_1 = @as(u32, 3);
pub const SE_SIGNING_LEVEL_AUTHENTICODE = @as(u32, 4);
pub const SE_SIGNING_LEVEL_CUSTOM_2 = @as(u32, 5);
pub const SE_SIGNING_LEVEL_STORE = @as(u32, 6);
pub const SE_SIGNING_LEVEL_CUSTOM_3 = @as(u32, 7);
pub const SE_SIGNING_LEVEL_MICROSOFT = @as(u32, 8);
pub const SE_SIGNING_LEVEL_CUSTOM_4 = @as(u32, 9);
pub const SE_SIGNING_LEVEL_CUSTOM_5 = @as(u32, 10);
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN = @as(u32, 11);
pub const SE_SIGNING_LEVEL_WINDOWS = @as(u32, 12);
pub const SE_SIGNING_LEVEL_CUSTOM_7 = @as(u32, 13);
pub const SE_SIGNING_LEVEL_WINDOWS_TCB = @as(u32, 14);
pub const SE_SIGNING_LEVEL_CUSTOM_6 = @as(u32, 15);
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE = @as(u32, 1);
pub const THREAD_TERMINATE = @as(u32, 1);
pub const THREAD_SUSPEND_RESUME = @as(u32, 2);
pub const THREAD_GET_CONTEXT = @as(u32, 8);
pub const THREAD_SET_CONTEXT = @as(u32, 16);
pub const THREAD_QUERY_INFORMATION = @as(u32, 64);
pub const THREAD_SET_INFORMATION = @as(u32, 32);
pub const THREAD_SET_THREAD_TOKEN = @as(u32, 128);
pub const THREAD_IMPERSONATE = @as(u32, 256);
pub const THREAD_DIRECT_IMPERSONATION = @as(u32, 512);
pub const THREAD_SET_LIMITED_INFORMATION = @as(u32, 1024);
pub const THREAD_QUERY_LIMITED_INFORMATION = @as(u32, 2048);
pub const THREAD_RESUME = @as(u32, 4096);
pub const JOB_OBJECT_ASSIGN_PROCESS = @as(u32, 1);
pub const JOB_OBJECT_SET_ATTRIBUTES = @as(u32, 2);
pub const JOB_OBJECT_QUERY = @as(u32, 4);
pub const JOB_OBJECT_TERMINATE = @as(u32, 8);
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES = @as(u32, 16);
pub const JOB_OBJECT_IMPERSONATE = @as(u32, 32);
pub const FLS_MAXIMUM_AVAILABLE = @as(u32, 4080);
pub const TLS_MINIMUM_AVAILABLE = @as(u32, 64);
pub const THREAD_DYNAMIC_CODE_ALLOW = @as(u32, 1);
pub const THREAD_BASE_PRIORITY_LOWRT = @as(u32, 15);
pub const THREAD_BASE_PRIORITY_MAX = @as(u32, 2);
pub const THREAD_BASE_PRIORITY_MIN = @as(i32, -2);
pub const THREAD_BASE_PRIORITY_IDLE = @as(i32, -15);
pub const MEMORY_PRIORITY_LOWEST = @as(u32, 0);
pub const DYNAMIC_EH_CONTINUATION_TARGET_ADD = @as(u32, 1);
pub const DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED = @as(u32, 2);
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE = @as(u32, 1);
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE = @as(u32, 2);
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE = @as(u32, 4);
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE = @as(u32, 8);
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS = @as(u32, 16);
pub const MAX_HW_COUNTERS = @as(u32, 16);
pub const THREAD_PROFILING_FLAG_DISPATCH = @as(u32, 1);
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG = @as(u32, 64);
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME = @as(u32, 1);
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME = @as(u32, 2);
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT = @as(u32, 3);
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO = @as(u32, 4);
pub const JOB_OBJECT_MSG_NEW_PROCESS = @as(u32, 6);
pub const JOB_OBJECT_MSG_EXIT_PROCESS = @as(u32, 7);
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS = @as(u32, 8);
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT = @as(u32, 9);
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT = @as(u32, 10);
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT = @as(u32, 11);
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT = @as(u32, 12);
pub const JOB_OBJECT_MSG_SILO_TERMINATED = @as(u32, 13);
pub const JOB_OBJECT_MSG_MINIMUM = @as(u32, 1);
pub const JOB_OBJECT_MSG_MAXIMUM = @as(u32, 13);
pub const JOB_OBJECT_UILIMIT_ALL = @as(u32, 255);
pub const JOB_OBJECT_UI_VALID_FLAGS = @as(u32, 255);
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE = @as(u32, 16);
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS = @as(u32, 31);
pub const EVENT_MODIFY_STATE = @as(u32, 2);
pub const MUTANT_QUERY_STATE = @as(u32, 1);
pub const SEMAPHORE_MODIFY_STATE = @as(u32, 2);
pub const TIMER_QUERY_STATE = @as(u32, 1);
pub const TIMER_MODIFY_STATE = @as(u32, 2);
pub const TIME_ZONE_ID_UNKNOWN = @as(u32, 0);
pub const TIME_ZONE_ID_STANDARD = @as(u32, 1);
pub const TIME_ZONE_ID_DAYLIGHT = @as(u32, 2);
pub const LTP_PC_SMT = @as(u32, 1);
pub const CACHE_FULLY_ASSOCIATIVE = @as(u32, 255);
pub const SYSTEM_CPU_SET_INFORMATION_PARKED = @as(u32, 1);
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED = @as(u32, 2);
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS = @as(u32, 4);
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME = @as(u32, 8);
pub const PROCESSOR_INTEL_386 = @as(u32, 386);
pub const PROCESSOR_INTEL_486 = @as(u32, 486);
pub const PROCESSOR_INTEL_PENTIUM = @as(u32, 586);
pub const PROCESSOR_INTEL_IA64 = @as(u32, 2200);
pub const PROCESSOR_AMD_X8664 = @as(u32, 8664);
pub const PROCESSOR_MIPS_R4000 = @as(u32, 4000);
pub const PROCESSOR_ALPHA_21064 = @as(u32, 21064);
pub const PROCESSOR_PPC_601 = @as(u32, 601);
pub const PROCESSOR_PPC_603 = @as(u32, 603);
pub const PROCESSOR_PPC_604 = @as(u32, 604);
pub const PROCESSOR_PPC_620 = @as(u32, 620);
pub const PROCESSOR_HITACHI_SH3 = @as(u32, 10003);
pub const PROCESSOR_HITACHI_SH3E = @as(u32, 10004);
pub const PROCESSOR_HITACHI_SH4 = @as(u32, 10005);
pub const PROCESSOR_MOTOROLA_821 = @as(u32, 821);
pub const PROCESSOR_SHx_SH3 = @as(u32, 103);
pub const PROCESSOR_SHx_SH4 = @as(u32, 104);
pub const PROCESSOR_STRONGARM = @as(u32, 2577);
pub const PROCESSOR_ARM720 = @as(u32, 1824);
pub const PROCESSOR_ARM820 = @as(u32, 2080);
pub const PROCESSOR_ARM920 = @as(u32, 2336);
pub const PROCESSOR_ARM_7TDMI = @as(u32, 70001);
pub const PROCESSOR_OPTIL = @as(u32, 18767);
pub const PROCESSOR_ARCHITECTURE_MIPS = @as(u32, 1);
pub const PROCESSOR_ARCHITECTURE_ALPHA = @as(u32, 2);
pub const PROCESSOR_ARCHITECTURE_PPC = @as(u32, 3);
pub const PROCESSOR_ARCHITECTURE_SHX = @as(u32, 4);
pub const PROCESSOR_ARCHITECTURE_ALPHA64 = @as(u32, 7);
pub const PROCESSOR_ARCHITECTURE_MSIL = @as(u32, 8);
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = @as(u32, 10);
pub const PROCESSOR_ARCHITECTURE_NEUTRAL = @as(u32, 11);
pub const PROCESSOR_ARCHITECTURE_ARM64 = @as(u32, 12);
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 = @as(u32, 13);
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64 = @as(u32, 14);
pub const PF_PPC_MOVEMEM_64BIT_OK = @as(u32, 4);
pub const PF_ALPHA_BYTE_INSTRUCTIONS = @as(u32, 5);
pub const PF_SSE_DAZ_MODE_AVAILABLE = @as(u32, 11);
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE = @as(u32, 19);
pub const PF_RDRAND_INSTRUCTION_AVAILABLE = @as(u32, 28);
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE = @as(u32, 32);
pub const PF_RDPID_INSTRUCTION_AVAILABLE = @as(u32, 33);
pub const PF_MONITORX_INSTRUCTION_AVAILABLE = @as(u32, 35);
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE = @as(u32, 36);
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE = @as(u32, 37);
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE = @as(u32, 38);
pub const PF_AVX_INSTRUCTIONS_AVAILABLE = @as(u32, 39);
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE = @as(u32, 40);
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE = @as(u32, 41);
pub const XSTATE_LEGACY_FLOATING_POINT = @as(u32, 0);
pub const XSTATE_LEGACY_SSE = @as(u32, 1);
pub const XSTATE_GSSE = @as(u32, 2);
pub const XSTATE_MPX_BNDREGS = @as(u32, 3);
pub const XSTATE_MPX_BNDCSR = @as(u32, 4);
pub const XSTATE_AVX512_KMASK = @as(u32, 5);
pub const XSTATE_AVX512_ZMM_H = @as(u32, 6);
pub const XSTATE_AVX512_ZMM = @as(u32, 7);
pub const XSTATE_IPT = @as(u32, 8);
pub const XSTATE_CET_U = @as(u32, 11);
pub const XSTATE_LWP = @as(u32, 62);
pub const MAXIMUM_XSTATE_FEATURES = @as(u32, 64);
pub const XSTATE_COMPACTION_ENABLE = @as(u32, 63);
pub const XSTATE_ALIGN_BIT = @as(u32, 1);
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK = @as(u32, 1);
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK = @as(u32, 2);
pub const CFG_CALL_TARGET_VALID = @as(u32, 1);
pub const CFG_CALL_TARGET_PROCESSED = @as(u32, 2);
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID = @as(u32, 4);
pub const SESSION_QUERY_ACCESS = @as(u32, 1);
pub const SESSION_MODIFY_ACCESS = @as(u32, 2);
pub const MEM_TOP_DOWN = @as(u32, 1048576);
pub const MEM_WRITE_WATCH = @as(u32, 2097152);
pub const MEM_PHYSICAL = @as(u32, 4194304);
pub const MEM_ROTATE = @as(u32, 8388608);
pub const MEM_DIFFERENT_IMAGE_BASE_OK = @as(u32, 8388608);
pub const MEM_4MB_PAGES = @as(u32, 2147483648);
pub const MEM_COALESCE_PLACEHOLDERS = @as(u32, 1);
pub const MEM_EXTENDED_PARAMETER_GRAPHICS = @as(u32, 1);
pub const MEM_EXTENDED_PARAMETER_NONPAGED = @as(u32, 2);
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL = @as(u32, 4);
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE = @as(u32, 8);
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE = @as(u32, 16);
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES = @as(u32, 32);
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS = @as(u32, 8);
pub const MEM_PRIVATE = @as(u32, 131072);
pub const MEM_MAPPED = @as(u32, 262144);
pub const MEM_IMAGE = @as(u32, 16777216);
pub const WRITE_WATCH_FLAG_RESET = @as(u32, 1);
pub const ENCLAVE_TYPE_SGX = @as(u32, 1);
pub const ENCLAVE_TYPE_SGX2 = @as(u32, 2);
pub const ENCLAVE_TYPE_VBS = @as(u32, 16);
pub const ENCLAVE_VBS_FLAG_DEBUG = @as(u32, 1);
pub const ENCLAVE_TYPE_VBS_BASIC = @as(u32, 17);
pub const VBS_BASIC_PAGE_MEASURED_DATA = @as(u32, 1);
pub const VBS_BASIC_PAGE_UNMEASURED_DATA = @as(u32, 2);
pub const VBS_BASIC_PAGE_ZERO_FILL = @as(u32, 3);
pub const VBS_BASIC_PAGE_THREAD_DESCRIPTOR = @as(u32, 4);
pub const VBS_BASIC_PAGE_SYSTEM_CALL = @as(u32, 5);
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY = @as(u32, 16384);
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY = @as(u32, 32768);
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL = @as(u32, 4);
pub const TREE_CONNECT_ATTRIBUTE_PINNED = @as(u32, 2);
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL = @as(u32, 536870912);
pub const FILE_CASE_SENSITIVE_SEARCH = @as(u32, 1);
pub const FILE_CASE_PRESERVED_NAMES = @as(u32, 2);
pub const FILE_UNICODE_ON_DISK = @as(u32, 4);
pub const FILE_PERSISTENT_ACLS = @as(u32, 8);
pub const FILE_FILE_COMPRESSION = @as(u32, 16);
pub const FILE_VOLUME_QUOTAS = @as(u32, 32);
pub const FILE_SUPPORTS_SPARSE_FILES = @as(u32, 64);
pub const FILE_SUPPORTS_REPARSE_POINTS = @as(u32, 128);
pub const FILE_SUPPORTS_REMOTE_STORAGE = @as(u32, 256);
pub const FILE_RETURNS_CLEANUP_RESULT_INFO = @as(u32, 512);
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME = @as(u32, 1024);
pub const FILE_VOLUME_IS_COMPRESSED = @as(u32, 32768);
pub const FILE_SUPPORTS_OBJECT_IDS = @as(u32, 65536);
pub const FILE_SUPPORTS_ENCRYPTION = @as(u32, 131072);
pub const FILE_NAMED_STREAMS = @as(u32, 262144);
pub const FILE_READ_ONLY_VOLUME = @as(u32, 524288);
pub const FILE_SEQUENTIAL_WRITE_ONCE = @as(u32, 1048576);
pub const FILE_SUPPORTS_TRANSACTIONS = @as(u32, 2097152);
pub const FILE_SUPPORTS_HARD_LINKS = @as(u32, 4194304);
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES = @as(u32, 8388608);
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID = @as(u32, 16777216);
pub const FILE_SUPPORTS_USN_JOURNAL = @as(u32, 33554432);
pub const FILE_SUPPORTS_INTEGRITY_STREAMS = @as(u32, 67108864);
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING = @as(u32, 134217728);
pub const FILE_SUPPORTS_SPARSE_VDL = @as(u32, 268435456);
pub const FILE_DAX_VOLUME = @as(u32, 536870912);
pub const FILE_SUPPORTS_GHOSTING = @as(u32, 1073741824);
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR = @as(u32, 1);
pub const FLUSH_FLAGS_FILE_DATA_ONLY = @as(u32, 1);
pub const FLUSH_FLAGS_NO_SYNC = @as(u32, 2);
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY = @as(u32, 4);
pub const IO_REPARSE_TAG_RESERVED_ZERO = @as(u32, 0);
pub const IO_REPARSE_TAG_RESERVED_ONE = @as(u32, 1);
pub const IO_REPARSE_TAG_RESERVED_TWO = @as(u32, 2);
pub const IO_REPARSE_TAG_MOUNT_POINT = @as(i32, -1610612733);
pub const IO_REPARSE_TAG_HSM = @as(i32, -1073741820);
pub const IO_REPARSE_TAG_HSM2 = @as(i32, -2147483642);
pub const IO_REPARSE_TAG_SIS = @as(i32, -2147483641);
pub const IO_REPARSE_TAG_WIM = @as(i32, -2147483640);
pub const IO_REPARSE_TAG_CSV = @as(i32, -2147483639);
pub const IO_REPARSE_TAG_DFS = @as(i32, -2147483638);
pub const IO_REPARSE_TAG_SYMLINK = @as(i32, -1610612724);
pub const IO_REPARSE_TAG_DFSR = @as(i32, -2147483630);
pub const IO_REPARSE_TAG_DEDUP = @as(i32, -2147483629);
pub const IO_REPARSE_TAG_NFS = @as(i32, -2147483628);
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER = @as(i32, -2147483627);
pub const IO_REPARSE_TAG_WOF = @as(i32, -2147483625);
pub const IO_REPARSE_TAG_WCI = @as(i32, -2147483624);
pub const IO_REPARSE_TAG_WCI_1 = @as(i32, -1879044072);
pub const IO_REPARSE_TAG_GLOBAL_REPARSE = @as(i32, -1610612711);
pub const IO_REPARSE_TAG_CLOUD = @as(i32, -1879048166);
pub const IO_REPARSE_TAG_CLOUD_1 = @as(i32, -1879044070);
pub const IO_REPARSE_TAG_CLOUD_2 = @as(i32, -1879039974);
pub const IO_REPARSE_TAG_CLOUD_3 = @as(i32, -1879035878);
pub const IO_REPARSE_TAG_CLOUD_4 = @as(i32, -1879031782);
pub const IO_REPARSE_TAG_CLOUD_5 = @as(i32, -1879027686);
pub const IO_REPARSE_TAG_CLOUD_6 = @as(i32, -1879023590);
pub const IO_REPARSE_TAG_CLOUD_7 = @as(i32, -1879019494);
pub const IO_REPARSE_TAG_CLOUD_8 = @as(i32, -1879015398);
pub const IO_REPARSE_TAG_CLOUD_9 = @as(i32, -1879011302);
pub const IO_REPARSE_TAG_CLOUD_A = @as(i32, -1879007206);
pub const IO_REPARSE_TAG_CLOUD_B = @as(i32, -1879003110);
pub const IO_REPARSE_TAG_CLOUD_C = @as(i32, -1878999014);
pub const IO_REPARSE_TAG_CLOUD_D = @as(i32, -1878994918);
pub const IO_REPARSE_TAG_CLOUD_E = @as(i32, -1878990822);
pub const IO_REPARSE_TAG_CLOUD_F = @as(i32, -1878986726);
pub const IO_REPARSE_TAG_CLOUD_MASK = @as(i32, 61440);
pub const IO_REPARSE_TAG_APPEXECLINK = @as(i32, -2147483621);
pub const IO_REPARSE_TAG_PROJFS = @as(i32, -1879048164);
pub const IO_REPARSE_TAG_STORAGE_SYNC = @as(i32, -2147483618);
pub const IO_REPARSE_TAG_WCI_TOMBSTONE = @as(i32, -1610612705);
pub const IO_REPARSE_TAG_UNHANDLED = @as(i32, -2147483616);
pub const IO_REPARSE_TAG_ONEDRIVE = @as(i32, -2147483615);
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE = @as(i32, -1610612702);
pub const IO_REPARSE_TAG_AF_UNIX = @as(i32, -2147483613);
pub const IO_REPARSE_TAG_WCI_LINK = @as(i32, -1610612697);
pub const IO_REPARSE_TAG_WCI_LINK_1 = @as(i32, -1610608601);
pub const SCRUB_DATA_INPUT_FLAG_RESUME = @as(u32, 1);
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC = @as(u32, 2);
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA = @as(u32, 4);
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY = @as(u32, 8);
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA = @as(u32, 16);
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID = @as(u32, 32);
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED = @as(u32, 64);
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE = @as(u32, 1);
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE = @as(u32, 65536);
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED = @as(u32, 131072);
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED = @as(u32, 262144);
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS = @as(u32, 1);
pub const IO_COMPLETION_MODIFY_STATE = @as(u32, 2);
pub const GUID_MAX_POWER_SAVINGS = Guid.initString("a1841308-3541-4fab-bc81-f71556f20b4a");
pub const GUID_MIN_POWER_SAVINGS = Guid.initString("8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c");
pub const GUID_TYPICAL_POWER_SAVINGS = Guid.initString("381b4222-f694-41f0-9685-ff5bb260df2e");
pub const NO_SUBGROUP_GUID = Guid.initString("fea3413e-7e05-4911-9a71-700331f1c294");
pub const ALL_POWERSCHEMES_GUID = Guid.initString("68a1e95e-13ea-41e1-8011-0c496ca490b0");
pub const GUID_POWERSCHEME_PERSONALITY = Guid.initString("245d8541-3943-4422-b025-13a784f679b7");
pub const GUID_ACTIVE_POWERSCHEME = Guid.initString("31f9f286-5084-42fe-b720-2b0264993763");
pub const GUID_IDLE_RESILIENCY_SUBGROUP = Guid.initString("2e601130-5351-4d9d-8e04-252966bad054");
pub const GUID_IDLE_RESILIENCY_PERIOD = Guid.initString("c42b79aa-aa3a-484b-a98f-2cf32aa90a28");
pub const GUID_DEEP_SLEEP_ENABLED = Guid.initString("d502f7ee-1dc7-4efd-a55d-f04b6f5c0545");
pub const GUID_DEEP_SLEEP_PLATFORM_STATE = Guid.initString("d23f2fb8-9536-4038-9c94-1ce02e5c2152");
pub const GUID_DISK_COALESCING_POWERDOWN_TIMEOUT = Guid.initString("c36f0eb4-2988-4a70-8eee-0884fc2c2433");
pub const GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT = Guid.initString("3166bc41-7e98-4e03-b34e-ec0f5f2b218e");
pub const GUID_VIDEO_SUBGROUP = Guid.initString("7516b95f-f776-4464-8c53-06167f40cc99");
pub const GUID_VIDEO_POWERDOWN_TIMEOUT = Guid.initString("3c0bc021-c8a8-4e07-a973-6b14cbcb2b7e");
pub const GUID_VIDEO_ANNOYANCE_TIMEOUT = Guid.initString("82dbcf2d-cd67-40c5-bfdc-9f1a5ccd4663");
pub const GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE = Guid.initString("eed904df-b142-4183-b10b-5a1197a37864");
pub const GUID_VIDEO_DIM_TIMEOUT = Guid.initString("17aaa29b-8b43-4b94-aafe-35f64daaf1ee");
pub const GUID_VIDEO_ADAPTIVE_POWERDOWN = Guid.initString("90959d22-d6a1-49b9-af93-bce885ad335b");
pub const GUID_MONITOR_POWER_ON = Guid.initString("02731015-4510-4526-99e6-e5a17ebd1aea");
pub const GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS = Guid.initString("aded5e82-b909-4619-9949-f5d71dac0bcb");
pub const GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS = Guid.initString("f1fbfde2-a960-4165-9f88-50667911ce96");
pub const GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS = Guid.initString("8ffee2c6-2d01-46be-adb9-398addc5b4ff");
pub const GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS = Guid.initString("fbd9aa66-9553-4097-ba44-ed6e9d65eab8");
pub const GUID_CONSOLE_DISPLAY_STATE = Guid.initString("6fe69556-704a-47a0-8f24-c28d936fda47");
pub const GUID_ALLOW_DISPLAY_REQUIRED = Guid.initString("a9ceb8da-cd46-44fb-a98b-02af69de4623");
pub const GUID_VIDEO_CONSOLE_LOCK_TIMEOUT = Guid.initString("8ec4b3a5-6868-48c2-be75-4f3044be88a7");
pub const GUID_ADVANCED_COLOR_QUALITY_BIAS = Guid.initString("684c3e69-a4f7-4014-8754-d45179a56167");
pub const GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP = Guid.initString("8619b916-e004-4dd8-9b66-dae86f806698");
pub const GUID_NON_ADAPTIVE_INPUT_TIMEOUT = Guid.initString("5adbbfbc-074e-4da1-ba38-db8b36b2c8f3");
pub const GUID_ADAPTIVE_INPUT_CONTROLLER_STATE = Guid.initString("0e98fae9-f45a-4de1-a757-6031f197f6ea");
pub const GUID_DISK_SUBGROUP = Guid.initString("0012ee47-9041-4b5d-9b77-535fba8b1442");
pub const GUID_DISK_MAX_POWER = Guid.initString("51dea550-bb38-4bc4-991b-eacf37be5ec8");
pub const GUID_DISK_POWERDOWN_TIMEOUT = Guid.initString("6738e2c4-e8a5-4a42-b16a-e040e769756e");
pub const GUID_DISK_IDLE_TIMEOUT = Guid.initString("58e39ba8-b8e6-4ef6-90d0-89ae32b258d6");
pub const GUID_DISK_BURST_IGNORE_THRESHOLD = Guid.initString("80e3c60e-bb94-4ad8-bbe0-0d3195efc663");
pub const GUID_DISK_ADAPTIVE_POWERDOWN = Guid.initString("396a32e1-499a-40b2-9124-a96afe707667");
pub const GUID_DISK_NVME_NOPPME = Guid.initString("fc7372b6-ab2d-43ee-8797-15e9841f2cca");
pub const GUID_SLEEP_SUBGROUP = Guid.initString("238c9fa8-0aad-41ed-83f4-97be242c8f20");
pub const GUID_SLEEP_IDLE_THRESHOLD = Guid.initString("81cd32e0-7833-44f3-8737-7081f38d1f70");
pub const GUID_STANDBY_TIMEOUT = Guid.initString("29f6c1db-86da-48c5-9fdb-f2b67b1f44da");
pub const GUID_UNATTEND_SLEEP_TIMEOUT = Guid.initString("7bc4a2f9-d8fc-4469-b07b-33eb785aaca0");
pub const GUID_HIBERNATE_TIMEOUT = Guid.initString("9d7815a6-7ee4-497e-8888-515a05f02364");
pub const GUID_HIBERNATE_FASTS4_POLICY = Guid.initString("94ac6d29-73ce-41a6-809f-6363ba21b47e");
pub const GUID_CRITICAL_POWER_TRANSITION = Guid.initString("b7a27025-e569-46c2-a504-2b96cad225a1");
pub const GUID_SYSTEM_AWAYMODE = Guid.initString("98a7f580-01f7-48aa-9c0f-44352c29e5c0");
pub const GUID_ALLOW_AWAYMODE = Guid.initString("25dfa149-5dd1-4736-b5ab-e8a37b5b8187");
pub const GUID_USER_PRESENCE_PREDICTION = Guid.initString("82011705-fb95-4d46-8d35-4042b1d20def");
pub const GUID_STANDBY_BUDGET_GRACE_PERIOD = Guid.initString("60c07fe1-0556-45cf-9903-d56e32210242");
pub const GUID_STANDBY_BUDGET_PERCENT = Guid.initString("9fe527be-1b70-48da-930d-7bcf17b44990");
pub const GUID_STANDBY_RESERVE_GRACE_PERIOD = Guid.initString("c763ee92-71e8-4127-84eb-f6ed043a3e3d");
pub const GUID_STANDBY_RESERVE_TIME = Guid.initString("468fe7e5-1158-46ec-88bc-5b96c9e44fd0");
pub const GUID_STANDBY_RESET_PERCENT = Guid.initString("49cb11a5-56e2-4afb-9d38-3df47872e21b");
pub const GUID_ALLOW_STANDBY_STATES = Guid.initString("abfc2519-3608-4c2a-94ea-171b0ed546ab");
pub const GUID_ALLOW_RTC_WAKE = Guid.initString("bd3b718a-0680-4d9d-8ab2-e1d2b4ac806d");
pub const GUID_LEGACY_RTC_MITIGATION = Guid.initString("1a34bdc3-7e6b-442e-a9d0-64b6ef378e84");
pub const GUID_ALLOW_SYSTEM_REQUIRED = Guid.initString("a4b195f5-8225-47d8-8012-9d41369786e2");
pub const GUID_POWER_SAVING_STATUS = Guid.initString("e00958c0-c213-4ace-ac77-fecced2eeea5");
pub const GUID_ENERGY_SAVER_SUBGROUP = Guid.initString("de830923-a562-41af-a086-e3a2c6bad2da");
pub const GUID_ENERGY_SAVER_BATTERY_THRESHOLD = Guid.initString("e69653ca-cf7f-4f05-aa73-cb833fa90ad4");
pub const GUID_ENERGY_SAVER_BRIGHTNESS = Guid.initString("13d09884-f74e-474a-a852-b6bde8ad03a8");
pub const GUID_ENERGY_SAVER_POLICY = Guid.initString("5c5bb349-ad29-4ee2-9d0b-2b25270f7a81");
pub const GUID_SYSTEM_BUTTON_SUBGROUP = Guid.initString("4f971e89-eebd-4455-a8de-9e59040e7347");
pub const POWERBUTTON_ACTION_INDEX_NOTHING = @as(u32, 0);
pub const POWERBUTTON_ACTION_INDEX_SLEEP = @as(u32, 1);
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE = @as(u32, 2);
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN = @as(u32, 3);
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY = @as(u32, 4);
pub const POWERBUTTON_ACTION_VALUE_NOTHING = @as(u32, 0);
pub const POWERBUTTON_ACTION_VALUE_SLEEP = @as(u32, 2);
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE = @as(u32, 3);
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN = @as(u32, 6);
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY = @as(u32, 8);
pub const GUID_POWERBUTTON_ACTION = Guid.initString("7648efa3-dd9c-4e3e-b566-50f929386280");
pub const GUID_SLEEPBUTTON_ACTION = Guid.initString("96996bc0-ad50-47ec-923b-6f41874dd9eb");
pub const GUID_USERINTERFACEBUTTON_ACTION = Guid.initString("a7066653-8d6c-40a8-910e-a1f54b84c7e5");
pub const GUID_LIDCLOSE_ACTION = Guid.initString("5ca83367-6e45-459f-a27b-476b1d01c936");
pub const GUID_LIDOPEN_POWERSTATE = Guid.initString("99ff10e7-23b1-4c07-a9d1-5c3206d741b4");
pub const GUID_BATTERY_SUBGROUP = Guid.initString("e73a048d-bf27-4f12-9731-8b2076e8891f");
pub const GUID_BATTERY_DISCHARGE_ACTION_0 = Guid.initString("637ea02f-bbcb-4015-8e2c-a1c7b9c0b546");
pub const GUID_BATTERY_DISCHARGE_LEVEL_0 = Guid.initString("9a66d8d7-4ff7-4ef9-b5a2-5a326ca2a469");
pub const GUID_BATTERY_DISCHARGE_FLAGS_0 = Guid.initString("5dbb7c9f-38e9-40d2-9749-4f8a0e9f640f");
pub const GUID_BATTERY_DISCHARGE_ACTION_1 = Guid.initString("d8742dcb-3e6a-4b3c-b3fe-374623cdcf06");
pub const GUID_BATTERY_DISCHARGE_LEVEL_1 = Guid.initString("8183ba9a-e910-48da-8769-14ae6dc1170a");
pub const GUID_BATTERY_DISCHARGE_FLAGS_1 = Guid.initString("bcded951-187b-4d05-bccc-f7e51960c258");
pub const GUID_BATTERY_DISCHARGE_ACTION_2 = Guid.initString("421cba38-1a8e-4881-ac89-e33a8b04ece4");
pub const GUID_BATTERY_DISCHARGE_LEVEL_2 = Guid.initString("07a07ca2-adaf-40d7-b077-533aaded1bfa");
pub const GUID_BATTERY_DISCHARGE_FLAGS_2 = Guid.initString("7fd2f0c4-feb7-4da3-8117-e3fbedc46582");
pub const GUID_BATTERY_DISCHARGE_ACTION_3 = Guid.initString("80472613-9780-455e-b308-72d3003cf2f8");
pub const GUID_BATTERY_DISCHARGE_LEVEL_3 = Guid.initString("58afd5a6-c2dd-47d2-9fbf-ef70cc5c5965");
pub const GUID_BATTERY_DISCHARGE_FLAGS_3 = Guid.initString("73613ccf-dbfa-4279-8356-4935f6bf62f3");
pub const GUID_PROCESSOR_SETTINGS_SUBGROUP = Guid.initString("54533251-82be-4824-96c1-47b60b740d00");
pub const GUID_PROCESSOR_THROTTLE_POLICY = Guid.initString("57027304-4af6-4104-9260-e3d95248fc36");
pub const PERFSTATE_POLICY_CHANGE_IDEAL = @as(u32, 0);
pub const PERFSTATE_POLICY_CHANGE_SINGLE = @as(u32, 1);
pub const PERFSTATE_POLICY_CHANGE_ROCKET = @as(u32, 2);
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE = @as(u32, 3);
pub const GUID_PROCESSOR_THROTTLE_MAXIMUM = Guid.initString("bc5038f7-23e0-4960-96da-33abaf5935ec");
pub const GUID_PROCESSOR_THROTTLE_MAXIMUM_1 = Guid.initString("bc5038f7-23e0-4960-96da-33abaf5935ed");
pub const GUID_PROCESSOR_THROTTLE_MINIMUM = Guid.initString("893dee8e-2bef-41e0-89c6-b55d0929964c");
pub const GUID_PROCESSOR_THROTTLE_MINIMUM_1 = Guid.initString("893dee8e-2bef-41e0-89c6-b55d0929964d");
pub const GUID_PROCESSOR_FREQUENCY_LIMIT = Guid.initString("75b0ae3f-bce0-45a7-8c89-c9611c25e100");
pub const GUID_PROCESSOR_FREQUENCY_LIMIT_1 = Guid.initString("75b0ae3f-bce0-45a7-8c89-c9611c25e101");
pub const GUID_PROCESSOR_ALLOW_THROTTLING = Guid.initString("3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb");
pub const PROCESSOR_THROTTLE_DISABLED = @as(u32, 0);
pub const PROCESSOR_THROTTLE_ENABLED = @as(u32, 1);
pub const PROCESSOR_THROTTLE_AUTOMATIC = @as(u32, 2);
pub const GUID_PROCESSOR_IDLESTATE_POLICY = Guid.initString("68f262a7-f621-4069-b9a5-4874169be23c");
pub const GUID_PROCESSOR_PERFSTATE_POLICY = Guid.initString("bbdc3814-18e9-4463-8a55-d197327c45c0");
pub const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD = Guid.initString("06cadf0e-64ed-448a-8927-ce7bf90eb35d");
pub const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1 = Guid.initString("06cadf0e-64ed-448a-8927-ce7bf90eb35e");
pub const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD = Guid.initString("12a0ab44-fe28-4fa9-b3bd-4b64f44960a6");
pub const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1 = Guid.initString("12a0ab44-fe28-4fa9-b3bd-4b64f44960a7");
pub const GUID_PROCESSOR_PERF_INCREASE_POLICY = Guid.initString("465e1f50-b610-473a-ab58-00d1077dc418");
pub const GUID_PROCESSOR_PERF_INCREASE_POLICY_1 = Guid.initString("465e1f50-b610-473a-ab58-00d1077dc419");
pub const GUID_PROCESSOR_PERF_DECREASE_POLICY = Guid.initString("40fbefc7-2e9d-4d25-a185-0cfd8574bac6");
pub const GUID_PROCESSOR_PERF_DECREASE_POLICY_1 = Guid.initString("40fbefc7-2e9d-4d25-a185-0cfd8574bac7");
pub const GUID_PROCESSOR_PERF_INCREASE_TIME = Guid.initString("984cf492-3bed-4488-a8f9-4286c97bf5aa");
pub const GUID_PROCESSOR_PERF_INCREASE_TIME_1 = Guid.initString("984cf492-3bed-4488-a8f9-4286c97bf5ab");
pub const GUID_PROCESSOR_PERF_DECREASE_TIME = Guid.initString("d8edeb9b-95cf-4f95-a73c-b061973693c8");
pub const GUID_PROCESSOR_PERF_DECREASE_TIME_1 = Guid.initString("d8edeb9b-95cf-4f95-a73c-b061973693c9");
pub const GUID_PROCESSOR_PERF_TIME_CHECK = Guid.initString("4d2b0152-7d5c-498b-88e2-34345392a2c5");
pub const GUID_PROCESSOR_PERF_BOOST_POLICY = Guid.initString("45bcc044-d885-43e2-8605-ee0ec6e96b59");
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED = @as(u32, 0);
pub const PROCESSOR_PERF_BOOST_POLICY_MAX = @as(u32, 100);
pub const GUID_PROCESSOR_PERF_BOOST_MODE = Guid.initString("be337238-0d82-4146-a960-4f3749d470c7");
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED = @as(u32, 0);
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED = @as(u32, 1);
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE = @as(u32, 2);
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED = @as(u32, 3);
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE = @as(u32, 4);
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED = @as(u32, 5);
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED = @as(u32, 6);
pub const GUID_PROCESSOR_PERF_AUTONOMOUS_MODE = Guid.initString("8baa4a8a-14c6-4451-8e8b-14bdbd197537");
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED = @as(u32, 0);
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED = @as(u32, 1);
pub const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE = Guid.initString("36687f9e-e3a5-4dbf-b1dc-15eb381c6863");
pub const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1 = Guid.initString("36687f9e-e3a5-4dbf-b1dc-15eb381c6864");
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE = @as(u32, 255);
pub const PROCESSOR_PERF_ENERGY_PREFERENCE = @as(u32, 0);
pub const GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW = Guid.initString("cfeda3d0-7697-4566-a922-a9086cd49dfa");
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW = @as(u32, 0);
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW = @as(u32, 1270000000);
pub const GUID_PROCESSOR_DUTY_CYCLING = Guid.initString("4e4450b3-6179-4e91-b8f1-5bb9938f81a1");
pub const PROCESSOR_DUTY_CYCLING_DISABLED = @as(u32, 0);
pub const PROCESSOR_DUTY_CYCLING_ENABLED = @as(u32, 1);
pub const GUID_PROCESSOR_IDLE_ALLOW_SCALING = Guid.initString("6c2993b0-8f48-481f-bcc6-00dd2742aa06");
pub const GUID_PROCESSOR_IDLE_DISABLE = Guid.initString("5d76a2ca-e8c0-402f-a133-2158492d58ad");
pub const GUID_PROCESSOR_IDLE_STATE_MAXIMUM = Guid.initString("9943e905-9a30-4ec1-9b99-44dd3b76f7a2");
pub const GUID_PROCESSOR_IDLE_TIME_CHECK = Guid.initString("c4581c31-89ab-4597-8e2b-9c9cab440e6b");
pub const GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD = Guid.initString("4b92d758-5a24-4851-a470-815d78aee119");
pub const GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD = Guid.initString("7b224883-b3cc-4d79-819f-8374152cbe7c");
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD = Guid.initString("df142941-20f3-4edf-9a4a-9c83d3d717d1");
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD = Guid.initString("68dd2f27-a4ce-4e11-8487-3794e4135dfa");
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY = Guid.initString("c7be0679-2817-4d69-9d02-519a537ed0c6");
pub const CORE_PARKING_POLICY_CHANGE_IDEAL = @as(u32, 0);
pub const CORE_PARKING_POLICY_CHANGE_SINGLE = @as(u32, 1);
pub const CORE_PARKING_POLICY_CHANGE_ROCKET = @as(u32, 2);
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP = @as(u32, 3);
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY = Guid.initString("71021b41-c749-4d21-be74-a00f335d582b");
pub const GUID_PROCESSOR_CORE_PARKING_MAX_CORES = Guid.initString("ea062031-0e34-4ff1-9b6d-eb1059334028");
pub const GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1 = Guid.initString("ea062031-0e34-4ff1-9b6d-eb1059334029");
pub const GUID_PROCESSOR_CORE_PARKING_MIN_CORES = Guid.initString("0cc5b647-c1df-4637-891a-dec35c318583");
pub const GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1 = Guid.initString("0cc5b647-c1df-4637-891a-dec35c318584");
pub const GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME = Guid.initString("2ddd5a84-5a71-437e-912a-db0b8c788732");
pub const GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME = Guid.initString("dfd10d17-d5eb-45dd-877a-9a34ddd15c82");
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR = Guid.initString("8f7b45e3-c393-480a-878c-f67ac3d07082");
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD = Guid.initString("5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9");
pub const GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING = Guid.initString("e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20");
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR = Guid.initString("1299023c-bc28-4f0a-81ec-d3295a8d815d");
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD = Guid.initString("9ac18e92-aa3c-4e27-b307-01ae37307129");
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING = Guid.initString("8809c2d8-b155-42d4-bcda-0d345651b1db");
pub const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD = Guid.initString("943c8cb6-6f93-4227-ad87-e9a3feec08d1");
pub const GUID_PROCESSOR_PARKING_CORE_OVERRIDE = Guid.initString("a55612aa-f624-42c6-a443-7397d064c04f");
pub const GUID_PROCESSOR_PARKING_PERF_STATE = Guid.initString("447235c7-6a8d-4cc0-8e24-9eaf70b96e2b");
pub const GUID_PROCESSOR_PARKING_PERF_STATE_1 = Guid.initString("447235c7-6a8d-4cc0-8e24-9eaf70b96e2c");
pub const GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD = Guid.initString("2430ab6f-a520-44a2-9601-f7f23b5134b1");
pub const GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD = Guid.initString("f735a673-2066-4f80-a0c5-ddee0cf1bf5d");
pub const GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD = Guid.initString("4bdaf4e9-d103-46d7-a5f0-6280121616ef");
pub const GUID_PROCESSOR_SOFT_PARKING_LATENCY = Guid.initString("97cfac41-2217-47eb-992d-618b1977c907");
pub const GUID_PROCESSOR_PERF_HISTORY = Guid.initString("7d24baa7-0b84-480f-840c-1b0743c00f5f");
pub const GUID_PROCESSOR_PERF_HISTORY_1 = Guid.initString("7d24baa7-0b84-480f-840c-1b0743c00f60");
pub const GUID_PROCESSOR_PERF_INCREASE_HISTORY = Guid.initString("99b3ef01-752f-46a1-80fb-7730011f2354");
pub const GUID_PROCESSOR_PERF_DECREASE_HISTORY = Guid.initString("0300f6f8-abd6-45a9-b74f-4908691a40b5");
pub const GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY = Guid.initString("77d7f282-8f1a-42cd-8537-45450a839be8");
pub const GUID_PROCESSOR_PERF_LATENCY_HINT = Guid.initString("0822df31-9c83-441c-a079-0de4cf009c7b");
pub const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF = Guid.initString("619b7505-003b-4e82-b7a6-4dd29c300971");
pub const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1 = Guid.initString("619b7505-003b-4e82-b7a6-4dd29c300972");
pub const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK = Guid.initString("616cdaa5-695e-4545-97ad-97dc2d1bdd88");
pub const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1 = Guid.initString("616cdaa5-695e-4545-97ad-97dc2d1bdd89");
pub const GUID_PROCESSOR_DISTRIBUTE_UTILITY = Guid.initString("e0007330-f589-42ed-a401-5ddb10e785d3");
pub const GUID_PROCESSOR_HETEROGENEOUS_POLICY = Guid.initString("7f2f5cfa-f10c-4823-b5e1-e93ae85f46b5");
pub const GUID_PROCESSOR_HETERO_DECREASE_TIME = Guid.initString("7f2492b6-60b1-45e5-ae55-773f8cd5caec");
pub const GUID_PROCESSOR_HETERO_INCREASE_TIME = Guid.initString("4009efa7-e72d-4cba-9edf-91084ea8cbc3");
pub const GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD = Guid.initString("f8861c27-95e7-475c-865b-13c0cb3f9d6b");
pub const GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD = Guid.initString("b000397d-9b0b-483d-98c9-692a6060cfbf");
pub const GUID_PROCESSOR_CLASS0_FLOOR_PERF = Guid.initString("fddc842b-8364-4edc-94cf-c17f60de1c80");
pub const GUID_PROCESSOR_CLASS1_INITIAL_PERF = Guid.initString("1facfc65-a930-4bc5-9f38-504ec097bbc0");
pub const GUID_PROCESSOR_THREAD_SCHEDULING_POLICY = Guid.initString("93b8b6dc-0698-4d1c-9ee4-0644e900c85d");
pub const GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY = Guid.initString("bae08b81-2d5e-4688-ad6a-13243356654b");
pub const GUID_SYSTEM_COOLING_POLICY = Guid.initString("94d3a615-a899-4ac5-ae2b-e4d8f634367f");
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD = Guid.initString("38b8383d-cce0-4c79-9e3e-56a4f17cc480");
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1 = Guid.initString("38b8383d-cce0-4c79-9e3e-56a4f17cc481");
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD = Guid.initString("3d44e256-7222-4415-a9ed-9c45fa3dd830");
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1 = Guid.initString("3d44e256-7222-4415-a9ed-9c45fa3dd831");
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME = Guid.initString("f565999f-3fb0-411a-a226-3f0198dec130");
pub const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1 = Guid.initString("f565999f-3fb0-411a-a226-3f0198dec131");
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME = Guid.initString("3d915188-7830-49ae-a79a-0fb0a1e5a200");
pub const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1 = Guid.initString("3d915188-7830-49ae-a79a-0fb0a1e5a201");
pub const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING = Guid.initString("4427c73b-9756-4a5c-b84b-c7bda79c7320");
pub const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1 = Guid.initString("4427c73b-9756-4a5c-b84b-c7bda79c7321");
pub const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR = Guid.initString("ce8e92ee-6a86-4572-bfe0-20c21d03cd40");
pub const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1 = Guid.initString("ce8e92ee-6a86-4572-bfe0-20c21d03cd41");
pub const GUID_LOCK_CONSOLE_ON_WAKE = Guid.initString("0e796bdb-100d-47d6-a2d5-f7d2daa51f51");
pub const GUID_DEVICE_IDLE_POLICY = Guid.initString("4faab71a-92e5-4726-b531-224559672d19");
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE = @as(u32, 0);
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE = @as(u32, 1);
pub const GUID_CONNECTIVITY_IN_STANDBY = Guid.initString("f15576e8-98b7-4186-b944-eafa664402d9");
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED = @as(u32, 0);
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED = @as(u32, 1);
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED = @as(u32, 2);
pub const GUID_DISCONNECTED_STANDBY_MODE = Guid.initString("68afb2d9-ee95-47a8-8f50-4115088073b1");
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL = @as(u32, 0);
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE = @as(u32, 1);
pub const GUID_ACDC_POWER_SOURCE = Guid.initString("5d3e9a59-e9d5-4b00-a6bd-ff34ff516548");
pub const GUID_LIDSWITCH_STATE_CHANGE = Guid.initString("ba3e0f4d-b817-4094-a2d1-d56379e6a0f3");
pub const GUID_BATTERY_PERCENTAGE_REMAINING = Guid.initString("a7ad8041-b45a-4cae-87a3-eecbb468a9e1");
pub const GUID_BATTERY_COUNT = Guid.initString("7d263f15-fca4-49e5-854b-a9f2bfbd5c24");
pub const GUID_GLOBAL_USER_PRESENCE = Guid.initString("786e8a1d-b427-4344-9207-09e70bdcbea9");
pub const GUID_SESSION_DISPLAY_STATUS = Guid.initString("2b84c20e-ad23-4ddf-93db-05ffbd7efca5");
pub const GUID_SESSION_USER_PRESENCE = Guid.initString("3c0f4548-c03f-4c4d-b9f2-237ede686376");
pub const GUID_IDLE_BACKGROUND_TASK = Guid.initString("515c31d8-f734-163d-a0fd-11a08c91e8f1");
pub const GUID_BACKGROUND_TASK_NOTIFICATION = Guid.initString("cf23f240-2a54-48d8-b114-de1518ff052e");
pub const GUID_APPLAUNCH_BUTTON = Guid.initString("1a689231-7399-4e9a-8f99-b71f999db3fa");
pub const GUID_PCIEXPRESS_SETTINGS_SUBGROUP = Guid.initString("501a4d13-42af-4429-9fd1-a8218c268e20");
pub const GUID_PCIEXPRESS_ASPM_POLICY = Guid.initString("ee12f906-d277-404b-b6da-e5fa1a576df5");
pub const GUID_ENABLE_SWITCH_FORCED_SHUTDOWN = Guid.initString("833a6b62-dfa4-46d1-82f8-e09e34d029d6");
pub const GUID_INTSTEER_SUBGROUP = Guid.initString("48672f38-7a9a-4bb2-8bf8-3d85be19de4e");
pub const GUID_INTSTEER_MODE = Guid.initString("2bfc24f9-5ea2-4801-8213-3dbae01aa39d");
pub const GUID_INTSTEER_LOAD_PER_PROC_TRIGGER = Guid.initString("73cde64d-d720-4bb2-a860-c755afe77ef2");
pub const GUID_INTSTEER_TIME_UNPARK_TRIGGER = Guid.initString("d6ba4903-386f-4c2c-8adb-5c21b3328d25");
pub const GUID_GRAPHICS_SUBGROUP = Guid.initString("5fb4938d-1ee8-4b0f-9a3c-5036b0ab995c");
pub const GUID_GPU_PREFERENCE_POLICY = Guid.initString("dd848b2a-8a5d-4451-9ae2-39cd41658f6c");
pub const GUID_MIXED_REALITY_MODE = Guid.initString("1e626b4e-cf04-4f8d-9cc7-c97c5b0f2391");
pub const GUID_SPR_ACTIVE_SESSION_CHANGE = Guid.initString("0e24ce38-c393-4742-bdb1-744f4b9ee08e");
pub const POWER_SYSTEM_MAXIMUM = @as(u32, 7);
pub const DIAGNOSTIC_REASON_VERSION = @as(u32, 0);
pub const DIAGNOSTIC_REASON_SIMPLE_STRING = @as(u32, 1);
pub const DIAGNOSTIC_REASON_DETAILED_STRING = @as(u32, 2);
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED = @as(u32, 2147483648);
pub const PDCAP_D0_SUPPORTED = @as(u32, 1);
pub const PDCAP_D1_SUPPORTED = @as(u32, 2);
pub const PDCAP_D2_SUPPORTED = @as(u32, 4);
pub const PDCAP_D3_SUPPORTED = @as(u32, 8);
pub const PDCAP_WAKE_FROM_D0_SUPPORTED = @as(u32, 16);
pub const PDCAP_WAKE_FROM_D1_SUPPORTED = @as(u32, 32);
pub const PDCAP_WAKE_FROM_D2_SUPPORTED = @as(u32, 64);
pub const PDCAP_WAKE_FROM_D3_SUPPORTED = @as(u32, 128);
pub const PDCAP_WARM_EJECT_SUPPORTED = @as(u32, 256);
pub const POWER_SETTING_VALUE_VERSION = @as(u32, 1);
pub const PROC_IDLE_BUCKET_COUNT = @as(u32, 6);
pub const PROC_IDLE_BUCKET_COUNT_EX = @as(u32, 16);
pub const ACPI_PPM_SOFTWARE_ALL = @as(u32, 252);
pub const ACPI_PPM_SOFTWARE_ANY = @as(u32, 253);
pub const ACPI_PPM_HARDWARE_ALL = @as(u32, 254);
pub const MS_PPM_SOFTWARE_ALL = @as(u32, 1);
pub const PPM_FIRMWARE_ACPI1C2 = @as(u32, 1);
pub const PPM_FIRMWARE_ACPI1C3 = @as(u32, 2);
pub const PPM_FIRMWARE_ACPI1TSTATES = @as(u32, 4);
pub const PPM_FIRMWARE_CST = @as(u32, 8);
pub const PPM_FIRMWARE_CSD = @as(u32, 16);
pub const PPM_FIRMWARE_PCT = @as(u32, 32);
pub const PPM_FIRMWARE_PSS = @as(u32, 64);
pub const PPM_FIRMWARE_XPSS = @as(u32, 128);
pub const PPM_FIRMWARE_PPC = @as(u32, 256);
pub const PPM_FIRMWARE_PSD = @as(u32, 512);
pub const PPM_FIRMWARE_PTC = @as(u32, 1024);
pub const PPM_FIRMWARE_TSS = @as(u32, 2048);
pub const PPM_FIRMWARE_TPC = @as(u32, 4096);
pub const PPM_FIRMWARE_TSD = @as(u32, 8192);
pub const PPM_FIRMWARE_PCCH = @as(u32, 16384);
pub const PPM_FIRMWARE_PCCP = @as(u32, 32768);
pub const PPM_FIRMWARE_OSC = @as(u32, 65536);
pub const PPM_FIRMWARE_PDC = @as(u32, 131072);
pub const PPM_FIRMWARE_CPC = @as(u32, 262144);
pub const PPM_FIRMWARE_LPI = @as(u32, 524288);
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE = @as(u32, 0);
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES = @as(u32, 1);
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1 = @as(u32, 2);
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC = @as(u32, 3);
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP = @as(u32, 4);
pub const PPM_IDLE_IMPLEMENTATION_NONE = @as(u32, 0);
pub const PPM_IDLE_IMPLEMENTATION_CSTATES = @as(u32, 1);
pub const PPM_IDLE_IMPLEMENTATION_PEP = @as(u32, 2);
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP = @as(u32, 3);
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES = @as(u32, 4);
pub const PPM_PERFSTATE_CHANGE_GUID = Guid.initString("a5b32ddd-7f39-4abc-b892-900e43b59ebb");
pub const PPM_PERFSTATE_DOMAIN_CHANGE_GUID = Guid.initString("995e6b7f-d653-497a-b978-36a30c29bf01");
pub const PPM_IDLESTATE_CHANGE_GUID = Guid.initString("4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c");
pub const PPM_PERFSTATES_DATA_GUID = Guid.initString("5708cc20-7d40-4bf4-b4aa-2b01338d0126");
pub const PPM_IDLESTATES_DATA_GUID = Guid.initString("ba138e10-e250-4ad7-8616-cf1a7ad410e7");
pub const PPM_IDLE_ACCOUNTING_GUID = Guid.initString("e2a26f78-ae07-4ee0-a30f-ce54f55a94cd");
pub const PPM_IDLE_ACCOUNTING_EX_GUID = Guid.initString("d67abd39-81f8-4a5e-8152-72e31ec912ee");
pub const PPM_THERMALCONSTRAINT_GUID = Guid.initString("a852c2c8-1a4c-423b-8c2c-f30d82931a88");
pub const PPM_PERFMON_PERFSTATE_GUID = Guid.initString("7fd18652-0cfe-40d2-b0a1-0b066a87759e");
pub const PPM_THERMAL_POLICY_CHANGE_GUID = Guid.initString("48f377b8-6880-4c7b-8bdc-380176c6654d");
pub const POWER_ACTION_QUERY_ALLOWED = @as(u32, 1);
pub const POWER_ACTION_UI_ALLOWED = @as(u32, 2);
pub const POWER_ACTION_OVERRIDE_APPS = @as(u32, 4);
pub const POWER_ACTION_HIBERBOOT = @as(u32, 8);
pub const POWER_ACTION_USER_NOTIFY = @as(u32, 16);
pub const POWER_ACTION_DOZE_TO_HIBERNATE = @as(u32, 32);
pub const POWER_ACTION_ACPI_CRITICAL = @as(u32, 16777216);
pub const POWER_ACTION_ACPI_USER_NOTIFY = @as(u32, 33554432);
pub const POWER_ACTION_DIRECTED_DRIPS = @as(u32, 67108864);
pub const POWER_ACTION_PSEUDO_TRANSITION = @as(u32, 134217728);
pub const POWER_ACTION_LIGHTEST_FIRST = @as(u32, 268435456);
pub const POWER_ACTION_LOCK_CONSOLE = @as(u32, 536870912);
pub const POWER_ACTION_DISABLE_WAKES = @as(u32, 1073741824);
pub const POWER_ACTION_CRITICAL = @as(u32, 2147483648);
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN = @as(u32, 32);
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK = @as(u32, 7);
pub const BATTERY_DISCHARGE_FLAGS_ENABLE = @as(u32, 2147483648);
pub const NUM_DISCHARGE_POLICIES = @as(u32, 4);
pub const DISCHARGE_POLICY_CRITICAL = @as(u32, 0);
pub const DISCHARGE_POLICY_LOW = @as(u32, 1);
pub const PROCESSOR_IDLESTATE_POLICY_COUNT = @as(u32, 3);
pub const PO_THROTTLE_NONE = @as(u32, 0);
pub const PO_THROTTLE_CONSTANT = @as(u32, 1);
pub const PO_THROTTLE_DEGRADE = @as(u32, 2);
pub const PO_THROTTLE_ADAPTIVE = @as(u32, 3);
pub const PO_THROTTLE_MAXIMUM = @as(u32, 4);
pub const HIBERFILE_TYPE_NONE = @as(u32, 0);
pub const HIBERFILE_TYPE_REDUCED = @as(u32, 1);
pub const HIBERFILE_TYPE_FULL = @as(u32, 2);
pub const HIBERFILE_TYPE_MAX = @as(u32, 3);
pub const IMAGE_DOS_SIGNATURE = @as(u32, 23117);
pub const IMAGE_OS2_SIGNATURE = @as(u32, 17742);
pub const IMAGE_OS2_SIGNATURE_LE = @as(u32, 17740);
pub const IMAGE_VXD_SIGNATURE = @as(u32, 17740);
pub const IMAGE_NT_SIGNATURE = @as(u32, 17744);
pub const IMAGE_SIZEOF_FILE_HEADER = @as(u32, 20);
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES = @as(u32, 16);
pub const IMAGE_SIZEOF_SHORT_NAME = @as(u32, 8);
pub const IMAGE_SIZEOF_SECTION_HEADER = @as(u32, 40);
pub const IMAGE_SIZEOF_SYMBOL = @as(u32, 18);
pub const IMAGE_SYM_SECTION_MAX = @as(u32, 65279);
pub const IMAGE_SYM_TYPE_NULL = @as(u32, 0);
pub const IMAGE_SYM_TYPE_VOID = @as(u32, 1);
pub const IMAGE_SYM_TYPE_CHAR = @as(u32, 2);
pub const IMAGE_SYM_TYPE_SHORT = @as(u32, 3);
pub const IMAGE_SYM_TYPE_INT = @as(u32, 4);
pub const IMAGE_SYM_TYPE_LONG = @as(u32, 5);
pub const IMAGE_SYM_TYPE_FLOAT = @as(u32, 6);
pub const IMAGE_SYM_TYPE_DOUBLE = @as(u32, 7);
pub const IMAGE_SYM_TYPE_STRUCT = @as(u32, 8);
pub const IMAGE_SYM_TYPE_UNION = @as(u32, 9);
pub const IMAGE_SYM_TYPE_ENUM = @as(u32, 10);
pub const IMAGE_SYM_TYPE_MOE = @as(u32, 11);
pub const IMAGE_SYM_TYPE_BYTE = @as(u32, 12);
pub const IMAGE_SYM_TYPE_WORD = @as(u32, 13);
pub const IMAGE_SYM_TYPE_UINT = @as(u32, 14);
pub const IMAGE_SYM_TYPE_DWORD = @as(u32, 15);
pub const IMAGE_SYM_TYPE_PCODE = @as(u32, 32768);
pub const IMAGE_SYM_DTYPE_NULL = @as(u32, 0);
pub const IMAGE_SYM_DTYPE_POINTER = @as(u32, 1);
pub const IMAGE_SYM_DTYPE_FUNCTION = @as(u32, 2);
pub const IMAGE_SYM_DTYPE_ARRAY = @as(u32, 3);
pub const IMAGE_SYM_CLASS_NULL = @as(u32, 0);
pub const IMAGE_SYM_CLASS_AUTOMATIC = @as(u32, 1);
pub const IMAGE_SYM_CLASS_EXTERNAL = @as(u32, 2);
pub const IMAGE_SYM_CLASS_STATIC = @as(u32, 3);
pub const IMAGE_SYM_CLASS_REGISTER = @as(u32, 4);
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF = @as(u32, 5);
pub const IMAGE_SYM_CLASS_LABEL = @as(u32, 6);
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL = @as(u32, 7);
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = @as(u32, 8);
pub const IMAGE_SYM_CLASS_ARGUMENT = @as(u32, 9);
pub const IMAGE_SYM_CLASS_STRUCT_TAG = @as(u32, 10);
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION = @as(u32, 11);
pub const IMAGE_SYM_CLASS_UNION_TAG = @as(u32, 12);
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION = @as(u32, 13);
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC = @as(u32, 14);
pub const IMAGE_SYM_CLASS_ENUM_TAG = @as(u32, 15);
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM = @as(u32, 16);
pub const IMAGE_SYM_CLASS_REGISTER_PARAM = @as(u32, 17);
pub const IMAGE_SYM_CLASS_BIT_FIELD = @as(u32, 18);
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL = @as(u32, 68);
pub const IMAGE_SYM_CLASS_BLOCK = @as(u32, 100);
pub const IMAGE_SYM_CLASS_FUNCTION = @as(u32, 101);
pub const IMAGE_SYM_CLASS_END_OF_STRUCT = @as(u32, 102);
pub const IMAGE_SYM_CLASS_FILE = @as(u32, 103);
pub const IMAGE_SYM_CLASS_SECTION = @as(u32, 104);
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL = @as(u32, 105);
pub const IMAGE_SYM_CLASS_CLR_TOKEN = @as(u32, 107);
pub const N_BTMASK = @as(u32, 15);
pub const N_TMASK = @as(u32, 48);
pub const N_TMASK1 = @as(u32, 192);
pub const N_TMASK2 = @as(u32, 240);
pub const N_BTSHFT = @as(u32, 4);
pub const N_TSHIFT = @as(u32, 2);
pub const IMAGE_COMDAT_SELECT_NODUPLICATES = @as(u32, 1);
pub const IMAGE_COMDAT_SELECT_ANY = @as(u32, 2);
pub const IMAGE_COMDAT_SELECT_SAME_SIZE = @as(u32, 3);
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH = @as(u32, 4);
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE = @as(u32, 5);
pub const IMAGE_COMDAT_SELECT_LARGEST = @as(u32, 6);
pub const IMAGE_COMDAT_SELECT_NEWEST = @as(u32, 7);
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = @as(u32, 1);
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = @as(u32, 2);
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS = @as(u32, 3);
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY = @as(u32, 4);
pub const IMAGE_REL_I386_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_I386_DIR16 = @as(u32, 1);
pub const IMAGE_REL_I386_REL16 = @as(u32, 2);
pub const IMAGE_REL_I386_DIR32 = @as(u32, 6);
pub const IMAGE_REL_I386_DIR32NB = @as(u32, 7);
pub const IMAGE_REL_I386_SEG12 = @as(u32, 9);
pub const IMAGE_REL_I386_SECTION = @as(u32, 10);
pub const IMAGE_REL_I386_SECREL = @as(u32, 11);
pub const IMAGE_REL_I386_TOKEN = @as(u32, 12);
pub const IMAGE_REL_I386_SECREL7 = @as(u32, 13);
pub const IMAGE_REL_I386_REL32 = @as(u32, 20);
pub const IMAGE_REL_MIPS_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_MIPS_REFHALF = @as(u32, 1);
pub const IMAGE_REL_MIPS_REFWORD = @as(u32, 2);
pub const IMAGE_REL_MIPS_JMPADDR = @as(u32, 3);
pub const IMAGE_REL_MIPS_REFHI = @as(u32, 4);
pub const IMAGE_REL_MIPS_REFLO = @as(u32, 5);
pub const IMAGE_REL_MIPS_GPREL = @as(u32, 6);
pub const IMAGE_REL_MIPS_LITERAL = @as(u32, 7);
pub const IMAGE_REL_MIPS_SECTION = @as(u32, 10);
pub const IMAGE_REL_MIPS_SECREL = @as(u32, 11);
pub const IMAGE_REL_MIPS_SECRELLO = @as(u32, 12);
pub const IMAGE_REL_MIPS_SECRELHI = @as(u32, 13);
pub const IMAGE_REL_MIPS_TOKEN = @as(u32, 14);
pub const IMAGE_REL_MIPS_JMPADDR16 = @as(u32, 16);
pub const IMAGE_REL_MIPS_REFWORDNB = @as(u32, 34);
pub const IMAGE_REL_MIPS_PAIR = @as(u32, 37);
pub const IMAGE_REL_ALPHA_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_ALPHA_REFLONG = @as(u32, 1);
pub const IMAGE_REL_ALPHA_REFQUAD = @as(u32, 2);
pub const IMAGE_REL_ALPHA_GPREL32 = @as(u32, 3);
pub const IMAGE_REL_ALPHA_LITERAL = @as(u32, 4);
pub const IMAGE_REL_ALPHA_LITUSE = @as(u32, 5);
pub const IMAGE_REL_ALPHA_GPDISP = @as(u32, 6);
pub const IMAGE_REL_ALPHA_BRADDR = @as(u32, 7);
pub const IMAGE_REL_ALPHA_HINT = @as(u32, 8);
pub const IMAGE_REL_ALPHA_INLINE_REFLONG = @as(u32, 9);
pub const IMAGE_REL_ALPHA_REFHI = @as(u32, 10);
pub const IMAGE_REL_ALPHA_REFLO = @as(u32, 11);
pub const IMAGE_REL_ALPHA_PAIR = @as(u32, 12);
pub const IMAGE_REL_ALPHA_MATCH = @as(u32, 13);
pub const IMAGE_REL_ALPHA_SECTION = @as(u32, 14);
pub const IMAGE_REL_ALPHA_SECREL = @as(u32, 15);
pub const IMAGE_REL_ALPHA_REFLONGNB = @as(u32, 16);
pub const IMAGE_REL_ALPHA_SECRELLO = @as(u32, 17);
pub const IMAGE_REL_ALPHA_SECRELHI = @as(u32, 18);
pub const IMAGE_REL_ALPHA_REFQ3 = @as(u32, 19);
pub const IMAGE_REL_ALPHA_REFQ2 = @as(u32, 20);
pub const IMAGE_REL_ALPHA_REFQ1 = @as(u32, 21);
pub const IMAGE_REL_ALPHA_GPRELLO = @as(u32, 22);
pub const IMAGE_REL_ALPHA_GPRELHI = @as(u32, 23);
pub const IMAGE_REL_PPC_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_PPC_ADDR64 = @as(u32, 1);
pub const IMAGE_REL_PPC_ADDR32 = @as(u32, 2);
pub const IMAGE_REL_PPC_ADDR24 = @as(u32, 3);
pub const IMAGE_REL_PPC_ADDR16 = @as(u32, 4);
pub const IMAGE_REL_PPC_ADDR14 = @as(u32, 5);
pub const IMAGE_REL_PPC_REL24 = @as(u32, 6);
pub const IMAGE_REL_PPC_REL14 = @as(u32, 7);
pub const IMAGE_REL_PPC_TOCREL16 = @as(u32, 8);
pub const IMAGE_REL_PPC_TOCREL14 = @as(u32, 9);
pub const IMAGE_REL_PPC_ADDR32NB = @as(u32, 10);
pub const IMAGE_REL_PPC_SECREL = @as(u32, 11);
pub const IMAGE_REL_PPC_SECTION = @as(u32, 12);
pub const IMAGE_REL_PPC_IFGLUE = @as(u32, 13);
pub const IMAGE_REL_PPC_IMGLUE = @as(u32, 14);
pub const IMAGE_REL_PPC_SECREL16 = @as(u32, 15);
pub const IMAGE_REL_PPC_REFHI = @as(u32, 16);
pub const IMAGE_REL_PPC_REFLO = @as(u32, 17);
pub const IMAGE_REL_PPC_PAIR = @as(u32, 18);
pub const IMAGE_REL_PPC_SECRELLO = @as(u32, 19);
pub const IMAGE_REL_PPC_SECRELHI = @as(u32, 20);
pub const IMAGE_REL_PPC_GPREL = @as(u32, 21);
pub const IMAGE_REL_PPC_TOKEN = @as(u32, 22);
pub const IMAGE_REL_PPC_TYPEMASK = @as(u32, 255);
pub const IMAGE_REL_PPC_NEG = @as(u32, 256);
pub const IMAGE_REL_PPC_BRTAKEN = @as(u32, 512);
pub const IMAGE_REL_PPC_BRNTAKEN = @as(u32, 1024);
pub const IMAGE_REL_PPC_TOCDEFN = @as(u32, 2048);
pub const IMAGE_REL_SH3_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_SH3_DIRECT16 = @as(u32, 1);
pub const IMAGE_REL_SH3_DIRECT32 = @as(u32, 2);
pub const IMAGE_REL_SH3_DIRECT8 = @as(u32, 3);
pub const IMAGE_REL_SH3_DIRECT8_WORD = @as(u32, 4);
pub const IMAGE_REL_SH3_DIRECT8_LONG = @as(u32, 5);
pub const IMAGE_REL_SH3_DIRECT4 = @as(u32, 6);
pub const IMAGE_REL_SH3_DIRECT4_WORD = @as(u32, 7);
pub const IMAGE_REL_SH3_DIRECT4_LONG = @as(u32, 8);
pub const IMAGE_REL_SH3_PCREL8_WORD = @as(u32, 9);
pub const IMAGE_REL_SH3_PCREL8_LONG = @as(u32, 10);
pub const IMAGE_REL_SH3_PCREL12_WORD = @as(u32, 11);
pub const IMAGE_REL_SH3_STARTOF_SECTION = @as(u32, 12);
pub const IMAGE_REL_SH3_SIZEOF_SECTION = @as(u32, 13);
pub const IMAGE_REL_SH3_SECTION = @as(u32, 14);
pub const IMAGE_REL_SH3_SECREL = @as(u32, 15);
pub const IMAGE_REL_SH3_DIRECT32_NB = @as(u32, 16);
pub const IMAGE_REL_SH3_GPREL4_LONG = @as(u32, 17);
pub const IMAGE_REL_SH3_TOKEN = @as(u32, 18);
pub const IMAGE_REL_SHM_PCRELPT = @as(u32, 19);
pub const IMAGE_REL_SHM_REFLO = @as(u32, 20);
pub const IMAGE_REL_SHM_REFHALF = @as(u32, 21);
pub const IMAGE_REL_SHM_RELLO = @as(u32, 22);
pub const IMAGE_REL_SHM_RELHALF = @as(u32, 23);
pub const IMAGE_REL_SHM_PAIR = @as(u32, 24);
pub const IMAGE_REL_SH_NOMODE = @as(u32, 32768);
pub const IMAGE_REL_ARM_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_ARM_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_ARM_ADDR32NB = @as(u32, 2);
pub const IMAGE_REL_ARM_BRANCH24 = @as(u32, 3);
pub const IMAGE_REL_ARM_BRANCH11 = @as(u32, 4);
pub const IMAGE_REL_ARM_TOKEN = @as(u32, 5);
pub const IMAGE_REL_ARM_GPREL12 = @as(u32, 6);
pub const IMAGE_REL_ARM_GPREL7 = @as(u32, 7);
pub const IMAGE_REL_ARM_BLX24 = @as(u32, 8);
pub const IMAGE_REL_ARM_BLX11 = @as(u32, 9);
pub const IMAGE_REL_ARM_SECTION = @as(u32, 14);
pub const IMAGE_REL_ARM_SECREL = @as(u32, 15);
pub const IMAGE_REL_ARM_MOV32A = @as(u32, 16);
pub const IMAGE_REL_ARM_MOV32 = @as(u32, 16);
pub const IMAGE_REL_ARM_MOV32T = @as(u32, 17);
pub const IMAGE_REL_THUMB_MOV32 = @as(u32, 17);
pub const IMAGE_REL_ARM_BRANCH20T = @as(u32, 18);
pub const IMAGE_REL_THUMB_BRANCH20 = @as(u32, 18);
pub const IMAGE_REL_ARM_BRANCH24T = @as(u32, 20);
pub const IMAGE_REL_THUMB_BRANCH24 = @as(u32, 20);
pub const IMAGE_REL_ARM_BLX23T = @as(u32, 21);
pub const IMAGE_REL_THUMB_BLX23 = @as(u32, 21);
pub const IMAGE_REL_AM_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_AM_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_AM_ADDR32NB = @as(u32, 2);
pub const IMAGE_REL_AM_CALL32 = @as(u32, 3);
pub const IMAGE_REL_AM_FUNCINFO = @as(u32, 4);
pub const IMAGE_REL_AM_REL32_1 = @as(u32, 5);
pub const IMAGE_REL_AM_REL32_2 = @as(u32, 6);
pub const IMAGE_REL_AM_SECREL = @as(u32, 7);
pub const IMAGE_REL_AM_SECTION = @as(u32, 8);
pub const IMAGE_REL_AM_TOKEN = @as(u32, 9);
pub const IMAGE_REL_ARM64_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_ARM64_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_ARM64_ADDR32NB = @as(u32, 2);
pub const IMAGE_REL_ARM64_BRANCH26 = @as(u32, 3);
pub const IMAGE_REL_ARM64_PAGEBASE_REL21 = @as(u32, 4);
pub const IMAGE_REL_ARM64_REL21 = @as(u32, 5);
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A = @as(u32, 6);
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L = @as(u32, 7);
pub const IMAGE_REL_ARM64_SECREL = @as(u32, 8);
pub const IMAGE_REL_ARM64_SECREL_LOW12A = @as(u32, 9);
pub const IMAGE_REL_ARM64_SECREL_HIGH12A = @as(u32, 10);
pub const IMAGE_REL_ARM64_SECREL_LOW12L = @as(u32, 11);
pub const IMAGE_REL_ARM64_TOKEN = @as(u32, 12);
pub const IMAGE_REL_ARM64_SECTION = @as(u32, 13);
pub const IMAGE_REL_ARM64_ADDR64 = @as(u32, 14);
pub const IMAGE_REL_ARM64_BRANCH19 = @as(u32, 15);
pub const IMAGE_REL_AMD64_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_AMD64_ADDR64 = @as(u32, 1);
pub const IMAGE_REL_AMD64_ADDR32 = @as(u32, 2);
pub const IMAGE_REL_AMD64_ADDR32NB = @as(u32, 3);
pub const IMAGE_REL_AMD64_REL32 = @as(u32, 4);
pub const IMAGE_REL_AMD64_REL32_1 = @as(u32, 5);
pub const IMAGE_REL_AMD64_REL32_2 = @as(u32, 6);
pub const IMAGE_REL_AMD64_REL32_3 = @as(u32, 7);
pub const IMAGE_REL_AMD64_REL32_4 = @as(u32, 8);
pub const IMAGE_REL_AMD64_REL32_5 = @as(u32, 9);
pub const IMAGE_REL_AMD64_SECTION = @as(u32, 10);
pub const IMAGE_REL_AMD64_SECREL = @as(u32, 11);
pub const IMAGE_REL_AMD64_SECREL7 = @as(u32, 12);
pub const IMAGE_REL_AMD64_TOKEN = @as(u32, 13);
pub const IMAGE_REL_AMD64_SREL32 = @as(u32, 14);
pub const IMAGE_REL_AMD64_PAIR = @as(u32, 15);
pub const IMAGE_REL_AMD64_SSPAN32 = @as(u32, 16);
pub const IMAGE_REL_AMD64_EHANDLER = @as(u32, 17);
pub const IMAGE_REL_AMD64_IMPORT_BR = @as(u32, 18);
pub const IMAGE_REL_AMD64_IMPORT_CALL = @as(u32, 19);
pub const IMAGE_REL_AMD64_CFG_BR = @as(u32, 20);
pub const IMAGE_REL_AMD64_CFG_BR_REX = @as(u32, 21);
pub const IMAGE_REL_AMD64_CFG_CALL = @as(u32, 22);
pub const IMAGE_REL_AMD64_INDIR_BR = @as(u32, 23);
pub const IMAGE_REL_AMD64_INDIR_BR_REX = @as(u32, 24);
pub const IMAGE_REL_AMD64_INDIR_CALL = @as(u32, 25);
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_FIRST = @as(u32, 32);
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_LAST = @as(u32, 47);
pub const IMAGE_REL_IA64_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_IA64_IMM14 = @as(u32, 1);
pub const IMAGE_REL_IA64_IMM22 = @as(u32, 2);
pub const IMAGE_REL_IA64_IMM64 = @as(u32, 3);
pub const IMAGE_REL_IA64_DIR32 = @as(u32, 4);
pub const IMAGE_REL_IA64_DIR64 = @as(u32, 5);
pub const IMAGE_REL_IA64_PCREL21B = @as(u32, 6);
pub const IMAGE_REL_IA64_PCREL21M = @as(u32, 7);
pub const IMAGE_REL_IA64_PCREL21F = @as(u32, 8);
pub const IMAGE_REL_IA64_GPREL22 = @as(u32, 9);
pub const IMAGE_REL_IA64_LTOFF22 = @as(u32, 10);
pub const IMAGE_REL_IA64_SECTION = @as(u32, 11);
pub const IMAGE_REL_IA64_SECREL22 = @as(u32, 12);
pub const IMAGE_REL_IA64_SECREL64I = @as(u32, 13);
pub const IMAGE_REL_IA64_SECREL32 = @as(u32, 14);
pub const IMAGE_REL_IA64_DIR32NB = @as(u32, 16);
pub const IMAGE_REL_IA64_SREL14 = @as(u32, 17);
pub const IMAGE_REL_IA64_SREL22 = @as(u32, 18);
pub const IMAGE_REL_IA64_SREL32 = @as(u32, 19);
pub const IMAGE_REL_IA64_UREL32 = @as(u32, 20);
pub const IMAGE_REL_IA64_PCREL60X = @as(u32, 21);
pub const IMAGE_REL_IA64_PCREL60B = @as(u32, 22);
pub const IMAGE_REL_IA64_PCREL60F = @as(u32, 23);
pub const IMAGE_REL_IA64_PCREL60I = @as(u32, 24);
pub const IMAGE_REL_IA64_PCREL60M = @as(u32, 25);
pub const IMAGE_REL_IA64_IMMGPREL64 = @as(u32, 26);
pub const IMAGE_REL_IA64_TOKEN = @as(u32, 27);
pub const IMAGE_REL_IA64_GPREL32 = @as(u32, 28);
pub const IMAGE_REL_IA64_ADDEND = @as(u32, 31);
pub const IMAGE_REL_CEF_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_CEF_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_CEF_ADDR64 = @as(u32, 2);
pub const IMAGE_REL_CEF_ADDR32NB = @as(u32, 3);
pub const IMAGE_REL_CEF_SECTION = @as(u32, 4);
pub const IMAGE_REL_CEF_SECREL = @as(u32, 5);
pub const IMAGE_REL_CEF_TOKEN = @as(u32, 6);
pub const IMAGE_REL_CEE_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_CEE_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_CEE_ADDR64 = @as(u32, 2);
pub const IMAGE_REL_CEE_ADDR32NB = @as(u32, 3);
pub const IMAGE_REL_CEE_SECTION = @as(u32, 4);
pub const IMAGE_REL_CEE_SECREL = @as(u32, 5);
pub const IMAGE_REL_CEE_TOKEN = @as(u32, 6);
pub const IMAGE_REL_M32R_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_M32R_ADDR32 = @as(u32, 1);
pub const IMAGE_REL_M32R_ADDR32NB = @as(u32, 2);
pub const IMAGE_REL_M32R_ADDR24 = @as(u32, 3);
pub const IMAGE_REL_M32R_GPREL16 = @as(u32, 4);
pub const IMAGE_REL_M32R_PCREL24 = @as(u32, 5);
pub const IMAGE_REL_M32R_PCREL16 = @as(u32, 6);
pub const IMAGE_REL_M32R_PCREL8 = @as(u32, 7);
pub const IMAGE_REL_M32R_REFHALF = @as(u32, 8);
pub const IMAGE_REL_M32R_REFHI = @as(u32, 9);
pub const IMAGE_REL_M32R_REFLO = @as(u32, 10);
pub const IMAGE_REL_M32R_PAIR = @as(u32, 11);
pub const IMAGE_REL_M32R_SECTION = @as(u32, 12);
pub const IMAGE_REL_M32R_SECREL32 = @as(u32, 13);
pub const IMAGE_REL_M32R_TOKEN = @as(u32, 14);
pub const IMAGE_REL_EBC_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_EBC_ADDR32NB = @as(u32, 1);
pub const IMAGE_REL_EBC_REL32 = @as(u32, 2);
pub const IMAGE_REL_EBC_SECTION = @as(u32, 3);
pub const IMAGE_REL_EBC_SECREL = @as(u32, 4);
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X = @as(u32, 3);
pub const EMARCH_ENC_I17_IMM7B_SIZE_X = @as(u32, 7);
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X = @as(u32, 4);
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X = @as(u32, 0);
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X = @as(u32, 3);
pub const EMARCH_ENC_I17_IMM9D_SIZE_X = @as(u32, 9);
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X = @as(u32, 18);
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X = @as(u32, 7);
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X = @as(u32, 3);
pub const EMARCH_ENC_I17_IMM5C_SIZE_X = @as(u32, 5);
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X = @as(u32, 13);
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X = @as(u32, 16);
pub const EMARCH_ENC_I17_IC_INST_WORD_X = @as(u32, 3);
pub const EMARCH_ENC_I17_IC_SIZE_X = @as(u32, 1);
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X = @as(u32, 12);
pub const EMARCH_ENC_I17_IC_VAL_POS_X = @as(u32, 21);
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X = @as(u32, 1);
pub const EMARCH_ENC_I17_IMM41a_SIZE_X = @as(u32, 10);
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X = @as(u32, 14);
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X = @as(u32, 22);
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X = @as(u32, 1);
pub const EMARCH_ENC_I17_IMM41b_SIZE_X = @as(u32, 8);
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X = @as(u32, 24);
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X = @as(u32, 32);
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X = @as(u32, 2);
pub const EMARCH_ENC_I17_IMM41c_SIZE_X = @as(u32, 23);
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X = @as(u32, 0);
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X = @as(u32, 40);
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X = @as(u32, 3);
pub const EMARCH_ENC_I17_SIGN_SIZE_X = @as(u32, 1);
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X = @as(u32, 27);
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X = @as(u32, 63);
pub const X3_OPCODE_INST_WORD_X = @as(u32, 3);
pub const X3_OPCODE_SIZE_X = @as(u32, 4);
pub const X3_OPCODE_INST_WORD_POS_X = @as(u32, 28);
pub const X3_OPCODE_SIGN_VAL_POS_X = @as(u32, 0);
pub const X3_I_INST_WORD_X = @as(u32, 3);
pub const X3_I_SIZE_X = @as(u32, 1);
pub const X3_I_INST_WORD_POS_X = @as(u32, 27);
pub const X3_I_SIGN_VAL_POS_X = @as(u32, 59);
pub const X3_D_WH_INST_WORD_X = @as(u32, 3);
pub const X3_D_WH_SIZE_X = @as(u32, 3);
pub const X3_D_WH_INST_WORD_POS_X = @as(u32, 24);
pub const X3_D_WH_SIGN_VAL_POS_X = @as(u32, 0);
pub const X3_IMM20_INST_WORD_X = @as(u32, 3);
pub const X3_IMM20_SIZE_X = @as(u32, 20);
pub const X3_IMM20_INST_WORD_POS_X = @as(u32, 4);
pub const X3_IMM20_SIGN_VAL_POS_X = @as(u32, 0);
pub const X3_IMM39_1_INST_WORD_X = @as(u32, 2);
pub const X3_IMM39_1_SIZE_X = @as(u32, 23);
pub const X3_IMM39_1_INST_WORD_POS_X = @as(u32, 0);
pub const X3_IMM39_1_SIGN_VAL_POS_X = @as(u32, 36);
pub const X3_IMM39_2_INST_WORD_X = @as(u32, 1);
pub const X3_IMM39_2_SIZE_X = @as(u32, 16);
pub const X3_IMM39_2_INST_WORD_POS_X = @as(u32, 16);
pub const X3_IMM39_2_SIGN_VAL_POS_X = @as(u32, 20);
pub const X3_P_INST_WORD_X = @as(u32, 3);
pub const X3_P_SIZE_X = @as(u32, 4);
pub const X3_P_INST_WORD_POS_X = @as(u32, 0);
pub const X3_P_SIGN_VAL_POS_X = @as(u32, 0);
pub const X3_TMPLT_INST_WORD_X = @as(u32, 0);
pub const X3_TMPLT_SIZE_X = @as(u32, 4);
pub const X3_TMPLT_INST_WORD_POS_X = @as(u32, 0);
pub const X3_TMPLT_SIGN_VAL_POS_X = @as(u32, 0);
pub const X3_BTYPE_QP_INST_WORD_X = @as(u32, 2);
pub const X3_BTYPE_QP_SIZE_X = @as(u32, 9);
pub const X3_BTYPE_QP_INST_WORD_POS_X = @as(u32, 23);
pub const X3_BTYPE_QP_INST_VAL_POS_X = @as(u32, 0);
pub const X3_EMPTY_INST_WORD_X = @as(u32, 1);
pub const X3_EMPTY_SIZE_X = @as(u32, 2);
pub const X3_EMPTY_INST_WORD_POS_X = @as(u32, 14);
pub const X3_EMPTY_INST_VAL_POS_X = @as(u32, 0);
pub const IMAGE_REL_BASED_ABSOLUTE = @as(u32, 0);
pub const IMAGE_REL_BASED_HIGH = @as(u32, 1);
pub const IMAGE_REL_BASED_LOW = @as(u32, 2);
pub const IMAGE_REL_BASED_HIGHLOW = @as(u32, 3);
pub const IMAGE_REL_BASED_HIGHADJ = @as(u32, 4);
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5 = @as(u32, 5);
pub const IMAGE_REL_BASED_RESERVED = @as(u32, 6);
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7 = @as(u32, 7);
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8 = @as(u32, 8);
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9 = @as(u32, 9);
pub const IMAGE_REL_BASED_DIR64 = @as(u32, 10);
pub const IMAGE_REL_BASED_IA64_IMM64 = @as(u32, 9);
pub const IMAGE_REL_BASED_MIPS_JMPADDR = @as(u32, 5);
pub const IMAGE_REL_BASED_MIPS_JMPADDR16 = @as(u32, 9);
pub const IMAGE_REL_BASED_ARM_MOV32 = @as(u32, 5);
pub const IMAGE_REL_BASED_THUMB_MOV32 = @as(u32, 7);
pub const IMAGE_ARCHIVE_START_SIZE = @as(u32, 8);
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = @as(u32, 60);
pub const IMAGE_ORDINAL_FLAG64 = @as(u64, 9223372036854775808);
pub const IMAGE_ORDINAL_FLAG32 = @as(u32, 2147483648);
pub const IMAGE_RESOURCE_NAME_IS_STRING = @as(u32, 2147483648);
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY = @as(u32, 2147483648);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE = @as(u32, 1);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE = @as(u32, 2);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER = @as(u32, 3);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER = @as(u32, 4);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH = @as(u32, 5);
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY = @as(u32, 1);
pub const IMAGE_HOT_PATCH_BASE_CAN_ROLL_BACK = @as(u32, 2);
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE = @as(u32, 2147483648);
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY = @as(u32, 1073741824);
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED = @as(u32, 1072705536);
pub const IMAGE_HOT_PATCH_CHUNK_TYPE = @as(u32, 1032192);
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA = @as(u32, 32768);
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA = @as(u32, 16384);
pub const IMAGE_HOT_PATCH_CHUNK_SIZE = @as(u32, 4095);
pub const IMAGE_HOT_PATCH_NONE = @as(u32, 0);
pub const IMAGE_HOT_PATCH_FUNCTION = @as(u32, 114688);
pub const IMAGE_HOT_PATCH_ABSOLUTE = @as(u32, 180224);
pub const IMAGE_HOT_PATCH_REL32 = @as(u32, 245760);
pub const IMAGE_HOT_PATCH_CALL_TARGET = @as(u32, 278528);
pub const IMAGE_HOT_PATCH_INDIRECT = @as(u32, 376832);
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET = @as(u32, 409600);
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE = @as(u32, 491520);
pub const IMAGE_GUARD_CF_INSTRUMENTED = @as(u32, 256);
pub const IMAGE_GUARD_CFW_INSTRUMENTED = @as(u32, 512);
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT = @as(u32, 1024);
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED = @as(u32, 2048);
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT = @as(u32, 4096);
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION = @as(u32, 8192);
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT = @as(u32, 16384);
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION = @as(u32, 32768);
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT = @as(u32, 65536);
pub const IMAGE_GUARD_RF_INSTRUMENTED = @as(u32, 131072);
pub const IMAGE_GUARD_RF_ENABLE = @as(u32, 262144);
pub const IMAGE_GUARD_RF_STRICT = @as(u32, 524288);
pub const IMAGE_GUARD_RETPOLINE_PRESENT = @as(u32, 1048576);
pub const IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT = @as(u32, 2097152);
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK = @as(u32, 4026531840);
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT = @as(u32, 28);
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED = @as(u32, 1);
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED = @as(u32, 2);
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE = @as(u32, 1);
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE = @as(u32, 1);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE = @as(u32, 0);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID = @as(u32, 1);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID = @as(u32, 2);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID = @as(u32, 3);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID = @as(u32, 4);
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC = @as(u32, 7);
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = @as(u32, 8);
pub const IMAGE_DEBUG_TYPE_RESERVED10 = @as(u32, 10);
pub const IMAGE_DEBUG_TYPE_CLSID = @as(u32, 11);
pub const IMAGE_DEBUG_TYPE_VC_FEATURE = @as(u32, 12);
pub const IMAGE_DEBUG_TYPE_POGO = @as(u32, 13);
pub const IMAGE_DEBUG_TYPE_ILTCG = @as(u32, 14);
pub const IMAGE_DEBUG_TYPE_MPX = @as(u32, 15);
pub const IMAGE_DEBUG_TYPE_REPRO = @as(u32, 16);
pub const IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS = @as(u32, 20);
pub const FRAME_FPO = @as(u32, 0);
pub const FRAME_TRAP = @as(u32, 1);
pub const FRAME_TSS = @as(u32, 2);
pub const FRAME_NONFPO = @as(u32, 3);
pub const SIZEOF_RFPO_DATA = @as(u32, 16);
pub const IMAGE_DEBUG_MISC_EXENAME = @as(u32, 1);
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE = @as(u32, 18756);
pub const NON_PAGED_DEBUG_SIGNATURE = @as(u32, 18766);
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK = @as(u32, 32768);
pub const IMAGE_SEPARATE_DEBUG_MISMATCH = @as(u32, 32768);
pub const IMPORT_OBJECT_HDR_SIG2 = @as(u32, 65535);
pub const RTL_RUN_ONCE_CHECK_ONLY = @as(u32, 1);
pub const RTL_RUN_ONCE_ASYNC = @as(u32, 2);
pub const RTL_RUN_ONCE_INIT_FAILED = @as(u32, 4);
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS = @as(u32, 2);
pub const FAST_FAIL_LEGACY_GS_VIOLATION = @as(u32, 0);
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE = @as(u32, 1);
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE = @as(u32, 2);
pub const FAST_FAIL_CORRUPT_LIST_ENTRY = @as(u32, 3);
pub const FAST_FAIL_INCORRECT_STACK = @as(u32, 4);
pub const FAST_FAIL_INVALID_ARG = @as(u32, 5);
pub const FAST_FAIL_GS_COOKIE_INIT = @as(u32, 6);
pub const FAST_FAIL_FATAL_APP_EXIT = @as(u32, 7);
pub const FAST_FAIL_RANGE_CHECK_FAILURE = @as(u32, 8);
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS = @as(u32, 9);
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE = @as(u32, 10);
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE = @as(u32, 11);
pub const FAST_FAIL_INVALID_FIBER_SWITCH = @as(u32, 12);
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT = @as(u32, 13);
pub const FAST_FAIL_INVALID_REFERENCE_COUNT = @as(u32, 14);
pub const FAST_FAIL_INVALID_JUMP_BUFFER = @as(u32, 18);
pub const FAST_FAIL_MRDATA_MODIFIED = @as(u32, 19);
pub const FAST_FAIL_CERTIFICATION_FAILURE = @as(u32, 20);
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN = @as(u32, 21);
pub const FAST_FAIL_CRYPTO_LIBRARY = @as(u32, 22);
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT = @as(u32, 23);
pub const FAST_FAIL_INVALID_IMAGE_BASE = @as(u32, 24);
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE = @as(u32, 25);
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL = @as(u32, 26);
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED = @as(u32, 27);
pub const FAST_FAIL_INVALID_BUFFER_ACCESS = @as(u32, 28);
pub const FAST_FAIL_INVALID_BALANCED_TREE = @as(u32, 29);
pub const FAST_FAIL_INVALID_NEXT_THREAD = @as(u32, 30);
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED = @as(u32, 31);
pub const FAST_FAIL_APCS_DISABLED = @as(u32, 32);
pub const FAST_FAIL_INVALID_IDLE_STATE = @as(u32, 33);
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE = @as(u32, 34);
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION = @as(u32, 35);
pub const FAST_FAIL_INVALID_LOCK_STATE = @as(u32, 36);
pub const FAST_FAIL_GUARD_JUMPTABLE = @as(u32, 37);
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET = @as(u32, 38);
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT = @as(u32, 39);
pub const FAST_FAIL_INVALID_THREAD = @as(u32, 40);
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER = @as(u32, 41);
pub const FAST_FAIL_INVALID_FILE_OPERATION = @as(u32, 42);
pub const FAST_FAIL_LPAC_ACCESS_DENIED = @as(u32, 43);
pub const FAST_FAIL_GUARD_SS_FAILURE = @as(u32, 44);
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE = @as(u32, 45);
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE = @as(u32, 46);
pub const FAST_FAIL_INVALID_CONTROL_STACK = @as(u32, 47);
pub const FAST_FAIL_SET_CONTEXT_DENIED = @as(u32, 48);
pub const FAST_FAIL_INVALID_IAT = @as(u32, 49);
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION = @as(u32, 50);
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION = @as(u32, 51);
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED = @as(u32, 52);
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE = @as(u32, 53);
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON = @as(u32, 54);
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED = @as(u32, 55);
pub const FAST_FAIL_UNEXPECTED_CALL = @as(u32, 56);
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS = @as(u32, 57);
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR = @as(u32, 58);
pub const FAST_FAIL_FLAGS_CORRUPTION = @as(u32, 59);
pub const FAST_FAIL_VEH_CORRUPTION = @as(u32, 60);
pub const FAST_FAIL_ETW_CORRUPTION = @as(u32, 61);
pub const FAST_FAIL_RIO_ABORT = @as(u32, 62);
pub const FAST_FAIL_INVALID_PFN = @as(u32, 63);
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE = @as(u32, 4294967295);
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE = @as(u32, 1024);
pub const COMPRESSION_FORMAT_NONE = @as(u32, 0);
pub const COMPRESSION_FORMAT_DEFAULT = @as(u32, 1);
pub const COMPRESSION_FORMAT_LZNT1 = @as(u32, 2);
pub const COMPRESSION_FORMAT_XPRESS = @as(u32, 3);
pub const COMPRESSION_FORMAT_XPRESS_HUFF = @as(u32, 4);
pub const COMPRESSION_ENGINE_STANDARD = @as(u32, 0);
pub const COMPRESSION_ENGINE_MAXIMUM = @as(u32, 256);
pub const COMPRESSION_ENGINE_HIBER = @as(u32, 512);
pub const SEF_AI_USE_EXTRA_PARAMS = @as(u32, 2048);
pub const SEF_FORCE_USER_MODE = @as(u32, 8192);
pub const MESSAGE_RESOURCE_UNICODE = @as(u32, 1);
pub const MESSAGE_RESOURCE_UTF8 = @as(u32, 2);
pub const VER_EQUAL = @as(u32, 1);
pub const VER_GREATER = @as(u32, 2);
pub const VER_GREATER_EQUAL = @as(u32, 3);
pub const VER_LESS = @as(u32, 4);
pub const VER_LESS_EQUAL = @as(u32, 5);
pub const VER_AND = @as(u32, 6);
pub const VER_OR = @as(u32, 7);
pub const VER_CONDITION_MASK = @as(u32, 7);
pub const VER_NUM_BITS_PER_CONDITION_MASK = @as(u32, 3);
pub const VER_NT_WORKSTATION = @as(u32, 1);
pub const VER_NT_DOMAIN_CONTROLLER = @as(u32, 2);
pub const VER_NT_SERVER = @as(u32, 3);
pub const RTL_UMS_VERSION = @as(u32, 256);
pub const VRL_PREDEFINED_CLASS_BEGIN = @as(u32, 1);
pub const VRL_CUSTOM_CLASS_BEGIN = @as(u32, 256);
pub const VRL_ENABLE_KERNEL_BREAKS = @as(u32, 2147483648);
pub const CTMF_INCLUDE_APPCONTAINER = @as(u32, 1);
pub const CTMF_INCLUDE_LPAC = @as(u32, 2);
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN = @as(u32, 1);
pub const WRITE_NV_MEMORY_FLAG_FLUSH = @as(u32, 1);
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL = @as(u32, 2);
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN = @as(u32, 256);
pub const FILL_NV_MEMORY_FLAG_FLUSH = @as(u32, 1);
pub const FILL_NV_MEMORY_FLAG_NON_TEMPORAL = @as(u32, 2);
pub const FILL_NV_MEMORY_FLAG_NO_DRAIN = @as(u32, 256);
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH = @as(u32, 129);
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH = @as(u32, 16);
pub const RTL_CORRELATION_VECTOR_V1_LENGTH = @as(u32, 64);
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH = @as(u32, 22);
pub const RTL_CORRELATION_VECTOR_V2_LENGTH = @as(u32, 128);
pub const IMAGE_POLICY_METADATA_VERSION = @as(u32, 1);
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO = @as(u32, 16777216);
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN = @as(u32, 33554432);
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT = @as(u32, 67108864);
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE = @as(u32, 134217728);
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO = @as(u32, 268435456);
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS = @as(u32, 4278190080);
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT = @as(u32, 1);
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED = @as(u32, 1);
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION = @as(u32, 1);
pub const WT_EXECUTEINUITHREAD = @as(u32, 2);
pub const WT_EXECUTEINPERSISTENTIOTHREAD = @as(u32, 64);
pub const WT_EXECUTEINLONGTHREAD = @as(u32, 16);
pub const WT_EXECUTEDELETEWAIT = @as(u32, 8);
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE = @as(u32, 1);
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE = @as(u32, 2);
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL = @as(u32, 3);
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF = @as(u32, 4);
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID = @as(u32, 1);
pub const PERFORMANCE_DATA_VERSION = @as(u32, 1);
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING = @as(u32, 1);
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS = @as(u32, 2);
pub const UNIFIEDBUILDREVISION_MIN = @as(u32, 0);
pub const DEVICEFAMILYINFOENUM_UAP = @as(u32, 0);
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X = @as(u32, 1);
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X = @as(u32, 2);
pub const DEVICEFAMILYINFOENUM_DESKTOP = @as(u32, 3);
pub const DEVICEFAMILYINFOENUM_MOBILE = @as(u32, 4);
pub const DEVICEFAMILYINFOENUM_XBOX = @as(u32, 5);
pub const DEVICEFAMILYINFOENUM_TEAM = @as(u32, 6);
pub const DEVICEFAMILYINFOENUM_IOT = @as(u32, 7);
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS = @as(u32, 8);
pub const DEVICEFAMILYINFOENUM_SERVER = @as(u32, 9);
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC = @as(u32, 10);
pub const DEVICEFAMILYINFOENUM_XBOXSRA = @as(u32, 11);
pub const DEVICEFAMILYINFOENUM_XBOXERA = @as(u32, 12);
pub const DEVICEFAMILYINFOENUM_SERVER_NANO = @as(u32, 13);
pub const DEVICEFAMILYINFOENUM_8828080 = @as(u32, 14);
pub const DEVICEFAMILYINFOENUM_7067329 = @as(u32, 15);
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE = @as(u32, 16);
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE_HEADLESS = @as(u32, 17);
pub const DEVICEFAMILYINFOENUM_MAX = @as(u32, 17);
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN = @as(u32, 0);
pub const DEVICEFAMILYDEVICEFORM_PHONE = @as(u32, 1);
pub const DEVICEFAMILYDEVICEFORM_TABLET = @as(u32, 2);
pub const DEVICEFAMILYDEVICEFORM_DESKTOP = @as(u32, 3);
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK = @as(u32, 4);
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE = @as(u32, 5);
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE = @as(u32, 6);
pub const DEVICEFAMILYDEVICEFORM_ALLINONE = @as(u32, 7);
pub const DEVICEFAMILYDEVICEFORM_STICKPC = @as(u32, 8);
pub const DEVICEFAMILYDEVICEFORM_PUCK = @as(u32, 9);
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN = @as(u32, 10);
pub const DEVICEFAMILYDEVICEFORM_HMD = @as(u32, 11);
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD = @as(u32, 12);
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET = @as(u32, 13);
pub const DEVICEFAMILYDEVICEFORM_BANKING = @as(u32, 14);
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION = @as(u32, 15);
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE = @as(u32, 16);
pub const DEVICEFAMILYDEVICEFORM_GAMING = @as(u32, 17);
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION = @as(u32, 18);
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION = @as(u32, 19);
pub const DEVICEFAMILYDEVICEFORM_KIOSK = @as(u32, 20);
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD = @as(u32, 21);
pub const DEVICEFAMILYDEVICEFORM_MEDICAL = @as(u32, 22);
pub const DEVICEFAMILYDEVICEFORM_NETWORKING = @as(u32, 23);
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE = @as(u32, 24);
pub const DEVICEFAMILYDEVICEFORM_PRINTING = @as(u32, 25);
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT = @as(u32, 26);
pub const DEVICEFAMILYDEVICEFORM_TOY = @as(u32, 27);
pub const DEVICEFAMILYDEVICEFORM_VENDING = @as(u32, 28);
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER = @as(u32, 29);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE = @as(u32, 30);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S = @as(u32, 31);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X = @as(u32, 32);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT = @as(u32, 33);
pub const DEVICEFAMILYDEVICEFORM_MAX = @as(u32, 33);
pub const DLL_PROCESS_ATTACH = @as(u32, 1);
pub const DLL_THREAD_ATTACH = @as(u32, 2);
pub const DLL_THREAD_DETACH = @as(u32, 3);
pub const DLL_PROCESS_DETACH = @as(u32, 0);
pub const EVENTLOG_FORWARDS_READ = @as(u32, 4);
pub const EVENTLOG_BACKWARDS_READ = @as(u32, 8);
pub const EVENTLOG_START_PAIRED_EVENT = @as(u32, 1);
pub const EVENTLOG_END_PAIRED_EVENT = @as(u32, 2);
pub const EVENTLOG_END_ALL_PAIRED_EVENTS = @as(u32, 4);
pub const EVENTLOG_PAIRED_EVENT_ACTIVE = @as(u32, 8);
pub const EVENTLOG_PAIRED_EVENT_INACTIVE = @as(u32, 16);
pub const MAXLOGICALLOGNAMESIZE = @as(u32, 256);
pub const REG_REFRESH_HIVE = @as(i32, 2);
pub const REG_NO_LAZY_FLUSH = @as(i32, 4);
pub const REG_APP_HIVE = @as(i32, 16);
pub const REG_PROCESS_PRIVATE = @as(i32, 32);
pub const REG_START_JOURNAL = @as(i32, 64);
pub const REG_HIVE_EXACT_FILE_GROWTH = @as(i32, 128);
pub const REG_HIVE_NO_RM = @as(i32, 256);
pub const REG_HIVE_SINGLE_LOG = @as(i32, 512);
pub const REG_BOOT_HIVE = @as(i32, 1024);
pub const REG_LOAD_HIVE_OPEN_HANDLE = @as(i32, 2048);
pub const REG_FLUSH_HIVE_FILE_GROWTH = @as(i32, 4096);
pub const REG_OPEN_READ_ONLY = @as(i32, 8192);
pub const REG_IMMUTABLE = @as(i32, 16384);
pub const REG_NO_IMPERSONATION_FALLBACK = @as(i32, 32768);
pub const REG_FORCE_UNLOAD = @as(u32, 1);
pub const SERVICE_USER_SERVICE = @as(u32, 64);
pub const SERVICE_USERSERVICE_INSTANCE = @as(u32, 128);
pub const SERVICE_INTERACTIVE_PROCESS = @as(u32, 256);
pub const SERVICE_PKG_SERVICE = @as(u32, 512);
pub const CM_SERVICE_NETWORK_BOOT_LOAD = @as(u32, 1);
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD = @as(u32, 2);
pub const CM_SERVICE_USB_DISK_BOOT_LOAD = @as(u32, 4);
pub const CM_SERVICE_SD_DISK_BOOT_LOAD = @as(u32, 8);
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD = @as(u32, 16);
pub const CM_SERVICE_MEASURED_BOOT_LOAD = @as(u32, 32);
pub const CM_SERVICE_VERIFIER_BOOT_LOAD = @as(u32, 64);
pub const CM_SERVICE_WINPE_BOOT_LOAD = @as(u32, 128);
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD = @as(u32, 256);
pub const TAPE_PSEUDO_LOGICAL_POSITION = @as(i32, 2);
pub const TAPE_PSEUDO_LOGICAL_BLOCK = @as(i32, 3);
pub const TAPE_DRIVE_FIXED = @as(u32, 1);
pub const TAPE_DRIVE_SELECT = @as(u32, 2);
pub const TAPE_DRIVE_INITIATOR = @as(u32, 4);
pub const TAPE_DRIVE_ERASE_SHORT = @as(u32, 16);
pub const TAPE_DRIVE_ERASE_LONG = @as(u32, 32);
pub const TAPE_DRIVE_ERASE_BOP_ONLY = @as(u32, 64);
pub const TAPE_DRIVE_ERASE_IMMEDIATE = @as(u32, 128);
pub const TAPE_DRIVE_TAPE_CAPACITY = @as(u32, 256);
pub const TAPE_DRIVE_TAPE_REMAINING = @as(u32, 512);
pub const TAPE_DRIVE_FIXED_BLOCK = @as(u32, 1024);
pub const TAPE_DRIVE_VARIABLE_BLOCK = @as(u32, 2048);
pub const TAPE_DRIVE_WRITE_PROTECT = @as(u32, 4096);
pub const TAPE_DRIVE_EOT_WZ_SIZE = @as(u32, 8192);
pub const TAPE_DRIVE_ECC = @as(u32, 65536);
pub const TAPE_DRIVE_COMPRESSION = @as(u32, 131072);
pub const TAPE_DRIVE_PADDING = @as(u32, 262144);
pub const TAPE_DRIVE_REPORT_SMKS = @as(u32, 524288);
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK = @as(u32, 1048576);
pub const TAPE_DRIVE_GET_LOGICAL_BLK = @as(u32, 2097152);
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE = @as(u32, 4194304);
pub const TAPE_DRIVE_EJECT_MEDIA = @as(u32, 16777216);
pub const TAPE_DRIVE_CLEAN_REQUESTS = @as(u32, 33554432);
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY = @as(u32, 67108864);
pub const TAPE_DRIVE_RESERVED_BIT = @as(u32, 2147483648);
pub const TAPE_DRIVE_FORMAT = @as(u32, 2684354560);
pub const TAPE_DRIVE_FORMAT_IMMEDIATE = @as(u32, 3221225472);
pub const TAPE_DRIVE_HIGH_FEATURES = @as(u32, 2147483648);
pub const TAPE_QUERY_DRIVE_PARAMETERS = @as(i32, 0);
pub const TAPE_QUERY_MEDIA_CAPACITY = @as(i32, 1);
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM = @as(i32, 2);
pub const TAPE_QUERY_IO_ERROR_DATA = @as(i32, 3);
pub const TAPE_QUERY_DEVICE_ERROR_DATA = @as(i32, 4);
pub const TRANSACTIONMANAGER_QUERY_INFORMATION = @as(u32, 1);
pub const TRANSACTIONMANAGER_SET_INFORMATION = @as(u32, 2);
pub const TRANSACTIONMANAGER_RECOVER = @as(u32, 4);
pub const TRANSACTIONMANAGER_RENAME = @as(u32, 8);
pub const TRANSACTIONMANAGER_CREATE_RM = @as(u32, 16);
pub const TRANSACTIONMANAGER_BIND_TRANSACTION = @as(u32, 32);
pub const TRANSACTION_QUERY_INFORMATION = @as(u32, 1);
pub const TRANSACTION_SET_INFORMATION = @as(u32, 2);
pub const TRANSACTION_ENLIST = @as(u32, 4);
pub const TRANSACTION_COMMIT = @as(u32, 8);
pub const TRANSACTION_ROLLBACK = @as(u32, 16);
pub const TRANSACTION_PROPAGATE = @as(u32, 32);
pub const TRANSACTION_RIGHT_RESERVED1 = @as(u32, 64);
pub const RESOURCEMANAGER_QUERY_INFORMATION = @as(u32, 1);
pub const RESOURCEMANAGER_SET_INFORMATION = @as(u32, 2);
pub const RESOURCEMANAGER_RECOVER = @as(u32, 4);
pub const RESOURCEMANAGER_ENLIST = @as(u32, 8);
pub const RESOURCEMANAGER_GET_NOTIFICATION = @as(u32, 16);
pub const RESOURCEMANAGER_REGISTER_PROTOCOL = @as(u32, 32);
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION = @as(u32, 64);
pub const ENLISTMENT_QUERY_INFORMATION = @as(u32, 1);
pub const ENLISTMENT_SET_INFORMATION = @as(u32, 2);
pub const ENLISTMENT_RECOVER = @as(u32, 4);
pub const ENLISTMENT_SUBORDINATE_RIGHTS = @as(u32, 8);
pub const ENLISTMENT_SUPERIOR_RIGHTS = @as(u32, 16);
pub const PcTeb = @as(u32, 24);
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION = @as(u32, 1);
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION = @as(u32, 2);
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION = @as(u32, 3);
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION = @as(u32, 4);
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION = @as(u32, 5);
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION = @as(u32, 6);
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION = @as(u32, 7);
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE = @as(u32, 8);
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES = @as(u32, 9);
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS = @as(u32, 10);
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO = @as(u32, 11);
pub const ACTIVATION_CONTEXT_SECTION_WINRT_ACTIVATABLE_CLASSES = @as(u32, 12);
pub const DEVPKEY_NAME = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("b725f130-47ef-101a-a5f1-02608c9eebac"), .pid = 10 };
pub const DEVPKEY_Device_DeviceDesc = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 2 };
pub const DEVPKEY_Device_HardwareIds = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 3 };
pub const DEVPKEY_Device_CompatibleIds = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 4 };
pub const DEVPKEY_Device_Service = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 6 };
pub const DEVPKEY_Device_Class = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 9 };
pub const DEVPKEY_Device_ClassGuid = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 10 };
pub const DEVPKEY_Device_Driver = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 11 };
pub const DEVPKEY_Device_ConfigFlags = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 12 };
pub const DEVPKEY_Device_Manufacturer = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 13 };
pub const DEVPKEY_Device_FriendlyName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 14 };
pub const DEVPKEY_Device_LocationInfo = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 15 };
pub const DEVPKEY_Device_PDOName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 16 };
pub const DEVPKEY_Device_Capabilities = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 17 };
pub const DEVPKEY_Device_UINumber = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 18 };
pub const DEVPKEY_Device_UpperFilters = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 19 };
pub const DEVPKEY_Device_LowerFilters = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 20 };
pub const DEVPKEY_Device_BusTypeGuid = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 21 };
pub const DEVPKEY_Device_LegacyBusType = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 22 };
pub const DEVPKEY_Device_BusNumber = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 23 };
pub const DEVPKEY_Device_EnumeratorName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 24 };
pub const DEVPKEY_Device_Security = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 25 };
pub const DEVPKEY_Device_SecuritySDS = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 26 };
pub const DEVPKEY_Device_DevType = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 27 };
pub const DEVPKEY_Device_Exclusive = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 28 };
pub const DEVPKEY_Device_Characteristics = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 29 };
pub const DEVPKEY_Device_Address = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 30 };
pub const DEVPKEY_Device_UINumberDescFormat = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 31 };
pub const DEVPKEY_Device_PowerData = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 32 };
pub const DEVPKEY_Device_RemovalPolicy = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 33 };
pub const DEVPKEY_Device_RemovalPolicyDefault = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 34 };
pub const DEVPKEY_Device_RemovalPolicyOverride = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 35 };
pub const DEVPKEY_Device_InstallState = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 36 };
pub const DEVPKEY_Device_LocationPaths = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 37 };
pub const DEVPKEY_Device_BaseContainerId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a45c254e-df1c-4efd-8020-67d146a850e0"), .pid = 38 };
pub const DEVPKEY_Device_InstanceId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 256 };
pub const DEVPKEY_Device_DevNodeStatus = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 2 };
pub const DEVPKEY_Device_ProblemCode = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 3 };
pub const DEVPKEY_Device_EjectionRelations = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 4 };
pub const DEVPKEY_Device_RemovalRelations = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 5 };
pub const DEVPKEY_Device_PowerRelations = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 6 };
pub const DEVPKEY_Device_BusRelations = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 7 };
pub const DEVPKEY_Device_Parent = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 8 };
pub const DEVPKEY_Device_Children = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 9 };
pub const DEVPKEY_Device_Siblings = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 10 };
pub const DEVPKEY_Device_TransportRelations = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 11 };
pub const DEVPKEY_Device_ProblemStatus = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4340a6c5-93fa-4706-972c-7b648008a5a7"), .pid = 12 };
pub const DEVPKEY_Device_Reported = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80497100-8c73-48b9-aad9-ce387e19c56e"), .pid = 2 };
pub const DEVPKEY_Device_Legacy = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80497100-8c73-48b9-aad9-ce387e19c56e"), .pid = 3 };
pub const DEVPKEY_Device_ContainerId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("8c7ed206-3f8a-4827-b3ab-ae9e1faefc6c"), .pid = 2 };
pub const DEVPKEY_Device_InLocalMachineContainer = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("8c7ed206-3f8a-4827-b3ab-ae9e1faefc6c"), .pid = 4 };
pub const DEVPKEY_Device_Model = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 39 };
pub const DEVPKEY_Device_ModelId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 2 };
pub const DEVPKEY_Device_FriendlyNameAttributes = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 3 };
pub const DEVPKEY_Device_ManufacturerAttributes = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 4 };
pub const DEVPKEY_Device_PresenceNotForDevice = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 5 };
pub const DEVPKEY_Device_SignalStrength = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 6 };
pub const DEVPKEY_Device_IsAssociateableByUserAction = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 7 };
pub const DEVPKEY_Device_ShowInUninstallUI = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("80d81ea6-7473-4b0c-8216-efc11a2c4c8b"), .pid = 8 };
pub const DEVPKEY_Device_Numa_Proximity_Domain = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 1 };
pub const DEVPKEY_Device_DHP_Rebalance_Policy = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 2 };
pub const DEVPKEY_Device_Numa_Node = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 3 };
pub const DEVPKEY_Device_BusReportedDeviceDesc = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 4 };
pub const DEVPKEY_Device_IsPresent = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 5 };
pub const DEVPKEY_Device_HasProblem = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 6 };
pub const DEVPKEY_Device_ConfigurationId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 7 };
pub const DEVPKEY_Device_ReportedDeviceIdsHash = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 8 };
pub const DEVPKEY_Device_PhysicalDeviceLocation = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 9 };
pub const DEVPKEY_Device_BiosDeviceName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 10 };
pub const DEVPKEY_Device_DriverProblemDesc = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 11 };
pub const DEVPKEY_Device_DebuggerSafe = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 12 };
pub const DEVPKEY_Device_PostInstallInProgress = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 13 };
pub const DEVPKEY_Device_Stack = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 14 };
pub const DEVPKEY_Device_ExtendedConfigurationIds = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 15 };
pub const DEVPKEY_Device_IsRebootRequired = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 16 };
pub const DEVPKEY_Device_FirmwareDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 17 };
pub const DEVPKEY_Device_FirmwareVersion = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 18 };
pub const DEVPKEY_Device_FirmwareRevision = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 19 };
pub const DEVPKEY_Device_DependencyProviders = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 20 };
pub const DEVPKEY_Device_DependencyDependents = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 21 };
pub const DEVPKEY_Device_SoftRestartSupported = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 22 };
pub const DEVPKEY_Device_ExtendedAddress = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 23 };
pub const DEVPKEY_Device_AssignedToGuest = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("540b947e-8b40-45bc-a8a2-6a0b894cbda2"), .pid = 24 };
pub const DEVPKEY_Device_SessionId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 6 };
pub const DEVPKEY_Device_InstallDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 100 };
pub const DEVPKEY_Device_FirstInstallDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 101 };
pub const DEVPKEY_Device_LastArrivalDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 102 };
pub const DEVPKEY_Device_LastRemovalDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 103 };
pub const DEVPKEY_Device_DriverDate = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 2 };
pub const DEVPKEY_Device_DriverVersion = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 3 };
pub const DEVPKEY_Device_DriverDesc = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 4 };
pub const DEVPKEY_Device_DriverInfPath = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 5 };
pub const DEVPKEY_Device_DriverInfSection = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 6 };
pub const DEVPKEY_Device_DriverInfSectionExt = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 7 };
pub const DEVPKEY_Device_MatchingDeviceId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 8 };
pub const DEVPKEY_Device_DriverProvider = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 9 };
pub const DEVPKEY_Device_DriverPropPageProvider = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 10 };
pub const DEVPKEY_Device_DriverCoInstallers = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 11 };
pub const DEVPKEY_Device_ResourcePickerTags = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 12 };
pub const DEVPKEY_Device_ResourcePickerExceptions = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 13 };
pub const DEVPKEY_Device_DriverRank = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 14 };
pub const DEVPKEY_Device_DriverLogoLevel = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 15 };
pub const DEVPKEY_Device_NoConnectSound = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 17 };
pub const DEVPKEY_Device_GenericDriverInstalled = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 18 };
pub const DEVPKEY_Device_AdditionalSoftwareRequested = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("a8b865dd-2e3d-4094-ad97-e593a70c75d6"), .pid = 19 };
pub const DEVPKEY_Device_SafeRemovalRequired = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("afd97640-86a3-4210-b67c-289c41aabe55"), .pid = 2 };
pub const DEVPKEY_Device_SafeRemovalRequiredOverride = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("afd97640-86a3-4210-b67c-289c41aabe55"), .pid = 3 };
pub const DEVPKEY_DrvPkg_Model = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 2 };
pub const DEVPKEY_DrvPkg_VendorWebSite = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 3 };
pub const DEVPKEY_DrvPkg_DetailedDescription = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 4 };
pub const DEVPKEY_DrvPkg_DocumentationLink = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 5 };
pub const DEVPKEY_DrvPkg_Icon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 6 };
pub const DEVPKEY_DrvPkg_BrandingIcon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("cf73bb51-3abf-44a2-85e0-9a3dc7a12132"), .pid = 7 };
pub const DEVPKEY_DeviceClass_UpperFilters = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 19 };
pub const DEVPKEY_DeviceClass_LowerFilters = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 20 };
pub const DEVPKEY_DeviceClass_Security = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 25 };
pub const DEVPKEY_DeviceClass_SecuritySDS = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 26 };
pub const DEVPKEY_DeviceClass_DevType = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 27 };
pub const DEVPKEY_DeviceClass_Exclusive = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 28 };
pub const DEVPKEY_DeviceClass_Characteristics = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4321918b-f69e-470d-a5de-4d88c75ad24b"), .pid = 29 };
pub const DEVPKEY_DeviceClass_Name = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 2 };
pub const DEVPKEY_DeviceClass_ClassName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 3 };
pub const DEVPKEY_DeviceClass_Icon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 4 };
pub const DEVPKEY_DeviceClass_ClassInstaller = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 5 };
pub const DEVPKEY_DeviceClass_PropPageProvider = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 6 };
pub const DEVPKEY_DeviceClass_NoInstallClass = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 7 };
pub const DEVPKEY_DeviceClass_NoDisplayClass = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 8 };
pub const DEVPKEY_DeviceClass_SilentInstall = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 9 };
pub const DEVPKEY_DeviceClass_NoUseClass = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 10 };
pub const DEVPKEY_DeviceClass_DefaultService = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 11 };
pub const DEVPKEY_DeviceClass_IconPath = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("259abffc-50a7-47ce-af08-68c9a7d73366"), .pid = 12 };
pub const DEVPKEY_DeviceClass_DHPRebalanceOptOut = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("d14d3ef3-66cf-4ba2-9d38-0ddb37ab4701"), .pid = 2 };
pub const DEVPKEY_DeviceClass_ClassCoInstallers = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("713d1703-a2e2-49f5-9214-56472ef3da5c"), .pid = 2 };
pub const DEVPKEY_DeviceInterface_FriendlyName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 2 };
pub const DEVPKEY_DeviceInterface_Enabled = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 3 };
pub const DEVPKEY_DeviceInterface_ClassGuid = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 4 };
pub const DEVPKEY_DeviceInterface_ReferenceString = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 5 };
pub const DEVPKEY_DeviceInterface_Restricted = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 6 };
pub const DEVPKEY_DeviceInterface_UnrestrictedAppCapabilities = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 8 };
pub const DEVPKEY_DeviceInterface_SchematicName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("026e516e-b814-414b-83cd-856d6fef4822"), .pid = 9 };
pub const DEVPKEY_DeviceInterfaceClass_DefaultInterface = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("14c83a99-0b3f-44b7-be4c-a178d3990564"), .pid = 2 };
pub const DEVPKEY_DeviceInterfaceClass_Name = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("14c83a99-0b3f-44b7-be4c-a178d3990564"), .pid = 3 };
pub const DEVPKEY_DeviceContainer_Address = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 51 };
pub const DEVPKEY_DeviceContainer_DiscoveryMethod = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 52 };
pub const DEVPKEY_DeviceContainer_IsEncrypted = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 53 };
pub const DEVPKEY_DeviceContainer_IsAuthenticated = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 54 };
pub const DEVPKEY_DeviceContainer_IsConnected = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 55 };
pub const DEVPKEY_DeviceContainer_IsPaired = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 56 };
pub const DEVPKEY_DeviceContainer_Icon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 57 };
pub const DEVPKEY_DeviceContainer_Version = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 65 };
pub const DEVPKEY_DeviceContainer_Last_Seen = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 66 };
pub const DEVPKEY_DeviceContainer_Last_Connected = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 67 };
pub const DEVPKEY_DeviceContainer_IsShowInDisconnectedState = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 68 };
pub const DEVPKEY_DeviceContainer_IsLocalMachine = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 70 };
pub const DEVPKEY_DeviceContainer_MetadataPath = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 71 };
pub const DEVPKEY_DeviceContainer_IsMetadataSearchInProgress = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 72 };
pub const DEVPKEY_DeviceContainer_MetadataChecksum = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 73 };
pub const DEVPKEY_DeviceContainer_IsNotInterestingForDisplay = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 74 };
pub const DEVPKEY_DeviceContainer_LaunchDeviceStageOnDeviceConnect = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 76 };
pub const DEVPKEY_DeviceContainer_LaunchDeviceStageFromExplorer = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 77 };
pub const DEVPKEY_DeviceContainer_BaselineExperienceId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 78 };
pub const DEVPKEY_DeviceContainer_IsDeviceUniquelyIdentifiable = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 79 };
pub const DEVPKEY_DeviceContainer_AssociationArray = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 80 };
pub const DEVPKEY_DeviceContainer_DeviceDescription1 = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 81 };
pub const DEVPKEY_DeviceContainer_DeviceDescription2 = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 82 };
pub const DEVPKEY_DeviceContainer_HasProblem = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 83 };
pub const DEVPKEY_DeviceContainer_IsSharedDevice = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 84 };
pub const DEVPKEY_DeviceContainer_IsNetworkDevice = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 85 };
pub const DEVPKEY_DeviceContainer_IsDefaultDevice = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 86 };
pub const DEVPKEY_DeviceContainer_MetadataCabinet = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 87 };
pub const DEVPKEY_DeviceContainer_RequiresPairingElevation = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 88 };
pub const DEVPKEY_DeviceContainer_ExperienceId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 89 };
pub const DEVPKEY_DeviceContainer_Category = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 90 };
pub const DEVPKEY_DeviceContainer_Category_Desc_Singular = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 91 };
pub const DEVPKEY_DeviceContainer_Category_Desc_Plural = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 92 };
pub const DEVPKEY_DeviceContainer_Category_Icon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 93 };
pub const DEVPKEY_DeviceContainer_CategoryGroup_Desc = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 94 };
pub const DEVPKEY_DeviceContainer_CategoryGroup_Icon = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 95 };
pub const DEVPKEY_DeviceContainer_PrimaryCategory = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 97 };
pub const DEVPKEY_DeviceContainer_UnpairUninstall = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 98 };
pub const DEVPKEY_DeviceContainer_RequiresUninstallElevation = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 99 };
pub const DEVPKEY_DeviceContainer_DeviceFunctionSubRank = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 100 };
pub const DEVPKEY_DeviceContainer_AlwaysShowDeviceAsConnected = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 101 };
pub const DEVPKEY_DeviceContainer_ConfigFlags = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 105 };
pub const DEVPKEY_DeviceContainer_PrivilegedPackageFamilyNames = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 106 };
pub const DEVPKEY_DeviceContainer_CustomPrivilegedPackageFamilyNames = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 107 };
pub const DEVPKEY_DeviceContainer_IsRebootRequired = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57"), .pid = 108 };
pub const DEVPKEY_DeviceContainer_FriendlyName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("656a3bb3-ecc0-43fd-8477-4ae0404a96cd"), .pid = 12288 };
pub const DEVPKEY_DeviceContainer_Manufacturer = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("656a3bb3-ecc0-43fd-8477-4ae0404a96cd"), .pid = 8192 };
pub const DEVPKEY_DeviceContainer_ModelName = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("656a3bb3-ecc0-43fd-8477-4ae0404a96cd"), .pid = 8194 };
pub const DEVPKEY_DeviceContainer_ModelNumber = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("656a3bb3-ecc0-43fd-8477-4ae0404a96cd"), .pid = 8195 };
pub const DEVPKEY_DeviceContainer_InstallInProgress = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("83da6326-97a6-4088-9453-a1923f573b29"), .pid = 9 };
pub const DEVPKEY_DevQuery_ObjectType = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("13673f42-a3d6-49f6-b4da-ae46e0c5237c"), .pid = 2 };
pub const AVENC_H263V_LEVELCOUNT = @as(u32, 8);
pub const AVENC_H264V_LEVELCOUNT = @as(u32, 16);
pub const AVENC_H264V_MAX_MBBITS = @as(u32, 3200);
pub const GUID_DEVINTERFACE_DISPLAY_ADAPTER = Guid.initString("5b45201d-f2f2-4f3b-85bb-30ff1f953599");
pub const GUID_DEVINTERFACE_MONITOR = Guid.initString("e6f07b5f-ee97-4a90-b076-33f57bf4eaa7");
pub const GUID_DISPLAY_DEVICE_ARRIVAL = Guid.initString("1ca05180-a699-450a-9a0c-de4fbe3ddd89");
pub const GUID_DEVINTERFACE_VIDEO_OUTPUT_ARRIVAL = Guid.initString("1ad9e4f0-f88d-4360-bab9-4c2d55e564cd");
pub const DEVPKEY_IndirectDisplay = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("c50a3f10-aa5c-4247-b830-d6a6f8eaa310"), .pid = 1 };
pub const DEVPKEY_Device_TerminalLuid = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("c50a3f10-aa5c-4247-b830-d6a6f8eaa310"), .pid = 2 };
pub const DEVPKEY_Device_AdapterLuid = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("c50a3f10-aa5c-4247-b830-d6a6f8eaa310"), .pid = 3 };
pub const DEVPKEY_Device_ActivityId = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("c50a3f10-aa5c-4247-b830-d6a6f8eaa310"), .pid = 4 };
pub const INDIRECT_DISPLAY_INFO_FLAGS_CREATED_IDDCX_ADAPTER = @as(u32, 1);
pub const DXGK_WIN32K_PARAM_FLAG_UPDATEREGISTRY = @as(u32, 1);
pub const DXGK_WIN32K_PARAM_FLAG_MODESWITCH = @as(u32, 2);
pub const DXGK_WIN32K_PARAM_FLAG_DISABLEVIEW = @as(u32, 4);
pub const VIDEO_DUALVIEW_REMOVABLE = @as(u32, 1);
pub const VIDEO_DUALVIEW_PRIMARY = @as(u32, 2147483648);
pub const VIDEO_DUALVIEW_SECONDARY = @as(u32, 1073741824);
pub const VIDEO_DUALVIEW_WDDM_VGA = @as(u32, 536870912);
pub const VIDEO_STATE_NON_STANDARD_VGA = @as(u32, 1);
pub const VIDEO_STATE_UNEMULATED_VGA_STATE = @as(u32, 2);
pub const VIDEO_STATE_PACKED_CHAIN4_MODE = @as(u32, 4);
pub const VIDEO_MODE_NO_ZERO_MEMORY = @as(u32, 2147483648);
pub const VIDEO_MODE_MAP_MEM_LINEAR = @as(u32, 1073741824);
pub const VIDEO_MODE_COLOR = @as(u32, 1);
pub const VIDEO_MODE_GRAPHICS = @as(u32, 2);
pub const VIDEO_MODE_PALETTE_DRIVEN = @as(u32, 4);
pub const VIDEO_MODE_MANAGED_PALETTE = @as(u32, 8);
pub const VIDEO_MODE_INTERLACED = @as(u32, 16);
pub const VIDEO_MODE_NO_OFF_SCREEN = @as(u32, 32);
pub const VIDEO_MODE_NO_64_BIT_ACCESS = @as(u32, 64);
pub const VIDEO_MODE_BANKED = @as(u32, 128);
pub const VIDEO_MODE_LINEAR = @as(u32, 256);
pub const VIDEO_MODE_ASYNC_POINTER = @as(u32, 1);
pub const VIDEO_MODE_MONO_POINTER = @as(u32, 2);
pub const VIDEO_MODE_COLOR_POINTER = @as(u32, 4);
pub const VIDEO_MODE_ANIMATE_START = @as(u32, 8);
pub const VIDEO_MODE_ANIMATE_UPDATE = @as(u32, 16);
pub const PLANAR_HC = @as(u32, 1);
pub const VIDEO_DEVICE_COLOR = @as(u32, 1);
pub const VIDEO_OPTIONAL_GAMMET_TABLE = @as(u32, 2);
pub const VIDEO_COLOR_LUT_DATA_FORMAT_RGB256WORDS = @as(u32, 1);
pub const VIDEO_COLOR_LUT_DATA_FORMAT_PRIVATEFORMAT = @as(u32, 2147483648);
pub const DISPLAYPOLICY_AC = @as(u32, 1);
pub const DISPLAYPOLICY_DC = @as(u32, 2);
pub const FOREGROUND_BLUE = @as(u32, 1);
pub const FOREGROUND_GREEN = @as(u32, 2);
pub const FOREGROUND_RED = @as(u32, 4);
pub const FOREGROUND_INTENSITY = @as(u32, 8);
pub const BACKGROUND_BLUE = @as(u32, 16);
pub const BACKGROUND_GREEN = @as(u32, 32);
pub const BACKGROUND_RED = @as(u32, 64);
pub const BACKGROUND_INTENSITY = @as(u32, 128);
pub const COMMON_LVB_LEADING_BYTE = @as(u32, 256);
pub const COMMON_LVB_TRAILING_BYTE = @as(u32, 512);
pub const COMMON_LVB_GRID_HORIZONTAL = @as(u32, 1024);
pub const COMMON_LVB_GRID_LVERTICAL = @as(u32, 2048);
pub const COMMON_LVB_GRID_RVERTICAL = @as(u32, 4096);
pub const COMMON_LVB_REVERSE_VIDEO = @as(u32, 16384);
pub const COMMON_LVB_UNDERSCORE = @as(u32, 32768);
pub const COMMON_LVB_SBCSDBCS = @as(u32, 768);
pub const CHAR_TYPE_SBCS = @as(u32, 0);
pub const CHAR_TYPE_LEADING = @as(u32, 2);
pub const CHAR_TYPE_TRAILING = @as(u32, 3);
pub const BITMAP_BITS_BYTE_ALIGN = @as(u32, 8);
pub const BITMAP_BITS_WORD_ALIGN = @as(u32, 16);
pub const BITMAP_ARRAY_BYTE = @as(u32, 3);
pub const BITMAP_PLANES = @as(u32, 1);
pub const BITMAP_BITS_PIXEL = @as(u32, 1);
pub const VIDEO_REASON_NONE = @as(u32, 0);
pub const VIDEO_REASON_POLICY1 = @as(u32, 1);
pub const VIDEO_REASON_POLICY2 = @as(u32, 2);
pub const VIDEO_REASON_POLICY3 = @as(u32, 3);
pub const VIDEO_REASON_POLICY4 = @as(u32, 4);
pub const VIDEO_REASON_LOCK = @as(u32, 5);
pub const VIDEO_REASON_FAILED_ROTATION = @as(u32, 5);
pub const VIDEO_REASON_ALLOCATION = @as(u32, 6);
pub const VIDEO_REASON_SCRATCH = @as(u32, 8);
pub const VIDEO_REASON_CONFIGURATION = @as(u32, 9);
pub const BRIGHTNESS_MAX_LEVEL_COUNT = @as(u32, 103);
pub const BRIGHTNESS_MAX_NIT_RANGE_COUNT = @as(u32, 16);
pub const DSI_PACKET_EMBEDDED_PAYLOAD_SIZE = @as(u32, 8);
pub const MAX_PACKET_COUNT = @as(u32, 128);
pub const DSI_INVALID_PACKET_INDEX = @as(u32, 255);
pub const DSI_SOT_ERROR = @as(u32, 1);
pub const DSI_SOT_SYNC_ERROR = @as(u32, 2);
pub const DSI_EOT_SYNC_ERROR = @as(u32, 4);
pub const DSI_ESCAPE_MODE_ENTRY_COMMAND_ERROR = @as(u32, 8);
pub const DSI_LOW_POWER_TRANSMIT_SYNC_ERROR = @as(u32, 16);
pub const DSI_PERIPHERAL_TIMEOUT_ERROR = @as(u32, 32);
pub const DSI_FALSE_CONTROL_ERROR = @as(u32, 64);
pub const DSI_CONTENTION_DETECTED = @as(u32, 128);
pub const DSI_CHECKSUM_ERROR_CORRECTED = @as(u32, 256);
pub const DSI_CHECKSUM_ERROR_NOT_CORRECTED = @as(u32, 512);
pub const DSI_LONG_PACKET_PAYLOAD_CHECKSUM_ERROR = @as(u32, 1024);
pub const DSI_DSI_DATA_TYPE_NOT_RECOGNIZED = @as(u32, 2048);
pub const DSI_DSI_VC_ID_INVALID = @as(u32, 4096);
pub const DSI_INVALID_TRANSMISSION_LENGTH = @as(u32, 8192);
pub const DSI_DSI_PROTOCOL_VIOLATION = @as(u32, 32768);
pub const HOST_DSI_DEVICE_NOT_READY = @as(u32, 1);
pub const HOST_DSI_INTERFACE_RESET = @as(u32, 2);
pub const HOST_DSI_DEVICE_RESET = @as(u32, 4);
pub const HOST_DSI_TRANSMISSION_CANCELLED = @as(u32, 16);
pub const HOST_DSI_TRANSMISSION_DROPPED = @as(u32, 32);
pub const HOST_DSI_TRANSMISSION_TIMEOUT = @as(u32, 64);
pub const HOST_DSI_INVALID_TRANSMISSION = @as(u32, 256);
pub const HOST_DSI_OS_REJECTED_PACKET = @as(u32, 512);
pub const HOST_DSI_DRIVER_REJECTED_PACKET = @as(u32, 1024);
pub const HOST_DSI_BAD_TRANSMISSION_MODE = @as(u32, 4096);
pub const GUID_MONITOR_OVERRIDE_PSEUDO_SPECIALIZED = Guid.initString("f196c02f-f86f-4f9a-aa15-e9cebdfe3b96");
pub const PROCESSOR_NUMBER_PKEY = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("5724c81d-d5af-4c1f-a103-a06e28f204c6"), .pid = 1 };
pub const GUID_DEVICE_BATTERY = Guid.initString("72631e54-78a4-11d0-bcf7-00aa00b7b32a");
pub const GUID_DEVICE_APPLICATIONLAUNCH_BUTTON = Guid.initString("629758ee-986e-4d9e-8e47-de27f8ab054d");
pub const GUID_DEVICE_SYS_BUTTON = Guid.initString("4afa3d53-74a7-11d0-be5e-00a0c9062857");
pub const GUID_DEVICE_LID = Guid.initString("4afa3d52-74a7-11d0-be5e-00a0c9062857");
pub const GUID_DEVICE_THERMAL_ZONE = Guid.initString("4afa3d51-74a7-11d0-be5e-00a0c9062857");
pub const GUID_DEVICE_FAN = Guid.initString("05ecd13d-81da-4a2a-8a4c-524f23dd4dc9");
pub const GUID_DEVICE_PROCESSOR = Guid.initString("97fadb10-4e33-40ae-359c-8bef029dbdd0");
pub const GUID_DEVICE_MEMORY = Guid.initString("3fd0f03d-92e0-45fb-b75c-5ed8ffb01021");
pub const GUID_DEVICE_ACPI_TIME = Guid.initString("97f99bf6-4497-4f18-bb22-4b9fb2fbef9c");
pub const GUID_DEVICE_MESSAGE_INDICATOR = Guid.initString("cd48a365-fa94-4ce2-a232-a1b764e5d8b4");
pub const GUID_CLASS_INPUT = Guid.initString("4d1e55b2-f16f-11cf-88cb-001111000030");
pub const GUID_DEVINTERFACE_THERMAL_COOLING = Guid.initString("dbe4373d-3c81-40cb-ace4-e0e5d05f0c9f");
pub const BATTERY_UNKNOWN_CAPACITY = @as(u32, 4294967295);
pub const BATTERY_SYSTEM_BATTERY = @as(u32, 2147483648);
pub const BATTERY_CAPACITY_RELATIVE = @as(u32, 1073741824);
pub const BATTERY_IS_SHORT_TERM = @as(u32, 536870912);
pub const BATTERY_SEALED = @as(u32, 268435456);
pub const BATTERY_SET_CHARGE_SUPPORTED = @as(u32, 1);
pub const BATTERY_SET_DISCHARGE_SUPPORTED = @as(u32, 2);
pub const BATTERY_SET_CHARGINGSOURCE_SUPPORTED = @as(u32, 4);
pub const BATTERY_SET_CHARGER_ID_SUPPORTED = @as(u32, 8);
pub const BATTERY_UNKNOWN_TIME = @as(u32, 4294967295);
pub const BATTERY_UNKNOWN_CURRENT = @as(u32, 4294967295);
pub const BATTERY_USB_CHARGER_STATUS_FN_DEFAULT_USB = @as(u32, 1);
pub const BATTERY_USB_CHARGER_STATUS_UCM_PD = @as(u32, 2);
pub const BATTERY_UNKNOWN_VOLTAGE = @as(u32, 4294967295);
pub const BATTERY_UNKNOWN_RATE = @as(u32, 2147483648);
pub const BATTERY_POWER_ON_LINE = @as(u32, 1);
pub const BATTERY_DISCHARGING = @as(u32, 2);
pub const BATTERY_CHARGING = @as(u32, 4);
pub const BATTERY_CRITICAL = @as(u32, 8);
pub const MAX_BATTERY_STRING_SIZE = @as(u32, 128);
pub const BATTERY_TAG_INVALID = @as(u32, 0);
pub const MAX_ACTIVE_COOLING_LEVELS = @as(u32, 10);
pub const ACTIVE_COOLING = @as(u32, 0);
pub const PASSIVE_COOLING = @as(u32, 1);
pub const TZ_ACTIVATION_REASON_THERMAL = @as(u32, 1);
pub const TZ_ACTIVATION_REASON_CURRENT = @as(u32, 2);
pub const THERMAL_POLICY_VERSION_1 = @as(u32, 1);
pub const THERMAL_POLICY_VERSION_2 = @as(u32, 2);
pub const SYS_BUTTON_POWER = @as(u32, 1);
pub const SYS_BUTTON_SLEEP = @as(u32, 2);
pub const SYS_BUTTON_LID = @as(u32, 4);
pub const SYS_BUTTON_WAKE = @as(u32, 2147483648);
pub const SYS_BUTTON_LID_STATE_MASK = @as(u32, 196608);
pub const SYS_BUTTON_LID_OPEN = @as(u32, 65536);
pub const SYS_BUTTON_LID_CLOSED = @as(u32, 131072);
pub const SYS_BUTTON_LID_INITIAL = @as(u32, 262144);
pub const SYS_BUTTON_LID_CHANGED = @as(u32, 524288);
pub const THERMAL_COOLING_INTERFACE_VERSION = @as(u32, 1);
pub const THERMAL_DEVICE_INTERFACE_VERSION = @as(u32, 1);
pub const ACPI_TIME_ADJUST_DAYLIGHT = @as(u32, 1);
pub const ACPI_TIME_IN_DAYLIGHT = @as(u32, 2);
pub const ACPI_TIME_ZONE_UNKNOWN = @as(u32, 2047);
pub const EFFECTIVE_POWER_MODE_V1 = @as(u32, 1);
pub const EFFECTIVE_POWER_MODE_V2 = @as(u32, 2);
pub const ENCLAVE_RUNTIME_POLICY_ALLOW_FULL_DEBUG = @as(u32, 1);
pub const ENCLAVE_RUNTIME_POLICY_ALLOW_DYNAMIC_DEBUG = @as(u32, 2);
pub const ENCLAVE_UNSEAL_FLAG_STALE_KEY = @as(u32, 1);
pub const ENCLAVE_FLAG_FULL_DEBUG_ENABLED = @as(u32, 1);
pub const ENCLAVE_FLAG_DYNAMIC_DEBUG_ENABLED = @as(u32, 2);
pub const ENCLAVE_FLAG_DYNAMIC_DEBUG_ACTIVE = @as(u32, 4);
pub const VBS_ENCLAVE_REPORT_PKG_HEADER_VERSION_CURRENT = @as(u32, 1);
pub const VBS_ENCLAVE_REPORT_SIGNATURE_SCHEME_SHA256_RSA_PSS_SHA256 = @as(u32, 1);
pub const VBS_ENCLAVE_REPORT_VERSION_CURRENT = @as(u32, 1);
pub const ENCLAVE_REPORT_DATA_LENGTH = @as(u32, 64);
pub const VBS_ENCLAVE_VARDATA_INVALID = @as(u32, 0);
pub const VBS_ENCLAVE_VARDATA_MODULE = @as(u32, 1);
pub const ENCLAVE_VBS_BASIC_KEY_FLAG_MEASUREMENT = @as(u32, 1);
pub const ENCLAVE_VBS_BASIC_KEY_FLAG_FAMILY_ID = @as(u32, 2);
pub const ENCLAVE_VBS_BASIC_KEY_FLAG_IMAGE_ID = @as(u32, 4);
pub const ENCLAVE_VBS_BASIC_KEY_FLAG_DEBUG_KEY = @as(u32, 8);
pub const GUID_DEVINTERFACE_PWM_CONTROLLER = Guid.initString("60824b4c-eed1-4c9c-b49c-1b961461a819");
pub const GUID_DEVINTERFACE_DISK = Guid.initString("53f56307-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_CDROM = Guid.initString("53f56308-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_PARTITION = Guid.initString("53f5630a-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_TAPE = Guid.initString("53f5630b-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_WRITEONCEDISK = Guid.initString("53f5630c-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_VOLUME = Guid.initString("53f5630d-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_MEDIUMCHANGER = Guid.initString("53f56310-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_FLOPPY = Guid.initString("53f56311-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_CDCHANGER = Guid.initString("53f56312-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_DEVINTERFACE_STORAGEPORT = Guid.initString("2accfe60-c130-11d2-b082-00a0c91efb8b");
pub const GUID_DEVINTERFACE_VMLUN = Guid.initString("6f416619-9f29-42a5-b20b-37e219ca02b0");
pub const GUID_DEVINTERFACE_SES = Guid.initString("1790c9ec-47d5-4df3-b5af-9adf3cf23e48");
pub const GUID_DEVINTERFACE_SERVICE_VOLUME = Guid.initString("6ead3d82-25ec-46bc-b7fd-c1f0df8f5037");
pub const GUID_DEVINTERFACE_HIDDEN_VOLUME = Guid.initString("7f108a28-9833-4b3b-b780-2c6b5fa5c062");
pub const GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB = Guid.initString("27447c21-bcc3-4d07-a05b-a3395bb4eee7");
pub const GUID_DEVICEDUMP_STORAGE_DEVICE = Guid.initString("d8e2592f-1aab-4d56-a746-1f7585df40f4");
pub const GUID_DEVICEDUMP_DRIVER_STORAGE_PORT = Guid.initString("da82441d-7142-4bc1-b844-0807c5a4b67f");
pub const DEVPKEY_Storage_Portable = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 2 };
pub const DEVPKEY_Storage_Removable_Media = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 3 };
pub const DEVPKEY_Storage_System_Critical = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 4 };
pub const DEVPKEY_Storage_Disk_Number = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 5 };
pub const DEVPKEY_Storage_Partition_Number = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 6 };
pub const DEVPKEY_Storage_Mbr_Type = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 7 };
pub const DEVPKEY_Storage_Gpt_Type = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 8 };
pub const DEVPKEY_Storage_Gpt_Name = PROPERTYKEY { .fmtid = @import("../zig.zig").Guid.initString("4d1ebee8-0803-4774-9842-b77db50265e9"), .pid = 9 };
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT = @as(u32, 1);
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID = @as(u32, 2);
pub const STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID = @as(u32, 4);
pub const RECOVERED_WRITES_VALID = @as(u32, 1);
pub const UNRECOVERED_WRITES_VALID = @as(u32, 2);
pub const RECOVERED_READS_VALID = @as(u32, 4);
pub const UNRECOVERED_READS_VALID = @as(u32, 8);
pub const WRITE_COMPRESSION_INFO_VALID = @as(u32, 16);
pub const READ_COMPRESSION_INFO_VALID = @as(u32, 32);
pub const TAPE_RETURN_STATISTICS = @as(i32, 0);
pub const TAPE_RETURN_ENV_INFO = @as(i32, 1);
pub const TAPE_RESET_STATISTICS = @as(i32, 2);
pub const MEDIA_ERASEABLE = @as(u32, 1);
pub const MEDIA_WRITE_ONCE = @as(u32, 2);
pub const MEDIA_READ_ONLY = @as(u32, 4);
pub const MEDIA_READ_WRITE = @as(u32, 8);
pub const MEDIA_WRITE_PROTECTED = @as(u32, 256);
pub const MEDIA_CURRENTLY_MOUNTED = @as(u32, 2147483648);
pub const STORAGE_FAILURE_PREDICTION_CONFIG_V1 = @as(u32, 1);
pub const SRB_TYPE_SCSI_REQUEST_BLOCK = @as(u32, 0);
pub const SRB_TYPE_STORAGE_REQUEST_BLOCK = @as(u32, 1);
pub const STORAGE_ADDRESS_TYPE_BTL8 = @as(u32, 0);
pub const STORAGE_RPMB_DESCRIPTOR_VERSION_1 = @as(u32, 1);
pub const STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE = @as(u32, 512);
pub const STORAGE_CRYPTO_CAPABILITY_VERSION_1 = @as(u32, 1);
pub const STORAGE_CRYPTO_DESCRIPTOR_VERSION_1 = @as(u32, 1);
pub const STORAGE_TIER_NAME_LENGTH = @as(u32, 256);
pub const STORAGE_TIER_DESCRIPTION_LENGTH = @as(u32, 512);
pub const STORAGE_TIER_FLAG_NO_SEEK_PENALTY = @as(u32, 131072);
pub const STORAGE_TIER_FLAG_WRITE_BACK_CACHE = @as(u32, 2097152);
pub const STORAGE_TIER_FLAG_READ_CACHE = @as(u32, 4194304);
pub const STORAGE_TIER_FLAG_PARITY = @as(u32, 8388608);
pub const STORAGE_TIER_FLAG_SMR = @as(u32, 16777216);
pub const STORAGE_TEMPERATURE_VALUE_NOT_REPORTED = @as(u32, 32768);
pub const STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST = @as(u32, 1);
pub const STORAGE_COMPONENT_ROLE_CACHE = @as(u32, 1);
pub const STORAGE_COMPONENT_ROLE_TIERING = @as(u32, 2);
pub const STORAGE_COMPONENT_ROLE_DATA = @as(u32, 4);
pub const STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO = @as(u32, 1);
pub const STORAGE_ATTRIBUTE_BLOCK_IO = @as(u32, 2);
pub const STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE = @as(u32, 4);
pub const STORAGE_ATTRIBUTE_VOLATILE = @as(u32, 8);
pub const STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION = @as(u32, 16);
pub const STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT = @as(u32, 32);
pub const STORAGE_DEVICE_MAX_OPERATIONAL_STATUS = @as(u32, 16);
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH = @as(u32, 128);
pub const DeviceDsmActionFlag_NonDestructive = @as(u32, 2147483648);
pub const DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE = @as(u32, 1);
pub const DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED = @as(u32, 2147483648);
pub const DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT = @as(u32, 1073741824);
pub const DEVICE_DSM_NOTIFY_FLAG_BEGIN = @as(u32, 1);
pub const DEVICE_DSM_NOTIFY_FLAG_END = @as(u32, 2);
pub const STORAGE_OFFLOAD_MAX_TOKEN_LENGTH = @as(u32, 512);
pub const STORAGE_OFFLOAD_TOKEN_ID_LENGTH = @as(u32, 504);
pub const STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA = @as(u32, 4294901761);
pub const STORAGE_OFFLOAD_READ_RANGE_TRUNCATED = @as(u32, 1);
pub const STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED = @as(u32, 1);
pub const STORAGE_OFFLOAD_TOKEN_INVALID = @as(u32, 2);
pub const DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY = @as(u32, 1073741824);
pub const DEVICE_DSM_PARAMETERS_V1 = @as(u32, 1);
pub const DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT = @as(u32, 1073741824);
pub const DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT = @as(u32, 536870912);
pub const DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC = @as(u32, 268435456);
pub const DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT = @as(u32, 536870912);
pub const DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES = @as(u32, 268435456);
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1 = @as(u32, 1);
pub const DEVICE_STORAGE_NO_ERRORS = @as(u32, 1);
pub const DEVICE_DSM_RANGE_ERROR_OUTPUT_V1 = @as(u32, 1);
pub const IOCTL_STORAGE_BC_VERSION = @as(u32, 1);
pub const STORAGE_PRIORITY_HINT_SUPPORTED = @as(u32, 1);
pub const ERROR_HISTORY_DIRECTORY_ENTRY_DEFAULT_COUNT = @as(u32, 8);
pub const DEVICEDUMP_STRUCTURE_VERSION_V1 = @as(u32, 1);
pub const DEVICEDUMP_MAX_IDSTRING = @as(u32, 32);
pub const MAX_FW_BUCKET_ID_LENGTH = @as(u32, 132);
pub const DDUMP_FLAG_DATA_READ_FROM_DEVICE = @as(u32, 1);
pub const FW_ISSUEID_NO_ISSUE = @as(u32, 0);
pub const FW_ISSUEID_UNKNOWN = @as(u32, 4294967295);
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_SMART = @as(u32, 1);
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG = @as(u32, 2);
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX = @as(u32, 16);
pub const TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH = @as(u32, 16);
pub const CDB_SIZE = @as(u32, 16);
pub const TELEMETRY_COMMAND_SIZE = @as(u32, 16);
pub const DEVICEDUMP_CAP_PRIVATE_SECTION = @as(u32, 1);
pub const DEVICEDUMP_CAP_RESTRICTED_SECTION = @as(u32, 2);
pub const STORAGE_IDLE_POWERUP_REASON_VERSION_V1 = @as(u32, 1);
pub const STORAGE_DEVICE_POWER_CAP_VERSION_V1 = @as(u32, 1);
pub const STORAGE_EVENT_NOTIFICATION_VERSION_V1 = @as(u32, 1);
pub const STORAGE_EVENT_MEDIA_STATUS = @as(u64, 1);
pub const STORAGE_EVENT_DEVICE_STATUS = @as(u64, 2);
pub const STORAGE_EVENT_DEVICE_OPERATION = @as(u64, 4);
pub const READ_COPY_NUMBER_KEY = @as(u32, 1380142592);
pub const READ_COPY_NUMBER_BYPASS_CACHE_FLAG = @as(u32, 256);
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER = @as(u32, 1);
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT = @as(u32, 2);
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT = @as(u32, 4);
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE = @as(u32, 2147483648);
pub const STORAGE_HW_FIRMWARE_INVALID_SLOT = @as(u32, 255);
pub const STORAGE_HW_FIRMWARE_REVISION_LENGTH = @as(u32, 16);
pub const STORAGE_PROTOCOL_STRUCTURE_VERSION = @as(u32, 1);
pub const STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST = @as(u32, 2147483648);
pub const STORAGE_PROTOCOL_STATUS_PENDING = @as(u32, 0);
pub const STORAGE_PROTOCOL_STATUS_SUCCESS = @as(u32, 1);
pub const STORAGE_PROTOCOL_STATUS_ERROR = @as(u32, 2);
pub const STORAGE_PROTOCOL_STATUS_INVALID_REQUEST = @as(u32, 3);
pub const STORAGE_PROTOCOL_STATUS_NO_DEVICE = @as(u32, 4);
pub const STORAGE_PROTOCOL_STATUS_BUSY = @as(u32, 5);
pub const STORAGE_PROTOCOL_STATUS_DATA_OVERRUN = @as(u32, 6);
pub const STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES = @as(u32, 7);
pub const STORAGE_PROTOCOL_STATUS_THROTTLED_REQUEST = @as(u32, 8);
pub const STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED = @as(u32, 255);
pub const STORAGE_PROTOCOL_COMMAND_LENGTH_NVME = @as(u32, 64);
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND = @as(u32, 1);
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND = @as(u32, 2);
pub const STORATTRIBUTE_NONE = @as(u32, 0);
pub const STORATTRIBUTE_MANAGEMENT_STATE = @as(u32, 1);
pub const BSF_MSGSRV32ISOK = @as(u32, 2147483648);
pub const BSF_MSGSRV32ISOK_BIT = @as(u32, 31);
pub const DBT_APPYBEGIN = @as(u32, 0);
pub const DBT_APPYEND = @as(u32, 1);
pub const DBT_DEVNODES_CHANGED = @as(u32, 7);
pub const DBT_QUERYCHANGECONFIG = @as(u32, 23);
pub const DBT_CONFIGCHANGED = @as(u32, 24);
pub const DBT_CONFIGCHANGECANCELED = @as(u32, 25);
pub const DBT_MONITORCHANGE = @as(u32, 27);
pub const DBT_SHELLLOGGEDON = @as(u32, 32);
pub const DBT_CONFIGMGAPI32 = @as(u32, 34);
pub const DBT_VXDINITCOMPLETE = @as(u32, 35);
pub const DBT_VOLLOCKQUERYLOCK = @as(u32, 32833);
pub const DBT_VOLLOCKLOCKTAKEN = @as(u32, 32834);
pub const DBT_VOLLOCKLOCKFAILED = @as(u32, 32835);
pub const DBT_VOLLOCKQUERYUNLOCK = @as(u32, 32836);
pub const DBT_VOLLOCKLOCKRELEASED = @as(u32, 32837);
pub const DBT_VOLLOCKUNLOCKFAILED = @as(u32, 32838);
pub const LOCKP_ALLOW_WRITES = @as(u32, 1);
pub const LOCKP_FAIL_WRITES = @as(u32, 0);
pub const LOCKP_FAIL_MEM_MAPPING = @as(u32, 2);
pub const LOCKP_ALLOW_MEM_MAPPING = @as(u32, 0);
pub const LOCKP_USER_MASK = @as(u32, 3);
pub const LOCKP_LOCK_FOR_FORMAT = @as(u32, 4);
pub const LOCKF_LOGICAL_LOCK = @as(u32, 0);
pub const LOCKF_PHYSICAL_LOCK = @as(u32, 1);
pub const DBT_NO_DISK_SPACE = @as(u32, 71);
pub const DBT_LOW_DISK_SPACE = @as(u32, 72);
pub const DBT_CONFIGMGPRIVATE = @as(u32, 32767);
pub const DBT_DEVICEARRIVAL = @as(u32, 32768);
pub const DBT_DEVICEQUERYREMOVE = @as(u32, 32769);
pub const DBT_DEVICEQUERYREMOVEFAILED = @as(u32, 32770);
pub const DBT_DEVICEREMOVEPENDING = @as(u32, 32771);
pub const DBT_DEVICEREMOVECOMPLETE = @as(u32, 32772);
pub const DBT_DEVICETYPESPECIFIC = @as(u32, 32773);
pub const DBT_CUSTOMEVENT = @as(u32, 32774);
pub const DBT_DEVTYP_DEVNODE = @as(u32, 1);
pub const DBT_DEVTYP_NET = @as(u32, 4);
pub const DBTF_RESOURCE = @as(u32, 1);
pub const DBTF_XPORT = @as(u32, 2);
pub const DBTF_SLOWNET = @as(u32, 4);
pub const DBT_VPOWERDAPI = @as(u32, 33024);
pub const DBT_USERDEFINED = @as(u32, 65535);
pub const DEVPROP_TYPEMOD_ARRAY = @as(u32, 4096);
pub const DEVPROP_TYPEMOD_LIST = @as(u32, 8192);
pub const DEVPROP_TYPE_EMPTY = @as(u32, 0);
pub const DEVPROP_TYPE_NULL = @as(u32, 1);
pub const DEVPROP_TYPE_SBYTE = @as(u32, 2);
pub const DEVPROP_TYPE_BYTE = @as(u32, 3);
pub const DEVPROP_TYPE_INT16 = @as(u32, 4);
pub const DEVPROP_TYPE_UINT16 = @as(u32, 5);
pub const DEVPROP_TYPE_INT32 = @as(u32, 6);
pub const DEVPROP_TYPE_UINT32 = @as(u32, 7);
pub const DEVPROP_TYPE_INT64 = @as(u32, 8);
pub const DEVPROP_TYPE_UINT64 = @as(u32, 9);
pub const DEVPROP_TYPE_FLOAT = @as(u32, 10);
pub const DEVPROP_TYPE_DOUBLE = @as(u32, 11);
pub const DEVPROP_TYPE_DECIMAL = @as(u32, 12);
pub const DEVPROP_TYPE_GUID = @as(u32, 13);
pub const DEVPROP_TYPE_CURRENCY = @as(u32, 14);
pub const DEVPROP_TYPE_DATE = @as(u32, 15);
pub const DEVPROP_TYPE_FILETIME = @as(u32, 16);
pub const DEVPROP_TYPE_BOOLEAN = @as(u32, 17);
pub const DEVPROP_TYPE_STRING = @as(u32, 18);
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR = @as(u32, 19);
pub const DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING = @as(u32, 20);
pub const DEVPROP_TYPE_DEVPROPKEY = @as(u32, 21);
pub const DEVPROP_TYPE_DEVPROPTYPE = @as(u32, 22);
pub const DEVPROP_TYPE_ERROR = @as(u32, 23);
pub const DEVPROP_TYPE_NTSTATUS = @as(u32, 24);
pub const DEVPROP_TYPE_STRING_INDIRECT = @as(u32, 25);
pub const MAX_DEVPROP_TYPE = @as(u32, 25);
pub const MAX_DEVPROP_TYPEMOD = @as(u32, 8192);
pub const DEVPROP_MASK_TYPE = @as(u32, 4095);
pub const DEVPROP_MASK_TYPEMOD = @as(u32, 61440);
pub const DEVPROPID_FIRST_USABLE = @as(u32, 2);
pub const GUID_IO_VOLUME_CHANGE = Guid.initString("7373654a-812a-11d0-bec7-08002be2092f");
pub const GUID_IO_VOLUME_DISMOUNT = Guid.initString("d16a55e8-1059-11d2-8ffd-00a0c9a06d32");
pub const GUID_IO_VOLUME_DISMOUNT_FAILED = Guid.initString("e3c5b178-105d-11d2-8ffd-00a0c9a06d32");
pub const GUID_IO_VOLUME_MOUNT = Guid.initString("b5804878-1a96-11d2-8ffd-00a0c9a06d32");
pub const GUID_IO_VOLUME_LOCK = Guid.initString("50708874-c9af-11d1-8fef-00a0c9a06d32");
pub const GUID_IO_VOLUME_LOCK_FAILED = Guid.initString("ae2eed10-0ba8-11d2-8ffb-00a0c9a06d32");
pub const GUID_IO_VOLUME_UNLOCK = Guid.initString("9a8c3d68-d0cb-11d1-8fef-00a0c9a06d32");
pub const GUID_IO_VOLUME_NAME_CHANGE = Guid.initString("2de97f83-4c06-11d2-a532-00609713055a");
pub const GUID_IO_VOLUME_NEED_CHKDSK = Guid.initString("799a0960-0a0b-4e03-ad88-2fa7c6ce748a");
pub const GUID_IO_VOLUME_WORM_NEAR_FULL = Guid.initString("f3bfff82-f3de-48d2-af95-457f80b763f2");
pub const GUID_IO_VOLUME_WEARING_OUT = Guid.initString("873113ca-1486-4508-82ac-c3b2e5297aaa");
pub const GUID_IO_VOLUME_FORCE_CLOSED = Guid.initString("411ad84f-433e-4dc2-a5ae-4a2d1a2de654");
pub const GUID_IO_VOLUME_INFO_MAKE_COMPAT = Guid.initString("3ab9a0d2-ef80-45cf-8cdc-cbe02a212906");
pub const GUID_IO_VOLUME_PREPARING_EJECT = Guid.initString("c79eb16e-0dac-4e7a-a86c-b25ceeaa88f6");
pub const GUID_IO_VOLUME_BACKGROUND_FORMAT = Guid.initString("a2e5fc86-d5cd-4038-b2e3-4445065c2377");
pub const GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE = Guid.initString("2de97f84-4c06-11d2-a532-00609713055a");
pub const GUID_IO_VOLUME_UNIQUE_ID_CHANGE = Guid.initString("af39da42-6622-41f5-970b-139d092fa3d9");
pub const GUID_IO_VOLUME_FVE_STATUS_CHANGE = Guid.initString("062998b2-ee1f-4b6a-b857-e76cbbe9a6da");
pub const GUID_IO_VOLUME_DEVICE_INTERFACE = Guid.initString("53f5630d-b6bf-11d0-94f2-00a0c91efb8b");
pub const GUID_IO_VOLUME_CHANGE_SIZE = Guid.initString("3a1625be-ad03-49f1-8ef8-6bbac182d1fd");
pub const GUID_IO_MEDIA_ARRIVAL = Guid.initString("d07433c0-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_MEDIA_REMOVAL = Guid.initString("d07433c1-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_CDROM_EXCLUSIVE_LOCK = Guid.initString("bc56c139-7a10-47ee-a294-4c6a38f0149a");
pub const GUID_IO_CDROM_EXCLUSIVE_UNLOCK = Guid.initString("a3b6d27d-5e35-4885-81e5-ee18c00ed779");
pub const GUID_IO_DEVICE_BECOMING_READY = Guid.initString("d07433f0-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_DEVICE_EXTERNAL_REQUEST = Guid.initString("d07433d0-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_MEDIA_EJECT_REQUEST = Guid.initString("d07433d1-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_DRIVE_REQUIRES_CLEANING = Guid.initString("7207877c-90ed-44e5-a000-81428d4c79bb");
pub const GUID_IO_TAPE_ERASE = Guid.initString("852d11eb-4bb8-4507-9d9b-417cc2b1b438");
pub const GUID_DEVICE_EVENT_RBC = Guid.initString("d0744792-a98e-11d2-917a-00a0c9068ff3");
pub const GUID_IO_DISK_CLONE_ARRIVAL = Guid.initString("6a61885b-7c39-43dd-9b56-b8ac22a549aa");
pub const GUID_IO_DISK_LAYOUT_CHANGE = Guid.initString("11dff54c-8469-41f9-b3de-ef836487c54a");
pub const GUID_IO_DISK_HEALTH_NOTIFICATION = Guid.initString("0f1bd644-3916-49c5-b063-991940118fb2");
pub const D3DNTHAL_NUMCLIPVERTICES = @as(u32, 20);
pub const D3DNTHAL_SCENE_CAPTURE_START = @as(i32, 0);
pub const D3DNTHAL_SCENE_CAPTURE_END = @as(i32, 1);
pub const D3DNTHAL_CONTEXT_BAD = @as(i64, 512);
pub const D3DNTHAL_OUTOFCONTEXTS = @as(i64, 513);
pub const D3DNTHAL2_CB32_SETRENDERTARGET = @as(i32, 1);
pub const D3DHAL_STATESETBEGIN = @as(u32, 0);
pub const D3DHAL_STATESETEND = @as(u32, 1);
pub const D3DHAL_STATESETDELETE = @as(u32, 2);
pub const D3DHAL_STATESETEXECUTE = @as(u32, 3);
pub const D3DHAL_STATESETCAPTURE = @as(u32, 4);
pub const D3DNTHALDP2_USERMEMVERTICES = @as(i32, 1);
pub const D3DNTHALDP2_EXECUTEBUFFER = @as(i32, 2);
pub const D3DNTHALDP2_SWAPVERTEXBUFFER = @as(i32, 4);
pub const D3DNTHALDP2_SWAPCOMMANDBUFFER = @as(i32, 8);
pub const D3DNTHALDP2_REQVERTEXBUFSIZE = @as(i32, 16);
pub const D3DNTHALDP2_REQCOMMANDBUFSIZE = @as(i32, 32);
pub const D3DNTHALDP2_VIDMEMVERTEXBUF = @as(i32, 64);
pub const D3DNTHALDP2_VIDMEMCOMMANDBUF = @as(i32, 128);
pub const D3DNTHAL3_CB32_CLEAR2 = @as(i32, 1);
pub const D3DNTHAL3_CB32_RESERVED = @as(i32, 2);
pub const D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE = @as(i32, 4);
pub const D3DNTHAL3_CB32_DRAWPRIMITIVES2 = @as(i32, 8);
pub const D3DNTHAL_TSS_RENDERSTATEBASE = @as(u32, 256);
pub const D3DNTHAL_TSS_MAXSTAGES = @as(u32, 8);
pub const D3DNTHAL_TSS_STATESPERSTAGE = @as(u32, 64);
pub const D3DTSS_TEXTUREMAP = @as(u32, 0);
pub const D3DHAL_SAMPLER_MAXSAMP = @as(u32, 16);
pub const D3DHAL_SAMPLER_MAXVERTEXSAMP = @as(u32, 4);
pub const D3DPMISCCAPS_LINEPATTERNREP = @as(i32, 4);
pub const D3DRS_MAXVERTEXSHADERINST = @as(u32, 196);
pub const D3DRS_MAXPIXELSHADERINST = @as(u32, 197);
pub const D3DRENDERSTATE_EVICTMANAGEDTEXTURES = @as(u32, 61);
pub const D3DRENDERSTATE_SCENECAPTURE = @as(u32, 62);
pub const D3DINFINITEINSTRUCTIONS = @as(u32, 4294967295);
pub const D3DNTHAL_STATESETCREATE = @as(u32, 5);
pub const D3DNTCLEAR_COMPUTERECTS = @as(i32, 8);
pub const D3DNTHAL_ROW_WEIGHTS = @as(u32, 1);
pub const D3DNTHAL_COL_WEIGHTS = @as(u32, 2);
pub const DP2BLT_POINT = @as(i32, 1);
pub const DP2BLT_LINEAR = @as(i32, 2);
pub const DDBLT_EXTENDED_PRESENTATION_STRETCHFACTOR = @as(i32, 16);
pub const DX9_DDI_VERSION = @as(u32, 4);
pub const D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE = @as(i32, 8388608);
pub const D3DVSDT_FLOAT1 = @as(u32, 0);
pub const D3DVSDT_FLOAT2 = @as(u32, 1);
pub const D3DVSDT_FLOAT3 = @as(u32, 2);
pub const D3DVSDT_FLOAT4 = @as(u32, 3);
pub const D3DVSDT_D3DCOLOR = @as(u32, 4);
pub const D3DVSDT_UBYTE4 = @as(u32, 5);
pub const D3DVSDT_SHORT2 = @as(u32, 6);
pub const D3DVSDT_SHORT4 = @as(u32, 7);
pub const D3DVSDE_POSITION = @as(u32, 0);
pub const D3DVSDE_BLENDWEIGHT = @as(u32, 1);
pub const D3DVSDE_BLENDINDICES = @as(u32, 2);
pub const D3DVSDE_NORMAL = @as(u32, 3);
pub const D3DVSDE_PSIZE = @as(u32, 4);
pub const D3DVSDE_DIFFUSE = @as(u32, 5);
pub const D3DVSDE_SPECULAR = @as(u32, 6);
pub const D3DVSDE_TEXCOORD0 = @as(u32, 7);
pub const D3DVSDE_TEXCOORD1 = @as(u32, 8);
pub const D3DVSDE_TEXCOORD2 = @as(u32, 9);
pub const D3DVSDE_TEXCOORD3 = @as(u32, 10);
pub const D3DVSDE_TEXCOORD4 = @as(u32, 11);
pub const D3DVSDE_TEXCOORD5 = @as(u32, 12);
pub const D3DVSDE_TEXCOORD6 = @as(u32, 13);
pub const D3DVSDE_TEXCOORD7 = @as(u32, 14);
pub const D3DVSDE_POSITION2 = @as(u32, 15);
pub const D3DVSDE_NORMAL2 = @as(u32, 16);
pub const D3DVSD_TOKENTYPESHIFT = @as(u32, 29);
pub const D3DVSD_STREAMNUMBERSHIFT = @as(u32, 0);
pub const D3DVSD_DATALOADTYPESHIFT = @as(u32, 28);
pub const D3DVSD_DATATYPESHIFT = @as(u32, 16);
pub const D3DVSD_SKIPCOUNTSHIFT = @as(u32, 16);
pub const D3DVSD_VERTEXREGSHIFT = @as(u32, 0);
pub const D3DVSD_VERTEXREGINSHIFT = @as(u32, 20);
pub const D3DVSD_CONSTCOUNTSHIFT = @as(u32, 25);
pub const D3DVSD_CONSTADDRESSSHIFT = @as(u32, 0);
pub const D3DVSD_CONSTRSSHIFT = @as(u32, 16);
pub const D3DVSD_EXTCOUNTSHIFT = @as(u32, 24);
pub const D3DVSD_EXTINFOSHIFT = @as(u32, 0);
pub const D3DVSD_STREAMTESSSHIFT = @as(u32, 28);
pub const DIRECT3D_VERSION = @as(u32, 1792);
pub const D3DTRANSFORMCAPS_CLIP = @as(i32, 1);
pub const D3DLIGHTINGMODEL_RGB = @as(i32, 1);
pub const D3DLIGHTINGMODEL_MONO = @as(i32, 2);
pub const D3DLIGHTCAPS_POINT = @as(i32, 1);
pub const D3DLIGHTCAPS_SPOT = @as(i32, 2);
pub const D3DLIGHTCAPS_DIRECTIONAL = @as(i32, 4);
pub const D3DLIGHTCAPS_PARALLELPOINT = @as(i32, 8);
pub const D3DLIGHTCAPS_GLSPOT = @as(i32, 16);
pub const D3DPMISCCAPS_MASKPLANES = @as(i32, 1);
pub const D3DPMISCCAPS_MASKZ = @as(i32, 2);
pub const D3DPMISCCAPS_CONFORMANT = @as(i32, 8);
pub const D3DPMISCCAPS_CULLNONE = @as(i32, 16);
pub const D3DPMISCCAPS_CULLCW = @as(i32, 32);
pub const D3DPMISCCAPS_CULLCCW = @as(i32, 64);
pub const D3DPRASTERCAPS_DITHER = @as(i32, 1);
pub const D3DPRASTERCAPS_ROP2 = @as(i32, 2);
pub const D3DPRASTERCAPS_XOR = @as(i32, 4);
pub const D3DPRASTERCAPS_PAT = @as(i32, 8);
pub const D3DPRASTERCAPS_ZTEST = @as(i32, 16);
pub const D3DPRASTERCAPS_SUBPIXEL = @as(i32, 32);
pub const D3DPRASTERCAPS_SUBPIXELX = @as(i32, 64);
pub const D3DPRASTERCAPS_FOGVERTEX = @as(i32, 128);
pub const D3DPRASTERCAPS_FOGTABLE = @as(i32, 256);
pub const D3DPRASTERCAPS_STIPPLE = @as(i32, 512);
pub const D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT = @as(i32, 1024);
pub const D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT = @as(i32, 2048);
pub const D3DPRASTERCAPS_ANTIALIASEDGES = @as(i32, 4096);
pub const D3DPRASTERCAPS_MIPMAPLODBIAS = @as(i32, 8192);
pub const D3DPRASTERCAPS_ZBIAS = @as(i32, 16384);
pub const D3DPRASTERCAPS_ZBUFFERLESSHSR = @as(i32, 32768);
pub const D3DPRASTERCAPS_FOGRANGE = @as(i32, 65536);
pub const D3DPRASTERCAPS_ANISOTROPY = @as(i32, 131072);
pub const D3DPRASTERCAPS_WBUFFER = @as(i32, 262144);
pub const D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT = @as(i32, 524288);
pub const D3DPRASTERCAPS_WFOG = @as(i32, 1048576);
pub const D3DPRASTERCAPS_ZFOG = @as(i32, 2097152);
pub const D3DPCMPCAPS_NEVER = @as(i32, 1);
pub const D3DPCMPCAPS_LESS = @as(i32, 2);
pub const D3DPCMPCAPS_EQUAL = @as(i32, 4);
pub const D3DPCMPCAPS_LESSEQUAL = @as(i32, 8);
pub const D3DPCMPCAPS_GREATER = @as(i32, 16);
pub const D3DPCMPCAPS_NOTEQUAL = @as(i32, 32);
pub const D3DPCMPCAPS_GREATEREQUAL = @as(i32, 64);
pub const D3DPCMPCAPS_ALWAYS = @as(i32, 128);
pub const D3DPBLENDCAPS_ZERO = @as(i32, 1);
pub const D3DPBLENDCAPS_ONE = @as(i32, 2);
pub const D3DPBLENDCAPS_SRCCOLOR = @as(i32, 4);
pub const D3DPBLENDCAPS_INVSRCCOLOR = @as(i32, 8);
pub const D3DPBLENDCAPS_SRCALPHA = @as(i32, 16);
pub const D3DPBLENDCAPS_INVSRCALPHA = @as(i32, 32);
pub const D3DPBLENDCAPS_DESTALPHA = @as(i32, 64);
pub const D3DPBLENDCAPS_INVDESTALPHA = @as(i32, 128);
pub const D3DPBLENDCAPS_DESTCOLOR = @as(i32, 256);
pub const D3DPBLENDCAPS_INVDESTCOLOR = @as(i32, 512);
pub const D3DPBLENDCAPS_SRCALPHASAT = @as(i32, 1024);
pub const D3DPBLENDCAPS_BOTHSRCALPHA = @as(i32, 2048);
pub const D3DPBLENDCAPS_BOTHINVSRCALPHA = @as(i32, 4096);
pub const D3DPSHADECAPS_COLORFLATMONO = @as(i32, 1);
pub const D3DPSHADECAPS_COLORFLATRGB = @as(i32, 2);
pub const D3DPSHADECAPS_COLORGOURAUDMONO = @as(i32, 4);
pub const D3DPSHADECAPS_COLORGOURAUDRGB = @as(i32, 8);
pub const D3DPSHADECAPS_COLORPHONGMONO = @as(i32, 16);
pub const D3DPSHADECAPS_COLORPHONGRGB = @as(i32, 32);
pub const D3DPSHADECAPS_SPECULARFLATMONO = @as(i32, 64);
pub const D3DPSHADECAPS_SPECULARFLATRGB = @as(i32, 128);
pub const D3DPSHADECAPS_SPECULARGOURAUDMONO = @as(i32, 256);
pub const D3DPSHADECAPS_SPECULARGOURAUDRGB = @as(i32, 512);
pub const D3DPSHADECAPS_SPECULARPHONGMONO = @as(i32, 1024);
pub const D3DPSHADECAPS_SPECULARPHONGRGB = @as(i32, 2048);
pub const D3DPSHADECAPS_ALPHAFLATBLEND = @as(i32, 4096);
pub const D3DPSHADECAPS_ALPHAFLATSTIPPLED = @as(i32, 8192);
pub const D3DPSHADECAPS_ALPHAGOURAUDBLEND = @as(i32, 16384);
pub const D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED = @as(i32, 32768);
pub const D3DPSHADECAPS_ALPHAPHONGBLEND = @as(i32, 65536);
pub const D3DPSHADECAPS_ALPHAPHONGSTIPPLED = @as(i32, 131072);
pub const D3DPSHADECAPS_FOGFLAT = @as(i32, 262144);
pub const D3DPSHADECAPS_FOGGOURAUD = @as(i32, 524288);
pub const D3DPSHADECAPS_FOGPHONG = @as(i32, 1048576);
pub const D3DPTEXTURECAPS_PERSPECTIVE = @as(i32, 1);
pub const D3DPTEXTURECAPS_POW2 = @as(i32, 2);
pub const D3DPTEXTURECAPS_ALPHA = @as(i32, 4);
pub const D3DPTEXTURECAPS_TRANSPARENCY = @as(i32, 8);
pub const D3DPTEXTURECAPS_BORDER = @as(i32, 16);
pub const D3DPTEXTURECAPS_SQUAREONLY = @as(i32, 32);
pub const D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE = @as(i32, 64);
pub const D3DPTEXTURECAPS_ALPHAPALETTE = @as(i32, 128);
pub const D3DPTEXTURECAPS_NONPOW2CONDITIONAL = @as(i32, 256);
pub const D3DPTEXTURECAPS_PROJECTED = @as(i32, 1024);
pub const D3DPTEXTURECAPS_CUBEMAP = @as(i32, 2048);
pub const D3DPTEXTURECAPS_COLORKEYBLEND = @as(i32, 4096);
pub const D3DPTFILTERCAPS_NEAREST = @as(i32, 1);
pub const D3DPTFILTERCAPS_LINEAR = @as(i32, 2);
pub const D3DPTFILTERCAPS_MIPNEAREST = @as(i32, 4);
pub const D3DPTFILTERCAPS_MIPLINEAR = @as(i32, 8);
pub const D3DPTFILTERCAPS_LINEARMIPNEAREST = @as(i32, 16);
pub const D3DPTFILTERCAPS_LINEARMIPLINEAR = @as(i32, 32);
pub const D3DPTFILTERCAPS_MINFPOINT = @as(i32, 256);
pub const D3DPTFILTERCAPS_MINFLINEAR = @as(i32, 512);
pub const D3DPTFILTERCAPS_MINFANISOTROPIC = @as(i32, 1024);
pub const D3DPTFILTERCAPS_MIPFPOINT = @as(i32, 65536);
pub const D3DPTFILTERCAPS_MIPFLINEAR = @as(i32, 131072);
pub const D3DPTFILTERCAPS_MAGFPOINT = @as(i32, 16777216);
pub const D3DPTFILTERCAPS_MAGFLINEAR = @as(i32, 33554432);
pub const D3DPTFILTERCAPS_MAGFANISOTROPIC = @as(i32, 67108864);
pub const D3DPTFILTERCAPS_MAGFAFLATCUBIC = @as(i32, 134217728);
pub const D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC = @as(i32, 268435456);
pub const D3DPTBLENDCAPS_DECAL = @as(i32, 1);
pub const D3DPTBLENDCAPS_MODULATE = @as(i32, 2);
pub const D3DPTBLENDCAPS_DECALALPHA = @as(i32, 4);
pub const D3DPTBLENDCAPS_MODULATEALPHA = @as(i32, 8);
pub const D3DPTBLENDCAPS_DECALMASK = @as(i32, 16);
pub const D3DPTBLENDCAPS_MODULATEMASK = @as(i32, 32);
pub const D3DPTBLENDCAPS_COPY = @as(i32, 64);
pub const D3DPTBLENDCAPS_ADD = @as(i32, 128);
pub const D3DPTADDRESSCAPS_WRAP = @as(i32, 1);
pub const D3DPTADDRESSCAPS_MIRROR = @as(i32, 2);
pub const D3DPTADDRESSCAPS_CLAMP = @as(i32, 4);
pub const D3DPTADDRESSCAPS_BORDER = @as(i32, 8);
pub const D3DPTADDRESSCAPS_INDEPENDENTUV = @as(i32, 16);
pub const D3DSTENCILCAPS_KEEP = @as(i32, 1);
pub const D3DSTENCILCAPS_ZERO = @as(i32, 2);
pub const D3DSTENCILCAPS_REPLACE = @as(i32, 4);
pub const D3DSTENCILCAPS_INCRSAT = @as(i32, 8);
pub const D3DSTENCILCAPS_DECRSAT = @as(i32, 16);
pub const D3DSTENCILCAPS_INVERT = @as(i32, 32);
pub const D3DSTENCILCAPS_INCR = @as(i32, 64);
pub const D3DSTENCILCAPS_DECR = @as(i32, 128);
pub const D3DTEXOPCAPS_DISABLE = @as(i32, 1);
pub const D3DTEXOPCAPS_SELECTARG1 = @as(i32, 2);
pub const D3DTEXOPCAPS_SELECTARG2 = @as(i32, 4);
pub const D3DTEXOPCAPS_MODULATE = @as(i32, 8);
pub const D3DTEXOPCAPS_MODULATE2X = @as(i32, 16);
pub const D3DTEXOPCAPS_MODULATE4X = @as(i32, 32);
pub const D3DTEXOPCAPS_ADD = @as(i32, 64);
pub const D3DTEXOPCAPS_ADDSIGNED = @as(i32, 128);
pub const D3DTEXOPCAPS_ADDSIGNED2X = @as(i32, 256);
pub const D3DTEXOPCAPS_SUBTRACT = @as(i32, 512);
pub const D3DTEXOPCAPS_ADDSMOOTH = @as(i32, 1024);
pub const D3DTEXOPCAPS_BLENDDIFFUSEALPHA = @as(i32, 2048);
pub const D3DTEXOPCAPS_BLENDTEXTUREALPHA = @as(i32, 4096);
pub const D3DTEXOPCAPS_BLENDFACTORALPHA = @as(i32, 8192);
pub const D3DTEXOPCAPS_BLENDTEXTUREALPHAPM = @as(i32, 16384);
pub const D3DTEXOPCAPS_BLENDCURRENTALPHA = @as(i32, 32768);
pub const D3DTEXOPCAPS_PREMODULATE = @as(i32, 65536);
pub const D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR = @as(i32, 131072);
pub const D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA = @as(i32, 262144);
pub const D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR = @as(i32, 524288);
pub const D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA = @as(i32, 1048576);
pub const D3DTEXOPCAPS_BUMPENVMAP = @as(i32, 2097152);
pub const D3DTEXOPCAPS_BUMPENVMAPLUMINANCE = @as(i32, 4194304);
pub const D3DTEXOPCAPS_DOTPRODUCT3 = @as(i32, 8388608);
pub const D3DFVFCAPS_TEXCOORDCOUNTMASK = @as(i32, 65535);
pub const D3DFVFCAPS_DONOTSTRIPELEMENTS = @as(i32, 524288);
pub const D3DDD_COLORMODEL = @as(i32, 1);
pub const D3DDD_DEVCAPS = @as(i32, 2);
pub const D3DDD_TRANSFORMCAPS = @as(i32, 4);
pub const D3DDD_LIGHTINGCAPS = @as(i32, 8);
pub const D3DDD_BCLIPPING = @as(i32, 16);
pub const D3DDD_LINECAPS = @as(i32, 32);
pub const D3DDD_TRICAPS = @as(i32, 64);
pub const D3DDD_DEVICERENDERBITDEPTH = @as(i32, 128);
pub const D3DDD_DEVICEZBUFFERBITDEPTH = @as(i32, 256);
pub const D3DDD_MAXBUFFERSIZE = @as(i32, 512);
pub const D3DDD_MAXVERTEXCOUNT = @as(i32, 1024);
pub const D3DDEVCAPS_FLOATTLVERTEX = @as(i32, 1);
pub const D3DDEVCAPS_SORTINCREASINGZ = @as(i32, 2);
pub const D3DDEVCAPS_SORTDECREASINGZ = @as(i32, 4);
pub const D3DDEVCAPS_SORTEXACT = @as(i32, 8);
pub const D3DDEVCAPS_EXECUTESYSTEMMEMORY = @as(i32, 16);
pub const D3DDEVCAPS_EXECUTEVIDEOMEMORY = @as(i32, 32);
pub const D3DDEVCAPS_TLVERTEXSYSTEMMEMORY = @as(i32, 64);
pub const D3DDEVCAPS_TLVERTEXVIDEOMEMORY = @as(i32, 128);
pub const D3DDEVCAPS_TEXTURESYSTEMMEMORY = @as(i32, 256);
pub const D3DDEVCAPS_TEXTUREVIDEOMEMORY = @as(i32, 512);
pub const D3DDEVCAPS_DRAWPRIMTLVERTEX = @as(i32, 1024);
pub const D3DDEVCAPS_CANRENDERAFTERFLIP = @as(i32, 2048);
pub const D3DDEVCAPS_TEXTURENONLOCALVIDMEM = @as(i32, 4096);
pub const D3DDEVCAPS_DRAWPRIMITIVES2 = @as(i32, 8192);
pub const D3DDEVCAPS_SEPARATETEXTUREMEMORIES = @as(i32, 16384);
pub const D3DDEVCAPS_DRAWPRIMITIVES2EX = @as(i32, 32768);
pub const D3DDEVCAPS_HWTRANSFORMANDLIGHT = @as(i32, 65536);
pub const D3DDEVCAPS_CANBLTSYSTONONLOCAL = @as(i32, 131072);
pub const D3DDEVCAPS_HWRASTERIZATION = @as(i32, 524288);
pub const D3DVTXPCAPS_TEXGEN = @as(i32, 1);
pub const D3DVTXPCAPS_MATERIALSOURCE7 = @as(i32, 2);
pub const D3DVTXPCAPS_VERTEXFOG = @as(i32, 4);
pub const D3DVTXPCAPS_DIRECTIONALLIGHTS = @as(i32, 8);
pub const D3DVTXPCAPS_POSITIONALLIGHTS = @as(i32, 16);
pub const D3DVTXPCAPS_LOCALVIEWER = @as(i32, 32);
pub const D3DFDS_COLORMODEL = @as(i32, 1);
pub const D3DFDS_GUID = @as(i32, 2);
pub const D3DFDS_HARDWARE = @as(i32, 4);
pub const D3DFDS_TRIANGLES = @as(i32, 8);
pub const D3DFDS_LINES = @as(i32, 16);
pub const D3DFDS_MISCCAPS = @as(i32, 32);
pub const D3DFDS_RASTERCAPS = @as(i32, 64);
pub const D3DFDS_ZCMPCAPS = @as(i32, 128);
pub const D3DFDS_ALPHACMPCAPS = @as(i32, 256);
pub const D3DFDS_SRCBLENDCAPS = @as(i32, 512);
pub const D3DFDS_DSTBLENDCAPS = @as(i32, 1024);
pub const D3DFDS_SHADECAPS = @as(i32, 2048);
pub const D3DFDS_TEXTURECAPS = @as(i32, 4096);
pub const D3DFDS_TEXTUREFILTERCAPS = @as(i32, 8192);
pub const D3DFDS_TEXTUREBLENDCAPS = @as(i32, 16384);
pub const D3DFDS_TEXTUREADDRESSCAPS = @as(i32, 32768);
pub const D3DDEB_BUFSIZE = @as(i32, 1);
pub const D3DDEB_CAPS = @as(i32, 2);
pub const D3DDEB_LPDATA = @as(i32, 4);
pub const D3DDEBCAPS_SYSTEMMEMORY = @as(i32, 1);
pub const D3DDEBCAPS_VIDEOMEMORY = @as(i32, 2);
pub const D3DMAXUSERCLIPPLANES = @as(u32, 32);
pub const D3DCLIPPLANE0 = @as(u32, 1);
pub const D3DCLIPPLANE1 = @as(u32, 2);
pub const D3DCLIPPLANE2 = @as(u32, 4);
pub const D3DCLIPPLANE3 = @as(u32, 8);
pub const D3DCLIPPLANE4 = @as(u32, 16);
pub const D3DCLIPPLANE5 = @as(u32, 32);
pub const D3DCLIP_LEFT = @as(i32, 1);
pub const D3DCLIP_RIGHT = @as(i32, 2);
pub const D3DCLIP_TOP = @as(i32, 4);
pub const D3DCLIP_BOTTOM = @as(i32, 8);
pub const D3DCLIP_FRONT = @as(i32, 16);
pub const D3DCLIP_BACK = @as(i32, 32);
pub const D3DCLIP_GEN0 = @as(i32, 64);
pub const D3DCLIP_GEN1 = @as(i32, 128);
pub const D3DCLIP_GEN2 = @as(i32, 256);
pub const D3DCLIP_GEN3 = @as(i32, 512);
pub const D3DCLIP_GEN4 = @as(i32, 1024);
pub const D3DCLIP_GEN5 = @as(i32, 2048);
pub const D3DSTATUS_CLIPINTERSECTIONLEFT = @as(i32, 4096);
pub const D3DSTATUS_CLIPINTERSECTIONRIGHT = @as(i32, 8192);
pub const D3DSTATUS_CLIPINTERSECTIONTOP = @as(i32, 16384);
pub const D3DSTATUS_CLIPINTERSECTIONBOTTOM = @as(i32, 32768);
pub const D3DSTATUS_CLIPINTERSECTIONFRONT = @as(i32, 65536);
pub const D3DSTATUS_CLIPINTERSECTIONBACK = @as(i32, 131072);
pub const D3DSTATUS_CLIPINTERSECTIONGEN0 = @as(i32, 262144);
pub const D3DSTATUS_CLIPINTERSECTIONGEN1 = @as(i32, 524288);
pub const D3DSTATUS_CLIPINTERSECTIONGEN2 = @as(i32, 1048576);
pub const D3DSTATUS_CLIPINTERSECTIONGEN3 = @as(i32, 2097152);
pub const D3DSTATUS_CLIPINTERSECTIONGEN4 = @as(i32, 4194304);
pub const D3DSTATUS_CLIPINTERSECTIONGEN5 = @as(i32, 8388608);
pub const D3DSTATUS_ZNOTVISIBLE = @as(i32, 16777216);
pub const D3DTRANSFORM_CLIPPED = @as(i32, 1);
pub const D3DTRANSFORM_UNCLIPPED = @as(i32, 2);
pub const D3DLIGHT_ACTIVE = @as(u32, 1);
pub const D3DLIGHT_NO_SPECULAR = @as(u32, 2);
pub const D3DCOLOR_MONO = @as(u32, 1);
pub const D3DCOLOR_RGB = @as(u32, 2);
pub const D3DCLEAR_TARGET = @as(i32, 1);
pub const D3DCLEAR_ZBUFFER = @as(i32, 2);
pub const D3DCLEAR_STENCIL = @as(i32, 4);
pub const D3DSTATE_OVERRIDE_BIAS = @as(u32, 256);
pub const D3DRENDERSTATE_WRAPBIAS = @as(u32, 128);
pub const D3DWRAP_U = @as(i32, 1);
pub const D3DWRAP_V = @as(i32, 2);
pub const D3DWRAPCOORD_0 = @as(i32, 1);
pub const D3DWRAPCOORD_1 = @as(i32, 2);
pub const D3DWRAPCOORD_2 = @as(i32, 4);
pub const D3DWRAPCOORD_3 = @as(i32, 8);
pub const D3DPROCESSVERTICES_TRANSFORMLIGHT = @as(i32, 0);
pub const D3DPROCESSVERTICES_TRANSFORM = @as(i32, 1);
pub const D3DPROCESSVERTICES_COPY = @as(i32, 2);
pub const D3DPROCESSVERTICES_OPMASK = @as(i32, 7);
pub const D3DPROCESSVERTICES_UPDATEEXTENTS = @as(i32, 8);
pub const D3DPROCESSVERTICES_NOCOLOR = @as(i32, 16);
pub const D3DTSS_TCI_PASSTHRU = @as(u32, 0);
pub const D3DTSS_TCI_CAMERASPACENORMAL = @as(u32, 65536);
pub const D3DTSS_TCI_CAMERASPACEPOSITION = @as(u32, 131072);
pub const D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR = @as(u32, 196608);
pub const D3DTA_SELECTMASK = @as(u32, 15);
pub const D3DTA_DIFFUSE = @as(u32, 0);
pub const D3DTA_CURRENT = @as(u32, 1);
pub const D3DTA_TEXTURE = @as(u32, 2);
pub const D3DTA_TFACTOR = @as(u32, 3);
pub const D3DTA_SPECULAR = @as(u32, 4);
pub const D3DTA_COMPLEMENT = @as(u32, 16);
pub const D3DTA_ALPHAREPLICATE = @as(u32, 32);
pub const D3DTRIFLAG_START = @as(i32, 0);
pub const D3DTRIFLAG_ODD = @as(i32, 30);
pub const D3DTRIFLAG_EVEN = @as(i32, 31);
pub const D3DTRIFLAG_EDGEENABLE1 = @as(i32, 256);
pub const D3DTRIFLAG_EDGEENABLE2 = @as(i32, 512);
pub const D3DTRIFLAG_EDGEENABLE3 = @as(i32, 1024);
pub const D3DSETSTATUS_STATUS = @as(i32, 1);
pub const D3DSETSTATUS_EXTENTS = @as(i32, 2);
pub const D3DCLIPSTATUS_STATUS = @as(i32, 1);
pub const D3DCLIPSTATUS_EXTENTS2 = @as(i32, 2);
pub const D3DCLIPSTATUS_EXTENTS3 = @as(i32, 4);
pub const D3DEXECUTE_CLIPPED = @as(i32, 1);
pub const D3DEXECUTE_UNCLIPPED = @as(i32, 2);
pub const D3DPAL_FREE = @as(u32, 0);
pub const D3DPAL_READONLY = @as(u32, 64);
pub const D3DPAL_RESERVED = @as(u32, 128);
pub const D3DVBCAPS_SYSTEMMEMORY = @as(i32, 2048);
pub const D3DVBCAPS_WRITEONLY = @as(i32, 65536);
pub const D3DVBCAPS_OPTIMIZED = @as(i32, -2147483648);
pub const D3DVBCAPS_DONOTCLIP = @as(i32, 1);
pub const D3DVOP_LIGHT = @as(u32, 1024);
pub const D3DVOP_TRANSFORM = @as(u32, 1);
pub const D3DVOP_CLIP = @as(u32, 4);
pub const D3DVOP_EXTENTS = @as(u32, 8);
pub const D3DPV_DONOTCOPYDATA = @as(u32, 1);
pub const D3DFVF_RESERVED0 = @as(u32, 1);
pub const D3DFVF_POSITION_MASK = @as(u32, 14);
pub const D3DFVF_XYZ = @as(u32, 2);
pub const D3DFVF_XYZRHW = @as(u32, 4);
pub const D3DFVF_XYZB1 = @as(u32, 6);
pub const D3DFVF_XYZB2 = @as(u32, 8);
pub const D3DFVF_XYZB3 = @as(u32, 10);
pub const D3DFVF_XYZB4 = @as(u32, 12);
pub const D3DFVF_XYZB5 = @as(u32, 14);
pub const D3DFVF_NORMAL = @as(u32, 16);
pub const D3DFVF_RESERVED1 = @as(u32, 32);
pub const D3DFVF_DIFFUSE = @as(u32, 64);
pub const D3DFVF_SPECULAR = @as(u32, 128);
pub const D3DFVF_TEXCOUNT_MASK = @as(u32, 3840);
pub const D3DFVF_TEXCOUNT_SHIFT = @as(u32, 8);
pub const D3DFVF_TEX0 = @as(u32, 0);
pub const D3DFVF_TEX1 = @as(u32, 256);
pub const D3DFVF_TEX2 = @as(u32, 512);
pub const D3DFVF_TEX3 = @as(u32, 768);
pub const D3DFVF_TEX4 = @as(u32, 1024);
pub const D3DFVF_TEX5 = @as(u32, 1280);
pub const D3DFVF_TEX6 = @as(u32, 1536);
pub const D3DFVF_TEX7 = @as(u32, 1792);
pub const D3DFVF_TEX8 = @as(u32, 2048);
pub const D3DFVF_RESERVED2 = @as(u32, 61440);
pub const D3DDP_MAXTEXCOORD = @as(u32, 8);
pub const D3DVIS_INSIDE_FRUSTUM = @as(u32, 0);
pub const D3DVIS_INTERSECT_FRUSTUM = @as(u32, 1);
pub const D3DVIS_OUTSIDE_FRUSTUM = @as(u32, 2);
pub const D3DVIS_INSIDE_LEFT = @as(u32, 0);
pub const D3DVIS_INTERSECT_LEFT = @as(u32, 4);
pub const D3DVIS_OUTSIDE_LEFT = @as(u32, 8);
pub const D3DVIS_INSIDE_RIGHT = @as(u32, 0);
pub const D3DVIS_INTERSECT_RIGHT = @as(u32, 16);
pub const D3DVIS_OUTSIDE_RIGHT = @as(u32, 32);
pub const D3DVIS_INSIDE_TOP = @as(u32, 0);
pub const D3DVIS_INTERSECT_TOP = @as(u32, 64);
pub const D3DVIS_OUTSIDE_TOP = @as(u32, 128);
pub const D3DVIS_INSIDE_BOTTOM = @as(u32, 0);
pub const D3DVIS_INTERSECT_BOTTOM = @as(u32, 256);
pub const D3DVIS_OUTSIDE_BOTTOM = @as(u32, 512);
pub const D3DVIS_INSIDE_NEAR = @as(u32, 0);
pub const D3DVIS_INTERSECT_NEAR = @as(u32, 1024);
pub const D3DVIS_OUTSIDE_NEAR = @as(u32, 2048);
pub const D3DVIS_INSIDE_FAR = @as(u32, 0);
pub const D3DVIS_INTERSECT_FAR = @as(u32, 4096);
pub const D3DVIS_OUTSIDE_FAR = @as(u32, 8192);
pub const D3DVIS_MASK_FRUSTUM = @as(u32, 3);
pub const D3DVIS_MASK_LEFT = @as(u32, 12);
pub const D3DVIS_MASK_RIGHT = @as(u32, 48);
pub const D3DVIS_MASK_TOP = @as(u32, 192);
pub const D3DVIS_MASK_BOTTOM = @as(u32, 768);
pub const D3DVIS_MASK_NEAR = @as(u32, 3072);
pub const D3DVIS_MASK_FAR = @as(u32, 12288);
pub const D3DDEVINFOID_TEXTUREMANAGER = @as(u32, 1);
pub const D3DDEVINFOID_D3DTEXTUREMANAGER = @as(u32, 2);
pub const D3DDEVINFOID_TEXTURING = @as(u32, 3);
pub const D3DFVF_TEXTUREFORMAT2 = @as(u32, 0);
pub const D3DFVF_TEXTUREFORMAT1 = @as(u32, 3);
pub const D3DFVF_TEXTUREFORMAT3 = @as(u32, 1);
pub const D3DFVF_TEXTUREFORMAT4 = @as(u32, 2);
pub const DDVPTYPE_E_HREFH_VREFH = Guid.initString("54f39980-da60-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_E_HREFH_VREFL = Guid.initString("92783220-da60-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_E_HREFL_VREFH = Guid.initString("a07a02e0-da60-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_E_HREFL_VREFL = Guid.initString("e09c77e0-da60-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_CCIR656 = Guid.initString("fca326a0-da60-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_BROOKTREE = Guid.initString("1352a560-da61-11cf-9b06-00a0c903a3b8");
pub const DDVPTYPE_PHILIPS = Guid.initString("332cf160-da61-11cf-9b06-00a0c903a3b8");
pub const DDVPD_WIDTH = @as(i32, 1);
pub const DDVPD_HEIGHT = @as(i32, 2);
pub const DDVPD_ID = @as(i32, 4);
pub const DDVPD_CAPS = @as(i32, 8);
pub const DDVPD_FX = @as(i32, 16);
pub const DDVPD_AUTOFLIP = @as(i32, 32);
pub const DDVPD_ALIGN = @as(i32, 64);
pub const DDVPD_PREFERREDAUTOFLIP = @as(i32, 128);
pub const DDVPD_FILTERQUALITY = @as(i32, 256);
pub const DDVPCONNECT_DOUBLECLOCK = @as(i32, 1);
pub const DDVPCONNECT_VACT = @as(i32, 2);
pub const DDVPCONNECT_INVERTPOLARITY = @as(i32, 4);
pub const DDVPCONNECT_DISCARDSVREFDATA = @as(i32, 8);
pub const DDVPCONNECT_HALFLINE = @as(i32, 16);
pub const DDVPCONNECT_INTERLACED = @as(i32, 32);
pub const DDVPCONNECT_SHAREEVEN = @as(i32, 64);
pub const DDVPCONNECT_SHAREODD = @as(i32, 128);
pub const DDVPCAPS_AUTOFLIP = @as(i32, 1);
pub const DDVPCAPS_INTERLACED = @as(i32, 2);
pub const DDVPCAPS_NONINTERLACED = @as(i32, 4);
pub const DDVPCAPS_READBACKFIELD = @as(i32, 8);
pub const DDVPCAPS_READBACKLINE = @as(i32, 16);
pub const DDVPCAPS_SHAREABLE = @as(i32, 32);
pub const DDVPCAPS_SKIPEVENFIELDS = @as(i32, 64);
pub const DDVPCAPS_SKIPODDFIELDS = @as(i32, 128);
pub const DDVPCAPS_SYNCMASTER = @as(i32, 256);
pub const DDVPCAPS_VBISURFACE = @as(i32, 512);
pub const DDVPCAPS_COLORCONTROL = @as(i32, 1024);
pub const DDVPCAPS_OVERSAMPLEDVBI = @as(i32, 2048);
pub const DDVPCAPS_SYSTEMMEMORY = @as(i32, 4096);
pub const DDVPCAPS_VBIANDVIDEOINDEPENDENT = @as(i32, 8192);
pub const DDVPCAPS_HARDWAREDEINTERLACE = @as(i32, 16384);
pub const DDVPFX_CROPTOPDATA = @as(i32, 1);
pub const DDVPFX_CROPX = @as(i32, 2);
pub const DDVPFX_CROPY = @as(i32, 4);
pub const DDVPFX_INTERLEAVE = @as(i32, 8);
pub const DDVPFX_MIRRORLEFTRIGHT = @as(i32, 16);
pub const DDVPFX_MIRRORUPDOWN = @as(i32, 32);
pub const DDVPFX_PRESHRINKX = @as(i32, 64);
pub const DDVPFX_PRESHRINKY = @as(i32, 128);
pub const DDVPFX_PRESHRINKXB = @as(i32, 256);
pub const DDVPFX_PRESHRINKYB = @as(i32, 512);
pub const DDVPFX_PRESHRINKXS = @as(i32, 1024);
pub const DDVPFX_PRESHRINKYS = @as(i32, 2048);
pub const DDVPFX_PRESTRETCHX = @as(i32, 4096);
pub const DDVPFX_PRESTRETCHY = @as(i32, 8192);
pub const DDVPFX_PRESTRETCHXN = @as(i32, 16384);
pub const DDVPFX_PRESTRETCHYN = @as(i32, 32768);
pub const DDVPFX_VBICONVERT = @as(i32, 65536);
pub const DDVPFX_VBINOSCALE = @as(i32, 131072);
pub const DDVPFX_IGNOREVBIXCROP = @as(i32, 262144);
pub const DDVPFX_VBINOINTERLEAVE = @as(i32, 524288);
pub const DDVP_AUTOFLIP = @as(i32, 1);
pub const DDVP_CONVERT = @as(i32, 2);
pub const DDVP_CROP = @as(i32, 4);
pub const DDVP_INTERLEAVE = @as(i32, 8);
pub const DDVP_MIRRORLEFTRIGHT = @as(i32, 16);
pub const DDVP_MIRRORUPDOWN = @as(i32, 32);
pub const DDVP_PRESCALE = @as(i32, 64);
pub const DDVP_SKIPEVENFIELDS = @as(i32, 128);
pub const DDVP_SKIPODDFIELDS = @as(i32, 256);
pub const DDVP_SYNCMASTER = @as(i32, 512);
pub const DDVP_VBICONVERT = @as(i32, 1024);
pub const DDVP_VBINOSCALE = @as(i32, 2048);
pub const DDVP_OVERRIDEBOBWEAVE = @as(i32, 4096);
pub const DDVP_IGNOREVBIXCROP = @as(i32, 8192);
pub const DDVP_VBINOINTERLEAVE = @as(i32, 16384);
pub const DDVP_HARDWAREDEINTERLACE = @as(i32, 32768);
pub const DDVPFORMAT_VIDEO = @as(i32, 1);
pub const DDVPFORMAT_VBI = @as(i32, 2);
pub const DDVPTARGET_VIDEO = @as(i32, 1);
pub const DDVPTARGET_VBI = @as(i32, 2);
pub const DDVPWAIT_BEGIN = @as(i32, 1);
pub const DDVPWAIT_END = @as(i32, 2);
pub const DDVPWAIT_LINE = @as(i32, 3);
pub const DDVPFLIP_VIDEO = @as(i32, 1);
pub const DDVPFLIP_VBI = @as(i32, 2);
pub const DDVPSQ_NOSIGNAL = @as(i32, 1);
pub const DDVPSQ_SIGNALOK = @as(i32, 2);
pub const DDVPB_VIDEOPORT = @as(i32, 1);
pub const DDVPB_OVERLAY = @as(i32, 2);
pub const DDVPB_TYPE = @as(i32, 4);
pub const DDVPBCAPS_SOURCE = @as(i32, 1);
pub const DDVPBCAPS_DESTINATION = @as(i32, 2);
pub const DDVPCREATE_VBIONLY = @as(i32, 1);
pub const DDVPCREATE_VIDEOONLY = @as(i32, 2);
pub const DDVPSTATUS_VBIONLY = @as(i32, 1);
pub const DDVPSTATUS_VIDEOONLY = @as(i32, 2);
pub const GUID_MiscellaneousCallbacks = Guid.initString("efd60cc0-49e7-11d0-889d-00aa00bbb76a");
pub const GUID_Miscellaneous2Callbacks = Guid.initString("406b2f00-3e5a-11d1-b640-00aa00a1f96a");
pub const GUID_VideoPortCallbacks = Guid.initString("efd60cc1-49e7-11d0-889d-00aa00bbb76a");
pub const GUID_ColorControlCallbacks = Guid.initString("efd60cc2-49e7-11d0-889d-00aa00bbb76a");
pub const GUID_MotionCompCallbacks = Guid.initString("b1122b40-5da5-11d1-8fcf-00c04fc29b4e");
pub const GUID_VideoPortCaps = Guid.initString("efd60cc3-49e7-11d0-889d-00aa00bbb76a");
pub const GUID_D3DCaps = Guid.initString("7bf06991-8794-11d0-9139-080036d2ef02");
pub const GUID_D3DExtendedCaps = Guid.initString("7de41f80-9d93-11d0-89ab-00a0c9054129");
pub const GUID_D3DCallbacks = Guid.initString("7bf06990-8794-11d0-9139-080036d2ef02");
pub const GUID_D3DCallbacks2 = Guid.initString("0ba584e1-70b6-11d0-889d-00aa00bbb76a");
pub const GUID_D3DCallbacks3 = Guid.initString("ddf41230-ec0a-11d0-a9b6-00aa00c0993e");
pub const GUID_NonLocalVidMemCaps = Guid.initString("86c4fa80-8d84-11d0-94e8-00c04fc34137");
pub const GUID_KernelCallbacks = Guid.initString("80863800-6b06-11d0-9b06-00a0c903a3b8");
pub const GUID_KernelCaps = Guid.initString("ffaa7540-7aa8-11d0-9b06-00a0c903a3b8");
pub const GUID_ZPixelFormats = Guid.initString("93869880-36cf-11d1-9b1b-00aa00bbb8ae");
pub const GUID_DDMoreCaps = Guid.initString("880baf30-b030-11d0-8ea7-00609797ea5b");
pub const GUID_D3DParseUnknownCommandCallback = Guid.initString("2e04ffa0-98e4-11d1-8ce1-00a0c90629a8");
pub const GUID_NTCallbacks = Guid.initString("6fe9ecde-df89-11d1-9db0-0060082771ba");
pub const GUID_DDMoreSurfaceCaps = Guid.initString("3b8a0466-f269-11d1-880b-00c04fd930c5");
pub const GUID_GetHeapAlignment = Guid.initString("42e02f16-7b41-11d2-8bff-00a0c983eaf6");
pub const GUID_UpdateNonLocalHeap = Guid.initString("42e02f17-7b41-11d2-8bff-00a0c983eaf6");
pub const GUID_NTPrivateDriverCaps = Guid.initString("fad16a23-7b66-11d2-83d7-00c04f7ce58c");
pub const GUID_DDStereoMode = Guid.initString("f828169c-a8e8-11d2-a1f2-00a0c983eaf6");
pub const GUID_VPE2Callbacks = Guid.initString("52882147-2d47-469a-a0d1-03455890f6c8");
pub const MAX_AUTOFLIP_BUFFERS = @as(u32, 10);
pub const DDPF_D3DFORMAT = @as(i32, 2097152);
pub const D3DFORMAT_OP_TEXTURE = @as(i32, 1);
pub const D3DFORMAT_OP_VOLUMETEXTURE = @as(i32, 2);
pub const D3DFORMAT_OP_CUBETEXTURE = @as(i32, 4);
pub const D3DFORMAT_OP_OFFSCREEN_RENDERTARGET = @as(i32, 8);
pub const D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET = @as(i32, 16);
pub const D3DFORMAT_OP_ZSTENCIL = @as(i32, 64);
pub const D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH = @as(i32, 128);
pub const D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET = @as(i32, 256);
pub const D3DFORMAT_OP_DISPLAYMODE = @as(i32, 1024);
pub const D3DFORMAT_OP_3DACCELERATION = @as(i32, 2048);
pub const D3DFORMAT_OP_PIXELSIZE = @as(i32, 4096);
pub const D3DFORMAT_OP_CONVERT_TO_ARGB = @as(i32, 8192);
pub const D3DFORMAT_OP_OFFSCREENPLAIN = @as(i32, 16384);
pub const D3DFORMAT_OP_SRGBREAD = @as(i32, 32768);
pub const D3DFORMAT_OP_BUMPMAP = @as(i32, 65536);
pub const D3DFORMAT_OP_DMAP = @as(i32, 131072);
pub const D3DFORMAT_OP_NOFILTER = @as(i32, 262144);
pub const D3DFORMAT_MEMBEROFGROUP_ARGB = @as(i32, 524288);
pub const D3DFORMAT_OP_SRGBWRITE = @as(i32, 1048576);
pub const D3DFORMAT_OP_NOALPHABLEND = @as(i32, 2097152);
pub const D3DFORMAT_OP_AUTOGENMIPMAP = @as(i32, 4194304);
pub const D3DFORMAT_OP_VERTEXTEXTURE = @as(i32, 8388608);
pub const D3DFORMAT_OP_NOTEXCOORDWRAPNORMIP = @as(i32, 16777216);
pub const DDHAL_PLEASEALLOC_BLOCKSIZE = @as(i32, 2);
pub const DDHAL_PLEASEALLOC_USERMEM = @as(i32, 4);
pub const VIDMEM_ISLINEAR = @as(i32, 1);
pub const VIDMEM_ISRECTANGULAR = @as(i32, 2);
pub const VIDMEM_ISHEAP = @as(i32, 4);
pub const VIDMEM_ISNONLOCAL = @as(i32, 8);
pub const VIDMEM_ISWC = @as(i32, 16);
pub const VIDMEM_HEAPDISABLED = @as(i32, 32);
pub const DDHAL_CB32_DESTROYDRIVER = @as(i32, 1);
pub const DDHAL_CB32_CREATESURFACE = @as(i32, 2);
pub const DDHAL_CB32_SETCOLORKEY = @as(i32, 4);
pub const DDHAL_CB32_SETMODE = @as(i32, 8);
pub const DDHAL_CB32_WAITFORVERTICALBLANK = @as(i32, 16);
pub const DDHAL_CB32_CANCREATESURFACE = @as(i32, 32);
pub const DDHAL_CB32_CREATEPALETTE = @as(i32, 64);
pub const DDHAL_CB32_GETSCANLINE = @as(i32, 128);
pub const DDHAL_CB32_MAPMEMORY = @as(i32, -2147483648);
pub const DDHAL_MISCCB32_GETAVAILDRIVERMEMORY = @as(i32, 1);
pub const DDHAL_MISC2CB32_ALPHABLT = @as(i32, 1);
pub const DDHAL_MISC2CB32_CREATESURFACEEX = @as(i32, 2);
pub const DDHAL_MISC2CB32_GETDRIVERSTATE = @as(i32, 4);
pub const DDHAL_MISC2CB32_DESTROYDDLOCAL = @as(i32, 8);
pub const DDHAL_CREATESURFACEEX_SWAPHANDLES = @as(i32, 1);
pub const DDHAL_NTCB32_FREEDRIVERMEMORY = @as(i32, 1);
pub const DDHAL_NTCB32_SETEXCLUSIVEMODE = @as(i32, 2);
pub const DDHAL_NTCB32_FLIPTOGDISURFACE = @as(i32, 4);
pub const DDHAL_PALCB32_DESTROYPALETTE = @as(i32, 1);
pub const DDHAL_PALCB32_SETENTRIES = @as(i32, 2);
pub const DDHAL_SURFCB32_DESTROYSURFACE = @as(i32, 1);
pub const DDHAL_SURFCB32_FLIP = @as(i32, 2);
pub const DDHAL_SURFCB32_SETCLIPLIST = @as(i32, 4);
pub const DDHAL_SURFCB32_LOCK = @as(i32, 8);
pub const DDHAL_SURFCB32_UNLOCK = @as(i32, 16);
pub const DDHAL_SURFCB32_BLT = @as(i32, 32);
pub const DDHAL_SURFCB32_SETCOLORKEY = @as(i32, 64);
pub const DDHAL_SURFCB32_ADDATTACHEDSURFACE = @as(i32, 128);
pub const DDHAL_SURFCB32_GETBLTSTATUS = @as(i32, 256);
pub const DDHAL_SURFCB32_GETFLIPSTATUS = @as(i32, 512);
pub const DDHAL_SURFCB32_UPDATEOVERLAY = @as(i32, 1024);
pub const DDHAL_SURFCB32_SETOVERLAYPOSITION = @as(i32, 2048);
pub const DDHAL_SURFCB32_RESERVED4 = @as(i32, 4096);
pub const DDHAL_SURFCB32_SETPALETTE = @as(i32, 8192);
pub const DDHAL_VPORT32_CANCREATEVIDEOPORT = @as(i32, 1);
pub const DDHAL_VPORT32_CREATEVIDEOPORT = @as(i32, 2);
pub const DDHAL_VPORT32_FLIP = @as(i32, 4);
pub const DDHAL_VPORT32_GETBANDWIDTH = @as(i32, 8);
pub const DDHAL_VPORT32_GETINPUTFORMATS = @as(i32, 16);
pub const DDHAL_VPORT32_GETOUTPUTFORMATS = @as(i32, 32);
pub const DDHAL_VPORT32_GETAUTOFLIPSURF = @as(i32, 64);
pub const DDHAL_VPORT32_GETFIELD = @as(i32, 128);
pub const DDHAL_VPORT32_GETLINE = @as(i32, 256);
pub const DDHAL_VPORT32_GETCONNECT = @as(i32, 512);
pub const DDHAL_VPORT32_DESTROY = @as(i32, 1024);
pub const DDHAL_VPORT32_GETFLIPSTATUS = @as(i32, 2048);
pub const DDHAL_VPORT32_UPDATE = @as(i32, 4096);
pub const DDHAL_VPORT32_WAITFORSYNC = @as(i32, 8192);
pub const DDHAL_VPORT32_GETSIGNALSTATUS = @as(i32, 16384);
pub const DDHAL_VPORT32_COLORCONTROL = @as(i32, 32768);
pub const DDHAL_COLOR_COLORCONTROL = @as(i32, 1);
pub const DDHAL_KERNEL_SYNCSURFACEDATA = @as(i32, 1);
pub const DDHAL_KERNEL_SYNCVIDEOPORTDATA = @as(i32, 2);
pub const DDHAL_MOCOMP32_GETGUIDS = @as(u32, 1);
pub const DDHAL_MOCOMP32_GETFORMATS = @as(u32, 2);
pub const DDHAL_MOCOMP32_CREATE = @as(u32, 4);
pub const DDHAL_MOCOMP32_GETCOMPBUFFINFO = @as(u32, 8);
pub const DDHAL_MOCOMP32_GETINTERNALINFO = @as(u32, 16);
pub const DDHAL_MOCOMP32_BEGINFRAME = @as(u32, 32);
pub const DDHAL_MOCOMP32_ENDFRAME = @as(u32, 64);
pub const DDHAL_MOCOMP32_RENDER = @as(u32, 128);
pub const DDHAL_MOCOMP32_QUERYSTATUS = @as(u32, 256);
pub const DDHAL_MOCOMP32_DESTROY = @as(u32, 512);
pub const DDHAL_DRIVER_NOTHANDLED = @as(i32, 0);
pub const DDHAL_DRIVER_HANDLED = @as(i32, 1);
pub const DDHAL_DRIVER_NOCKEYHW = @as(i32, 2);
pub const DDRAWISURF_HASCKEYSRCBLT = @as(i32, 2048);
pub const DDRAWISURF_HASPIXELFORMAT = @as(i32, 8192);
pub const DDRAWISURF_HASOVERLAYDATA = @as(i32, 16384);
pub const DDRAWISURF_FRONTBUFFER = @as(i32, 67108864);
pub const DDRAWISURF_BACKBUFFER = @as(i32, 134217728);
pub const DDRAWISURF_INVALID = @as(i32, 268435456);
pub const DDRAWISURF_DRIVERMANAGED = @as(i32, 1073741824);
pub const ROP_HAS_SOURCE = @as(i32, 1);
pub const ROP_HAS_PATTERN = @as(i32, 2);
pub const DDHAL_EXEBUFCB32_CANCREATEEXEBUF = @as(i32, 1);
pub const DDHAL_EXEBUFCB32_CREATEEXEBUF = @as(i32, 2);
pub const DDHAL_EXEBUFCB32_DESTROYEXEBUF = @as(i32, 4);
pub const DDHAL_EXEBUFCB32_LOCKEXEBUF = @as(i32, 8);
pub const DDHAL_EXEBUFCB32_UNLOCKEXEBUF = @as(i32, 16);
pub const DDHALINFO_GETDRIVERINFOSET = @as(i32, 4);
pub const DDHALINFO_GETDRIVERINFO2 = @as(i32, 8);
pub const DDRAWIVPORT_ON = @as(u32, 1);
pub const DDRAWIVPORT_SOFTWARE_AUTOFLIP = @as(u32, 2);
pub const DDRAWIVPORT_COLORKEYANDINTERP = @as(u32, 4);
pub const DDHAL_PRIVATECAP_ATOMICSURFACECREATION = @as(i32, 1);
pub const DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION = @as(i32, 2);
pub const DDHAL_PRIVATECAP_RESERVED1 = @as(i32, 4);
pub const DDBLT_AFLAGS = @as(i32, -2147483648);
pub const DDABLT_SRCOVERDEST = @as(i32, 1);
pub const DDWAITVB_I_TESTVB = @as(i32, -2147483642);
pub const DDRAWI_VPORTSTART = @as(u32, 1);
pub const DDRAWI_VPORTSTOP = @as(u32, 2);
pub const DDRAWI_VPORTUPDATE = @as(u32, 3);
pub const DDRAWI_VPORTGETCOLOR = @as(u32, 1);
pub const DDRAWI_VPORTSETCOLOR = @as(u32, 2);
pub const DDRAWI_GETCOLOR = @as(u32, 1);
pub const DDRAWI_SETCOLOR = @as(u32, 2);
pub const DDMCQUERY_READ = @as(u32, 1);
pub const FD_ERROR = @as(u32, 4294967295);
pub const DDI_ERROR = @as(u32, 4294967295);
pub const FDM_TYPE_BM_SIDE_CONST = @as(u32, 1);
pub const FDM_TYPE_MAXEXT_EQUAL_BM_SIDE = @as(u32, 2);
pub const FDM_TYPE_CHAR_INC_EQUAL_BM_BASE = @as(u32, 4);
pub const FDM_TYPE_ZERO_BEARINGS = @as(u32, 8);
pub const FDM_TYPE_CONST_BEARINGS = @as(u32, 16);
pub const GS_UNICODE_HANDLES = @as(u32, 1);
pub const GS_8BIT_HANDLES = @as(u32, 2);
pub const GS_16BIT_HANDLES = @as(u32, 4);
pub const FM_VERSION_NUMBER = @as(u32, 0);
pub const FM_TYPE_LICENSED = @as(u32, 2);
pub const FM_READONLY_EMBED = @as(u32, 4);
pub const FM_EDITABLE_EMBED = @as(u32, 8);
pub const FM_INFO_TECH_TRUETYPE = @as(u32, 1);
pub const FM_INFO_TECH_BITMAP = @as(u32, 2);
pub const FM_INFO_TECH_STROKE = @as(u32, 4);
pub const FM_INFO_TECH_OUTLINE_NOT_TRUETYPE = @as(u32, 8);
pub const FM_INFO_ARB_XFORMS = @as(u32, 16);
pub const FM_INFO_1BPP = @as(u32, 32);
pub const FM_INFO_4BPP = @as(u32, 64);
pub const FM_INFO_8BPP = @as(u32, 128);
pub const FM_INFO_16BPP = @as(u32, 256);
pub const FM_INFO_24BPP = @as(u32, 512);
pub const FM_INFO_32BPP = @as(u32, 1024);
pub const FM_INFO_INTEGER_WIDTH = @as(u32, 2048);
pub const FM_INFO_CONSTANT_WIDTH = @as(u32, 4096);
pub const FM_INFO_NOT_CONTIGUOUS = @as(u32, 8192);
pub const FM_INFO_TECH_MM = @as(u32, 16384);
pub const FM_INFO_RETURNS_OUTLINES = @as(u32, 32768);
pub const FM_INFO_RETURNS_STROKES = @as(u32, 65536);
pub const FM_INFO_RETURNS_BITMAPS = @as(u32, 131072);
pub const FM_INFO_DSIG = @as(u32, 262144);
pub const FM_INFO_RIGHT_HANDED = @as(u32, 524288);
pub const FM_INFO_INTEGRAL_SCALING = @as(u32, 1048576);
pub const FM_INFO_90DEGREE_ROTATIONS = @as(u32, 2097152);
pub const FM_INFO_OPTICALLY_FIXED_PITCH = @as(u32, 4194304);
pub const FM_INFO_DO_NOT_ENUMERATE = @as(u32, 8388608);
pub const FM_INFO_ISOTROPIC_SCALING_ONLY = @as(u32, 16777216);
pub const FM_INFO_ANISOTROPIC_SCALING_ONLY = @as(u32, 33554432);
pub const FM_INFO_TECH_CFF = @as(u32, 67108864);
pub const FM_INFO_FAMILY_EQUIV = @as(u32, 134217728);
pub const FM_INFO_DBCS_FIXED_PITCH = @as(u32, 268435456);
pub const FM_INFO_NONNEGATIVE_AC = @as(u32, 536870912);
pub const FM_INFO_IGNORE_TC_RA_ABLE = @as(u32, 1073741824);
pub const FM_INFO_TECH_TYPE1 = @as(u32, 2147483648);
pub const MAXCHARSETS = @as(u32, 16);
pub const FM_PANOSE_CULTURE_LATIN = @as(u32, 0);
pub const FM_SEL_ITALIC = @as(u32, 1);
pub const FM_SEL_UNDERSCORE = @as(u32, 2);
pub const FM_SEL_NEGATIVE = @as(u32, 4);
pub const FM_SEL_OUTLINED = @as(u32, 8);
pub const FM_SEL_STRIKEOUT = @as(u32, 16);
pub const FM_SEL_BOLD = @as(u32, 32);
pub const FM_SEL_REGULAR = @as(u32, 64);
pub const OPENGL_CMD = @as(u32, 4352);
pub const OPENGL_GETINFO = @as(u32, 4353);
pub const WNDOBJ_SETUP = @as(u32, 4354);
pub const DDI_DRIVER_VERSION_NT4 = @as(u32, 131072);
pub const DDI_DRIVER_VERSION_SP3 = @as(u32, 131075);
pub const DDI_DRIVER_VERSION_NT5 = @as(u32, 196608);
pub const DDI_DRIVER_VERSION_NT5_01 = @as(u32, 196864);
pub const DDI_DRIVER_VERSION_NT5_01_SP1 = @as(u32, 196865);
pub const GDI_DRIVER_VERSION = @as(u32, 16384);
pub const INDEX_DrvEnablePDEV = @as(i32, 0);
pub const INDEX_DrvCompletePDEV = @as(i32, 1);
pub const INDEX_DrvDisablePDEV = @as(i32, 2);
pub const INDEX_DrvEnableSurface = @as(i32, 3);
pub const INDEX_DrvDisableSurface = @as(i32, 4);
pub const INDEX_DrvAssertMode = @as(i32, 5);
pub const INDEX_DrvOffset = @as(i32, 6);
pub const INDEX_DrvResetPDEV = @as(i32, 7);
pub const INDEX_DrvDisableDriver = @as(i32, 8);
pub const INDEX_DrvCreateDeviceBitmap = @as(i32, 10);
pub const INDEX_DrvDeleteDeviceBitmap = @as(i32, 11);
pub const INDEX_DrvRealizeBrush = @as(i32, 12);
pub const INDEX_DrvDitherColor = @as(i32, 13);
pub const INDEX_DrvStrokePath = @as(i32, 14);
pub const INDEX_DrvFillPath = @as(i32, 15);
pub const INDEX_DrvStrokeAndFillPath = @as(i32, 16);
pub const INDEX_DrvPaint = @as(i32, 17);
pub const INDEX_DrvBitBlt = @as(i32, 18);
pub const INDEX_DrvCopyBits = @as(i32, 19);
pub const INDEX_DrvStretchBlt = @as(i32, 20);
pub const INDEX_DrvSetPalette = @as(i32, 22);
pub const INDEX_DrvTextOut = @as(i32, 23);
pub const INDEX_DrvEscape = @as(i32, 24);
pub const INDEX_DrvDrawEscape = @as(i32, 25);
pub const INDEX_DrvQueryFont = @as(i32, 26);
pub const INDEX_DrvQueryFontTree = @as(i32, 27);
pub const INDEX_DrvQueryFontData = @as(i32, 28);
pub const INDEX_DrvSetPointerShape = @as(i32, 29);
pub const INDEX_DrvMovePointer = @as(i32, 30);
pub const INDEX_DrvLineTo = @as(i32, 31);
pub const INDEX_DrvSendPage = @as(i32, 32);
pub const INDEX_DrvStartPage = @as(i32, 33);
pub const INDEX_DrvEndDoc = @as(i32, 34);
pub const INDEX_DrvStartDoc = @as(i32, 35);
pub const INDEX_DrvGetGlyphMode = @as(i32, 37);
pub const INDEX_DrvSynchronize = @as(i32, 38);
pub const INDEX_DrvSaveScreenBits = @as(i32, 40);
pub const INDEX_DrvGetModes = @as(i32, 41);
pub const INDEX_DrvFree = @as(i32, 42);
pub const INDEX_DrvDestroyFont = @as(i32, 43);
pub const INDEX_DrvQueryFontCaps = @as(i32, 44);
pub const INDEX_DrvLoadFontFile = @as(i32, 45);
pub const INDEX_DrvUnloadFontFile = @as(i32, 46);
pub const INDEX_DrvFontManagement = @as(i32, 47);
pub const INDEX_DrvQueryTrueTypeTable = @as(i32, 48);
pub const INDEX_DrvQueryTrueTypeOutline = @as(i32, 49);
pub const INDEX_DrvGetTrueTypeFile = @as(i32, 50);
pub const INDEX_DrvQueryFontFile = @as(i32, 51);
pub const INDEX_DrvMovePanning = @as(i32, 52);
pub const INDEX_DrvQueryAdvanceWidths = @as(i32, 53);
pub const INDEX_DrvSetPixelFormat = @as(i32, 54);
pub const INDEX_DrvDescribePixelFormat = @as(i32, 55);
pub const INDEX_DrvSwapBuffers = @as(i32, 56);
pub const INDEX_DrvStartBanding = @as(i32, 57);
pub const INDEX_DrvNextBand = @as(i32, 58);
pub const INDEX_DrvGetDirectDrawInfo = @as(i32, 59);
pub const INDEX_DrvEnableDirectDraw = @as(i32, 60);
pub const INDEX_DrvDisableDirectDraw = @as(i32, 61);
pub const INDEX_DrvQuerySpoolType = @as(i32, 62);
pub const INDEX_DrvIcmCreateColorTransform = @as(i32, 64);
pub const INDEX_DrvIcmDeleteColorTransform = @as(i32, 65);
pub const INDEX_DrvIcmCheckBitmapBits = @as(i32, 66);
pub const INDEX_DrvIcmSetDeviceGammaRamp = @as(i32, 67);
pub const INDEX_DrvGradientFill = @as(i32, 68);
pub const INDEX_DrvStretchBltROP = @as(i32, 69);
pub const INDEX_DrvPlgBlt = @as(i32, 70);
pub const INDEX_DrvAlphaBlend = @as(i32, 71);
pub const INDEX_DrvSynthesizeFont = @as(i32, 72);
pub const INDEX_DrvGetSynthesizedFontFiles = @as(i32, 73);
pub const INDEX_DrvTransparentBlt = @as(i32, 74);
pub const INDEX_DrvQueryPerBandInfo = @as(i32, 75);
pub const INDEX_DrvQueryDeviceSupport = @as(i32, 76);
pub const INDEX_DrvReserved1 = @as(i32, 77);
pub const INDEX_DrvReserved2 = @as(i32, 78);
pub const INDEX_DrvReserved3 = @as(i32, 79);
pub const INDEX_DrvReserved4 = @as(i32, 80);
pub const INDEX_DrvReserved5 = @as(i32, 81);
pub const INDEX_DrvReserved6 = @as(i32, 82);
pub const INDEX_DrvReserved7 = @as(i32, 83);
pub const INDEX_DrvReserved8 = @as(i32, 84);
pub const INDEX_DrvDeriveSurface = @as(i32, 85);
pub const INDEX_DrvQueryGlyphAttrs = @as(i32, 86);
pub const INDEX_DrvNotify = @as(i32, 87);
pub const INDEX_DrvSynchronizeSurface = @as(i32, 88);
pub const INDEX_DrvResetDevice = @as(i32, 89);
pub const INDEX_DrvReserved9 = @as(i32, 90);
pub const INDEX_DrvReserved10 = @as(i32, 91);
pub const INDEX_DrvReserved11 = @as(i32, 92);
pub const INDEX_DrvRenderHint = @as(i32, 93);
pub const INDEX_DrvCreateDeviceBitmapEx = @as(i32, 94);
pub const INDEX_DrvDeleteDeviceBitmapEx = @as(i32, 95);
pub const INDEX_DrvAssociateSharedSurface = @as(i32, 96);
pub const INDEX_DrvSynchronizeRedirectionBitmaps = @as(i32, 97);
pub const INDEX_DrvAccumulateD3DDirtyRect = @as(i32, 98);
pub const INDEX_DrvStartDxInterop = @as(i32, 99);
pub const INDEX_DrvEndDxInterop = @as(i32, 100);
pub const INDEX_DrvLockDisplayArea = @as(i32, 101);
pub const INDEX_DrvUnlockDisplayArea = @as(i32, 102);
pub const INDEX_DrvSurfaceComplete = @as(i32, 103);
pub const INDEX_LAST = @as(i32, 89);
pub const GCAPS_BEZIERS = @as(u32, 1);
pub const GCAPS_GEOMETRICWIDE = @as(u32, 2);
pub const GCAPS_ALTERNATEFILL = @as(u32, 4);
pub const GCAPS_WINDINGFILL = @as(u32, 8);
pub const GCAPS_HALFTONE = @as(u32, 16);
pub const GCAPS_COLOR_DITHER = @as(u32, 32);
pub const GCAPS_HORIZSTRIKE = @as(u32, 64);
pub const GCAPS_VERTSTRIKE = @as(u32, 128);
pub const GCAPS_OPAQUERECT = @as(u32, 256);
pub const GCAPS_VECTORFONT = @as(u32, 512);
pub const GCAPS_MONO_DITHER = @as(u32, 1024);
pub const GCAPS_ASYNCCHANGE = @as(u32, 2048);
pub const GCAPS_ASYNCMOVE = @as(u32, 4096);
pub const GCAPS_DONTJOURNAL = @as(u32, 8192);
pub const GCAPS_DIRECTDRAW = @as(u32, 16384);
pub const GCAPS_ARBRUSHOPAQUE = @as(u32, 32768);
pub const GCAPS_PANNING = @as(u32, 65536);
pub const GCAPS_HIGHRESTEXT = @as(u32, 262144);
pub const GCAPS_PALMANAGED = @as(u32, 524288);
pub const GCAPS_DITHERONREALIZE = @as(u32, 2097152);
pub const GCAPS_NO64BITMEMACCESS = @as(u32, 4194304);
pub const GCAPS_FORCEDITHER = @as(u32, 8388608);
pub const GCAPS_GRAY16 = @as(u32, 16777216);
pub const GCAPS_ICM = @as(u32, 33554432);
pub const GCAPS_CMYKCOLOR = @as(u32, 67108864);
pub const GCAPS_LAYERED = @as(u32, 134217728);
pub const GCAPS_ARBRUSHTEXT = @as(u32, 268435456);
pub const GCAPS_SCREENPRECISION = @as(u32, 536870912);
pub const GCAPS_FONT_RASTERIZER = @as(u32, 1073741824);
pub const GCAPS_NUP = @as(u32, 2147483648);
pub const GCAPS2_JPEGSRC = @as(u32, 1);
pub const GCAPS2_xxxx = @as(u32, 2);
pub const GCAPS2_PNGSRC = @as(u32, 8);
pub const GCAPS2_CHANGEGAMMARAMP = @as(u32, 16);
pub const GCAPS2_ALPHACURSOR = @as(u32, 32);
pub const GCAPS2_SYNCFLUSH = @as(u32, 64);
pub const GCAPS2_SYNCTIMER = @as(u32, 128);
pub const GCAPS2_ICD_MULTIMON = @as(u32, 256);
pub const GCAPS2_MOUSETRAILS = @as(u32, 512);
pub const GCAPS2_RESERVED1 = @as(u32, 1024);
pub const GCAPS2_REMOTEDRIVER = @as(u32, 1024);
pub const GCAPS2_EXCLUDELAYERED = @as(u32, 2048);
pub const GCAPS2_INCLUDEAPIBITMAPS = @as(u32, 4096);
pub const GCAPS2_SHOWHIDDENPOINTER = @as(u32, 8192);
pub const GCAPS2_CLEARTYPE = @as(u32, 16384);
pub const GCAPS2_ACC_DRIVER = @as(u32, 32768);
pub const GCAPS2_BITMAPEXREUSE = @as(u32, 65536);
pub const LA_GEOMETRIC = @as(u32, 1);
pub const LA_ALTERNATE = @as(u32, 2);
pub const LA_STARTGAP = @as(u32, 4);
pub const LA_STYLED = @as(u32, 8);
pub const JOIN_ROUND = @as(i32, 0);
pub const JOIN_BEVEL = @as(i32, 1);
pub const JOIN_MITER = @as(i32, 2);
pub const ENDCAP_ROUND = @as(i32, 0);
pub const ENDCAP_SQUARE = @as(i32, 1);
pub const ENDCAP_BUTT = @as(i32, 2);
pub const PRIMARY_ORDER_ABC = @as(u32, 0);
pub const PRIMARY_ORDER_ACB = @as(u32, 1);
pub const PRIMARY_ORDER_BAC = @as(u32, 2);
pub const PRIMARY_ORDER_BCA = @as(u32, 3);
pub const PRIMARY_ORDER_CBA = @as(u32, 4);
pub const PRIMARY_ORDER_CAB = @as(u32, 5);
pub const HT_PATSIZE_2x2 = @as(u32, 0);
pub const HT_PATSIZE_2x2_M = @as(u32, 1);
pub const HT_PATSIZE_4x4 = @as(u32, 2);
pub const HT_PATSIZE_4x4_M = @as(u32, 3);
pub const HT_PATSIZE_6x6 = @as(u32, 4);
pub const HT_PATSIZE_6x6_M = @as(u32, 5);
pub const HT_PATSIZE_8x8 = @as(u32, 6);
pub const HT_PATSIZE_8x8_M = @as(u32, 7);
pub const HT_PATSIZE_10x10 = @as(u32, 8);
pub const HT_PATSIZE_10x10_M = @as(u32, 9);
pub const HT_PATSIZE_12x12 = @as(u32, 10);
pub const HT_PATSIZE_12x12_M = @as(u32, 11);
pub const HT_PATSIZE_14x14 = @as(u32, 12);
pub const HT_PATSIZE_14x14_M = @as(u32, 13);
pub const HT_PATSIZE_16x16 = @as(u32, 14);
pub const HT_PATSIZE_16x16_M = @as(u32, 15);
pub const HT_PATSIZE_SUPERCELL = @as(u32, 16);
pub const HT_PATSIZE_SUPERCELL_M = @as(u32, 17);
pub const HT_PATSIZE_USER = @as(u32, 18);
pub const HT_USERPAT_CX_MIN = @as(u32, 4);
pub const HT_USERPAT_CX_MAX = @as(u32, 256);
pub const HT_USERPAT_CY_MIN = @as(u32, 4);
pub const HT_USERPAT_CY_MAX = @as(u32, 256);
pub const HT_FORMAT_1BPP = @as(u32, 0);
pub const HT_FORMAT_4BPP = @as(u32, 2);
pub const HT_FORMAT_4BPP_IRGB = @as(u32, 3);
pub const HT_FORMAT_8BPP = @as(u32, 4);
pub const HT_FORMAT_16BPP = @as(u32, 5);
pub const HT_FORMAT_24BPP = @as(u32, 6);
pub const HT_FORMAT_32BPP = @as(u32, 7);
pub const WINDDI_MAX_BROADCAST_CONTEXT = @as(u32, 64);
pub const HT_FLAG_SQUARE_DEVICE_PEL = @as(u32, 1);
pub const HT_FLAG_HAS_BLACK_DYE = @as(u32, 2);
pub const HT_FLAG_ADDITIVE_PRIMS = @as(u32, 4);
pub const HT_FLAG_USE_8BPP_BITMASK = @as(u32, 8);
pub const HT_FLAG_INK_HIGH_ABSORPTION = @as(u32, 16);
pub const HT_FLAG_INK_ABSORPTION_INDICES = @as(u32, 96);
pub const HT_FLAG_DO_DEVCLR_XFORM = @as(u32, 128);
pub const HT_FLAG_OUTPUT_CMY = @as(u32, 256);
pub const HT_FLAG_PRINT_DRAFT_MODE = @as(u32, 512);
pub const HT_FLAG_INVERT_8BPP_BITMASK_IDX = @as(u32, 1024);
pub const HT_FLAG_8BPP_CMY332_MASK = @as(u32, 4278190080);
pub const HT_FLAG_INK_ABSORPTION_IDX0 = @as(u32, 0);
pub const HT_FLAG_INK_ABSORPTION_IDX1 = @as(u32, 32);
pub const HT_FLAG_INK_ABSORPTION_IDX2 = @as(u32, 64);
pub const HT_FLAG_INK_ABSORPTION_IDX3 = @as(u32, 96);
pub const PPC_DEFAULT = @as(u32, 0);
pub const PPC_UNDEFINED = @as(u32, 1);
pub const PPC_RGB_ORDER_VERTICAL_STRIPES = @as(u32, 2);
pub const PPC_BGR_ORDER_VERTICAL_STRIPES = @as(u32, 3);
pub const PPC_RGB_ORDER_HORIZONTAL_STRIPES = @as(u32, 4);
pub const PPC_BGR_ORDER_HORIZONTAL_STRIPES = @as(u32, 5);
pub const PPG_DEFAULT = @as(u32, 0);
pub const PPG_SRGB = @as(u32, 1);
pub const BR_DEVICE_ICM = @as(u32, 1);
pub const BR_HOST_ICM = @as(u32, 2);
pub const BR_CMYKCOLOR = @as(u32, 4);
pub const BR_ORIGCOLOR = @as(u32, 8);
pub const FO_SIM_BOLD = @as(u32, 8192);
pub const FO_SIM_ITALIC = @as(u32, 16384);
pub const FO_EM_HEIGHT = @as(u32, 32768);
pub const FO_GRAY16 = @as(u32, 65536);
pub const FO_NOGRAY16 = @as(u32, 131072);
pub const FO_NOHINTS = @as(u32, 262144);
pub const FO_NO_CHOICE = @as(u32, 524288);
pub const FO_CFF = @as(u32, 1048576);
pub const FO_POSTSCRIPT = @as(u32, 2097152);
pub const FO_MULTIPLEMASTER = @as(u32, 4194304);
pub const FO_VERT_FACE = @as(u32, 8388608);
pub const FO_DBCS_FONT = @as(u32, 16777216);
pub const FO_NOCLEARTYPE = @as(u32, 33554432);
pub const FO_CLEARTYPE_X = @as(u32, 268435456);
pub const FO_CLEARTYPE_Y = @as(u32, 536870912);
pub const FO_CLEARTYPENATURAL_X = @as(u32, 1073741824);
pub const DC_TRIVIAL = @as(u32, 0);
pub const DC_RECT = @as(u32, 1);
pub const DC_COMPLEX = @as(u32, 3);
pub const FC_RECT = @as(u32, 1);
pub const FC_RECT4 = @as(u32, 2);
pub const FC_COMPLEX = @as(u32, 3);
pub const TC_RECTANGLES = @as(u32, 0);
pub const TC_PATHOBJ = @as(u32, 2);
pub const OC_BANK_CLIP = @as(u32, 1);
pub const CT_RECTANGLES = @as(i32, 0);
pub const CD_RIGHTDOWN = @as(i32, 0);
pub const CD_LEFTDOWN = @as(i32, 1);
pub const CD_RIGHTUP = @as(i32, 2);
pub const CD_LEFTUP = @as(i32, 3);
pub const CD_ANY = @as(i32, 4);
pub const CD_LEFTWARDS = @as(i32, 1);
pub const CD_UPWARDS = @as(i32, 2);
pub const FO_HGLYPHS = @as(i32, 0);
pub const FO_GLYPHBITS = @as(i32, 1);
pub const FO_PATHOBJ = @as(i32, 2);
pub const FD_NEGATIVE_FONT = @as(i32, 1);
pub const FO_DEVICE_FONT = @as(i32, 1);
pub const FO_OUTLINE_CAPABLE = @as(i32, 2);
pub const SO_FLAG_DEFAULT_PLACEMENT = @as(u32, 1);
pub const SO_HORIZONTAL = @as(u32, 2);
pub const SO_VERTICAL = @as(u32, 4);
pub const SO_REVERSED = @as(u32, 8);
pub const SO_ZERO_BEARINGS = @as(u32, 16);
pub const SO_CHAR_INC_EQUAL_BM_BASE = @as(u32, 32);
pub const SO_MAXEXT_EQUAL_BM_SIDE = @as(u32, 64);
pub const SO_DO_NOT_SUBSTITUTE_DEVICE_FONT = @as(u32, 128);
pub const SO_GLYPHINDEX_TEXTOUT = @as(u32, 256);
pub const SO_ESC_NOT_ORIENT = @as(u32, 512);
pub const SO_DXDY = @as(u32, 1024);
pub const SO_CHARACTER_EXTRA = @as(u32, 2048);
pub const SO_BREAK_EXTRA = @as(u32, 4096);
pub const FO_ATTR_MODE_ROTATE = @as(u32, 1);
pub const PAL_INDEXED = @as(u32, 1);
pub const PAL_BITFIELDS = @as(u32, 2);
pub const PAL_RGB = @as(u32, 4);
pub const PAL_BGR = @as(u32, 8);
pub const PAL_CMYK = @as(u32, 16);
pub const PO_BEZIERS = @as(u32, 1);
pub const PO_ELLIPSE = @as(u32, 2);
pub const PO_ALL_INTEGERS = @as(u32, 4);
pub const PO_ENUM_AS_INTEGERS = @as(u32, 8);
pub const PO_WIDENED = @as(u32, 16);
pub const PD_BEGINSUBPATH = @as(u32, 1);
pub const PD_ENDSUBPATH = @as(u32, 2);
pub const PD_RESETSTYLE = @as(u32, 4);
pub const PD_CLOSEFIGURE = @as(u32, 8);
pub const PD_BEZIERS = @as(u32, 16);
pub const SGI_EXTRASPACE = @as(u32, 0);
pub const STYPE_BITMAP = @as(i32, 0);
pub const STYPE_DEVBITMAP = @as(i32, 3);
pub const BMF_1BPP = @as(i32, 1);
pub const BMF_4BPP = @as(i32, 2);
pub const BMF_8BPP = @as(i32, 3);
pub const BMF_16BPP = @as(i32, 4);
pub const BMF_24BPP = @as(i32, 5);
pub const BMF_32BPP = @as(i32, 6);
pub const BMF_4RLE = @as(i32, 7);
pub const BMF_8RLE = @as(i32, 8);
pub const BMF_JPEG = @as(i32, 9);
pub const BMF_PNG = @as(i32, 10);
pub const BMF_TOPDOWN = @as(u32, 1);
pub const BMF_NOZEROINIT = @as(u32, 2);
pub const BMF_DONTCACHE = @as(u32, 4);
pub const BMF_USERMEM = @as(u32, 8);
pub const BMF_KMSECTION = @as(u32, 16);
pub const BMF_NOTSYSMEM = @as(u32, 32);
pub const BMF_WINDOW_BLT = @as(u32, 64);
pub const BMF_UMPDMEM = @as(u32, 128);
pub const BMF_TEMP_ALPHA = @as(u32, 256);
pub const BMF_ACC_NOTIFY = @as(u32, 32768);
pub const BMF_RMT_ENTER = @as(u32, 16384);
pub const BMF_RESERVED = @as(u32, 15872);
pub const GX_IDENTITY = @as(i32, 0);
pub const GX_OFFSET = @as(i32, 1);
pub const GX_SCALE = @as(i32, 2);
pub const GX_GENERAL = @as(i32, 3);
pub const XF_LTOL = @as(i32, 0);
pub const XF_INV_LTOL = @as(i32, 1);
pub const XF_LTOFX = @as(i32, 2);
pub const XF_INV_FXTOL = @as(i32, 3);
pub const XO_TRIVIAL = @as(u32, 1);
pub const XO_TABLE = @as(u32, 2);
pub const XO_TO_MONO = @as(u32, 4);
pub const XO_FROM_CMYK = @as(u32, 8);
pub const XO_DEVICE_ICM = @as(u32, 16);
pub const XO_HOST_ICM = @as(u32, 32);
pub const XO_SRCPALETTE = @as(u32, 1);
pub const XO_DESTPALETTE = @as(u32, 2);
pub const XO_DESTDCPALETTE = @as(u32, 3);
pub const XO_SRCBITFIELDS = @as(u32, 4);
pub const XO_DESTBITFIELDS = @as(u32, 5);
pub const HOOK_BITBLT = @as(u32, 1);
pub const HOOK_STRETCHBLT = @as(u32, 2);
pub const HOOK_PLGBLT = @as(u32, 4);
pub const HOOK_TEXTOUT = @as(u32, 8);
pub const HOOK_PAINT = @as(u32, 16);
pub const HOOK_STROKEPATH = @as(u32, 32);
pub const HOOK_FILLPATH = @as(u32, 64);
pub const HOOK_STROKEANDFILLPATH = @as(u32, 128);
pub const HOOK_LINETO = @as(u32, 256);
pub const HOOK_COPYBITS = @as(u32, 1024);
pub const HOOK_MOVEPANNING = @as(u32, 2048);
pub const HOOK_SYNCHRONIZE = @as(u32, 4096);
pub const HOOK_STRETCHBLTROP = @as(u32, 8192);
pub const HOOK_SYNCHRONIZEACCESS = @as(u32, 16384);
pub const HOOK_TRANSPARENTBLT = @as(u32, 32768);
pub const HOOK_ALPHABLEND = @as(u32, 65536);
pub const HOOK_GRADIENTFILL = @as(u32, 131072);
pub const HOOK_FLAGS = @as(u32, 243199);
pub const MS_NOTSYSTEMMEMORY = @as(u32, 1);
pub const MS_SHAREDACCESS = @as(u32, 2);
pub const MS_CDDDEVICEBITMAP = @as(u32, 4);
pub const MS_REUSEDDEVICEBITMAP = @as(u32, 8);
pub const DRVQUERY_USERMODE = @as(u32, 1);
pub const HS_DDI_MAX = @as(u32, 6);
pub const DRD_SUCCESS = @as(u32, 0);
pub const DRD_ERROR = @as(u32, 1);
pub const SS_SAVE = @as(u32, 0);
pub const SS_RESTORE = @as(u32, 1);
pub const SS_FREE = @as(u32, 2);
pub const CDBEX_REDIRECTION = @as(u32, 1);
pub const CDBEX_DXINTEROP = @as(u32, 2);
pub const CDBEX_NTSHAREDSURFACEHANDLE = @as(u32, 4);
pub const CDBEX_CROSSADAPTER = @as(u32, 8);
pub const CDBEX_REUSE = @as(u32, 16);
pub const WINDDI_MAXSETPALETTECOLORS = @as(u32, 256);
pub const WINDDI_MAXSETPALETTECOLORINDEX = @as(u32, 255);
pub const DM_DEFAULT = @as(u32, 1);
pub const DM_MONOCHROME = @as(u32, 2);
pub const DCR_SOLID = @as(u32, 0);
pub const DCR_DRIVER = @as(u32, 1);
pub const DCR_HALFTONE = @as(u32, 2);
pub const RB_DITHERCOLOR = @as(i32, -2147483648);
pub const QFT_LIGATURES = @as(i32, 1);
pub const QFT_KERNPAIRS = @as(i32, 2);
pub const QFT_GLYPHSET = @as(i32, 3);
pub const QFD_GLYPHANDBITMAP = @as(i32, 1);
pub const QFD_GLYPHANDOUTLINE = @as(i32, 2);
pub const QFD_MAXEXTENTS = @as(i32, 3);
pub const QFD_TT_GLYPHANDBITMAP = @as(i32, 4);
pub const QFD_TT_GRAY1_BITMAP = @as(i32, 5);
pub const QFD_TT_GRAY2_BITMAP = @as(i32, 6);
pub const QFD_TT_GRAY4_BITMAP = @as(i32, 8);
pub const QFD_TT_GRAY8_BITMAP = @as(i32, 9);
pub const QC_OUTLINES = @as(u32, 1);
pub const QC_1BIT = @as(u32, 2);
pub const QC_4BIT = @as(u32, 4);
pub const FF_SIGNATURE_VERIFIED = @as(u32, 1);
pub const FF_IGNORED_SIGNATURE = @as(u32, 2);
pub const QAW_GETWIDTHS = @as(u32, 0);
pub const QAW_GETEASYWIDTHS = @as(u32, 1);
pub const TTO_METRICS_ONLY = @as(u32, 1);
pub const TTO_QUBICS = @as(u32, 2);
pub const TTO_UNHINTED = @as(u32, 4);
pub const QFF_DESCRIPTION = @as(i32, 1);
pub const QFF_NUMFACES = @as(i32, 2);
pub const FP_ALTERNATEMODE = @as(i32, 1);
pub const FP_WINDINGMODE = @as(i32, 2);
pub const SPS_ERROR = @as(u32, 0);
pub const SPS_DECLINE = @as(u32, 1);
pub const SPS_ACCEPT_NOEXCLUDE = @as(u32, 2);
pub const SPS_ACCEPT_EXCLUDE = @as(u32, 3);
pub const SPS_ACCEPT_SYNCHRONOUS = @as(u32, 4);
pub const SPS_CHANGE = @as(i32, 1);
pub const SPS_ASYNCCHANGE = @as(i32, 2);
pub const SPS_ANIMATESTART = @as(i32, 4);
pub const SPS_ANIMATEUPDATE = @as(i32, 8);
pub const SPS_ALPHA = @as(i32, 16);
pub const SPS_RESERVED = @as(i32, 32);
pub const SPS_RESERVED1 = @as(i32, 64);
pub const SPS_FLAGSMASK = @as(i32, 255);
pub const SPS_LENGTHMASK = @as(i32, 3840);
pub const SPS_FREQMASK = @as(i32, 1044480);
pub const ED_ABORTDOC = @as(u32, 1);
pub const IGRF_RGB_256BYTES = @as(u32, 0);
pub const IGRF_RGB_256WORDS = @as(u32, 1);
pub const QDS_CHECKJPEGFORMAT = @as(u32, 0);
pub const QDS_CHECKPNGFORMAT = @as(u32, 1);
pub const DSS_TIMER_EVENT = @as(u32, 1);
pub const DSS_FLUSH_EVENT = @as(u32, 2);
pub const DSS_RESERVED = @as(u32, 4);
pub const DSS_RESERVED1 = @as(u32, 8);
pub const DSS_RESERVED2 = @as(u32, 16);
pub const DN_ACCELERATION_LEVEL = @as(u32, 1);
pub const DN_DEVICE_ORIGIN = @as(u32, 2);
pub const DN_SLEEP_MODE = @as(u32, 3);
pub const DN_DRAWING_BEGIN = @as(u32, 4);
pub const DN_ASSOCIATE_WINDOW = @as(u32, 5);
pub const DN_COMPOSITION_CHANGED = @as(u32, 6);
pub const DN_DRAWING_BEGIN_APIBITMAP = @as(u32, 7);
pub const DN_SURFOBJ_DESTRUCTION = @as(u32, 8);
pub const WOC_RGN_CLIENT_DELTA = @as(u32, 1);
pub const WOC_RGN_CLIENT = @as(u32, 2);
pub const WOC_RGN_SURFACE_DELTA = @as(u32, 4);
pub const WOC_RGN_SURFACE = @as(u32, 8);
pub const WOC_CHANGED = @as(u32, 16);
pub const WOC_DELETE = @as(u32, 32);
pub const WOC_DRAWN = @as(u32, 64);
pub const WOC_SPRITE_OVERLAP = @as(u32, 128);
pub const WOC_SPRITE_NO_OVERLAP = @as(u32, 256);
pub const WOC_RGN_SPRITE = @as(u32, 512);
pub const WO_RGN_CLIENT_DELTA = @as(u32, 1);
pub const WO_RGN_CLIENT = @as(u32, 2);
pub const WO_RGN_SURFACE_DELTA = @as(u32, 4);
pub const WO_RGN_SURFACE = @as(u32, 8);
pub const WO_RGN_UPDATE_ALL = @as(u32, 16);
pub const WO_RGN_WINDOW = @as(u32, 32);
pub const WO_DRAW_NOTIFY = @as(u32, 64);
pub const WO_SPRITE_NOTIFY = @as(u32, 128);
pub const WO_RGN_DESKTOP_COORD = @as(u32, 256);
pub const WO_RGN_SPRITE = @as(u32, 512);
pub const EHN_RESTORED = @as(u32, 0);
pub const EHN_ERROR = @as(u32, 1);
pub const ECS_TEARDOWN = @as(u32, 1);
pub const ECS_REDRAW = @as(u32, 2);
pub const DEVHTADJF_COLOR_DEVICE = @as(u32, 1);
pub const DEVHTADJF_ADDITIVE_DEVICE = @as(u32, 2);
pub const FL_ZERO_MEMORY = @as(u32, 1);
pub const FL_NONPAGED_MEMORY = @as(u32, 2);
pub const FL_NON_SESSION = @as(u32, 4);
pub const QSA_MMX = @as(u32, 256);
pub const QSA_SSE = @as(u32, 8192);
pub const QSA_3DNOW = @as(u32, 16384);
pub const QSA_SSE2 = @as(u32, 65536);
pub const QSA_SSE3 = @as(u32, 524288);
pub const ENG_FNT_CACHE_READ_FAULT = @as(u32, 1);
pub const ENG_FNT_CACHE_WRITE_FAULT = @as(u32, 2);
pub const DRH_APIBITMAP = @as(u32, 1);
pub const VER_VDS_LUN_INFORMATION = @as(u32, 1);
pub const MDM_COMPRESSION = @as(u32, 1);
pub const MDM_ERROR_CONTROL = @as(u32, 2);
pub const MDM_FORCED_EC = @as(u32, 4);
pub const MDM_CELLULAR = @as(u32, 8);
pub const MDM_FLOWCONTROL_HARD = @as(u32, 16);
pub const MDM_FLOWCONTROL_SOFT = @as(u32, 32);
pub const MDM_CCITT_OVERRIDE = @as(u32, 64);
pub const MDM_SPEED_ADJUST = @as(u32, 128);
pub const MDM_TONE_DIAL = @as(u32, 256);
pub const MDM_BLIND_DIAL = @as(u32, 512);
pub const MDM_V23_OVERRIDE = @as(u32, 1024);
pub const MDM_DIAGNOSTICS = @as(u32, 2048);
pub const MDM_MASK_BEARERMODE = @as(u32, 61440);
pub const MDM_SHIFT_BEARERMODE = @as(u32, 12);
pub const MDM_MASK_PROTOCOLID = @as(u32, 983040);
pub const MDM_SHIFT_PROTOCOLID = @as(u32, 16);
pub const MDM_MASK_PROTOCOLDATA = @as(u32, 267386880);
pub const MDM_SHIFT_PROTOCOLDATA = @as(u32, 20);
pub const MDM_BEARERMODE_ANALOG = @as(u32, 0);
pub const MDM_BEARERMODE_ISDN = @as(u32, 1);
pub const MDM_BEARERMODE_GSM = @as(u32, 2);
pub const MDM_PROTOCOLID_DEFAULT = @as(u32, 0);
pub const MDM_PROTOCOLID_HDLCPPP = @as(u32, 1);
pub const MDM_PROTOCOLID_V128 = @as(u32, 2);
pub const MDM_PROTOCOLID_X75 = @as(u32, 3);
pub const MDM_PROTOCOLID_V110 = @as(u32, 4);
pub const MDM_PROTOCOLID_V120 = @as(u32, 5);
pub const MDM_PROTOCOLID_AUTO = @as(u32, 6);
pub const MDM_PROTOCOLID_ANALOG = @as(u32, 7);
pub const MDM_PROTOCOLID_GPRS = @as(u32, 8);
pub const MDM_PROTOCOLID_PIAFS = @as(u32, 9);
pub const MDM_SHIFT_HDLCPPP_SPEED = @as(u32, 0);
pub const MDM_MASK_HDLCPPP_SPEED = @as(u32, 7);
pub const MDM_HDLCPPP_SPEED_DEFAULT = @as(u32, 0);
pub const MDM_HDLCPPP_SPEED_64K = @as(u32, 1);
pub const MDM_HDLCPPP_SPEED_56K = @as(u32, 2);
pub const MDM_SHIFT_HDLCPPP_AUTH = @as(u32, 3);
pub const MDM_HDLCPPP_AUTH_DEFAULT = @as(u32, 0);
pub const MDM_HDLCPPP_AUTH_NONE = @as(u32, 1);
pub const MDM_HDLCPPP_AUTH_PAP = @as(u32, 2);
pub const MDM_HDLCPPP_AUTH_CHAP = @as(u32, 3);
pub const MDM_HDLCPPP_AUTH_MSCHAP = @as(u32, 4);
pub const MDM_SHIFT_HDLCPPP_ML = @as(u32, 6);
pub const MDM_HDLCPPP_ML_DEFAULT = @as(u32, 0);
pub const MDM_HDLCPPP_ML_NONE = @as(u32, 1);
pub const MDM_HDLCPPP_ML_2 = @as(u32, 2);
pub const MDM_SHIFT_V120_SPEED = @as(u32, 0);
pub const MDM_MASK_V120_SPEED = @as(u32, 7);
pub const MDM_V120_SPEED_DEFAULT = @as(u32, 0);
pub const MDM_V120_SPEED_64K = @as(u32, 1);
pub const MDM_V120_SPEED_56K = @as(u32, 2);
pub const MDM_SHIFT_V120_ML = @as(u32, 6);
pub const MDM_V120_ML_DEFAULT = @as(u32, 0);
pub const MDM_V120_ML_NONE = @as(u32, 1);
pub const MDM_V120_ML_2 = @as(u32, 2);
pub const MDM_SHIFT_X75_DATA = @as(u32, 0);
pub const MDM_MASK_X75_DATA = @as(u32, 7);
pub const MDM_X75_DATA_DEFAULT = @as(u32, 0);
pub const MDM_X75_DATA_64K = @as(u32, 1);
pub const MDM_X75_DATA_128K = @as(u32, 2);
pub const MDM_X75_DATA_T_70 = @as(u32, 3);
pub const MDM_X75_DATA_BTX = @as(u32, 4);
pub const MDM_SHIFT_V110_SPEED = @as(u32, 0);
pub const MDM_MASK_V110_SPEED = @as(u32, 15);
pub const MDM_V110_SPEED_DEFAULT = @as(u32, 0);
pub const MDM_V110_SPEED_1DOT2K = @as(u32, 1);
pub const MDM_V110_SPEED_2DOT4K = @as(u32, 2);
pub const MDM_V110_SPEED_4DOT8K = @as(u32, 3);
pub const MDM_V110_SPEED_9DOT6K = @as(u32, 4);
pub const MDM_V110_SPEED_12DOT0K = @as(u32, 5);
pub const MDM_V110_SPEED_14DOT4K = @as(u32, 6);
pub const MDM_V110_SPEED_19DOT2K = @as(u32, 7);
pub const MDM_V110_SPEED_28DOT8K = @as(u32, 8);
pub const MDM_V110_SPEED_38DOT4K = @as(u32, 9);
pub const MDM_V110_SPEED_57DOT6K = @as(u32, 10);
pub const MDM_SHIFT_AUTO_SPEED = @as(u32, 0);
pub const MDM_MASK_AUTO_SPEED = @as(u32, 7);
pub const MDM_AUTO_SPEED_DEFAULT = @as(u32, 0);
pub const MDM_SHIFT_AUTO_ML = @as(u32, 6);
pub const MDM_AUTO_ML_DEFAULT = @as(u32, 0);
pub const MDM_AUTO_ML_NONE = @as(u32, 1);
pub const MDM_AUTO_ML_2 = @as(u32, 2);
pub const MDM_ANALOG_RLP_ON = @as(u32, 0);
pub const MDM_ANALOG_RLP_OFF = @as(u32, 1);
pub const MDM_ANALOG_V34 = @as(u32, 2);
pub const MDM_PIAFS_INCOMING = @as(u32, 0);
pub const MDM_PIAFS_OUTGOING = @as(u32, 1);
pub const DSPRINT_PUBLISH = @as(u32, 1);
pub const DSPRINT_UPDATE = @as(u32, 2);
pub const DSPRINT_UNPUBLISH = @as(u32, 4);
pub const DSPRINT_REPUBLISH = @as(u32, 8);
pub const DSPRINT_PENDING = @as(u32, 2147483648);
pub const PRINTER_CONTROL_PAUSE = @as(u32, 1);
pub const PRINTER_CONTROL_RESUME = @as(u32, 2);
pub const PRINTER_CONTROL_PURGE = @as(u32, 3);
pub const PRINTER_CONTROL_SET_STATUS = @as(u32, 4);
pub const PRINTER_STATUS_PAUSED = @as(u32, 1);
pub const PRINTER_STATUS_ERROR = @as(u32, 2);
pub const PRINTER_STATUS_PENDING_DELETION = @as(u32, 4);
pub const PRINTER_STATUS_PAPER_JAM = @as(u32, 8);
pub const PRINTER_STATUS_PAPER_OUT = @as(u32, 16);
pub const PRINTER_STATUS_MANUAL_FEED = @as(u32, 32);
pub const PRINTER_STATUS_PAPER_PROBLEM = @as(u32, 64);
pub const PRINTER_STATUS_OFFLINE = @as(u32, 128);
pub const PRINTER_STATUS_IO_ACTIVE = @as(u32, 256);
pub const PRINTER_STATUS_BUSY = @as(u32, 512);
pub const PRINTER_STATUS_PRINTING = @as(u32, 1024);
pub const PRINTER_STATUS_OUTPUT_BIN_FULL = @as(u32, 2048);
pub const PRINTER_STATUS_NOT_AVAILABLE = @as(u32, 4096);
pub const PRINTER_STATUS_WAITING = @as(u32, 8192);
pub const PRINTER_STATUS_PROCESSING = @as(u32, 16384);
pub const PRINTER_STATUS_INITIALIZING = @as(u32, 32768);
pub const PRINTER_STATUS_WARMING_UP = @as(u32, 65536);
pub const PRINTER_STATUS_TONER_LOW = @as(u32, 131072);
pub const PRINTER_STATUS_NO_TONER = @as(u32, 262144);
pub const PRINTER_STATUS_PAGE_PUNT = @as(u32, 524288);
pub const PRINTER_STATUS_USER_INTERVENTION = @as(u32, 1048576);
pub const PRINTER_STATUS_OUT_OF_MEMORY = @as(u32, 2097152);
pub const PRINTER_STATUS_DOOR_OPEN = @as(u32, 4194304);
pub const PRINTER_STATUS_SERVER_UNKNOWN = @as(u32, 8388608);
pub const PRINTER_STATUS_POWER_SAVE = @as(u32, 16777216);
pub const PRINTER_STATUS_SERVER_OFFLINE = @as(u32, 33554432);
pub const PRINTER_STATUS_DRIVER_UPDATE_NEEDED = @as(u32, 67108864);
pub const PRINTER_ATTRIBUTE_QUEUED = @as(u32, 1);
pub const PRINTER_ATTRIBUTE_DIRECT = @as(u32, 2);
pub const PRINTER_ATTRIBUTE_DEFAULT = @as(u32, 4);
pub const PRINTER_ATTRIBUTE_SHARED = @as(u32, 8);
pub const PRINTER_ATTRIBUTE_NETWORK = @as(u32, 16);
pub const PRINTER_ATTRIBUTE_HIDDEN = @as(u32, 32);
pub const PRINTER_ATTRIBUTE_LOCAL = @as(u32, 64);
pub const PRINTER_ATTRIBUTE_ENABLE_DEVQ = @as(u32, 128);
pub const PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS = @as(u32, 256);
pub const PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = @as(u32, 512);
pub const PRINTER_ATTRIBUTE_WORK_OFFLINE = @as(u32, 1024);
pub const PRINTER_ATTRIBUTE_ENABLE_BIDI = @as(u32, 2048);
pub const PRINTER_ATTRIBUTE_RAW_ONLY = @as(u32, 4096);
pub const PRINTER_ATTRIBUTE_PUBLISHED = @as(u32, 8192);
pub const NO_PRIORITY = @as(u32, 0);
pub const MAX_PRIORITY = @as(u32, 99);
pub const MIN_PRIORITY = @as(u32, 1);
pub const DEF_PRIORITY = @as(u32, 1);
pub const JOB_CONTROL_PAUSE = @as(u32, 1);
pub const JOB_CONTROL_RESUME = @as(u32, 2);
pub const JOB_CONTROL_CANCEL = @as(u32, 3);
pub const JOB_CONTROL_RESTART = @as(u32, 4);
pub const JOB_CONTROL_DELETE = @as(u32, 5);
pub const JOB_CONTROL_SENT_TO_PRINTER = @as(u32, 6);
pub const JOB_CONTROL_LAST_PAGE_EJECTED = @as(u32, 7);
pub const JOB_STATUS_PAUSED = @as(u32, 1);
pub const JOB_STATUS_ERROR = @as(u32, 2);
pub const JOB_STATUS_DELETING = @as(u32, 4);
pub const JOB_STATUS_SPOOLING = @as(u32, 8);
pub const JOB_STATUS_PRINTING = @as(u32, 16);
pub const JOB_STATUS_OFFLINE = @as(u32, 32);
pub const JOB_STATUS_PAPEROUT = @as(u32, 64);
pub const JOB_STATUS_PRINTED = @as(u32, 128);
pub const JOB_STATUS_DELETED = @as(u32, 256);
pub const JOB_STATUS_BLOCKED_DEVQ = @as(u32, 512);
pub const JOB_STATUS_USER_INTERVENTION = @as(u32, 1024);
pub const JOB_STATUS_RESTART = @as(u32, 2048);
pub const JOB_POSITION_UNSPECIFIED = @as(u32, 0);
pub const PRINTER_DRIVER_PACKAGE_AWARE = @as(u32, 1);
pub const PRINTER_DRIVER_XPS = @as(u32, 2);
pub const PRINTER_DRIVER_SANDBOX_ENABLED = @as(u32, 4);
pub const PRINTER_DRIVER_CLASS = @as(u32, 8);
pub const PRINTER_DRIVER_DERIVED = @as(u32, 16);
pub const PRINTER_DRIVER_NOT_SHAREABLE = @as(u32, 32);
pub const PRINTER_DRIVER_CATEGORY_FAX = @as(u32, 64);
pub const PRINTER_DRIVER_CATEGORY_FILE = @as(u32, 128);
pub const PRINTER_DRIVER_CATEGORY_VIRTUAL = @as(u32, 256);
pub const PRINTER_DRIVER_CATEGORY_SERVICE = @as(u32, 512);
pub const PRINTER_DRIVER_SOFT_RESET_REQUIRED = @as(u32, 1024);
pub const PRINTER_DRIVER_SANDBOX_DISABLED = @as(u32, 2048);
pub const PRINTER_DRIVER_CATEGORY_3D = @as(u32, 4096);
pub const PRINTER_DRIVER_CATEGORY_CLOUD = @as(u32, 8192);
pub const DRIVER_KERNELMODE = @as(u32, 1);
pub const DRIVER_USERMODE = @as(u32, 2);
pub const DPD_DELETE_UNUSED_FILES = @as(u32, 1);
pub const DPD_DELETE_SPECIFIC_VERSION = @as(u32, 2);
pub const DPD_DELETE_ALL_FILES = @as(u32, 4);
pub const APD_STRICT_UPGRADE = @as(u32, 1);
pub const APD_STRICT_DOWNGRADE = @as(u32, 2);
pub const APD_COPY_ALL_FILES = @as(u32, 4);
pub const APD_COPY_NEW_FILES = @as(u32, 8);
pub const DI_CHANNEL = @as(u32, 1);
pub const DI_READ_SPOOL_JOB = @as(u32, 3);
pub const DI_MEMORYMAP_WRITE = @as(u32, 1);
pub const FORM_USER = @as(u32, 0);
pub const FORM_BUILTIN = @as(u32, 1);
pub const FORM_PRINTER = @as(u32, 2);
pub const PORT_TYPE_WRITE = @as(u32, 1);
pub const PORT_TYPE_READ = @as(u32, 2);
pub const PORT_TYPE_REDIRECTED = @as(u32, 4);
pub const PORT_TYPE_NET_ATTACHED = @as(u32, 8);
pub const PORT_STATUS_TYPE_ERROR = @as(u32, 1);
pub const PORT_STATUS_TYPE_WARNING = @as(u32, 2);
pub const PORT_STATUS_TYPE_INFO = @as(u32, 3);
pub const PORT_STATUS_OFFLINE = @as(u32, 1);
pub const PORT_STATUS_PAPER_JAM = @as(u32, 2);
pub const PORT_STATUS_PAPER_OUT = @as(u32, 3);
pub const PORT_STATUS_OUTPUT_BIN_FULL = @as(u32, 4);
pub const PORT_STATUS_PAPER_PROBLEM = @as(u32, 5);
pub const PORT_STATUS_NO_TONER = @as(u32, 6);
pub const PORT_STATUS_DOOR_OPEN = @as(u32, 7);
pub const PORT_STATUS_USER_INTERVENTION = @as(u32, 8);
pub const PORT_STATUS_OUT_OF_MEMORY = @as(u32, 9);
pub const PORT_STATUS_TONER_LOW = @as(u32, 10);
pub const PORT_STATUS_WARMING_UP = @as(u32, 11);
pub const PORT_STATUS_POWER_SAVE = @as(u32, 12);
pub const PRINTER_ENUM_DEFAULT = @as(u32, 1);
pub const PRINTER_ENUM_LOCAL = @as(u32, 2);
pub const PRINTER_ENUM_CONNECTIONS = @as(u32, 4);
pub const PRINTER_ENUM_FAVORITE = @as(u32, 4);
pub const PRINTER_ENUM_NAME = @as(u32, 8);
pub const PRINTER_ENUM_REMOTE = @as(u32, 16);
pub const PRINTER_ENUM_SHARED = @as(u32, 32);
pub const PRINTER_ENUM_NETWORK = @as(u32, 64);
pub const PRINTER_ENUM_EXPAND = @as(u32, 16384);
pub const PRINTER_ENUM_CONTAINER = @as(u32, 32768);
pub const PRINTER_ENUM_ICONMASK = @as(u32, 16711680);
pub const PRINTER_ENUM_ICON1 = @as(u32, 65536);
pub const PRINTER_ENUM_ICON2 = @as(u32, 131072);
pub const PRINTER_ENUM_ICON3 = @as(u32, 262144);
pub const PRINTER_ENUM_ICON4 = @as(u32, 524288);
pub const PRINTER_ENUM_ICON5 = @as(u32, 1048576);
pub const PRINTER_ENUM_ICON6 = @as(u32, 2097152);
pub const PRINTER_ENUM_ICON7 = @as(u32, 4194304);
pub const PRINTER_ENUM_ICON8 = @as(u32, 8388608);
pub const PRINTER_ENUM_HIDE = @as(u32, 16777216);
pub const PRINTER_ENUM_CATEGORY_ALL = @as(u32, 33554432);
pub const PRINTER_ENUM_CATEGORY_3D = @as(u32, 67108864);
pub const SPOOL_FILE_PERSISTENT = @as(u32, 1);
pub const SPOOL_FILE_TEMPORARY = @as(u32, 2);
pub const PRINTER_NOTIFY_TYPE = @as(u32, 0);
pub const JOB_NOTIFY_TYPE = @as(u32, 1);
pub const SERVER_NOTIFY_TYPE = @as(u32, 2);
pub const PRINTER_NOTIFY_FIELD_SERVER_NAME = @as(u32, 0);
pub const PRINTER_NOTIFY_FIELD_PRINTER_NAME = @as(u32, 1);
pub const PRINTER_NOTIFY_FIELD_SHARE_NAME = @as(u32, 2);
pub const PRINTER_NOTIFY_FIELD_PORT_NAME = @as(u32, 3);
pub const PRINTER_NOTIFY_FIELD_DRIVER_NAME = @as(u32, 4);
pub const PRINTER_NOTIFY_FIELD_COMMENT = @as(u32, 5);
pub const PRINTER_NOTIFY_FIELD_LOCATION = @as(u32, 6);
pub const PRINTER_NOTIFY_FIELD_DEVMODE = @as(u32, 7);
pub const PRINTER_NOTIFY_FIELD_SEPFILE = @as(u32, 8);
pub const PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR = @as(u32, 9);
pub const PRINTER_NOTIFY_FIELD_PARAMETERS = @as(u32, 10);
pub const PRINTER_NOTIFY_FIELD_DATATYPE = @as(u32, 11);
pub const PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR = @as(u32, 12);
pub const PRINTER_NOTIFY_FIELD_ATTRIBUTES = @as(u32, 13);
pub const PRINTER_NOTIFY_FIELD_PRIORITY = @as(u32, 14);
pub const PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY = @as(u32, 15);
pub const PRINTER_NOTIFY_FIELD_START_TIME = @as(u32, 16);
pub const PRINTER_NOTIFY_FIELD_UNTIL_TIME = @as(u32, 17);
pub const PRINTER_NOTIFY_FIELD_STATUS = @as(u32, 18);
pub const PRINTER_NOTIFY_FIELD_STATUS_STRING = @as(u32, 19);
pub const PRINTER_NOTIFY_FIELD_CJOBS = @as(u32, 20);
pub const PRINTER_NOTIFY_FIELD_AVERAGE_PPM = @as(u32, 21);
pub const PRINTER_NOTIFY_FIELD_TOTAL_PAGES = @as(u32, 22);
pub const PRINTER_NOTIFY_FIELD_PAGES_PRINTED = @as(u32, 23);
pub const PRINTER_NOTIFY_FIELD_TOTAL_BYTES = @as(u32, 24);
pub const PRINTER_NOTIFY_FIELD_BYTES_PRINTED = @as(u32, 25);
pub const PRINTER_NOTIFY_FIELD_OBJECT_GUID = @as(u32, 26);
pub const JOB_NOTIFY_FIELD_PRINTER_NAME = @as(u32, 0);
pub const JOB_NOTIFY_FIELD_MACHINE_NAME = @as(u32, 1);
pub const JOB_NOTIFY_FIELD_PORT_NAME = @as(u32, 2);
pub const JOB_NOTIFY_FIELD_USER_NAME = @as(u32, 3);
pub const JOB_NOTIFY_FIELD_NOTIFY_NAME = @as(u32, 4);
pub const JOB_NOTIFY_FIELD_DATATYPE = @as(u32, 5);
pub const JOB_NOTIFY_FIELD_PRINT_PROCESSOR = @as(u32, 6);
pub const JOB_NOTIFY_FIELD_PARAMETERS = @as(u32, 7);
pub const JOB_NOTIFY_FIELD_DRIVER_NAME = @as(u32, 8);
pub const JOB_NOTIFY_FIELD_DEVMODE = @as(u32, 9);
pub const JOB_NOTIFY_FIELD_STATUS = @as(u32, 10);
pub const JOB_NOTIFY_FIELD_STATUS_STRING = @as(u32, 11);
pub const JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR = @as(u32, 12);
pub const JOB_NOTIFY_FIELD_DOCUMENT = @as(u32, 13);
pub const JOB_NOTIFY_FIELD_PRIORITY = @as(u32, 14);
pub const JOB_NOTIFY_FIELD_POSITION = @as(u32, 15);
pub const JOB_NOTIFY_FIELD_SUBMITTED = @as(u32, 16);
pub const JOB_NOTIFY_FIELD_START_TIME = @as(u32, 17);
pub const JOB_NOTIFY_FIELD_UNTIL_TIME = @as(u32, 18);
pub const JOB_NOTIFY_FIELD_TIME = @as(u32, 19);
pub const JOB_NOTIFY_FIELD_TOTAL_PAGES = @as(u32, 20);
pub const JOB_NOTIFY_FIELD_PAGES_PRINTED = @as(u32, 21);
pub const JOB_NOTIFY_FIELD_TOTAL_BYTES = @as(u32, 22);
pub const JOB_NOTIFY_FIELD_BYTES_PRINTED = @as(u32, 23);
pub const JOB_NOTIFY_FIELD_REMOTE_JOB_ID = @as(u32, 24);
pub const PRINTER_NOTIFY_OPTIONS_REFRESH = @as(u32, 1);
pub const PRINTER_NOTIFY_INFO_DISCARDED = @as(u32, 1);
pub const PRINTER_CHANGE_ADD_PRINTER = @as(u32, 1);
pub const PRINTER_CHANGE_SET_PRINTER = @as(u32, 2);
pub const PRINTER_CHANGE_DELETE_PRINTER = @as(u32, 4);
pub const PRINTER_CHANGE_FAILED_CONNECTION_PRINTER = @as(u32, 8);
pub const PRINTER_CHANGE_PRINTER = @as(u32, 255);
pub const PRINTER_CHANGE_ADD_JOB = @as(u32, 256);
pub const PRINTER_CHANGE_SET_JOB = @as(u32, 512);
pub const PRINTER_CHANGE_DELETE_JOB = @as(u32, 1024);
pub const PRINTER_CHANGE_WRITE_JOB = @as(u32, 2048);
pub const PRINTER_CHANGE_JOB = @as(u32, 65280);
pub const PRINTER_CHANGE_ADD_FORM = @as(u32, 65536);
pub const PRINTER_CHANGE_SET_FORM = @as(u32, 131072);
pub const PRINTER_CHANGE_DELETE_FORM = @as(u32, 262144);
pub const PRINTER_CHANGE_FORM = @as(u32, 458752);
pub const PRINTER_CHANGE_ADD_PORT = @as(u32, 1048576);
pub const PRINTER_CHANGE_CONFIGURE_PORT = @as(u32, 2097152);
pub const PRINTER_CHANGE_DELETE_PORT = @as(u32, 4194304);
pub const PRINTER_CHANGE_PORT = @as(u32, 7340032);
pub const PRINTER_CHANGE_ADD_PRINT_PROCESSOR = @as(u32, 16777216);
pub const PRINTER_CHANGE_DELETE_PRINT_PROCESSOR = @as(u32, 67108864);
pub const PRINTER_CHANGE_PRINT_PROCESSOR = @as(u32, 117440512);
pub const PRINTER_CHANGE_SERVER = @as(u32, 134217728);
pub const PRINTER_CHANGE_ADD_PRINTER_DRIVER = @as(u32, 268435456);
pub const PRINTER_CHANGE_SET_PRINTER_DRIVER = @as(u32, 536870912);
pub const PRINTER_CHANGE_DELETE_PRINTER_DRIVER = @as(u32, 1073741824);
pub const PRINTER_CHANGE_PRINTER_DRIVER = @as(u32, 1879048192);
pub const PRINTER_CHANGE_TIMEOUT = @as(u32, 2147483648);
pub const PRINTER_CHANGE_ALL = @as(u32, 2138570751);
pub const PRINTER_ERROR_INFORMATION = @as(u32, 2147483648);
pub const PRINTER_ERROR_WARNING = @as(u32, 1073741824);
pub const PRINTER_ERROR_SEVERE = @as(u32, 536870912);
pub const PRINTER_ERROR_OUTOFPAPER = @as(u32, 1);
pub const PRINTER_ERROR_JAM = @as(u32, 2);
pub const PRINTER_ERROR_OUTOFTONER = @as(u32, 4);
pub const SERVER_ACCESS_ADMINISTER = @as(u32, 1);
pub const SERVER_ACCESS_ENUMERATE = @as(u32, 2);
pub const PRINTER_ACCESS_ADMINISTER = @as(u32, 4);
pub const PRINTER_ACCESS_USE = @as(u32, 8);
pub const JOB_ACCESS_ADMINISTER = @as(u32, 16);
pub const PRINTER_ACCESS_MANAGE_LIMITED = @as(u32, 64);
pub const IPDFP_COPY_ALL_FILES = @as(u32, 1);
pub const UPDP_SILENT_UPLOAD = @as(u32, 1);
pub const UPDP_UPLOAD_ALWAYS = @as(u32, 2);
pub const UPDP_CHECK_DRIVERSTORE = @as(u32, 4);
pub const FILE_DEVICE_SMARTCARD = @as(u32, 49);
pub const GUID_DEVINTERFACE_SMARTCARD_READER = Guid.initString("50dd5230-ba8a-11d1-bf5d-0000f805f530");
pub const SCARD_ATR_LENGTH = @as(u32, 33);
pub const SCARD_PROTOCOL_UNDEFINED = @as(u32, 0);
pub const SCARD_PROTOCOL_T0 = @as(u32, 1);
pub const SCARD_PROTOCOL_T1 = @as(u32, 2);
pub const SCARD_PROTOCOL_RAW = @as(u32, 65536);
pub const SCARD_PROTOCOL_DEFAULT = @as(u32, 2147483648);
pub const SCARD_PROTOCOL_OPTIMAL = @as(u32, 0);
pub const SCARD_POWER_DOWN = @as(u32, 0);
pub const SCARD_COLD_RESET = @as(u32, 1);
pub const SCARD_WARM_RESET = @as(u32, 2);
pub const MAXIMUM_ATTR_STRING_LENGTH = @as(u32, 32);
pub const MAXIMUM_SMARTCARD_READERS = @as(u32, 10);
pub const SCARD_CLASS_VENDOR_INFO = @as(u32, 1);
pub const SCARD_CLASS_COMMUNICATIONS = @as(u32, 2);
pub const SCARD_CLASS_PROTOCOL = @as(u32, 3);
pub const SCARD_CLASS_POWER_MGMT = @as(u32, 4);
pub const SCARD_CLASS_SECURITY = @as(u32, 5);
pub const SCARD_CLASS_MECHANICAL = @as(u32, 6);
pub const SCARD_CLASS_VENDOR_DEFINED = @as(u32, 7);
pub const SCARD_CLASS_IFD_PROTOCOL = @as(u32, 8);
pub const SCARD_CLASS_ICC_STATE = @as(u32, 9);
pub const SCARD_CLASS_PERF = @as(u32, 32766);
pub const SCARD_CLASS_SYSTEM = @as(u32, 32767);
pub const SCARD_T0_HEADER_LENGTH = @as(u32, 7);
pub const SCARD_T0_CMD_LENGTH = @as(u32, 5);
pub const SCARD_T1_PROLOGUE_LENGTH = @as(u32, 3);
pub const SCARD_T1_EPILOGUE_LENGTH = @as(u32, 2);
pub const SCARD_T1_EPILOGUE_LENGTH_LRC = @as(u32, 1);
pub const SCARD_T1_MAX_IFS = @as(u32, 254);
pub const SCARD_UNKNOWN = @as(u32, 0);
pub const SCARD_ABSENT = @as(u32, 1);
pub const SCARD_PRESENT = @as(u32, 2);
pub const SCARD_SWALLOWED = @as(u32, 3);
pub const SCARD_POWERED = @as(u32, 4);
pub const SCARD_NEGOTIABLE = @as(u32, 5);
pub const SCARD_SPECIFIC = @as(u32, 6);
pub const SCARD_READER_SWALLOWS = @as(u32, 1);
pub const SCARD_READER_EJECTS = @as(u32, 2);
pub const SCARD_READER_CONFISCATES = @as(u32, 4);
pub const SCARD_READER_CONTACTLESS = @as(u32, 8);
pub const SCARD_READER_TYPE_SERIAL = @as(u32, 1);
pub const SCARD_READER_TYPE_PARALELL = @as(u32, 2);
pub const SCARD_READER_TYPE_KEYBOARD = @as(u32, 4);
pub const SCARD_READER_TYPE_SCSI = @as(u32, 8);
pub const SCARD_READER_TYPE_IDE = @as(u32, 16);
pub const SCARD_READER_TYPE_USB = @as(u32, 32);
pub const SCARD_READER_TYPE_PCMCIA = @as(u32, 64);
pub const SCARD_READER_TYPE_TPM = @as(u32, 128);
pub const SCARD_READER_TYPE_NFC = @as(u32, 256);
pub const SCARD_READER_TYPE_UICC = @as(u32, 512);
pub const SCARD_READER_TYPE_NGC = @as(u32, 1024);
pub const SCARD_READER_TYPE_EMBEDDEDSE = @as(u32, 2048);
pub const SCARD_READER_TYPE_VENDOR = @as(u32, 240);
pub const GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE = Guid.initString("4283609d-4dc2-43be-bbb4-4f15dfce2c61");
pub const GUID_SCM_PD_HEALTH_NOTIFICATION = Guid.initString("9da2d386-72f5-4ee3-8155-eca0678e3b06");
pub const GUID_SCM_PD_PASSTHROUGH_INVDIMM = Guid.initString("4309ac30-0d11-11e4-9191-0800200c9a66");
pub const GUID_DEVINTERFACE_COMPORT = Guid.initString("86e0d1e0-8089-11d0-9ce4-08003e301f73");
pub const GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR = Guid.initString("4d36e978-e325-11ce-bfc1-08002be10318");
pub const FILE_DEVICE_BEEP = @as(u32, 1);
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM = @as(u32, 3);
pub const FILE_DEVICE_CONTROLLER = @as(u32, 4);
pub const FILE_DEVICE_DATALINK = @as(u32, 5);
pub const FILE_DEVICE_DFS = @as(u32, 6);
pub const FILE_DEVICE_DISK_FILE_SYSTEM = @as(u32, 8);
pub const FILE_DEVICE_FILE_SYSTEM = @as(u32, 9);
pub const FILE_DEVICE_INPORT_PORT = @as(u32, 10);
pub const FILE_DEVICE_KEYBOARD = @as(u32, 11);
pub const FILE_DEVICE_MAILSLOT = @as(u32, 12);
pub const FILE_DEVICE_MIDI_IN = @as(u32, 13);
pub const FILE_DEVICE_MIDI_OUT = @as(u32, 14);
pub const FILE_DEVICE_MOUSE = @as(u32, 15);
pub const FILE_DEVICE_MULTI_UNC_PROVIDER = @as(u32, 16);
pub const FILE_DEVICE_NAMED_PIPE = @as(u32, 17);
pub const FILE_DEVICE_NETWORK = @as(u32, 18);
pub const FILE_DEVICE_NETWORK_BROWSER = @as(u32, 19);
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM = @as(u32, 20);
pub const FILE_DEVICE_NULL = @as(u32, 21);
pub const FILE_DEVICE_PARALLEL_PORT = @as(u32, 22);
pub const FILE_DEVICE_PHYSICAL_NETCARD = @as(u32, 23);
pub const FILE_DEVICE_PRINTER = @as(u32, 24);
pub const FILE_DEVICE_SCANNER = @as(u32, 25);
pub const FILE_DEVICE_SERIAL_MOUSE_PORT = @as(u32, 26);
pub const FILE_DEVICE_SERIAL_PORT = @as(u32, 27);
pub const FILE_DEVICE_SCREEN = @as(u32, 28);
pub const FILE_DEVICE_SOUND = @as(u32, 29);
pub const FILE_DEVICE_STREAMS = @as(u32, 30);
pub const FILE_DEVICE_TAPE_FILE_SYSTEM = @as(u32, 32);
pub const FILE_DEVICE_TRANSPORT = @as(u32, 33);
pub const FILE_DEVICE_UNKNOWN = @as(u32, 34);
pub const FILE_DEVICE_VIDEO = @as(u32, 35);
pub const FILE_DEVICE_VIRTUAL_DISK = @as(u32, 36);
pub const FILE_DEVICE_WAVE_IN = @as(u32, 37);
pub const FILE_DEVICE_WAVE_OUT = @as(u32, 38);
pub const FILE_DEVICE_8042_PORT = @as(u32, 39);
pub const FILE_DEVICE_NETWORK_REDIRECTOR = @as(u32, 40);
pub const FILE_DEVICE_BATTERY = @as(u32, 41);
pub const FILE_DEVICE_BUS_EXTENDER = @as(u32, 42);
pub const FILE_DEVICE_MODEM = @as(u32, 43);
pub const FILE_DEVICE_VDM = @as(u32, 44);
pub const FILE_DEVICE_MASS_STORAGE = @as(u32, 45);
pub const FILE_DEVICE_SMB = @as(u32, 46);
pub const FILE_DEVICE_KS = @as(u32, 47);
pub const FILE_DEVICE_CHANGER = @as(u32, 48);
pub const FILE_DEVICE_ACPI = @as(u32, 50);
pub const FILE_DEVICE_FULLSCREEN_VIDEO = @as(u32, 52);
pub const FILE_DEVICE_DFS_FILE_SYSTEM = @as(u32, 53);
pub const FILE_DEVICE_DFS_VOLUME = @as(u32, 54);
pub const FILE_DEVICE_SERENUM = @as(u32, 55);
pub const FILE_DEVICE_TERMSRV = @as(u32, 56);
pub const FILE_DEVICE_KSEC = @as(u32, 57);
pub const FILE_DEVICE_FIPS = @as(u32, 58);
pub const FILE_DEVICE_INFINIBAND = @as(u32, 59);
pub const FILE_DEVICE_VMBUS = @as(u32, 62);
pub const FILE_DEVICE_CRYPT_PROVIDER = @as(u32, 63);
pub const FILE_DEVICE_WPD = @as(u32, 64);
pub const FILE_DEVICE_BLUETOOTH = @as(u32, 65);
pub const FILE_DEVICE_MT_COMPOSITE = @as(u32, 66);
pub const FILE_DEVICE_MT_TRANSPORT = @as(u32, 67);
pub const FILE_DEVICE_BIOMETRIC = @as(u32, 68);
pub const FILE_DEVICE_PMI = @as(u32, 69);
pub const FILE_DEVICE_EHSTOR = @as(u32, 70);
pub const FILE_DEVICE_DEVAPI = @as(u32, 71);
pub const FILE_DEVICE_GPIO = @as(u32, 72);
pub const FILE_DEVICE_USBEX = @as(u32, 73);
pub const FILE_DEVICE_CONSOLE = @as(u32, 80);
pub const FILE_DEVICE_NFP = @as(u32, 81);
pub const FILE_DEVICE_SYSENV = @as(u32, 82);
pub const FILE_DEVICE_VIRTUAL_BLOCK = @as(u32, 83);
pub const FILE_DEVICE_POINT_OF_SERVICE = @as(u32, 84);
pub const FILE_DEVICE_STORAGE_REPLICATION = @as(u32, 85);
pub const FILE_DEVICE_TRUST_ENV = @as(u32, 86);
pub const FILE_DEVICE_UCM = @as(u32, 87);
pub const FILE_DEVICE_UCMTCPCI = @as(u32, 88);
pub const FILE_DEVICE_PERSISTENT_MEMORY = @as(u32, 89);
pub const FILE_DEVICE_NVDIMM = @as(u32, 90);
pub const FILE_DEVICE_HOLOGRAPHIC = @as(u32, 91);
pub const FILE_DEVICE_SDFXHCI = @as(u32, 92);
pub const FILE_DEVICE_UCMUCSI = @as(u32, 93);
pub const METHOD_BUFFERED = @as(u32, 0);
pub const METHOD_IN_DIRECT = @as(u32, 1);
pub const METHOD_OUT_DIRECT = @as(u32, 2);
pub const METHOD_NEITHER = @as(u32, 3);
pub const FILE_ANY_ACCESS = @as(u32, 0);
pub const FILE_READ_ACCESS = @as(u32, 1);
pub const FILE_WRITE_ACCESS = @as(u32, 2);
pub const IOCTL_SCMBUS_DEVICE_FUNCTION_BASE = @as(u32, 0);
pub const IOCTL_SCM_LOGICAL_DEVICE_FUNCTION_BASE = @as(u32, 768);
pub const IOCTL_SCM_PHYSICAL_DEVICE_FUNCTION_BASE = @as(u32, 1536);
pub const SCM_MAX_SYMLINK_LEN_IN_CHARS = @as(u32, 256);
pub const MAX_INTERFACE_CODES = @as(u32, 8);
pub const SCM_PD_FIRMWARE_REVISION_LENGTH_BYTES = @as(u32, 32);
pub const SCM_PD_PROPERTY_NAME_LENGTH_IN_CHARS = @as(u32, 128);
pub const SCM_PD_MAX_OPERATIONAL_STATUS = @as(u32, 16);
pub const SCM_PD_FIRMWARE_LAST_DOWNLOAD = @as(u32, 1);
pub const PARTITION_ENTRY_UNUSED = @as(u32, 0);
pub const PARTITION_FAT_12 = @as(u32, 1);
pub const PARTITION_XENIX_1 = @as(u32, 2);
pub const PARTITION_XENIX_2 = @as(u32, 3);
pub const PARTITION_FAT_16 = @as(u32, 4);
pub const PARTITION_EXTENDED = @as(u32, 5);
pub const PARTITION_HUGE = @as(u32, 6);
pub const PARTITION_IFS = @as(u32, 7);
pub const PARTITION_OS2BOOTMGR = @as(u32, 10);
pub const PARTITION_FAT32 = @as(u32, 11);
pub const PARTITION_FAT32_XINT13 = @as(u32, 12);
pub const PARTITION_XINT13 = @as(u32, 14);
pub const PARTITION_XINT13_EXTENDED = @as(u32, 15);
pub const PARTITION_MSFT_RECOVERY = @as(u32, 39);
pub const PARTITION_MAIN_OS = @as(u32, 40);
pub const PARTIITON_OS_DATA = @as(u32, 41);
pub const PARTITION_PRE_INSTALLED = @as(u32, 42);
pub const PARTITION_BSP = @as(u32, 43);
pub const PARTITION_DPP = @as(u32, 44);
pub const PARTITION_WINDOWS_SYSTEM = @as(u32, 45);
pub const PARTITION_PREP = @as(u32, 65);
pub const PARTITION_LDM = @as(u32, 66);
pub const PARTITION_DM = @as(u32, 84);
pub const PARTITION_EZDRIVE = @as(u32, 85);
pub const PARTITION_UNIX = @as(u32, 99);
pub const PARTITION_SPACES_DATA = @as(u32, 215);
pub const PARTITION_SPACES = @as(u32, 231);
pub const PARTITION_GPT = @as(u32, 238);
pub const PARTITION_SYSTEM = @as(u32, 239);
pub const VALID_NTFT = @as(u32, 192);
pub const PARTITION_NTFT = @as(u32, 128);
pub const GPT_ATTRIBUTE_NO_BLOCK_IO_PROTOCOL = @as(u64, 2);
pub const GPT_ATTRIBUTE_LEGACY_BIOS_BOOTABLE = @as(u64, 4);
pub const GPT_BASIC_DATA_ATTRIBUTE_OFFLINE = @as(u64, 576460752303423488);
pub const GPT_BASIC_DATA_ATTRIBUTE_DAX = @as(u64, 288230376151711744);
pub const GPT_BASIC_DATA_ATTRIBUTE_SERVICE = @as(u64, 144115188075855872);
pub const GPT_SPACES_ATTRIBUTE_NO_METADATA = @as(u64, 9223372036854775808);
pub const HIST_NO_OF_BUCKETS = @as(u32, 24);
pub const DISK_LOGGING_START = @as(u32, 0);
pub const DISK_LOGGING_STOP = @as(u32, 1);
pub const DISK_LOGGING_DUMP = @as(u32, 2);
pub const DISK_BINNING = @as(u32, 3);
pub const CAP_ATA_ID_CMD = @as(u32, 1);
pub const CAP_ATAPI_ID_CMD = @as(u32, 2);
pub const CAP_SMART_CMD = @as(u32, 4);
pub const ATAPI_ID_CMD = @as(u32, 161);
pub const ID_CMD = @as(u32, 236);
pub const SMART_CMD = @as(u32, 176);
pub const SMART_CYL_LOW = @as(u32, 79);
pub const SMART_CYL_HI = @as(u32, 194);
pub const SMART_NO_ERROR = @as(u32, 0);
pub const SMART_IDE_ERROR = @as(u32, 1);
pub const SMART_INVALID_FLAG = @as(u32, 2);
pub const SMART_INVALID_COMMAND = @as(u32, 3);
pub const SMART_INVALID_BUFFER = @as(u32, 4);
pub const SMART_INVALID_DRIVE = @as(u32, 5);
pub const SMART_INVALID_IOCTL = @as(u32, 6);
pub const SMART_ERROR_NO_MEM = @as(u32, 7);
pub const SMART_INVALID_REGISTER = @as(u32, 8);
pub const SMART_NOT_SUPPORTED = @as(u32, 9);
pub const SMART_NO_IDE_DEVICE = @as(u32, 10);
pub const SMART_OFFLINE_ROUTINE_OFFLINE = @as(u32, 0);
pub const SMART_SHORT_SELFTEST_OFFLINE = @as(u32, 1);
pub const SMART_EXTENDED_SELFTEST_OFFLINE = @as(u32, 2);
pub const SMART_ABORT_OFFLINE_SELFTEST = @as(u32, 127);
pub const SMART_SHORT_SELFTEST_CAPTIVE = @as(u32, 129);
pub const SMART_EXTENDED_SELFTEST_CAPTIVE = @as(u32, 130);
pub const READ_ATTRIBUTE_BUFFER_SIZE = @as(u32, 512);
pub const IDENTIFY_BUFFER_SIZE = @as(u32, 512);
pub const READ_THRESHOLD_BUFFER_SIZE = @as(u32, 512);
pub const SMART_LOG_SECTOR_SIZE = @as(u32, 512);
pub const READ_ATTRIBUTES = @as(u32, 208);
pub const READ_THRESHOLDS = @as(u32, 209);
pub const ENABLE_DISABLE_AUTOSAVE = @as(u32, 210);
pub const SAVE_ATTRIBUTE_VALUES = @as(u32, 211);
pub const EXECUTE_OFFLINE_DIAGS = @as(u32, 212);
pub const SMART_READ_LOG = @as(u32, 213);
pub const SMART_WRITE_LOG = @as(u32, 214);
pub const ENABLE_SMART = @as(u32, 216);
pub const DISABLE_SMART = @as(u32, 217);
pub const RETURN_SMART_STATUS = @as(u32, 218);
pub const ENABLE_DISABLE_AUTO_OFFLINE = @as(u32, 219);
pub const DISK_ATTRIBUTE_OFFLINE = @as(u64, 1);
pub const DISK_ATTRIBUTE_READ_ONLY = @as(u64, 2);
pub const MAX_VOLUME_ID_SIZE = @as(u32, 36);
pub const MAX_VOLUME_TEMPLATE_SIZE = @as(u32, 40);
pub const VENDOR_ID_LENGTH = @as(u32, 8);
pub const PRODUCT_ID_LENGTH = @as(u32, 16);
pub const REVISION_LENGTH = @as(u32, 4);
pub const SERIAL_NUMBER_LENGTH = @as(u32, 32);
pub const CHANGER_RESERVED_BIT = @as(u32, 2147483648);
pub const CHANGER_TO_TRANSPORT = @as(u32, 1);
pub const CHANGER_TO_SLOT = @as(u32, 2);
pub const CHANGER_TO_IEPORT = @as(u32, 4);
pub const CHANGER_TO_DRIVE = @as(u32, 8);
pub const LOCK_UNLOCK_IEPORT = @as(u32, 1);
pub const LOCK_UNLOCK_DOOR = @as(u32, 2);
pub const LOCK_UNLOCK_KEYPAD = @as(u32, 4);
pub const LOCK_ELEMENT = @as(u32, 0);
pub const UNLOCK_ELEMENT = @as(u32, 1);
pub const EXTEND_IEPORT = @as(u32, 2);
pub const RETRACT_IEPORT = @as(u32, 3);
pub const ERROR_LABEL_UNREADABLE = @as(u32, 1);
pub const ERROR_LABEL_QUESTIONABLE = @as(u32, 2);
pub const ERROR_SLOT_NOT_PRESENT = @as(u32, 4);
pub const ERROR_DRIVE_NOT_INSTALLED = @as(u32, 8);
pub const ERROR_TRAY_MALFUNCTION = @as(u32, 16);
pub const ERROR_INIT_STATUS_NEEDED = @as(u32, 17);
pub const ERROR_UNHANDLED_ERROR = @as(u32, 4294967295);
pub const SEARCH_ALL = @as(u32, 0);
pub const SEARCH_PRIMARY = @as(u32, 1);
pub const SEARCH_ALTERNATE = @as(u32, 2);
pub const SEARCH_ALL_NO_SEQ = @as(u32, 4);
pub const SEARCH_PRI_NO_SEQ = @as(u32, 5);
pub const SEARCH_ALT_NO_SEQ = @as(u32, 6);
pub const ASSERT_PRIMARY = @as(u32, 8);
pub const ASSERT_ALTERNATE = @as(u32, 9);
pub const REPLACE_PRIMARY = @as(u32, 10);
pub const REPLACE_ALTERNATE = @as(u32, 11);
pub const UNDEFINE_PRIMARY = @as(u32, 12);
pub const UNDEFINE_ALTERNATE = @as(u32, 13);
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA = @as(u32, 1);
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE = @as(u32, 1);
pub const USN_PAGE_SIZE = @as(u32, 4096);
pub const USN_REASON_DATA_OVERWRITE = @as(u32, 1);
pub const USN_REASON_DATA_EXTEND = @as(u32, 2);
pub const USN_REASON_DATA_TRUNCATION = @as(u32, 4);
pub const USN_REASON_NAMED_DATA_OVERWRITE = @as(u32, 16);
pub const USN_REASON_NAMED_DATA_EXTEND = @as(u32, 32);
pub const USN_REASON_NAMED_DATA_TRUNCATION = @as(u32, 64);
pub const USN_REASON_FILE_CREATE = @as(u32, 256);
pub const USN_REASON_FILE_DELETE = @as(u32, 512);
pub const USN_REASON_EA_CHANGE = @as(u32, 1024);
pub const USN_REASON_SECURITY_CHANGE = @as(u32, 2048);
pub const USN_REASON_RENAME_OLD_NAME = @as(u32, 4096);
pub const USN_REASON_RENAME_NEW_NAME = @as(u32, 8192);
pub const USN_REASON_INDEXABLE_CHANGE = @as(u32, 16384);
pub const USN_REASON_BASIC_INFO_CHANGE = @as(u32, 32768);
pub const USN_REASON_HARD_LINK_CHANGE = @as(u32, 65536);
pub const USN_REASON_COMPRESSION_CHANGE = @as(u32, 131072);
pub const USN_REASON_ENCRYPTION_CHANGE = @as(u32, 262144);
pub const USN_REASON_OBJECT_ID_CHANGE = @as(u32, 524288);
pub const USN_REASON_REPARSE_POINT_CHANGE = @as(u32, 1048576);
pub const USN_REASON_STREAM_CHANGE = @as(u32, 2097152);
pub const USN_REASON_TRANSACTED_CHANGE = @as(u32, 4194304);
pub const USN_REASON_INTEGRITY_CHANGE = @as(u32, 8388608);
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE = @as(u32, 16777216);
pub const USN_REASON_CLOSE = @as(u32, 2147483648);
pub const USN_DELETE_VALID_FLAGS = @as(u32, 3);
pub const MARK_HANDLE_PROTECT_CLUSTERS = @as(u32, 1);
pub const MARK_HANDLE_TXF_SYSTEM_LOG = @as(u32, 4);
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG = @as(u32, 8);
pub const MARK_HANDLE_REALTIME = @as(u32, 32);
pub const MARK_HANDLE_NOT_REALTIME = @as(u32, 64);
pub const MARK_HANDLE_FILTER_METADATA = @as(u32, 512);
pub const MARK_HANDLE_CLOUD_SYNC = @as(u32, 2048);
pub const MARK_HANDLE_READ_COPY = @as(u32, 128);
pub const MARK_HANDLE_NOT_READ_COPY = @as(u32, 256);
pub const MARK_HANDLE_RETURN_PURGE_FAILURE = @as(u32, 1024);
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION = @as(u32, 4096);
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO = @as(u32, 8192);
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES = @as(u32, 16384);
pub const MARK_HANDLE_ENABLE_CPU_CACHE = @as(u32, 268435456);
pub const VOLUME_IS_DIRTY = @as(u32, 1);
pub const VOLUME_UPGRADE_SCHEDULED = @as(u32, 2);
pub const VOLUME_SESSION_OPEN = @as(u32, 4);
pub const FILE_PREFETCH_TYPE_FOR_CREATE = @as(u32, 1);
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM = @as(u32, 2);
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX = @as(u32, 3);
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX = @as(u32, 4);
pub const FILE_PREFETCH_TYPE_MAX = @as(u32, 4);
pub const FILESYSTEM_STATISTICS_TYPE_REFS = @as(u32, 4);
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA = @as(u32, 1);
pub const FILE_SET_ENCRYPTION = @as(u32, 1);
pub const FILE_CLEAR_ENCRYPTION = @as(u32, 2);
pub const STREAM_SET_ENCRYPTION = @as(u32, 3);
pub const STREAM_CLEAR_ENCRYPTION = @as(u32, 4);
pub const MAXIMUM_ENCRYPTION_VALUE = @as(u32, 4);
pub const ENCRYPTION_FORMAT_DEFAULT = @as(u32, 1);
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE = @as(u32, 1);
pub const COPYFILE_SIS_LINK = @as(u32, 1);
pub const COPYFILE_SIS_REPLACE = @as(u32, 2);
pub const COPYFILE_SIS_FLAGS = @as(u32, 3);
pub const SET_REPAIR_ENABLED = @as(u32, 1);
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS = @as(u32, 8);
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT = @as(u32, 16);
pub const SET_REPAIR_VALID_MASK = @as(u32, 25);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE = @as(u64, 1);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED = @as(u64, 2);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST = @as(u64, 4);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD = @as(u64, 8);
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE = @as(u64, 16);
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED = @as(u64, 32);
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR = @as(u64, 64);
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED = @as(u64, 128);
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED = @as(u64, 256);
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED = @as(u64, 512);
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED = @as(u64, 1024);
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG = @as(u64, 2048);
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND = @as(u64, 4096);
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK = @as(u64, 8192);
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION = @as(u64, 16384);
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE = @as(u64, 32768);
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST = @as(u64, 65536);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH = @as(u64, 131072);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN = @as(u64, 262144);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD = @as(u64, 524288);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT = @as(u64, 1048576);
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID = @as(u64, 2097152);
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH = @as(u64, 4194304);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT = @as(u64, 8388608);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE = @as(u64, 16777216);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED = @as(u64, 33554432);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST = @as(u64, 67108864);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD = @as(u64, 134217728);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX = @as(u64, 268435456);
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY = @as(u64, 536870912);
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES = @as(u64, 1073741824);
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE = @as(u64, 2147483648);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN = @as(u64, 4294967296);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN = @as(u64, 8589934592);
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT = @as(u64, 17179869184);
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN = @as(u64, 34359738368);
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL = @as(u64, 68719476736);
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT = @as(u64, 137438953472);
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG = @as(u64, 274877906944);
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID = @as(u64, 549755813888);
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH = @as(u64, 1099511627776);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME = @as(u64, 2199023255552);
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES = @as(u64, 4398046511104);
pub const TXFS_LOGGING_MODE_SIMPLE = @as(u32, 1);
pub const TXFS_LOGGING_MODE_FULL = @as(u32, 2);
pub const TXFS_TRANSACTION_STATE_NONE = @as(u32, 0);
pub const TXFS_TRANSACTION_STATE_ACTIVE = @as(u32, 1);
pub const TXFS_TRANSACTION_STATE_PREPARED = @as(u32, 2);
pub const TXFS_TRANSACTION_STATE_NOTACTIVE = @as(u32, 3);
pub const TXFS_RM_STATE_NOT_STARTED = @as(u32, 0);
pub const TXFS_RM_STATE_STARTING = @as(u32, 1);
pub const TXFS_RM_STATE_ACTIVE = @as(u32, 2);
pub const TXFS_RM_STATE_SHUTTING_DOWN = @as(u32, 3);
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN = @as(u32, 1);
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK = @as(u32, 2);
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX = @as(u32, 1);
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN = @as(u32, 2);
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE = @as(u32, 4);
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = @as(u32, 8);
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = @as(u32, 16);
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = @as(u32, 32);
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = @as(u32, 64);
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = @as(u32, 128);
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT = @as(u32, 512);
pub const TXFS_START_RM_FLAG_LOGGING_MODE = @as(u32, 1024);
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES = @as(u32, 2048);
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY = @as(u32, 4096);
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY = @as(u32, 8192);
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED = @as(u32, 1);
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED = @as(u32, 2);
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED = @as(u32, 4294967294);
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED = @as(u32, 4294967295);
pub const TXFS_SAVEPOINT_SET = @as(u32, 1);
pub const TXFS_SAVEPOINT_ROLLBACK = @as(u32, 2);
pub const TXFS_SAVEPOINT_CLEAR = @as(u32, 4);
pub const TXFS_SAVEPOINT_CLEAR_ALL = @as(u32, 16);
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED = @as(u32, 1);
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED = @as(u32, 2);
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY = @as(u32, 4);
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY = @as(u32, 8);
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING = @as(u32, 16);
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM = @as(u32, 32);
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM = @as(u32, 64);
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING = @as(u32, 128);
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED = @as(u32, 256);
pub const PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES = @as(u32, 512);
pub const OPLOCK_LEVEL_CACHE_READ = @as(u32, 1);
pub const OPLOCK_LEVEL_CACHE_HANDLE = @as(u32, 2);
pub const OPLOCK_LEVEL_CACHE_WRITE = @as(u32, 4);
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST = @as(u32, 1);
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK = @as(u32, 2);
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE = @as(u32, 4);
pub const REQUEST_OPLOCK_CURRENT_VERSION = @as(u32, 1);
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED = @as(u32, 1);
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED = @as(u32, 2);
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES = @as(u32, 1);
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES = @as(u32, 2);
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID = @as(u32, 1);
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS = @as(u32, 65536);
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS = @as(u32, 131072);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE = @as(u32, 1);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET = @as(u32, 2);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE = @as(u32, 4);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE = @as(u32, 8);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK = @as(u32, 4278190080);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA = @as(u32, 16777216);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX = @as(u32, 33554432);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM = @as(u32, 50331648);
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN = @as(u32, 1);
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END = @as(u32, 2);
pub const FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE = Guid.initString("0d0a64a1-38fc-4db8-9fe7-3f4352cd7c5c");
pub const FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE = Guid.initString("b7624d64-b9a3-4cf8-8011-5b86c940e7b7");
pub const FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE = Guid.initString("9d453eb7-d2a6-4dbd-a2e3-fbd0ed9109a9");
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED = @as(u32, 1);
pub const CSV_INVALID_DEVICE_NUMBER = @as(u32, 4294967295);
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1 = @as(u32, 1);
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED = @as(u32, 1);
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED = @as(u32, 2);
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED = @as(u32, 4);
pub const QUERY_FILE_LAYOUT_RESTART = @as(u32, 1);
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES = @as(u32, 2);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS = @as(u32, 4);
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS = @as(u32, 8);
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO = @as(u32, 16);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED = @as(u32, 32);
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES = @as(u32, 64);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION = @as(u32, 128);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE = @as(u32, 256);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE = @as(u32, 512);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE = @as(u32, 1024);
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES = @as(u32, 2048);
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE = @as(u32, 4096);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE = @as(u32, 8192);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE = @as(u32, 16384);
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE = @as(u32, 32768);
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED = @as(u32, 1);
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY = @as(u32, 1);
pub const FILE_LAYOUT_NAME_ENTRY_DOS = @as(u32, 2);
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE = @as(u32, 1);
pub const STREAM_LAYOUT_ENTRY_PINNED = @as(u32, 2);
pub const STREAM_LAYOUT_ENTRY_RESIDENT = @as(u32, 4);
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED = @as(u32, 8);
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION = @as(u32, 16);
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS = @as(u32, 1);
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS = @as(u32, 2);
pub const CHECKSUM_TYPE_UNCHANGED = @as(i32, -1);
pub const CHECKSUM_TYPE_NONE = @as(u32, 0);
pub const CHECKSUM_TYPE_CRC32 = @as(u32, 1);
pub const CHECKSUM_TYPE_CRC64 = @as(u32, 2);
pub const CHECKSUM_TYPE_ECC = @as(u32, 3);
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE = @as(u32, 4);
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF = @as(u32, 1);
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE = @as(u32, 1);
pub const SET_PURGE_FAILURE_MODE_ENABLED = @as(u32, 1);
pub const SET_PURGE_FAILURE_MODE_DISABLED = @as(u32, 2);
pub const FILE_REGION_USAGE_VALID_CACHED_DATA = @as(u32, 1);
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA = @as(u32, 2);
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT = @as(u32, 4);
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT = @as(u32, 8);
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT = @as(u32, 16);
pub const FILE_STORAGE_TIER_NAME_LENGTH = @as(u32, 256);
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH = @as(u32, 512);
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE = @as(u32, 2097152);
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE = @as(u32, 4194304);
pub const FILE_STORAGE_TIER_FLAG_PARITY = @as(u32, 8388608);
pub const FILE_STORAGE_TIER_FLAG_SMR = @as(u32, 16777216);
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE = @as(u32, 2147483648);
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ = @as(u32, 1073741824);
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME = @as(u32, 536870912);
pub const QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID = @as(u32, 1);
pub const QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID = @as(u32, 2);
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC = @as(u32, 1);
pub const DUPLICATE_EXTENTS_DATA_EX_ASYNC = @as(u32, 2);
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1 = @as(u32, 1);
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1 = @as(u32, 1);
pub const STREAMS_INVALID_ID = @as(u32, 0);
pub const STREAMS_ASSOCIATE_ID_CLEAR = @as(u32, 1);
pub const STREAMS_ASSOCIATE_ID_SET = @as(u32, 2);
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY = @as(u32, 1);
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED = @as(u32, 2);
pub const WOF_CURRENT_VERSION = @as(u32, 1);
pub const WOF_PROVIDER_WIM = @as(u32, 1);
pub const WOF_PROVIDER_FILE = @as(u32, 2);
pub const WOF_PROVIDER_CLOUD = @as(u32, 3);
pub const WIM_PROVIDER_HASH_SIZE = @as(u32, 20);
pub const WIM_PROVIDER_CURRENT_VERSION = @as(u32, 1);
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE = @as(u32, 1);
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED = @as(u32, 2);
pub const WIM_BOOT_OS_WIM = @as(u32, 1);
pub const WIM_BOOT_NOT_OS_WIM = @as(u32, 0);
pub const FILE_PROVIDER_CURRENT_VERSION = @as(u32, 1);
pub const FILE_PROVIDER_SINGLE_FILE = @as(u32, 1);
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K = @as(u32, 0);
pub const FILE_PROVIDER_COMPRESSION_LZX = @as(u32, 1);
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K = @as(u32, 2);
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K = @as(u32, 3);
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM = @as(u32, 4);
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE = @as(u32, 1);
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER = @as(u32, 1);
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT = @as(u32, 1);
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT = @as(u32, 2);
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT = @as(u32, 4);
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT = @as(u32, 8);
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT = @as(u32, 16);
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT = @as(u32, 32);
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT = @as(u32, 64);
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT = @as(u32, 128);
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME = @as(u32, 256);
pub const CONTAINER_ROOT_INFO_VALID_FLAGS = @as(u32, 511);
pub const PROJFS_PROTOCOL_VERSION = @as(u32, 3);
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = @as(u32, 1);
pub const IOCTL_VOLUME_BASE = @as(u32, 86);
pub const EFS_TRACKED_OFFSET_HEADER_FLAG = @as(u32, 1);
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG = @as(u32, 2);
pub const ROTFLAGS_REGISTRATIONKEEPSALIVE = @as(u32, 1);
pub const ROTFLAGS_ALLOWANYCLIENT = @as(u32, 2);
pub const ROT_COMPARE_MAX = @as(u32, 2048);
pub const WDT_INPROC_CALL = @as(u32, 1215587415);
pub const WDT_REMOTE_CALL = @as(u32, 1383359575);
pub const WDT_INPROC64_CALL = @as(u32, 1349805143);
pub const PERF_DATA_VERSION = @as(u32, 1);
pub const PERF_DATA_REVISION = @as(u32, 1);
pub const PERF_NO_INSTANCES = @as(i32, -1);
pub const PERF_SIZE_DWORD = @as(u32, 0);
pub const PERF_SIZE_LARGE = @as(u32, 256);
pub const PERF_SIZE_ZERO = @as(u32, 512);
pub const PERF_SIZE_VARIABLE_LEN = @as(u32, 768);
pub const PERF_TYPE_NUMBER = @as(u32, 0);
pub const PERF_TYPE_COUNTER = @as(u32, 1024);
pub const PERF_TYPE_TEXT = @as(u32, 2048);
pub const PERF_TYPE_ZERO = @as(u32, 3072);
pub const PERF_NUMBER_HEX = @as(u32, 0);
pub const PERF_NUMBER_DECIMAL = @as(u32, 65536);
pub const PERF_NUMBER_DEC_1000 = @as(u32, 131072);
pub const PERF_COUNTER_VALUE = @as(u32, 0);
pub const PERF_COUNTER_RATE = @as(u32, 65536);
pub const PERF_COUNTER_FRACTION = @as(u32, 131072);
pub const PERF_COUNTER_BASE = @as(u32, 196608);
pub const PERF_COUNTER_ELAPSED = @as(u32, 262144);
pub const PERF_COUNTER_QUEUELEN = @as(u32, 327680);
pub const PERF_COUNTER_HISTOGRAM = @as(u32, 393216);
pub const PERF_COUNTER_PRECISION = @as(u32, 458752);
pub const PERF_TEXT_UNICODE = @as(u32, 0);
pub const PERF_TEXT_ASCII = @as(u32, 65536);
pub const PERF_TIMER_TICK = @as(u32, 0);
pub const PERF_TIMER_100NS = @as(u32, 1048576);
pub const PERF_OBJECT_TIMER = @as(u32, 2097152);
pub const PERF_DELTA_COUNTER = @as(u32, 4194304);
pub const PERF_DELTA_BASE = @as(u32, 8388608);
pub const PERF_INVERSE_COUNTER = @as(u32, 16777216);
pub const PERF_MULTI_COUNTER = @as(u32, 33554432);
pub const PERF_DISPLAY_NO_SUFFIX = @as(u32, 0);
pub const PERF_DISPLAY_PER_SEC = @as(u32, 268435456);
pub const PERF_DISPLAY_PERCENT = @as(u32, 536870912);
pub const PERF_DISPLAY_SECONDS = @as(u32, 805306368);
pub const PERF_DISPLAY_NOSHOW = @as(u32, 1073741824);
pub const PERF_COUNTER_HISTOGRAM_TYPE = @as(u32, 2147483648);
pub const PERF_NO_UNIQUE_ID = @as(i32, -1);
pub const MAX_PERF_OBJECTS_IN_QUERY_FUNCTION = @as(i32, 64);
pub const WINPERF_LOG_NONE = @as(u32, 0);
pub const WINPERF_LOG_USER = @as(u32, 1);
pub const WINPERF_LOG_DEBUG = @as(u32, 2);
pub const WINPERF_LOG_VERBOSE = @as(u32, 3);
pub const TIME_ONESHOT = @as(u32, 0);
pub const TIME_PERIODIC = @as(u32, 1);
pub const TIME_CALLBACK_FUNCTION = @as(u32, 0);
pub const TIME_CALLBACK_EVENT_SET = @as(u32, 16);
pub const TIME_CALLBACK_EVENT_PULSE = @as(u32, 32);
pub const TIME_KILL_SYNCHRONOUS = @as(u32, 256);
pub const VS_VERSION_INFO = @as(u32, 1);
pub const VS_USER_DEFINED = @as(u32, 100);
pub const VS_FFI_SIGNATURE = @as(i32, -17890115);
pub const VS_FFI_STRUCVERSION = @as(i32, 65536);
pub const VS_FFI_FILEFLAGSMASK = @as(i32, 63);
pub const VOS_WINCE = @as(i32, 327680);
pub const VOS__BASE = @as(i32, 0);
pub const VOS_DOS_WINDOWS16 = @as(i32, 65537);
pub const VOS_DOS_WINDOWS32 = @as(i32, 65540);
pub const VOS_OS216_PM16 = @as(i32, 131074);
pub const VOS_OS232_PM32 = @as(i32, 196611);
pub const VOS_NT_WINDOWS32 = @as(i32, 262148);
pub const VFT2_DRV_INPUTMETHOD = @as(i32, 11);
pub const VFT2_FONT_RASTER = @as(i32, 1);
pub const VFT2_FONT_VECTOR = @as(i32, 2);
pub const VFT2_FONT_TRUETYPE = @as(i32, 3);
pub const VFFF_ISSHAREDFILE = @as(u32, 1);
pub const VFF_CURNEDEST = @as(u32, 1);
pub const VFF_FILEINUSE = @as(u32, 2);
pub const VFF_BUFFTOOSMALL = @as(u32, 4);
pub const VIF_TEMPFILE = @as(i32, 1);
pub const VIF_MISMATCH = @as(i32, 2);
pub const VIF_SRCOLD = @as(i32, 4);
pub const VIF_DIFFLANG = @as(i32, 8);
pub const VIF_DIFFCODEPG = @as(i32, 16);
pub const VIF_DIFFTYPE = @as(i32, 32);
pub const VIF_WRITEPROT = @as(i32, 64);
pub const VIF_FILEINUSE = @as(i32, 128);
pub const VIF_OUTOFSPACE = @as(i32, 256);
pub const VIF_ACCESSVIOLATION = @as(i32, 512);
pub const VIF_SHARINGVIOLATION = @as(i32, 1024);
pub const VIF_CANNOTCREATE = @as(i32, 2048);
pub const VIF_CANNOTDELETE = @as(i32, 4096);
pub const VIF_CANNOTRENAME = @as(i32, 8192);
pub const VIF_CANNOTDELETECUR = @as(i32, 16384);
pub const VIF_OUTOFMEMORY = @as(i32, 32768);
pub const VIF_CANNOTREADSRC = @as(i32, 65536);
pub const VIF_CANNOTREADDST = @as(i32, 131072);
pub const VIF_BUFFTOOSMALL = @as(i32, 262144);
pub const VIF_CANNOTLOADLZ32 = @as(i32, 524288);
pub const VIF_CANNOTLOADCABINET = @as(i32, 1048576);
pub const FILE_VER_GET_LOCALISED = @as(u32, 1);
pub const FILE_VER_GET_NEUTRAL = @as(u32, 2);
pub const FILE_VER_GET_PREFETCHED = @as(u32, 4);
pub const CONSOLE_NO_SELECTION = @as(u32, 0);
pub const CONSOLE_SELECTION_IN_PROGRESS = @as(u32, 1);
pub const CONSOLE_SELECTION_NOT_EMPTY = @as(u32, 2);
pub const CONSOLE_MOUSE_SELECTION = @as(u32, 4);
pub const CONSOLE_MOUSE_DOWN = @as(u32, 8);
pub const HISTORY_NO_DUP_FLAG = @as(u32, 1);
pub const CONSOLE_FULLSCREEN = @as(u32, 1);
pub const CONSOLE_FULLSCREEN_HARDWARE = @as(u32, 2);
pub const CONSOLE_FULLSCREEN_MODE = @as(u32, 1);
pub const CONSOLE_WINDOWED_MODE = @as(u32, 2);
pub const ENABLE_EXTENDED_FLAGS = @as(u32, 128);
pub const ENABLE_AUTO_POSITION = @as(u32, 256);
pub const CTRL_C_EVENT = @as(u32, 0);
pub const CTRL_BREAK_EVENT = @as(u32, 1);
pub const CTRL_CLOSE_EVENT = @as(u32, 2);
pub const CTRL_LOGOFF_EVENT = @as(u32, 5);
pub const CTRL_SHUTDOWN_EVENT = @as(u32, 6);
pub const PSEUDOCONSOLE_INHERIT_CURSOR = @as(u32, 1);
pub const RIGHT_ALT_PRESSED = @as(u32, 1);
pub const LEFT_ALT_PRESSED = @as(u32, 2);
pub const RIGHT_CTRL_PRESSED = @as(u32, 4);
pub const LEFT_CTRL_PRESSED = @as(u32, 8);
pub const SHIFT_PRESSED = @as(u32, 16);
pub const NUMLOCK_ON = @as(u32, 32);
pub const SCROLLLOCK_ON = @as(u32, 64);
pub const CAPSLOCK_ON = @as(u32, 128);
pub const ENHANCED_KEY = @as(u32, 256);
pub const NLS_DBCSCHAR = @as(u32, 65536);
pub const NLS_ALPHANUMERIC = @as(u32, 0);
pub const NLS_KATAKANA = @as(u32, 131072);
pub const NLS_HIRAGANA = @as(u32, 262144);
pub const NLS_ROMAN = @as(u32, 4194304);
pub const NLS_IME_CONVERSION = @as(u32, 8388608);
pub const ALTNUMPAD_BIT = @as(u32, 67108864);
pub const NLS_IME_DISABLE = @as(u32, 536870912);
pub const FROM_LEFT_1ST_BUTTON_PRESSED = @as(u32, 1);
pub const RIGHTMOST_BUTTON_PRESSED = @as(u32, 2);
pub const FROM_LEFT_2ND_BUTTON_PRESSED = @as(u32, 4);
pub const FROM_LEFT_3RD_BUTTON_PRESSED = @as(u32, 8);
pub const FROM_LEFT_4TH_BUTTON_PRESSED = @as(u32, 16);
pub const MOUSE_MOVED = @as(u32, 1);
pub const DOUBLE_CLICK = @as(u32, 2);
pub const MOUSE_WHEELED = @as(u32, 4);
pub const MOUSE_HWHEELED = @as(u32, 8);
pub const KEY_EVENT = @as(u32, 1);
pub const MOUSE_EVENT = @as(u32, 2);
pub const WINDOW_BUFFER_SIZE_EVENT = @as(u32, 4);
pub const MENU_EVENT = @as(u32, 8);
pub const FOCUS_EVENT = @as(u32, 16);
pub const FILE_CACHE_MAX_HARD_ENABLE = @as(u32, 1);
pub const FILE_CACHE_MAX_HARD_DISABLE = @as(u32, 2);
pub const FILE_CACHE_MIN_HARD_ENABLE = @as(u32, 4);
pub const FILE_CACHE_MIN_HARD_DISABLE = @as(u32, 8);
pub const MEHC_PATROL_SCRUBBER_PRESENT = @as(u32, 1);
pub const PROCESS_HEAP_REGION = @as(u32, 1);
pub const PROCESS_HEAP_UNCOMMITTED_RANGE = @as(u32, 2);
pub const PROCESS_HEAP_ENTRY_BUSY = @as(u32, 4);
pub const PROCESS_HEAP_SEG_ALLOC = @as(u32, 8);
pub const PROCESS_HEAP_ENTRY_MOVEABLE = @as(u32, 16);
pub const PROCESS_HEAP_ENTRY_DDESHARE = @as(u32, 32);
pub const LMEM_NOCOMPACT = @as(u32, 16);
pub const LMEM_NODISCARD = @as(u32, 32);
pub const LMEM_MODIFY = @as(u32, 128);
pub const LMEM_DISCARDABLE = @as(u32, 3840);
pub const LMEM_VALID_FLAGS = @as(u32, 3954);
pub const LMEM_INVALID_HANDLE = @as(u32, 32768);
pub const LMEM_DISCARDED = @as(u32, 16384);
pub const LMEM_LOCKCOUNT = @as(u32, 255);
pub const REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION = @as(u32, 1);
pub const EnableSysTrayBatteryMeter = @as(u32, 1);
pub const EnableMultiBatteryDisplay = @as(u32, 2);
pub const EnablePasswordLogon = @as(u32, 4);
pub const EnableWakeOnRing = @as(u32, 8);
pub const EnableVideoDimDisplay = @as(u32, 16);
pub const POWER_ATTRIBUTE_HIDE = @as(u32, 1);
pub const POWER_ATTRIBUTE_SHOW_AOAC = @as(u32, 2);
pub const DEVICEPOWER_HARDWAREID = @as(u32, 2147483648);
pub const DEVICEPOWER_AND_OPERATION = @as(u32, 1073741824);
pub const DEVICEPOWER_FILTER_DEVICES_PRESENT = @as(u32, 536870912);
pub const DEVICEPOWER_FILTER_HARDWARE = @as(u32, 268435456);
pub const DEVICEPOWER_FILTER_WAKEENABLED = @as(u32, 134217728);
pub const DEVICEPOWER_FILTER_WAKEPROGRAMMABLE = @as(u32, 67108864);
pub const DEVICEPOWER_FILTER_ON_NAME = @as(u32, 33554432);
pub const DEVICEPOWER_SET_WAKEENABLED = @as(u32, 1);
pub const DEVICEPOWER_CLEAR_WAKEENABLED = @as(u32, 2);
pub const PDCAP_S0_SUPPORTED = @as(u32, 65536);
pub const PDCAP_S1_SUPPORTED = @as(u32, 131072);
pub const PDCAP_S2_SUPPORTED = @as(u32, 262144);
pub const PDCAP_S3_SUPPORTED = @as(u32, 524288);
pub const PDCAP_WAKE_FROM_S0_SUPPORTED = @as(u32, 1048576);
pub const PDCAP_WAKE_FROM_S1_SUPPORTED = @as(u32, 2097152);
pub const PDCAP_WAKE_FROM_S2_SUPPORTED = @as(u32, 4194304);
pub const PDCAP_WAKE_FROM_S3_SUPPORTED = @as(u32, 8388608);
pub const PDCAP_S4_SUPPORTED = @as(u32, 16777216);
pub const PDCAP_S5_SUPPORTED = @as(u32, 33554432);
pub const THERMAL_EVENT_VERSION = @as(u32, 1);
pub const VDS_NF_VOLUME_ARRIVE = @as(u32, 4);
pub const VDS_NF_VOLUME_DEPART = @as(u32, 5);
pub const VDS_NF_VOLUME_MODIFY = @as(u32, 6);
pub const VDS_NF_VOLUME_REBUILDING_PROGRESS = @as(u32, 7);
pub const VDS_NF_PARTITION_ARRIVE = @as(u32, 11);
pub const VDS_NF_PARTITION_DEPART = @as(u32, 12);
pub const VDS_NF_PARTITION_MODIFY = @as(u32, 13);
pub const VDS_NF_SUB_SYSTEM_ARRIVE = @as(u32, 101);
pub const VDS_NF_SUB_SYSTEM_DEPART = @as(u32, 102);
pub const VDS_NF_PORTAL_ARRIVE = @as(u32, 123);
pub const VDS_NF_PORTAL_DEPART = @as(u32, 124);
pub const VDS_NF_PORTAL_MODIFY = @as(u32, 125);
pub const VDS_NF_TARGET_ARRIVE = @as(u32, 126);
pub const VDS_NF_TARGET_DEPART = @as(u32, 127);
pub const VDS_NF_TARGET_MODIFY = @as(u32, 128);
pub const VDS_NF_PORTAL_GROUP_ARRIVE = @as(u32, 129);
pub const VDS_NF_PORTAL_GROUP_DEPART = @as(u32, 130);
pub const VDS_NF_PORTAL_GROUP_MODIFY = @as(u32, 131);
pub const VDS_NF_SUB_SYSTEM_MODIFY = @as(u32, 151);
pub const VDS_NF_DRIVE_LETTER_FREE = @as(u32, 201);
pub const VDS_NF_DRIVE_LETTER_ASSIGN = @as(u32, 202);
pub const VDS_NF_MOUNT_POINTS_CHANGE = @as(u32, 205);
pub const VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS = @as(u32, 206);
pub const VDS_NF_SERVICE_OUT_OF_SYNC = @as(u32, 301);
pub const GPT_PARTITION_NAME_LENGTH = @as(u32, 36);
pub const VDS_HINT_FASTCRASHRECOVERYREQUIRED = @as(i32, 1);
pub const VDS_HINT_MOSTLYREADS = @as(i32, 2);
pub const VDS_HINT_OPTIMIZEFORSEQUENTIALREADS = @as(i32, 4);
pub const VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES = @as(i32, 8);
pub const VDS_HINT_READBACKVERIFYENABLED = @as(i32, 16);
pub const VDS_HINT_REMAPENABLED = @as(i32, 32);
pub const VDS_HINT_WRITETHROUGHCACHINGENABLED = @as(i32, 64);
pub const VDS_HINT_HARDWARECHECKSUMENABLED = @as(i32, 128);
pub const VDS_HINT_ISYANKABLE = @as(i32, 256);
pub const VDS_HINT_ALLOCATEHOTSPARE = @as(i32, 512);
pub const VDS_HINT_BUSTYPE = @as(i32, 1024);
pub const VDS_HINT_USEMIRROREDCACHE = @as(i32, 2048);
pub const VDS_HINT_READCACHINGENABLED = @as(i32, 4096);
pub const VDS_HINT_WRITECACHINGENABLED = @as(i32, 8192);
pub const VDS_HINT_MEDIASCANENABLED = @as(i32, 16384);
pub const VDS_HINT_CONSISTENCYCHECKENABLED = @as(i32, 32768);
pub const VDS_REBUILD_PRIORITY_MIN = @as(u32, 0);
pub const VDS_REBUILD_PRIORITY_MAX = @as(u32, 16);
pub const VDS_POOL_ATTRIB_RAIDTYPE = @as(i32, 1);
pub const VDS_POOL_ATTRIB_BUSTYPE = @as(i32, 2);
pub const VDS_POOL_ATTRIB_ALLOW_SPINDOWN = @as(i32, 4);
pub const VDS_POOL_ATTRIB_THIN_PROVISION = @as(i32, 8);
pub const VDS_POOL_ATTRIB_NO_SINGLE_POF = @as(i32, 16);
pub const VDS_POOL_ATTRIB_DATA_RDNCY_MAX = @as(i32, 32);
pub const VDS_POOL_ATTRIB_DATA_RDNCY_MIN = @as(i32, 64);
pub const VDS_POOL_ATTRIB_DATA_RDNCY_DEF = @as(i32, 128);
pub const VDS_POOL_ATTRIB_PKG_RDNCY_MAX = @as(i32, 256);
pub const VDS_POOL_ATTRIB_PKG_RDNCY_MIN = @as(i32, 512);
pub const VDS_POOL_ATTRIB_PKG_RDNCY_DEF = @as(i32, 1024);
pub const VDS_POOL_ATTRIB_STRIPE_SIZE = @as(i32, 2048);
pub const VDS_POOL_ATTRIB_STRIPE_SIZE_MAX = @as(i32, 4096);
pub const VDS_POOL_ATTRIB_STRIPE_SIZE_MIN = @as(i32, 8192);
pub const VDS_POOL_ATTRIB_STRIPE_SIZE_DEF = @as(i32, 16384);
pub const VDS_POOL_ATTRIB_NUM_CLMNS = @as(i32, 32768);
pub const VDS_POOL_ATTRIB_NUM_CLMNS_MAX = @as(i32, 65536);
pub const VDS_POOL_ATTRIB_NUM_CLMNS_MIN = @as(i32, 131072);
pub const VDS_POOL_ATTRIB_NUM_CLMNS_DEF = @as(i32, 262144);
pub const VDS_POOL_ATTRIB_DATA_AVL_HINT = @as(i32, 524288);
pub const VDS_POOL_ATTRIB_ACCS_RNDM_HINT = @as(i32, 1048576);
pub const VDS_POOL_ATTRIB_ACCS_DIR_HINT = @as(i32, 2097152);
pub const VDS_POOL_ATTRIB_ACCS_SIZE_HINT = @as(i32, 4194304);
pub const VDS_POOL_ATTRIB_ACCS_LTNCY_HINT = @as(i32, 8388608);
pub const VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT = @as(i32, 16777216);
pub const VDS_POOL_ATTRIB_STOR_COST_HINT = @as(i32, 33554432);
pub const VDS_POOL_ATTRIB_STOR_EFFCY_HINT = @as(i32, 67108864);
pub const VDS_POOL_ATTRIB_CUSTOM_ATTRIB = @as(i32, 134217728);
pub const VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL = @as(u32, 1);
pub const CLSID_VdsLoader = Guid.initString("9c38ed61-d565-4728-aeee-c80952f0ecde");
pub const CLSID_VdsService = Guid.initString("7d1933cb-86f6-4a98-8628-01be94c9a575");
pub const MAX_FS_NAME_SIZE = @as(u32, 8);
pub const MAX_FS_FORMAT_SUPPORT_NAME_SIZE = @as(u32, 32);
pub const MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE = @as(u32, 32);
pub const VSS_ASSOC_NO_MAX_SPACE = @as(i32, -1);
pub const VSS_ASSOC_REMOVE = @as(u32, 0);
pub const FIND_RESOURCE_DIRECTORY_TYPES = @as(u32, 256);
pub const FIND_RESOURCE_DIRECTORY_NAMES = @as(u32, 512);
pub const FIND_RESOURCE_DIRECTORY_LANGUAGES = @as(u32, 1024);
pub const RESOURCE_ENUM_LN = @as(u32, 1);
pub const RESOURCE_ENUM_MUI = @as(u32, 2);
pub const RESOURCE_ENUM_MUI_SYSTEM = @as(u32, 4);
pub const RESOURCE_ENUM_VALIDATE = @as(u32, 8);
pub const RESOURCE_ENUM_MODULE_EXACT = @as(u32, 16);
pub const SUPPORT_LANG_NUMBER = @as(u32, 32);
pub const GET_MODULE_HANDLE_EX_FLAG_PIN = @as(u32, 1);
pub const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = @as(u32, 2);
pub const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = @as(u32, 4);
pub const CURRENT_IMPORT_REDIRECTION_VERSION = @as(u32, 1);
pub const LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY = @as(u32, 32768);
pub const SEC_E_OK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 0));
pub const RPC_X_NO_MORE_ENTRIES = @as(i32, 1772);
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL = @as(i32, 1773);
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE = @as(i32, 1774);
pub const RPC_X_SS_IN_NULL_CONTEXT = @as(i32, 1775);
pub const RPC_X_SS_CONTEXT_DAMAGED = @as(i32, 1777);
pub const RPC_X_SS_HANDLES_MISMATCH = @as(i32, 1778);
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE = @as(i32, 1779);
pub const RPC_X_NULL_REF_POINTER = @as(i32, 1780);
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE = @as(i32, 1781);
pub const RPC_X_BYTE_COUNT_TOO_SMALL = @as(i32, 1782);
pub const RPC_X_BAD_STUB_DATA = @as(i32, 1783);
pub const RPC_X_INVALID_ES_ACTION = @as(i32, 1827);
pub const RPC_X_WRONG_ES_VERSION = @as(i32, 1828);
pub const RPC_X_WRONG_STUB_VERSION = @as(i32, 1829);
pub const RPC_X_INVALID_PIPE_OBJECT = @as(i32, 1830);
pub const RPC_X_WRONG_PIPE_ORDER = @as(i32, 1831);
pub const RPC_X_WRONG_PIPE_VERSION = @as(i32, 1832);
pub const OR_INVALID_OXID = @as(i32, 1910);
pub const OR_INVALID_OID = @as(i32, 1911);
pub const OR_INVALID_SET = @as(i32, 1912);
pub const RPC_X_PIPE_CLOSED = @as(i32, 1916);
pub const RPC_X_PIPE_DISCIPLINE_ERROR = @as(i32, 1917);
pub const RPC_X_PIPE_EMPTY = @as(i32, 1918);
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED = @as(i32, 4050);
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO = @as(i32, 4051);
pub const PEERDIST_ERROR_MISSING_DATA = @as(i32, 4052);
pub const PEERDIST_ERROR_NO_MORE = @as(i32, 4053);
pub const PEERDIST_ERROR_NOT_INITIALIZED = @as(i32, 4054);
pub const PEERDIST_ERROR_ALREADY_INITIALIZED = @as(i32, 4055);
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS = @as(i32, 4056);
pub const PEERDIST_ERROR_INVALIDATED = @as(i32, 4057);
pub const PEERDIST_ERROR_ALREADY_EXISTS = @as(i32, 4058);
pub const PEERDIST_ERROR_OPERATION_NOTFOUND = @as(i32, 4059);
pub const PEERDIST_ERROR_ALREADY_COMPLETED = @as(i32, 4060);
pub const PEERDIST_ERROR_OUT_OF_BOUNDS = @as(i32, 4061);
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED = @as(i32, 4062);
pub const PEERDIST_ERROR_INVALID_CONFIGURATION = @as(i32, 4063);
pub const PEERDIST_ERROR_NOT_LICENSED = @as(i32, 4064);
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE = @as(i32, 4065);
pub const PEERDIST_ERROR_TRUST_FAILURE = @as(i32, 4066);
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM = @as(i32, 6200);
pub const FRS_ERR_INVALID_API_SEQUENCE = @as(i32, 8001);
pub const FRS_ERR_STARTING_SERVICE = @as(i32, 8002);
pub const FRS_ERR_STOPPING_SERVICE = @as(i32, 8003);
pub const FRS_ERR_INTERNAL_API = @as(i32, 8004);
pub const FRS_ERR_INTERNAL = @as(i32, 8005);
pub const FRS_ERR_SERVICE_COMM = @as(i32, 8006);
pub const FRS_ERR_INSUFFICIENT_PRIV = @as(i32, 8007);
pub const FRS_ERR_AUTHENTICATION = @as(i32, 8008);
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV = @as(i32, 8009);
pub const FRS_ERR_PARENT_AUTHENTICATION = @as(i32, 8010);
pub const FRS_ERR_CHILD_TO_PARENT_COMM = @as(i32, 8011);
pub const FRS_ERR_PARENT_TO_CHILD_COMM = @as(i32, 8012);
pub const FRS_ERR_SYSVOL_POPULATE = @as(i32, 8013);
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT = @as(i32, 8014);
pub const FRS_ERR_SYSVOL_IS_BUSY = @as(i32, 8015);
pub const FRS_ERR_SYSVOL_DEMOTE = @as(i32, 8016);
pub const FRS_ERR_INVALID_SERVICE_PARAMETER = @as(i32, 8017);
pub const DNS_INFO_NO_RECORDS = @as(i32, 9501);
pub const DNS_REQUEST_PENDING = @as(i32, 9506);
pub const DNS_STATUS_FQDN = @as(i32, 9557);
pub const DNS_STATUS_DOTTED_NAME = @as(i32, 9558);
pub const DNS_STATUS_SINGLE_PART_NAME = @as(i32, 9559);
pub const DNS_WARNING_PTR_CREATE_FAILED = @as(i32, 9715);
pub const DNS_WARNING_DOMAIN_UNDELETED = @as(i32, 9716);
pub const DNS_INFO_AXFR_COMPLETE = @as(i32, 9751);
pub const DNS_INFO_ADDED_LOCAL_WINS = @as(i32, 9753);
pub const DNS_STATUS_CONTINUE_NEEDED = @as(i32, 9801);
pub const WARNING_IPSEC_MM_POLICY_PRUNED = @as(i32, 13024);
pub const WARNING_IPSEC_QM_POLICY_PRUNED = @as(i32, 13025);
pub const APPMODEL_ERROR_NO_PACKAGE = @as(i32, 15700);
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT = @as(i32, 15701);
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT = @as(i32, 15702);
pub const APPMODEL_ERROR_NO_APPLICATION = @as(i32, 15703);
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED = @as(i32, 15704);
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID = @as(i32, 15705);
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE = @as(i32, 15706);
pub const APPMODEL_ERROR_NO_MUTABLE_DIRECTORY = @as(i32, 15707);
pub const STORE_ERROR_UNLICENSED = @as(i32, 15861);
pub const STORE_ERROR_UNLICENSED_USER = @as(i32, 15862);
pub const STORE_ERROR_PENDING_COM_TRANSACTION = @as(i32, 15863);
pub const STORE_ERROR_LICENSE_REVOKED = @as(i32, 15864);
pub const SEVERITY_SUCCESS = @as(u32, 0);
pub const SEVERITY_ERROR = @as(u32, 1);
pub const NOERROR = @as(u32, 0);
pub const E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418113));
pub const E_NOTIMPL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467263));
pub const E_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147024882));
pub const E_INVALIDARG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147024809));
pub const E_NOINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467262));
pub const E_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467261));
pub const E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147024890));
pub const E_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467260));
pub const E_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467259));
pub const E_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147024891));
pub const E_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483638));
pub const E_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483637));
pub const E_CHANGED_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483636));
pub const E_ILLEGAL_STATE_CHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483635));
pub const E_ILLEGAL_METHOD_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483634));
pub const RO_E_METADATA_NAME_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483633));
pub const RO_E_METADATA_NAME_IS_NAMESPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483632));
pub const RO_E_METADATA_INVALID_TYPE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483631));
pub const RO_E_INVALID_METADATA_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483630));
pub const RO_E_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483629));
pub const RO_E_EXCLUSIVE_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483628));
pub const RO_E_CHANGE_NOTIFICATION_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483627));
pub const RO_E_ERROR_STRING_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483626));
pub const E_STRING_NOT_NULL_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483625));
pub const E_ILLEGAL_DELEGATE_ASSIGNMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483624));
pub const E_ASYNC_OPERATION_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483623));
pub const E_APPLICATION_EXITING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483622));
pub const E_APPLICATION_VIEW_EXITING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483621));
pub const RO_E_MUST_BE_AGILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483620));
pub const RO_E_UNSUPPORTED_FROM_MTA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483619));
pub const RO_E_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483618));
pub const RO_E_BLOCKED_CROSS_ASTA_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483617));
pub const RO_E_CANNOT_ACTIVATE_FULL_TRUST_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483616));
pub const RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147483615));
pub const CO_E_INIT_TLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467258));
pub const CO_E_INIT_SHARED_ALLOCATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467257));
pub const CO_E_INIT_MEMORY_ALLOCATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467256));
pub const CO_E_INIT_CLASS_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467255));
pub const CO_E_INIT_RPC_CHANNEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467254));
pub const CO_E_INIT_TLS_SET_CHANNEL_CONTROL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467253));
pub const CO_E_INIT_TLS_CHANNEL_CONTROL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467252));
pub const CO_E_INIT_UNACCEPTED_USER_ALLOCATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467251));
pub const CO_E_INIT_SCM_MUTEX_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467250));
pub const CO_E_INIT_SCM_FILE_MAPPING_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467249));
pub const CO_E_INIT_SCM_MAP_VIEW_OF_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467248));
pub const CO_E_INIT_SCM_EXEC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467247));
pub const CO_E_INIT_ONLY_SINGLE_THREADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467246));
pub const CO_E_CANT_REMOTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467245));
pub const CO_E_BAD_SERVER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467244));
pub const CO_E_WRONG_SERVER_IDENTITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467243));
pub const CO_E_OLE1DDE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467242));
pub const CO_E_RUNAS_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467241));
pub const CO_E_CREATEPROCESS_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467240));
pub const CO_E_RUNAS_CREATEPROCESS_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467239));
pub const CO_E_RUNAS_LOGON_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467238));
pub const CO_E_LAUNCH_PERMSSION_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467237));
pub const CO_E_START_SERVICE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467236));
pub const CO_E_REMOTE_COMMUNICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467235));
pub const CO_E_SERVER_START_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467234));
pub const CO_E_CLSREG_INCONSISTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467233));
pub const CO_E_IIDREG_INCONSISTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467232));
pub const CO_E_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467231));
pub const CO_E_RELOAD_DLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467230));
pub const CO_E_MSI_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467229));
pub const CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467228));
pub const CO_E_SERVER_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467227));
pub const CO_E_SERVER_NOT_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467226));
pub const CO_E_CLASS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467225));
pub const CO_E_CLRNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467224));
pub const CO_E_ASYNC_WORK_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467223));
pub const CO_E_SERVER_INIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467222));
pub const CO_E_NO_SECCTX_IN_ACTIVATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467221));
pub const CO_E_TRACKER_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467216));
pub const CO_E_THREADPOOL_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467215));
pub const CO_E_SXS_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467214));
pub const CO_E_MALFORMED_SPN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467213));
pub const CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467212));
pub const CO_E_PREMATURE_STUB_RUNDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147467211));
pub const S_OK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 0));
pub const S_FALSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1));
pub const OLE_E_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221504));
pub const OLE_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221249));
pub const OLE_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262144));
pub const OLE_S_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262399));
pub const OLE_E_OLEVERB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221504));
pub const OLE_E_ADVF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221503));
pub const OLE_E_ENUM_NOMORE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221502));
pub const OLE_E_ADVISENOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221501));
pub const OLE_E_NOCONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221500));
pub const OLE_E_NOTRUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221499));
pub const OLE_E_NOCACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221498));
pub const OLE_E_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221497));
pub const OLE_E_CLASSDIFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221496));
pub const OLE_E_CANT_GETMONIKER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221495));
pub const OLE_E_CANT_BINDTOSOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221494));
pub const OLE_E_STATIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221493));
pub const OLE_E_PROMPTSAVECANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221492));
pub const OLE_E_INVALIDRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221491));
pub const OLE_E_WRONGCOMPOBJ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221490));
pub const OLE_E_INVALIDHWND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221489));
pub const OLE_E_NOT_INPLACEACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221488));
pub const OLE_E_CANTCONVERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221487));
pub const OLE_E_NOSTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221486));
pub const DV_E_FORMATETC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221404));
pub const DV_E_DVTARGETDEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221403));
pub const DV_E_STGMEDIUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221402));
pub const DV_E_STATDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221401));
pub const DV_E_LINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221400));
pub const DV_E_TYMED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221399));
pub const DV_E_CLIPFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221398));
pub const DV_E_DVASPECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221397));
pub const DV_E_DVTARGETDEVICE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221396));
pub const DV_E_NOIVIEWOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221395));
pub const DRAGDROP_E_FIRST = @as(i32, -2147221248);
pub const DRAGDROP_E_LAST = @as(i32, -2147221233);
pub const DRAGDROP_S_FIRST = @as(i32, 262400);
pub const DRAGDROP_S_LAST = @as(i32, 262415);
pub const DRAGDROP_E_NOTREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221248));
pub const DRAGDROP_E_ALREADYREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221247));
pub const DRAGDROP_E_INVALIDHWND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221246));
pub const DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221245));
pub const CLASSFACTORY_E_FIRST = @as(i32, -2147221232);
pub const CLASSFACTORY_E_LAST = @as(i32, -2147221217);
pub const CLASSFACTORY_S_FIRST = @as(i32, 262416);
pub const CLASSFACTORY_S_LAST = @as(i32, 262431);
pub const CLASS_E_NOAGGREGATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221232));
pub const CLASS_E_CLASSNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221231));
pub const CLASS_E_NOTLICENSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221230));
pub const MARSHAL_E_FIRST = @as(i32, -2147221216);
pub const MARSHAL_E_LAST = @as(i32, -2147221201);
pub const MARSHAL_S_FIRST = @as(i32, 262432);
pub const MARSHAL_S_LAST = @as(i32, 262447);
pub const DATA_E_FIRST = @as(i32, -2147221200);
pub const DATA_E_LAST = @as(i32, -2147221185);
pub const DATA_S_FIRST = @as(i32, 262448);
pub const DATA_S_LAST = @as(i32, 262463);
pub const VIEW_E_FIRST = @as(i32, -2147221184);
pub const VIEW_E_LAST = @as(i32, -2147221169);
pub const VIEW_S_FIRST = @as(i32, 262464);
pub const VIEW_S_LAST = @as(i32, 262479);
pub const VIEW_E_DRAW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221184));
pub const REGDB_E_FIRST = @as(i32, -2147221168);
pub const REGDB_E_LAST = @as(i32, -2147221153);
pub const REGDB_S_FIRST = @as(i32, 262480);
pub const REGDB_S_LAST = @as(i32, 262495);
pub const REGDB_E_READREGDB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221168));
pub const REGDB_E_WRITEREGDB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221167));
pub const REGDB_E_KEYMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221166));
pub const REGDB_E_INVALIDVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221165));
pub const REGDB_E_CLASSNOTREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221164));
pub const REGDB_E_IIDNOTREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221163));
pub const REGDB_E_BADTHREADINGMODEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221162));
pub const REGDB_E_PACKAGEPOLICYVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221161));
pub const CAT_E_FIRST = @as(i32, -2147221152);
pub const CAT_E_LAST = @as(i32, -2147221151);
pub const CAT_E_CATIDNOEXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221152));
pub const CAT_E_NODESCRIPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221151));
pub const CS_E_FIRST = @as(i32, -2147221148);
pub const CS_E_LAST = @as(i32, -2147221137);
pub const CS_E_PACKAGE_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221148));
pub const CS_E_NOT_DELETABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221147));
pub const CS_E_CLASS_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221146));
pub const CS_E_INVALID_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221145));
pub const CS_E_NO_CLASSSTORE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221144));
pub const CS_E_OBJECT_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221143));
pub const CS_E_OBJECT_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221142));
pub const CS_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221141));
pub const CS_E_NETWORK_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221140));
pub const CS_E_ADMIN_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221139));
pub const CS_E_SCHEMA_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221138));
pub const CS_E_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221137));
pub const CACHE_E_FIRST = @as(i32, -2147221136);
pub const CACHE_E_LAST = @as(i32, -2147221121);
pub const CACHE_S_FIRST = @as(i32, 262512);
pub const CACHE_S_LAST = @as(i32, 262527);
pub const CACHE_E_NOCACHE_UPDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221136));
pub const OLEOBJ_E_FIRST = @as(i32, -2147221120);
pub const OLEOBJ_E_LAST = @as(i32, -2147221105);
pub const OLEOBJ_S_FIRST = @as(i32, 262528);
pub const OLEOBJ_S_LAST = @as(i32, 262543);
pub const OLEOBJ_E_NOVERBS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221120));
pub const OLEOBJ_E_INVALIDVERB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221119));
pub const CLIENTSITE_E_FIRST = @as(i32, -2147221104);
pub const CLIENTSITE_E_LAST = @as(i32, -2147221089);
pub const CLIENTSITE_S_FIRST = @as(i32, 262544);
pub const CLIENTSITE_S_LAST = @as(i32, 262559);
pub const INPLACE_E_NOTUNDOABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221088));
pub const INPLACE_E_NOTOOLSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221087));
pub const INPLACE_E_FIRST = @as(i32, -2147221088);
pub const INPLACE_E_LAST = @as(i32, -2147221073);
pub const INPLACE_S_FIRST = @as(i32, 262560);
pub const INPLACE_S_LAST = @as(i32, 262575);
pub const ENUM_E_FIRST = @as(i32, -2147221072);
pub const ENUM_E_LAST = @as(i32, -2147221057);
pub const ENUM_S_FIRST = @as(i32, 262576);
pub const ENUM_S_LAST = @as(i32, 262591);
pub const CONVERT10_E_FIRST = @as(i32, -2147221056);
pub const CONVERT10_E_LAST = @as(i32, -2147221041);
pub const CONVERT10_S_FIRST = @as(i32, 262592);
pub const CONVERT10_S_LAST = @as(i32, 262607);
pub const CONVERT10_E_OLESTREAM_GET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221056));
pub const CONVERT10_E_OLESTREAM_PUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221055));
pub const CONVERT10_E_OLESTREAM_FMT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221054));
pub const CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221053));
pub const CONVERT10_E_STG_FMT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221052));
pub const CONVERT10_E_STG_NO_STD_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221051));
pub const CONVERT10_E_STG_DIB_TO_BITMAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221050));
pub const CLIPBRD_E_FIRST = @as(i32, -2147221040);
pub const CLIPBRD_E_LAST = @as(i32, -2147221025);
pub const CLIPBRD_S_FIRST = @as(i32, 262608);
pub const CLIPBRD_S_LAST = @as(i32, 262623);
pub const CLIPBRD_E_CANT_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221040));
pub const CLIPBRD_E_CANT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221039));
pub const CLIPBRD_E_CANT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221038));
pub const CLIPBRD_E_BAD_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221037));
pub const CLIPBRD_E_CANT_CLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221036));
pub const MK_E_FIRST = @as(i32, -2147221024);
pub const MK_E_LAST = @as(i32, -2147221009);
pub const MK_S_FIRST = @as(i32, 262624);
pub const MK_S_LAST = @as(i32, 262639);
pub const MK_E_CONNECTMANUALLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221024));
pub const MK_E_EXCEEDEDDEADLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221023));
pub const MK_E_NEEDGENERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221022));
pub const MK_E_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221021));
pub const MK_E_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221020));
pub const MK_E_NOOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221019));
pub const MK_E_INVALIDEXTENSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221018));
pub const MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221017));
pub const MK_E_NOTBINDABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221016));
pub const MK_E_NOTBOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221015));
pub const MK_E_CANTOPENFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221014));
pub const MK_E_MUSTBOTHERUSER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221013));
pub const MK_E_NOINVERSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221012));
pub const MK_E_NOSTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221011));
pub const MK_E_NOPREFIX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221010));
pub const MK_E_ENUMERATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221009));
pub const CO_E_FIRST = @as(i32, -2147221008);
pub const CO_E_LAST = @as(i32, -2147220993);
pub const CO_S_FIRST = @as(i32, 262640);
pub const CO_S_LAST = @as(i32, 262655);
pub const CO_E_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221008));
pub const CO_E_ALREADYINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221007));
pub const CO_E_CANTDETERMINECLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221006));
pub const CO_E_CLASSSTRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221005));
pub const CO_E_IIDSTRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221004));
pub const CO_E_APPNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221003));
pub const CO_E_APPSINGLEUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221002));
pub const CO_E_ERRORINAPP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221001));
pub const CO_E_DLLNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221000));
pub const CO_E_ERRORINDLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220999));
pub const CO_E_WRONGOSFORAPP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220998));
pub const CO_E_OBJNOTREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220997));
pub const CO_E_OBJISREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220996));
pub const CO_E_OBJNOTCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220995));
pub const CO_E_APPDIDNTREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220994));
pub const CO_E_RELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220993));
pub const EVENT_E_FIRST = @as(i32, -2147220992);
pub const EVENT_E_LAST = @as(i32, -2147220961);
pub const EVENT_S_FIRST = @as(i32, 262656);
pub const EVENT_S_LAST = @as(i32, 262687);
pub const EVENT_S_SOME_SUBSCRIBERS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const EVENT_E_ALL_SUBSCRIBERS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const EVENT_S_NOSUBSCRIBERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const EVENT_E_QUERYSYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const EVENT_E_QUERYFIELD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const EVENT_E_INTERNALEXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const EVENT_E_INTERNALERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const EVENT_E_INVALID_PER_USER_SID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const EVENT_E_USER_EXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const EVENT_E_TOO_MANY_METHODS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const EVENT_E_MISSING_EVENTCLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const EVENT_E_NOT_ALL_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const EVENT_E_COMPLUS_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const EVENT_E_INVALID_EVENT_CLASS_PARTITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const EVENT_E_PER_USER_SID_NOT_LOGGED_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const TPC_E_INVALID_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220927));
pub const TPC_E_NO_DEFAULT_TABLET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const TPC_E_UNKNOWN_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const TPC_E_INVALID_INPUT_RECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const TPC_E_INVALID_STROKE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const TPC_E_INITIALIZE_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const TPC_E_NOT_RELEVANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220942));
pub const TPC_E_INVALID_PACKET_DESCRIPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220941));
pub const TPC_E_RECOGNIZER_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220939));
pub const TPC_E_INVALID_RIGHTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220938));
pub const TPC_E_OUT_OF_ORDER_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220937));
pub const TPC_E_QUEUE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220936));
pub const TPC_E_INVALID_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220935));
pub const TPC_E_INVALID_DATA_FROM_RECOGNIZER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220934));
pub const TPC_S_TRUNCATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262738));
pub const TPC_S_INTERRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262739));
pub const TPC_S_NO_DATA_TO_PROCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262740));
pub const XACT_E_FIRST = @as(u32, 2147799040);
pub const XACT_E_LAST = @as(u32, 2147799083);
pub const XACT_S_FIRST = @as(u32, 315392);
pub const XACT_S_LAST = @as(u32, 315408);
pub const XACT_E_ALREADYOTHERSINGLEPHASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168256));
pub const XACT_E_CANTRETAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168255));
pub const XACT_E_COMMITFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168254));
pub const XACT_E_COMMITPREVENTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168253));
pub const XACT_E_HEURISTICABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168252));
pub const XACT_E_HEURISTICCOMMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168251));
pub const XACT_E_HEURISTICDAMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168250));
pub const XACT_E_HEURISTICDANGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168249));
pub const XACT_E_ISOLATIONLEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168248));
pub const XACT_E_NOASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168247));
pub const XACT_E_NOENLIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168246));
pub const XACT_E_NOISORETAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168245));
pub const XACT_E_NORESOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168244));
pub const XACT_E_NOTCURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168243));
pub const XACT_E_NOTRANSACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168242));
pub const XACT_E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168241));
pub const XACT_E_UNKNOWNRMGRID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168240));
pub const XACT_E_WRONGSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168239));
pub const XACT_E_WRONGUOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168238));
pub const XACT_E_XTIONEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168237));
pub const XACT_E_NOIMPORTOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168236));
pub const XACT_E_INVALIDCOOKIE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168235));
pub const XACT_E_INDOUBT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168234));
pub const XACT_E_NOTIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168233));
pub const XACT_E_ALREADYINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168232));
pub const XACT_E_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168231));
pub const XACT_E_LOGFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168230));
pub const XACT_E_TMNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168229));
pub const XACT_E_CONNECTION_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168228));
pub const XACT_E_CONNECTION_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168227));
pub const XACT_E_REENLISTTIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168226));
pub const XACT_E_TIP_CONNECT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168225));
pub const XACT_E_TIP_PROTOCOL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168224));
pub const XACT_E_TIP_PULL_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168223));
pub const XACT_E_DEST_TMNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168222));
pub const XACT_E_TIP_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168221));
pub const XACT_E_NETWORK_TX_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168220));
pub const XACT_E_PARTNER_NETWORK_TX_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168219));
pub const XACT_E_XA_TX_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168218));
pub const XACT_E_UNABLE_TO_READ_DTC_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168217));
pub const XACT_E_UNABLE_TO_LOAD_DTC_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168216));
pub const XACT_E_ABORTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168215));
pub const XACT_E_PUSH_COMM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168214));
pub const XACT_E_PULL_COMM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168213));
pub const XACT_E_LU_TX_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168212));
pub const XACT_E_CLERKNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168128));
pub const XACT_E_CLERKEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168127));
pub const XACT_E_RECOVERYINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168126));
pub const XACT_E_TRANSACTIONCLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168125));
pub const XACT_E_INVALIDLSN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168124));
pub const XACT_E_REPLAYREQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147168123));
pub const XACT_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315392));
pub const XACT_S_DEFECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315393));
pub const XACT_S_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315394));
pub const XACT_S_SOMENORETAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315395));
pub const XACT_S_OKINFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315396));
pub const XACT_S_MADECHANGESCONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315397));
pub const XACT_S_MADECHANGESINFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315398));
pub const XACT_S_ALLNORETAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315399));
pub const XACT_S_ABORTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315400));
pub const XACT_S_SINGLEPHASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315401));
pub const XACT_S_LOCALLY_OK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315402));
pub const XACT_S_LASTRESOURCEMANAGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 315408));
pub const CONTEXT_E_FIRST = @as(i32, -2147164160);
pub const CONTEXT_E_LAST = @as(i32, -2147164113);
pub const CONTEXT_S_FIRST = @as(i32, 319488);
pub const CONTEXT_S_LAST = @as(i32, 319535);
pub const CONTEXT_E_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164158));
pub const CONTEXT_E_ABORTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164157));
pub const CONTEXT_E_NOCONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164156));
pub const CONTEXT_E_WOULD_DEADLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164155));
pub const CONTEXT_E_SYNCH_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164154));
pub const CONTEXT_E_OLDREF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164153));
pub const CONTEXT_E_ROLENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164148));
pub const CONTEXT_E_TMNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164145));
pub const CO_E_ACTIVATIONFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164127));
pub const CO_E_ACTIVATIONFAILED_EVENTLOGGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164126));
pub const CO_E_ACTIVATIONFAILED_CATALOGERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164125));
pub const CO_E_ACTIVATIONFAILED_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164124));
pub const CO_E_INITIALIZATIONFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164123));
pub const CONTEXT_E_NOJIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164122));
pub const CONTEXT_E_NOTRANSACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164121));
pub const CO_E_THREADINGMODEL_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164120));
pub const CO_E_NOIISINTRINSICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164119));
pub const CO_E_NOCOOKIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164118));
pub const CO_E_DBERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164117));
pub const CO_E_NOTPOOLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164116));
pub const CO_E_NOTCONSTRUCTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164115));
pub const CO_E_NOSYNCHRONIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164114));
pub const CO_E_ISOLEVELMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164113));
pub const CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164112));
pub const CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147164111));
pub const OLE_S_USEREG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262144));
pub const OLE_S_STATIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262145));
pub const OLE_S_MAC_CLIPFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262146));
pub const DRAGDROP_S_DROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262400));
pub const DRAGDROP_S_CANCEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262401));
pub const DRAGDROP_S_USEDEFAULTCURSORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262402));
pub const DATA_S_SAMEFORMATETC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262448));
pub const VIEW_S_ALREADY_FROZEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262464));
pub const CACHE_S_FORMATETC_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262512));
pub const CACHE_S_SAMECACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262513));
pub const CACHE_S_SOMECACHES_NOTUPDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262514));
pub const OLEOBJ_S_INVALIDVERB = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262528));
pub const OLEOBJ_S_CANNOT_DOVERB_NOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262529));
pub const OLEOBJ_S_INVALIDHWND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262530));
pub const INPLACE_S_TRUNCATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262560));
pub const CONVERT10_S_NO_PRESENTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262592));
pub const MK_S_REDUCED_TO_SELF = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262626));
pub const MK_S_ME = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262628));
pub const MK_S_HIM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262629));
pub const MK_S_US = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262630));
pub const MK_S_MONIKERALREADYREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262631));
pub const SCHED_S_TASK_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267008));
pub const SCHED_S_TASK_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267009));
pub const SCHED_S_TASK_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267010));
pub const SCHED_S_TASK_HAS_NOT_RUN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267011));
pub const SCHED_S_TASK_NO_MORE_RUNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267012));
pub const SCHED_S_TASK_NOT_SCHEDULED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267013));
pub const SCHED_S_TASK_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267014));
pub const SCHED_S_TASK_NO_VALID_TRIGGERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267015));
pub const SCHED_S_EVENT_TRIGGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267016));
pub const SCHED_E_TRIGGER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216631));
pub const SCHED_E_TASK_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216630));
pub const SCHED_E_TASK_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216629));
pub const SCHED_E_SERVICE_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216628));
pub const SCHED_E_CANNOT_OPEN_TASK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216627));
pub const SCHED_E_INVALID_TASK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216626));
pub const SCHED_E_ACCOUNT_INFORMATION_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216625));
pub const SCHED_E_ACCOUNT_NAME_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216624));
pub const SCHED_E_ACCOUNT_DBASE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216623));
pub const SCHED_E_NO_SECURITY_SERVICES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216622));
pub const SCHED_E_UNKNOWN_OBJECT_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216621));
pub const SCHED_E_UNSUPPORTED_ACCOUNT_OPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216620));
pub const SCHED_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216619));
pub const SCHED_E_UNEXPECTEDNODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216618));
pub const SCHED_E_NAMESPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216617));
pub const SCHED_E_INVALIDVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216616));
pub const SCHED_E_MISSINGNODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216615));
pub const SCHED_E_MALFORMEDXML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216614));
pub const SCHED_S_SOME_TRIGGERS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267035));
pub const SCHED_S_BATCH_LOGON_PROBLEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267036));
pub const SCHED_E_TOO_MANY_NODES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216611));
pub const SCHED_E_PAST_END_BOUNDARY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216610));
pub const SCHED_E_ALREADY_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216609));
pub const SCHED_E_USER_NOT_LOGGED_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216608));
pub const SCHED_E_INVALID_TASK_HASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216607));
pub const SCHED_E_SERVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216606));
pub const SCHED_E_SERVICE_TOO_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216605));
pub const SCHED_E_TASK_ATTEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216604));
pub const SCHED_S_TASK_QUEUED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 267045));
pub const SCHED_E_TASK_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216602));
pub const SCHED_E_TASK_NOT_V1_COMPAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216601));
pub const SCHED_E_START_ON_DEMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216600));
pub const SCHED_E_TASK_NOT_UBPM_COMPAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216599));
pub const SCHED_E_DEPRECATED_FEATURE_USED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147216592));
pub const CO_E_CLASS_CREATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959359));
pub const CO_E_SCM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959358));
pub const CO_E_SCM_RPC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959357));
pub const CO_E_BAD_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959356));
pub const CO_E_SERVER_EXEC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959355));
pub const CO_E_OBJSRV_RPC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959354));
pub const MK_E_NO_NORMALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959353));
pub const CO_E_SERVER_STOPPING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959352));
pub const MEM_E_INVALID_ROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959351));
pub const MEM_E_INVALID_LINK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959344));
pub const MEM_E_INVALID_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959343));
pub const CO_S_NOTALLINTERFACES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 524306));
pub const CO_S_MACHINENAMENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 524307));
pub const CO_E_MISSING_DISPLAYNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959339));
pub const CO_E_RUNAS_VALUE_MUST_BE_AAA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959338));
pub const CO_E_ELEVATION_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146959337));
pub const APPX_E_PACKAGING_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958848));
pub const APPX_E_INTERLEAVING_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958847));
pub const APPX_E_RELATIONSHIPS_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958846));
pub const APPX_E_MISSING_REQUIRED_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958845));
pub const APPX_E_INVALID_MANIFEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958844));
pub const APPX_E_INVALID_BLOCKMAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958843));
pub const APPX_E_CORRUPT_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958842));
pub const APPX_E_BLOCK_HASH_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958841));
pub const APPX_E_REQUESTED_RANGE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958840));
pub const APPX_E_INVALID_SIP_CLIENT_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958839));
pub const APPX_E_INVALID_KEY_INFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958838));
pub const APPX_E_INVALID_CONTENTGROUPMAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958837));
pub const APPX_E_INVALID_APPINSTALLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958836));
pub const APPX_E_DELTA_BASELINE_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958835));
pub const APPX_E_DELTA_PACKAGE_MISSING_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958834));
pub const APPX_E_INVALID_DELTA_PACKAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958833));
pub const APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958832));
pub const APPX_E_INVALID_PACKAGING_LAYOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958831));
pub const APPX_E_INVALID_PACKAGESIGNCONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958830));
pub const APPX_E_RESOURCESPRI_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958829));
pub const APPX_E_FILE_COMPRESSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958828));
pub const APPX_E_INVALID_PAYLOAD_PACKAGE_EXTENSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958827));
pub const APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958826));
pub const BT_E_SPURIOUS_ACTIVATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146958592));
pub const DISP_E_UNKNOWNINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352575));
pub const DISP_E_MEMBERNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352573));
pub const DISP_E_PARAMNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352572));
pub const DISP_E_TYPEMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352571));
pub const DISP_E_UNKNOWNNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352570));
pub const DISP_E_NONAMEDARGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352569));
pub const DISP_E_BADVARTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352568));
pub const DISP_E_EXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352567));
pub const DISP_E_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352566));
pub const DISP_E_BADINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352565));
pub const DISP_E_UNKNOWNLCID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352564));
pub const DISP_E_ARRAYISLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352563));
pub const DISP_E_BADPARAMCOUNT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352562));
pub const DISP_E_PARAMNOTOPTIONAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352561));
pub const DISP_E_BADCALLEE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352560));
pub const DISP_E_NOTACOLLECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352559));
pub const DISP_E_DIVBYZERO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352558));
pub const DISP_E_BUFFERTOOSMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352557));
pub const TYPE_E_BUFFERTOOSMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319786));
pub const TYPE_E_FIELDNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319785));
pub const TYPE_E_INVDATAREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319784));
pub const TYPE_E_UNSUPFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319783));
pub const TYPE_E_REGISTRYACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319780));
pub const TYPE_E_LIBNOTREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319779));
pub const TYPE_E_UNDEFINEDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319769));
pub const TYPE_E_QUALIFIEDNAMEDISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319768));
pub const TYPE_E_INVALIDSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319767));
pub const TYPE_E_WRONGTYPEKIND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319766));
pub const TYPE_E_ELEMENTNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319765));
pub const TYPE_E_AMBIGUOUSNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319764));
pub const TYPE_E_NAMECONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319763));
pub const TYPE_E_UNKNOWNLCID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319762));
pub const TYPE_E_DLLFUNCTIONNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147319761));
pub const TYPE_E_BADMODULEKIND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147317571));
pub const TYPE_E_SIZETOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147317563));
pub const TYPE_E_DUPLICATEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147317562));
pub const TYPE_E_INVALIDID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147317553));
pub const TYPE_E_TYPEMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147316576));
pub const TYPE_E_OUTOFBOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147316575));
pub const TYPE_E_IOERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147316574));
pub const TYPE_E_CANTCREATETMPFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147316573));
pub const TYPE_E_CANTLOADLIBRARY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147312566));
pub const TYPE_E_INCONSISTENTPROPFUNCS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147312509));
pub const TYPE_E_CIRCULARTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147312508));
pub const STG_E_INVALIDFUNCTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287039));
pub const STG_E_FILENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287038));
pub const STG_E_PATHNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287037));
pub const STG_E_TOOMANYOPENFILES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287036));
pub const STG_E_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287035));
pub const STG_E_INVALIDHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287034));
pub const STG_E_INSUFFICIENTMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287032));
pub const STG_E_INVALIDPOINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287031));
pub const STG_E_NOMOREFILES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287022));
pub const STG_E_DISKISWRITEPROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287021));
pub const STG_E_SEEKERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287015));
pub const STG_E_WRITEFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287011));
pub const STG_E_READFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287010));
pub const STG_E_SHAREVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287008));
pub const STG_E_LOCKVIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147287007));
pub const STG_E_FILEALREADYEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286960));
pub const STG_E_INVALIDPARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286953));
pub const STG_E_MEDIUMFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286928));
pub const STG_E_PROPSETMISMATCHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286800));
pub const STG_E_ABNORMALAPIEXIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286790));
pub const STG_E_INVALIDHEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286789));
pub const STG_E_INVALIDNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286788));
pub const STG_E_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286787));
pub const STG_E_UNIMPLEMENTEDFUNCTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286786));
pub const STG_E_INVALIDFLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286785));
pub const STG_E_INUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286784));
pub const STG_E_NOTCURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286783));
pub const STG_E_REVERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286782));
pub const STG_E_CANTSAVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286781));
pub const STG_E_OLDFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286780));
pub const STG_E_OLDDLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286779));
pub const STG_E_SHAREREQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286778));
pub const STG_E_NOTFILEBASEDSTORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286777));
pub const STG_E_EXTANTMARSHALLINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286776));
pub const STG_E_DOCFILECORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286775));
pub const STG_E_BADBASEADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286768));
pub const STG_E_DOCFILETOOLARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286767));
pub const STG_E_NOTSIMPLEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286766));
pub const STG_E_INCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286527));
pub const STG_E_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286526));
pub const STG_S_CONVERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197120));
pub const STG_S_BLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197121));
pub const STG_S_RETRYNOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197122));
pub const STG_S_MONITORING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197123));
pub const STG_S_MULTIPLEOPENS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197124));
pub const STG_S_CONSOLIDATIONFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197125));
pub const STG_S_CANNOTCONSOLIDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197126));
pub const STG_S_POWER_CYCLE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 197127));
pub const STG_E_FIRMWARE_SLOT_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286520));
pub const STG_E_FIRMWARE_IMAGE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286519));
pub const STG_E_DEVICE_UNRESPONSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286518));
pub const STG_E_STATUS_COPY_PROTECTION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286267));
pub const STG_E_CSS_AUTHENTICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286266));
pub const STG_E_CSS_KEY_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286265));
pub const STG_E_CSS_KEY_NOT_ESTABLISHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286264));
pub const STG_E_CSS_SCRAMBLED_SECTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286263));
pub const STG_E_CSS_REGION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286262));
pub const STG_E_RESETS_EXHAUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147286261));
pub const RPC_E_CALL_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418111));
pub const RPC_E_CALL_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418110));
pub const RPC_E_CANTPOST_INSENDCALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418109));
pub const RPC_E_CANTCALLOUT_INASYNCCALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418108));
pub const RPC_E_CANTCALLOUT_INEXTERNALCALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418107));
pub const RPC_E_CONNECTION_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418106));
pub const RPC_E_SERVER_DIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418105));
pub const RPC_E_CLIENT_DIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418104));
pub const RPC_E_INVALID_DATAPACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418103));
pub const RPC_E_CANTTRANSMIT_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418102));
pub const RPC_E_CLIENT_CANTMARSHAL_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418101));
pub const RPC_E_CLIENT_CANTUNMARSHAL_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418100));
pub const RPC_E_SERVER_CANTMARSHAL_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418099));
pub const RPC_E_SERVER_CANTUNMARSHAL_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418098));
pub const RPC_E_INVALID_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418097));
pub const RPC_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418096));
pub const RPC_E_CANTCALLOUT_AGAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418095));
pub const RPC_E_SERVER_DIED_DNE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147418094));
pub const RPC_E_SYS_CALL_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417856));
pub const RPC_E_OUT_OF_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417855));
pub const RPC_E_ATTEMPTED_MULTITHREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417854));
pub const RPC_E_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417853));
pub const RPC_E_FAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417852));
pub const RPC_E_SERVERFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417851));
pub const RPC_E_CHANGED_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417850));
pub const RPC_E_INVALIDMETHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417849));
pub const RPC_E_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417848));
pub const RPC_E_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417847));
pub const RPC_E_SERVERCALL_RETRYLATER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417846));
pub const RPC_E_SERVERCALL_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417845));
pub const RPC_E_INVALID_CALLDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417844));
pub const RPC_E_CANTCALLOUT_ININPUTSYNCCALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417843));
pub const RPC_E_WRONG_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417842));
pub const RPC_E_THREAD_NOT_INIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417841));
pub const RPC_E_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417840));
pub const RPC_E_INVALID_HEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417839));
pub const RPC_E_INVALID_EXTENSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417838));
pub const RPC_E_INVALID_IPID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417837));
pub const RPC_E_INVALID_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417836));
pub const RPC_S_CALLPENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417835));
pub const RPC_S_WAITONTIMER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417834));
pub const RPC_E_CALL_COMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417833));
pub const RPC_E_UNSECURE_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417832));
pub const RPC_E_TOO_LATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417831));
pub const RPC_E_NO_GOOD_SECURITY_PACKAGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417830));
pub const RPC_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417829));
pub const RPC_E_REMOTE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417828));
pub const RPC_E_INVALID_OBJREF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417827));
pub const RPC_E_NO_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417826));
pub const RPC_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417825));
pub const RPC_E_NO_SYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417824));
pub const RPC_E_FULLSIC_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417823));
pub const RPC_E_INVALID_STD_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417822));
pub const CO_E_FAILEDTOIMPERSONATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417821));
pub const CO_E_FAILEDTOGETSECCTX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417820));
pub const CO_E_FAILEDTOOPENTHREADTOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417819));
pub const CO_E_FAILEDTOGETTOKENINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417818));
pub const CO_E_TRUSTEEDOESNTMATCHCLIENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417817));
pub const CO_E_FAILEDTOQUERYCLIENTBLANKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417816));
pub const CO_E_FAILEDTOSETDACL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417815));
pub const CO_E_ACCESSCHECKFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417814));
pub const CO_E_NETACCESSAPIFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417813));
pub const CO_E_WRONGTRUSTEENAMESYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417812));
pub const CO_E_INVALIDSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417811));
pub const CO_E_CONVERSIONFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417810));
pub const CO_E_NOMATCHINGSIDFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417809));
pub const CO_E_LOOKUPACCSIDFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417808));
pub const CO_E_NOMATCHINGNAMEFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417807));
pub const CO_E_LOOKUPACCNAMEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417806));
pub const CO_E_SETSERLHNDLFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417805));
pub const CO_E_FAILEDTOGETWINDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417804));
pub const CO_E_PATHTOOLONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417803));
pub const CO_E_FAILEDTOGENUUID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417802));
pub const CO_E_FAILEDTOCREATEFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417801));
pub const CO_E_FAILEDTOCLOSEHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417800));
pub const CO_E_EXCEEDSYSACLLIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417799));
pub const CO_E_ACESINWRONGORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417798));
pub const CO_E_INCOMPATIBLESTREAMVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417797));
pub const CO_E_FAILEDTOOPENPROCESSTOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417796));
pub const CO_E_DECODEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417795));
pub const CO_E_ACNOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417793));
pub const CO_E_CANCEL_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147417792));
pub const RPC_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147352577));
pub const ERROR_AUDITING_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073151999));
pub const ERROR_ALL_SIDS_FILTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073151998));
pub const ERROR_BIZRULES_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073151997));
pub const NTE_BAD_UID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893823));
pub const NTE_BAD_HASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893822));
pub const NTE_BAD_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893821));
pub const NTE_BAD_LEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893820));
pub const NTE_BAD_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893819));
pub const NTE_BAD_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893818));
pub const NTE_BAD_VER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893817));
pub const NTE_BAD_ALGID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893816));
pub const NTE_BAD_FLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893815));
pub const NTE_BAD_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893814));
pub const NTE_BAD_KEY_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893813));
pub const NTE_BAD_HASH_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893812));
pub const NTE_NO_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893811));
pub const NTE_NO_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893810));
pub const NTE_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893809));
pub const NTE_PERM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893808));
pub const NTE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893807));
pub const NTE_DOUBLE_ENCRYPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893806));
pub const NTE_BAD_PROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893805));
pub const NTE_BAD_PROV_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893804));
pub const NTE_BAD_PUBLIC_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893803));
pub const NTE_BAD_KEYSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893802));
pub const NTE_PROV_TYPE_NOT_DEF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893801));
pub const NTE_PROV_TYPE_ENTRY_BAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893800));
pub const NTE_KEYSET_NOT_DEF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893799));
pub const NTE_KEYSET_ENTRY_BAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893798));
pub const NTE_PROV_TYPE_NO_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893797));
pub const NTE_SIGNATURE_FILE_BAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893796));
pub const NTE_PROVIDER_DLL_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893795));
pub const NTE_PROV_DLL_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893794));
pub const NTE_BAD_KEYSET_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893793));
pub const NTE_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893792));
pub const NTE_SYS_ERR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893791));
pub const NTE_SILENT_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893790));
pub const NTE_TOKEN_KEYSET_STORAGE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893789));
pub const NTE_TEMPORARY_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893788));
pub const NTE_FIXEDPARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893787));
pub const NTE_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893786));
pub const NTE_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893785));
pub const NTE_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893784));
pub const NTE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893783));
pub const NTE_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893782));
pub const NTE_BUFFERS_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893781));
pub const NTE_DECRYPTION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893780));
pub const NTE_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893779));
pub const NTE_UI_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893778));
pub const NTE_HMAC_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893777));
pub const NTE_DEVICE_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893776));
pub const NTE_AUTHENTICATION_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893775));
pub const NTE_VALIDATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893774));
pub const NTE_INCORRECT_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893773));
pub const NTE_ENCRYPTION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893772));
pub const NTE_DEVICE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893771));
pub const NTE_USER_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893770));
pub const NTE_PASSWORD_CHANGE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893769));
pub const NTE_NOT_ACTIVE_CONSOLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893768));
pub const SEC_E_INSUFFICIENT_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893056));
pub const SEC_E_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893055));
pub const SEC_E_UNSUPPORTED_FUNCTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893054));
pub const SEC_E_TARGET_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893053));
pub const SEC_E_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893052));
pub const SEC_E_SECPKG_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893051));
pub const SEC_E_NOT_OWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893050));
pub const SEC_E_CANNOT_INSTALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893049));
pub const SEC_E_INVALID_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893048));
pub const SEC_E_CANNOT_PACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893047));
pub const SEC_E_QOP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893046));
pub const SEC_E_NO_IMPERSONATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893045));
pub const SEC_E_LOGON_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893044));
pub const SEC_E_UNKNOWN_CREDENTIALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893043));
pub const SEC_E_NO_CREDENTIALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893042));
pub const SEC_E_MESSAGE_ALTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893041));
pub const SEC_E_OUT_OF_SEQUENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893040));
pub const SEC_E_NO_AUTHENTICATING_AUTHORITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893039));
pub const SEC_I_CONTINUE_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590610));
pub const SEC_I_COMPLETE_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590611));
pub const SEC_I_COMPLETE_AND_CONTINUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590612));
pub const SEC_I_LOCAL_LOGON = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590613));
pub const SEC_I_GENERIC_EXTENSION_RECEIVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590614));
pub const SEC_E_BAD_PKGID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893034));
pub const SEC_E_CONTEXT_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893033));
pub const SEC_I_CONTEXT_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590615));
pub const SEC_E_INCOMPLETE_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893032));
pub const SEC_E_INCOMPLETE_CREDENTIALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893024));
pub const SEC_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893023));
pub const SEC_I_INCOMPLETE_CREDENTIALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590624));
pub const SEC_I_RENEGOTIATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590625));
pub const SEC_E_WRONG_PRINCIPAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893022));
pub const SEC_I_NO_LSA_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590627));
pub const SEC_E_TIME_SKEW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893020));
pub const SEC_E_UNTRUSTED_ROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893019));
pub const SEC_E_ILLEGAL_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893018));
pub const SEC_E_CERT_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893017));
pub const SEC_E_CERT_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893016));
pub const SEC_E_ENCRYPT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893015));
pub const SEC_E_DECRYPT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893008));
pub const SEC_E_ALGORITHM_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893007));
pub const SEC_E_SECURITY_QOS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893006));
pub const SEC_E_UNFINISHED_CONTEXT_DELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893005));
pub const SEC_E_NO_TGT_REPLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893004));
pub const SEC_E_NO_IP_ADDRESSES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893003));
pub const SEC_E_WRONG_CREDENTIAL_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893002));
pub const SEC_E_CRYPTO_SYSTEM_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893001));
pub const SEC_E_MAX_REFERRALS_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146893000));
pub const SEC_E_MUST_BE_KDC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892999));
pub const SEC_E_STRONG_CRYPTO_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892998));
pub const SEC_E_TOO_MANY_PRINCIPALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892997));
pub const SEC_E_NO_PA_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892996));
pub const SEC_E_PKINIT_NAME_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892995));
pub const SEC_E_SMARTCARD_LOGON_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892994));
pub const SEC_E_SHUTDOWN_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892993));
pub const SEC_E_KDC_INVALID_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892992));
pub const SEC_E_KDC_UNABLE_TO_REFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892991));
pub const SEC_E_KDC_UNKNOWN_ETYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892990));
pub const SEC_E_UNSUPPORTED_PREAUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892989));
pub const SEC_E_DELEGATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892987));
pub const SEC_E_BAD_BINDINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892986));
pub const SEC_E_MULTIPLE_ACCOUNTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892985));
pub const SEC_E_NO_KERB_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892984));
pub const SEC_E_CERT_WRONG_USAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892983));
pub const SEC_E_DOWNGRADE_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892976));
pub const SEC_E_SMARTCARD_CERT_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892975));
pub const SEC_E_ISSUING_CA_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892974));
pub const SEC_E_REVOCATION_OFFLINE_C = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892973));
pub const SEC_E_PKINIT_CLIENT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892972));
pub const SEC_E_SMARTCARD_CERT_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892971));
pub const SEC_E_NO_S4U_PROT_SUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892970));
pub const SEC_E_CROSSREALM_DELEGATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892969));
pub const SEC_E_REVOCATION_OFFLINE_KDC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892968));
pub const SEC_E_ISSUING_CA_UNTRUSTED_KDC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892967));
pub const SEC_E_KDC_CERT_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892966));
pub const SEC_E_KDC_CERT_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892965));
pub const SEC_I_SIGNATURE_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590684));
pub const SEC_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892963));
pub const SEC_E_DELEGATION_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892962));
pub const SEC_E_POLICY_NLTM_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892961));
pub const SEC_I_NO_RENEGOTIATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590688));
pub const SEC_E_NO_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892959));
pub const SEC_E_PKU2U_CERT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892958));
pub const SEC_E_MUTUAL_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892957));
pub const SEC_I_MESSAGE_FRAGMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590692));
pub const SEC_E_ONLY_HTTPS_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892955));
pub const SEC_I_CONTINUE_NEEDED_MESSAGE_OK = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590694));
pub const SEC_E_APPLICATION_PROTOCOL_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892953));
pub const SEC_I_ASYNC_CALL_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 590696));
pub const SEC_E_INVALID_UPN_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892951));
pub const SEC_E_EXT_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892950));
pub const SEC_E_INSUFFICIENT_BUFFERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146892949));
pub const CRYPT_E_MSG_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889727));
pub const CRYPT_E_UNKNOWN_ALGO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889726));
pub const CRYPT_E_OID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889725));
pub const CRYPT_E_INVALID_MSG_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889724));
pub const CRYPT_E_UNEXPECTED_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889723));
pub const CRYPT_E_AUTH_ATTR_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889722));
pub const CRYPT_E_HASH_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889721));
pub const CRYPT_E_INVALID_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889720));
pub const CRYPT_E_ALREADY_DECRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889719));
pub const CRYPT_E_NOT_DECRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889718));
pub const CRYPT_E_RECIPIENT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889717));
pub const CRYPT_E_CONTROL_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889716));
pub const CRYPT_E_ISSUER_SERIALNUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889715));
pub const CRYPT_E_SIGNER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889714));
pub const CRYPT_E_ATTRIBUTES_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889713));
pub const CRYPT_E_STREAM_MSG_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889712));
pub const CRYPT_E_STREAM_INSUFFICIENT_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146889711));
pub const CRYPT_I_NEW_PROTECTION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 593938));
pub const CRYPT_E_BAD_LEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885631));
pub const CRYPT_E_BAD_ENCODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885630));
pub const CRYPT_E_FILE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885629));
pub const CRYPT_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885628));
pub const CRYPT_E_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885627));
pub const CRYPT_E_NO_PROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885626));
pub const CRYPT_E_SELF_SIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885625));
pub const CRYPT_E_DELETED_PREV = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885624));
pub const CRYPT_E_NO_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885623));
pub const CRYPT_E_UNEXPECTED_MSG_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885622));
pub const CRYPT_E_NO_KEY_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885621));
pub const CRYPT_E_NO_DECRYPT_CERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885620));
pub const CRYPT_E_BAD_MSG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885619));
pub const CRYPT_E_NO_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885618));
pub const CRYPT_E_PENDING_CLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885617));
pub const CRYPT_E_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885616));
pub const CRYPT_E_NO_REVOCATION_DLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885615));
pub const CRYPT_E_NO_REVOCATION_CHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885614));
pub const CRYPT_E_REVOCATION_OFFLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885613));
pub const CRYPT_E_NOT_IN_REVOCATION_DATABASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885612));
pub const CRYPT_E_INVALID_NUMERIC_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885600));
pub const CRYPT_E_INVALID_PRINTABLE_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885599));
pub const CRYPT_E_INVALID_IA5_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885598));
pub const CRYPT_E_INVALID_X500_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885597));
pub const CRYPT_E_NOT_CHAR_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885596));
pub const CRYPT_E_FILERESIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885595));
pub const CRYPT_E_SECURITY_SETTINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885594));
pub const CRYPT_E_NO_VERIFY_USAGE_DLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885593));
pub const CRYPT_E_NO_VERIFY_USAGE_CHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885592));
pub const CRYPT_E_VERIFY_USAGE_OFFLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885591));
pub const CRYPT_E_NOT_IN_CTL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885590));
pub const CRYPT_E_NO_TRUSTED_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885589));
pub const CRYPT_E_MISSING_PUBKEY_PARA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885588));
pub const CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885587));
pub const CRYPT_E_OSS_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881536));
pub const OSS_MORE_BUF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881535));
pub const OSS_NEGATIVE_UINTEGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881534));
pub const OSS_PDU_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881533));
pub const OSS_MORE_INPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881532));
pub const OSS_DATA_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881531));
pub const OSS_BAD_ARG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881530));
pub const OSS_BAD_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881529));
pub const OSS_OUT_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881528));
pub const OSS_PDU_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881527));
pub const OSS_LIMITED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881526));
pub const OSS_BAD_PTR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881525));
pub const OSS_BAD_TIME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881524));
pub const OSS_INDEFINITE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881523));
pub const OSS_MEM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881522));
pub const OSS_BAD_TABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881521));
pub const OSS_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881520));
pub const OSS_CONSTRAINT_VIOLATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881519));
pub const OSS_FATAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881518));
pub const OSS_ACCESS_SERIALIZATION_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881517));
pub const OSS_NULL_TBL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881516));
pub const OSS_NULL_FCN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881515));
pub const OSS_BAD_ENCRULES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881514));
pub const OSS_UNAVAIL_ENCRULES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881513));
pub const OSS_CANT_OPEN_TRACE_WINDOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881512));
pub const OSS_UNIMPLEMENTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881511));
pub const OSS_OID_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881510));
pub const OSS_CANT_OPEN_TRACE_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881509));
pub const OSS_TRACE_FILE_ALREADY_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881508));
pub const OSS_TABLE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881507));
pub const OSS_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881506));
pub const OSS_REAL_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881505));
pub const OSS_REAL_CODE_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881504));
pub const OSS_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881503));
pub const OSS_COPIER_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881502));
pub const OSS_CONSTRAINT_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881501));
pub const OSS_COMPARATOR_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881500));
pub const OSS_COMPARATOR_CODE_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881499));
pub const OSS_MEM_MGR_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881498));
pub const OSS_PDV_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881497));
pub const OSS_PDV_CODE_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881496));
pub const OSS_API_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881495));
pub const OSS_BERDER_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881494));
pub const OSS_PER_DLL_NOT_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881493));
pub const OSS_OPEN_TYPE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881492));
pub const OSS_MUTEX_NOT_CREATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881491));
pub const OSS_CANT_CLOSE_TRACE_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881490));
pub const CRYPT_E_ASN1_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881280));
pub const CRYPT_E_ASN1_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881279));
pub const CRYPT_E_ASN1_EOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881278));
pub const CRYPT_E_ASN1_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881277));
pub const CRYPT_E_ASN1_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881276));
pub const CRYPT_E_ASN1_CONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881275));
pub const CRYPT_E_ASN1_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881274));
pub const CRYPT_E_ASN1_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881273));
pub const CRYPT_E_ASN1_BADPDU = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881272));
pub const CRYPT_E_ASN1_BADARGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881271));
pub const CRYPT_E_ASN1_BADREAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881270));
pub const CRYPT_E_ASN1_BADTAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881269));
pub const CRYPT_E_ASN1_CHOICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881268));
pub const CRYPT_E_ASN1_RULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881267));
pub const CRYPT_E_ASN1_UTF8 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881266));
pub const CRYPT_E_ASN1_PDU_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881229));
pub const CRYPT_E_ASN1_NYI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881228));
pub const CRYPT_E_ASN1_EXTENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881023));
pub const CRYPT_E_ASN1_NOEOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146881022));
pub const CERTSRV_E_BAD_REQUESTSUBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877439));
pub const CERTSRV_E_NO_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877438));
pub const CERTSRV_E_BAD_REQUESTSTATUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877437));
pub const CERTSRV_E_PROPERTY_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877436));
pub const CERTSRV_E_INVALID_CA_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877435));
pub const CERTSRV_E_SERVER_SUSPENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877434));
pub const CERTSRV_E_ENCODING_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877433));
pub const CERTSRV_E_ROLECONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877432));
pub const CERTSRV_E_RESTRICTEDOFFICER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877431));
pub const CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877430));
pub const CERTSRV_E_NO_VALID_KRA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877429));
pub const CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877428));
pub const CERTSRV_E_NO_CAADMIN_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877427));
pub const CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877426));
pub const CERTSRV_E_NO_DB_SESSIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877425));
pub const CERTSRV_E_ALIGNMENT_FAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877424));
pub const CERTSRV_E_ENROLL_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877423));
pub const CERTSRV_E_TEMPLATE_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877422));
pub const CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877421));
pub const CERTSRV_E_ADMIN_DENIED_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877420));
pub const CERTSRV_E_NO_POLICY_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877419));
pub const CERTSRV_E_WEAK_SIGNATURE_OR_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877418));
pub const CERTSRV_E_KEY_ATTESTATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877417));
pub const CERTSRV_E_ENCRYPTION_CERT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146877416));
pub const CERTSRV_E_UNSUPPORTED_CERT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875392));
pub const CERTSRV_E_NO_CERT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875391));
pub const CERTSRV_E_TEMPLATE_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875390));
pub const CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875389));
pub const CERTSRV_E_ARCHIVED_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875388));
pub const CERTSRV_E_SMIME_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875387));
pub const CERTSRV_E_BAD_RENEWAL_SUBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875386));
pub const CERTSRV_E_BAD_TEMPLATE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875385));
pub const CERTSRV_E_TEMPLATE_POLICY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875384));
pub const CERTSRV_E_SIGNATURE_POLICY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875383));
pub const CERTSRV_E_SIGNATURE_COUNT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875382));
pub const CERTSRV_E_SIGNATURE_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875381));
pub const CERTSRV_E_ISSUANCE_POLICY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875380));
pub const CERTSRV_E_SUBJECT_UPN_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875379));
pub const CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875378));
pub const CERTSRV_E_SUBJECT_DNS_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875377));
pub const CERTSRV_E_ARCHIVED_KEY_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875376));
pub const CERTSRV_E_KEY_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875375));
pub const CERTSRV_E_SUBJECT_EMAIL_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875374));
pub const CERTSRV_E_UNKNOWN_CERT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875373));
pub const CERTSRV_E_CERT_TYPE_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875372));
pub const CERTSRV_E_TOO_MANY_SIGNATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875371));
pub const CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875370));
pub const CERTSRV_E_INVALID_EK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875369));
pub const CERTSRV_E_INVALID_IDBINDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875368));
pub const CERTSRV_E_INVALID_ATTESTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875367));
pub const CERTSRV_E_KEY_ATTESTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875366));
pub const CERTSRV_E_CORRUPT_KEY_ATTESTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875365));
pub const CERTSRV_E_EXPIRED_CHALLENGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875364));
pub const CERTSRV_E_INVALID_RESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875363));
pub const CERTSRV_E_INVALID_REQUESTID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875362));
pub const CERTSRV_E_REQUEST_PRECERTIFICATE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875361));
pub const CERTSRV_E_PENDING_CLIENT_RESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146875360));
pub const XENROLL_E_KEY_NOT_EXPORTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873344));
pub const XENROLL_E_CANNOT_ADD_ROOT_CERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873343));
pub const XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873342));
pub const XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873341));
pub const XENROLL_E_RESPONSE_KA_HASH_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873340));
pub const XENROLL_E_KEYSPEC_SMIME_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146873339));
pub const TRUST_E_SYSTEM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869247));
pub const TRUST_E_NO_SIGNER_CERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869246));
pub const TRUST_E_COUNTER_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869245));
pub const TRUST_E_CERT_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869244));
pub const TRUST_E_TIME_STAMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869243));
pub const TRUST_E_BAD_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869232));
pub const TRUST_E_MALFORMED_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869231));
pub const TRUST_E_BASIC_CONSTRAINTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869223));
pub const TRUST_E_FINANCIAL_CRITERIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146869218));
pub const MSSIPOTF_E_OUTOFMEMRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865151));
pub const MSSIPOTF_E_CANTGETOBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865150));
pub const MSSIPOTF_E_NOHEADTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865149));
pub const MSSIPOTF_E_BAD_MAGICNUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865148));
pub const MSSIPOTF_E_BAD_OFFSET_TABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865147));
pub const MSSIPOTF_E_TABLE_TAGORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865146));
pub const MSSIPOTF_E_TABLE_LONGWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865145));
pub const MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865144));
pub const MSSIPOTF_E_TABLES_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865143));
pub const MSSIPOTF_E_TABLE_PADBYTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865142));
pub const MSSIPOTF_E_FILETOOSMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865141));
pub const MSSIPOTF_E_TABLE_CHECKSUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865140));
pub const MSSIPOTF_E_FILE_CHECKSUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865139));
pub const MSSIPOTF_E_FAILED_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865136));
pub const MSSIPOTF_E_FAILED_HINTS_CHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865135));
pub const MSSIPOTF_E_NOT_OPENTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865134));
pub const MSSIPOTF_E_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865133));
pub const MSSIPOTF_E_CRYPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865132));
pub const MSSIPOTF_E_BADVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865131));
pub const MSSIPOTF_E_DSIG_STRUCTURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865130));
pub const MSSIPOTF_E_PCONST_CHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865129));
pub const MSSIPOTF_E_STRUCTURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865128));
pub const ERROR_CRED_REQUIRES_CONFIRMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146865127));
pub const NTE_OP_OK = @as(u32, 0);
pub const TRUST_E_PROVIDER_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762751));
pub const TRUST_E_ACTION_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762750));
pub const TRUST_E_SUBJECT_FORM_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762749));
pub const TRUST_E_SUBJECT_NOT_TRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762748));
pub const DIGSIG_E_ENCODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762747));
pub const DIGSIG_E_DECODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762746));
pub const DIGSIG_E_EXTENSIBILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762745));
pub const DIGSIG_E_CRYPTO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762744));
pub const PERSIST_E_SIZEDEFINITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762743));
pub const PERSIST_E_SIZEINDEFINITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762742));
pub const PERSIST_E_NOTSELFSIZING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762741));
pub const TRUST_E_NOSIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762496));
pub const CERT_E_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762495));
pub const CERT_E_VALIDITYPERIODNESTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762494));
pub const CERT_E_ROLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762493));
pub const CERT_E_PATHLENCONST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762492));
pub const CERT_E_CRITICAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762491));
pub const CERT_E_PURPOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762490));
pub const CERT_E_ISSUERCHAINING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762489));
pub const CERT_E_MALFORMED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762488));
pub const CERT_E_UNTRUSTEDROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762487));
pub const CERT_E_CHAINING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762486));
pub const TRUST_E_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762485));
pub const CERT_E_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762484));
pub const CERT_E_UNTRUSTEDTESTROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762483));
pub const CERT_E_REVOCATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762482));
pub const CERT_E_CN_NO_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762481));
pub const CERT_E_WRONG_USAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762480));
pub const TRUST_E_EXPLICIT_DISTRUST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762479));
pub const CERT_E_UNTRUSTEDCA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762478));
pub const CERT_E_INVALID_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762477));
pub const CERT_E_INVALID_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146762476));
pub const SPAPI_E_EXPECTED_SECTION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500608));
pub const SPAPI_E_BAD_SECTION_NAME_LINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500607));
pub const SPAPI_E_SECTION_NAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500606));
pub const SPAPI_E_GENERAL_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500605));
pub const SPAPI_E_WRONG_INF_STYLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500352));
pub const SPAPI_E_SECTION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500351));
pub const SPAPI_E_LINE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500350));
pub const SPAPI_E_NO_BACKUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500349));
pub const SPAPI_E_NO_ASSOCIATED_CLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500096));
pub const SPAPI_E_CLASS_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500095));
pub const SPAPI_E_DUPLICATE_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500094));
pub const SPAPI_E_NO_DRIVER_SELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500093));
pub const SPAPI_E_KEY_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500092));
pub const SPAPI_E_INVALID_DEVINST_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500091));
pub const SPAPI_E_INVALID_CLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500090));
pub const SPAPI_E_DEVINST_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500089));
pub const SPAPI_E_DEVINFO_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500088));
pub const SPAPI_E_INVALID_REG_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500087));
pub const SPAPI_E_NO_INF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500086));
pub const SPAPI_E_NO_SUCH_DEVINST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500085));
pub const SPAPI_E_CANT_LOAD_CLASS_ICON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500084));
pub const SPAPI_E_INVALID_CLASS_INSTALLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500083));
pub const SPAPI_E_DI_DO_DEFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500082));
pub const SPAPI_E_DI_NOFILECOPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500081));
pub const SPAPI_E_INVALID_HWPROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500080));
pub const SPAPI_E_NO_DEVICE_SELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500079));
pub const SPAPI_E_DEVINFO_LIST_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500078));
pub const SPAPI_E_DEVINFO_DATA_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500077));
pub const SPAPI_E_DI_BAD_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500076));
pub const SPAPI_E_NO_CLASSINSTALL_PARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500075));
pub const SPAPI_E_FILEQUEUE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500074));
pub const SPAPI_E_BAD_SERVICE_INSTALLSECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500073));
pub const SPAPI_E_NO_CLASS_DRIVER_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500072));
pub const SPAPI_E_NO_ASSOCIATED_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500071));
pub const SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500070));
pub const SPAPI_E_DEVICE_INTERFACE_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500069));
pub const SPAPI_E_DEVICE_INTERFACE_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500068));
pub const SPAPI_E_BAD_INTERFACE_INSTALLSECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500067));
pub const SPAPI_E_NO_SUCH_INTERFACE_CLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500066));
pub const SPAPI_E_INVALID_REFERENCE_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500065));
pub const SPAPI_E_INVALID_MACHINENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500064));
pub const SPAPI_E_REMOTE_COMM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500063));
pub const SPAPI_E_MACHINE_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500062));
pub const SPAPI_E_NO_CONFIGMGR_SERVICES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500061));
pub const SPAPI_E_INVALID_PROPPAGE_PROVIDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500060));
pub const SPAPI_E_NO_SUCH_DEVICE_INTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500059));
pub const SPAPI_E_DI_POSTPROCESSING_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500058));
pub const SPAPI_E_INVALID_COINSTALLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500057));
pub const SPAPI_E_NO_COMPAT_DRIVERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500056));
pub const SPAPI_E_NO_DEVICE_ICON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500055));
pub const SPAPI_E_INVALID_INF_LOGCONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500054));
pub const SPAPI_E_DI_DONT_INSTALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500053));
pub const SPAPI_E_INVALID_FILTER_DRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500052));
pub const SPAPI_E_NON_WINDOWS_NT_DRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500051));
pub const SPAPI_E_NON_WINDOWS_DRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500050));
pub const SPAPI_E_NO_CATALOG_FOR_OEM_INF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500049));
pub const SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500048));
pub const SPAPI_E_NOT_DISABLEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500047));
pub const SPAPI_E_CANT_REMOVE_DEVINST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500046));
pub const SPAPI_E_INVALID_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500045));
pub const SPAPI_E_DRIVER_NONNATIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500044));
pub const SPAPI_E_IN_WOW64 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500043));
pub const SPAPI_E_SET_SYSTEM_RESTORE_POINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500042));
pub const SPAPI_E_INCORRECTLY_COPIED_INF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500041));
pub const SPAPI_E_SCE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500040));
pub const SPAPI_E_UNKNOWN_EXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500039));
pub const SPAPI_E_PNP_REGISTRY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500038));
pub const SPAPI_E_REMOTE_REQUEST_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500037));
pub const SPAPI_E_NOT_AN_INSTALLED_OEM_INF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500036));
pub const SPAPI_E_INF_IN_USE_BY_DEVICES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500035));
pub const SPAPI_E_DI_FUNCTION_OBSOLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500034));
pub const SPAPI_E_NO_AUTHENTICODE_CATALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500033));
pub const SPAPI_E_AUTHENTICODE_DISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500032));
pub const SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500031));
pub const SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500030));
pub const SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500029));
pub const SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500028));
pub const SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500027));
pub const SPAPI_E_DEVICE_INSTALLER_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500026));
pub const SPAPI_E_DRIVER_STORE_ADD_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500025));
pub const SPAPI_E_DEVICE_INSTALL_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500024));
pub const SPAPI_E_DRIVER_INSTALL_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500023));
pub const SPAPI_E_WRONG_INF_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500022));
pub const SPAPI_E_FILE_HASH_NOT_IN_CATALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500021));
pub const SPAPI_E_DRIVER_STORE_DELETE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146500020));
pub const SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146499840));
pub const SPAPI_E_ERROR_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146496512));
pub const SCARD_F_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435071));
pub const SCARD_E_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435070));
pub const SCARD_E_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435069));
pub const SCARD_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435068));
pub const SCARD_E_INVALID_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435067));
pub const SCARD_E_NO_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435066));
pub const SCARD_F_WAITED_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435065));
pub const SCARD_E_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435064));
pub const SCARD_E_UNKNOWN_READER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435063));
pub const SCARD_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435062));
pub const SCARD_E_SHARING_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435061));
pub const SCARD_E_NO_SMARTCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435060));
pub const SCARD_E_UNKNOWN_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435059));
pub const SCARD_E_CANT_DISPOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435058));
pub const SCARD_E_PROTO_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435057));
pub const SCARD_E_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435056));
pub const SCARD_E_INVALID_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435055));
pub const SCARD_E_SYSTEM_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435054));
pub const SCARD_F_COMM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435053));
pub const SCARD_F_UNKNOWN_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435052));
pub const SCARD_E_INVALID_ATR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435051));
pub const SCARD_E_NOT_TRANSACTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435050));
pub const SCARD_E_READER_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435049));
pub const SCARD_P_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435048));
pub const SCARD_E_PCI_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435047));
pub const SCARD_E_READER_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435046));
pub const SCARD_E_DUPLICATE_READER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435045));
pub const SCARD_E_CARD_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435044));
pub const SCARD_E_NO_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435043));
pub const SCARD_E_SERVICE_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435042));
pub const SCARD_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435041));
pub const SCARD_E_ICC_INSTALLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435040));
pub const SCARD_E_ICC_CREATEORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435039));
pub const SCARD_E_UNSUPPORTED_FEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435038));
pub const SCARD_E_DIR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435037));
pub const SCARD_E_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435036));
pub const SCARD_E_NO_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435035));
pub const SCARD_E_NO_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435034));
pub const SCARD_E_NO_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435033));
pub const SCARD_E_WRITE_TOO_MANY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435032));
pub const SCARD_E_BAD_SEEK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435031));
pub const SCARD_E_INVALID_CHV = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435030));
pub const SCARD_E_UNKNOWN_RES_MNG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435029));
pub const SCARD_E_NO_SUCH_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435028));
pub const SCARD_E_CERTIFICATE_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435027));
pub const SCARD_E_NO_READERS_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435026));
pub const SCARD_E_COMM_DATA_LOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435025));
pub const SCARD_E_NO_KEY_CONTAINER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435024));
pub const SCARD_E_SERVER_TOO_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435023));
pub const SCARD_E_PIN_CACHE_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435022));
pub const SCARD_E_NO_PIN_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435021));
pub const SCARD_E_READ_ONLY_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146435020));
pub const SCARD_W_UNSUPPORTED_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434971));
pub const SCARD_W_UNRESPONSIVE_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434970));
pub const SCARD_W_UNPOWERED_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434969));
pub const SCARD_W_RESET_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434968));
pub const SCARD_W_REMOVED_CARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434967));
pub const SCARD_W_SECURITY_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434966));
pub const SCARD_W_WRONG_CHV = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434965));
pub const SCARD_W_CHV_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434964));
pub const SCARD_W_EOF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434963));
pub const SCARD_W_CANCELLED_BY_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434962));
pub const SCARD_W_CARD_NOT_AUTHENTICATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434961));
pub const SCARD_W_CACHE_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434960));
pub const SCARD_W_CACHE_ITEM_STALE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434959));
pub const SCARD_W_CACHE_ITEM_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146434958));
pub const COMADMIN_E_OBJECTERRORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368511));
pub const COMADMIN_E_OBJECTINVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368510));
pub const COMADMIN_E_KEYMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368509));
pub const COMADMIN_E_ALREADYINSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368508));
pub const COMADMIN_E_APP_FILE_WRITEFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368505));
pub const COMADMIN_E_APP_FILE_READFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368504));
pub const COMADMIN_E_APP_FILE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368503));
pub const COMADMIN_E_BADPATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368502));
pub const COMADMIN_E_APPLICATIONEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368501));
pub const COMADMIN_E_ROLEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368500));
pub const COMADMIN_E_CANTCOPYFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368499));
pub const COMADMIN_E_NOUSER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368497));
pub const COMADMIN_E_INVALIDUSERIDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368496));
pub const COMADMIN_E_NOREGISTRYCLSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368495));
pub const COMADMIN_E_BADREGISTRYPROGID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368494));
pub const COMADMIN_E_AUTHENTICATIONLEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368493));
pub const COMADMIN_E_USERPASSWDNOTVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368492));
pub const COMADMIN_E_CLSIDORIIDMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368488));
pub const COMADMIN_E_REMOTEINTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368487));
pub const COMADMIN_E_DLLREGISTERSERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368486));
pub const COMADMIN_E_NOSERVERSHARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368485));
pub const COMADMIN_E_DLLLOADFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368483));
pub const COMADMIN_E_BADREGISTRYLIBID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368482));
pub const COMADMIN_E_APPDIRNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368481));
pub const COMADMIN_E_REGISTRARFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368477));
pub const COMADMIN_E_COMPFILE_DOESNOTEXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368476));
pub const COMADMIN_E_COMPFILE_LOADDLLFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368475));
pub const COMADMIN_E_COMPFILE_GETCLASSOBJ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368474));
pub const COMADMIN_E_COMPFILE_CLASSNOTAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368473));
pub const COMADMIN_E_COMPFILE_BADTLB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368472));
pub const COMADMIN_E_COMPFILE_NOTINSTALLABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368471));
pub const COMADMIN_E_NOTCHANGEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368470));
pub const COMADMIN_E_NOTDELETEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368469));
pub const COMADMIN_E_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368468));
pub const COMADMIN_E_COMP_MOVE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368467));
pub const COMADMIN_E_COMP_MOVE_BAD_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368466));
pub const COMADMIN_E_REGISTERTLB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368464));
pub const COMADMIN_E_SYSTEMAPP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368461));
pub const COMADMIN_E_COMPFILE_NOREGISTRAR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368460));
pub const COMADMIN_E_COREQCOMPINSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368459));
pub const COMADMIN_E_SERVICENOTINSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368458));
pub const COMADMIN_E_PROPERTYSAVEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368457));
pub const COMADMIN_E_OBJECTEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368456));
pub const COMADMIN_E_COMPONENTEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368455));
pub const COMADMIN_E_REGFILE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368453));
pub const COMADMIN_E_PROPERTY_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368452));
pub const COMADMIN_E_NOTINREGISTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368450));
pub const COMADMIN_E_OBJECTNOTPOOLABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368449));
pub const COMADMIN_E_APPLID_MATCHES_CLSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368442));
pub const COMADMIN_E_ROLE_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368441));
pub const COMADMIN_E_START_APP_NEEDS_COMPONENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368440));
pub const COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368439));
pub const COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368438));
pub const COMADMIN_E_CAN_NOT_START_APP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368437));
pub const COMADMIN_E_CAN_NOT_EXPORT_SYS_APP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368436));
pub const COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368435));
pub const COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368434));
pub const COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368433));
pub const COMADMIN_E_BASE_PARTITION_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368432));
pub const COMADMIN_E_START_APP_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368431));
pub const COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368425));
pub const COMADMIN_E_CAT_INVALID_PARTITION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368424));
pub const COMADMIN_E_CAT_PARTITION_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368423));
pub const COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368422));
pub const COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368421));
pub const COMADMIN_E_AMBIGUOUS_APPLICATION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368420));
pub const COMADMIN_E_AMBIGUOUS_PARTITION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368419));
pub const COMADMIN_E_REGDB_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368398));
pub const COMADMIN_E_REGDB_NOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368397));
pub const COMADMIN_E_REGDB_SYSTEMERR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368396));
pub const COMADMIN_E_REGDB_ALREADYRUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368395));
pub const COMADMIN_E_MIG_VERSIONNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368384));
pub const COMADMIN_E_MIG_SCHEMANOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368383));
pub const COMADMIN_E_CAT_BITNESSMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368382));
pub const COMADMIN_E_CAT_UNACCEPTABLEBITNESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368381));
pub const COMADMIN_E_CAT_WRONGAPPBITNESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368380));
pub const COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368379));
pub const COMADMIN_E_CAT_SERVERFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368378));
pub const COMQC_E_APPLICATION_NOT_QUEUED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146368000));
pub const COMQC_E_NO_QUEUEABLE_INTERFACES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367999));
pub const COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367998));
pub const COMQC_E_NO_IPERSISTSTREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367997));
pub const COMQC_E_BAD_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367996));
pub const COMQC_E_UNAUTHENTICATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367995));
pub const COMQC_E_UNTRUSTED_ENQUEUER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367994));
pub const MSDTC_E_DUPLICATE_RESOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367743));
pub const COMADMIN_E_OBJECT_PARENT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367480));
pub const COMADMIN_E_OBJECT_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367479));
pub const COMADMIN_E_APP_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367478));
pub const COMADMIN_E_INVALID_PARTITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367477));
pub const COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367475));
pub const COMADMIN_E_USER_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367474));
pub const COMADMIN_E_CANTRECYCLELIBRARYAPPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367473));
pub const COMADMIN_E_CANTRECYCLESERVICEAPPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367471));
pub const COMADMIN_E_PROCESSALREADYRECYCLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367470));
pub const COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367469));
pub const COMADMIN_E_CANTMAKEINPROCSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367468));
pub const COMADMIN_E_PROGIDINUSEBYCLSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367467));
pub const COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367466));
pub const COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367465));
pub const COMADMIN_E_PARTITION_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367464));
pub const COMADMIN_E_PARTITION_MSI_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367463));
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367462));
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367461));
pub const COMADMIN_E_COMP_MOVE_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367460));
pub const COMADMIN_E_COMP_MOVE_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367459));
pub const COMADMIN_E_COMP_MOVE_PRIVATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367458));
pub const COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367457));
pub const COMADMIN_E_CANNOT_ALIAS_EVENTCLASS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367456));
pub const COMADMIN_E_PRIVATE_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367455));
pub const COMADMIN_E_SAFERINVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367454));
pub const COMADMIN_E_REGISTRY_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367453));
pub const COMADMIN_E_PARTITIONS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146367452));
pub const WER_S_REPORT_DEBUG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769472));
pub const WER_S_REPORT_UPLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769473));
pub const WER_S_REPORT_QUEUED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769474));
pub const WER_S_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769475));
pub const WER_S_SUSPENDED_UPLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769476));
pub const WER_S_DISABLED_QUEUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769477));
pub const WER_S_DISABLED_ARCHIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769478));
pub const WER_S_REPORT_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769479));
pub const WER_S_IGNORE_ASSERT_INSTANCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769480));
pub const WER_S_IGNORE_ALL_ASSERTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769481));
pub const WER_S_ASSERT_CONTINUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769482));
pub const WER_S_THROTTLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769483));
pub const WER_S_REPORT_UPLOADED_CAB = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1769484));
pub const WER_E_CRASH_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681408));
pub const WER_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681407));
pub const WER_E_NETWORK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681406));
pub const WER_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681405));
pub const WER_E_ALREADY_REPORTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681404));
pub const WER_E_DUMP_THROTTLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681403));
pub const WER_E_INSUFFICIENT_CONSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681402));
pub const WER_E_TOO_HEAVY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145681401));
pub const ERROR_FLT_IO_COMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2031617));
pub const ERROR_FLT_NO_HANDLER_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452031));
pub const ERROR_FLT_CONTEXT_ALREADY_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452030));
pub const ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452029));
pub const ERROR_FLT_DISALLOW_FAST_IO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452028));
pub const ERROR_FLT_INVALID_NAME_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452027));
pub const ERROR_FLT_NOT_SAFE_TO_POST_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452026));
pub const ERROR_FLT_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452025));
pub const ERROR_FLT_FILTER_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452024));
pub const ERROR_FLT_POST_OPERATION_CLEANUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452023));
pub const ERROR_FLT_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452022));
pub const ERROR_FLT_DELETING_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452021));
pub const ERROR_FLT_MUST_BE_NONPAGED_POOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452020));
pub const ERROR_FLT_DUPLICATE_ENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452019));
pub const ERROR_FLT_CBDQ_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452018));
pub const ERROR_FLT_DO_NOT_ATTACH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452017));
pub const ERROR_FLT_DO_NOT_DETACH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452016));
pub const ERROR_FLT_INSTANCE_ALTITUDE_COLLISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452015));
pub const ERROR_FLT_INSTANCE_NAME_COLLISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452014));
pub const ERROR_FLT_FILTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452013));
pub const ERROR_FLT_VOLUME_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452012));
pub const ERROR_FLT_INSTANCE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452011));
pub const ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452010));
pub const ERROR_FLT_INVALID_CONTEXT_REGISTRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452009));
pub const ERROR_FLT_NAME_CACHE_MISS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452008));
pub const ERROR_FLT_NO_DEVICE_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452007));
pub const ERROR_FLT_VOLUME_ALREADY_MOUNTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452006));
pub const ERROR_FLT_ALREADY_ENLISTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452005));
pub const ERROR_FLT_CONTEXT_ALREADY_LINKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452004));
pub const ERROR_FLT_NO_WAITER_FOR_REPLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145452000));
pub const ERROR_FLT_REGISTRATION_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145451997));
pub const ERROR_HUNG_DISPLAY_DRIVER_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144993279));
pub const DWM_E_COMPOSITIONDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980991));
pub const DWM_E_REMOTING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980990));
pub const DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980989));
pub const DWM_E_NOT_QUEUING_PRESENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980988));
pub const DWM_E_ADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980987));
pub const DWM_S_GDI_REDIRECTION_SURFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2502661));
pub const DWM_E_TEXTURE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144980985));
pub const DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2502664));
pub const ERROR_MONITOR_NO_DESCRIPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2494465));
pub const ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2494466));
pub const ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247357));
pub const ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247356));
pub const ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247355));
pub const ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247354));
pub const ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247353));
pub const ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247352));
pub const ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247351));
pub const ERROR_MONITOR_INVALID_MANUFACTURE_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071247350));
pub const ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243264));
pub const ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243263));
pub const ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243262));
pub const ERROR_GRAPHICS_ADAPTER_WAS_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243261));
pub const ERROR_GRAPHICS_INVALID_DRIVER_MODEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243260));
pub const ERROR_GRAPHICS_PRESENT_MODE_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243259));
pub const ERROR_GRAPHICS_PRESENT_OCCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243258));
pub const ERROR_GRAPHICS_PRESENT_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243257));
pub const ERROR_GRAPHICS_CANNOTCOLORCONVERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243256));
pub const ERROR_GRAPHICS_DRIVER_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243255));
pub const ERROR_GRAPHICS_PARTIAL_DATA_POPULATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076240394));
pub const ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243253));
pub const ERROR_GRAPHICS_PRESENT_UNOCCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243252));
pub const ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243251));
pub const ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243250));
pub const ERROR_GRAPHICS_PRESENT_INVALID_WINDOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243249));
pub const ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243248));
pub const ERROR_GRAPHICS_VAIL_STATE_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243247));
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243246));
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243245));
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_CREATE_SUPERWETINK_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243244));
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_DESTROY_SUPERWETINK_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243243));
pub const ERROR_GRAPHICS_NO_VIDEO_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243008));
pub const ERROR_GRAPHICS_CANT_LOCK_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243007));
pub const ERROR_GRAPHICS_ALLOCATION_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243006));
pub const ERROR_GRAPHICS_TOO_MANY_REFERENCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243005));
pub const ERROR_GRAPHICS_TRY_AGAIN_LATER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243004));
pub const ERROR_GRAPHICS_TRY_AGAIN_NOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243003));
pub const ERROR_GRAPHICS_ALLOCATION_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243002));
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243001));
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071243000));
pub const ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242999));
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242992));
pub const ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242991));
pub const ERROR_GRAPHICS_ALLOCATION_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242990));
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242989));
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242988));
pub const ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242987));
pub const ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242986));
pub const ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242752));
pub const ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076240897));
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242496));
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242495));
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242494));
pub const ERROR_GRAPHICS_INVALID_VIDPN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242493));
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242492));
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242491));
pub const ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242490));
pub const ERROR_GRAPHICS_MODE_NOT_PINNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2499335));
pub const ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242488));
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242487));
pub const ERROR_GRAPHICS_INVALID_FREQUENCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242486));
pub const ERROR_GRAPHICS_INVALID_ACTIVE_REGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242485));
pub const ERROR_GRAPHICS_INVALID_TOTAL_REGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242484));
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242480));
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242479));
pub const ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242478));
pub const ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242477));
pub const ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242476));
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242475));
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242474));
pub const ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242473));
pub const ERROR_GRAPHICS_TARGET_ALREADY_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242472));
pub const ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242471));
pub const ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242470));
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242469));
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242468));
pub const ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242467));
pub const ERROR_GRAPHICS_NO_PREFERRED_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2499358));
pub const ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242465));
pub const ERROR_GRAPHICS_STALE_MODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242464));
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242463));
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242462));
pub const ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242461));
pub const ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242460));
pub const ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242459));
pub const ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242458));
pub const ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242457));
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242456));
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242455));
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242454));
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242453));
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242452));
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242451));
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242450));
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242449));
pub const ERROR_GRAPHICS_RESOURCES_NOT_RELATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242448));
pub const ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242447));
pub const ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242446));
pub const ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242445));
pub const ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242444));
pub const ERROR_GRAPHICS_NO_VIDPNMGR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242443));
pub const ERROR_GRAPHICS_NO_ACTIVE_VIDPN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242442));
pub const ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242441));
pub const ERROR_GRAPHICS_MONITOR_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242440));
pub const ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242439));
pub const ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242438));
pub const ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242437));
pub const ERROR_GRAPHICS_INVALID_STRIDE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242436));
pub const ERROR_GRAPHICS_INVALID_PIXELFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242435));
pub const ERROR_GRAPHICS_INVALID_COLORBASIS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242434));
pub const ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242433));
pub const ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242432));
pub const ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242431));
pub const ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242430));
pub const ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242429));
pub const ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242428));
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242427));
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242426));
pub const ERROR_GRAPHICS_INVALID_GAMMA_RAMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242425));
pub const ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242424));
pub const ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242423));
pub const ERROR_GRAPHICS_MODE_NOT_IN_MODESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242422));
pub const ERROR_GRAPHICS_DATASET_IS_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2499403));
pub const ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2499404));
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242419));
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242418));
pub const ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242417));
pub const ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242416));
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2499409));
pub const ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242414));
pub const ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242413));
pub const ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242412));
pub const ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242411));
pub const ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242410));
pub const ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242409));
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242408));
pub const ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242407));
pub const ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242406));
pub const ERROR_GRAPHICS_INVALID_CLIENT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242405));
pub const ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242404));
pub const ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242240));
pub const ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242239));
pub const ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076241455));
pub const ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242192));
pub const ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242191));
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242190));
pub const ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242189));
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242188));
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242187));
pub const ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242186));
pub const ERROR_GRAPHICS_LEADLINK_START_DEFERRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076241463));
pub const ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242184));
pub const ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076241465));
pub const ERROR_GRAPHICS_START_DEFERRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076241466));
pub const ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071242181));
pub const ERROR_GRAPHICS_DEPENDABLE_CHILD_STATUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076241468));
pub const ERROR_GRAPHICS_OPM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241984));
pub const ERROR_GRAPHICS_COPP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241983));
pub const ERROR_GRAPHICS_UAB_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241982));
pub const ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241981));
pub const ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241979));
pub const ERROR_GRAPHICS_OPM_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241973));
pub const ERROR_GRAPHICS_OPM_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241972));
pub const ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241970));
pub const ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241969));
pub const ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241968));
pub const ERROR_GRAPHICS_PVP_HFS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241967));
pub const ERROR_GRAPHICS_OPM_INVALID_SRM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241966));
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241965));
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241964));
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241963));
pub const ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241962));
pub const ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241961));
pub const ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241960));
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241958));
pub const ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241957));
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241956));
pub const ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241955));
pub const ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241954));
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241953));
pub const ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241952));
pub const ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241951));
pub const ERROR_GRAPHICS_I2C_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241856));
pub const ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241855));
pub const ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241854));
pub const ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241853));
pub const ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241852));
pub const ERROR_GRAPHICS_DDCCI_INVALID_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241851));
pub const ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241850));
pub const ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241849));
pub const ERROR_GRAPHICS_MCA_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241848));
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241847));
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241846));
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241845));
pub const ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241844));
pub const ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241843));
pub const ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241768));
pub const ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241767));
pub const ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241766));
pub const ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241765));
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241764));
pub const ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241762));
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241761));
pub const ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241760));
pub const ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241759));
pub const ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241758));
pub const ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241757));
pub const ERROR_GRAPHICS_INVALID_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241756));
pub const ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241755));
pub const ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241754));
pub const ERROR_GRAPHICS_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071241753));
pub const ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1071249944));
pub const NAP_E_INVALID_PACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927743));
pub const NAP_E_MISSING_SOH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927742));
pub const NAP_E_CONFLICTING_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927741));
pub const NAP_E_NO_CACHED_SOH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927740));
pub const NAP_E_STILL_BOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927739));
pub const NAP_E_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927738));
pub const NAP_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927737));
pub const NAP_E_MISMATCHED_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927736));
pub const NAP_E_NOT_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927735));
pub const NAP_E_ID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927734));
pub const NAP_E_MAXSIZE_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927733));
pub const NAP_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927732));
pub const NAP_S_CERT_ALREADY_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555917));
pub const NAP_E_ENTITY_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927730));
pub const NAP_E_NETSH_GROUPPOLICY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927729));
pub const NAP_E_TOO_MANY_CALLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927728));
pub const NAP_E_SHV_CONFIG_EXISTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927727));
pub const NAP_E_SHV_CONFIG_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927726));
pub const NAP_E_SHV_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927725));
pub const TPM_E_ERROR_MASK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862208));
pub const TPM_E_AUTHFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862207));
pub const TPM_E_BADINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862206));
pub const TPM_E_BAD_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862205));
pub const TPM_E_AUDITFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862204));
pub const TPM_E_CLEAR_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862203));
pub const TPM_E_DEACTIVATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862202));
pub const TPM_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862201));
pub const TPM_E_DISABLED_CMD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862200));
pub const TPM_E_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862199));
pub const TPM_E_BAD_ORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862198));
pub const TPM_E_INSTALL_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862197));
pub const TPM_E_INVALID_KEYHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862196));
pub const TPM_E_KEYNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862195));
pub const TPM_E_INAPPROPRIATE_ENC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862194));
pub const TPM_E_MIGRATEFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862193));
pub const TPM_E_INVALID_PCR_INFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862192));
pub const TPM_E_NOSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862191));
pub const TPM_E_NOSRK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862190));
pub const TPM_E_NOTSEALED_BLOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862189));
pub const TPM_E_OWNER_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862188));
pub const TPM_E_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862187));
pub const TPM_E_SHORTRANDOM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862186));
pub const TPM_E_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862185));
pub const TPM_E_WRONGPCRVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862184));
pub const TPM_E_BAD_PARAM_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862183));
pub const TPM_E_SHA_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862182));
pub const TPM_E_SHA_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862181));
pub const TPM_E_FAILEDSELFTEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862180));
pub const TPM_E_AUTH2FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862179));
pub const TPM_E_BADTAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862178));
pub const TPM_E_IOERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862177));
pub const TPM_E_ENCRYPT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862176));
pub const TPM_E_DECRYPT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862175));
pub const TPM_E_INVALID_AUTHHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862174));
pub const TPM_E_NO_ENDORSEMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862173));
pub const TPM_E_INVALID_KEYUSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862172));
pub const TPM_E_WRONG_ENTITYTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862171));
pub const TPM_E_INVALID_POSTINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862170));
pub const TPM_E_INAPPROPRIATE_SIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862169));
pub const TPM_E_BAD_KEY_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862168));
pub const TPM_E_BAD_MIGRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862167));
pub const TPM_E_BAD_SCHEME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862166));
pub const TPM_E_BAD_DATASIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862165));
pub const TPM_E_BAD_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862164));
pub const TPM_E_BAD_PRESENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862163));
pub const TPM_E_BAD_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862162));
pub const TPM_E_NO_WRAP_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862161));
pub const TPM_E_AUDITFAIL_UNSUCCESSFUL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862160));
pub const TPM_E_AUDITFAIL_SUCCESSFUL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862159));
pub const TPM_E_NOTRESETABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862158));
pub const TPM_E_NOTLOCAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862157));
pub const TPM_E_BAD_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862156));
pub const TPM_E_INVALID_RESOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862155));
pub const TPM_E_NOTFIPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862154));
pub const TPM_E_INVALID_FAMILY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862153));
pub const TPM_E_NO_NV_PERMISSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862152));
pub const TPM_E_REQUIRES_SIGN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862151));
pub const TPM_E_KEY_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862150));
pub const TPM_E_AUTH_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862149));
pub const TPM_E_AREA_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862148));
pub const TPM_E_BAD_LOCALITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862147));
pub const TPM_E_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862146));
pub const TPM_E_PER_NOWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862145));
pub const TPM_E_FAMILYCOUNT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862144));
pub const TPM_E_WRITE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862143));
pub const TPM_E_BAD_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862142));
pub const TPM_E_INVALID_STRUCTURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862141));
pub const TPM_E_KEY_OWNER_CONTROL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862140));
pub const TPM_E_BAD_COUNTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862139));
pub const TPM_E_NOT_FULLWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862138));
pub const TPM_E_CONTEXT_GAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862137));
pub const TPM_E_MAXNVWRITES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862136));
pub const TPM_E_NOOPERATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862135));
pub const TPM_E_RESOURCEMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862134));
pub const TPM_E_DELEGATE_LOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862133));
pub const TPM_E_DELEGATE_FAMILY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862132));
pub const TPM_E_DELEGATE_ADMIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862131));
pub const TPM_E_TRANSPORT_NOTEXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862130));
pub const TPM_E_OWNER_CONTROL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862129));
pub const TPM_E_DAA_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862128));
pub const TPM_E_DAA_INPUT_DATA0 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862127));
pub const TPM_E_DAA_INPUT_DATA1 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862126));
pub const TPM_E_DAA_ISSUER_SETTINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862125));
pub const TPM_E_DAA_TPM_SETTINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862124));
pub const TPM_E_DAA_STAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862123));
pub const TPM_E_DAA_ISSUER_VALIDITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862122));
pub const TPM_E_DAA_WRONG_W = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862121));
pub const TPM_E_BAD_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862120));
pub const TPM_E_BAD_DELEGATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862119));
pub const TPM_E_BADCONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862118));
pub const TPM_E_TOOMANYCONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862117));
pub const TPM_E_MA_TICKET_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862116));
pub const TPM_E_MA_DESTINATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862115));
pub const TPM_E_MA_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862114));
pub const TPM_E_MA_AUTHORITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862113));
pub const TPM_E_PERMANENTEK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862111));
pub const TPM_E_BAD_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862110));
pub const TPM_E_NOCONTEXTSPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862109));
pub const TPM_20_E_ASYMMETRIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862079));
pub const TPM_20_E_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862078));
pub const TPM_20_E_HASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862077));
pub const TPM_20_E_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862076));
pub const TPM_20_E_HIERARCHY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862075));
pub const TPM_20_E_KEY_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862073));
pub const TPM_20_E_MGF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862072));
pub const TPM_20_E_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862071));
pub const TPM_20_E_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862070));
pub const TPM_20_E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862069));
pub const TPM_20_E_KDF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862068));
pub const TPM_20_E_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862067));
pub const TPM_20_E_AUTH_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862066));
pub const TPM_20_E_NONCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862065));
pub const TPM_20_E_PP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862064));
pub const TPM_20_E_SCHEME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862062));
pub const TPM_20_E_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862059));
pub const TPM_20_E_SYMMETRIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862058));
pub const TPM_20_E_TAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862057));
pub const TPM_20_E_SELECTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862056));
pub const TPM_20_E_INSUFFICIENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862054));
pub const TPM_20_E_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862053));
pub const TPM_20_E_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862052));
pub const TPM_20_E_POLICY_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862051));
pub const TPM_20_E_INTEGRITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862049));
pub const TPM_20_E_TICKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862048));
pub const TPM_20_E_RESERVED_BITS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862047));
pub const TPM_20_E_BAD_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862046));
pub const TPM_20_E_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862045));
pub const TPM_20_E_POLICY_CC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862044));
pub const TPM_20_E_BINDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862043));
pub const TPM_20_E_CURVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862042));
pub const TPM_20_E_ECC_POINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144862041));
pub const TPM_20_E_INITIALIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861952));
pub const TPM_20_E_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861951));
pub const TPM_20_E_SEQUENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861949));
pub const TPM_20_E_PRIVATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861941));
pub const TPM_20_E_HMAC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861927));
pub const TPM_20_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861920));
pub const TPM_20_E_EXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861919));
pub const TPM_20_E_ECC_CURVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861917));
pub const TPM_20_E_AUTH_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861916));
pub const TPM_20_E_AUTH_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861915));
pub const TPM_20_E_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861914));
pub const TPM_20_E_PCR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861913));
pub const TPM_20_E_PCR_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861912));
pub const TPM_20_E_UPGRADE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861907));
pub const TPM_20_E_TOO_MANY_CONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861906));
pub const TPM_20_E_AUTH_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861905));
pub const TPM_20_E_REBOOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861904));
pub const TPM_20_E_UNBALANCED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861903));
pub const TPM_20_E_COMMAND_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861886));
pub const TPM_20_E_COMMAND_CODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861885));
pub const TPM_20_E_AUTHSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861884));
pub const TPM_20_E_AUTH_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861883));
pub const TPM_20_E_NV_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861882));
pub const TPM_20_E_NV_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861881));
pub const TPM_20_E_NV_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861880));
pub const TPM_20_E_NV_AUTHORIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861879));
pub const TPM_20_E_NV_UNINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861878));
pub const TPM_20_E_NV_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861877));
pub const TPM_20_E_NV_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861876));
pub const TPM_20_E_BAD_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861872));
pub const TPM_20_E_CPHASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861871));
pub const TPM_20_E_PARENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861870));
pub const TPM_20_E_NEEDS_TEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861869));
pub const TPM_20_E_NO_RESULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861868));
pub const TPM_20_E_SENSITIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861867));
pub const TPM_E_COMMAND_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861184));
pub const TPM_E_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861183));
pub const TPM_E_DUPLICATE_VHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861182));
pub const TPM_E_EMBEDDED_COMMAND_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861181));
pub const TPM_E_EMBEDDED_COMMAND_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144861180));
pub const TPM_E_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144860160));
pub const TPM_E_NEEDS_SELFTEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144860159));
pub const TPM_E_DOING_SELFTEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144860158));
pub const TPM_E_DEFEND_LOCK_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144860157));
pub const TPM_20_E_CONTEXT_GAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859903));
pub const TPM_20_E_OBJECT_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859902));
pub const TPM_20_E_SESSION_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859901));
pub const TPM_20_E_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859900));
pub const TPM_20_E_SESSION_HANDLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859899));
pub const TPM_20_E_OBJECT_HANDLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859898));
pub const TPM_20_E_LOCALITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859897));
pub const TPM_20_E_YIELDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859896));
pub const TPM_20_E_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859895));
pub const TPM_20_E_TESTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859894));
pub const TPM_20_E_NV_RATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859872));
pub const TPM_20_E_LOCKOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859871));
pub const TPM_20_E_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859870));
pub const TPM_20_E_NV_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144859869));
pub const TBS_E_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845823));
pub const TBS_E_BAD_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845822));
pub const TBS_E_INVALID_OUTPUT_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845821));
pub const TBS_E_INVALID_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845820));
pub const TBS_E_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845819));
pub const TBS_E_IOERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845818));
pub const TBS_E_INVALID_CONTEXT_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845817));
pub const TBS_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845816));
pub const TBS_E_TOO_MANY_TBS_CONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845815));
pub const TBS_E_TOO_MANY_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845814));
pub const TBS_E_SERVICE_START_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845813));
pub const TBS_E_PPI_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845812));
pub const TBS_E_COMMAND_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845811));
pub const TBS_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845810));
pub const TBS_E_TPM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845809));
pub const TBS_E_SERVICE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845808));
pub const TBS_E_NO_EVENT_LOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845807));
pub const TBS_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845806));
pub const TBS_E_PROVISIONING_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845805));
pub const TBS_E_PPI_FUNCTION_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845804));
pub const TBS_E_OWNERAUTH_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845803));
pub const TBS_E_PROVISIONING_INCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144845802));
pub const TPMAPI_E_INVALID_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796416));
pub const TPMAPI_E_NOT_ENOUGH_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796415));
pub const TPMAPI_E_TOO_MUCH_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796414));
pub const TPMAPI_E_INVALID_OUTPUT_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796413));
pub const TPMAPI_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796412));
pub const TPMAPI_E_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796411));
pub const TPMAPI_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796410));
pub const TPMAPI_E_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796409));
pub const TPMAPI_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796408));
pub const TPMAPI_E_AUTHORIZATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796407));
pub const TPMAPI_E_INVALID_CONTEXT_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796406));
pub const TPMAPI_E_TBS_COMMUNICATION_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796405));
pub const TPMAPI_E_TPM_COMMAND_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796404));
pub const TPMAPI_E_MESSAGE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796403));
pub const TPMAPI_E_INVALID_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796402));
pub const TPMAPI_E_INVALID_KEY_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796401));
pub const TPMAPI_E_ENCRYPTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796400));
pub const TPMAPI_E_INVALID_KEY_PARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796399));
pub const TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796398));
pub const TPMAPI_E_INVALID_PCR_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796397));
pub const TPMAPI_E_INVALID_DELEGATE_BLOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796396));
pub const TPMAPI_E_INVALID_CONTEXT_PARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796395));
pub const TPMAPI_E_INVALID_KEY_BLOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796394));
pub const TPMAPI_E_INVALID_PCR_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796393));
pub const TPMAPI_E_INVALID_OWNER_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796392));
pub const TPMAPI_E_FIPS_RNG_CHECK_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796391));
pub const TPMAPI_E_EMPTY_TCG_LOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796390));
pub const TPMAPI_E_INVALID_TCG_LOG_ENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796389));
pub const TPMAPI_E_TCG_SEPARATOR_ABSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796388));
pub const TPMAPI_E_TCG_INVALID_DIGEST_ENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796387));
pub const TPMAPI_E_POLICY_DENIES_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796386));
pub const TPMAPI_E_NV_BITS_NOT_DEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796385));
pub const TPMAPI_E_NV_BITS_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796384));
pub const TPMAPI_E_SEALING_KEY_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796383));
pub const TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796382));
pub const TPMAPI_E_SVN_COUNTER_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796381));
pub const TPMAPI_E_OWNER_AUTH_NOT_NULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796380));
pub const TPMAPI_E_ENDORSEMENT_AUTH_NOT_NULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796379));
pub const TPMAPI_E_AUTHORIZATION_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796378));
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796377));
pub const TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796376));
pub const TPMAPI_E_INVALID_AUTHORIZATION_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796375));
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796374));
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796373));
pub const TPMAPI_E_SEALING_KEY_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796372));
pub const TPMAPI_E_INVALID_TPM_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796371));
pub const TPMAPI_E_INVALID_POLICYAUTH_BLOB_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796370));
pub const TBSIMP_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796160));
pub const TBSIMP_E_CLEANUP_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796159));
pub const TBSIMP_E_INVALID_CONTEXT_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796158));
pub const TBSIMP_E_INVALID_CONTEXT_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796157));
pub const TBSIMP_E_TPM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796156));
pub const TBSIMP_E_HASH_BAD_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796155));
pub const TBSIMP_E_DUPLICATE_VHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796154));
pub const TBSIMP_E_INVALID_OUTPUT_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796153));
pub const TBSIMP_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796152));
pub const TBSIMP_E_RPC_INIT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796151));
pub const TBSIMP_E_SCHEDULER_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796150));
pub const TBSIMP_E_COMMAND_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796149));
pub const TBSIMP_E_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796148));
pub const TBSIMP_E_LIST_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796147));
pub const TBSIMP_E_LIST_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796146));
pub const TBSIMP_E_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796145));
pub const TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796144));
pub const TBSIMP_E_COMMAND_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796143));
pub const TBSIMP_E_UNKNOWN_ORDINAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796142));
pub const TBSIMP_E_RESOURCE_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796141));
pub const TBSIMP_E_INVALID_RESOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796140));
pub const TBSIMP_E_NOTHING_TO_UNLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796139));
pub const TBSIMP_E_HASH_TABLE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796138));
pub const TBSIMP_E_TOO_MANY_TBS_CONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796137));
pub const TBSIMP_E_TOO_MANY_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796136));
pub const TBSIMP_E_PPI_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796135));
pub const TBSIMP_E_TPM_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796134));
pub const TBSIMP_E_NO_EVENT_LOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144796133));
pub const TPM_E_PPI_ACPI_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795904));
pub const TPM_E_PPI_USER_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795903));
pub const TPM_E_PPI_BIOS_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795902));
pub const TPM_E_PPI_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795901));
pub const TPM_E_PPI_BLOCKED_IN_BIOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795900));
pub const TPM_E_PCP_ERROR_MASK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795648));
pub const TPM_E_PCP_DEVICE_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795647));
pub const TPM_E_PCP_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795646));
pub const TPM_E_PCP_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795645));
pub const TPM_E_PCP_FLAG_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795644));
pub const TPM_E_PCP_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795643));
pub const TPM_E_PCP_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795642));
pub const TPM_E_PCP_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795641));
pub const TPM_E_PCP_AUTHENTICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795640));
pub const TPM_E_PCP_AUTHENTICATION_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795639));
pub const TPM_E_PCP_POLICY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795638));
pub const TPM_E_PCP_PROFILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795637));
pub const TPM_E_PCP_VALIDATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795636));
pub const TPM_E_PCP_WRONG_PARENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795634));
pub const TPM_E_KEY_NOT_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795633));
pub const TPM_E_NO_KEY_CERTIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795632));
pub const TPM_E_KEY_NOT_FINALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795631));
pub const TPM_E_ATTESTATION_CHALLENGE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795630));
pub const TPM_E_NOT_PCR_BOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795629));
pub const TPM_E_KEY_ALREADY_FINALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795628));
pub const TPM_E_KEY_USAGE_POLICY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795627));
pub const TPM_E_KEY_USAGE_POLICY_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795626));
pub const TPM_E_SOFT_KEY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795625));
pub const TPM_E_KEY_NOT_AUTHENTICATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795624));
pub const TPM_E_PCP_KEY_NOT_AIK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795623));
pub const TPM_E_KEY_NOT_SIGNING_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795622));
pub const TPM_E_LOCKED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795621));
pub const TPM_E_CLAIM_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795620));
pub const TPM_E_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795619));
pub const TPM_E_BUFFER_LENGTH_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795618));
pub const TPM_E_PCP_IFX_RSA_KEY_CREATION_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795617));
pub const TPM_E_PCP_TICKET_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795616));
pub const TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795615));
pub const TPM_E_PCP_KEY_HANDLE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795614));
pub const TPM_E_PCP_UNSUPPORTED_PSS_SALT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076429859));
pub const TPM_E_PCP_PLATFORM_CLAIM_MAY_BE_OUTDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076429860));
pub const TPM_E_PCP_PLATFORM_CLAIM_OUTDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076429861));
pub const TPM_E_PCP_PLATFORM_CLAIM_REBOOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1076429862));
pub const TPM_E_ZERO_EXHAUST_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795392));
pub const TPM_E_PROVISIONING_INCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795136));
pub const TPM_E_INVALID_OWNER_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795135));
pub const TPM_E_TOO_MUCH_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144795134));
pub const PLA_E_DCS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337918));
pub const PLA_E_DCS_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337750));
pub const PLA_E_TOO_MANY_FOLDERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337851));
pub const PLA_E_NO_MIN_DISK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337808));
pub const PLA_E_DCS_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337737));
pub const PLA_S_PROPERTY_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 3145984));
pub const PLA_E_PROPERTY_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337663));
pub const PLA_E_DCS_SINGLETON_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337662));
pub const PLA_E_CREDENTIALS_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337661));
pub const PLA_E_DCS_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337660));
pub const PLA_E_CONFLICT_INCL_EXCL_API = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337659));
pub const PLA_E_NETWORK_EXE_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337658));
pub const PLA_E_EXE_ALREADY_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337657));
pub const PLA_E_EXE_PATH_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337656));
pub const PLA_E_DC_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337655));
pub const PLA_E_DCS_START_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337654));
pub const PLA_E_DC_START_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337653));
pub const PLA_E_REPORT_WAIT_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337652));
pub const PLA_E_NO_DUPLICATES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337651));
pub const PLA_E_EXE_FULL_PATH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337650));
pub const PLA_E_INVALID_SESSION_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337649));
pub const PLA_E_PLA_CHANNEL_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337648));
pub const PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337647));
pub const PLA_E_RULES_MANAGER_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337646));
pub const PLA_E_CABAPI_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144337645));
pub const FVE_E_LOCKED_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272384));
pub const FVE_E_NOT_ENCRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272383));
pub const FVE_E_NO_TPM_BIOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272382));
pub const FVE_E_NO_MBR_METRIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272381));
pub const FVE_E_NO_BOOTSECTOR_METRIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272380));
pub const FVE_E_NO_BOOTMGR_METRIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272379));
pub const FVE_E_WRONG_BOOTMGR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272378));
pub const FVE_E_SECURE_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272377));
pub const FVE_E_NOT_ACTIVATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272376));
pub const FVE_E_ACTION_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272375));
pub const FVE_E_AD_SCHEMA_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272374));
pub const FVE_E_AD_INVALID_DATATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272373));
pub const FVE_E_AD_INVALID_DATASIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272372));
pub const FVE_E_AD_NO_VALUES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272371));
pub const FVE_E_AD_ATTR_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272370));
pub const FVE_E_AD_GUID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272369));
pub const FVE_E_BAD_INFORMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272368));
pub const FVE_E_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272367));
pub const FVE_E_SYSTEM_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272366));
pub const FVE_E_FAILED_WRONG_FS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272365));
pub const FVE_E_BAD_PARTITION_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272364));
pub const FVE_E_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272363));
pub const FVE_E_BAD_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272362));
pub const FVE_E_VOLUME_NOT_BOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272361));
pub const FVE_E_TPM_NOT_OWNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272360));
pub const FVE_E_NOT_DATA_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272359));
pub const FVE_E_AD_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272358));
pub const FVE_E_CONV_READ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272357));
pub const FVE_E_CONV_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272356));
pub const FVE_E_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272355));
pub const FVE_E_CLUSTERING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272354));
pub const FVE_E_VOLUME_BOUND_ALREADY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272353));
pub const FVE_E_OS_NOT_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272352));
pub const FVE_E_PROTECTION_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272351));
pub const FVE_E_RECOVERY_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272350));
pub const FVE_E_FOREIGN_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272349));
pub const FVE_E_OVERLAPPED_UPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272348));
pub const FVE_E_TPM_SRK_AUTH_NOT_ZERO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272347));
pub const FVE_E_FAILED_SECTOR_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272346));
pub const FVE_E_FAILED_AUTHENTICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272345));
pub const FVE_E_NOT_OS_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272344));
pub const FVE_E_AUTOUNLOCK_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272343));
pub const FVE_E_WRONG_BOOTSECTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272342));
pub const FVE_E_WRONG_SYSTEM_FS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272341));
pub const FVE_E_POLICY_PASSWORD_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272340));
pub const FVE_E_CANNOT_SET_FVEK_ENCRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272339));
pub const FVE_E_CANNOT_ENCRYPT_NO_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272338));
pub const FVE_E_BOOTABLE_CDDVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272336));
pub const FVE_E_PROTECTOR_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272335));
pub const FVE_E_RELATIVE_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272334));
pub const FVE_E_PROTECTOR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272333));
pub const FVE_E_INVALID_KEY_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272332));
pub const FVE_E_INVALID_PASSWORD_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272331));
pub const FVE_E_FIPS_RNG_CHECK_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272330));
pub const FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272329));
pub const FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272328));
pub const FVE_E_NOT_DECRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272327));
pub const FVE_E_INVALID_PROTECTOR_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272326));
pub const FVE_E_NO_PROTECTORS_TO_TEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272325));
pub const FVE_E_KEYFILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272324));
pub const FVE_E_KEYFILE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272323));
pub const FVE_E_KEYFILE_NO_VMK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272322));
pub const FVE_E_TPM_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272321));
pub const FVE_E_NOT_ALLOWED_IN_SAFE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272320));
pub const FVE_E_TPM_INVALID_PCR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272319));
pub const FVE_E_TPM_NO_VMK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272318));
pub const FVE_E_PIN_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272317));
pub const FVE_E_AUTH_INVALID_APPLICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272316));
pub const FVE_E_AUTH_INVALID_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272315));
pub const FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272314));
pub const FVE_E_FS_NOT_EXTENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272313));
pub const FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272312));
pub const FVE_E_NO_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272311));
pub const FVE_E_NOT_ON_STACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272310));
pub const FVE_E_FS_MOUNTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272309));
pub const FVE_E_TOKEN_NOT_IMPERSONATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272308));
pub const FVE_E_DRY_RUN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272307));
pub const FVE_E_REBOOT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272306));
pub const FVE_E_DEBUGGER_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272305));
pub const FVE_E_RAW_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272304));
pub const FVE_E_RAW_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272303));
pub const FVE_E_BCD_APPLICATIONS_PATH_INCORRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272302));
pub const FVE_E_NOT_ALLOWED_IN_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272301));
pub const FVE_E_NO_AUTOUNLOCK_MASTER_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272300));
pub const FVE_E_MOR_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272299));
pub const FVE_E_HIDDEN_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272298));
pub const FVE_E_TRANSIENT_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272297));
pub const FVE_E_PUBKEY_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272296));
pub const FVE_E_VOLUME_HANDLE_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272295));
pub const FVE_E_NO_FEATURE_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272294));
pub const FVE_E_INVALID_STARTUP_OPTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272293));
pub const FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272292));
pub const FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272291));
pub const FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272290));
pub const FVE_E_POLICY_RECOVERY_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272289));
pub const FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272288));
pub const FVE_E_POLICY_STARTUP_PIN_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272287));
pub const FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272286));
pub const FVE_E_POLICY_STARTUP_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272285));
pub const FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272284));
pub const FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272283));
pub const FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272282));
pub const FVE_E_POLICY_STARTUP_TPM_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272281));
pub const FVE_E_POLICY_INVALID_PIN_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272280));
pub const FVE_E_KEY_PROTECTOR_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272279));
pub const FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272278));
pub const FVE_E_POLICY_PASSPHRASE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272277));
pub const FVE_E_FIPS_PREVENTS_PASSPHRASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272276));
pub const FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272275));
pub const FVE_E_INVALID_BITLOCKER_OID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272274));
pub const FVE_E_VOLUME_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272273));
pub const FVE_E_DV_NOT_SUPPORTED_ON_FS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272272));
pub const FVE_E_DV_NOT_ALLOWED_BY_GP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272271));
pub const FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272270));
pub const FVE_E_POLICY_USER_CERTIFICATE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272269));
pub const FVE_E_POLICY_USER_CERT_MUST_BE_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272268));
pub const FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272267));
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272266));
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272265));
pub const FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272264));
pub const FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272263));
pub const FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272256));
pub const FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272255));
pub const FVE_E_RECOVERY_PARTITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272254));
pub const FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272253));
pub const FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272252));
pub const FVE_E_NON_BITLOCKER_OID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272251));
pub const FVE_E_POLICY_PROHIBITS_SELFSIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272250));
pub const FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272249));
pub const FVE_E_CONV_RECOVERY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272248));
pub const FVE_E_VIRTUALIZED_SPACE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272247));
pub const FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272240));
pub const FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272239));
pub const FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272238));
pub const FVE_E_NON_BITLOCKER_KU = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272237));
pub const FVE_E_PRIVATEKEY_AUTH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272236));
pub const FVE_E_REMOVAL_OF_DRA_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272235));
pub const FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272234));
pub const FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272233));
pub const FVE_E_FIPS_HASH_KDF_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272232));
pub const FVE_E_ENH_PIN_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272231));
pub const FVE_E_INVALID_PIN_CHARS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272230));
pub const FVE_E_INVALID_DATUM_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272229));
pub const FVE_E_EFI_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272228));
pub const FVE_E_MULTIPLE_NKP_CERTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272227));
pub const FVE_E_REMOVAL_OF_NKP_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272226));
pub const FVE_E_INVALID_NKP_CERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272225));
pub const FVE_E_NO_EXISTING_PIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272224));
pub const FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272223));
pub const FVE_E_PIN_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272222));
pub const FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272221));
pub const FVE_E_POLICY_PASSPHRASE_REQUIRES_ASCII = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272220));
pub const FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272219));
pub const FVE_E_WIPE_NOT_ALLOWED_ON_TP_STORAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272218));
pub const FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272217));
pub const FVE_E_NO_EXISTING_PASSPHRASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272216));
pub const FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272215));
pub const FVE_E_PASSPHRASE_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272214));
pub const FVE_E_NO_PASSPHRASE_WITH_TPM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272213));
pub const FVE_E_NO_TPM_WITH_PASSPHRASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272212));
pub const FVE_E_NOT_ALLOWED_ON_CSV_STACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272211));
pub const FVE_E_NOT_ALLOWED_ON_CLUSTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272210));
pub const FVE_E_EDRIVE_NO_FAILOVER_TO_SW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272209));
pub const FVE_E_EDRIVE_BAND_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272208));
pub const FVE_E_EDRIVE_DISALLOWED_BY_GP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272207));
pub const FVE_E_EDRIVE_INCOMPATIBLE_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272206));
pub const FVE_E_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272205));
pub const FVE_E_EDRIVE_DV_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272204));
pub const FVE_E_NO_PREBOOT_KEYBOARD_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272203));
pub const FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272202));
pub const FVE_E_POLICY_REQUIRES_STARTUP_PIN_ON_TOUCH_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272201));
pub const FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272200));
pub const FVE_E_WIPE_CANCEL_NOT_APPLICABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272199));
pub const FVE_E_SECUREBOOT_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272198));
pub const FVE_E_SECUREBOOT_CONFIGURATION_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272197));
pub const FVE_E_EDRIVE_DRY_RUN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272196));
pub const FVE_E_SHADOW_COPY_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272195));
pub const FVE_E_POLICY_INVALID_ENHANCED_BCD_SETTINGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272194));
pub const FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272193));
pub const FVE_E_PROTECTOR_CHANGE_MAX_PASSPHRASE_CHANGE_ATTEMPTS_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272192));
pub const FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272191));
pub const FVE_E_LIVEID_ACCOUNT_SUSPENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272190));
pub const FVE_E_LIVEID_ACCOUNT_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272189));
pub const FVE_E_NOT_PROVISIONED_ON_ALL_VOLUMES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272188));
pub const FVE_E_DE_FIXED_DATA_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272187));
pub const FVE_E_DE_HARDWARE_NOT_COMPLIANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272186));
pub const FVE_E_DE_WINRE_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272185));
pub const FVE_E_DE_PROTECTION_SUSPENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272184));
pub const FVE_E_DE_OS_VOLUME_NOT_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272183));
pub const FVE_E_DE_DEVICE_LOCKEDOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272182));
pub const FVE_E_DE_PROTECTION_NOT_YET_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272181));
pub const FVE_E_INVALID_PIN_CHARS_DETAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272180));
pub const FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272179));
pub const FVE_E_DEVICELOCKOUT_COUNTER_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272178));
pub const FVE_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272177));
pub const FVE_E_NO_SUCH_CAPABILITY_ON_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272176));
pub const FVE_E_DE_PREVENTED_FOR_OS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272175));
pub const FVE_E_DE_VOLUME_OPTED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272174));
pub const FVE_E_DE_VOLUME_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272173));
pub const FVE_E_EOW_NOT_SUPPORTED_IN_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272172));
pub const FVE_E_ADBACKUP_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272171));
pub const FVE_E_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272170));
pub const FVE_E_NOT_DE_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272169));
pub const FVE_E_PROTECTION_CANNOT_BE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272168));
pub const FVE_E_OSV_KSR_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272167));
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_OS_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272166));
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_FIXED_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272165));
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272164));
pub const FVE_E_KEY_ROTATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272163));
pub const FVE_E_EXECUTE_REQUEST_SENT_TOO_SOON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272162));
pub const FVE_E_KEY_ROTATION_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272161));
pub const FVE_E_DEVICE_NOT_JOINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272160));
pub const FVE_E_AAD_ENDPOINT_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144272159));
pub const FWP_E_CALLOUT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206847));
pub const FWP_E_CONDITION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206846));
pub const FWP_E_FILTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206845));
pub const FWP_E_LAYER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206844));
pub const FWP_E_PROVIDER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206843));
pub const FWP_E_PROVIDER_CONTEXT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206842));
pub const FWP_E_SUBLAYER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206841));
pub const FWP_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206840));
pub const FWP_E_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206839));
pub const FWP_E_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206838));
pub const FWP_E_DYNAMIC_SESSION_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206837));
pub const FWP_E_WRONG_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206836));
pub const FWP_E_NO_TXN_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206835));
pub const FWP_E_TXN_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206834));
pub const FWP_E_TXN_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206833));
pub const FWP_E_SESSION_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206832));
pub const FWP_E_INCOMPATIBLE_TXN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206831));
pub const FWP_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206830));
pub const FWP_E_NET_EVENTS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206829));
pub const FWP_E_INCOMPATIBLE_LAYER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206828));
pub const FWP_E_KM_CLIENTS_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206827));
pub const FWP_E_LIFETIME_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206826));
pub const FWP_E_BUILTIN_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206825));
pub const FWP_E_TOO_MANY_CALLOUTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206824));
pub const FWP_E_NOTIFICATION_DROPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206823));
pub const FWP_E_TRAFFIC_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206822));
pub const FWP_E_INCOMPATIBLE_SA_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206821));
pub const FWP_E_NULL_POINTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206820));
pub const FWP_E_INVALID_ENUMERATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206819));
pub const FWP_E_INVALID_FLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206818));
pub const FWP_E_INVALID_NET_MASK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206817));
pub const FWP_E_INVALID_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206816));
pub const FWP_E_INVALID_INTERVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206815));
pub const FWP_E_ZERO_LENGTH_ARRAY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206814));
pub const FWP_E_NULL_DISPLAY_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206813));
pub const FWP_E_INVALID_ACTION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206812));
pub const FWP_E_INVALID_WEIGHT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206811));
pub const FWP_E_MATCH_TYPE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206810));
pub const FWP_E_TYPE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206809));
pub const FWP_E_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206808));
pub const FWP_E_RESERVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206807));
pub const FWP_E_DUPLICATE_CONDITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206806));
pub const FWP_E_DUPLICATE_KEYMOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206805));
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206804));
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206803));
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206802));
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206801));
pub const FWP_E_INCOMPATIBLE_AUTH_METHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206800));
pub const FWP_E_INCOMPATIBLE_DH_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206799));
pub const FWP_E_EM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206798));
pub const FWP_E_NEVER_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206797));
pub const FWP_E_PROVIDER_CONTEXT_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206796));
pub const FWP_E_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206795));
pub const FWP_E_TOO_MANY_SUBLAYERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206794));
pub const FWP_E_CALLOUT_NOTIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206793));
pub const FWP_E_INVALID_AUTH_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206792));
pub const FWP_E_INVALID_CIPHER_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206791));
pub const FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206790));
pub const FWP_E_INVALID_TRANSFORM_COMBINATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206789));
pub const FWP_E_DUPLICATE_AUTH_METHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206788));
pub const FWP_E_INVALID_TUNNEL_ENDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206787));
pub const FWP_E_L2_DRIVER_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206786));
pub const FWP_E_KEY_DICTATOR_ALREADY_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206785));
pub const FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206784));
pub const FWP_E_CONNECTIONS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206783));
pub const FWP_E_INVALID_DNS_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206782));
pub const FWP_E_STILL_ON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206781));
pub const FWP_E_IKEEXT_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206780));
pub const FWP_E_DROP_NOICMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144206588));
pub const WS_S_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 3997696));
pub const WS_S_END = @import("../zig.zig").typedConst(HRESULT, @as(i32, 3997697));
pub const WS_E_INVALID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485952));
pub const WS_E_OBJECT_FAULTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485951));
pub const WS_E_NUMERIC_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485950));
pub const WS_E_INVALID_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485949));
pub const WS_E_OPERATION_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485948));
pub const WS_E_ENDPOINT_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485947));
pub const WS_E_OPERATION_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485946));
pub const WS_E_OPERATION_ABANDONED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485945));
pub const WS_E_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485944));
pub const WS_E_NO_TRANSLATION_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485943));
pub const WS_E_SECURITY_VERIFICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485942));
pub const WS_E_ADDRESS_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485941));
pub const WS_E_ADDRESS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485940));
pub const WS_E_ENDPOINT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485939));
pub const WS_E_ENDPOINT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485938));
pub const WS_E_ENDPOINT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485937));
pub const WS_E_ENDPOINT_UNREACHABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485936));
pub const WS_E_ENDPOINT_ACTION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485935));
pub const WS_E_ENDPOINT_TOO_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485934));
pub const WS_E_ENDPOINT_FAULT_RECEIVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485933));
pub const WS_E_ENDPOINT_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485932));
pub const WS_E_PROXY_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485931));
pub const WS_E_PROXY_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485930));
pub const WS_E_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485929));
pub const WS_E_PROXY_REQUIRES_BASIC_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485928));
pub const WS_E_PROXY_REQUIRES_DIGEST_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485927));
pub const WS_E_PROXY_REQUIRES_NTLM_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485926));
pub const WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485925));
pub const WS_E_SERVER_REQUIRES_BASIC_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485924));
pub const WS_E_SERVER_REQUIRES_DIGEST_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485923));
pub const WS_E_SERVER_REQUIRES_NTLM_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485922));
pub const WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485921));
pub const WS_E_INVALID_ENDPOINT_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485920));
pub const WS_E_OTHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485919));
pub const WS_E_SECURITY_TOKEN_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485918));
pub const WS_E_SECURITY_SYSTEM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143485917));
pub const HCS_E_TERMINATED_DURING_START = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878912));
pub const HCS_E_IMAGE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878911));
pub const HCS_E_HYPERV_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878910));
pub const HCS_E_INVALID_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878907));
pub const HCS_E_UNEXPECTED_EXIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878906));
pub const HCS_E_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878905));
pub const HCS_E_CONNECT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878904));
pub const HCS_E_CONNECTION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878903));
pub const HCS_E_CONNECTION_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878902));
pub const HCS_E_UNKNOWN_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878901));
pub const HCS_E_UNSUPPORTED_PROTOCOL_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878900));
pub const HCS_E_INVALID_JSON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878899));
pub const HCS_E_SYSTEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878898));
pub const HCS_E_SYSTEM_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878897));
pub const HCS_E_SYSTEM_ALREADY_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878896));
pub const HCS_E_PROTOCOL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878895));
pub const HCS_E_INVALID_LAYER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878894));
pub const HCS_E_WINDOWS_INSIDER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878893));
pub const HCS_E_SERVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878892));
pub const HCS_E_OPERATION_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878891));
pub const HCS_E_OPERATION_ALREADY_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878890));
pub const HCS_E_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878889));
pub const HCS_E_OPERATION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878888));
pub const HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878887));
pub const HCS_E_OPERATION_RESULT_ALLOCATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878886));
pub const HCS_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878885));
pub const HCS_E_GUEST_CRITICAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878884));
pub const HCS_E_PROCESS_INFO_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878883));
pub const HCS_E_SERVICE_DISCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878882));
pub const HCS_E_PROCESS_ALREADY_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878881));
pub const WHV_E_UNKNOWN_CAPABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878400));
pub const WHV_E_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878399));
pub const WHV_E_UNKNOWN_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878398));
pub const WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878397));
pub const WHV_E_INVALID_PARTITION_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878396));
pub const WHV_E_GPA_RANGE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878395));
pub const WHV_E_VP_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878394));
pub const WHV_E_VP_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878393));
pub const WHV_E_INVALID_VP_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878392));
pub const WHV_E_INVALID_VP_REGISTER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878391));
pub const WHV_E_UNSUPPORTED_PROCESSOR_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143878384));
pub const VM_SAVED_STATE_DUMP_E_PARTITION_STATE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136064));
pub const VM_SAVED_STATE_DUMP_E_GUEST_MEMORY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136063));
pub const VM_SAVED_STATE_DUMP_E_NO_VP_FOUND_IN_PARTITION_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136062));
pub const VM_SAVED_STATE_DUMP_E_NESTED_VIRTUALIZATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136061));
pub const VM_SAVED_STATE_DUMP_E_WINDOWS_KERNEL_IMAGE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136060));
pub const VM_SAVED_STATE_DUMP_E_PXE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136059));
pub const VM_SAVED_STATE_DUMP_E_PDPTE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136058));
pub const VM_SAVED_STATE_DUMP_E_PDE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136057));
pub const VM_SAVED_STATE_DUMP_E_PTE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1070136056));
pub const HCN_E_NETWORK_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617023));
pub const HCN_E_ENDPOINT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617022));
pub const HCN_E_LAYER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617021));
pub const HCN_E_SWITCH_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617020));
pub const HCN_E_SUBNET_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617019));
pub const HCN_E_ADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617018));
pub const HCN_E_PORT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617017));
pub const HCN_E_POLICY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617016));
pub const HCN_E_VFP_PORTSETTING_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617015));
pub const HCN_E_INVALID_NETWORK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617014));
pub const HCN_E_INVALID_NETWORK_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617013));
pub const HCN_E_INVALID_ENDPOINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617012));
pub const HCN_E_INVALID_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617011));
pub const HCN_E_INVALID_POLICY_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617010));
pub const HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617009));
pub const HCN_E_NETWORK_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617008));
pub const HCN_E_LAYER_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617007));
pub const HCN_E_POLICY_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617006));
pub const HCN_E_PORT_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617005));
pub const HCN_E_ENDPOINT_ALREADY_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617004));
pub const HCN_E_REQUEST_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617003));
pub const HCN_E_MAPPING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617002));
pub const HCN_E_DEGRADED_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617001));
pub const HCN_E_SHARED_SWITCH_MODIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143617000));
pub const HCN_E_GUID_CONVERSION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616999));
pub const HCN_E_REGKEY_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616998));
pub const HCN_E_INVALID_JSON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616997));
pub const HCN_E_INVALID_JSON_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616996));
pub const HCN_E_ENDPOINT_SHARING_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616995));
pub const HCN_E_INVALID_IP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616994));
pub const HCN_E_SWITCH_EXTENSION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616993));
pub const HCN_E_MANAGER_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616992));
pub const GCN_E_MODULE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616991));
pub const GCN_E_NO_REQUEST_HANDLERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616990));
pub const GCN_E_REQUEST_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616989));
pub const GCN_E_RUNTIMEKEYS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616988));
pub const GCN_E_NETADAPTER_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616987));
pub const GCN_E_NETADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616986));
pub const GCN_E_NETCOMPARTMENT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616985));
pub const GCN_E_NETINTERFACE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616984));
pub const GCN_E_DEFAULTNAMESPACE_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616983));
pub const HCN_E_ICS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616982));
pub const HCN_E_ENDPOINT_NAMESPACE_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616981));
pub const HCN_E_ENTITY_HAS_REFERENCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616980));
pub const HCN_E_INVALID_INTERNAL_PORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616979));
pub const HCN_E_NAMESPACE_ATTACH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616978));
pub const HCN_E_ADDR_INVALID_OR_RESERVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616977));
pub const HCN_E_INVALID_PREFIX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616976));
pub const HCN_E_OBJECT_USED_AFTER_UNLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616975));
pub const HCN_E_INVALID_SUBNET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616974));
pub const HCN_E_INVALID_IP_SUBNET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616973));
pub const HCN_E_ENDPOINT_NOT_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616972));
pub const HCN_E_ENDPOINT_NOT_LOCAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616971));
pub const HCN_INTERFACEPARAMETERS_ALREADY_APPLIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143616970));
pub const SDIAG_E_CANCELLED = @as(i32, -2143551232);
pub const SDIAG_E_SCRIPT = @as(i32, -2143551231);
pub const SDIAG_E_POWERSHELL = @as(i32, -2143551230);
pub const SDIAG_E_MANAGEDHOST = @as(i32, -2143551229);
pub const SDIAG_E_NOVERIFIER = @as(i32, -2143551228);
pub const SDIAG_S_CANNOTRUN = @as(i32, 3932421);
pub const SDIAG_E_DISABLED = @as(i32, -2143551226);
pub const SDIAG_E_TRUST = @as(i32, -2143551225);
pub const SDIAG_E_CANNOTRUN = @as(i32, -2143551224);
pub const SDIAG_E_VERSION = @as(i32, -2143551223);
pub const SDIAG_E_RESOURCE = @as(i32, -2143551222);
pub const SDIAG_E_ROOTCAUSE = @as(i32, -2143551221);
pub const WPN_E_CHANNEL_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420160));
pub const WPN_E_CHANNEL_REQUEST_NOT_COMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420159));
pub const WPN_E_INVALID_APP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420158));
pub const WPN_E_OUTSTANDING_CHANNEL_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420157));
pub const WPN_E_DUPLICATE_CHANNEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420156));
pub const WPN_E_PLATFORM_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420155));
pub const WPN_E_NOTIFICATION_POSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420154));
pub const WPN_E_NOTIFICATION_HIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420153));
pub const WPN_E_NOTIFICATION_NOT_POSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420152));
pub const WPN_E_CLOUD_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420151));
pub const WPN_E_CLOUD_INCAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420144));
pub const WPN_E_CLOUD_AUTH_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420134));
pub const WPN_E_CLOUD_SERVICE_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420133));
pub const WPN_E_FAILED_LOCK_SCREEN_UPDATE_INTIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420132));
pub const WPN_E_NOTIFICATION_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420143));
pub const WPN_E_NOTIFICATION_INCAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420142));
pub const WPN_E_INTERNET_INCAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420141));
pub const WPN_E_NOTIFICATION_TYPE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420140));
pub const WPN_E_NOTIFICATION_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420139));
pub const WPN_E_TAG_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420138));
pub const WPN_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420137));
pub const WPN_E_DUPLICATE_REGISTRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420136));
pub const WPN_E_PUSH_NOTIFICATION_INCAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420135));
pub const WPN_E_DEV_ID_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420128));
pub const WPN_E_TAG_ALPHANUMERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420118));
pub const WPN_E_INVALID_HTTP_STATUS_CODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143420117));
pub const WPN_E_OUT_OF_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419904));
pub const WPN_E_POWER_SAVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419903));
pub const WPN_E_IMAGE_NOT_FOUND_IN_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419902));
pub const WPN_E_ALL_URL_NOT_COMPLETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419901));
pub const WPN_E_INVALID_CLOUD_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419900));
pub const WPN_E_NOTIFICATION_ID_MATCHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419899));
pub const WPN_E_CALLBACK_ALREADY_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419898));
pub const WPN_E_TOAST_NOTIFICATION_DROPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419897));
pub const WPN_E_STORAGE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419896));
pub const WPN_E_GROUP_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419895));
pub const WPN_E_GROUP_ALPHANUMERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419894));
pub const WPN_E_CLOUD_DISABLED_FOR_APP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143419893));
pub const E_MBN_CONTEXT_NOT_ACTIVATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945343));
pub const E_MBN_BAD_SIM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945342));
pub const E_MBN_DATA_CLASS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945341));
pub const E_MBN_INVALID_ACCESS_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945340));
pub const E_MBN_MAX_ACTIVATED_CONTEXTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945339));
pub const E_MBN_PACKET_SVC_DETACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945338));
pub const E_MBN_PROVIDER_NOT_VISIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945337));
pub const E_MBN_RADIO_POWER_OFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945336));
pub const E_MBN_SERVICE_NOT_ACTIVATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945335));
pub const E_MBN_SIM_NOT_INSERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945334));
pub const E_MBN_VOICE_CALL_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945333));
pub const E_MBN_INVALID_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945332));
pub const E_MBN_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945331));
pub const E_MBN_PROVIDERS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945330));
pub const E_MBN_PIN_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945329));
pub const E_MBN_PIN_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945328));
pub const E_MBN_PIN_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945327));
pub const E_MBN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945326));
pub const E_MBN_INVALID_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945320));
pub const E_MBN_DEFAULT_PROFILE_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945319));
pub const E_MBN_SMS_ENCODING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945312));
pub const E_MBN_SMS_FILTER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945311));
pub const E_MBN_SMS_INVALID_MEMORY_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945310));
pub const E_MBN_SMS_LANG_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945309));
pub const E_MBN_SMS_MEMORY_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945308));
pub const E_MBN_SMS_NETWORK_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945307));
pub const E_MBN_SMS_UNKNOWN_SMSC_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945306));
pub const E_MBN_SMS_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945305));
pub const E_MBN_SMS_OPERATION_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945304));
pub const E_MBN_SMS_MEMORY_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141945303));
pub const PEER_E_IPV6_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995583));
pub const PEER_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995582));
pub const PEER_E_CANNOT_START_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995581));
pub const PEER_E_NOT_LICENSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995580));
pub const PEER_E_INVALID_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995568));
pub const PEER_E_DBNAME_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995567));
pub const PEER_E_DUPLICATE_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995566));
pub const PEER_E_GRAPH_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995565));
pub const PEER_E_GRAPH_SHUTTING_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995564));
pub const PEER_E_GRAPH_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995563));
pub const PEER_E_INVALID_DATABASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995562));
pub const PEER_E_TOO_MANY_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995561));
pub const PEER_E_CONNECTION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995325));
pub const PEER_E_CONNECT_SELF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995322));
pub const PEER_E_ALREADY_LISTENING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995321));
pub const PEER_E_NODE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995320));
pub const PEER_E_CONNECTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995319));
pub const PEER_E_CONNECTION_NOT_AUTHENTICATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995318));
pub const PEER_E_CONNECTION_REFUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995317));
pub const PEER_E_CLASSIFIER_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995071));
pub const PEER_E_TOO_MANY_IDENTITIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995070));
pub const PEER_E_NO_KEY_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995069));
pub const PEER_E_GROUPS_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140995068));
pub const PEER_E_RECORD_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994815));
pub const PEER_E_DATABASE_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994814));
pub const PEER_E_DBINITIALIZATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994813));
pub const PEER_E_MAX_RECORD_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994812));
pub const PEER_E_DATABASE_ALREADY_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994811));
pub const PEER_E_DATABASE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994810));
pub const PEER_E_IDENTITY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994559));
pub const PEER_E_EVENT_HANDLE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994303));
pub const PEER_E_INVALID_SEARCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994047));
pub const PEER_E_INVALID_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140994046));
pub const PEER_E_INVITATION_NOT_TRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140993791));
pub const PEER_E_CHAIN_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140993789));
pub const PEER_E_INVALID_TIME_PERIOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140993787));
pub const PEER_E_CIRCULAR_CHAIN_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140993786));
pub const PEER_E_CERT_STORE_CORRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140993535));
pub const PEER_E_NO_CLOUD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140991487));
pub const PEER_E_CLOUD_NAME_AMBIGUOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140991483));
pub const PEER_E_INVALID_RECORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987376));
pub const PEER_E_NOT_AUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987360));
pub const PEER_E_PASSWORD_DOES_NOT_MEET_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987359));
pub const PEER_E_DEFERRED_VALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987344));
pub const PEER_E_INVALID_GROUP_PROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987328));
pub const PEER_E_INVALID_PEER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987312));
pub const PEER_E_INVALID_CLASSIFIER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987296));
pub const PEER_E_INVALID_FRIENDLY_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987280));
pub const PEER_E_INVALID_ROLE_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987279));
pub const PEER_E_INVALID_CLASSIFIER_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987278));
pub const PEER_E_INVALID_RECORD_EXPIRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987264));
pub const PEER_E_INVALID_CREDENTIAL_INFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987263));
pub const PEER_E_INVALID_CREDENTIAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987262));
pub const PEER_E_INVALID_RECORD_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987261));
pub const PEER_E_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987248));
pub const PEER_E_GROUP_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987247));
pub const PEER_E_GROUP_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987246));
pub const PEER_E_INVALID_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987245));
pub const PEER_E_NO_MEMBERS_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987244));
pub const PEER_E_NO_MEMBER_CONNECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987243));
pub const PEER_E_UNABLE_TO_LISTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987242));
pub const PEER_E_IDENTITY_DELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987232));
pub const PEER_E_SERVICE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140987231));
pub const PEER_E_CONTACT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140971007));
pub const PEER_S_GRAPH_DATA_CREATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6488065));
pub const PEER_S_NO_EVENT_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6488066));
pub const PEER_S_ALREADY_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6496256));
pub const PEER_S_SUBSCRIPTION_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6512640));
pub const PEER_S_NO_CONNECTIVITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6488069));
pub const PEER_S_ALREADY_A_MEMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6488070));
pub const PEER_E_CANNOT_CONVERT_PEER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140979199));
pub const PEER_E_INVALID_PEER_HOST_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140979198));
pub const PEER_E_NO_MORE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140979197));
pub const PEER_E_PNRP_DUPLICATE_PEER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140979195));
pub const PEER_E_INVITE_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966912));
pub const PEER_E_INVITE_RESPONSE_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966911));
pub const PEER_E_NOT_SIGNED_IN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966909));
pub const PEER_E_PRIVACY_DECLINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966908));
pub const PEER_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966907));
pub const PEER_E_INVALID_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966905));
pub const PEER_E_FW_EXCEPTION_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966904));
pub const PEER_E_FW_BLOCKED_BY_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966903));
pub const PEER_E_FW_BLOCKED_BY_SHIELDS_UP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966902));
pub const PEER_E_FW_DECLINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140966901));
pub const UI_E_CREATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731135));
pub const UI_E_SHUTDOWN_CALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731134));
pub const UI_E_ILLEGAL_REENTRANCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731133));
pub const UI_E_OBJECT_SEALED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731132));
pub const UI_E_VALUE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731131));
pub const UI_E_VALUE_NOT_DETERMINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731130));
pub const UI_E_INVALID_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731129));
pub const UI_E_BOOLEAN_EXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731128));
pub const UI_E_DIFFERENT_OWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731127));
pub const UI_E_AMBIGUOUS_MATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731126));
pub const UI_E_FP_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731125));
pub const UI_E_WRONG_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144731124));
pub const UI_E_STORYBOARD_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730879));
pub const UI_E_STORYBOARD_NOT_PLAYING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730878));
pub const UI_E_START_KEYFRAME_AFTER_END = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730877));
pub const UI_E_END_KEYFRAME_NOT_DETERMINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730876));
pub const UI_E_LOOPS_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730875));
pub const UI_E_TRANSITION_ALREADY_USED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730874));
pub const UI_E_TRANSITION_NOT_IN_STORYBOARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730873));
pub const UI_E_TRANSITION_ECLIPSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730872));
pub const UI_E_TIME_BEFORE_LAST_UPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730871));
pub const UI_E_TIMER_CLIENT_ALREADY_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730870));
pub const UI_E_INVALID_DIMENSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730869));
pub const UI_E_PRIMITIVE_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730868));
pub const UI_E_WINDOW_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144730623));
pub const E_BLUETOOTH_ATT_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864511));
pub const E_BLUETOOTH_ATT_READ_NOT_PERMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864510));
pub const E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864509));
pub const E_BLUETOOTH_ATT_INVALID_PDU = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864508));
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864507));
pub const E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864506));
pub const E_BLUETOOTH_ATT_INVALID_OFFSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864505));
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864504));
pub const E_BLUETOOTH_ATT_PREPARE_QUEUE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864503));
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864502));
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864501));
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864500));
pub const E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864499));
pub const E_BLUETOOTH_ATT_UNLIKELY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864498));
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864497));
pub const E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864496));
pub const E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140864495));
pub const E_BLUETOOTH_ATT_UNKNOWN_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140860416));
pub const E_AUDIO_ENGINE_NODE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140798975));
pub const E_HDAUDIO_EMPTY_CONNECTION_LIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140798974));
pub const E_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140798973));
pub const E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140798972));
pub const E_HDAUDIO_NULL_LINKED_LIST_ENTRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140798971));
pub const STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733439));
pub const STATEREPOSITORY_E_STATEMENT_INPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733438));
pub const STATEREPOSITORY_E_CONFIGURATION_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733437));
pub const STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733436));
pub const STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733435));
pub const STATEREPOSITORY_E_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733434));
pub const STATEREPOSITORY_E_BUSY_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733433));
pub const STATEREPOSITORY_E_BUSY_RECOVERY_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733432));
pub const STATEREPOSITORY_E_LOCKED_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733431));
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733430));
pub const STATEREPOSITORY_E_TRANSACTION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733429));
pub const STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733428));
pub const STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733427));
pub const STATEREPOSITORY_E_LOCKED_TIMEOUT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733426));
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733425));
pub const STATEREPOSITORY_E_SERVICE_STOP_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733424));
pub const STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733423));
pub const STATEREPOSITORY_ERROR_CACHE_CORRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2140733422));
pub const STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6750227));
pub const STATEREPOSITORY_TRANSACTION_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 6750228));
pub const ERROR_SPACES_POOL_WAS_DELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 15138817));
pub const ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344831));
pub const ERROR_SPACES_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344830));
pub const ERROR_SPACES_RESILIENCY_TYPE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344829));
pub const ERROR_SPACES_DRIVE_SECTOR_SIZE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344828));
pub const ERROR_SPACES_DRIVE_REDUNDANCY_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344826));
pub const ERROR_SPACES_NUMBER_OF_DATA_COPIES_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344825));
pub const ERROR_SPACES_PARITY_LAYOUT_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344824));
pub const ERROR_SPACES_INTERLEAVE_LENGTH_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344823));
pub const ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344822));
pub const ERROR_SPACES_NOT_ENOUGH_DRIVES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344821));
pub const ERROR_SPACES_EXTENDED_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344820));
pub const ERROR_SPACES_PROVISIONING_TYPE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344819));
pub const ERROR_SPACES_ALLOCATION_SIZE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344818));
pub const ERROR_SPACES_ENCLOSURE_AWARE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344817));
pub const ERROR_SPACES_WRITE_CACHE_SIZE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344816));
pub const ERROR_SPACES_NUMBER_OF_GROUPS_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344815));
pub const ERROR_SPACES_DRIVE_OPERATIONAL_STATE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344814));
pub const ERROR_SPACES_ENTRY_INCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344813));
pub const ERROR_SPACES_ENTRY_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2132344812));
pub const ERROR_VOLSNAP_BOOTFILE_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138963967));
pub const ERROR_VOLSNAP_ACTIVATION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138963966));
pub const ERROR_TIERING_NOT_SUPPORTED_ON_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898431));
pub const ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898430));
pub const ERROR_TIERING_STORAGE_TIER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898429));
pub const ERROR_TIERING_INVALID_FILE_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898428));
pub const ERROR_TIERING_WRONG_CLUSTER_NODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898427));
pub const ERROR_TIERING_ALREADY_PROCESSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898426));
pub const ERROR_TIERING_CANNOT_PIN_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898425));
pub const ERROR_TIERING_FILE_IS_NOT_PINNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898424));
pub const ERROR_NOT_A_TIERED_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898423));
pub const ERROR_ATTRIBUTE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138898422));
pub const ERROR_SECCORE_INVALID_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058537472));
pub const ERROR_NO_APPLICABLE_APP_LICENSES_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406399));
pub const ERROR_CLIP_LICENSE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406398));
pub const ERROR_CLIP_DEVICE_LICENSE_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406397));
pub const ERROR_CLIP_LICENSE_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406396));
pub const ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406395));
pub const ERROR_CLIP_LICENSE_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406394));
pub const ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406393));
pub const ERROR_CLIP_LICENSE_NOT_SIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406392));
pub const ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406391));
pub const ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1058406390));
pub const DXGI_STATUS_OCCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213121));
pub const DXGI_STATUS_CLIPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213122));
pub const DXGI_STATUS_NO_REDIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213124));
pub const DXGI_STATUS_NO_DESKTOP_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213125));
pub const DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213126));
pub const DXGI_STATUS_MODE_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213127));
pub const DXGI_STATUS_MODE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213128));
pub const DXCORE_ERROR_EVENT_NOT_UNREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004877311));
pub const DXGI_STATUS_UNOCCLUDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213129));
pub const DXGI_STATUS_DDA_WAS_STILL_DRAWING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213130));
pub const DXGI_STATUS_PRESENT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 142213167));
pub const DXGI_DDI_ERR_WASSTILLDRAWING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005204991));
pub const DXGI_DDI_ERR_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005204990));
pub const DXGI_DDI_ERR_NONEXCLUSIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005204989));
pub const D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005336063));
pub const D3D10_ERROR_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005336062));
pub const D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005139455));
pub const D3D11_ERROR_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005139454));
pub const D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005139453));
pub const D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005139452));
pub const D3D12_ERROR_ADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005008383));
pub const D3D12_ERROR_DRIVER_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2005008382));
pub const D2DERR_WRONG_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238911));
pub const D2DERR_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238910));
pub const D2DERR_UNSUPPORTED_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238909));
pub const D2DERR_SCANNER_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238908));
pub const D2DERR_SCREEN_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238907));
pub const D2DERR_DISPLAY_STATE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238906));
pub const D2DERR_ZERO_VECTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238905));
pub const D2DERR_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238904));
pub const D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238903));
pub const D2DERR_INVALID_CALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238902));
pub const D2DERR_NO_HARDWARE_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238901));
pub const D2DERR_RECREATE_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238900));
pub const D2DERR_TOO_MANY_SHADER_ELEMENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238899));
pub const D2DERR_SHADER_COMPILE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238898));
pub const D2DERR_MAX_TEXTURE_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238897));
pub const D2DERR_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238896));
pub const D2DERR_BAD_NUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238895));
pub const D2DERR_WRONG_FACTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238894));
pub const D2DERR_LAYER_ALREADY_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238893));
pub const D2DERR_POP_CALL_DID_NOT_MATCH_PUSH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238892));
pub const D2DERR_WRONG_RESOURCE_DOMAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238891));
pub const D2DERR_PUSH_POP_UNBALANCED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238890));
pub const D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238889));
pub const D2DERR_INCOMPATIBLE_BRUSH_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238888));
pub const D2DERR_WIN32_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238887));
pub const D2DERR_TARGET_NOT_GDI_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238886));
pub const D2DERR_TEXT_EFFECT_IS_WRONG_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238885));
pub const D2DERR_TEXT_RENDERER_NOT_RELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238884));
pub const D2DERR_EXCEEDS_MAX_BITMAP_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238883));
pub const D2DERR_INVALID_GRAPH_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238882));
pub const D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238881));
pub const D2DERR_CYCLIC_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238880));
pub const D2DERR_BITMAP_CANNOT_DRAW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238879));
pub const D2DERR_OUTSTANDING_BITMAP_REFERENCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238878));
pub const D2DERR_ORIGINAL_TARGET_NOT_BOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238877));
pub const D2DERR_INVALID_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238876));
pub const D2DERR_BITMAP_BOUND_AS_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238875));
pub const D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238874));
pub const D2DERR_INTERMEDIATE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238873));
pub const D2DERR_EFFECT_IS_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238872));
pub const D2DERR_INVALID_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238871));
pub const D2DERR_NO_SUBPROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238870));
pub const D2DERR_PRINT_JOB_CLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238869));
pub const D2DERR_PRINT_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238868));
pub const D2DERR_TOO_MANY_TRANSFORM_INPUTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238867));
pub const D2DERR_INVALID_GLYPH_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003238866));
pub const DWRITE_E_FILEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283968));
pub const DWRITE_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283967));
pub const DWRITE_E_NOFONT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283966));
pub const DWRITE_E_FILENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283965));
pub const DWRITE_E_FILEACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283964));
pub const DWRITE_E_FONTCOLLECTIONOBSOLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283963));
pub const DWRITE_E_ALREADYREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283962));
pub const DWRITE_E_CACHEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283961));
pub const DWRITE_E_CACHEVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283960));
pub const DWRITE_E_UNSUPPORTEDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283959));
pub const DWRITE_E_TEXTRENDERERINCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283958));
pub const DWRITE_E_FLOWDIRECTIONCONFLICTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283957));
pub const DWRITE_E_NOCOLOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283956));
pub const DWRITE_E_REMOTEFONT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283955));
pub const DWRITE_E_DOWNLOADCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283954));
pub const DWRITE_E_DOWNLOADFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283953));
pub const DWRITE_E_TOOMANYDOWNLOADS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003283952));
pub const WINCODEC_ERR_WRONGSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292412));
pub const WINCODEC_ERR_VALUEOUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292411));
pub const WINCODEC_ERR_UNKNOWNIMAGEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292409));
pub const WINCODEC_ERR_UNSUPPORTEDVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292405));
pub const WINCODEC_ERR_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292404));
pub const WINCODEC_ERR_ALREADYLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292403));
pub const WINCODEC_ERR_PROPERTYNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292352));
pub const WINCODEC_ERR_PROPERTYNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292351));
pub const WINCODEC_ERR_PROPERTYSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292350));
pub const WINCODEC_ERR_CODECPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292349));
pub const WINCODEC_ERR_CODECNOTHUMBNAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292348));
pub const WINCODEC_ERR_PALETTEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292347));
pub const WINCODEC_ERR_CODECTOOMANYSCANLINES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292346));
pub const WINCODEC_ERR_INTERNALERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292344));
pub const WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292343));
pub const WINCODEC_ERR_COMPONENTNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292336));
pub const WINCODEC_ERR_IMAGESIZEOUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292335));
pub const WINCODEC_ERR_TOOMUCHMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292334));
pub const WINCODEC_ERR_BADIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292320));
pub const WINCODEC_ERR_BADHEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292319));
pub const WINCODEC_ERR_FRAMEMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292318));
pub const WINCODEC_ERR_BADMETADATAHEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292317));
pub const WINCODEC_ERR_BADSTREAMDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292304));
pub const WINCODEC_ERR_STREAMWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292303));
pub const WINCODEC_ERR_STREAMREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292302));
pub const WINCODEC_ERR_STREAMNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292301));
pub const WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292288));
pub const WINCODEC_ERR_UNSUPPORTEDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292287));
pub const WINCODEC_ERR_INVALIDREGISTRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292278));
pub const WINCODEC_ERR_COMPONENTINITIALIZEFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292277));
pub const WINCODEC_ERR_INSUFFICIENTBUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292276));
pub const WINCODEC_ERR_DUPLICATEMETADATAPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292275));
pub const WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292274));
pub const WINCODEC_ERR_UNEXPECTEDSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292273));
pub const WINCODEC_ERR_INVALIDQUERYREQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292272));
pub const WINCODEC_ERR_UNEXPECTEDMETADATATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292271));
pub const WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292270));
pub const WINCODEC_ERR_INVALIDQUERYCHARACTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292269));
pub const WINCODEC_ERR_WIN32ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292268));
pub const WINCODEC_ERR_INVALIDPROGRESSIVELEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292267));
pub const WINCODEC_ERR_INVALIDJPEGSCANINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003292266));
pub const MILERR_OBJECTBUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304447));
pub const MILERR_INSUFFICIENTBUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304446));
pub const MILERR_WIN32ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304445));
pub const MILERR_SCANNER_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304444));
pub const MILERR_SCREENACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304443));
pub const MILERR_DISPLAYSTATEINVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304442));
pub const MILERR_NONINVERTIBLEMATRIX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304441));
pub const MILERR_ZEROVECTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304440));
pub const MILERR_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304439));
pub const MILERR_BADNUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304438));
pub const MILERR_INTERNALERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304320));
pub const MILERR_DISPLAYFORMATNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304316));
pub const MILERR_INVALIDCALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304315));
pub const MILERR_ALREADYLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304314));
pub const MILERR_NOTLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304313));
pub const MILERR_DEVICECANNOTRENDERTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304312));
pub const MILERR_GLYPHBITMAPMISSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304311));
pub const MILERR_MALFORMEDGLYPHCACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304310));
pub const MILERR_GENERIC_IGNORE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304309));
pub const MILERR_MALFORMED_GUIDELINE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304308));
pub const MILERR_NO_HARDWARE_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304307));
pub const MILERR_NEED_RECREATE_AND_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304306));
pub const MILERR_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304305));
pub const MILERR_MISMATCHED_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304304));
pub const MILERR_NO_REDIRECTION_SURFACE_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304303));
pub const MILERR_REMOTING_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304302));
pub const MILERR_QUEUED_PRESENT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304301));
pub const MILERR_NOT_QUEUING_PRESENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304300));
pub const MILERR_NO_REDIRECTION_SURFACE_RETRY_LATER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304299));
pub const MILERR_TOOMANYSHADERELEMNTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304298));
pub const MILERR_MROW_READLOCK_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304297));
pub const MILERR_MROW_UPDATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304296));
pub const MILERR_SHADER_COMPILE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304295));
pub const MILERR_MAX_TEXTURE_SIZE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304294));
pub const MILERR_QPC_TIME_WENT_BACKWARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304293));
pub const MILERR_DXGI_ENUMERATION_OUT_OF_SYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304291));
pub const MILERR_ADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304290));
pub const MILERR_COLORSPACE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304289));
pub const MILERR_PREFILTER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304288));
pub const MILERR_DISPLAYID_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003304287));
pub const UCEERR_INVALIDPACKETHEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303424));
pub const UCEERR_UNKNOWNPACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303423));
pub const UCEERR_ILLEGALPACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303422));
pub const UCEERR_MALFORMEDPACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303421));
pub const UCEERR_ILLEGALHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303420));
pub const UCEERR_HANDLELOOKUPFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303419));
pub const UCEERR_RENDERTHREADFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303418));
pub const UCEERR_CTXSTACKFRSTTARGETNULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303417));
pub const UCEERR_CONNECTIONIDLOOKUPFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303416));
pub const UCEERR_BLOCKSFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303415));
pub const UCEERR_MEMORYFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303414));
pub const UCEERR_PACKETRECORDOUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303413));
pub const UCEERR_ILLEGALRECORDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303412));
pub const UCEERR_OUTOFHANDLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303411));
pub const UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303410));
pub const UCEERR_NO_MULTIPLE_WORKER_THREADS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303409));
pub const UCEERR_REMOTINGNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303408));
pub const UCEERR_MISSINGENDCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303407));
pub const UCEERR_MISSINGBEGINCOMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303406));
pub const UCEERR_CHANNELSYNCTIMEDOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303405));
pub const UCEERR_CHANNELSYNCABANDONED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303404));
pub const UCEERR_UNSUPPORTEDTRANSPORTVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303403));
pub const UCEERR_TRANSPORTUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303402));
pub const UCEERR_FEEDBACK_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303401));
pub const UCEERR_COMMANDTRANSPORTDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303400));
pub const UCEERR_GRAPHICSSTREAMUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303399));
pub const UCEERR_GRAPHICSSTREAMALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303392));
pub const UCEERR_TRANSPORTDISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303391));
pub const UCEERR_TRANSPORTOVERLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303390));
pub const UCEERR_PARTITION_ZOMBIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303389));
pub const MILAVERR_NOCLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303168));
pub const MILAVERR_NOMEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303167));
pub const MILAVERR_NOVIDEOMIXER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303166));
pub const MILAVERR_NOVIDEOPRESENTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303165));
pub const MILAVERR_NOREADYFRAMES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303164));
pub const MILAVERR_MODULENOTLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303163));
pub const MILAVERR_WMPFACTORYNOTREGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303162));
pub const MILAVERR_INVALIDWMPVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303161));
pub const MILAVERR_INSUFFICIENTVIDEORESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303160));
pub const MILAVERR_VIDEOACCELERATIONNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303159));
pub const MILAVERR_REQUESTEDTEXTURETOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303158));
pub const MILAVERR_SEEKFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303157));
pub const MILAVERR_UNEXPECTEDWMPFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303156));
pub const MILAVERR_MEDIAPLAYERCLOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303155));
pub const MILAVERR_UNKNOWNHARDWAREERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003303154));
pub const MILEFFECTSERR_UNKNOWNPROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302898));
pub const MILEFFECTSERR_EFFECTNOTPARTOFGROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302897));
pub const MILEFFECTSERR_NOINPUTSOURCEATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302896));
pub const MILEFFECTSERR_CONNECTORNOTCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302895));
pub const MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302894));
pub const MILEFFECTSERR_RESERVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302893));
pub const MILEFFECTSERR_CYCLEDETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302892));
pub const MILEFFECTSERR_EFFECTINMORETHANONEGRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302891));
pub const MILEFFECTSERR_EFFECTALREADYINAGRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302890));
pub const MILEFFECTSERR_EFFECTHASNOCHILDREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302889));
pub const MILEFFECTSERR_ALREADYATTACHEDTOLISTENER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302888));
pub const MILEFFECTSERR_NOTAFFINETRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302887));
pub const MILEFFECTSERR_EMPTYBOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302886));
pub const MILEFFECTSERR_OUTPUTSIZETOOLARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302885));
pub const DWMERR_STATE_TRANSITION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302656));
pub const DWMERR_THEME_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302655));
pub const DWMERR_CATASTROPHIC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302654));
pub const DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302400));
pub const DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302399));
pub const DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003302398));
pub const ONL_E_INVALID_AUTHENTICATION_TARGET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701823));
pub const ONL_E_ACCESS_DENIED_BY_TOU = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701822));
pub const ONL_E_INVALID_APPLICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701821));
pub const ONL_E_PASSWORD_UPDATE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701820));
pub const ONL_E_ACCOUNT_UPDATE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701819));
pub const ONL_E_FORCESIGNIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701818));
pub const ONL_E_ACCOUNT_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701817));
pub const ONL_E_PARENTAL_CONSENT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701816));
pub const ONL_E_EMAIL_VERIFICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701815));
pub const ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701814));
pub const ONL_E_ACCOUNT_SUSPENDED_ABUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701813));
pub const ONL_E_ACTION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701812));
pub const ONL_CONNECTION_COUNT_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701811));
pub const ONL_E_CONNECTED_ACCOUNT_CAN_NOT_SIGNOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701810));
pub const ONL_E_USER_AUTHENTICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701809));
pub const ONL_E_REQUEST_THROTTLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2138701808));
pub const FA_E_MAX_PERSISTED_ITEMS_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927200));
pub const FA_E_HOMEGROUP_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927198));
pub const E_MONITOR_RESOLUTION_TOO_LOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927152));
pub const E_ELEVATED_ACTIVATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927151));
pub const E_UAC_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927150));
pub const E_FULL_ADMIN_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927149));
pub const E_APPLICATION_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927148));
pub const E_MULTIPLE_EXTENSIONS_FOR_APPLICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927147));
pub const E_MULTIPLE_PACKAGES_FOR_FAMILY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927146));
pub const E_APPLICATION_MANAGER_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927145));
pub const S_STORE_LAUNCHED_FOR_REMEDIATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2556504));
pub const S_APPLICATION_ACTIVATION_ERROR_HANDLED_BY_DIALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2556505));
pub const E_APPLICATION_ACTIVATION_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927142));
pub const E_APPLICATION_ACTIVATION_EXEC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927141));
pub const E_APPLICATION_TEMPORARY_LICENSE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927140));
pub const E_APPLICATION_TRIAL_LICENSE_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927139));
pub const E_SKYDRIVE_ROOT_TARGET_FILE_SYSTEM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927136));
pub const E_SKYDRIVE_ROOT_TARGET_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927135));
pub const E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927134));
pub const E_SKYDRIVE_FILE_NOT_UPLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927133));
pub const E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927132));
pub const E_SKYDRIVE_ROOT_TARGET_VOLUME_ROOT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927131));
pub const E_SYNCENGINE_FILE_SIZE_OVER_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089791));
pub const E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089790));
pub const E_SYNCENGINE_UNSUPPORTED_FILE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089789));
pub const E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089788));
pub const E_SYNCENGINE_FILE_SYNC_PARTNER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089787));
pub const E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013089786));
pub const E_SYNCENGINE_FILE_IDENTIFIER_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085694));
pub const E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085693));
pub const E_SYNCENGINE_UNKNOWN_SERVICE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085692));
pub const E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085691));
pub const E_SYNCENGINE_REQUEST_BLOCKED_BY_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085690));
pub const E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013085689));
pub const E_SYNCENGINE_FOLDER_INACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081599));
pub const E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081598));
pub const E_SYNCENGINE_UNSUPPORTED_MARKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081597));
pub const E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081596));
pub const E_SYNCENGINE_REMOTE_PATH_LENGTH_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081595));
pub const E_SYNCENGINE_CLIENT_UPDATE_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081594));
pub const E_SYNCENGINE_PROXY_AUTHENTICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081593));
pub const E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081592));
pub const E_SYNCENGINE_UNSUPPORTED_REPARSE_POINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081591));
pub const E_SYNCENGINE_STORAGE_SERVICE_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081590));
pub const E_SYNCENGINE_FOLDER_IN_REDIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013081589));
pub const EAS_E_POLICY_NOT_MANAGED_BY_OS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913087));
pub const EAS_E_POLICY_COMPLIANT_WITH_ACTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913086));
pub const EAS_E_REQUESTED_POLICY_NOT_ENFORCEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913085));
pub const EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913084));
pub const EAS_E_REQUESTED_POLICY_PASSWORD_EXPIRATION_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913083));
pub const EAS_E_USER_CANNOT_CHANGE_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913082));
pub const EAS_E_ADMINS_HAVE_BLANK_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913081));
pub const EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913080));
pub const EAS_E_LOCAL_CONTROLLED_USERS_CANNOT_CHANGE_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913079));
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913078));
pub const EAS_E_CONNECTED_ADMINS_NEED_TO_CHANGE_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913077));
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913076));
pub const EAS_E_CURRENT_CONNECTED_USER_NEED_TO_CHANGE_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2141913075));
pub const WEB_E_UNSUPPORTED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484287));
pub const WEB_E_INVALID_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484286));
pub const WEB_E_MISSING_REQUIRED_ELEMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484285));
pub const WEB_E_MISSING_REQUIRED_ATTRIBUTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484284));
pub const WEB_E_UNEXPECTED_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484283));
pub const WEB_E_RESOURCE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484282));
pub const WEB_E_INVALID_JSON_STRING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484281));
pub const WEB_E_INVALID_JSON_NUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484280));
pub const WEB_E_JSON_VALUE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089484279));
pub const HTTP_E_STATUS_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145845247));
pub const HTTP_E_STATUS_UNEXPECTED_REDIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145845245));
pub const HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145845244));
pub const HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145845243));
pub const HTTP_E_STATUS_AMBIGUOUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844948));
pub const HTTP_E_STATUS_MOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844947));
pub const HTTP_E_STATUS_REDIRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844946));
pub const HTTP_E_STATUS_REDIRECT_METHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844945));
pub const HTTP_E_STATUS_NOT_MODIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844944));
pub const HTTP_E_STATUS_USE_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844943));
pub const HTTP_E_STATUS_REDIRECT_KEEP_VERB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844941));
pub const HTTP_E_STATUS_BAD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844848));
pub const HTTP_E_STATUS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844847));
pub const HTTP_E_STATUS_PAYMENT_REQ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844846));
pub const HTTP_E_STATUS_FORBIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844845));
pub const HTTP_E_STATUS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844844));
pub const HTTP_E_STATUS_BAD_METHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844843));
pub const HTTP_E_STATUS_NONE_ACCEPTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844842));
pub const HTTP_E_STATUS_PROXY_AUTH_REQ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844841));
pub const HTTP_E_STATUS_REQUEST_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844840));
pub const HTTP_E_STATUS_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844839));
pub const HTTP_E_STATUS_GONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844838));
pub const HTTP_E_STATUS_LENGTH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844837));
pub const HTTP_E_STATUS_PRECOND_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844836));
pub const HTTP_E_STATUS_REQUEST_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844835));
pub const HTTP_E_STATUS_URI_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844834));
pub const HTTP_E_STATUS_UNSUPPORTED_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844833));
pub const HTTP_E_STATUS_RANGE_NOT_SATISFIABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844832));
pub const HTTP_E_STATUS_EXPECTATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844831));
pub const HTTP_E_STATUS_SERVER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844748));
pub const HTTP_E_STATUS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844747));
pub const HTTP_E_STATUS_BAD_GATEWAY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844746));
pub const HTTP_E_STATUS_SERVICE_UNAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844745));
pub const HTTP_E_STATUS_GATEWAY_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844744));
pub const HTTP_E_STATUS_VERSION_NOT_SUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145844743));
pub const E_INVALID_PROTOCOL_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089418751));
pub const E_INVALID_PROTOCOL_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089418750));
pub const E_PROTOCOL_EXTENSIONS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089418749));
pub const E_SUBPROTOCOL_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089418748));
pub const E_PROTOCOL_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2089418747));
pub const INPUT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289344));
pub const INPUT_E_REENTRANCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289343));
pub const INPUT_E_MULTIMODAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289342));
pub const INPUT_E_PACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289341));
pub const INPUT_E_FRAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289340));
pub const INPUT_E_HISTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289339));
pub const INPUT_E_DEVICE_INFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289338));
pub const INPUT_E_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289337));
pub const INPUT_E_DEVICE_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143289336));
pub const INET_E_INVALID_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697214));
pub const INET_E_NO_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697213));
pub const INET_E_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697212));
pub const INET_E_RESOURCE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697211));
pub const INET_E_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697210));
pub const INET_E_DATA_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697209));
pub const INET_E_DOWNLOAD_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697208));
pub const INET_E_AUTHENTICATION_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697207));
pub const INET_E_NO_VALID_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697206));
pub const INET_E_CONNECTION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697205));
pub const INET_E_INVALID_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697204));
pub const INET_E_UNKNOWN_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697203));
pub const INET_E_SECURITY_PROBLEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697202));
pub const INET_E_CANNOT_LOAD_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697201));
pub const INET_E_CANNOT_INSTANTIATE_OBJECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697200));
pub const INET_E_INVALID_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697191));
pub const INET_E_REDIRECT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697196));
pub const INET_E_REDIRECT_TO_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146697195));
pub const ERROR_DBG_CREATE_PROCESS_FAILURE_LOCKDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2135949311));
pub const ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2135949310));
pub const ERROR_DBG_CONNECT_SERVER_FAILURE_LOCKDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2135949309));
pub const ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2135949308));
pub const ERROR_IO_PREEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1996423167));
pub const JSCRIPT_E_CANTEXECUTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1996357631));
pub const WEP_E_NOT_PROVISIONED_ON_ALL_VOLUMES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200383));
pub const WEP_E_FIXED_DATA_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200382));
pub const WEP_E_HARDWARE_NOT_COMPLIANT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200381));
pub const WEP_E_LOCK_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200380));
pub const WEP_E_PROTECTION_SUSPENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200379));
pub const WEP_E_NO_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200378));
pub const WEP_E_OS_NOT_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200377));
pub const WEP_E_UNEXPECTED_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200376));
pub const WEP_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2013200375));
pub const ERROR_SVHDX_ERROR_STORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067712512));
pub const ERROR_SVHDX_ERROR_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647232));
pub const ERROR_SVHDX_UNIT_ATTENTION_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647231));
pub const ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647230));
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647229));
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647228));
pub const ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647227));
pub const ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647226));
pub const ERROR_SVHDX_RESERVATION_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647225));
pub const ERROR_SVHDX_WRONG_FILE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647224));
pub const ERROR_SVHDX_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647223));
pub const ERROR_VHD_SHARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647222));
pub const ERROR_SVHDX_NO_INITIATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647221));
pub const ERROR_VHDSET_BACKING_STORAGE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067647220));
pub const ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067646976));
pub const ERROR_SMB_BAD_CLUSTER_DIALECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1067646975));
pub const WININET_E_OUT_OF_HANDLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012895));
pub const WININET_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012894));
pub const WININET_E_EXTENDED_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012893));
pub const WININET_E_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012892));
pub const WININET_E_INVALID_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012891));
pub const WININET_E_UNRECOGNIZED_SCHEME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012890));
pub const WININET_E_NAME_NOT_RESOLVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012889));
pub const WININET_E_PROTOCOL_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012888));
pub const WININET_E_INVALID_OPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012887));
pub const WININET_E_BAD_OPTION_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012886));
pub const WININET_E_OPTION_NOT_SETTABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012885));
pub const WININET_E_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012884));
pub const WININET_E_INCORRECT_USER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012883));
pub const WININET_E_INCORRECT_PASSWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012882));
pub const WININET_E_LOGIN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012881));
pub const WININET_E_INVALID_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012880));
pub const WININET_E_OPERATION_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012879));
pub const WININET_E_INCORRECT_HANDLE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012878));
pub const WININET_E_INCORRECT_HANDLE_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012877));
pub const WININET_E_NOT_PROXY_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012876));
pub const WININET_E_REGISTRY_VALUE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012875));
pub const WININET_E_BAD_REGISTRY_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012874));
pub const WININET_E_NO_DIRECT_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012873));
pub const WININET_E_NO_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012872));
pub const WININET_E_NO_CALLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012871));
pub const WININET_E_REQUEST_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012870));
pub const WININET_E_INCORRECT_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012869));
pub const WININET_E_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012868));
pub const WININET_E_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012867));
pub const WININET_E_CONNECTION_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012866));
pub const WININET_E_CONNECTION_RESET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012865));
pub const WININET_E_FORCE_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012864));
pub const WININET_E_INVALID_PROXY_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012863));
pub const WININET_E_NEED_UI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012862));
pub const WININET_E_HANDLE_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012860));
pub const WININET_E_SEC_CERT_DATE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012859));
pub const WININET_E_SEC_CERT_CN_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012858));
pub const WININET_E_HTTP_TO_HTTPS_ON_REDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012857));
pub const WININET_E_HTTPS_TO_HTTP_ON_REDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012856));
pub const WININET_E_MIXED_SECURITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012855));
pub const WININET_E_CHG_POST_IS_NON_SECURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012854));
pub const WININET_E_POST_IS_NON_SECURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012853));
pub const WININET_E_CLIENT_AUTH_CERT_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012852));
pub const WININET_E_INVALID_CA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012851));
pub const WININET_E_CLIENT_AUTH_NOT_SETUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012850));
pub const WININET_E_ASYNC_THREAD_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012849));
pub const WININET_E_REDIRECT_SCHEME_CHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012848));
pub const WININET_E_DIALOG_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012847));
pub const WININET_E_RETRY_DIALOG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012846));
pub const WININET_E_NO_NEW_CONTAINERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012845));
pub const WININET_E_HTTPS_HTTP_SUBMIT_REDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012844));
pub const WININET_E_SEC_CERT_ERRORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012841));
pub const WININET_E_SEC_CERT_REV_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012839));
pub const WININET_E_HEADER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012746));
pub const WININET_E_DOWNLEVEL_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012745));
pub const WININET_E_INVALID_SERVER_RESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012744));
pub const WININET_E_INVALID_HEADER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012743));
pub const WININET_E_INVALID_QUERY_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012742));
pub const WININET_E_HEADER_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012741));
pub const WININET_E_REDIRECT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012740));
pub const WININET_E_SECURITY_CHANNEL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012739));
pub const WININET_E_UNABLE_TO_CACHE_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012738));
pub const WININET_E_TCPIP_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012737));
pub const WININET_E_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012733));
pub const WININET_E_SERVER_UNREACHABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012732));
pub const WININET_E_PROXY_SERVER_UNREACHABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012731));
pub const WININET_E_BAD_AUTO_PROXY_SCRIPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012730));
pub const WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012729));
pub const WININET_E_SEC_INVALID_CERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012727));
pub const WININET_E_SEC_CERT_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012726));
pub const WININET_E_FAILED_DUETOSECURITYCHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012725));
pub const WININET_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012724));
pub const WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012722));
pub const WININET_E_DECODING_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012721));
pub const WININET_E_NOT_REDIRECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012736));
pub const WININET_E_COOKIE_NEEDS_CONFIRMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012735));
pub const WININET_E_COOKIE_DECLINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012734));
pub const WININET_E_REDIRECT_NEEDS_CONFIRMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147012728));
pub const SQLITE_E_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574335));
pub const SQLITE_E_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574334));
pub const SQLITE_E_PERM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574333));
pub const SQLITE_E_ABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574332));
pub const SQLITE_E_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574331));
pub const SQLITE_E_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574330));
pub const SQLITE_E_NOMEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574329));
pub const SQLITE_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574328));
pub const SQLITE_E_INTERRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574327));
pub const SQLITE_E_IOERR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574326));
pub const SQLITE_E_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574325));
pub const SQLITE_E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574324));
pub const SQLITE_E_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574323));
pub const SQLITE_E_CANTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574322));
pub const SQLITE_E_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574321));
pub const SQLITE_E_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574320));
pub const SQLITE_E_SCHEMA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574319));
pub const SQLITE_E_TOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574318));
pub const SQLITE_E_CONSTRAINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574317));
pub const SQLITE_E_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574316));
pub const SQLITE_E_MISUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574315));
pub const SQLITE_E_NOLFS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574314));
pub const SQLITE_E_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574313));
pub const SQLITE_E_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574312));
pub const SQLITE_E_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574311));
pub const SQLITE_E_NOTADB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574310));
pub const SQLITE_E_NOTICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574309));
pub const SQLITE_E_WARNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574308));
pub const SQLITE_E_ROW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574236));
pub const SQLITE_E_DONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574235));
pub const SQLITE_E_IOERR_READ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574070));
pub const SQLITE_E_IOERR_SHORT_READ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573814));
pub const SQLITE_E_IOERR_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573558));
pub const SQLITE_E_IOERR_FSYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573302));
pub const SQLITE_E_IOERR_DIR_FSYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573046));
pub const SQLITE_E_IOERR_TRUNCATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572790));
pub const SQLITE_E_IOERR_FSTAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572534));
pub const SQLITE_E_IOERR_UNLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572278));
pub const SQLITE_E_IOERR_RDLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572022));
pub const SQLITE_E_IOERR_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018571766));
pub const SQLITE_E_IOERR_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018571510));
pub const SQLITE_E_IOERR_NOMEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018571254));
pub const SQLITE_E_IOERR_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018570998));
pub const SQLITE_E_IOERR_CHECKRESERVEDLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018570742));
pub const SQLITE_E_IOERR_LOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018570486));
pub const SQLITE_E_IOERR_CLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018570230));
pub const SQLITE_E_IOERR_DIR_CLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018569974));
pub const SQLITE_E_IOERR_SHMOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018569718));
pub const SQLITE_E_IOERR_SHMSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018569462));
pub const SQLITE_E_IOERR_SHMLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018569206));
pub const SQLITE_E_IOERR_SHMMAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018568950));
pub const SQLITE_E_IOERR_SEEK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018568694));
pub const SQLITE_E_IOERR_DELETE_NOENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018568438));
pub const SQLITE_E_IOERR_MMAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018568182));
pub const SQLITE_E_IOERR_GETTEMPPATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018567926));
pub const SQLITE_E_IOERR_CONVPATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018567670));
pub const SQLITE_E_IOERR_VNODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018567678));
pub const SQLITE_E_IOERR_AUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018567677));
pub const SQLITE_E_LOCKED_SHAREDCACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574074));
pub const SQLITE_E_BUSY_RECOVERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574075));
pub const SQLITE_E_BUSY_SNAPSHOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573819));
pub const SQLITE_E_CANTOPEN_NOTEMPDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574066));
pub const SQLITE_E_CANTOPEN_ISDIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573810));
pub const SQLITE_E_CANTOPEN_FULLPATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573554));
pub const SQLITE_E_CANTOPEN_CONVPATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573298));
pub const SQLITE_E_CORRUPT_VTAB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574069));
pub const SQLITE_E_READONLY_RECOVERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574072));
pub const SQLITE_E_READONLY_CANTLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573816));
pub const SQLITE_E_READONLY_ROLLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573560));
pub const SQLITE_E_READONLY_DBMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573304));
pub const SQLITE_E_ABORT_ROLLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573820));
pub const SQLITE_E_CONSTRAINT_CHECK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574061));
pub const SQLITE_E_CONSTRAINT_COMMITHOOK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573805));
pub const SQLITE_E_CONSTRAINT_FOREIGNKEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573549));
pub const SQLITE_E_CONSTRAINT_FUNCTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573293));
pub const SQLITE_E_CONSTRAINT_NOTNULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573037));
pub const SQLITE_E_CONSTRAINT_PRIMARYKEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572781));
pub const SQLITE_E_CONSTRAINT_TRIGGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572525));
pub const SQLITE_E_CONSTRAINT_UNIQUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572269));
pub const SQLITE_E_CONSTRAINT_VTAB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018572013));
pub const SQLITE_E_CONSTRAINT_ROWID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018571757));
pub const SQLITE_E_NOTICE_RECOVER_WAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574053));
pub const SQLITE_E_NOTICE_RECOVER_ROLLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018573797));
pub const SQLITE_E_WARNING_AUTOINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2018574052));
pub const UTC_E_TOGGLE_TRACE_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128447));
pub const UTC_E_ALTERNATIVE_TRACE_CANNOT_PREEMPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128446));
pub const UTC_E_AOT_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128445));
pub const UTC_E_SCRIPT_TYPE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128444));
pub const UTC_E_SCENARIODEF_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128443));
pub const UTC_E_TRACEPROFILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128442));
pub const UTC_E_FORWARDER_ALREADY_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128441));
pub const UTC_E_FORWARDER_ALREADY_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128440));
pub const UTC_E_EVENTLOG_ENTRY_MALFORMED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128439));
pub const UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128438));
pub const UTC_E_SCRIPT_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128437));
pub const UTC_E_INVALID_CUSTOM_FILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128436));
pub const UTC_E_TRACE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128435));
pub const UTC_E_REESCALATED_TOO_QUICKLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128434));
pub const UTC_E_ESCALATION_ALREADY_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128433));
pub const UTC_E_PERFTRACK_ALREADY_TRACING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128432));
pub const UTC_E_REACHED_MAX_ESCALATIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128431));
pub const UTC_E_FORWARDER_PRODUCER_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128430));
pub const UTC_E_INTENTIONAL_SCRIPT_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128429));
pub const UTC_E_SQM_INIT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128428));
pub const UTC_E_NO_WER_LOGGER_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128427));
pub const UTC_E_TRACERS_DONT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128426));
pub const UTC_E_WINRT_INIT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128425));
pub const UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128424));
pub const UTC_E_INVALID_FILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128423));
pub const UTC_E_EXE_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128422));
pub const UTC_E_ESCALATION_NOT_AUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128421));
pub const UTC_E_SETUP_NOT_AUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128420));
pub const UTC_E_CHILD_PROCESS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128419));
pub const UTC_E_COMMAND_LINE_NOT_AUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128418));
pub const UTC_E_CANNOT_LOAD_SCENARIO_EDITOR_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128417));
pub const UTC_E_ESCALATION_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128416));
pub const UTC_E_SETUP_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128415));
pub const UTC_E_TRIGGER_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128414));
pub const UTC_E_TRIGGER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128413));
pub const UTC_E_SIF_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128412));
pub const UTC_E_DELAY_TERMINATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128411));
pub const UTC_E_DEVICE_TICKET_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128410));
pub const UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128409));
pub const UTC_E_API_RESULT_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128408));
pub const UTC_E_RPC_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128407));
pub const UTC_E_RPC_WAIT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128406));
pub const UTC_E_API_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128405));
pub const UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128404));
pub const UTC_E_EXCLUSIVITY_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128403));
pub const UTC_E_GETFILE_FILE_PATH_NOT_APPROVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128402));
pub const UTC_E_ESCALATION_DIRECTORY_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128401));
pub const UTC_E_TIME_TRIGGER_ON_START_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128400));
pub const UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128399));
pub const UTC_E_TIME_TRIGGER_INVALID_TIME_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128398));
pub const UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128397));
pub const UTC_E_BINARY_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128396));
pub const UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128394));
pub const UTC_E_UNABLE_TO_RESOLVE_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128393));
pub const UTC_E_THROTTLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128392));
pub const UTC_E_UNAPPROVED_SCRIPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128391));
pub const UTC_E_SCRIPT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128390));
pub const UTC_E_SCENARIO_THROTTLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128389));
pub const UTC_E_API_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128388));
pub const UTC_E_GETFILE_EXTERNAL_PATH_NOT_APPROVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128387));
pub const UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128386));
pub const UTC_E_CERT_REV_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128385));
pub const UTC_E_FAILED_TO_START_NDISCAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128384));
pub const UTC_E_KERNELDUMP_LIMIT_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128383));
pub const UTC_E_MISSING_AGGREGATE_EVENT_TAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128382));
pub const UTC_E_INVALID_AGGREGATION_STRUCT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128381));
pub const UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128380));
pub const UTC_E_FILTER_MISSING_ATTRIBUTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128379));
pub const UTC_E_FILTER_INVALID_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128378));
pub const UTC_E_FILTER_VARIABLE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128377));
pub const UTC_E_FILTER_FUNCTION_RESTRICTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128376));
pub const UTC_E_FILTER_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128375));
pub const UTC_E_FILTER_INVALID_FUNCTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128368));
pub const UTC_E_FILTER_INVALID_FUNCTION_PARAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128367));
pub const UTC_E_FILTER_INVALID_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128366));
pub const UTC_E_FILTER_ILLEGAL_EVAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128365));
pub const UTC_E_TTTRACER_RETURNED_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128364));
pub const UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128363));
pub const UTC_E_FAILED_TO_RECEIVE_AGENT_DIAGNOSTICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128362));
pub const UTC_E_SCENARIO_HAS_NO_ACTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128361));
pub const UTC_E_TTTRACER_STORAGE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128360));
pub const UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128359));
pub const UTC_E_ESCALATION_CANCELLED_AT_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128358));
pub const UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128357));
pub const UTC_E_SETREGKEYACTION_TYPE_NOT_APPROVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2017128356));
pub const WINML_ERR_INVALID_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003828735));
pub const WINML_ERR_INVALID_BINDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003828734));
pub const WINML_ERR_VALUE_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003828733));
pub const WINML_ERR_SIZE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2003828732));
pub const ERROR_QUIC_HANDSHAKE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143223808));
pub const ERROR_QUIC_VER_NEG_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2143223807));
pub const STATUS_WAIT_0 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 0));
pub const FACILTIY_MUI_ERROR_CODE = @as(u32, 11);
pub const STATUS_SEVERITY_SUCCESS = @as(u32, 0);
pub const STATUS_SEVERITY_INFORMATIONAL = @as(u32, 1);
pub const STATUS_SEVERITY_WARNING = @as(u32, 2);
pub const STATUS_SEVERITY_ERROR = @as(u32, 3);
pub const STATUS_SUCCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 0));
pub const STATUS_WAIT_1 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1));
pub const STATUS_WAIT_2 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 2));
pub const STATUS_WAIT_3 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 3));
pub const STATUS_WAIT_63 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 63));
pub const STATUS_ABANDONED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 128));
pub const STATUS_ABANDONED_WAIT_0 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 128));
pub const STATUS_ABANDONED_WAIT_63 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 191));
pub const STATUS_USER_APC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 192));
pub const STATUS_ALREADY_COMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 255));
pub const STATUS_KERNEL_APC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 256));
pub const STATUS_ALERTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 257));
pub const STATUS_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 258));
pub const STATUS_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 259));
pub const STATUS_REPARSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 260));
pub const STATUS_MORE_ENTRIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 261));
pub const STATUS_NOT_ALL_ASSIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 262));
pub const STATUS_SOME_NOT_MAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 263));
pub const STATUS_OPLOCK_BREAK_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 264));
pub const STATUS_VOLUME_MOUNTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 265));
pub const STATUS_RXACT_COMMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 266));
pub const STATUS_NOTIFY_CLEANUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 267));
pub const STATUS_NOTIFY_ENUM_DIR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 268));
pub const STATUS_NO_QUOTAS_FOR_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 269));
pub const STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 270));
pub const STATUS_PAGE_FAULT_TRANSITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 272));
pub const STATUS_PAGE_FAULT_DEMAND_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 273));
pub const STATUS_PAGE_FAULT_COPY_ON_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 274));
pub const STATUS_PAGE_FAULT_GUARD_PAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 275));
pub const STATUS_PAGE_FAULT_PAGING_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 276));
pub const STATUS_CACHE_PAGE_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 277));
pub const STATUS_CRASH_DUMP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 278));
pub const STATUS_BUFFER_ALL_ZEROS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 279));
pub const STATUS_REPARSE_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 280));
pub const STATUS_RESOURCE_REQUIREMENTS_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 281));
pub const STATUS_TRANSLATION_COMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 288));
pub const STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 289));
pub const STATUS_NOTHING_TO_TERMINATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 290));
pub const STATUS_PROCESS_NOT_IN_JOB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 291));
pub const STATUS_PROCESS_IN_JOB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 292));
pub const STATUS_VOLSNAP_HIBERNATE_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 293));
pub const STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 294));
pub const STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 295));
pub const STATUS_INTERRUPT_STILL_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 296));
pub const STATUS_PROCESS_CLONED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 297));
pub const STATUS_FILE_LOCKED_WITH_ONLY_READERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 298));
pub const STATUS_FILE_LOCKED_WITH_WRITERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 299));
pub const STATUS_VALID_IMAGE_HASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 300));
pub const STATUS_VALID_CATALOG_HASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 301));
pub const STATUS_VALID_STRONG_CODE_HASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 302));
pub const STATUS_GHOSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 303));
pub const STATUS_DATA_OVERWRITTEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 304));
pub const STATUS_RESOURCEMANAGER_READ_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 514));
pub const STATUS_RING_PREVIOUSLY_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 528));
pub const STATUS_RING_PREVIOUSLY_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 529));
pub const STATUS_RING_PREVIOUSLY_ABOVE_QUOTA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 530));
pub const STATUS_RING_NEWLY_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 531));
pub const STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 532));
pub const STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 533));
pub const STATUS_OPLOCK_HANDLE_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 534));
pub const STATUS_WAIT_FOR_OPLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 871));
pub const STATUS_REPARSE_GLOBAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 872));
pub const DBG_EXCEPTION_HANDLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 65537));
pub const DBG_CONTINUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 65538));
pub const STATUS_FLT_IO_COMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1835009));
pub const STATUS_OBJECT_NAME_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741824));
pub const STATUS_THREAD_WAS_SUSPENDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741825));
pub const STATUS_WORKING_SET_LIMIT_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741826));
pub const STATUS_IMAGE_NOT_AT_BASE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741827));
pub const STATUS_RXACT_STATE_CREATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741828));
pub const STATUS_SEGMENT_NOTIFICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741829));
pub const STATUS_LOCAL_USER_SESSION_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741830));
pub const STATUS_BAD_CURRENT_DIRECTORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741831));
pub const STATUS_SERIAL_MORE_WRITES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741832));
pub const STATUS_REGISTRY_RECOVERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741833));
pub const STATUS_FT_READ_RECOVERY_FROM_BACKUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741834));
pub const STATUS_FT_WRITE_RECOVERY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741835));
pub const STATUS_SERIAL_COUNTER_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741836));
pub const STATUS_NULL_LM_PASSWORD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741837));
pub const STATUS_IMAGE_MACHINE_TYPE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741838));
pub const STATUS_RECEIVE_PARTIAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741839));
pub const STATUS_RECEIVE_EXPEDITED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741840));
pub const STATUS_RECEIVE_PARTIAL_EXPEDITED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741841));
pub const STATUS_EVENT_DONE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741842));
pub const STATUS_EVENT_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741843));
pub const STATUS_CHECKING_FILE_SYSTEM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741844));
pub const STATUS_FATAL_APP_EXIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741845));
pub const STATUS_PREDEFINED_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741846));
pub const STATUS_WAS_UNLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741847));
pub const STATUS_SERVICE_NOTIFICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741848));
pub const STATUS_WAS_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741849));
pub const STATUS_LOG_HARD_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741850));
pub const STATUS_ALREADY_WIN32 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741851));
pub const STATUS_WX86_UNSIMULATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741852));
pub const STATUS_WX86_CONTINUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741853));
pub const STATUS_WX86_SINGLE_STEP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741854));
pub const STATUS_WX86_BREAKPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741855));
pub const STATUS_WX86_EXCEPTION_CONTINUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741856));
pub const STATUS_WX86_EXCEPTION_LASTCHANCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741857));
pub const STATUS_WX86_EXCEPTION_CHAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741858));
pub const STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741859));
pub const STATUS_NO_YIELD_PERFORMED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741860));
pub const STATUS_TIMER_RESUME_IGNORED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741861));
pub const STATUS_ARBITRATION_UNHANDLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741862));
pub const STATUS_CARDBUS_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741863));
pub const STATUS_WX86_CREATEWX86TIB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741864));
pub const STATUS_MP_PROCESSOR_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741865));
pub const STATUS_HIBERNATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741866));
pub const STATUS_RESUME_HIBERNATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741867));
pub const STATUS_FIRMWARE_UPDATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741868));
pub const STATUS_DRIVERS_LEAKING_LOCKED_PAGES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741869));
pub const STATUS_MESSAGE_RETRIEVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741870));
pub const STATUS_SYSTEM_POWERSTATE_TRANSITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741871));
pub const STATUS_ALPC_CHECK_COMPLETION_LIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741872));
pub const STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741873));
pub const STATUS_ACCESS_AUDIT_BY_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741874));
pub const STATUS_ABANDON_HIBERFILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741875));
pub const STATUS_BIZRULES_NOT_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741876));
pub const STATUS_FT_READ_FROM_COPY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741877));
pub const STATUS_IMAGE_AT_DIFFERENT_BASE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741878));
pub const STATUS_PATCH_DEFERRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073741879));
pub const DBG_REPLY_LATER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807361));
pub const DBG_UNABLE_TO_PROVIDE_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807362));
pub const DBG_TERMINATE_THREAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807363));
pub const DBG_TERMINATE_PROCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807364));
pub const DBG_CONTROL_C = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807365));
pub const DBG_PRINTEXCEPTION_C = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807366));
pub const DBG_RIPEXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807367));
pub const DBG_CONTROL_BREAK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807368));
pub const DBG_COMMAND_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807369));
pub const DBG_PRINTEXCEPTION_WIDE_C = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073807370));
pub const STATUS_HEURISTIC_DAMAGE_POSSIBLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075380225));
pub const STATUS_GUARD_PAGE_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483647));
pub const STATUS_DATATYPE_MISALIGNMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483646));
pub const STATUS_BREAKPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483645));
pub const STATUS_SINGLE_STEP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483644));
pub const STATUS_BUFFER_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483643));
pub const STATUS_NO_MORE_FILES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483642));
pub const STATUS_WAKE_SYSTEM_DEBUGGER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483641));
pub const STATUS_HANDLES_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483638));
pub const STATUS_NO_INHERITANCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483637));
pub const STATUS_GUID_SUBSTITUTION_MADE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483636));
pub const STATUS_PARTIAL_COPY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483635));
pub const STATUS_DEVICE_PAPER_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483634));
pub const STATUS_DEVICE_POWERED_OFF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483633));
pub const STATUS_DEVICE_OFF_LINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483632));
pub const STATUS_DEVICE_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483631));
pub const STATUS_NO_MORE_EAS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483630));
pub const STATUS_INVALID_EA_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483629));
pub const STATUS_EA_LIST_INCONSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483628));
pub const STATUS_INVALID_EA_FLAG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483627));
pub const STATUS_VERIFY_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483626));
pub const STATUS_EXTRANEOUS_INFORMATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483625));
pub const STATUS_RXACT_COMMIT_NECESSARY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483624));
pub const STATUS_NO_MORE_ENTRIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483622));
pub const STATUS_FILEMARK_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483621));
pub const STATUS_MEDIA_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483620));
pub const STATUS_BUS_RESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483619));
pub const STATUS_END_OF_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483618));
pub const STATUS_BEGINNING_OF_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483617));
pub const STATUS_MEDIA_CHECK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483616));
pub const STATUS_SETMARK_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483615));
pub const STATUS_NO_DATA_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483614));
pub const STATUS_REDIRECTOR_HAS_OPEN_HANDLES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483613));
pub const STATUS_SERVER_HAS_OPEN_HANDLES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483612));
pub const STATUS_ALREADY_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483611));
pub const STATUS_LONGJUMP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483610));
pub const STATUS_CLEANER_CARTRIDGE_INSTALLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483609));
pub const STATUS_PLUGPLAY_QUERY_VETOED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483608));
pub const STATUS_UNWIND_CONSOLIDATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483607));
pub const STATUS_REGISTRY_HIVE_RECOVERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483606));
pub const STATUS_DLL_MIGHT_BE_INSECURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483605));
pub const STATUS_DLL_MIGHT_BE_INCOMPATIBLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483604));
pub const STATUS_STOPPED_ON_SYMLINK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483603));
pub const STATUS_CANNOT_GRANT_REQUESTED_OPLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483602));
pub const STATUS_NO_ACE_CONDITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483601));
pub const STATUS_DEVICE_SUPPORT_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483600));
pub const STATUS_DEVICE_POWER_CYCLE_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483599));
pub const STATUS_NO_WORK_DONE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483598));
pub const STATUS_RETURN_ADDRESS_HIJACK_ATTEMPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483597));
pub const DBG_EXCEPTION_NOT_HANDLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147418111));
pub const STATUS_CLUSTER_NODE_ALREADY_UP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2146238463));
pub const STATUS_CLUSTER_NODE_ALREADY_DOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2146238462));
pub const STATUS_CLUSTER_NETWORK_ALREADY_ONLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2146238461));
pub const STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2146238460));
pub const STATUS_CLUSTER_NODE_ALREADY_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2146238459));
pub const STATUS_FLT_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145648639));
pub const STATUS_FVE_PARTIAL_METADATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145320959));
pub const STATUS_FVE_TRANSIENT_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145320958));
pub const STATUS_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147430656));
pub const STATUS_UNSUCCESSFUL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741823));
pub const STATUS_NOT_IMPLEMENTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741822));
pub const STATUS_INVALID_INFO_CLASS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741821));
pub const STATUS_INFO_LENGTH_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741820));
pub const STATUS_ACCESS_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741819));
pub const STATUS_IN_PAGE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741818));
pub const STATUS_PAGEFILE_QUOTA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741817));
pub const STATUS_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741816));
pub const STATUS_BAD_INITIAL_STACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741815));
pub const STATUS_BAD_INITIAL_PC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741814));
pub const STATUS_INVALID_CID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741813));
pub const STATUS_TIMER_NOT_CANCELED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741812));
pub const STATUS_INVALID_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741811));
pub const STATUS_NO_SUCH_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741810));
pub const STATUS_NO_SUCH_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741809));
pub const STATUS_INVALID_DEVICE_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741808));
pub const STATUS_END_OF_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741807));
pub const STATUS_WRONG_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741806));
pub const STATUS_NO_MEDIA_IN_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741805));
pub const STATUS_UNRECOGNIZED_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741804));
pub const STATUS_NONEXISTENT_SECTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741803));
pub const STATUS_MORE_PROCESSING_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741802));
pub const STATUS_NO_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741801));
pub const STATUS_CONFLICTING_ADDRESSES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741800));
pub const STATUS_NOT_MAPPED_VIEW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741799));
pub const STATUS_UNABLE_TO_FREE_VM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741798));
pub const STATUS_UNABLE_TO_DELETE_SECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741797));
pub const STATUS_INVALID_SYSTEM_SERVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741796));
pub const STATUS_ILLEGAL_INSTRUCTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741795));
pub const STATUS_INVALID_LOCK_SEQUENCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741794));
pub const STATUS_INVALID_VIEW_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741793));
pub const STATUS_INVALID_FILE_FOR_SECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741792));
pub const STATUS_ALREADY_COMMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741791));
pub const STATUS_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741790));
pub const STATUS_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741789));
pub const STATUS_OBJECT_TYPE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741788));
pub const STATUS_NONCONTINUABLE_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741787));
pub const STATUS_INVALID_DISPOSITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741786));
pub const STATUS_UNWIND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741785));
pub const STATUS_BAD_STACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741784));
pub const STATUS_INVALID_UNWIND_TARGET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741783));
pub const STATUS_NOT_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741782));
pub const STATUS_PARITY_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741781));
pub const STATUS_UNABLE_TO_DECOMMIT_VM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741780));
pub const STATUS_NOT_COMMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741779));
pub const STATUS_INVALID_PORT_ATTRIBUTES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741778));
pub const STATUS_PORT_MESSAGE_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741777));
pub const STATUS_INVALID_PARAMETER_MIX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741776));
pub const STATUS_INVALID_QUOTA_LOWER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741775));
pub const STATUS_DISK_CORRUPT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741774));
pub const STATUS_OBJECT_NAME_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741773));
pub const STATUS_OBJECT_NAME_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741772));
pub const STATUS_OBJECT_NAME_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741771));
pub const STATUS_PORT_DO_NOT_DISTURB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741770));
pub const STATUS_PORT_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741769));
pub const STATUS_DEVICE_ALREADY_ATTACHED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741768));
pub const STATUS_OBJECT_PATH_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741767));
pub const STATUS_OBJECT_PATH_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741766));
pub const STATUS_OBJECT_PATH_SYNTAX_BAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741765));
pub const STATUS_DATA_OVERRUN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741764));
pub const STATUS_DATA_LATE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741763));
pub const STATUS_DATA_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741762));
pub const STATUS_CRC_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741761));
pub const STATUS_SECTION_TOO_BIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741760));
pub const STATUS_PORT_CONNECTION_REFUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741759));
pub const STATUS_INVALID_PORT_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741758));
pub const STATUS_SHARING_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741757));
pub const STATUS_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741756));
pub const STATUS_INVALID_PAGE_PROTECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741755));
pub const STATUS_MUTANT_NOT_OWNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741754));
pub const STATUS_SEMAPHORE_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741753));
pub const STATUS_PORT_ALREADY_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741752));
pub const STATUS_SECTION_NOT_IMAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741751));
pub const STATUS_SUSPEND_COUNT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741750));
pub const STATUS_THREAD_IS_TERMINATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741749));
pub const STATUS_BAD_WORKING_SET_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741748));
pub const STATUS_INCOMPATIBLE_FILE_MAP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741747));
pub const STATUS_SECTION_PROTECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741746));
pub const STATUS_EAS_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741745));
pub const STATUS_EA_TOO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741744));
pub const STATUS_NONEXISTENT_EA_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741743));
pub const STATUS_NO_EAS_ON_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741742));
pub const STATUS_EA_CORRUPT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741741));
pub const STATUS_FILE_LOCK_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741740));
pub const STATUS_LOCK_NOT_GRANTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741739));
pub const STATUS_DELETE_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741738));
pub const STATUS_CTL_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741737));
pub const STATUS_UNKNOWN_REVISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741736));
pub const STATUS_REVISION_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741735));
pub const STATUS_INVALID_OWNER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741734));
pub const STATUS_INVALID_PRIMARY_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741733));
pub const STATUS_NO_IMPERSONATION_TOKEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741732));
pub const STATUS_CANT_DISABLE_MANDATORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741731));
pub const STATUS_NO_LOGON_SERVERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741730));
pub const STATUS_NO_SUCH_LOGON_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741729));
pub const STATUS_NO_SUCH_PRIVILEGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741728));
pub const STATUS_PRIVILEGE_NOT_HELD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741727));
pub const STATUS_INVALID_ACCOUNT_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741726));
pub const STATUS_USER_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741725));
pub const STATUS_NO_SUCH_USER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741724));
pub const STATUS_GROUP_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741723));
pub const STATUS_NO_SUCH_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741722));
pub const STATUS_MEMBER_IN_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741721));
pub const STATUS_MEMBER_NOT_IN_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741720));
pub const STATUS_LAST_ADMIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741719));
pub const STATUS_WRONG_PASSWORD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741718));
pub const STATUS_ILL_FORMED_PASSWORD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741717));
pub const STATUS_PASSWORD_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741716));
pub const STATUS_LOGON_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741715));
pub const STATUS_ACCOUNT_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741714));
pub const STATUS_INVALID_LOGON_HOURS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741713));
pub const STATUS_INVALID_WORKSTATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741712));
pub const STATUS_PASSWORD_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741711));
pub const STATUS_ACCOUNT_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741710));
pub const STATUS_NONE_MAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741709));
pub const STATUS_TOO_MANY_LUIDS_REQUESTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741708));
pub const STATUS_LUIDS_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741707));
pub const STATUS_INVALID_SUB_AUTHORITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741706));
pub const STATUS_INVALID_ACL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741705));
pub const STATUS_INVALID_SID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741704));
pub const STATUS_INVALID_SECURITY_DESCR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741703));
pub const STATUS_PROCEDURE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741702));
pub const STATUS_INVALID_IMAGE_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741701));
pub const STATUS_NO_TOKEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741700));
pub const STATUS_BAD_INHERITANCE_ACL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741699));
pub const STATUS_RANGE_NOT_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741698));
pub const STATUS_DISK_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741697));
pub const STATUS_SERVER_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741696));
pub const STATUS_SERVER_NOT_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741695));
pub const STATUS_TOO_MANY_GUIDS_REQUESTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741694));
pub const STATUS_GUIDS_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741693));
pub const STATUS_INVALID_ID_AUTHORITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741692));
pub const STATUS_AGENTS_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741691));
pub const STATUS_INVALID_VOLUME_LABEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741690));
pub const STATUS_SECTION_NOT_EXTENDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741689));
pub const STATUS_NOT_MAPPED_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741688));
pub const STATUS_RESOURCE_DATA_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741687));
pub const STATUS_RESOURCE_TYPE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741686));
pub const STATUS_RESOURCE_NAME_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741685));
pub const STATUS_ARRAY_BOUNDS_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741684));
pub const STATUS_FLOAT_DENORMAL_OPERAND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741683));
pub const STATUS_FLOAT_DIVIDE_BY_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741682));
pub const STATUS_FLOAT_INEXACT_RESULT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741681));
pub const STATUS_FLOAT_INVALID_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741680));
pub const STATUS_FLOAT_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741679));
pub const STATUS_FLOAT_STACK_CHECK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741678));
pub const STATUS_FLOAT_UNDERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741677));
pub const STATUS_INTEGER_DIVIDE_BY_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741676));
pub const STATUS_INTEGER_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741675));
pub const STATUS_PRIVILEGED_INSTRUCTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741674));
pub const STATUS_TOO_MANY_PAGING_FILES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741673));
pub const STATUS_FILE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741672));
pub const STATUS_ALLOTTED_SPACE_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741671));
pub const STATUS_INSUFFICIENT_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741670));
pub const STATUS_DFS_EXIT_PATH_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741669));
pub const STATUS_DEVICE_DATA_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741668));
pub const STATUS_DEVICE_NOT_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741667));
pub const STATUS_DEVICE_POWER_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741666));
pub const STATUS_FREE_VM_NOT_AT_BASE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741665));
pub const STATUS_MEMORY_NOT_ALLOCATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741664));
pub const STATUS_WORKING_SET_QUOTA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741663));
pub const STATUS_MEDIA_WRITE_PROTECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741662));
pub const STATUS_DEVICE_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741661));
pub const STATUS_INVALID_GROUP_ATTRIBUTES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741660));
pub const STATUS_BAD_IMPERSONATION_LEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741659));
pub const STATUS_CANT_OPEN_ANONYMOUS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741658));
pub const STATUS_BAD_VALIDATION_CLASS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741657));
pub const STATUS_BAD_TOKEN_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741656));
pub const STATUS_BAD_MASTER_BOOT_RECORD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741655));
pub const STATUS_INSTRUCTION_MISALIGNMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741654));
pub const STATUS_INSTANCE_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741653));
pub const STATUS_PIPE_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741652));
pub const STATUS_INVALID_PIPE_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741651));
pub const STATUS_PIPE_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741650));
pub const STATUS_ILLEGAL_FUNCTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741649));
pub const STATUS_PIPE_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741648));
pub const STATUS_PIPE_CLOSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741647));
pub const STATUS_PIPE_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741646));
pub const STATUS_PIPE_LISTENING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741645));
pub const STATUS_INVALID_READ_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741644));
pub const STATUS_IO_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741643));
pub const STATUS_FILE_FORCED_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741642));
pub const STATUS_PROFILING_NOT_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741641));
pub const STATUS_PROFILING_NOT_STOPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741640));
pub const STATUS_COULD_NOT_INTERPRET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741639));
pub const STATUS_FILE_IS_A_DIRECTORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741638));
pub const STATUS_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741637));
pub const STATUS_REMOTE_NOT_LISTENING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741636));
pub const STATUS_DUPLICATE_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741635));
pub const STATUS_BAD_NETWORK_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741634));
pub const STATUS_NETWORK_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741633));
pub const STATUS_DEVICE_DOES_NOT_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741632));
pub const STATUS_TOO_MANY_COMMANDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741631));
pub const STATUS_ADAPTER_HARDWARE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741630));
pub const STATUS_INVALID_NETWORK_RESPONSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741629));
pub const STATUS_UNEXPECTED_NETWORK_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741628));
pub const STATUS_BAD_REMOTE_ADAPTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741627));
pub const STATUS_PRINT_QUEUE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741626));
pub const STATUS_NO_SPOOL_SPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741625));
pub const STATUS_PRINT_CANCELLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741624));
pub const STATUS_NETWORK_NAME_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741623));
pub const STATUS_NETWORK_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741622));
pub const STATUS_BAD_DEVICE_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741621));
pub const STATUS_BAD_NETWORK_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741620));
pub const STATUS_TOO_MANY_NAMES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741619));
pub const STATUS_TOO_MANY_SESSIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741618));
pub const STATUS_SHARING_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741617));
pub const STATUS_REQUEST_NOT_ACCEPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741616));
pub const STATUS_REDIRECTOR_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741615));
pub const STATUS_NET_WRITE_FAULT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741614));
pub const STATUS_PROFILING_AT_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741613));
pub const STATUS_NOT_SAME_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741612));
pub const STATUS_FILE_RENAMED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741611));
pub const STATUS_VIRTUAL_CIRCUIT_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741610));
pub const STATUS_NO_SECURITY_ON_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741609));
pub const STATUS_CANT_WAIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741608));
pub const STATUS_PIPE_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741607));
pub const STATUS_CANT_ACCESS_DOMAIN_INFO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741606));
pub const STATUS_CANT_TERMINATE_SELF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741605));
pub const STATUS_INVALID_SERVER_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741604));
pub const STATUS_INVALID_DOMAIN_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741603));
pub const STATUS_INVALID_DOMAIN_ROLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741602));
pub const STATUS_NO_SUCH_DOMAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741601));
pub const STATUS_DOMAIN_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741600));
pub const STATUS_DOMAIN_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741599));
pub const STATUS_OPLOCK_NOT_GRANTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741598));
pub const STATUS_INVALID_OPLOCK_PROTOCOL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741597));
pub const STATUS_INTERNAL_DB_CORRUPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741596));
pub const STATUS_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741595));
pub const STATUS_GENERIC_NOT_MAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741594));
pub const STATUS_BAD_DESCRIPTOR_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741593));
pub const STATUS_INVALID_USER_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741592));
pub const STATUS_UNEXPECTED_IO_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741591));
pub const STATUS_UNEXPECTED_MM_CREATE_ERR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741590));
pub const STATUS_UNEXPECTED_MM_MAP_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741589));
pub const STATUS_UNEXPECTED_MM_EXTEND_ERR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741588));
pub const STATUS_NOT_LOGON_PROCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741587));
pub const STATUS_LOGON_SESSION_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741586));
pub const STATUS_INVALID_PARAMETER_1 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741585));
pub const STATUS_INVALID_PARAMETER_2 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741584));
pub const STATUS_INVALID_PARAMETER_3 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741583));
pub const STATUS_INVALID_PARAMETER_4 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741582));
pub const STATUS_INVALID_PARAMETER_5 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741581));
pub const STATUS_INVALID_PARAMETER_6 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741580));
pub const STATUS_INVALID_PARAMETER_7 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741579));
pub const STATUS_INVALID_PARAMETER_8 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741578));
pub const STATUS_INVALID_PARAMETER_9 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741577));
pub const STATUS_INVALID_PARAMETER_10 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741576));
pub const STATUS_INVALID_PARAMETER_11 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741575));
pub const STATUS_INVALID_PARAMETER_12 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741574));
pub const STATUS_REDIRECTOR_NOT_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741573));
pub const STATUS_REDIRECTOR_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741572));
pub const STATUS_STACK_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741571));
pub const STATUS_NO_SUCH_PACKAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741570));
pub const STATUS_BAD_FUNCTION_TABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741569));
pub const STATUS_VARIABLE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741568));
pub const STATUS_DIRECTORY_NOT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741567));
pub const STATUS_FILE_CORRUPT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741566));
pub const STATUS_NOT_A_DIRECTORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741565));
pub const STATUS_BAD_LOGON_SESSION_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741564));
pub const STATUS_LOGON_SESSION_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741563));
pub const STATUS_NAME_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741562));
pub const STATUS_FILES_OPEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741561));
pub const STATUS_CONNECTION_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741560));
pub const STATUS_MESSAGE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741559));
pub const STATUS_PROCESS_IS_TERMINATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741558));
pub const STATUS_INVALID_LOGON_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741557));
pub const STATUS_NO_GUID_TRANSLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741556));
pub const STATUS_CANNOT_IMPERSONATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741555));
pub const STATUS_IMAGE_ALREADY_LOADED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741554));
pub const STATUS_ABIOS_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741553));
pub const STATUS_ABIOS_LID_NOT_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741552));
pub const STATUS_ABIOS_LID_ALREADY_OWNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741551));
pub const STATUS_ABIOS_NOT_LID_OWNER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741550));
pub const STATUS_ABIOS_INVALID_COMMAND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741549));
pub const STATUS_ABIOS_INVALID_LID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741548));
pub const STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741547));
pub const STATUS_ABIOS_INVALID_SELECTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741546));
pub const STATUS_NO_LDT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741545));
pub const STATUS_INVALID_LDT_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741544));
pub const STATUS_INVALID_LDT_OFFSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741543));
pub const STATUS_INVALID_LDT_DESCRIPTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741542));
pub const STATUS_INVALID_IMAGE_NE_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741541));
pub const STATUS_RXACT_INVALID_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741540));
pub const STATUS_RXACT_COMMIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741539));
pub const STATUS_MAPPED_FILE_SIZE_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741538));
pub const STATUS_TOO_MANY_OPENED_FILES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741537));
pub const STATUS_CANCELLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741536));
pub const STATUS_CANNOT_DELETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741535));
pub const STATUS_INVALID_COMPUTER_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741534));
pub const STATUS_FILE_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741533));
pub const STATUS_SPECIAL_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741532));
pub const STATUS_SPECIAL_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741531));
pub const STATUS_SPECIAL_USER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741530));
pub const STATUS_MEMBERS_PRIMARY_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741529));
pub const STATUS_FILE_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741528));
pub const STATUS_TOO_MANY_THREADS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741527));
pub const STATUS_THREAD_NOT_IN_PROCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741526));
pub const STATUS_TOKEN_ALREADY_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741525));
pub const STATUS_PAGEFILE_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741524));
pub const STATUS_COMMITMENT_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741523));
pub const STATUS_INVALID_IMAGE_LE_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741522));
pub const STATUS_INVALID_IMAGE_NOT_MZ = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741521));
pub const STATUS_INVALID_IMAGE_PROTECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741520));
pub const STATUS_INVALID_IMAGE_WIN_16 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741519));
pub const STATUS_LOGON_SERVER_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741518));
pub const STATUS_TIME_DIFFERENCE_AT_DC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741517));
pub const STATUS_SYNCHRONIZATION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741516));
pub const STATUS_DLL_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741515));
pub const STATUS_OPEN_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741514));
pub const STATUS_IO_PRIVILEGE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741513));
pub const STATUS_ORDINAL_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741512));
pub const STATUS_ENTRYPOINT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741511));
pub const STATUS_CONTROL_C_EXIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741510));
pub const STATUS_LOCAL_DISCONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741509));
pub const STATUS_REMOTE_DISCONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741508));
pub const STATUS_REMOTE_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741507));
pub const STATUS_LINK_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741506));
pub const STATUS_LINK_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741505));
pub const STATUS_INVALID_CONNECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741504));
pub const STATUS_INVALID_ADDRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741503));
pub const STATUS_DLL_INIT_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741502));
pub const STATUS_MISSING_SYSTEMFILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741501));
pub const STATUS_UNHANDLED_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741500));
pub const STATUS_APP_INIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741499));
pub const STATUS_PAGEFILE_CREATE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741498));
pub const STATUS_NO_PAGEFILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741497));
pub const STATUS_INVALID_LEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741496));
pub const STATUS_WRONG_PASSWORD_CORE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741495));
pub const STATUS_ILLEGAL_FLOAT_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741494));
pub const STATUS_PIPE_BROKEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741493));
pub const STATUS_REGISTRY_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741492));
pub const STATUS_REGISTRY_IO_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741491));
pub const STATUS_NO_EVENT_PAIR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741490));
pub const STATUS_UNRECOGNIZED_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741489));
pub const STATUS_SERIAL_NO_DEVICE_INITED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741488));
pub const STATUS_NO_SUCH_ALIAS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741487));
pub const STATUS_MEMBER_NOT_IN_ALIAS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741486));
pub const STATUS_MEMBER_IN_ALIAS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741485));
pub const STATUS_ALIAS_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741484));
pub const STATUS_LOGON_NOT_GRANTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741483));
pub const STATUS_TOO_MANY_SECRETS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741482));
pub const STATUS_SECRET_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741481));
pub const STATUS_INTERNAL_DB_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741480));
pub const STATUS_FULLSCREEN_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741479));
pub const STATUS_TOO_MANY_CONTEXT_IDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741478));
pub const STATUS_LOGON_TYPE_NOT_GRANTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741477));
pub const STATUS_NOT_REGISTRY_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741476));
pub const STATUS_NT_CROSS_ENCRYPTION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741475));
pub const STATUS_DOMAIN_CTRLR_CONFIG_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741474));
pub const STATUS_FT_MISSING_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741473));
pub const STATUS_ILL_FORMED_SERVICE_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741472));
pub const STATUS_ILLEGAL_CHARACTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741471));
pub const STATUS_UNMAPPABLE_CHARACTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741470));
pub const STATUS_UNDEFINED_CHARACTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741469));
pub const STATUS_FLOPPY_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741468));
pub const STATUS_FLOPPY_ID_MARK_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741467));
pub const STATUS_FLOPPY_WRONG_CYLINDER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741466));
pub const STATUS_FLOPPY_UNKNOWN_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741465));
pub const STATUS_FLOPPY_BAD_REGISTERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741464));
pub const STATUS_DISK_RECALIBRATE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741463));
pub const STATUS_DISK_OPERATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741462));
pub const STATUS_DISK_RESET_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741461));
pub const STATUS_SHARED_IRQ_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741460));
pub const STATUS_FT_ORPHANING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741459));
pub const STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741458));
pub const STATUS_PARTITION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741454));
pub const STATUS_INVALID_BLOCK_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741453));
pub const STATUS_DEVICE_NOT_PARTITIONED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741452));
pub const STATUS_UNABLE_TO_LOCK_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741451));
pub const STATUS_UNABLE_TO_UNLOAD_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741450));
pub const STATUS_EOM_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741449));
pub const STATUS_NO_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741448));
pub const STATUS_NO_SUCH_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741446));
pub const STATUS_INVALID_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741445));
pub const STATUS_KEY_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741444));
pub const STATUS_NO_LOG_SPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741443));
pub const STATUS_TOO_MANY_SIDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741442));
pub const STATUS_LM_CROSS_ENCRYPTION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741441));
pub const STATUS_KEY_HAS_CHILDREN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741440));
pub const STATUS_CHILD_MUST_BE_VOLATILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741439));
pub const STATUS_DEVICE_CONFIGURATION_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741438));
pub const STATUS_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741437));
pub const STATUS_INVALID_DEVICE_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741436));
pub const STATUS_IO_DEVICE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741435));
pub const STATUS_DEVICE_PROTOCOL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741434));
pub const STATUS_BACKUP_CONTROLLER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741433));
pub const STATUS_LOG_FILE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741432));
pub const STATUS_TOO_LATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741431));
pub const STATUS_NO_TRUST_LSA_SECRET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741430));
pub const STATUS_NO_TRUST_SAM_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741429));
pub const STATUS_TRUSTED_DOMAIN_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741428));
pub const STATUS_TRUSTED_RELATIONSHIP_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741427));
pub const STATUS_EVENTLOG_FILE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741426));
pub const STATUS_EVENTLOG_CANT_START = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741425));
pub const STATUS_TRUST_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741424));
pub const STATUS_MUTANT_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741423));
pub const STATUS_NETLOGON_NOT_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741422));
pub const STATUS_ACCOUNT_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741421));
pub const STATUS_POSSIBLE_DEADLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741420));
pub const STATUS_NETWORK_CREDENTIAL_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741419));
pub const STATUS_REMOTE_SESSION_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741418));
pub const STATUS_EVENTLOG_FILE_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741417));
pub const STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741416));
pub const STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741415));
pub const STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741414));
pub const STATUS_DOMAIN_TRUST_INCONSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741413));
pub const STATUS_FS_DRIVER_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741412));
pub const STATUS_IMAGE_ALREADY_LOADED_AS_DLL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741411));
pub const STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741410));
pub const STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741409));
pub const STATUS_SECURITY_STREAM_IS_INCONSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741408));
pub const STATUS_INVALID_LOCK_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741407));
pub const STATUS_INVALID_ACE_CONDITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741406));
pub const STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741405));
pub const STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741404));
pub const STATUS_INVALID_EXCEPTION_HANDLER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741403));
pub const STATUS_DUPLICATE_PRIVILEGES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741402));
pub const STATUS_NOT_ALLOWED_ON_SYSTEM_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741401));
pub const STATUS_REPAIR_NEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741400));
pub const STATUS_QUOTA_NOT_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741399));
pub const STATUS_NO_APPLICATION_PACKAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741398));
pub const STATUS_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741397));
pub const STATUS_NOT_SAME_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741396));
pub const STATUS_FATAL_MEMORY_EXHAUSTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741395));
pub const STATUS_ERROR_PROCESS_NOT_IN_JOB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741394));
pub const STATUS_CPU_SET_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741393));
pub const STATUS_IO_DEVICE_INVALID_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741392));
pub const STATUS_IO_UNALIGNED_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741391));
pub const STATUS_CONTROL_STACK_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741390));
pub const STATUS_NETWORK_OPEN_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741311));
pub const STATUS_NO_USER_SESSION_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741310));
pub const STATUS_USER_SESSION_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741309));
pub const STATUS_RESOURCE_LANG_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741308));
pub const STATUS_INSUFF_SERVER_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741307));
pub const STATUS_INVALID_BUFFER_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741306));
pub const STATUS_INVALID_ADDRESS_COMPONENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741305));
pub const STATUS_INVALID_ADDRESS_WILDCARD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741304));
pub const STATUS_TOO_MANY_ADDRESSES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741303));
pub const STATUS_ADDRESS_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741302));
pub const STATUS_ADDRESS_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741301));
pub const STATUS_CONNECTION_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741300));
pub const STATUS_CONNECTION_RESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741299));
pub const STATUS_TOO_MANY_NODES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741298));
pub const STATUS_TRANSACTION_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741297));
pub const STATUS_TRANSACTION_TIMED_OUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741296));
pub const STATUS_TRANSACTION_NO_RELEASE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741295));
pub const STATUS_TRANSACTION_NO_MATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741294));
pub const STATUS_TRANSACTION_RESPONDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741293));
pub const STATUS_TRANSACTION_INVALID_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741292));
pub const STATUS_TRANSACTION_INVALID_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741291));
pub const STATUS_NOT_SERVER_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741290));
pub const STATUS_NOT_CLIENT_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741289));
pub const STATUS_CANNOT_LOAD_REGISTRY_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741288));
pub const STATUS_DEBUG_ATTACH_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741287));
pub const STATUS_SYSTEM_PROCESS_TERMINATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741286));
pub const STATUS_DATA_NOT_ACCEPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741285));
pub const STATUS_NO_BROWSER_SERVERS_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741284));
pub const STATUS_VDM_HARD_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741283));
pub const STATUS_DRIVER_CANCEL_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741282));
pub const STATUS_REPLY_MESSAGE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741281));
pub const STATUS_MAPPED_ALIGNMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741280));
pub const STATUS_IMAGE_CHECKSUM_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741279));
pub const STATUS_LOST_WRITEBEHIND_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741278));
pub const STATUS_CLIENT_SERVER_PARAMETERS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741277));
pub const STATUS_PASSWORD_MUST_CHANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741276));
pub const STATUS_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741275));
pub const STATUS_NOT_TINY_STREAM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741274));
pub const STATUS_RECOVERY_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741273));
pub const STATUS_STACK_OVERFLOW_READ = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741272));
pub const STATUS_FAIL_CHECK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741271));
pub const STATUS_DUPLICATE_OBJECTID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741270));
pub const STATUS_OBJECTID_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741269));
pub const STATUS_CONVERT_TO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741268));
pub const STATUS_RETRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741267));
pub const STATUS_FOUND_OUT_OF_SCOPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741266));
pub const STATUS_ALLOCATE_BUCKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741265));
pub const STATUS_PROPSET_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741264));
pub const STATUS_MARSHALL_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741263));
pub const STATUS_INVALID_VARIANT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741262));
pub const STATUS_DOMAIN_CONTROLLER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741261));
pub const STATUS_ACCOUNT_LOCKED_OUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741260));
pub const STATUS_HANDLE_NOT_CLOSABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741259));
pub const STATUS_CONNECTION_REFUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741258));
pub const STATUS_GRACEFUL_DISCONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741257));
pub const STATUS_ADDRESS_ALREADY_ASSOCIATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741256));
pub const STATUS_ADDRESS_NOT_ASSOCIATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741255));
pub const STATUS_CONNECTION_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741254));
pub const STATUS_CONNECTION_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741253));
pub const STATUS_NETWORK_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741252));
pub const STATUS_HOST_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741251));
pub const STATUS_PROTOCOL_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741250));
pub const STATUS_PORT_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741249));
pub const STATUS_REQUEST_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741248));
pub const STATUS_CONNECTION_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741247));
pub const STATUS_BAD_COMPRESSION_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741246));
pub const STATUS_USER_MAPPED_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741245));
pub const STATUS_AUDIT_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741244));
pub const STATUS_TIMER_RESOLUTION_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741243));
pub const STATUS_CONNECTION_COUNT_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741242));
pub const STATUS_LOGIN_TIME_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741241));
pub const STATUS_LOGIN_WKSTA_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741240));
pub const STATUS_IMAGE_MP_UP_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741239));
pub const STATUS_INSUFFICIENT_LOGON_INFO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741232));
pub const STATUS_BAD_DLL_ENTRYPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741231));
pub const STATUS_BAD_SERVICE_ENTRYPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741230));
pub const STATUS_LPC_REPLY_LOST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741229));
pub const STATUS_IP_ADDRESS_CONFLICT1 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741228));
pub const STATUS_IP_ADDRESS_CONFLICT2 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741227));
pub const STATUS_REGISTRY_QUOTA_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741226));
pub const STATUS_PATH_NOT_COVERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741225));
pub const STATUS_NO_CALLBACK_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741224));
pub const STATUS_LICENSE_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741223));
pub const STATUS_PWD_TOO_SHORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741222));
pub const STATUS_PWD_TOO_RECENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741221));
pub const STATUS_PWD_HISTORY_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741220));
pub const STATUS_PLUGPLAY_NO_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741218));
pub const STATUS_UNSUPPORTED_COMPRESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741217));
pub const STATUS_INVALID_HW_PROFILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741216));
pub const STATUS_INVALID_PLUGPLAY_DEVICE_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741215));
pub const STATUS_DRIVER_ORDINAL_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741214));
pub const STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741213));
pub const STATUS_RESOURCE_NOT_OWNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741212));
pub const STATUS_TOO_MANY_LINKS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741211));
pub const STATUS_QUOTA_LIST_INCONSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741210));
pub const STATUS_FILE_IS_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741209));
pub const STATUS_EVALUATION_EXPIRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741208));
pub const STATUS_ILLEGAL_DLL_RELOCATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741207));
pub const STATUS_LICENSE_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741206));
pub const STATUS_DLL_INIT_FAILED_LOGOFF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741205));
pub const STATUS_DRIVER_UNABLE_TO_LOAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741204));
pub const STATUS_DFS_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741203));
pub const STATUS_VOLUME_DISMOUNTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741202));
pub const STATUS_WX86_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741201));
pub const STATUS_WX86_FLOAT_STACK_CHECK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741200));
pub const STATUS_VALIDATE_CONTINUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741199));
pub const STATUS_NO_MATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741198));
pub const STATUS_NO_MORE_MATCHES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741197));
pub const STATUS_NOT_A_REPARSE_POINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741195));
pub const STATUS_IO_REPARSE_TAG_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741194));
pub const STATUS_IO_REPARSE_TAG_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741193));
pub const STATUS_IO_REPARSE_DATA_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741192));
pub const STATUS_IO_REPARSE_TAG_NOT_HANDLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741191));
pub const STATUS_PWD_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741190));
pub const STATUS_STOWED_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741189));
pub const STATUS_CONTEXT_STOWED_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741188));
pub const STATUS_REPARSE_POINT_NOT_RESOLVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741184));
pub const STATUS_DIRECTORY_IS_A_REPARSE_POINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741183));
pub const STATUS_RANGE_LIST_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741182));
pub const STATUS_SOURCE_ELEMENT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741181));
pub const STATUS_DESTINATION_ELEMENT_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741180));
pub const STATUS_ILLEGAL_ELEMENT_ADDRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741179));
pub const STATUS_MAGAZINE_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741178));
pub const STATUS_REINITIALIZATION_NEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741177));
pub const STATUS_DEVICE_REQUIRES_CLEANING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147483000));
pub const STATUS_DEVICE_DOOR_OPEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147482999));
pub const STATUS_ENCRYPTION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741174));
pub const STATUS_DECRYPTION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741173));
pub const STATUS_RANGE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741172));
pub const STATUS_NO_RECOVERY_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741171));
pub const STATUS_NO_EFS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741170));
pub const STATUS_WRONG_EFS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741169));
pub const STATUS_NO_USER_KEYS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741168));
pub const STATUS_FILE_NOT_ENCRYPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741167));
pub const STATUS_NOT_EXPORT_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741166));
pub const STATUS_FILE_ENCRYPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741165));
pub const STATUS_WAKE_SYSTEM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073742484));
pub const STATUS_WMI_GUID_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741163));
pub const STATUS_WMI_INSTANCE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741162));
pub const STATUS_WMI_ITEMID_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741161));
pub const STATUS_WMI_TRY_AGAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741160));
pub const STATUS_SHARED_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741159));
pub const STATUS_POLICY_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741158));
pub const STATUS_POLICY_ONLY_IN_DS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741157));
pub const STATUS_VOLUME_NOT_UPGRADED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741156));
pub const STATUS_REMOTE_STORAGE_NOT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741155));
pub const STATUS_REMOTE_STORAGE_MEDIA_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741154));
pub const STATUS_NO_TRACKING_SERVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741153));
pub const STATUS_SERVER_SID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741152));
pub const STATUS_DS_NO_ATTRIBUTE_OR_VALUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741151));
pub const STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741150));
pub const STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741149));
pub const STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741148));
pub const STATUS_DS_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741147));
pub const STATUS_DS_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741146));
pub const STATUS_DS_NO_RIDS_ALLOCATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741145));
pub const STATUS_DS_NO_MORE_RIDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741144));
pub const STATUS_DS_INCORRECT_ROLE_OWNER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741143));
pub const STATUS_DS_RIDMGR_INIT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741142));
pub const STATUS_DS_OBJ_CLASS_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741141));
pub const STATUS_DS_CANT_ON_NON_LEAF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741140));
pub const STATUS_DS_CANT_ON_RDN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741139));
pub const STATUS_DS_CANT_MOD_OBJ_CLASS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741138));
pub const STATUS_DS_CROSS_DOM_MOVE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741137));
pub const STATUS_DS_GC_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741136));
pub const STATUS_DIRECTORY_SERVICE_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741135));
pub const STATUS_REPARSE_ATTRIBUTE_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741134));
pub const STATUS_CANT_ENABLE_DENY_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741133));
pub const STATUS_FLOAT_MULTIPLE_FAULTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741132));
pub const STATUS_FLOAT_MULTIPLE_TRAPS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741131));
pub const STATUS_DEVICE_REMOVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741130));
pub const STATUS_JOURNAL_DELETE_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741129));
pub const STATUS_JOURNAL_NOT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741128));
pub const STATUS_NOINTERFACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741127));
pub const STATUS_DS_RIDMGR_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741126));
pub const STATUS_DS_ADMIN_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741119));
pub const STATUS_DRIVER_FAILED_SLEEP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741118));
pub const STATUS_MUTUAL_AUTHENTICATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741117));
pub const STATUS_CORRUPT_SYSTEM_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741116));
pub const STATUS_DATATYPE_MISALIGNMENT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741115));
pub const STATUS_WMI_READ_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741114));
pub const STATUS_WMI_SET_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741113));
pub const STATUS_COMMITMENT_MINIMUM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741112));
pub const STATUS_REG_NAT_CONSUMPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741111));
pub const STATUS_TRANSPORT_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741110));
pub const STATUS_DS_SAM_INIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741109));
pub const STATUS_ONLY_IF_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741108));
pub const STATUS_DS_SENSITIVE_GROUP_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741107));
pub const STATUS_PNP_RESTART_ENUMERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741106));
pub const STATUS_JOURNAL_ENTRY_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741105));
pub const STATUS_DS_CANT_MOD_PRIMARYGROUPID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741104));
pub const STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741103));
pub const STATUS_PNP_REBOOT_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741102));
pub const STATUS_POWER_STATE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741101));
pub const STATUS_DS_INVALID_GROUP_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741100));
pub const STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741099));
pub const STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741098));
pub const STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741097));
pub const STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741096));
pub const STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741095));
pub const STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741094));
pub const STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741093));
pub const STATUS_DS_HAVE_PRIMARY_MEMBERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741092));
pub const STATUS_WMI_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741091));
pub const STATUS_INSUFFICIENT_POWER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741090));
pub const STATUS_SAM_NEED_BOOTKEY_PASSWORD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741089));
pub const STATUS_SAM_NEED_BOOTKEY_FLOPPY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741088));
pub const STATUS_DS_CANT_START = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741087));
pub const STATUS_DS_INIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741086));
pub const STATUS_SAM_INIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741085));
pub const STATUS_DS_GC_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741084));
pub const STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741083));
pub const STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741082));
pub const STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741081));
pub const STATUS_MULTIPLE_FAULT_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741080));
pub const STATUS_CURRENT_DOMAIN_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741079));
pub const STATUS_CANNOT_MAKE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741078));
pub const STATUS_SYSTEM_SHUTDOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741077));
pub const STATUS_DS_INIT_FAILURE_CONSOLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741076));
pub const STATUS_DS_SAM_INIT_FAILURE_CONSOLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741075));
pub const STATUS_UNFINISHED_CONTEXT_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741074));
pub const STATUS_NO_TGT_REPLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741073));
pub const STATUS_OBJECTID_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741072));
pub const STATUS_NO_IP_ADDRESSES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741071));
pub const STATUS_WRONG_CREDENTIAL_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741070));
pub const STATUS_CRYPTO_SYSTEM_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741069));
pub const STATUS_MAX_REFERRALS_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741068));
pub const STATUS_MUST_BE_KDC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741067));
pub const STATUS_STRONG_CRYPTO_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741066));
pub const STATUS_TOO_MANY_PRINCIPALS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741065));
pub const STATUS_NO_PA_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741064));
pub const STATUS_PKINIT_NAME_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741063));
pub const STATUS_SMARTCARD_LOGON_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741062));
pub const STATUS_KDC_INVALID_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741061));
pub const STATUS_KDC_UNABLE_TO_REFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741060));
pub const STATUS_KDC_UNKNOWN_ETYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741059));
pub const STATUS_SHUTDOWN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741058));
pub const STATUS_SERVER_SHUTDOWN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741057));
pub const STATUS_NOT_SUPPORTED_ON_SBS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741056));
pub const STATUS_WMI_GUID_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741055));
pub const STATUS_WMI_ALREADY_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741054));
pub const STATUS_WMI_ALREADY_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741053));
pub const STATUS_MFT_TOO_FRAGMENTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741052));
pub const STATUS_COPY_PROTECTION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741051));
pub const STATUS_CSS_AUTHENTICATION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741050));
pub const STATUS_CSS_KEY_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741049));
pub const STATUS_CSS_KEY_NOT_ESTABLISHED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741048));
pub const STATUS_CSS_SCRAMBLED_SECTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741047));
pub const STATUS_CSS_REGION_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741046));
pub const STATUS_CSS_RESETS_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741045));
pub const STATUS_PASSWORD_CHANGE_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741044));
pub const STATUS_LOST_MODE_LOGON_RESTRICTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741043));
pub const STATUS_PKINIT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741024));
pub const STATUS_SMARTCARD_SUBSYSTEM_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741023));
pub const STATUS_NO_KERB_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073741022));
pub const STATUS_HOST_DOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740976));
pub const STATUS_UNSUPPORTED_PREAUTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740975));
pub const STATUS_EFS_ALG_BLOB_TOO_BIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740974));
pub const STATUS_PORT_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740973));
pub const STATUS_DEBUGGER_INACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740972));
pub const STATUS_DS_VERSION_CHECK_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740971));
pub const STATUS_AUDITING_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740970));
pub const STATUS_PRENT4_MACHINE_ACCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740969));
pub const STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740968));
pub const STATUS_INVALID_IMAGE_WIN_32 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740967));
pub const STATUS_INVALID_IMAGE_WIN_64 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740966));
pub const STATUS_BAD_BINDINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740965));
pub const STATUS_NETWORK_SESSION_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740964));
pub const STATUS_APPHELP_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740963));
pub const STATUS_ALL_SIDS_FILTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740962));
pub const STATUS_NOT_SAFE_MODE_DRIVER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740961));
pub const STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740959));
pub const STATUS_ACCESS_DISABLED_BY_POLICY_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740958));
pub const STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740957));
pub const STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740956));
pub const STATUS_FAILED_DRIVER_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740955));
pub const STATUS_DEVICE_ENUMERATION_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740954));
pub const STATUS_MOUNT_POINT_NOT_RESOLVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740952));
pub const STATUS_INVALID_DEVICE_OBJECT_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740951));
pub const STATUS_MCA_OCCURED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740950));
pub const STATUS_DRIVER_BLOCKED_CRITICAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740949));
pub const STATUS_DRIVER_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740948));
pub const STATUS_DRIVER_DATABASE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740947));
pub const STATUS_SYSTEM_HIVE_TOO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740946));
pub const STATUS_INVALID_IMPORT_OF_NON_DLL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740945));
pub const STATUS_DS_SHUTTING_DOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073742704));
pub const STATUS_NO_SECRETS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740943));
pub const STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740942));
pub const STATUS_FAILED_STACK_SWITCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740941));
pub const STATUS_HEAP_CORRUPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740940));
pub const STATUS_SMARTCARD_WRONG_PIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740928));
pub const STATUS_SMARTCARD_CARD_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740927));
pub const STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740926));
pub const STATUS_SMARTCARD_NO_CARD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740925));
pub const STATUS_SMARTCARD_NO_KEY_CONTAINER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740924));
pub const STATUS_SMARTCARD_NO_CERTIFICATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740923));
pub const STATUS_SMARTCARD_NO_KEYSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740922));
pub const STATUS_SMARTCARD_IO_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740921));
pub const STATUS_DOWNGRADE_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740920));
pub const STATUS_SMARTCARD_CERT_REVOKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740919));
pub const STATUS_ISSUING_CA_UNTRUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740918));
pub const STATUS_REVOCATION_OFFLINE_C = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740917));
pub const STATUS_PKINIT_CLIENT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740916));
pub const STATUS_SMARTCARD_CERT_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740915));
pub const STATUS_DRIVER_FAILED_PRIOR_UNLOAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740914));
pub const STATUS_SMARTCARD_SILENT_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740913));
pub const STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740799));
pub const STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740798));
pub const STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740797));
pub const STATUS_DS_NAME_NOT_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740796));
pub const STATUS_DS_DUPLICATE_ID_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740795));
pub const STATUS_DS_GROUP_CONVERSION_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740794));
pub const STATUS_VOLSNAP_PREPARE_HIBERNATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740793));
pub const STATUS_USER2USER_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740792));
pub const STATUS_STACK_BUFFER_OVERRUN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740791));
pub const STATUS_NO_S4U_PROT_SUPPORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740790));
pub const STATUS_CROSSREALM_DELEGATION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740789));
pub const STATUS_REVOCATION_OFFLINE_KDC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740788));
pub const STATUS_ISSUING_CA_UNTRUSTED_KDC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740787));
pub const STATUS_KDC_CERT_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740786));
pub const STATUS_KDC_CERT_REVOKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740785));
pub const STATUS_PARAMETER_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740784));
pub const STATUS_HIBERNATION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740783));
pub const STATUS_DELAY_LOAD_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740782));
pub const STATUS_AUTHENTICATION_FIREWALL_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740781));
pub const STATUS_VDM_DISALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740780));
pub const STATUS_HUNG_DISPLAY_DRIVER_THREAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740779));
pub const STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740778));
pub const STATUS_INVALID_CRUNTIME_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740777));
pub const STATUS_NTLM_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740776));
pub const STATUS_DS_SRC_SID_EXISTS_IN_FOREST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740775));
pub const STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740774));
pub const STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740773));
pub const STATUS_INVALID_USER_PRINCIPAL_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740772));
pub const STATUS_FATAL_USER_CALLBACK_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740771));
pub const STATUS_ASSERTION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740768));
pub const STATUS_VERIFIER_STOP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740767));
pub const STATUS_CALLBACK_POP_STACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740765));
pub const STATUS_INCOMPATIBLE_DRIVER_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740764));
pub const STATUS_HIVE_UNLOADED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740763));
pub const STATUS_COMPRESSION_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740762));
pub const STATUS_FILE_SYSTEM_LIMITATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740761));
pub const STATUS_INVALID_IMAGE_HASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740760));
pub const STATUS_NOT_CAPABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740759));
pub const STATUS_REQUEST_OUT_OF_SEQUENCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740758));
pub const STATUS_IMPLEMENTATION_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740757));
pub const STATUS_ELEVATION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740756));
pub const STATUS_NO_SECURITY_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740755));
pub const STATUS_PKU2U_CERT_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740753));
pub const STATUS_BEYOND_VDL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740750));
pub const STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740749));
pub const STATUS_PTE_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740748));
pub const STATUS_PURGE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740747));
pub const STATUS_CRED_REQUIRES_CONFIRMATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740736));
pub const STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740735));
pub const STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740734));
pub const STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740733));
pub const STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740732));
pub const STATUS_CS_ENCRYPTION_FILE_NOT_CSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740731));
pub const STATUS_INVALID_LABEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740730));
pub const STATUS_DRIVER_PROCESS_TERMINATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740720));
pub const STATUS_AMBIGUOUS_SYSTEM_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740719));
pub const STATUS_SYSTEM_DEVICE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740718));
pub const STATUS_RESTART_BOOT_APPLICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740717));
pub const STATUS_INSUFFICIENT_NVRAM_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740716));
pub const STATUS_INVALID_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740715));
pub const STATUS_THREAD_ALREADY_IN_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740714));
pub const STATUS_THREAD_NOT_IN_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740713));
pub const STATUS_INVALID_WEIGHT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740712));
pub const STATUS_REQUEST_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740711));
pub const STATUS_NO_RANGES_PROCESSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740704));
pub const STATUS_DISK_RESOURCES_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740703));
pub const STATUS_NEEDS_REMEDIATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740702));
pub const STATUS_DEVICE_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740701));
pub const STATUS_DEVICE_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740700));
pub const STATUS_INVALID_TOKEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740699));
pub const STATUS_SERVER_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740698));
pub const STATUS_FILE_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740697));
pub const STATUS_DEVICE_INSUFFICIENT_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740696));
pub const STATUS_PACKAGE_UPDATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740695));
pub const STATUS_NOT_READ_FROM_COPY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740694));
pub const STATUS_FT_WRITE_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740693));
pub const STATUS_FT_DI_SCAN_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740692));
pub const STATUS_OBJECT_NOT_EXTERNALLY_BACKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740691));
pub const STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740690));
pub const STATUS_COMPRESSION_NOT_BENEFICIAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740689));
pub const STATUS_DATA_CHECKSUM_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740688));
pub const STATUS_INTERMIXED_KERNEL_EA_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740687));
pub const STATUS_TRIM_READ_ZERO_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740686));
pub const STATUS_TOO_MANY_SEGMENT_DESCRIPTORS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740685));
pub const STATUS_INVALID_OFFSET_ALIGNMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740684));
pub const STATUS_INVALID_FIELD_IN_PARAMETER_LIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740683));
pub const STATUS_OPERATION_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740682));
pub const STATUS_INVALID_INITIATOR_TARGET_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740681));
pub const STATUS_SCRUB_DATA_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740680));
pub const STATUS_NOT_REDUNDANT_STORAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740679));
pub const STATUS_RESIDENT_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740678));
pub const STATUS_COMPRESSED_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740677));
pub const STATUS_DIRECTORY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740676));
pub const STATUS_IO_OPERATION_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740675));
pub const STATUS_SYSTEM_NEEDS_REMEDIATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740674));
pub const STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740673));
pub const STATUS_SHARE_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740672));
pub const STATUS_APISET_NOT_HOSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740671));
pub const STATUS_APISET_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740670));
pub const STATUS_DEVICE_HARDWARE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740669));
pub const STATUS_FIRMWARE_SLOT_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740668));
pub const STATUS_FIRMWARE_IMAGE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740667));
pub const STATUS_STORAGE_TOPOLOGY_ID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740666));
pub const STATUS_WIM_NOT_BOOTABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740665));
pub const STATUS_BLOCKED_BY_PARENTAL_CONTROLS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740664));
pub const STATUS_NEEDS_REGISTRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740663));
pub const STATUS_QUOTA_ACTIVITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740662));
pub const STATUS_CALLBACK_INVOKE_INLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740661));
pub const STATUS_BLOCK_TOO_MANY_REFERENCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740660));
pub const STATUS_MARKED_TO_DISALLOW_WRITES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740659));
pub const STATUS_NETWORK_ACCESS_DENIED_EDP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740658));
pub const STATUS_ENCLAVE_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740657));
pub const STATUS_PNP_NO_COMPAT_DRIVERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740656));
pub const STATUS_PNP_DRIVER_PACKAGE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740655));
pub const STATUS_PNP_DRIVER_CONFIGURATION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740654));
pub const STATUS_PNP_DRIVER_CONFIGURATION_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740653));
pub const STATUS_PNP_FUNCTION_DRIVER_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740652));
pub const STATUS_PNP_DEVICE_CONFIGURATION_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740651));
pub const STATUS_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740650));
pub const STATUS_PACKAGE_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740649));
pub const STATUS_DEVICE_IN_MAINTENANCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740647));
pub const STATUS_NOT_SUPPORTED_ON_DAX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740646));
pub const STATUS_FREE_SPACE_TOO_FRAGMENTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740645));
pub const STATUS_DAX_MAPPING_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740644));
pub const STATUS_CHILD_PROCESS_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740643));
pub const STATUS_STORAGE_LOST_DATA_PERSISTENCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740642));
pub const STATUS_VRF_CFG_AND_IO_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740641));
pub const STATUS_PARTITION_TERMINATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740640));
pub const STATUS_EXTERNAL_SYSKEY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740639));
pub const STATUS_ENCLAVE_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740638));
pub const STATUS_FILE_PROTECTED_UNDER_DPL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740637));
pub const STATUS_VOLUME_NOT_CLUSTER_ALIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740636));
pub const STATUS_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740635));
pub const STATUS_APPX_FILE_NOT_ENCRYPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740634));
pub const STATUS_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740633));
pub const STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740632));
pub const STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740631));
pub const STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740630));
pub const STATUS_FT_READ_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740629));
pub const STATUS_PATCH_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740628));
pub const STATUS_STORAGE_RESERVE_ID_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740627));
pub const STATUS_STORAGE_RESERVE_DOES_NOT_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740626));
pub const STATUS_STORAGE_RESERVE_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740625));
pub const STATUS_STORAGE_RESERVE_NOT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740624));
pub const STATUS_NOT_A_DAX_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740623));
pub const STATUS_NOT_DAX_MAPPABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740622));
pub const STATUS_CASE_DIFFERING_NAMES_IN_DIR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740621));
pub const STATUS_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740620));
pub const STATUS_NOT_SUPPORTED_WITH_BTT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740619));
pub const STATUS_ENCRYPTION_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740618));
pub const STATUS_ENCRYPTING_METADATA_DISALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740617));
pub const STATUS_CANT_CLEAR_ENCRYPTION_FLAG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740616));
pub const STATUS_UNSATISFIED_DEPENDENCIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740615));
pub const STATUS_CASE_SENSITIVE_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740614));
pub const STATUS_INVALID_TASK_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740544));
pub const STATUS_INVALID_TASK_INDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740543));
pub const STATUS_THREAD_ALREADY_IN_TASK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740542));
pub const STATUS_CALLBACK_BYPASS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740541));
pub const STATUS_UNDEFINED_SCOPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740540));
pub const STATUS_INVALID_CAP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740539));
pub const STATUS_NOT_GUI_PROCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740538));
pub const STATUS_DEVICE_HUNG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740537));
pub const STATUS_CONTAINER_ASSIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740536));
pub const STATUS_JOB_NO_CONTAINER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740535));
pub const STATUS_DEVICE_UNRESPONSIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740534));
pub const STATUS_REPARSE_POINT_ENCOUNTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740533));
pub const STATUS_ATTRIBUTE_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740532));
pub const STATUS_NOT_A_TIERED_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740531));
pub const STATUS_ALREADY_HAS_STREAM_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740530));
pub const STATUS_JOB_NOT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740529));
pub const STATUS_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740528));
pub const STATUS_ENCLAVE_NOT_TERMINATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740527));
pub const STATUS_ENCLAVE_IS_TERMINATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740526));
pub const STATUS_SMB1_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740525));
pub const STATUS_SMR_GARBAGE_COLLECTION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740524));
pub const STATUS_INTERRUPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740523));
pub const STATUS_THREAD_NOT_RUNNING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740522));
pub const STATUS_FAIL_FAST_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740286));
pub const STATUS_IMAGE_CERT_REVOKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740285));
pub const STATUS_DYNAMIC_CODE_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740284));
pub const STATUS_IMAGE_CERT_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740283));
pub const STATUS_STRICT_CFG_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740282));
pub const STATUS_SET_CONTEXT_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740278));
pub const STATUS_CROSS_PARTITION_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740277));
pub const STATUS_PORT_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740032));
pub const STATUS_MESSAGE_LOST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740031));
pub const STATUS_INVALID_MESSAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740030));
pub const STATUS_REQUEST_CANCELED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740029));
pub const STATUS_RECURSIVE_DISPATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740028));
pub const STATUS_LPC_RECEIVE_BUFFER_EXPECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740027));
pub const STATUS_LPC_INVALID_CONNECTION_USAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740026));
pub const STATUS_LPC_REQUESTS_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740025));
pub const STATUS_RESOURCE_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740024));
pub const STATUS_HARDWARE_MEMORY_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740023));
pub const STATUS_THREADPOOL_HANDLE_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740022));
pub const STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740021));
pub const STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740020));
pub const STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740019));
pub const STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740018));
pub const STATUS_THREADPOOL_RELEASED_DURING_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740017));
pub const STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740016));
pub const STATUS_APC_RETURNED_WHILE_IMPERSONATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740015));
pub const STATUS_PROCESS_IS_PROTECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740014));
pub const STATUS_MCA_EXCEPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740013));
pub const STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740012));
pub const STATUS_SYMLINK_CLASS_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740011));
pub const STATUS_INVALID_IDN_NORMALIZATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740010));
pub const STATUS_NO_UNICODE_TRANSLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740009));
pub const STATUS_ALREADY_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740008));
pub const STATUS_CONTEXT_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740007));
pub const STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740006));
pub const STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740005));
pub const STATUS_INVALID_THREAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740004));
pub const STATUS_CALLBACK_RETURNED_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740003));
pub const STATUS_CALLBACK_RETURNED_LDR_LOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740002));
pub const STATUS_CALLBACK_RETURNED_LANG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740001));
pub const STATUS_CALLBACK_RETURNED_PRI_BACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073740000));
pub const STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739999));
pub const STATUS_LPC_HANDLE_COUNT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739998));
pub const STATUS_EXECUTABLE_MEMORY_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739997));
pub const STATUS_KERNEL_EXECUTABLE_MEMORY_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739996));
pub const STATUS_ATTACHED_EXECUTABLE_MEMORY_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739995));
pub const STATUS_TRIGGERED_EXECUTABLE_MEMORY_WRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739994));
pub const STATUS_DISK_REPAIR_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739776));
pub const STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739775));
pub const STATUS_DISK_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739774));
pub const STATUS_DATA_LOST_REPAIR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147481597));
pub const STATUS_CONTENT_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739772));
pub const STATUS_BAD_CLUSTERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739771));
pub const STATUS_VOLUME_DIRTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739770));
pub const STATUS_DISK_REPAIR_REDIRECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073743879));
pub const STATUS_DISK_REPAIR_UNSUCCESSFUL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739768));
pub const STATUS_CORRUPT_LOG_OVERFULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739767));
pub const STATUS_CORRUPT_LOG_CORRUPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739766));
pub const STATUS_CORRUPT_LOG_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739765));
pub const STATUS_CORRUPT_LOG_DELETED_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739764));
pub const STATUS_CORRUPT_LOG_CLEARED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739763));
pub const STATUS_ORPHAN_NAME_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739762));
pub const STATUS_PROACTIVE_SCAN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739761));
pub const STATUS_ENCRYPTED_IO_NOT_POSSIBLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739760));
pub const STATUS_CORRUPT_LOG_UPLEVEL_RECORDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739759));
pub const STATUS_FILE_CHECKED_OUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739519));
pub const STATUS_CHECKOUT_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739518));
pub const STATUS_BAD_FILE_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739517));
pub const STATUS_FILE_TOO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739516));
pub const STATUS_FORMS_AUTH_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739515));
pub const STATUS_VIRUS_INFECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739514));
pub const STATUS_VIRUS_DELETED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739513));
pub const STATUS_BAD_MCFG_TABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739512));
pub const STATUS_CANNOT_BREAK_OPLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739511));
pub const STATUS_BAD_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739510));
pub const STATUS_BAD_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739509));
pub const STATUS_NO_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739508));
pub const STATUS_FILE_HANDLE_REVOKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073739504));
pub const STATUS_WOW_ASSERTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073702760));
pub const STATUS_INVALID_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700864));
pub const STATUS_HMAC_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700863));
pub const STATUS_AUTH_TAG_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700862));
pub const STATUS_INVALID_STATE_TRANSITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700861));
pub const STATUS_INVALID_KERNEL_INFO_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700860));
pub const STATUS_INVALID_PEP_INFO_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700859));
pub const STATUS_HANDLE_REVOKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700858));
pub const STATUS_EOF_ON_GHOSTED_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700857));
pub const STATUS_CC_NEEDS_CALLBACK_SECTION_DRAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700856));
pub const STATUS_IPSEC_QUEUE_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700848));
pub const STATUS_ND_QUEUE_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700847));
pub const STATUS_HOPLIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700846));
pub const STATUS_PROTOCOL_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700845));
pub const STATUS_FASTPATH_REJECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700844));
pub const STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700736));
pub const STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700735));
pub const STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700734));
pub const STATUS_XML_PARSE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700733));
pub const STATUS_XMLDSIG_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700732));
pub const STATUS_WRONG_COMPARTMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700731));
pub const STATUS_AUTHIP_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700730));
pub const STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700729));
pub const STATUS_DS_OID_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700728));
pub const STATUS_INCORRECT_ACCOUNT_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700727));
pub const STATUS_HASH_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700608));
pub const STATUS_HASH_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700607));
pub const STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700575));
pub const STATUS_GPIO_CLIENT_INFORMATION_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700574));
pub const STATUS_GPIO_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700573));
pub const STATUS_GPIO_INVALID_REGISTRATION_PACKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700572));
pub const STATUS_GPIO_OPERATION_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700571));
pub const STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700570));
pub const STATUS_GPIO_INTERRUPT_ALREADY_UNMASKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147442393));
pub const STATUS_CANNOT_SWITCH_RUNLEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700543));
pub const STATUS_INVALID_RUNLEVEL_SETTING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700542));
pub const STATUS_RUNLEVEL_SWITCH_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700541));
pub const STATUS_SERVICES_FAILED_AUTOSTART = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073783108));
pub const STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700539));
pub const STATUS_RUNLEVEL_SWITCH_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700538));
pub const STATUS_NOT_APPCONTAINER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700352));
pub const STATUS_NOT_SUPPORTED_IN_APPCONTAINER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700351));
pub const STATUS_INVALID_PACKAGE_SID_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700350));
pub const STATUS_LPAC_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700349));
pub const STATUS_ADMINLESS_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700348));
pub const STATUS_APP_DATA_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700223));
pub const STATUS_APP_DATA_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700222));
pub const STATUS_APP_DATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700221));
pub const STATUS_APP_DATA_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700220));
pub const STATUS_APP_DATA_REBOOT_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700219));
pub const STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700191));
pub const STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700190));
pub const STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700189));
pub const STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700188));
pub const STATUS_WOF_WIM_HEADER_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700187));
pub const STATUS_WOF_WIM_RESOURCE_TABLE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700186));
pub const STATUS_WOF_FILE_RESOURCE_TABLE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073700185));
pub const STATUS_CIMFS_IMAGE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073692671));
pub const STATUS_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073689087));
pub const STATUS_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073689086));
pub const STATUS_FILE_SYSTEM_VIRTUALIZATION_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073689085));
pub const STATUS_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073689084));
pub const STATUS_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073689083));
pub const STATUS_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688832));
pub const STATUS_CLOUD_FILE_PROVIDER_NOT_RUNNING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688831));
pub const STATUS_CLOUD_FILE_METADATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688830));
pub const STATUS_CLOUD_FILE_METADATA_TOO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688829));
pub const STATUS_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147430652));
pub const STATUS_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2147430651));
pub const STATUS_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688826));
pub const STATUS_NOT_A_CLOUD_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688825));
pub const STATUS_CLOUD_FILE_NOT_IN_SYNC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688824));
pub const STATUS_CLOUD_FILE_ALREADY_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688823));
pub const STATUS_CLOUD_FILE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688822));
pub const STATUS_CLOUD_FILE_INVALID_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688821));
pub const STATUS_CLOUD_FILE_READ_ONLY_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688820));
pub const STATUS_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688819));
pub const STATUS_CLOUD_FILE_VALIDATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688818));
pub const STATUS_CLOUD_FILE_AUTHENTICATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688817));
pub const STATUS_CLOUD_FILE_INSUFFICIENT_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688816));
pub const STATUS_CLOUD_FILE_NETWORK_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688815));
pub const STATUS_CLOUD_FILE_UNSUCCESSFUL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688814));
pub const STATUS_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688813));
pub const STATUS_CLOUD_FILE_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688812));
pub const STATUS_CLOUD_FILE_PINNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688811));
pub const STATUS_CLOUD_FILE_REQUEST_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688810));
pub const STATUS_CLOUD_FILE_PROPERTY_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688809));
pub const STATUS_CLOUD_FILE_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688808));
pub const STATUS_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688807));
pub const STATUS_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688806));
pub const STATUS_CLOUD_FILE_REQUEST_CANCELED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688805));
pub const STATUS_CLOUD_FILE_PROVIDER_TERMINATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688803));
pub const STATUS_NOT_A_CLOUD_SYNC_ROOT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688802));
pub const STATUS_CLOUD_FILE_REQUEST_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688801));
pub const STATUS_CLOUD_FILE_DEHYDRATION_DISALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073688800));
pub const STATUS_FILE_SNAP_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679104));
pub const STATUS_FILE_SNAP_USER_SECTION_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679103));
pub const STATUS_FILE_SNAP_MODIFY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679102));
pub const STATUS_FILE_SNAP_IO_NOT_COORDINATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679101));
pub const STATUS_FILE_SNAP_UNEXPECTED_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679100));
pub const STATUS_FILE_SNAP_INVALID_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073679099));
pub const DBG_NO_STATE_CHANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073676287));
pub const DBG_APP_NOT_IDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073676286));
pub const RPC_NT_INVALID_STRING_BINDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610751));
pub const RPC_NT_WRONG_KIND_OF_BINDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610750));
pub const RPC_NT_INVALID_BINDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610749));
pub const RPC_NT_PROTSEQ_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610748));
pub const RPC_NT_INVALID_RPC_PROTSEQ = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610747));
pub const RPC_NT_INVALID_STRING_UUID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610746));
pub const RPC_NT_INVALID_ENDPOINT_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610745));
pub const RPC_NT_INVALID_NET_ADDR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610744));
pub const RPC_NT_NO_ENDPOINT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610743));
pub const RPC_NT_INVALID_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610742));
pub const RPC_NT_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610741));
pub const RPC_NT_ALREADY_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610740));
pub const RPC_NT_TYPE_ALREADY_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610739));
pub const RPC_NT_ALREADY_LISTENING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610738));
pub const RPC_NT_NO_PROTSEQS_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610737));
pub const RPC_NT_NOT_LISTENING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610736));
pub const RPC_NT_UNKNOWN_MGR_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610735));
pub const RPC_NT_UNKNOWN_IF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610734));
pub const RPC_NT_NO_BINDINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610733));
pub const RPC_NT_NO_PROTSEQS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610732));
pub const RPC_NT_CANT_CREATE_ENDPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610731));
pub const RPC_NT_OUT_OF_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610730));
pub const RPC_NT_SERVER_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610729));
pub const RPC_NT_SERVER_TOO_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610728));
pub const RPC_NT_INVALID_NETWORK_OPTIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610727));
pub const RPC_NT_NO_CALL_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610726));
pub const RPC_NT_CALL_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610725));
pub const RPC_NT_CALL_FAILED_DNE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610724));
pub const RPC_NT_PROTOCOL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610723));
pub const RPC_NT_UNSUPPORTED_TRANS_SYN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610721));
pub const RPC_NT_UNSUPPORTED_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610719));
pub const RPC_NT_INVALID_TAG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610718));
pub const RPC_NT_INVALID_BOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610717));
pub const RPC_NT_NO_ENTRY_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610716));
pub const RPC_NT_INVALID_NAME_SYNTAX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610715));
pub const RPC_NT_UNSUPPORTED_NAME_SYNTAX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610714));
pub const RPC_NT_UUID_NO_ADDRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610712));
pub const RPC_NT_DUPLICATE_ENDPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610711));
pub const RPC_NT_UNKNOWN_AUTHN_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610710));
pub const RPC_NT_MAX_CALLS_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610709));
pub const RPC_NT_STRING_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610708));
pub const RPC_NT_PROTSEQ_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610707));
pub const RPC_NT_PROCNUM_OUT_OF_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610706));
pub const RPC_NT_BINDING_HAS_NO_AUTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610705));
pub const RPC_NT_UNKNOWN_AUTHN_SERVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610704));
pub const RPC_NT_UNKNOWN_AUTHN_LEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610703));
pub const RPC_NT_INVALID_AUTH_IDENTITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610702));
pub const RPC_NT_UNKNOWN_AUTHZ_SERVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610701));
pub const EPT_NT_INVALID_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610700));
pub const EPT_NT_CANT_PERFORM_OP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610699));
pub const EPT_NT_NOT_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610698));
pub const RPC_NT_NOTHING_TO_EXPORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610697));
pub const RPC_NT_INCOMPLETE_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610696));
pub const RPC_NT_INVALID_VERS_OPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610695));
pub const RPC_NT_NO_MORE_MEMBERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610694));
pub const RPC_NT_NOT_ALL_OBJS_UNEXPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610693));
pub const RPC_NT_INTERFACE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610692));
pub const RPC_NT_ENTRY_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610691));
pub const RPC_NT_ENTRY_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610690));
pub const RPC_NT_NAME_SERVICE_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610689));
pub const RPC_NT_INVALID_NAF_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610688));
pub const RPC_NT_CANNOT_SUPPORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610687));
pub const RPC_NT_NO_CONTEXT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610686));
pub const RPC_NT_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610685));
pub const RPC_NT_ZERO_DIVIDE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610684));
pub const RPC_NT_ADDRESS_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610683));
pub const RPC_NT_FP_DIV_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610682));
pub const RPC_NT_FP_UNDERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610681));
pub const RPC_NT_FP_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610680));
pub const RPC_NT_NO_MORE_ENTRIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545215));
pub const RPC_NT_SS_CHAR_TRANS_OPEN_FAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545214));
pub const RPC_NT_SS_CHAR_TRANS_SHORT_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545213));
pub const RPC_NT_SS_IN_NULL_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545212));
pub const RPC_NT_SS_CONTEXT_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545211));
pub const RPC_NT_SS_CONTEXT_DAMAGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545210));
pub const RPC_NT_SS_HANDLES_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545209));
pub const RPC_NT_SS_CANNOT_GET_CALL_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545208));
pub const RPC_NT_NULL_REF_POINTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545207));
pub const RPC_NT_ENUM_VALUE_OUT_OF_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545206));
pub const RPC_NT_BYTE_COUNT_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545205));
pub const RPC_NT_BAD_STUB_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545204));
pub const RPC_NT_CALL_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610679));
pub const RPC_NT_NO_MORE_BINDINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610678));
pub const RPC_NT_GROUP_MEMBER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610677));
pub const EPT_NT_CANT_CREATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610676));
pub const RPC_NT_INVALID_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610675));
pub const RPC_NT_NO_INTERFACES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610673));
pub const RPC_NT_CALL_CANCELLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610672));
pub const RPC_NT_BINDING_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610671));
pub const RPC_NT_COMM_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610670));
pub const RPC_NT_UNSUPPORTED_AUTHN_LEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610669));
pub const RPC_NT_NO_PRINC_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610668));
pub const RPC_NT_NOT_RPC_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610667));
pub const RPC_NT_UUID_LOCAL_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073872982));
pub const RPC_NT_SEC_PKG_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610665));
pub const RPC_NT_NOT_CANCELLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610664));
pub const RPC_NT_INVALID_ES_ACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545127));
pub const RPC_NT_WRONG_ES_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545126));
pub const RPC_NT_WRONG_STUB_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545125));
pub const RPC_NT_INVALID_PIPE_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545124));
pub const RPC_NT_INVALID_PIPE_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545123));
pub const RPC_NT_WRONG_PIPE_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545122));
pub const RPC_NT_PIPE_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545121));
pub const RPC_NT_PIPE_DISCIPLINE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545120));
pub const RPC_NT_PIPE_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073545119));
pub const RPC_NT_INVALID_ASYNC_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610654));
pub const RPC_NT_INVALID_ASYNC_CALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610653));
pub const RPC_NT_PROXY_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610652));
pub const RPC_NT_COOKIE_AUTH_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073610651));
pub const RPC_NT_SEND_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1073873071));
pub const STATUS_ACPI_INVALID_OPCODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431103));
pub const STATUS_ACPI_STACK_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431102));
pub const STATUS_ACPI_ASSERT_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431101));
pub const STATUS_ACPI_INVALID_INDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431100));
pub const STATUS_ACPI_INVALID_ARGUMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431099));
pub const STATUS_ACPI_FATAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431098));
pub const STATUS_ACPI_INVALID_SUPERNAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431097));
pub const STATUS_ACPI_INVALID_ARGTYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431096));
pub const STATUS_ACPI_INVALID_OBJTYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431095));
pub const STATUS_ACPI_INVALID_TARGETTYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431094));
pub const STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431093));
pub const STATUS_ACPI_ADDRESS_NOT_MAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431092));
pub const STATUS_ACPI_INVALID_EVENTTYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431091));
pub const STATUS_ACPI_HANDLER_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431090));
pub const STATUS_ACPI_INVALID_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431089));
pub const STATUS_ACPI_INVALID_REGION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431088));
pub const STATUS_ACPI_INVALID_ACCESS_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431087));
pub const STATUS_ACPI_ACQUIRE_GLOBAL_LOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431086));
pub const STATUS_ACPI_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431085));
pub const STATUS_ACPI_NOT_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431084));
pub const STATUS_ACPI_INVALID_MUTEX_LEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431083));
pub const STATUS_ACPI_MUTEX_NOT_OWNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431082));
pub const STATUS_ACPI_MUTEX_NOT_OWNER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431081));
pub const STATUS_ACPI_RS_ACCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431080));
pub const STATUS_ACPI_INVALID_TABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431079));
pub const STATUS_ACPI_REG_HANDLER_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431072));
pub const STATUS_ACPI_POWER_REQUEST_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072431071));
pub const STATUS_CTX_WINSTATION_NAME_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086463));
pub const STATUS_CTX_INVALID_PD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086462));
pub const STATUS_CTX_PD_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086461));
pub const STATUS_CTX_CDM_CONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1074397188));
pub const STATUS_CTX_CDM_DISCONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1074397189));
pub const STATUS_CTX_CLOSE_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086458));
pub const STATUS_CTX_NO_OUTBUF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086457));
pub const STATUS_CTX_MODEM_INF_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086456));
pub const STATUS_CTX_INVALID_MODEMNAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086455));
pub const STATUS_CTX_RESPONSE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086454));
pub const STATUS_CTX_MODEM_RESPONSE_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086453));
pub const STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086452));
pub const STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086451));
pub const STATUS_CTX_MODEM_RESPONSE_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086450));
pub const STATUS_CTX_MODEM_RESPONSE_VOICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086449));
pub const STATUS_CTX_TD_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086448));
pub const STATUS_CTX_LICENSE_CLIENT_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086446));
pub const STATUS_CTX_LICENSE_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086445));
pub const STATUS_CTX_LICENSE_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086444));
pub const STATUS_CTX_WINSTATION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086443));
pub const STATUS_CTX_WINSTATION_NAME_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086442));
pub const STATUS_CTX_WINSTATION_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086441));
pub const STATUS_CTX_BAD_VIDEO_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086440));
pub const STATUS_CTX_GRAPHICS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086430));
pub const STATUS_CTX_NOT_CONSOLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086428));
pub const STATUS_CTX_CLIENT_QUERY_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086426));
pub const STATUS_CTX_CONSOLE_DISCONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086425));
pub const STATUS_CTX_CONSOLE_CONNECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086424));
pub const STATUS_CTX_SHADOW_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086422));
pub const STATUS_CTX_WINSTATION_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086421));
pub const STATUS_CTX_INVALID_WD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086418));
pub const STATUS_CTX_WD_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086417));
pub const STATUS_CTX_SHADOW_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086416));
pub const STATUS_CTX_SHADOW_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086415));
pub const STATUS_RDP_PROTOCOL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086414));
pub const STATUS_CTX_CLIENT_LICENSE_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086413));
pub const STATUS_CTX_CLIENT_LICENSE_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086412));
pub const STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086411));
pub const STATUS_CTX_SHADOW_NOT_RUNNING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086410));
pub const STATUS_CTX_LOGON_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086409));
pub const STATUS_CTX_SECURITY_LAYER_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086408));
pub const STATUS_TS_INCOMPATIBLE_SESSIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086407));
pub const STATUS_TS_VIDEO_SUBSYSTEM_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073086406));
pub const STATUS_PNP_BAD_MPS_TABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073479627));
pub const STATUS_PNP_TRANSLATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073479626));
pub const STATUS_PNP_IRQ_TRANSLATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073479625));
pub const STATUS_PNP_INVALID_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073479624));
pub const STATUS_IO_REISSUE_AS_CACHED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073479623));
pub const STATUS_MUI_FILE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020927));
pub const STATUS_MUI_INVALID_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020926));
pub const STATUS_MUI_INVALID_RC_CONFIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020925));
pub const STATUS_MUI_INVALID_LOCALE_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020924));
pub const STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020923));
pub const STATUS_MUI_FILE_NOT_LOADED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020922));
pub const STATUS_RESOURCE_ENUM_USER_STOP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1073020921));
pub const STATUS_FLT_NO_HANDLER_DEFINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906815));
pub const STATUS_FLT_CONTEXT_ALREADY_DEFINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906814));
pub const STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906813));
pub const STATUS_FLT_DISALLOW_FAST_IO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906812));
pub const STATUS_FLT_INVALID_NAME_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906811));
pub const STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906810));
pub const STATUS_FLT_NOT_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906809));
pub const STATUS_FLT_FILTER_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906808));
pub const STATUS_FLT_POST_OPERATION_CLEANUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906807));
pub const STATUS_FLT_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906806));
pub const STATUS_FLT_DELETING_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906805));
pub const STATUS_FLT_MUST_BE_NONPAGED_POOL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906804));
pub const STATUS_FLT_DUPLICATE_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906803));
pub const STATUS_FLT_CBDQ_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906802));
pub const STATUS_FLT_DO_NOT_ATTACH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906801));
pub const STATUS_FLT_DO_NOT_DETACH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906800));
pub const STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906799));
pub const STATUS_FLT_INSTANCE_NAME_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906798));
pub const STATUS_FLT_FILTER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906797));
pub const STATUS_FLT_VOLUME_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906796));
pub const STATUS_FLT_INSTANCE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906795));
pub const STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906794));
pub const STATUS_FLT_INVALID_CONTEXT_REGISTRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906793));
pub const STATUS_FLT_NAME_CACHE_MISS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906792));
pub const STATUS_FLT_NO_DEVICE_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906791));
pub const STATUS_FLT_VOLUME_ALREADY_MOUNTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906790));
pub const STATUS_FLT_ALREADY_ENLISTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906789));
pub const STATUS_FLT_CONTEXT_ALREADY_LINKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906788));
pub const STATUS_FLT_NO_WAITER_FOR_REPLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906784));
pub const STATUS_FLT_REGISTRATION_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071906781));
pub const STATUS_SXS_SECTION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365567));
pub const STATUS_SXS_CANT_GEN_ACTCTX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365566));
pub const STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365565));
pub const STATUS_SXS_ASSEMBLY_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365564));
pub const STATUS_SXS_MANIFEST_FORMAT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365563));
pub const STATUS_SXS_MANIFEST_PARSE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365562));
pub const STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365561));
pub const STATUS_SXS_KEY_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365560));
pub const STATUS_SXS_VERSION_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365559));
pub const STATUS_SXS_WRONG_SECTION_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365558));
pub const STATUS_SXS_THREAD_QUERIES_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365557));
pub const STATUS_SXS_ASSEMBLY_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365556));
pub const STATUS_SXS_RELEASE_ACTIVATION_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075118093));
pub const STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365554));
pub const STATUS_SXS_EARLY_DEACTIVATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365553));
pub const STATUS_SXS_INVALID_DEACTIVATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365552));
pub const STATUS_SXS_MULTIPLE_DEACTIVATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365551));
pub const STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365550));
pub const STATUS_SXS_PROCESS_TERMINATION_REQUESTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365549));
pub const STATUS_SXS_CORRUPT_ACTIVATION_STACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365548));
pub const STATUS_SXS_CORRUPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365547));
pub const STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365546));
pub const STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365545));
pub const STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365544));
pub const STATUS_SXS_IDENTITY_PARSE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365543));
pub const STATUS_SXS_COMPONENT_STORE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365542));
pub const STATUS_SXS_FILE_HASH_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365541));
pub const STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365540));
pub const STATUS_SXS_IDENTITIES_DIFFERENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365539));
pub const STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365538));
pub const STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365537));
pub const STATUS_ADVANCED_INSTALLER_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365536));
pub const STATUS_XML_ENCODING_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365535));
pub const STATUS_SXS_MANIFEST_TOO_BIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365534));
pub const STATUS_SXS_SETTING_NOT_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365533));
pub const STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365532));
pub const STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365531));
pub const STATUS_GENERIC_COMMAND_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365530));
pub const STATUS_SXS_FILE_HASH_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072365529));
pub const STATUS_CLUSTER_INVALID_NODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496639));
pub const STATUS_CLUSTER_NODE_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496638));
pub const STATUS_CLUSTER_JOIN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496637));
pub const STATUS_CLUSTER_NODE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496636));
pub const STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496635));
pub const STATUS_CLUSTER_NETWORK_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496634));
pub const STATUS_CLUSTER_NETWORK_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496633));
pub const STATUS_CLUSTER_NETINTERFACE_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496632));
pub const STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496631));
pub const STATUS_CLUSTER_INVALID_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496630));
pub const STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496629));
pub const STATUS_CLUSTER_NODE_DOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496628));
pub const STATUS_CLUSTER_NODE_UNREACHABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496627));
pub const STATUS_CLUSTER_NODE_NOT_MEMBER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496626));
pub const STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496625));
pub const STATUS_CLUSTER_INVALID_NETWORK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496624));
pub const STATUS_CLUSTER_NO_NET_ADAPTERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496623));
pub const STATUS_CLUSTER_NODE_UP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496622));
pub const STATUS_CLUSTER_NODE_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496621));
pub const STATUS_CLUSTER_NODE_NOT_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496620));
pub const STATUS_CLUSTER_NO_SECURITY_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496619));
pub const STATUS_CLUSTER_NETWORK_NOT_INTERNAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496618));
pub const STATUS_CLUSTER_POISONED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496617));
pub const STATUS_CLUSTER_NON_CSV_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496616));
pub const STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496615));
pub const STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496608));
pub const STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496607));
pub const STATUS_CLUSTER_CSV_REDIRECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496606));
pub const STATUS_CLUSTER_CSV_NOT_REDIRECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496605));
pub const STATUS_CLUSTER_CSV_VOLUME_DRAINING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496604));
pub const STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496603));
pub const STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496602));
pub const STATUS_CLUSTER_CSV_NO_SNAPSHOTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496601));
pub const STATUS_CSV_IO_PAUSE_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496600));
pub const STATUS_CLUSTER_CSV_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496599));
pub const STATUS_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496592));
pub const STATUS_CLUSTER_CAM_TICKET_REPLAY_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072496591));
pub const STATUS_TRANSACTIONAL_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103423));
pub const STATUS_INVALID_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103422));
pub const STATUS_TRANSACTION_NOT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103421));
pub const STATUS_TM_INITIALIZATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103420));
pub const STATUS_RM_NOT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103419));
pub const STATUS_RM_METADATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103418));
pub const STATUS_TRANSACTION_NOT_JOINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103417));
pub const STATUS_DIRECTORY_NOT_RM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103416));
pub const STATUS_COULD_NOT_RESIZE_LOG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145845239));
pub const STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103414));
pub const STATUS_LOG_RESIZE_INVALID_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103413));
pub const STATUS_REMOTE_FILE_VERSION_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103412));
pub const STATUS_CRM_PROTOCOL_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103409));
pub const STATUS_TRANSACTION_PROPAGATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103408));
pub const STATUS_CRM_PROTOCOL_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103407));
pub const STATUS_TRANSACTION_SUPERIOR_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103406));
pub const STATUS_TRANSACTION_REQUEST_NOT_VALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103405));
pub const STATUS_TRANSACTION_NOT_REQUESTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103404));
pub const STATUS_TRANSACTION_ALREADY_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103403));
pub const STATUS_TRANSACTION_ALREADY_COMMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103402));
pub const STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103401));
pub const STATUS_CURRENT_TRANSACTION_NOT_VALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103400));
pub const STATUS_LOG_GROWTH_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103399));
pub const STATUS_OBJECT_NO_LONGER_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103391));
pub const STATUS_STREAM_MINIVERSION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103390));
pub const STATUS_STREAM_MINIVERSION_NOT_VALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103389));
pub const STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103388));
pub const STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103387));
pub const STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103386));
pub const STATUS_HANDLE_NO_LONGER_VALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103384));
pub const STATUS_NO_TXF_METADATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145845207));
pub const STATUS_LOG_CORRUPTION_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103376));
pub const STATUS_CANT_RECOVER_WITH_HANDLE_OPEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145845199));
pub const STATUS_RM_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103374));
pub const STATUS_ENLISTMENT_NOT_SUPERIOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103373));
pub const STATUS_RECOVERY_NOT_NEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075380276));
pub const STATUS_RM_ALREADY_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075380277));
pub const STATUS_FILE_IDENTITY_NOT_PERSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103370));
pub const STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103369));
pub const STATUS_CANT_CROSS_RM_BOUNDARY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103368));
pub const STATUS_TXF_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103367));
pub const STATUS_INDOUBT_TRANSACTIONS_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103366));
pub const STATUS_TM_VOLATILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103365));
pub const STATUS_ROLLBACK_TIMER_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103364));
pub const STATUS_TXF_ATTRIBUTE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103363));
pub const STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103362));
pub const STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103361));
pub const STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103360));
pub const STATUS_TXF_METADATA_ALREADY_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145845183));
pub const STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145845182));
pub const STATUS_TRANSACTION_REQUIRED_PROMOTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103357));
pub const STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103356));
pub const STATUS_TRANSACTIONS_NOT_FROZEN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103355));
pub const STATUS_TRANSACTION_FREEZE_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103354));
pub const STATUS_NOT_SNAPSHOT_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103353));
pub const STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103352));
pub const STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103351));
pub const STATUS_TM_IDENTITY_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103350));
pub const STATUS_FLOATED_SECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103349));
pub const STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103348));
pub const STATUS_CANNOT_ABORT_TRANSACTIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103347));
pub const STATUS_TRANSACTION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103346));
pub const STATUS_RESOURCEMANAGER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103345));
pub const STATUS_ENLISTMENT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103344));
pub const STATUS_TRANSACTIONMANAGER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103343));
pub const STATUS_TRANSACTIONMANAGER_NOT_ONLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103342));
pub const STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103341));
pub const STATUS_TRANSACTION_NOT_ROOT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103340));
pub const STATUS_TRANSACTION_OBJECT_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103339));
pub const STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103338));
pub const STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103337));
pub const STATUS_TRANSACTION_RECORD_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103336));
pub const STATUS_NO_LINK_TRACKING_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103335));
pub const STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103334));
pub const STATUS_TRANSACTION_INTEGRITY_VIOLATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103333));
pub const STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103332));
pub const STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103331));
pub const STATUS_TRANSACTION_MUST_WRITETHROUGH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103330));
pub const STATUS_TRANSACTION_NO_SUPERIOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103329));
pub const STATUS_EXPIRED_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103328));
pub const STATUS_TRANSACTION_NOT_ENLISTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072103327));
pub const STATUS_LOG_SECTOR_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037887));
pub const STATUS_LOG_SECTOR_PARITY_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037886));
pub const STATUS_LOG_SECTOR_REMAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037885));
pub const STATUS_LOG_BLOCK_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037884));
pub const STATUS_LOG_INVALID_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037883));
pub const STATUS_LOG_BLOCKS_EXHAUSTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037882));
pub const STATUS_LOG_READ_CONTEXT_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037881));
pub const STATUS_LOG_RESTART_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037880));
pub const STATUS_LOG_BLOCK_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037879));
pub const STATUS_LOG_BLOCK_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037878));
pub const STATUS_LOG_READ_MODE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037877));
pub const STATUS_LOG_NO_RESTART = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075445772));
pub const STATUS_LOG_METADATA_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037875));
pub const STATUS_LOG_METADATA_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037874));
pub const STATUS_LOG_METADATA_INCONSISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037873));
pub const STATUS_LOG_RESERVATION_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037872));
pub const STATUS_LOG_CANT_DELETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037871));
pub const STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037870));
pub const STATUS_LOG_START_OF_LOG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037869));
pub const STATUS_LOG_POLICY_ALREADY_INSTALLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037868));
pub const STATUS_LOG_POLICY_NOT_INSTALLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037867));
pub const STATUS_LOG_POLICY_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037866));
pub const STATUS_LOG_POLICY_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037865));
pub const STATUS_LOG_PINNED_ARCHIVE_TAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037864));
pub const STATUS_LOG_RECORD_NONEXISTENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037863));
pub const STATUS_LOG_RECORDS_RESERVED_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037862));
pub const STATUS_LOG_SPACE_RESERVED_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037861));
pub const STATUS_LOG_TAIL_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037860));
pub const STATUS_LOG_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037859));
pub const STATUS_LOG_MULTIPLEXED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037858));
pub const STATUS_LOG_DEDICATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037857));
pub const STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037856));
pub const STATUS_LOG_ARCHIVE_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037855));
pub const STATUS_LOG_EPHEMERAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037854));
pub const STATUS_LOG_NOT_ENOUGH_CONTAINERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037853));
pub const STATUS_LOG_CLIENT_ALREADY_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037852));
pub const STATUS_LOG_CLIENT_NOT_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037851));
pub const STATUS_LOG_FULL_HANDLER_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037850));
pub const STATUS_LOG_CONTAINER_READ_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037849));
pub const STATUS_LOG_CONTAINER_WRITE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037848));
pub const STATUS_LOG_CONTAINER_OPEN_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037847));
pub const STATUS_LOG_CONTAINER_STATE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037846));
pub const STATUS_LOG_STATE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037845));
pub const STATUS_LOG_PINNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037844));
pub const STATUS_LOG_METADATA_FLUSH_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037843));
pub const STATUS_LOG_INCONSISTENT_SECURITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037842));
pub const STATUS_LOG_APPENDED_FLUSH_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037841));
pub const STATUS_LOG_PINNED_RESERVATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1072037840));
pub const STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071972118));
pub const STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2145713941));
pub const STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075511532));
pub const STATUS_MONITOR_NO_DESCRIPTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841279));
pub const STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841278));
pub const STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841277));
pub const STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841276));
pub const STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841275));
pub const STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841274));
pub const STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841273));
pub const STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841272));
pub const STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841271));
pub const STATUS_MONITOR_INVALID_MANUFACTURE_DATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071841270));
pub const STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775744));
pub const STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775743));
pub const STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775742));
pub const STATUS_GRAPHICS_ADAPTER_WAS_RESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775741));
pub const STATUS_GRAPHICS_INVALID_DRIVER_MODEL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775740));
pub const STATUS_GRAPHICS_PRESENT_MODE_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775739));
pub const STATUS_GRAPHICS_PRESENT_OCCLUDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775738));
pub const STATUS_GRAPHICS_PRESENT_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775737));
pub const STATUS_GRAPHICS_CANNOTCOLORCONVERT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775736));
pub const STATUS_GRAPHICS_DRIVER_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775735));
pub const STATUS_GRAPHICS_PARTIAL_DATA_POPULATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075707914));
pub const STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775733));
pub const STATUS_GRAPHICS_PRESENT_UNOCCLUDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775732));
pub const STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775731));
pub const STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775730));
pub const STATUS_GRAPHICS_PRESENT_INVALID_WINDOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775729));
pub const STATUS_GRAPHICS_PRESENT_BUFFER_NOT_BOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775728));
pub const STATUS_GRAPHICS_VAIL_STATE_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775727));
pub const STATUS_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775726));
pub const STATUS_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775725));
pub const STATUS_GRAPHICS_NO_VIDEO_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775488));
pub const STATUS_GRAPHICS_CANT_LOCK_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775487));
pub const STATUS_GRAPHICS_ALLOCATION_BUSY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775486));
pub const STATUS_GRAPHICS_TOO_MANY_REFERENCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775485));
pub const STATUS_GRAPHICS_TRY_AGAIN_LATER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775484));
pub const STATUS_GRAPHICS_TRY_AGAIN_NOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775483));
pub const STATUS_GRAPHICS_ALLOCATION_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775482));
pub const STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775481));
pub const STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775480));
pub const STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775479));
pub const STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775472));
pub const STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775471));
pub const STATUS_GRAPHICS_ALLOCATION_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775470));
pub const STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775469));
pub const STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775468));
pub const STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775467));
pub const STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775466));
pub const STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071775232));
pub const STATUS_GRAPHICS_SKIP_ALLOCATION_PREPARATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708417));
pub const STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774976));
pub const STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774975));
pub const STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774974));
pub const STATUS_GRAPHICS_INVALID_VIDPN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774973));
pub const STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774972));
pub const STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774971));
pub const STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774970));
pub const STATUS_GRAPHICS_MODE_NOT_PINNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708679));
pub const STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774968));
pub const STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774967));
pub const STATUS_GRAPHICS_INVALID_FREQUENCY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774966));
pub const STATUS_GRAPHICS_INVALID_ACTIVE_REGION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774965));
pub const STATUS_GRAPHICS_INVALID_TOTAL_REGION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774964));
pub const STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774960));
pub const STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774959));
pub const STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774958));
pub const STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774957));
pub const STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774956));
pub const STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774955));
pub const STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774954));
pub const STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774953));
pub const STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774952));
pub const STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774951));
pub const STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774950));
pub const STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774949));
pub const STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774948));
pub const STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774947));
pub const STATUS_GRAPHICS_NO_PREFERRED_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708702));
pub const STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774945));
pub const STATUS_GRAPHICS_STALE_MODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774944));
pub const STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774943));
pub const STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774942));
pub const STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774941));
pub const STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774940));
pub const STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774939));
pub const STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774938));
pub const STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774937));
pub const STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774936));
pub const STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774935));
pub const STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774934));
pub const STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774933));
pub const STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774932));
pub const STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774931));
pub const STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774930));
pub const STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774929));
pub const STATUS_GRAPHICS_RESOURCES_NOT_RELATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774928));
pub const STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774927));
pub const STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774926));
pub const STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774925));
pub const STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774924));
pub const STATUS_GRAPHICS_NO_VIDPNMGR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774923));
pub const STATUS_GRAPHICS_NO_ACTIVE_VIDPN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774922));
pub const STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774921));
pub const STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774920));
pub const STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774919));
pub const STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774918));
pub const STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774917));
pub const STATUS_GRAPHICS_INVALID_STRIDE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774916));
pub const STATUS_GRAPHICS_INVALID_PIXELFORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774915));
pub const STATUS_GRAPHICS_INVALID_COLORBASIS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774914));
pub const STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774913));
pub const STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774912));
pub const STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774911));
pub const STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774910));
pub const STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774909));
pub const STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774908));
pub const STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774907));
pub const STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774906));
pub const STATUS_GRAPHICS_INVALID_GAMMA_RAMP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774905));
pub const STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774904));
pub const STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774903));
pub const STATUS_GRAPHICS_MODE_NOT_IN_MODESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774902));
pub const STATUS_GRAPHICS_DATASET_IS_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708747));
pub const STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708748));
pub const STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774899));
pub const STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774898));
pub const STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774897));
pub const STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774896));
pub const STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708753));
pub const STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774894));
pub const STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774893));
pub const STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774892));
pub const STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774891));
pub const STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774890));
pub const STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774889));
pub const STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774888));
pub const STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774887));
pub const STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774886));
pub const STATUS_GRAPHICS_INVALID_CLIENT_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774885));
pub const STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774884));
pub const STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774720));
pub const STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774719));
pub const STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708975));
pub const STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774672));
pub const STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774671));
pub const STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774670));
pub const STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774669));
pub const STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774668));
pub const STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774667));
pub const STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774666));
pub const STATUS_GRAPHICS_LEADLINK_START_DEFERRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708983));
pub const STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774664));
pub const STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708985));
pub const STATUS_GRAPHICS_START_DEFERRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708986));
pub const STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774661));
pub const STATUS_GRAPHICS_DEPENDABLE_CHILD_STATUS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1075708988));
pub const STATUS_GRAPHICS_OPM_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774464));
pub const STATUS_GRAPHICS_COPP_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774463));
pub const STATUS_GRAPHICS_UAB_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774462));
pub const STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774461));
pub const STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774459));
pub const STATUS_GRAPHICS_OPM_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774453));
pub const STATUS_GRAPHICS_OPM_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774452));
pub const STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774450));
pub const STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774449));
pub const STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774448));
pub const STATUS_GRAPHICS_PVP_HFS_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774447));
pub const STATUS_GRAPHICS_OPM_INVALID_SRM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774446));
pub const STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774445));
pub const STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774444));
pub const STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774443));
pub const STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774442));
pub const STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774441));
pub const STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774440));
pub const STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774438));
pub const STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774436));
pub const STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774435));
pub const STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774434));
pub const STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774433));
pub const STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774432));
pub const STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774431));
pub const STATUS_GRAPHICS_I2C_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774336));
pub const STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774335));
pub const STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774334));
pub const STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774333));
pub const STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774332));
pub const STATUS_GRAPHICS_DDCCI_INVALID_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774331));
pub const STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774330));
pub const STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774329));
pub const STATUS_GRAPHICS_MCA_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774328));
pub const STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774327));
pub const STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774326));
pub const STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774325));
pub const STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774324));
pub const STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774323));
pub const STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774240));
pub const STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774239));
pub const STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774238));
pub const STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774237));
pub const STATUS_GRAPHICS_INVALID_POINTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774236));
pub const STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774235));
pub const STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774234));
pub const STATUS_GRAPHICS_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774233));
pub const STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071774232));
pub const STATUS_FVE_LOCKED_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579136));
pub const STATUS_FVE_NOT_ENCRYPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579135));
pub const STATUS_FVE_BAD_INFORMATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579134));
pub const STATUS_FVE_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579133));
pub const STATUS_FVE_FAILED_WRONG_FS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579132));
pub const STATUS_FVE_BAD_PARTITION_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579131));
pub const STATUS_FVE_FS_NOT_EXTENDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579130));
pub const STATUS_FVE_FS_MOUNTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579129));
pub const STATUS_FVE_NO_LICENSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579128));
pub const STATUS_FVE_ACTION_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579127));
pub const STATUS_FVE_BAD_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579126));
pub const STATUS_FVE_VOLUME_NOT_BOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579125));
pub const STATUS_FVE_NOT_DATA_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579124));
pub const STATUS_FVE_CONV_READ_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579123));
pub const STATUS_FVE_CONV_WRITE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579122));
pub const STATUS_FVE_OVERLAPPED_UPDATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579121));
pub const STATUS_FVE_FAILED_SECTOR_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579120));
pub const STATUS_FVE_FAILED_AUTHENTICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579119));
pub const STATUS_FVE_NOT_OS_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579118));
pub const STATUS_FVE_KEYFILE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579117));
pub const STATUS_FVE_KEYFILE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579116));
pub const STATUS_FVE_KEYFILE_NO_VMK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579115));
pub const STATUS_FVE_TPM_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579114));
pub const STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579113));
pub const STATUS_FVE_TPM_INVALID_PCR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579112));
pub const STATUS_FVE_TPM_NO_VMK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579111));
pub const STATUS_FVE_PIN_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579110));
pub const STATUS_FVE_AUTH_INVALID_APPLICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579109));
pub const STATUS_FVE_AUTH_INVALID_CONFIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579108));
pub const STATUS_FVE_DEBUGGER_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579107));
pub const STATUS_FVE_DRY_RUN_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579106));
pub const STATUS_FVE_BAD_METADATA_POINTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579105));
pub const STATUS_FVE_OLD_METADATA_COPY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579104));
pub const STATUS_FVE_REBOOT_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579103));
pub const STATUS_FVE_RAW_ACCESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579102));
pub const STATUS_FVE_RAW_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579101));
pub const STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579100));
pub const STATUS_FVE_MOR_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579099));
pub const STATUS_FVE_NO_FEATURE_LICENSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579098));
pub const STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579097));
pub const STATUS_FVE_CONV_RECOVERY_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579096));
pub const STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579095));
pub const STATUS_FVE_INVALID_DATUM_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579094));
pub const STATUS_FVE_VOLUME_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579088));
pub const STATUS_FVE_ENH_PIN_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579087));
pub const STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579086));
pub const STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579085));
pub const STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579084));
pub const STATUS_FVE_NOT_ALLOWED_ON_CLUSTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579083));
pub const STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579082));
pub const STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579081));
pub const STATUS_FVE_EDRIVE_DRY_RUN_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579080));
pub const STATUS_FVE_SECUREBOOT_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579079));
pub const STATUS_FVE_SECUREBOOT_CONFIG_CHANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579078));
pub const STATUS_FVE_DEVICE_LOCKEDOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579077));
pub const STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579076));
pub const STATUS_FVE_NOT_DE_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579075));
pub const STATUS_FVE_PROTECTION_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579074));
pub const STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579073));
pub const STATUS_FVE_OSV_KSR_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071579072));
pub const STATUS_FWP_CALLOUT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513599));
pub const STATUS_FWP_CONDITION_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513598));
pub const STATUS_FWP_FILTER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513597));
pub const STATUS_FWP_LAYER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513596));
pub const STATUS_FWP_PROVIDER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513595));
pub const STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513594));
pub const STATUS_FWP_SUBLAYER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513593));
pub const STATUS_FWP_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513592));
pub const STATUS_FWP_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513591));
pub const STATUS_FWP_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513590));
pub const STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513589));
pub const STATUS_FWP_WRONG_SESSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513588));
pub const STATUS_FWP_NO_TXN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513587));
pub const STATUS_FWP_TXN_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513586));
pub const STATUS_FWP_TXN_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513585));
pub const STATUS_FWP_SESSION_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513584));
pub const STATUS_FWP_INCOMPATIBLE_TXN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513583));
pub const STATUS_FWP_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513582));
pub const STATUS_FWP_NET_EVENTS_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513581));
pub const STATUS_FWP_INCOMPATIBLE_LAYER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513580));
pub const STATUS_FWP_KM_CLIENTS_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513579));
pub const STATUS_FWP_LIFETIME_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513578));
pub const STATUS_FWP_BUILTIN_OBJECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513577));
pub const STATUS_FWP_TOO_MANY_CALLOUTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513576));
pub const STATUS_FWP_NOTIFICATION_DROPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513575));
pub const STATUS_FWP_TRAFFIC_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513574));
pub const STATUS_FWP_INCOMPATIBLE_SA_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513573));
pub const STATUS_FWP_NULL_POINTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513572));
pub const STATUS_FWP_INVALID_ENUMERATOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513571));
pub const STATUS_FWP_INVALID_FLAGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513570));
pub const STATUS_FWP_INVALID_NET_MASK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513569));
pub const STATUS_FWP_INVALID_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513568));
pub const STATUS_FWP_INVALID_INTERVAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513567));
pub const STATUS_FWP_ZERO_LENGTH_ARRAY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513566));
pub const STATUS_FWP_NULL_DISPLAY_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513565));
pub const STATUS_FWP_INVALID_ACTION_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513564));
pub const STATUS_FWP_INVALID_WEIGHT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513563));
pub const STATUS_FWP_MATCH_TYPE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513562));
pub const STATUS_FWP_TYPE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513561));
pub const STATUS_FWP_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513560));
pub const STATUS_FWP_RESERVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513559));
pub const STATUS_FWP_DUPLICATE_CONDITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513558));
pub const STATUS_FWP_DUPLICATE_KEYMOD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513557));
pub const STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513556));
pub const STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513555));
pub const STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513554));
pub const STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513553));
pub const STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513552));
pub const STATUS_FWP_INCOMPATIBLE_DH_GROUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513551));
pub const STATUS_FWP_EM_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513550));
pub const STATUS_FWP_NEVER_MATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513549));
pub const STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513548));
pub const STATUS_FWP_INVALID_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513547));
pub const STATUS_FWP_TOO_MANY_SUBLAYERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513546));
pub const STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513545));
pub const STATUS_FWP_INVALID_AUTH_TRANSFORM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513544));
pub const STATUS_FWP_INVALID_CIPHER_TRANSFORM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513543));
pub const STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513542));
pub const STATUS_FWP_INVALID_TRANSFORM_COMBINATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513541));
pub const STATUS_FWP_DUPLICATE_AUTH_METHOD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513540));
pub const STATUS_FWP_INVALID_TUNNEL_ENDPOINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513539));
pub const STATUS_FWP_L2_DRIVER_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513538));
pub const STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513537));
pub const STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513536));
pub const STATUS_FWP_CONNECTIONS_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513535));
pub const STATUS_FWP_INVALID_DNS_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513534));
pub const STATUS_FWP_STILL_ON = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513533));
pub const STATUS_FWP_IKEEXT_NOT_RUNNING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513532));
pub const STATUS_FWP_TCPIP_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513344));
pub const STATUS_FWP_INJECT_HANDLE_CLOSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513343));
pub const STATUS_FWP_INJECT_HANDLE_STALE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513342));
pub const STATUS_FWP_CANNOT_PEND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513341));
pub const STATUS_FWP_DROP_NOICMP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071513340));
pub const STATUS_NDIS_CLOSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448062));
pub const STATUS_NDIS_BAD_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448060));
pub const STATUS_NDIS_BAD_CHARACTERISTICS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448059));
pub const STATUS_NDIS_ADAPTER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448058));
pub const STATUS_NDIS_OPEN_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448057));
pub const STATUS_NDIS_DEVICE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448056));
pub const STATUS_NDIS_MULTICAST_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448055));
pub const STATUS_NDIS_MULTICAST_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448054));
pub const STATUS_NDIS_MULTICAST_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448053));
pub const STATUS_NDIS_REQUEST_ABORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448052));
pub const STATUS_NDIS_RESET_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448051));
pub const STATUS_NDIS_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071447877));
pub const STATUS_NDIS_INVALID_PACKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448049));
pub const STATUS_NDIS_ADAPTER_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448047));
pub const STATUS_NDIS_INVALID_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448044));
pub const STATUS_NDIS_INVALID_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448043));
pub const STATUS_NDIS_BUFFER_TOO_SHORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448042));
pub const STATUS_NDIS_INVALID_OID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448041));
pub const STATUS_NDIS_ADAPTER_REMOVED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448040));
pub const STATUS_NDIS_UNSUPPORTED_MEDIA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448039));
pub const STATUS_NDIS_GROUP_ADDRESS_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448038));
pub const STATUS_NDIS_FILE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448037));
pub const STATUS_NDIS_ERROR_READING_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448036));
pub const STATUS_NDIS_ALREADY_MAPPED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448035));
pub const STATUS_NDIS_RESOURCE_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448034));
pub const STATUS_NDIS_MEDIA_DISCONNECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448033));
pub const STATUS_NDIS_INVALID_ADDRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448030));
pub const STATUS_NDIS_INVALID_DEVICE_REQUEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448048));
pub const STATUS_NDIS_PAUSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448022));
pub const STATUS_NDIS_INTERFACE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448021));
pub const STATUS_NDIS_UNSUPPORTED_REVISION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448020));
pub const STATUS_NDIS_INVALID_PORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448019));
pub const STATUS_NDIS_INVALID_PORT_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448018));
pub const STATUS_NDIS_LOW_POWER_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448017));
pub const STATUS_NDIS_REINIT_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448016));
pub const STATUS_NDIS_NO_QUEUES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071448015));
pub const STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439872));
pub const STATUS_NDIS_DOT11_MEDIA_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439871));
pub const STATUS_NDIS_DOT11_POWER_STATE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439870));
pub const STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439869));
pub const STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439868));
pub const STATUS_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439867));
pub const STATUS_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439866));
pub const STATUS_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439865));
pub const STATUS_NDIS_DOT11_AP_BAND_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071439864));
pub const STATUS_NDIS_INDICATION_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1076035585));
pub const STATUS_NDIS_OFFLOAD_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071443953));
pub const STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071443950));
pub const STATUS_NDIS_OFFLOAD_PATH_REJECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071443949));
pub const STATUS_TPM_ERROR_MASK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054848));
pub const STATUS_TPM_AUTHFAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054847));
pub const STATUS_TPM_BADINDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054846));
pub const STATUS_TPM_BAD_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054845));
pub const STATUS_TPM_AUDITFAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054844));
pub const STATUS_TPM_CLEAR_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054843));
pub const STATUS_TPM_DEACTIVATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054842));
pub const STATUS_TPM_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054841));
pub const STATUS_TPM_DISABLED_CMD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054840));
pub const STATUS_TPM_FAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054839));
pub const STATUS_TPM_BAD_ORDINAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054838));
pub const STATUS_TPM_INSTALL_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054837));
pub const STATUS_TPM_INVALID_KEYHANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054836));
pub const STATUS_TPM_KEYNOTFOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054835));
pub const STATUS_TPM_INAPPROPRIATE_ENC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054834));
pub const STATUS_TPM_MIGRATEFAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054833));
pub const STATUS_TPM_INVALID_PCR_INFO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054832));
pub const STATUS_TPM_NOSPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054831));
pub const STATUS_TPM_NOSRK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054830));
pub const STATUS_TPM_NOTSEALED_BLOB = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054829));
pub const STATUS_TPM_OWNER_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054828));
pub const STATUS_TPM_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054827));
pub const STATUS_TPM_SHORTRANDOM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054826));
pub const STATUS_TPM_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054825));
pub const STATUS_TPM_WRONGPCRVAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054824));
pub const STATUS_TPM_BAD_PARAM_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054823));
pub const STATUS_TPM_SHA_THREAD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054822));
pub const STATUS_TPM_SHA_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054821));
pub const STATUS_TPM_FAILEDSELFTEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054820));
pub const STATUS_TPM_AUTH2FAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054819));
pub const STATUS_TPM_BADTAG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054818));
pub const STATUS_TPM_IOERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054817));
pub const STATUS_TPM_ENCRYPT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054816));
pub const STATUS_TPM_DECRYPT_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054815));
pub const STATUS_TPM_INVALID_AUTHHANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054814));
pub const STATUS_TPM_NO_ENDORSEMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054813));
pub const STATUS_TPM_INVALID_KEYUSAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054812));
pub const STATUS_TPM_WRONG_ENTITYTYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054811));
pub const STATUS_TPM_INVALID_POSTINIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054810));
pub const STATUS_TPM_INAPPROPRIATE_SIG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054809));
pub const STATUS_TPM_BAD_KEY_PROPERTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054808));
pub const STATUS_TPM_BAD_MIGRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054807));
pub const STATUS_TPM_BAD_SCHEME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054806));
pub const STATUS_TPM_BAD_DATASIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054805));
pub const STATUS_TPM_BAD_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054804));
pub const STATUS_TPM_BAD_PRESENCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054803));
pub const STATUS_TPM_BAD_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054802));
pub const STATUS_TPM_NO_WRAP_TRANSPORT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054801));
pub const STATUS_TPM_AUDITFAIL_UNSUCCESSFUL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054800));
pub const STATUS_TPM_AUDITFAIL_SUCCESSFUL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054799));
pub const STATUS_TPM_NOTRESETABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054798));
pub const STATUS_TPM_NOTLOCAL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054797));
pub const STATUS_TPM_BAD_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054796));
pub const STATUS_TPM_INVALID_RESOURCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054795));
pub const STATUS_TPM_NOTFIPS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054794));
pub const STATUS_TPM_INVALID_FAMILY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054793));
pub const STATUS_TPM_NO_NV_PERMISSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054792));
pub const STATUS_TPM_REQUIRES_SIGN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054791));
pub const STATUS_TPM_KEY_NOTSUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054790));
pub const STATUS_TPM_AUTH_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054789));
pub const STATUS_TPM_AREA_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054788));
pub const STATUS_TPM_BAD_LOCALITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054787));
pub const STATUS_TPM_READ_ONLY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054786));
pub const STATUS_TPM_PER_NOWRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054785));
pub const STATUS_TPM_FAMILYCOUNT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054784));
pub const STATUS_TPM_WRITE_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054783));
pub const STATUS_TPM_BAD_ATTRIBUTES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054782));
pub const STATUS_TPM_INVALID_STRUCTURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054781));
pub const STATUS_TPM_KEY_OWNER_CONTROL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054780));
pub const STATUS_TPM_BAD_COUNTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054779));
pub const STATUS_TPM_NOT_FULLWRITE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054778));
pub const STATUS_TPM_CONTEXT_GAP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054777));
pub const STATUS_TPM_MAXNVWRITES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054776));
pub const STATUS_TPM_NOOPERATOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054775));
pub const STATUS_TPM_RESOURCEMISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054774));
pub const STATUS_TPM_DELEGATE_LOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054773));
pub const STATUS_TPM_DELEGATE_FAMILY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054772));
pub const STATUS_TPM_DELEGATE_ADMIN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054771));
pub const STATUS_TPM_TRANSPORT_NOTEXCLUSIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054770));
pub const STATUS_TPM_OWNER_CONTROL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054769));
pub const STATUS_TPM_DAA_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054768));
pub const STATUS_TPM_DAA_INPUT_DATA0 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054767));
pub const STATUS_TPM_DAA_INPUT_DATA1 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054766));
pub const STATUS_TPM_DAA_ISSUER_SETTINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054765));
pub const STATUS_TPM_DAA_TPM_SETTINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054764));
pub const STATUS_TPM_DAA_STAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054763));
pub const STATUS_TPM_DAA_ISSUER_VALIDITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054762));
pub const STATUS_TPM_DAA_WRONG_W = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054761));
pub const STATUS_TPM_BAD_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054760));
pub const STATUS_TPM_BAD_DELEGATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054759));
pub const STATUS_TPM_BADCONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054758));
pub const STATUS_TPM_TOOMANYCONTEXTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054757));
pub const STATUS_TPM_MA_TICKET_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054756));
pub const STATUS_TPM_MA_DESTINATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054755));
pub const STATUS_TPM_MA_SOURCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054754));
pub const STATUS_TPM_MA_AUTHORITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054753));
pub const STATUS_TPM_PERMANENTEK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054751));
pub const STATUS_TPM_BAD_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054750));
pub const STATUS_TPM_NOCONTEXTSPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054749));
pub const STATUS_TPM_20_E_ASYMMETRIC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054719));
pub const STATUS_TPM_20_E_ATTRIBUTES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054718));
pub const STATUS_TPM_20_E_HASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054717));
pub const STATUS_TPM_20_E_VALUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054716));
pub const STATUS_TPM_20_E_HIERARCHY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054715));
pub const STATUS_TPM_20_E_KEY_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054713));
pub const STATUS_TPM_20_E_MGF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054712));
pub const STATUS_TPM_20_E_MODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054711));
pub const STATUS_TPM_20_E_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054710));
pub const STATUS_TPM_20_E_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054709));
pub const STATUS_TPM_20_E_KDF = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054708));
pub const STATUS_TPM_20_E_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054707));
pub const STATUS_TPM_20_E_AUTH_FAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054706));
pub const STATUS_TPM_20_E_NONCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054705));
pub const STATUS_TPM_20_E_PP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054704));
pub const STATUS_TPM_20_E_SCHEME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054702));
pub const STATUS_TPM_20_E_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054699));
pub const STATUS_TPM_20_E_SYMMETRIC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054698));
pub const STATUS_TPM_20_E_TAG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054697));
pub const STATUS_TPM_20_E_SELECTOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054696));
pub const STATUS_TPM_20_E_INSUFFICIENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054694));
pub const STATUS_TPM_20_E_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054693));
pub const STATUS_TPM_20_E_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054692));
pub const STATUS_TPM_20_E_POLICY_FAIL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054691));
pub const STATUS_TPM_20_E_INTEGRITY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054689));
pub const STATUS_TPM_20_E_TICKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054688));
pub const STATUS_TPM_20_E_RESERVED_BITS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054687));
pub const STATUS_TPM_20_E_BAD_AUTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054686));
pub const STATUS_TPM_20_E_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054685));
pub const STATUS_TPM_20_E_POLICY_CC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054684));
pub const STATUS_TPM_20_E_BINDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054683));
pub const STATUS_TPM_20_E_CURVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054682));
pub const STATUS_TPM_20_E_ECC_POINT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054681));
pub const STATUS_TPM_20_E_INITIALIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054592));
pub const STATUS_TPM_20_E_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054591));
pub const STATUS_TPM_20_E_SEQUENCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054589));
pub const STATUS_TPM_20_E_PRIVATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054581));
pub const STATUS_TPM_20_E_HMAC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054567));
pub const STATUS_TPM_20_E_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054560));
pub const STATUS_TPM_20_E_EXCLUSIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054559));
pub const STATUS_TPM_20_E_ECC_CURVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054557));
pub const STATUS_TPM_20_E_AUTH_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054556));
pub const STATUS_TPM_20_E_AUTH_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054555));
pub const STATUS_TPM_20_E_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054554));
pub const STATUS_TPM_20_E_PCR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054553));
pub const STATUS_TPM_20_E_PCR_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054552));
pub const STATUS_TPM_20_E_UPGRADE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054547));
pub const STATUS_TPM_20_E_TOO_MANY_CONTEXTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054546));
pub const STATUS_TPM_20_E_AUTH_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054545));
pub const STATUS_TPM_20_E_REBOOT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054544));
pub const STATUS_TPM_20_E_UNBALANCED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054543));
pub const STATUS_TPM_20_E_COMMAND_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054526));
pub const STATUS_TPM_20_E_COMMAND_CODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054525));
pub const STATUS_TPM_20_E_AUTHSIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054524));
pub const STATUS_TPM_20_E_AUTH_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054523));
pub const STATUS_TPM_20_E_NV_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054522));
pub const STATUS_TPM_20_E_NV_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054521));
pub const STATUS_TPM_20_E_NV_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054520));
pub const STATUS_TPM_20_E_NV_AUTHORIZATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054519));
pub const STATUS_TPM_20_E_NV_UNINITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054518));
pub const STATUS_TPM_20_E_NV_SPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054517));
pub const STATUS_TPM_20_E_NV_DEFINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054516));
pub const STATUS_TPM_20_E_BAD_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054512));
pub const STATUS_TPM_20_E_CPHASH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054511));
pub const STATUS_TPM_20_E_PARENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054510));
pub const STATUS_TPM_20_E_NEEDS_TEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054509));
pub const STATUS_TPM_20_E_NO_RESULT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054508));
pub const STATUS_TPM_20_E_SENSITIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071054507));
pub const STATUS_TPM_COMMAND_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071053824));
pub const STATUS_TPM_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071053823));
pub const STATUS_TPM_DUPLICATE_VHANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071053822));
pub const STATUS_TPM_EMBEDDED_COMMAND_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071053821));
pub const STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071053820));
pub const STATUS_TPM_RETRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071052800));
pub const STATUS_TPM_NEEDS_SELFTEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071052799));
pub const STATUS_TPM_DOING_SELFTEST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071052798));
pub const STATUS_TPM_DEFEND_LOCK_RUNNING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071052797));
pub const STATUS_TPM_COMMAND_CANCELED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050751));
pub const STATUS_TPM_TOO_MANY_CONTEXTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050750));
pub const STATUS_TPM_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050749));
pub const STATUS_TPM_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050748));
pub const STATUS_TPM_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050747));
pub const STATUS_TPM_PPI_FUNCTION_UNSUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071050746));
pub const STATUS_PCP_ERROR_MASK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046656));
pub const STATUS_PCP_DEVICE_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046655));
pub const STATUS_PCP_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046654));
pub const STATUS_PCP_INVALID_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046653));
pub const STATUS_PCP_FLAG_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046652));
pub const STATUS_PCP_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046651));
pub const STATUS_PCP_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046650));
pub const STATUS_PCP_INTERNAL_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046649));
pub const STATUS_PCP_AUTHENTICATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046648));
pub const STATUS_PCP_AUTHENTICATION_IGNORED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046647));
pub const STATUS_PCP_POLICY_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046646));
pub const STATUS_PCP_PROFILE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046645));
pub const STATUS_PCP_VALIDATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046644));
pub const STATUS_PCP_DEVICE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046643));
pub const STATUS_PCP_WRONG_PARENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046642));
pub const STATUS_PCP_KEY_NOT_LOADED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046641));
pub const STATUS_PCP_NO_KEY_CERTIFICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046640));
pub const STATUS_PCP_KEY_NOT_FINALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046639));
pub const STATUS_PCP_ATTESTATION_CHALLENGE_NOT_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046638));
pub const STATUS_PCP_NOT_PCR_BOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046637));
pub const STATUS_PCP_KEY_ALREADY_FINALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046636));
pub const STATUS_PCP_KEY_USAGE_POLICY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046635));
pub const STATUS_PCP_KEY_USAGE_POLICY_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046634));
pub const STATUS_PCP_SOFT_KEY_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046633));
pub const STATUS_PCP_KEY_NOT_AUTHENTICATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046632));
pub const STATUS_PCP_KEY_NOT_AIK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046631));
pub const STATUS_PCP_KEY_NOT_SIGNING_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046630));
pub const STATUS_PCP_LOCKED_OUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046629));
pub const STATUS_PCP_CLAIM_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046628));
pub const STATUS_PCP_TPM_VERSION_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046627));
pub const STATUS_PCP_BUFFER_LENGTH_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046626));
pub const STATUS_PCP_IFX_RSA_KEY_CREATION_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046625));
pub const STATUS_PCP_TICKET_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046624));
pub const STATUS_PCP_RAW_POLICY_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046623));
pub const STATUS_PCP_KEY_HANDLE_INVALIDATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071046622));
pub const STATUS_PCP_UNSUPPORTED_PSS_SALT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 1076437027));
pub const STATUS_RTPM_CONTEXT_CONTINUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 2699264));
pub const STATUS_RTPM_CONTEXT_COMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 2699265));
pub const STATUS_RTPM_NO_RESULT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071042558));
pub const STATUS_RTPM_PCR_READ_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071042557));
pub const STATUS_RTPM_INVALID_CONTEXT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071042556));
pub const STATUS_RTPM_UNSUPPORTED_CMD = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071042555));
pub const STATUS_TPM_ZERO_EXHAUST_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071038464));
pub const STATUS_HV_INVALID_HYPERCALL_CODE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268414));
pub const STATUS_HV_INVALID_HYPERCALL_INPUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268413));
pub const STATUS_HV_INVALID_ALIGNMENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268412));
pub const STATUS_HV_INVALID_PARAMETER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268411));
pub const STATUS_HV_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268410));
pub const STATUS_HV_INVALID_PARTITION_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268409));
pub const STATUS_HV_OPERATION_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268408));
pub const STATUS_HV_UNKNOWN_PROPERTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268407));
pub const STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268406));
pub const STATUS_HV_INSUFFICIENT_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268405));
pub const STATUS_HV_PARTITION_TOO_DEEP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268404));
pub const STATUS_HV_INVALID_PARTITION_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268403));
pub const STATUS_HV_INVALID_VP_INDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268402));
pub const STATUS_HV_INVALID_PORT_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268399));
pub const STATUS_HV_INVALID_CONNECTION_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268398));
pub const STATUS_HV_INSUFFICIENT_BUFFERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268397));
pub const STATUS_HV_NOT_ACKNOWLEDGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268396));
pub const STATUS_HV_INVALID_VP_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268395));
pub const STATUS_HV_ACKNOWLEDGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268394));
pub const STATUS_HV_INVALID_SAVE_RESTORE_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268393));
pub const STATUS_HV_INVALID_SYNIC_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268392));
pub const STATUS_HV_OBJECT_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268391));
pub const STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268390));
pub const STATUS_HV_NO_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268389));
pub const STATUS_HV_INACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268388));
pub const STATUS_HV_NO_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268387));
pub const STATUS_HV_FEATURE_UNAVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268386));
pub const STATUS_HV_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268365));
pub const STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268360));
pub const STATUS_HV_CPUID_FEATURE_VALIDATION_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268356));
pub const STATUS_HV_CPUID_XSAVE_FEATURE_VALIDATION_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268355));
pub const STATUS_HV_PROCESSOR_STARTUP_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268354));
pub const STATUS_HV_SMX_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268353));
pub const STATUS_HV_INVALID_LP_INDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268351));
pub const STATUS_HV_INVALID_REGISTER_VALUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268336));
pub const STATUS_HV_INVALID_VTL_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268335));
pub const STATUS_HV_NX_NOT_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268331));
pub const STATUS_HV_INVALID_DEVICE_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268329));
pub const STATUS_HV_INVALID_DEVICE_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268328));
pub const STATUS_HV_PENDING_PAGE_REQUESTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 3473497));
pub const STATUS_HV_PAGE_REQUEST_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268320));
pub const STATUS_HV_INVALID_CPU_GROUP_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268305));
pub const STATUS_HV_INVALID_CPU_GROUP_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268304));
pub const STATUS_HV_OPERATION_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268303));
pub const STATUS_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268302));
pub const STATUS_HV_INSUFFICIENT_ROOT_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268301));
pub const STATUS_HV_EVENT_BUFFER_ALREADY_FREED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268300));
pub const STATUS_HV_INSUFFICIENT_CONTIGUOUS_MEMORY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070268299));
pub const STATUS_HV_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070264320));
pub const STATUS_VID_DUPLICATE_HANDLER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137343));
pub const STATUS_VID_TOO_MANY_HANDLERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137342));
pub const STATUS_VID_QUEUE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137341));
pub const STATUS_VID_HANDLER_NOT_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137340));
pub const STATUS_VID_INVALID_OBJECT_NAME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137339));
pub const STATUS_VID_PARTITION_NAME_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137338));
pub const STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137337));
pub const STATUS_VID_PARTITION_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137336));
pub const STATUS_VID_PARTITION_DOES_NOT_EXIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137335));
pub const STATUS_VID_PARTITION_NAME_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137334));
pub const STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137333));
pub const STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137332));
pub const STATUS_VID_MB_STILL_REFERENCED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137331));
pub const STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137330));
pub const STATUS_VID_INVALID_NUMA_SETTINGS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137329));
pub const STATUS_VID_INVALID_NUMA_NODE_INDEX = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137328));
pub const STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137327));
pub const STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137326));
pub const STATUS_VID_PAGE_RANGE_OVERFLOW = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137325));
pub const STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137324));
pub const STATUS_VID_INVALID_GPA_RANGE_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137323));
pub const STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137322));
pub const STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137321));
pub const STATUS_VID_INVALID_PPM_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137320));
pub const STATUS_VID_MBPS_ARE_LOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137319));
pub const STATUS_VID_MESSAGE_QUEUE_CLOSED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137318));
pub const STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137317));
pub const STATUS_VID_STOP_PENDING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137316));
pub const STATUS_VID_INVALID_PROCESSOR_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137315));
pub const STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137314));
pub const STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137313));
pub const STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137312));
pub const STATUS_VID_MMIO_RANGE_DESTROYED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137311));
pub const STATUS_VID_INVALID_CHILD_GPA_PAGE_SET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137310));
pub const STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137309));
pub const STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137308));
pub const STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137307));
pub const STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137306));
pub const STATUS_VID_SAVED_STATE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137305));
pub const STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137304));
pub const STATUS_VID_SAVED_STATE_INCOMPATIBLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137303));
pub const STATUS_VID_VTL_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070137302));
pub const STATUS_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143879167));
pub const STATUS_IPSEC_BAD_SPI = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202879));
pub const STATUS_IPSEC_SA_LIFETIME_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202878));
pub const STATUS_IPSEC_WRONG_SA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202877));
pub const STATUS_IPSEC_REPLAY_CHECK_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202876));
pub const STATUS_IPSEC_INVALID_PACKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202875));
pub const STATUS_IPSEC_INTEGRITY_CHECK_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202874));
pub const STATUS_IPSEC_CLEAR_TEXT_DROP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202873));
pub const STATUS_IPSEC_AUTH_FIREWALL_DROP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202872));
pub const STATUS_IPSEC_THROTTLE_DROP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070202871));
pub const STATUS_IPSEC_DOSP_BLOCK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170112));
pub const STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170111));
pub const STATUS_IPSEC_DOSP_INVALID_PACKET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170110));
pub const STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170109));
pub const STATUS_IPSEC_DOSP_MAX_ENTRIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170108));
pub const STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170107));
pub const STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070170106));
pub const STATUS_VOLMGR_INCOMPLETE_REGENERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143813631));
pub const STATUS_VOLMGR_INCOMPLETE_DISK_MIGRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143813630));
pub const STATUS_VOLMGR_DATABASE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071807));
pub const STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071806));
pub const STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071805));
pub const STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071804));
pub const STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071803));
pub const STATUS_VOLMGR_DISK_DUPLICATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071802));
pub const STATUS_VOLMGR_DISK_DYNAMIC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071801));
pub const STATUS_VOLMGR_DISK_ID_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071800));
pub const STATUS_VOLMGR_DISK_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071799));
pub const STATUS_VOLMGR_DISK_LAST_VOTER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071798));
pub const STATUS_VOLMGR_DISK_LAYOUT_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071797));
pub const STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071796));
pub const STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071795));
pub const STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071794));
pub const STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071793));
pub const STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071792));
pub const STATUS_VOLMGR_DISK_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071791));
pub const STATUS_VOLMGR_DISK_NOT_EMPTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071790));
pub const STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071789));
pub const STATUS_VOLMGR_DISK_REVECTORING_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071788));
pub const STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071787));
pub const STATUS_VOLMGR_DISK_SET_NOT_CONTAINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071786));
pub const STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071785));
pub const STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071784));
pub const STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071783));
pub const STATUS_VOLMGR_EXTENT_ALREADY_USED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071782));
pub const STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071781));
pub const STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071780));
pub const STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071779));
pub const STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071778));
pub const STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071777));
pub const STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071776));
pub const STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071775));
pub const STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071774));
pub const STATUS_VOLMGR_MEMBER_IN_SYNC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071773));
pub const STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071772));
pub const STATUS_VOLMGR_MEMBER_INDEX_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071771));
pub const STATUS_VOLMGR_MEMBER_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071770));
pub const STATUS_VOLMGR_MEMBER_NOT_DETACHED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071769));
pub const STATUS_VOLMGR_MEMBER_REGENERATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071768));
pub const STATUS_VOLMGR_ALL_DISKS_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071767));
pub const STATUS_VOLMGR_NO_REGISTERED_USERS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071766));
pub const STATUS_VOLMGR_NO_SUCH_USER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071765));
pub const STATUS_VOLMGR_NOTIFICATION_RESET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071764));
pub const STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071763));
pub const STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071762));
pub const STATUS_VOLMGR_PACK_DUPLICATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071761));
pub const STATUS_VOLMGR_PACK_ID_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071760));
pub const STATUS_VOLMGR_PACK_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071759));
pub const STATUS_VOLMGR_PACK_NAME_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071758));
pub const STATUS_VOLMGR_PACK_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071757));
pub const STATUS_VOLMGR_PACK_HAS_QUORUM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071756));
pub const STATUS_VOLMGR_PACK_WITHOUT_QUORUM = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071755));
pub const STATUS_VOLMGR_PARTITION_STYLE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071754));
pub const STATUS_VOLMGR_PARTITION_UPDATE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071753));
pub const STATUS_VOLMGR_PLEX_IN_SYNC = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071752));
pub const STATUS_VOLMGR_PLEX_INDEX_DUPLICATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071751));
pub const STATUS_VOLMGR_PLEX_INDEX_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071750));
pub const STATUS_VOLMGR_PLEX_LAST_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071749));
pub const STATUS_VOLMGR_PLEX_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071748));
pub const STATUS_VOLMGR_PLEX_REGENERATING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071747));
pub const STATUS_VOLMGR_PLEX_TYPE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071746));
pub const STATUS_VOLMGR_PLEX_NOT_RAID5 = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071745));
pub const STATUS_VOLMGR_PLEX_NOT_SIMPLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071744));
pub const STATUS_VOLMGR_STRUCTURE_SIZE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071743));
pub const STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071742));
pub const STATUS_VOLMGR_TRANSACTION_IN_PROGRESS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071741));
pub const STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071740));
pub const STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071739));
pub const STATUS_VOLMGR_VOLUME_ID_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071738));
pub const STATUS_VOLMGR_VOLUME_LENGTH_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071737));
pub const STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071736));
pub const STATUS_VOLMGR_VOLUME_NOT_MIRRORED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071735));
pub const STATUS_VOLMGR_VOLUME_NOT_RETAINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071734));
pub const STATUS_VOLMGR_VOLUME_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071733));
pub const STATUS_VOLMGR_VOLUME_RETAINED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071732));
pub const STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071731));
pub const STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071730));
pub const STATUS_VOLMGR_BAD_BOOT_DISK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071729));
pub const STATUS_VOLMGR_PACK_CONFIG_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071728));
pub const STATUS_VOLMGR_PACK_CONFIG_ONLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071727));
pub const STATUS_VOLMGR_NOT_PRIMARY_PACK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071726));
pub const STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071725));
pub const STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071724));
pub const STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071723));
pub const STATUS_VOLMGR_VOLUME_MIRRORED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071722));
pub const STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071721));
pub const STATUS_VOLMGR_NO_VALID_LOG_COPIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071720));
pub const STATUS_VOLMGR_PRIMARY_PACK_PRESENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071719));
pub const STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071718));
pub const STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071717));
pub const STATUS_VOLMGR_RAID5_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070071716));
pub const STATUS_BCD_NOT_ALL_ENTRIES_IMPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143748095));
pub const STATUS_BCD_TOO_MANY_ELEMENTS = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1070006270));
pub const STATUS_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143748093));
pub const STATUS_VHD_DRIVE_FOOTER_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940735));
pub const STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940734));
pub const STATUS_VHD_DRIVE_FOOTER_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940733));
pub const STATUS_VHD_FORMAT_UNKNOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940732));
pub const STATUS_VHD_FORMAT_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940731));
pub const STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940730));
pub const STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940729));
pub const STATUS_VHD_SPARSE_HEADER_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940728));
pub const STATUS_VHD_BLOCK_ALLOCATION_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940727));
pub const STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940726));
pub const STATUS_VHD_INVALID_BLOCK_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940725));
pub const STATUS_VHD_BITMAP_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940724));
pub const STATUS_VHD_PARENT_VHD_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940723));
pub const STATUS_VHD_CHILD_PARENT_ID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940722));
pub const STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940721));
pub const STATUS_VHD_METADATA_READ_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940720));
pub const STATUS_VHD_METADATA_WRITE_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940719));
pub const STATUS_VHD_INVALID_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940718));
pub const STATUS_VHD_INVALID_FILE_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940717));
pub const STATUS_VIRTDISK_PROVIDER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940716));
pub const STATUS_VIRTDISK_NOT_VIRTUAL_DISK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940715));
pub const STATUS_VHD_PARENT_VHD_ACCESS_DENIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940714));
pub const STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940713));
pub const STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940712));
pub const STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940711));
pub const STATUS_VIRTUAL_DISK_LIMITATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940710));
pub const STATUS_VHD_INVALID_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940709));
pub const STATUS_VHD_INVALID_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940708));
pub const STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940707));
pub const STATUS_VIRTDISK_DISK_ALREADY_OWNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940706));
pub const STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940705));
pub const STATUS_CTLOG_TRACKING_NOT_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940704));
pub const STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940703));
pub const STATUS_CTLOG_VHD_CHANGED_OFFLINE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940702));
pub const STATUS_CTLOG_INVALID_TRACKING_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940701));
pub const STATUS_CTLOG_INCONSISTENT_TRACKING_FILE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940700));
pub const STATUS_VHD_METADATA_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940696));
pub const STATUS_VHD_INVALID_CHANGE_TRACKING_ID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940695));
pub const STATUS_VHD_CHANGE_TRACKING_DISABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940694));
pub const STATUS_VHD_MISSING_CHANGE_TRACKING_INFORMATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940688));
pub const STATUS_VHD_RESIZE_WOULD_TRUNCATE_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940687));
pub const STATUS_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940686));
pub const STATUS_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069940685));
pub const STATUS_QUERY_STORAGE_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143682559));
pub const STATUS_GDI_HANDLE_LEAK = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143354879));
pub const STATUS_RKF_KEY_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547519));
pub const STATUS_RKF_DUPLICATE_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547518));
pub const STATUS_RKF_BLOB_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547517));
pub const STATUS_RKF_STORE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547516));
pub const STATUS_RKF_FILE_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547515));
pub const STATUS_RKF_ACTIVE_KEY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069547514));
pub const STATUS_RDBSS_RESTART_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069481983));
pub const STATUS_RDBSS_CONTINUE_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069481982));
pub const STATUS_RDBSS_POST_OPERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069481981));
pub const STATUS_RDBSS_RETRY_LOOKUP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069481980));
pub const STATUS_BTH_ATT_INVALID_HANDLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416447));
pub const STATUS_BTH_ATT_READ_NOT_PERMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416446));
pub const STATUS_BTH_ATT_WRITE_NOT_PERMITTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416445));
pub const STATUS_BTH_ATT_INVALID_PDU = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416444));
pub const STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416443));
pub const STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416442));
pub const STATUS_BTH_ATT_INVALID_OFFSET = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416441));
pub const STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416440));
pub const STATUS_BTH_ATT_PREPARE_QUEUE_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416439));
pub const STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416438));
pub const STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416437));
pub const STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416436));
pub const STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416435));
pub const STATUS_BTH_ATT_UNLIKELY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416434));
pub const STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416433));
pub const STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416432));
pub const STATUS_BTH_ATT_INSUFFICIENT_RESOURCES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069416431));
pub const STATUS_BTH_ATT_UNKNOWN_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069412352));
pub const STATUS_SECUREBOOT_ROLLBACK_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350911));
pub const STATUS_SECUREBOOT_POLICY_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350910));
pub const STATUS_SECUREBOOT_INVALID_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350909));
pub const STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350908));
pub const STATUS_SECUREBOOT_POLICY_NOT_SIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350907));
pub const STATUS_SECUREBOOT_NOT_ENABLED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -2143092730));
pub const STATUS_SECUREBOOT_FILE_REPLACED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350905));
pub const STATUS_SECUREBOOT_POLICY_NOT_AUTHORIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350904));
pub const STATUS_SECUREBOOT_POLICY_UNKNOWN = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350903));
pub const STATUS_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350902));
pub const STATUS_SECUREBOOT_PLATFORM_ID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350901));
pub const STATUS_SECUREBOOT_POLICY_ROLLBACK_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350900));
pub const STATUS_SECUREBOOT_POLICY_UPGRADE_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350899));
pub const STATUS_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350898));
pub const STATUS_SECUREBOOT_NOT_BASE_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350897));
pub const STATUS_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069350896));
pub const STATUS_PLATFORM_MANIFEST_NOT_AUTHORIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340863));
pub const STATUS_PLATFORM_MANIFEST_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340862));
pub const STATUS_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340861));
pub const STATUS_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340860));
pub const STATUS_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340859));
pub const STATUS_PLATFORM_MANIFEST_NOT_ACTIVE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340858));
pub const STATUS_PLATFORM_MANIFEST_NOT_SIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058340857));
pub const STATUS_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471935));
pub const STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471934));
pub const STATUS_SYSTEM_INTEGRITY_INVALID_POLICY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471933));
pub const STATUS_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471932));
pub const STATUS_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471931));
pub const STATUS_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058471930));
pub const STATUS_NO_APPLICABLE_APP_LICENSES_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406399));
pub const STATUS_CLIP_LICENSE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406398));
pub const STATUS_CLIP_DEVICE_LICENSE_MISSING = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406397));
pub const STATUS_CLIP_LICENSE_INVALID_SIGNATURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406396));
pub const STATUS_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406395));
pub const STATUS_CLIP_LICENSE_EXPIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406394));
pub const STATUS_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406393));
pub const STATUS_CLIP_LICENSE_NOT_SIGNED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406392));
pub const STATUS_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406391));
pub const STATUS_CLIP_LICENSE_DEVICE_ID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058406390));
pub const STATUS_AUDIO_ENGINE_NODE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069285375));
pub const STATUS_HDAUDIO_EMPTY_CONNECTION_LIST = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069285374));
pub const STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069285373));
pub const STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069285372));
pub const STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069285371));
pub const STATUS_SPACES_REPAIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 15138816));
pub const STATUS_SPACES_PAUSE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 15138817));
pub const STATUS_SPACES_COMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 15138818));
pub const STATUS_SPACES_REDIRECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, 15138819));
pub const STATUS_SPACES_FAULT_DOMAIN_TYPE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058603007));
pub const STATUS_SPACES_RESILIENCY_TYPE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058603005));
pub const STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058603004));
pub const STATUS_SPACES_DRIVE_REDUNDANCY_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058603002));
pub const STATUS_SPACES_NUMBER_OF_DATA_COPIES_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058603001));
pub const STATUS_SPACES_INTERLEAVE_LENGTH_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602999));
pub const STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602998));
pub const STATUS_SPACES_NOT_ENOUGH_DRIVES = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602997));
pub const STATUS_SPACES_EXTENDED_ERROR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602996));
pub const STATUS_SPACES_PROVISIONING_TYPE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602995));
pub const STATUS_SPACES_ALLOCATION_SIZE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602994));
pub const STATUS_SPACES_ENCLOSURE_AWARE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602993));
pub const STATUS_SPACES_WRITE_CACHE_SIZE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602992));
pub const STATUS_SPACES_NUMBER_OF_GROUPS_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602991));
pub const STATUS_SPACES_DRIVE_OPERATIONAL_STATE_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602990));
pub const STATUS_SPACES_UPDATE_COLUMN_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602989));
pub const STATUS_SPACES_MAP_REQUIRED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602988));
pub const STATUS_SPACES_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602987));
pub const STATUS_SPACES_CORRUPT_METADATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602986));
pub const STATUS_SPACES_DRT_FULL = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602985));
pub const STATUS_SPACES_INCONSISTENCY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602984));
pub const STATUS_SPACES_LOG_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602983));
pub const STATUS_SPACES_NO_REDUNDANCY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602982));
pub const STATUS_SPACES_DRIVE_NOT_READY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602981));
pub const STATUS_SPACES_DRIVE_SPLIT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602980));
pub const STATUS_SPACES_DRIVE_LOST_DATA = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602979));
pub const STATUS_SPACES_ENTRY_INCOMPLETE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602978));
pub const STATUS_SPACES_ENTRY_INVALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602977));
pub const STATUS_SPACES_MARK_DIRTY = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058602976));
pub const STATUS_VOLSNAP_BOOTFILE_NOT_VALID = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1068498941));
pub const STATUS_VOLSNAP_ACTIVATION_TIMEOUT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1068498940));
pub const STATUS_IO_PREEMPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1068433407));
pub const STATUS_SVHDX_ERROR_STORED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067712512));
pub const STATUS_SVHDX_ERROR_NOT_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647232));
pub const STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647231));
pub const STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647230));
pub const STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647229));
pub const STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647228));
pub const STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647227));
pub const STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647226));
pub const STATUS_SVHDX_RESERVATION_CONFLICT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647225));
pub const STATUS_SVHDX_WRONG_FILE_TYPE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647224));
pub const STATUS_SVHDX_VERSION_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647223));
pub const STATUS_VHD_SHARED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647222));
pub const STATUS_SVHDX_NO_INITIATOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647221));
pub const STATUS_VHDSET_BACKING_STORAGE_NOT_FOUND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067647220));
pub const STATUS_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067646976));
pub const STATUS_SMB_BAD_CLUSTER_DIALECT = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067646975));
pub const STATUS_SMB_GUEST_LOGON_BLOCKED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1067646974));
pub const STATUS_SECCORE_INVALID_COMMAND = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058537472));
pub const STATUS_VSM_NOT_INITIALIZED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069219840));
pub const STATUS_VSM_DMA_PROTECTION_NOT_IN_USE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1069219839));
pub const STATUS_APPEXEC_CONDITION_NOT_SATISFIED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275328));
pub const STATUS_APPEXEC_HANDLE_INVALIDATED = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275327));
pub const STATUS_APPEXEC_INVALID_HOST_GENERATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275326));
pub const STATUS_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275325));
pub const STATUS_APPEXEC_INVALID_HOST_STATE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275324));
pub const STATUS_APPEXEC_NO_DONOR = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275323));
pub const STATUS_APPEXEC_HOST_ID_MISMATCH = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275322));
pub const STATUS_APPEXEC_UNKNOWN_USER = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1058275321));
pub const STATUS_QUIC_HANDSHAKE_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071382528));
pub const STATUS_QUIC_VER_NEG_FAILURE = @import("../zig.zig").typedConst(NTSTATUS, @as(i32, -1071382527));

//--------------------------------------------------------------------------------
// Section: Types (1690)
//--------------------------------------------------------------------------------
pub const PUMS_SCHEDULER_ENTRY_POINT = fn(
    Reason: RTL_UMS_SCHEDULER_REASON,
    ActivationPayload: usize,
    SchedulerParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CONSOLE_MODE = extern enum(u32) {
    ENABLE_ECHO_INPUT = 4,
    ENABLE_INSERT_MODE = 32,
    ENABLE_LINE_INPUT = 2,
    ENABLE_MOUSE_INPUT = 16,
    ENABLE_PROCESSED_INPUT = 1,
    ENABLE_QUICK_EDIT_MODE = 64,
    ENABLE_WINDOW_INPUT = 8,
    ENABLE_VIRTUAL_TERMINAL_INPUT = 512,
    ENABLE_PROCESSED_OUTPUT = 1,
    ENABLE_WRAP_AT_EOL_OUTPUT = 2,
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4,
    DISABLE_NEWLINE_AUTO_RETURN = 8,
    ENABLE_LVB_GRID_WORLDWIDE = 16,
    _,
};
pub const ENABLE_ECHO_INPUT = CONSOLE_MODE.ENABLE_ECHO_INPUT;
pub const ENABLE_INSERT_MODE = CONSOLE_MODE.ENABLE_INSERT_MODE;
pub const ENABLE_LINE_INPUT = CONSOLE_MODE.ENABLE_LINE_INPUT;
pub const ENABLE_MOUSE_INPUT = CONSOLE_MODE.ENABLE_MOUSE_INPUT;
pub const ENABLE_PROCESSED_INPUT = CONSOLE_MODE.ENABLE_PROCESSED_INPUT;
pub const ENABLE_QUICK_EDIT_MODE = CONSOLE_MODE.ENABLE_QUICK_EDIT_MODE;
pub const ENABLE_WINDOW_INPUT = CONSOLE_MODE.ENABLE_WINDOW_INPUT;
pub const ENABLE_VIRTUAL_TERMINAL_INPUT = CONSOLE_MODE.ENABLE_VIRTUAL_TERMINAL_INPUT;
pub const ENABLE_PROCESSED_OUTPUT = CONSOLE_MODE.ENABLE_PROCESSED_OUTPUT;
pub const ENABLE_WRAP_AT_EOL_OUTPUT = CONSOLE_MODE.ENABLE_WRAP_AT_EOL_OUTPUT;
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING = CONSOLE_MODE.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
pub const DISABLE_NEWLINE_AUTO_RETURN = CONSOLE_MODE.DISABLE_NEWLINE_AUTO_RETURN;
pub const ENABLE_LVB_GRID_WORLDWIDE = CONSOLE_MODE.ENABLE_LVB_GRID_WORLDWIDE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PROCESS_ACCESS_RIGHTS = extern enum(u32) {
    PROCESS_TERMINATE = 1,
    PROCESS_CREATE_THREAD = 2,
    PROCESS_SET_SESSIONID = 4,
    PROCESS_VM_OPERATION = 8,
    PROCESS_VM_READ = 16,
    PROCESS_VM_WRITE = 32,
    PROCESS_DUP_HANDLE = 64,
    PROCESS_CREATE_PROCESS = 128,
    PROCESS_SET_QUOTA = 256,
    PROCESS_SET_INFORMATION = 512,
    PROCESS_QUERY_INFORMATION = 1024,
    PROCESS_SUSPEND_RESUME = 2048,
    PROCESS_QUERY_LIMITED_INFORMATION = 4096,
    PROCESS_SET_LIMITED_INFORMATION = 8192,
    PROCESS_ALL_ACCESS = 2097151,
    DELETE = 65536,
    READ_CONTROL = 131072,
    WRITE_DAC = 262144,
    WRITE_OWNER = 524288,
    SYNCHRONIZE = 1048576,
    STANDARD_RIGHTS_REQUIRED = 983040,
    _,
};
pub const PROCESS_TERMINATE = PROCESS_ACCESS_RIGHTS.PROCESS_TERMINATE;
pub const PROCESS_CREATE_THREAD = PROCESS_ACCESS_RIGHTS.PROCESS_CREATE_THREAD;
pub const PROCESS_SET_SESSIONID = PROCESS_ACCESS_RIGHTS.PROCESS_SET_SESSIONID;
pub const PROCESS_VM_OPERATION = PROCESS_ACCESS_RIGHTS.PROCESS_VM_OPERATION;
pub const PROCESS_VM_READ = PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ;
pub const PROCESS_VM_WRITE = PROCESS_ACCESS_RIGHTS.PROCESS_VM_WRITE;
pub const PROCESS_DUP_HANDLE = PROCESS_ACCESS_RIGHTS.PROCESS_DUP_HANDLE;
pub const PROCESS_CREATE_PROCESS = PROCESS_ACCESS_RIGHTS.PROCESS_CREATE_PROCESS;
pub const PROCESS_SET_QUOTA = PROCESS_ACCESS_RIGHTS.PROCESS_SET_QUOTA;
pub const PROCESS_SET_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_SET_INFORMATION;
pub const PROCESS_QUERY_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_QUERY_INFORMATION;
pub const PROCESS_SUSPEND_RESUME = PROCESS_ACCESS_RIGHTS.PROCESS_SUSPEND_RESUME;
pub const PROCESS_QUERY_LIMITED_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_QUERY_LIMITED_INFORMATION;
pub const PROCESS_SET_LIMITED_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_SET_LIMITED_INFORMATION;
pub const PROCESS_ALL_ACCESS = PROCESS_ACCESS_RIGHTS.PROCESS_ALL_ACCESS;
pub const DELETE = PROCESS_ACCESS_RIGHTS.DELETE;
pub const READ_CONTROL = PROCESS_ACCESS_RIGHTS.READ_CONTROL;
pub const WRITE_DAC = PROCESS_ACCESS_RIGHTS.WRITE_DAC;
pub const WRITE_OWNER = PROCESS_ACCESS_RIGHTS.WRITE_OWNER;
pub const SYNCHRONIZE = PROCESS_ACCESS_RIGHTS.SYNCHRONIZE;
pub const STANDARD_RIGHTS_REQUIRED = PROCESS_ACCESS_RIGHTS.STANDARD_RIGHTS_REQUIRED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_LIMIT = extern enum(u32) {
    LIMIT_WORKINGSET = 1,
    LIMIT_PROCESS_TIME = 2,
    LIMIT_JOB_TIME = 4,
    LIMIT_ACTIVE_PROCESS = 8,
    LIMIT_AFFINITY = 16,
    LIMIT_PRIORITY_CLASS = 32,
    LIMIT_PRESERVE_JOB_TIME = 64,
    LIMIT_SCHEDULING_CLASS = 128,
    LIMIT_PROCESS_MEMORY = 256,
    LIMIT_JOB_MEMORY = 512,
    LIMIT_JOB_MEMORY_HIGH = 512,
    LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024,
    LIMIT_BREAKAWAY_OK = 2048,
    LIMIT_SILENT_BREAKAWAY_OK = 4096,
    LIMIT_KILL_ON_JOB_CLOSE = 8192,
    LIMIT_SUBSET_AFFINITY = 16384,
    LIMIT_JOB_MEMORY_LOW = 32768,
    LIMIT_JOB_READ_BYTES = 65536,
    LIMIT_JOB_WRITE_BYTES = 131072,
    LIMIT_RATE_CONTROL = 262144,
    LIMIT_CPU_RATE_CONTROL = 262144,
    LIMIT_IO_RATE_CONTROL = 524288,
    LIMIT_NET_RATE_CONTROL = 1048576,
    LIMIT_VALID_FLAGS = 524287,
    BASIC_LIMIT_VALID_FLAGS = 255,
    EXTENDED_LIMIT_VALID_FLAGS = 32767,
    NOTIFICATION_LIMIT_VALID_FLAGS = 2064900,
    _,
};
pub const JOB_OBJECT_LIMIT_WORKINGSET = JOB_OBJECT_LIMIT.LIMIT_WORKINGSET;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME = JOB_OBJECT_LIMIT.LIMIT_PROCESS_TIME;
pub const JOB_OBJECT_LIMIT_JOB_TIME = JOB_OBJECT_LIMIT.LIMIT_JOB_TIME;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS = JOB_OBJECT_LIMIT.LIMIT_ACTIVE_PROCESS;
pub const JOB_OBJECT_LIMIT_AFFINITY = JOB_OBJECT_LIMIT.LIMIT_AFFINITY;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS = JOB_OBJECT_LIMIT.LIMIT_PRIORITY_CLASS;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = JOB_OBJECT_LIMIT.LIMIT_PRESERVE_JOB_TIME;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS = JOB_OBJECT_LIMIT.LIMIT_SCHEDULING_CLASS;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY = JOB_OBJECT_LIMIT.LIMIT_PROCESS_MEMORY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY = JOB_OBJECT_LIMIT.LIMIT_JOB_MEMORY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH = JOB_OBJECT_LIMIT.LIMIT_JOB_MEMORY_HIGH;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = JOB_OBJECT_LIMIT.LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK = JOB_OBJECT_LIMIT.LIMIT_BREAKAWAY_OK;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = JOB_OBJECT_LIMIT.LIMIT_SILENT_BREAKAWAY_OK;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = JOB_OBJECT_LIMIT.LIMIT_KILL_ON_JOB_CLOSE;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY = JOB_OBJECT_LIMIT.LIMIT_SUBSET_AFFINITY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW = JOB_OBJECT_LIMIT.LIMIT_JOB_MEMORY_LOW;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES = JOB_OBJECT_LIMIT.LIMIT_JOB_READ_BYTES;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES = JOB_OBJECT_LIMIT.LIMIT_JOB_WRITE_BYTES;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL = JOB_OBJECT_LIMIT.LIMIT_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL = JOB_OBJECT_LIMIT.LIMIT_CPU_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL = JOB_OBJECT_LIMIT.LIMIT_IO_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL = JOB_OBJECT_LIMIT.LIMIT_NET_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.LIMIT_VALID_FLAGS;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.BASIC_LIMIT_VALID_FLAGS;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.EXTENDED_LIMIT_VALID_FLAGS;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.NOTIFICATION_LIMIT_VALID_FLAGS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_UILIMIT = extern enum(u32) {
    NONE = 0,
    HANDLES = 1,
    READCLIPBOARD = 2,
    WRITECLIPBOARD = 4,
    SYSTEMPARAMETERS = 8,
    DISPLAYSETTINGS = 16,
    GLOBALATOMS = 32,
    DESKTOP = 64,
    EXITWINDOWS = 128,
    _,
};
pub const JOB_OBJECT_UILIMIT_NONE = JOB_OBJECT_UILIMIT.NONE;
pub const JOB_OBJECT_UILIMIT_HANDLES = JOB_OBJECT_UILIMIT.HANDLES;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD = JOB_OBJECT_UILIMIT.READCLIPBOARD;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD = JOB_OBJECT_UILIMIT.WRITECLIPBOARD;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = JOB_OBJECT_UILIMIT.SYSTEMPARAMETERS;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = JOB_OBJECT_UILIMIT.DISPLAYSETTINGS;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS = JOB_OBJECT_UILIMIT.GLOBALATOMS;
pub const JOB_OBJECT_UILIMIT_DESKTOP = JOB_OBJECT_UILIMIT.DESKTOP;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS = JOB_OBJECT_UILIMIT.EXITWINDOWS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_SECURITY = extern enum(u32) {
    NO_ADMIN = 1,
    RESTRICTED_TOKEN = 2,
    ONLY_TOKEN = 4,
    FILTER_TOKENS = 8,
    VALID_FLAGS = 15,
    _,
};
pub const JOB_OBJECT_SECURITY_NO_ADMIN = JOB_OBJECT_SECURITY.NO_ADMIN;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = JOB_OBJECT_SECURITY.RESTRICTED_TOKEN;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN = JOB_OBJECT_SECURITY.ONLY_TOKEN;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS = JOB_OBJECT_SECURITY.FILTER_TOKENS;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS = JOB_OBJECT_SECURITY.VALID_FLAGS;

pub const WAIT_RETURN_CAUSE = extern enum(u32) {
    OBJECT_0 = 0,
    ABANDONED = 128,
    ABANDONED_0 = 128,
    IO_COMPLETION = 192,
    TIMEOUT = 258,
    FAILED = 4294967295,
};
pub const WAIT_OBJECT_0 = WAIT_RETURN_CAUSE.OBJECT_0;
pub const WAIT_ABANDONED = WAIT_RETURN_CAUSE.ABANDONED;
pub const WAIT_ABANDONED_0 = WAIT_RETURN_CAUSE.ABANDONED_0;
pub const WAIT_IO_COMPLETION = WAIT_RETURN_CAUSE.IO_COMPLETION;
pub const WAIT_TIMEOUT = WAIT_RETURN_CAUSE.TIMEOUT;
pub const WAIT_FAILED = WAIT_RETURN_CAUSE.FAILED;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const XSAVE_FORMAT = extern struct {
    ControlWord: u16,
    StatusWord: u16,
    TagWord: u8,
    Reserved1: u8,
    ErrorOpcode: u16,
    ErrorOffset: u32,
    ErrorSelector: u16,
    Reserved2: u16,
    DataOffset: u32,
    DataSelector: u16,
    Reserved3: u16,
    MxCsr: u32,
    MxCsr_Mask: u32,
    FloatRegisters: [8]M128A,
    XmmRegisters: [16]M128A,
    Reserved4: [96]u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const XSTATE_CONTEXT = extern struct {
    Mask: u64,
    Length: u32,
    Reserved1: u32,
    Area: *XSAVE_AREA,
    Buffer: *c_void,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const ARM64_NT_NEON128 = extern union {
    Anonymous: _Anonymous_e__Struct,
    D: [2]f64,
    S: [4]f32,
    H: [8]u16,
    B: [16]u8,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const UNWIND_HISTORY_TABLE_ENTRY = extern struct {
    ImageBase: u64,
    FunctionEntry: *IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const UNWIND_HISTORY_TABLE = extern struct {
    Count: u32,
    LocalHint: u8,
    GlobalHint: u8,
    Search: u8,
    Once: u8,
    LowAddress: u64,
    HighAddress: u64,
    Entry: [12]UNWIND_HISTORY_TABLE_ENTRY,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const DISPATCHER_CONTEXT = extern struct {
    ControlPc: usize,
    ImageBase: usize,
    FunctionEntry: *IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    EstablisherFrame: usize,
    TargetPc: usize,
    ContextRecord: *CONTEXT,
    LanguageHandler: EXCEPTION_ROUTINE,
    HandlerData: *c_void,
    HistoryTable: *UNWIND_HISTORY_TABLE,
    ScopeIndex: u32,
    ControlPcIsUnwound: u8,
    NonVolatileRegisters: *u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const PEXCEPTION_FILTER = fn(
    ExceptionPointers: *EXCEPTION_POINTERS,
    EstablisherFrame: u64,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const PTERMINATION_HANDLER = fn(
    _abnormal_termination: u8,
    EstablisherFrame: u64,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const PGET_RUNTIME_FUNCTION_CALLBACK = fn(
    ControlPc: u64,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = fn(
    Process: HANDLE,
    TableAddress: *c_void,
    Entries: *u32,
    Functions: **IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const MEMORY_BASIC_INFORMATION = extern struct {
    BaseAddress: *c_void,
    AllocationBase: *c_void,
    AllocationProtect: u32,
    PartitionId: u16,
    RegionSize: usize,
    State: VIRTUAL_ALLOCATION_TYPE,
    Protect: u32,
    Type: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const REARRANGE_FILE_DATA32 = extern struct {
    SourceStartingOffset: u64,
    TargetOffset: u64,
    SourceFileHandle: u32,
    Length: u32,
    Flags: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const SLIST_ENTRY = extern struct {
    Next: *SLIST_ENTRY,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.Arm64 => struct {

pub const SLIST_HEADER = extern union {
    Anonymous: _Anonymous_e__Struct,
    HeaderArm64: _HeaderArm64_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
    const _HeaderArm64_e__Struct = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub const TP_CALLBACK_INSTANCE = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_POOL = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_CLEANUP_GROUP = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_WORK = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_TIMER = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_WAIT = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TP_IO = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const TEB = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const FARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) isize;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const NEARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) isize;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const PROC = fn(
) callconv(@import("std").os.windows.WINAPI) isize;

}, else => struct { } };

}, else => struct { } };

pub const IVssExamineWriterMetadata = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDDVideoPortContainer = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawVideoPort = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawVideoPortNotify = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDDVideoPortContainerVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawVideoPortVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const IDirectDrawVideoPortNotifyVtbl = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _DD_DESTROYDRIVERDATA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _DD_SETMODEDATA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const _DD_GETVPORTAUTOFLIPSURFACEDATA = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const MOVE_FILE_DATA32 = extern struct {
    FileHandle: u32,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const DUPLICATE_EXTENTS_DATA32 = extern struct {
    FileHandle: u32,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const DUPLICATE_EXTENTS_DATA_EX32 = extern struct {
    Size: u32,
    FileHandle: u32,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: u32,
};

}, else => struct { } };

pub const AtlThunkData_t = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86, .Arm64 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION = fn(
    ExceptionRecord: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub const FLOAT128 = extern struct {
    LowPart: i64,
    HighPart: i64,
};

pub const LARGE_INTEGER = extern union {
    Anonymous: _Anonymous_e__Struct,
    u: _u_e__Struct,
    QuadPart: i64,
    const _u_e__Struct = u32; // TODO: generate this nested type!
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const ULARGE_INTEGER = extern union {
    Anonymous: _Anonymous_e__Struct,
    u: _u_e__Struct,
    QuadPart: u64,
    const _u_e__Struct = u32; // TODO: generate this nested type!
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const M128A = extern struct {
    Low: u64,
    High: i64,
};

pub const XSAVE_CET_U_FORMAT = extern struct {
    Ia32CetUMsr: u64,
    Ia32Pl3SspMsr: u64,
};

pub const XSAVE_AREA_HEADER = extern struct {
    Mask: u64,
    CompactionMask: u64,
    Reserved2: [6]u64,
};

pub const XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};

pub const SCOPE_TABLE_AMD64 = extern struct {
    Count: u32,
    ScopeRecord: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const UNWIND_HISTORY_TABLE_ENTRY = extern struct {
    ImageBase: u64,
    FunctionEntry: *IMAGE_RUNTIME_FUNCTION_ENTRY,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const PGET_RUNTIME_FUNCTION_CALLBACK = fn(
    ControlPc: u64,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *IMAGE_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = fn(
    Process: HANDLE,
    TableAddress: *c_void,
    Entries: *u32,
    Functions: **IMAGE_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const DISPATCHER_CONTEXT = extern struct {
    ControlPc: u64,
    ImageBase: u64,
    FunctionEntry: *IMAGE_RUNTIME_FUNCTION_ENTRY,
    EstablisherFrame: u64,
    TargetIp: u64,
    ContextRecord: *CONTEXT,
    LanguageHandler: EXCEPTION_ROUTINE,
    HandlerData: *c_void,
    HistoryTable: *UNWIND_HISTORY_TABLE,
    ScopeIndex: u32,
    Fill0: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const PEXCEPTION_FILTER = fn(
    ExceptionPointers: *EXCEPTION_POINTERS,
    EstablisherFrame: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const PTERMINATION_HANDLER = fn(
    _abnormal_termination: u8,
    EstablisherFrame: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub const SCOPE_TABLE_ARM = extern struct {
    Count: u32,
    ScopeRecord: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const SCOPE_TABLE_ARM64 = extern struct {
    Count: u32,
    ScopeRecord: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = extern struct {
    X19: *u64,
    X20: *u64,
    X21: *u64,
    X22: *u64,
    X23: *u64,
    X24: *u64,
    X25: *u64,
    X26: *u64,
    X27: *u64,
    X28: *u64,
    Fp: *u64,
    Lr: *u64,
    D8: *u64,
    D9: *u64,
    D10: *u64,
    D11: *u64,
    D12: *u64,
    D13: *u64,
    D14: *u64,
    D15: *u64,
};

pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};

pub const EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u32,
    ExceptionAddress: u32,
    NumberParameters: u32,
    ExceptionInformation: [15]u32,
};

pub const SE_SID = extern union {
    Sid: SID,
    Buffer: [68]u8,
};

pub const SYSTEM_PROCESS_TRUST_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ACCESS_FILTER_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SECURITY_DESCRIPTOR_RELATIVE = extern struct {
    Revision: u8,
    Sbz1: u8,
    Control: u16,
    Owner: u32,
    Group: u32,
    Sacl: u32,
    Dacl: u32,
};

pub const SECURITY_OBJECT_AI_PARAMS = extern struct {
    Size: u32,
    ConstraintMask: u32,
};

pub const ACCESS_REASON_TYPE = extern enum(i32) {
    None = 0,
    AllowedAce = 65536,
    DeniedAce = 131072,
    AllowedParentAce = 196608,
    DeniedParentAce = 262144,
    NotGrantedByCape = 327680,
    NotGrantedByParentCape = 393216,
    NotGrantedToAppContainer = 458752,
    MissingPrivilege = 1048576,
    FromPrivilege = 2097152,
    IntegrityLevel = 3145728,
    Ownership = 4194304,
    NullDacl = 5242880,
    EmptyDacl = 6291456,
    NoSD = 7340032,
    NoGrant = 8388608,
    TrustLabel = 9437184,
    FilterAce = 10485760,
};
pub const AccessReasonNone = ACCESS_REASON_TYPE.None;
pub const AccessReasonAllowedAce = ACCESS_REASON_TYPE.AllowedAce;
pub const AccessReasonDeniedAce = ACCESS_REASON_TYPE.DeniedAce;
pub const AccessReasonAllowedParentAce = ACCESS_REASON_TYPE.AllowedParentAce;
pub const AccessReasonDeniedParentAce = ACCESS_REASON_TYPE.DeniedParentAce;
pub const AccessReasonNotGrantedByCape = ACCESS_REASON_TYPE.NotGrantedByCape;
pub const AccessReasonNotGrantedByParentCape = ACCESS_REASON_TYPE.NotGrantedByParentCape;
pub const AccessReasonNotGrantedToAppContainer = ACCESS_REASON_TYPE.NotGrantedToAppContainer;
pub const AccessReasonMissingPrivilege = ACCESS_REASON_TYPE.MissingPrivilege;
pub const AccessReasonFromPrivilege = ACCESS_REASON_TYPE.FromPrivilege;
pub const AccessReasonIntegrityLevel = ACCESS_REASON_TYPE.IntegrityLevel;
pub const AccessReasonOwnership = ACCESS_REASON_TYPE.Ownership;
pub const AccessReasonNullDacl = ACCESS_REASON_TYPE.NullDacl;
pub const AccessReasonEmptyDacl = ACCESS_REASON_TYPE.EmptyDacl;
pub const AccessReasonNoSD = ACCESS_REASON_TYPE.NoSD;
pub const AccessReasonNoGrant = ACCESS_REASON_TYPE.NoGrant;
pub const AccessReasonTrustLabel = ACCESS_REASON_TYPE.TrustLabel;
pub const AccessReasonFilterAce = ACCESS_REASON_TYPE.FilterAce;

pub const ACCESS_REASONS = extern struct {
    Data: [32]u32,
};

pub const SE_SECURITY_DESCRIPTOR = extern struct {
    Size: u32,
    Flags: u32,
    SecurityDescriptor: *SECURITY_DESCRIPTOR,
};

pub const SE_ACCESS_REQUEST = extern struct {
    Size: u32,
    SeSecurityDescriptor: *SE_SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    PreviouslyGrantedAccess: u32,
    PrincipalSelfSid: PSID,
    GenericMapping: *GENERIC_MAPPING,
    ObjectTypeListCount: u32,
    ObjectTypeList: *OBJECT_TYPE_LIST,
};

pub const SE_ACCESS_REPLY = extern struct {
    Size: u32,
    ResultListCount: u32,
    GrantedAccess: *u32,
    AccessStatus: *u32,
    AccessReason: *ACCESS_REASONS,
    Privileges: **PRIVILEGE_SET,
};

pub const SE_TOKEN_USER = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const TOKEN_SID_INFORMATION = extern struct {
    Sid: PSID,
};

pub const TOKEN_BNO_ISOLATION_INFORMATION = extern struct {
    IsolationPrefix: PWSTR,
    IsolationEnabled: u8,
};

pub const SE_IMPERSONATION_STATE = extern struct {
    Token: *c_void,
    CopyOnOpen: u8,
    EffectiveOnly: u8,
    Level: SECURITY_IMPERSONATION_LEVEL,
};

pub const SE_IMAGE_SIGNATURE_TYPE = extern enum(i32) {
    None = 0,
    Embedded = 1,
    Cache = 2,
    CatalogCached = 3,
    CatalogNotCached = 4,
    CatalogHint = 5,
    PackageCatalog = 6,
};
pub const SeImageSignatureNone = SE_IMAGE_SIGNATURE_TYPE.None;
pub const SeImageSignatureEmbedded = SE_IMAGE_SIGNATURE_TYPE.Embedded;
pub const SeImageSignatureCache = SE_IMAGE_SIGNATURE_TYPE.Cache;
pub const SeImageSignatureCatalogCached = SE_IMAGE_SIGNATURE_TYPE.CatalogCached;
pub const SeImageSignatureCatalogNotCached = SE_IMAGE_SIGNATURE_TYPE.CatalogNotCached;
pub const SeImageSignatureCatalogHint = SE_IMAGE_SIGNATURE_TYPE.CatalogHint;
pub const SeImageSignaturePackageCatalog = SE_IMAGE_SIGNATURE_TYPE.PackageCatalog;

pub const SE_LEARNING_MODE_DATA_TYPE = extern enum(i32) {
    InvalidType = 0,
    Settings = 1,
    Max = 2,
};
pub const SeLearningModeInvalidType = SE_LEARNING_MODE_DATA_TYPE.InvalidType;
pub const SeLearningModeSettings = SE_LEARNING_MODE_DATA_TYPE.Settings;
pub const SeLearningModeMax = SE_LEARNING_MODE_DATA_TYPE.Max;

pub const JOB_SET_ARRAY = extern struct {
    JobHandle: HANDLE,
    MemberLevel: u32,
    Flags: u32,
};

pub const EXCEPTION_REGISTRATION_RECORD = extern struct {
    Next: *EXCEPTION_REGISTRATION_RECORD,
    Handler: EXCEPTION_ROUTINE,
};

pub const NT_TIB = extern struct {
    ExceptionList: *EXCEPTION_REGISTRATION_RECORD,
    StackBase: *c_void,
    StackLimit: *c_void,
    SubSystemTib: *c_void,
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: *c_void,
    Self: *NT_TIB,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const NT_TIB32 = extern struct {
    ExceptionList: u32,
    StackBase: u32,
    StackLimit: u32,
    SubSystemTib: u32,
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: u32,
    Self: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const NT_TIB64 = extern struct {
    ExceptionList: u64,
    StackBase: u64,
    StackLimit: u64,
    SubSystemTib: u64,
    Anonymous: _Anonymous_e__Union,
    ArbitraryUserPointer: u64,
    Self: u64,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const UMS_CREATE_THREAD_ATTRIBUTES = extern struct {
    UmsVersion: u32,
    UmsContext: *c_void,
    UmsCompletionList: *c_void,
};

pub const WOW64_ARCHITECTURE_INFORMATION = extern struct {
    _bitfield: u32,
};

pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = extern struct {
    TargetAddress: usize,
    Flags: usize,
};

pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION = extern struct {
    NumberOfTargets: u16,
    Reserved: u16,
    Reserved2: u32,
    Targets: *PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
};

pub const RATE_QUOTA_LIMIT = extern union {
    RateData: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const QUOTA_LIMITS_EX = extern struct {
    PagedPoolLimit: usize,
    NonPagedPoolLimit: usize,
    MinimumWorkingSetSize: usize,
    MaximumWorkingSetSize: usize,
    PagefileLimit: usize,
    TimeLimit: LARGE_INTEGER,
    WorkingSetLimit: usize,
    Reserved2: usize,
    Reserved3: usize,
    Reserved4: usize,
    Flags: u32,
    CpuRateLimit: RATE_QUOTA_LIMIT,
};

pub const IO_COUNTERS = extern struct {
    ReadOperationCount: u64,
    WriteOperationCount: u64,
    OtherOperationCount: u64,
    ReadTransferCount: u64,
    WriteTransferCount: u64,
    OtherTransferCount: u64,
};

pub const PROCESS_MITIGATION_POLICY = extern enum(i32) {
    ProcessDEPPolicy = 0,
    ProcessASLRPolicy = 1,
    ProcessDynamicCodePolicy = 2,
    ProcessStrictHandleCheckPolicy = 3,
    ProcessSystemCallDisablePolicy = 4,
    ProcessMitigationOptionsMask = 5,
    ProcessExtensionPointDisablePolicy = 6,
    ProcessControlFlowGuardPolicy = 7,
    ProcessSignaturePolicy = 8,
    ProcessFontDisablePolicy = 9,
    ProcessImageLoadPolicy = 10,
    ProcessSystemCallFilterPolicy = 11,
    ProcessPayloadRestrictionPolicy = 12,
    ProcessChildProcessPolicy = 13,
    ProcessSideChannelIsolationPolicy = 14,
    ProcessUserShadowStackPolicy = 15,
    MaxProcessMitigationPolicy = 16,
};
pub const ProcessDEPPolicy = PROCESS_MITIGATION_POLICY.ProcessDEPPolicy;
pub const ProcessASLRPolicy = PROCESS_MITIGATION_POLICY.ProcessASLRPolicy;
pub const ProcessDynamicCodePolicy = PROCESS_MITIGATION_POLICY.ProcessDynamicCodePolicy;
pub const ProcessStrictHandleCheckPolicy = PROCESS_MITIGATION_POLICY.ProcessStrictHandleCheckPolicy;
pub const ProcessSystemCallDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessSystemCallDisablePolicy;
pub const ProcessMitigationOptionsMask = PROCESS_MITIGATION_POLICY.ProcessMitigationOptionsMask;
pub const ProcessExtensionPointDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessExtensionPointDisablePolicy;
pub const ProcessControlFlowGuardPolicy = PROCESS_MITIGATION_POLICY.ProcessControlFlowGuardPolicy;
pub const ProcessSignaturePolicy = PROCESS_MITIGATION_POLICY.ProcessSignaturePolicy;
pub const ProcessFontDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessFontDisablePolicy;
pub const ProcessImageLoadPolicy = PROCESS_MITIGATION_POLICY.ProcessImageLoadPolicy;
pub const ProcessSystemCallFilterPolicy = PROCESS_MITIGATION_POLICY.ProcessSystemCallFilterPolicy;
pub const ProcessPayloadRestrictionPolicy = PROCESS_MITIGATION_POLICY.ProcessPayloadRestrictionPolicy;
pub const ProcessChildProcessPolicy = PROCESS_MITIGATION_POLICY.ProcessChildProcessPolicy;
pub const ProcessSideChannelIsolationPolicy = PROCESS_MITIGATION_POLICY.ProcessSideChannelIsolationPolicy;
pub const ProcessUserShadowStackPolicy = PROCESS_MITIGATION_POLICY.ProcessUserShadowStackPolicy;
pub const MaxProcessMitigationPolicy = PROCESS_MITIGATION_POLICY.MaxProcessMitigationPolicy;

pub const PROCESS_MITIGATION_ASLR_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_DEP_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    Permanent: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_FONT_DISABLE_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_IMAGE_LOAD_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_CHILD_PROCESS_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = extern struct {
    TotalUserTime: LARGE_INTEGER,
    TotalKernelTime: LARGE_INTEGER,
    ThisPeriodTotalUserTime: LARGE_INTEGER,
    ThisPeriodTotalKernelTime: LARGE_INTEGER,
    TotalPageFaultCount: u32,
    TotalProcesses: u32,
    ActiveProcesses: u32,
    TotalTerminatedProcesses: u32,
};

pub const JOBOBJECT_BASIC_LIMIT_INFORMATION = extern struct {
    PerProcessUserTimeLimit: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    LimitFlags: JOB_OBJECT_LIMIT,
    MinimumWorkingSetSize: usize,
    MaximumWorkingSetSize: usize,
    ActiveProcessLimit: u32,
    Affinity: usize,
    PriorityClass: u32,
    SchedulingClass: u32,
};

pub const JOBOBJECT_EXTENDED_LIMIT_INFORMATION = extern struct {
    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    IoInfo: IO_COUNTERS,
    ProcessMemoryLimit: usize,
    JobMemoryLimit: usize,
    PeakProcessMemoryUsed: usize,
    PeakJobMemoryUsed: usize,
};

pub const JOBOBJECT_BASIC_PROCESS_ID_LIST = extern struct {
    NumberOfAssignedProcesses: u32,
    NumberOfProcessIdsInList: u32,
    ProcessIdList: [1]usize,
};

pub const JOBOBJECT_BASIC_UI_RESTRICTIONS = extern struct {
    UIRestrictionsClass: JOB_OBJECT_UILIMIT,
};

pub const JOBOBJECT_SECURITY_LIMIT_INFORMATION = extern struct {
    SecurityLimitFlags: JOB_OBJECT_SECURITY,
    JobToken: HANDLE,
    SidsToDisable: *TOKEN_GROUPS,
    PrivilegesToDelete: *TOKEN_PRIVILEGES,
    RestrictedSids: *TOKEN_GROUPS,
};

pub const JOBOBJECT_END_OF_JOB_TIME_INFORMATION = extern struct {
    EndOfJobTimeAction: JOB_OBJECT_TERMINATE_AT_END_ACTION,
};

pub const JOBOBJECT_ASSOCIATE_COMPLETION_PORT = extern struct {
    CompletionKey: *c_void,
    CompletionPort: HANDLE,
};

pub const JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = extern struct {
    BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    IoInfo: IO_COUNTERS,
};

pub const JOBOBJECT_JOBSET_INFORMATION = extern struct {
    MemberLevel: u32,
};

pub const JOBOBJECT_RATE_CONTROL_TOLERANCE = extern enum(i32) {
    Low = 1,
    Medium = 2,
    High = 3,
};
pub const ToleranceLow = JOBOBJECT_RATE_CONTROL_TOLERANCE.Low;
pub const ToleranceMedium = JOBOBJECT_RATE_CONTROL_TOLERANCE.Medium;
pub const ToleranceHigh = JOBOBJECT_RATE_CONTROL_TOLERANCE.High;

pub const JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = extern enum(i32) {
    Short = 1,
    Medium = 2,
    Long = 3,
};
// TODO: enum 'JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL' has known issues with its value aliases

pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    LimitFlags: JOB_OBJECT_LIMIT,
};

pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    LimitFlags: JOB_OBJECT_LIMIT,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    JobLowMemoryLimit: u64,
    IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION = extern struct {
    LimitFlags: JOB_OBJECT_LIMIT,
    ViolationLimitFlags: JOB_OBJECT_LIMIT,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
};

pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 = extern struct {
    LimitFlags: JOB_OBJECT_LIMIT,
    ViolationLimitFlags: JOB_OBJECT_LIMIT,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    JobLowMemoryLimit: u64,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = extern struct {
    ControlFlags: JOB_OBJECT_CPU_RATE_CONTROL,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS = extern enum(i32) {
    ENABLE = 1,
    MAX_BANDWIDTH = 2,
    DSCP_TAG = 4,
    VALID_FLAGS = 7,
};
pub const JOB_OBJECT_NET_RATE_CONTROL_ENABLE = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.ENABLE;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.MAX_BANDWIDTH;
pub const JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.DSCP_TAG;
pub const JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.VALID_FLAGS;

pub const JOBOBJECT_NET_RATE_CONTROL_INFORMATION = extern struct {
    MaxBandwidth: u64,
    ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    DscpTag: u8,
};

pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS = extern enum(i32) {
    ENABLE = 1,
    STANDALONE_VOLUME = 2,
    FORCE_UNIT_ACCESS_ALL = 4,
    FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8,
    VALID_FLAGS = 15,
};
pub const JOB_OBJECT_IO_RATE_CONTROL_ENABLE = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.ENABLE;
pub const JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.STANDALONE_VOLUME;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.FORCE_UNIT_ACCESS_ALL;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.FORCE_UNIT_ACCESS_ON_SOFT_CAP;
pub const JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.VALID_FLAGS;

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
};

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
};

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
    SoftMaxIops: i64,
    SoftMaxBandwidth: i64,
    SoftMaxTimePercent: i64,
    LimitExcessNotifyIops: i64,
    LimitExcessNotifyBandwidth: i64,
    LimitExcessNotifyTimePercent: i64,
};

pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = extern enum(i32) {
    ENABLE = 1,
    DISABLE = 2,
    VALID_FLAGS = 3,
};
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.ENABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.DISABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.VALID_FLAGS;

pub const JOBOBJECT_IO_ATTRIBUTION_STATS = extern struct {
    IoCount: usize,
    TotalNonOverlappedQueueTime: u64,
    TotalNonOverlappedServiceTime: u64,
    TotalSize: u64,
};

pub const JOBOBJECT_IO_ATTRIBUTION_INFORMATION = extern struct {
    ControlFlags: u32,
    ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
};

pub const JOBOBJECTINFOCLASS = extern enum(i32) {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    JobObjectReserved9Information = 26,
    JobObjectReserved10Information = 27,
    JobObjectReserved11Information = 28,
    JobObjectReserved12Information = 29,
    JobObjectReserved13Information = 30,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation = 32,
    JobObjectNotificationLimitInformation2 = 33,
    JobObjectLimitViolationInformation2 = 34,
    JobObjectCreateSilo = 35,
    JobObjectSiloBasicInformation = 36,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass = 48,
};
pub const JobObjectBasicAccountingInformation = JOBOBJECTINFOCLASS.JobObjectBasicAccountingInformation;
pub const JobObjectBasicLimitInformation = JOBOBJECTINFOCLASS.JobObjectBasicLimitInformation;
pub const JobObjectBasicProcessIdList = JOBOBJECTINFOCLASS.JobObjectBasicProcessIdList;
pub const JobObjectBasicUIRestrictions = JOBOBJECTINFOCLASS.JobObjectBasicUIRestrictions;
pub const JobObjectSecurityLimitInformation = JOBOBJECTINFOCLASS.JobObjectSecurityLimitInformation;
pub const JobObjectEndOfJobTimeInformation = JOBOBJECTINFOCLASS.JobObjectEndOfJobTimeInformation;
pub const JobObjectAssociateCompletionPortInformation = JOBOBJECTINFOCLASS.JobObjectAssociateCompletionPortInformation;
pub const JobObjectBasicAndIoAccountingInformation = JOBOBJECTINFOCLASS.JobObjectBasicAndIoAccountingInformation;
pub const JobObjectExtendedLimitInformation = JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation;
pub const JobObjectJobSetInformation = JOBOBJECTINFOCLASS.JobObjectJobSetInformation;
pub const JobObjectGroupInformation = JOBOBJECTINFOCLASS.JobObjectGroupInformation;
pub const JobObjectNotificationLimitInformation = JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation;
pub const JobObjectLimitViolationInformation = JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation;
pub const JobObjectGroupInformationEx = JOBOBJECTINFOCLASS.JobObjectGroupInformationEx;
pub const JobObjectCpuRateControlInformation = JOBOBJECTINFOCLASS.JobObjectCpuRateControlInformation;
pub const JobObjectCompletionFilter = JOBOBJECTINFOCLASS.JobObjectCompletionFilter;
pub const JobObjectCompletionCounter = JOBOBJECTINFOCLASS.JobObjectCompletionCounter;
pub const JobObjectReserved1Information = JOBOBJECTINFOCLASS.JobObjectReserved1Information;
pub const JobObjectReserved2Information = JOBOBJECTINFOCLASS.JobObjectReserved2Information;
pub const JobObjectReserved3Information = JOBOBJECTINFOCLASS.JobObjectReserved3Information;
pub const JobObjectReserved4Information = JOBOBJECTINFOCLASS.JobObjectReserved4Information;
pub const JobObjectReserved5Information = JOBOBJECTINFOCLASS.JobObjectReserved5Information;
pub const JobObjectReserved6Information = JOBOBJECTINFOCLASS.JobObjectReserved6Information;
pub const JobObjectReserved7Information = JOBOBJECTINFOCLASS.JobObjectReserved7Information;
pub const JobObjectReserved8Information = JOBOBJECTINFOCLASS.JobObjectReserved8Information;
pub const JobObjectReserved9Information = JOBOBJECTINFOCLASS.JobObjectReserved9Information;
pub const JobObjectReserved10Information = JOBOBJECTINFOCLASS.JobObjectReserved10Information;
pub const JobObjectReserved11Information = JOBOBJECTINFOCLASS.JobObjectReserved11Information;
pub const JobObjectReserved12Information = JOBOBJECTINFOCLASS.JobObjectReserved12Information;
pub const JobObjectReserved13Information = JOBOBJECTINFOCLASS.JobObjectReserved13Information;
pub const JobObjectReserved14Information = JOBOBJECTINFOCLASS.JobObjectReserved14Information;
pub const JobObjectNetRateControlInformation = JOBOBJECTINFOCLASS.JobObjectNetRateControlInformation;
pub const JobObjectNotificationLimitInformation2 = JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation2;
pub const JobObjectLimitViolationInformation2 = JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation2;
pub const JobObjectCreateSilo = JOBOBJECTINFOCLASS.JobObjectCreateSilo;
pub const JobObjectSiloBasicInformation = JOBOBJECTINFOCLASS.JobObjectSiloBasicInformation;
pub const JobObjectReserved15Information = JOBOBJECTINFOCLASS.JobObjectReserved15Information;
pub const JobObjectReserved16Information = JOBOBJECTINFOCLASS.JobObjectReserved16Information;
pub const JobObjectReserved17Information = JOBOBJECTINFOCLASS.JobObjectReserved17Information;
pub const JobObjectReserved18Information = JOBOBJECTINFOCLASS.JobObjectReserved18Information;
pub const JobObjectReserved19Information = JOBOBJECTINFOCLASS.JobObjectReserved19Information;
pub const JobObjectReserved20Information = JOBOBJECTINFOCLASS.JobObjectReserved20Information;
pub const JobObjectReserved21Information = JOBOBJECTINFOCLASS.JobObjectReserved21Information;
pub const JobObjectReserved22Information = JOBOBJECTINFOCLASS.JobObjectReserved22Information;
pub const JobObjectReserved23Information = JOBOBJECTINFOCLASS.JobObjectReserved23Information;
pub const JobObjectReserved24Information = JOBOBJECTINFOCLASS.JobObjectReserved24Information;
pub const JobObjectReserved25Information = JOBOBJECTINFOCLASS.JobObjectReserved25Information;
pub const MaxJobObjectInfoClass = JOBOBJECTINFOCLASS.MaxJobObjectInfoClass;

pub const SILOOBJECT_BASIC_INFORMATION = extern struct {
    SiloId: u32,
    SiloParentId: u32,
    NumberOfProcesses: u32,
    IsInServerSilo: u8,
    Reserved: [3]u8,
};

pub const SERVERSILO_STATE = extern enum(i32) {
    INITING = 0,
    STARTED = 1,
    SHUTTING_DOWN = 2,
    TERMINATING = 3,
    TERMINATED = 4,
};
pub const SERVERSILO_INITING = SERVERSILO_STATE.INITING;
pub const SERVERSILO_STARTED = SERVERSILO_STATE.STARTED;
pub const SERVERSILO_SHUTTING_DOWN = SERVERSILO_STATE.SHUTTING_DOWN;
pub const SERVERSILO_TERMINATING = SERVERSILO_STATE.TERMINATING;
pub const SERVERSILO_TERMINATED = SERVERSILO_STATE.TERMINATED;

pub const SERVERSILO_BASIC_INFORMATION = extern struct {
    ServiceSessionId: u32,
    State: SERVERSILO_STATE,
    ExitStatus: u32,
    IsDownlevelContainer: u8,
    ApiSetSchema: *c_void,
    HostApiSetSchema: *c_void,
};

pub const LOGICAL_PROCESSOR_RELATIONSHIP = extern enum(i32) {
    ProcessorCore = 0,
    NumaNode = 1,
    Cache = 2,
    ProcessorPackage = 3,
    Group = 4,
    All = 65535,
};
pub const RelationProcessorCore = LOGICAL_PROCESSOR_RELATIONSHIP.ProcessorCore;
pub const RelationNumaNode = LOGICAL_PROCESSOR_RELATIONSHIP.NumaNode;
pub const RelationCache = LOGICAL_PROCESSOR_RELATIONSHIP.Cache;
pub const RelationProcessorPackage = LOGICAL_PROCESSOR_RELATIONSHIP.ProcessorPackage;
pub const RelationGroup = LOGICAL_PROCESSOR_RELATIONSHIP.Group;
pub const RelationAll = LOGICAL_PROCESSOR_RELATIONSHIP.All;

pub const PROCESSOR_CACHE_TYPE = extern enum(i32) {
    Unified = 0,
    Instruction = 1,
    Data = 2,
    Trace = 3,
};
pub const CacheUnified = PROCESSOR_CACHE_TYPE.Unified;
pub const CacheInstruction = PROCESSOR_CACHE_TYPE.Instruction;
pub const CacheData = PROCESSOR_CACHE_TYPE.Data;
pub const CacheTrace = PROCESSOR_CACHE_TYPE.Trace;

pub const CACHE_DESCRIPTOR = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    Size: u32,
    Type: PROCESSOR_CACHE_TYPE,
};

pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION = extern struct {
    ProcessorMask: usize,
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESSOR_RELATIONSHIP = extern struct {
    Flags: u8,
    EfficiencyClass: u8,
    Reserved: [20]u8,
    GroupCount: u16,
    GroupMask: [1]GROUP_AFFINITY,
};

pub const NUMA_NODE_RELATIONSHIP = extern struct {
    NodeNumber: u32,
    Reserved: [20]u8,
    GroupMask: GROUP_AFFINITY,
};

pub const CACHE_RELATIONSHIP = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    CacheSize: u32,
    Type: PROCESSOR_CACHE_TYPE,
    Reserved: [20]u8,
    GroupMask: GROUP_AFFINITY,
};

pub const PROCESSOR_GROUP_INFO = extern struct {
    MaximumProcessorCount: u8,
    ActiveProcessorCount: u8,
    Reserved: [38]u8,
    ActiveProcessorMask: usize,
};

pub const GROUP_RELATIONSHIP = extern struct {
    MaximumGroupCount: u16,
    ActiveGroupCount: u16,
    Reserved: [20]u8,
    GroupInfo: [1]PROCESSOR_GROUP_INFO,
};

pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = extern struct {
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CPU_SET_INFORMATION_TYPE = extern enum(i32) {
    n = 0,
};
pub const CpuSetInformation = CPU_SET_INFORMATION_TYPE.n;

pub const SYSTEM_CPU_SET_INFORMATION = extern struct {
    Size: u32,
    Type: CPU_SET_INFORMATION_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = extern struct {
    CycleTime: u64,
};

pub const XSTATE_FEATURE = extern struct {
    Offset: u32,
    Size: u32,
};

pub const XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: u64,
    EnabledVolatileFeatures: u64,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    Features: [64]XSTATE_FEATURE,
    EnabledSupervisorFeatures: u64,
    AlignedFeatures: u64,
    AllFeatureSize: u32,
    AllFeatures: [64]u32,
    EnabledUserVisibleSupervisorFeatures: u64,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MEMORY_BASIC_INFORMATION32 = extern struct {
    BaseAddress: u32,
    AllocationBase: u32,
    AllocationProtect: u32,
    RegionSize: u32,
    State: u32,
    Protect: u32,
    Type: u32,
};

pub const MEMORY_BASIC_INFORMATION64 = extern struct {
    BaseAddress: u64,
    AllocationBase: u64,
    AllocationProtect: u32,
    __alignment1: u32,
    RegionSize: u64,
    State: u32,
    Protect: u32,
    Type: u32,
    __alignment2: u32,
};

pub const CFG_CALL_TARGET_INFO = extern struct {
    Offset: usize,
    Flags: usize,
};

pub const MEM_ADDRESS_REQUIREMENTS = extern struct {
    LowestStartingAddress: *c_void,
    HighestEndingAddress: *c_void,
    Alignment: usize,
};

pub const MEM_EXTENDED_PARAMETER_TYPE = extern enum(i32) {
    InvalidType = 0,
    AddressRequirements = 1,
    NumaNode = 2,
    PartitionHandle = 3,
    UserPhysicalHandle = 4,
    AttributeFlags = 5,
    Max = 6,
};
pub const MemExtendedParameterInvalidType = MEM_EXTENDED_PARAMETER_TYPE.InvalidType;
pub const MemExtendedParameterAddressRequirements = MEM_EXTENDED_PARAMETER_TYPE.AddressRequirements;
pub const MemExtendedParameterNumaNode = MEM_EXTENDED_PARAMETER_TYPE.NumaNode;
pub const MemExtendedParameterPartitionHandle = MEM_EXTENDED_PARAMETER_TYPE.PartitionHandle;
pub const MemExtendedParameterUserPhysicalHandle = MEM_EXTENDED_PARAMETER_TYPE.UserPhysicalHandle;
pub const MemExtendedParameterAttributeFlags = MEM_EXTENDED_PARAMETER_TYPE.AttributeFlags;
pub const MemExtendedParameterMax = MEM_EXTENDED_PARAMETER_TYPE.Max;

pub const MEM_EXTENDED_PARAMETER = extern struct {
    Anonymous1: _Anonymous1_e__Struct,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Struct = u32; // TODO: generate this nested type!
};

pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE = extern enum(i32) {
    InvalidType = 0,
    UserPhysicalFlags = 1,
    NumaNode = 2,
    Max = 3,
};
pub const MemSectionExtendedParameterInvalidType = MEM_SECTION_EXTENDED_PARAMETER_TYPE.InvalidType;
pub const MemSectionExtendedParameterUserPhysicalFlags = MEM_SECTION_EXTENDED_PARAMETER_TYPE.UserPhysicalFlags;
pub const MemSectionExtendedParameterNumaNode = MEM_SECTION_EXTENDED_PARAMETER_TYPE.NumaNode;
pub const MemSectionExtendedParameterMax = MEM_SECTION_EXTENDED_PARAMETER_TYPE.Max;

pub const ENCLAVE_CREATE_INFO_SGX = extern struct {
    Secs: [4096]u8,
};

pub const ENCLAVE_INIT_INFO_SGX = extern struct {
    SigStruct: [1808]u8,
    Reserved1: [240]u8,
    EInitToken: [304]u8,
    Reserved2: [1744]u8,
};

pub const ENCLAVE_CREATE_INFO_VBS = extern struct {
    Flags: u32,
    OwnerID: [32]u8,
};

pub const ENCLAVE_CREATE_INFO_VBS_BASIC = extern struct {
    Flags: u32,
    OwnerID: [32]u8,
};

pub const ENCLAVE_LOAD_DATA_VBS_BASIC = extern struct {
    PageType: u32,
};

pub const ENCLAVE_INIT_INFO_VBS_BASIC = extern struct {
    FamilyId: [16]u8,
    ImageId: [16]u8,
    EnclaveSize: u64,
    EnclaveSvn: u32,
    Reserved: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ENCLAVE_INIT_INFO_VBS = extern struct {
    Length: u32,
    ThreadCount: u32,
};

pub const LPENCLAVE_TARGET_FUNCTION = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const FILE_SEGMENT_ELEMENT = extern union {
    Buffer: *c_void,
    Alignment: u64,
};

pub const SCRUB_DATA_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    MaximumIos: u32,
    ObjectId: [4]u32,
    Reserved: [25]u32,
    ResumeContext: [816]u8,
};

pub const SCRUB_PARITY_EXTENT = extern struct {
    Offset: i64,
    Length: u64,
};

pub const SCRUB_PARITY_EXTENT_DATA = extern struct {
    Size: u16,
    Flags: u16,
    NumberOfParityExtents: u16,
    MaximumNumberOfParityExtents: u16,
    ParityExtents: [1]SCRUB_PARITY_EXTENT,
};

pub const SCRUB_DATA_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    Status: u32,
    ErrorFileOffset: u64,
    ErrorLength: u64,
    NumberOfBytesRepaired: u64,
    NumberOfBytesFailed: u64,
    InternalFileReference: u64,
    ResumeContextLength: u16,
    ParityExtentDataOffset: u16,
    Reserved: [9]u32,
    NumberOfMetadataBytesProcessed: u64,
    NumberOfDataBytesProcessed: u64,
    TotalNumberOfMetadataBytesInUse: u64,
    TotalNumberOfDataBytesInUse: u64,
    ResumeContext: [816]u8,
};

pub const SharedVirtualDiskSupportType = extern enum(i32) {
    sUnsupported = 0,
    sSupported = 1,
    SnapshotsSupported = 3,
    CDPSnapshotsSupported = 7,
};
pub const SharedVirtualDisksUnsupported = SharedVirtualDiskSupportType.sUnsupported;
pub const SharedVirtualDisksSupported = SharedVirtualDiskSupportType.sSupported;
pub const SharedVirtualDiskSnapshotsSupported = SharedVirtualDiskSupportType.SnapshotsSupported;
pub const SharedVirtualDiskCDPSnapshotsSupported = SharedVirtualDiskSupportType.CDPSnapshotsSupported;

pub const SharedVirtualDiskHandleState = extern enum(i32) {
    None = 0,
    FileShared = 1,
    HandleShared = 3,
};
pub const SharedVirtualDiskHandleStateNone = SharedVirtualDiskHandleState.None;
pub const SharedVirtualDiskHandleStateFileShared = SharedVirtualDiskHandleState.FileShared;
pub const SharedVirtualDiskHandleStateHandleShared = SharedVirtualDiskHandleState.HandleShared;

pub const SHARED_VIRTUAL_DISK_SUPPORT = extern struct {
    SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    HandleState: SharedVirtualDiskHandleState,
};

pub const REARRANGE_FILE_DATA = extern struct {
    SourceStartingOffset: u64,
    TargetOffset: u64,
    SourceFileHandle: HANDLE,
    Length: u32,
    Flags: u32,
};

pub const SHUFFLE_FILE_DATA = extern struct {
    StartingOffset: i64,
    Length: i64,
    Flags: u32,
};

pub const NETWORK_APP_INSTANCE_EA = extern struct {
    AppInstanceID: Guid,
    CsvFlags: u32,
};

pub const SYSTEM_POWER_STATE = extern enum(i32) {
    Unspecified = 0,
    Working = 1,
    Sleeping1 = 2,
    Sleeping2 = 3,
    Sleeping3 = 4,
    Hibernate = 5,
    Shutdown = 6,
    Maximum = 7,
};
pub const PowerSystemUnspecified = SYSTEM_POWER_STATE.Unspecified;
pub const PowerSystemWorking = SYSTEM_POWER_STATE.Working;
pub const PowerSystemSleeping1 = SYSTEM_POWER_STATE.Sleeping1;
pub const PowerSystemSleeping2 = SYSTEM_POWER_STATE.Sleeping2;
pub const PowerSystemSleeping3 = SYSTEM_POWER_STATE.Sleeping3;
pub const PowerSystemHibernate = SYSTEM_POWER_STATE.Hibernate;
pub const PowerSystemShutdown = SYSTEM_POWER_STATE.Shutdown;
pub const PowerSystemMaximum = SYSTEM_POWER_STATE.Maximum;

pub const POWER_ACTION = extern enum(i32) {
    None = 0,
    Reserved = 1,
    Sleep = 2,
    Hibernate = 3,
    Shutdown = 4,
    ShutdownReset = 5,
    ShutdownOff = 6,
    WarmEject = 7,
    DisplayOff = 8,
};
pub const PowerActionNone = POWER_ACTION.None;
pub const PowerActionReserved = POWER_ACTION.Reserved;
pub const PowerActionSleep = POWER_ACTION.Sleep;
pub const PowerActionHibernate = POWER_ACTION.Hibernate;
pub const PowerActionShutdown = POWER_ACTION.Shutdown;
pub const PowerActionShutdownReset = POWER_ACTION.ShutdownReset;
pub const PowerActionShutdownOff = POWER_ACTION.ShutdownOff;
pub const PowerActionWarmEject = POWER_ACTION.WarmEject;
pub const PowerActionDisplayOff = POWER_ACTION.DisplayOff;

pub const DEVICE_POWER_STATE = extern enum(i32) {
    Unspecified = 0,
    D0 = 1,
    D1 = 2,
    D2 = 3,
    D3 = 4,
    Maximum = 5,
};
pub const PowerDeviceUnspecified = DEVICE_POWER_STATE.Unspecified;
pub const PowerDeviceD0 = DEVICE_POWER_STATE.D0;
pub const PowerDeviceD1 = DEVICE_POWER_STATE.D1;
pub const PowerDeviceD2 = DEVICE_POWER_STATE.D2;
pub const PowerDeviceD3 = DEVICE_POWER_STATE.D3;
pub const PowerDeviceMaximum = DEVICE_POWER_STATE.Maximum;

pub const MONITOR_DISPLAY_STATE = extern enum(i32) {
    Off = 0,
    On = 1,
    Dim = 2,
};
pub const PowerMonitorOff = MONITOR_DISPLAY_STATE.Off;
pub const PowerMonitorOn = MONITOR_DISPLAY_STATE.On;
pub const PowerMonitorDim = MONITOR_DISPLAY_STATE.Dim;

pub const USER_ACTIVITY_PRESENCE = extern enum(i32) {
    Present = 0,
    NotPresent = 1,
    Inactive = 2,
    Maximum = 3,
    Invalid = 3,
};
pub const PowerUserPresent = USER_ACTIVITY_PRESENCE.Present;
pub const PowerUserNotPresent = USER_ACTIVITY_PRESENCE.NotPresent;
pub const PowerUserInactive = USER_ACTIVITY_PRESENCE.Inactive;
pub const PowerUserMaximum = USER_ACTIVITY_PRESENCE.Maximum;
pub const PowerUserInvalid = USER_ACTIVITY_PRESENCE.Invalid;

pub const LATENCY_TIME = extern enum(i32) {
    DONT_CARE = 0,
    LOWEST_LATENCY = 1,
};
pub const LT_DONT_CARE = LATENCY_TIME.DONT_CARE;
pub const LT_LOWEST_LATENCY = LATENCY_TIME.LOWEST_LATENCY;

pub const POWER_REQUEST_TYPE = extern enum(i32) {
    DisplayRequired = 0,
    SystemRequired = 1,
    AwayModeRequired = 2,
    ExecutionRequired = 3,
};
pub const PowerRequestDisplayRequired = POWER_REQUEST_TYPE.DisplayRequired;
pub const PowerRequestSystemRequired = POWER_REQUEST_TYPE.SystemRequired;
pub const PowerRequestAwayModeRequired = POWER_REQUEST_TYPE.AwayModeRequired;
pub const PowerRequestExecutionRequired = POWER_REQUEST_TYPE.ExecutionRequired;

pub const CM_Power_Data_s = extern struct {
    PD_Size: u32,
    PD_MostRecentPowerState: DEVICE_POWER_STATE,
    PD_Capabilities: u32,
    PD_D1Latency: u32,
    PD_D2Latency: u32,
    PD_D3Latency: u32,
    PD_PowerStateMapping: [7]DEVICE_POWER_STATE,
    PD_DeepestSystemWake: SYSTEM_POWER_STATE,
};

pub const POWER_INFORMATION_LEVEL = extern enum(i32) {
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,
    LastSleepTime = 15,
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerRequestActionInternal = 85,
    BatteryDeviceState = 86,
    PowerInformationInternal = 87,
    ThermalStandby = 88,
    SystemHiberFileType = 89,
    PhysicalPowerButtonPress = 90,
    QueryPotentialDripsConstraint = 91,
    EnergyTrackerCreate = 92,
    EnergyTrackerQuery = 93,
    UpdateBlackBoxRecorder = 94,
    SessionAllowExternalDmaDevices = 95,
    PowerInformationLevelMaximum = 96,
};
pub const SystemPowerPolicyAc = POWER_INFORMATION_LEVEL.SystemPowerPolicyAc;
pub const SystemPowerPolicyDc = POWER_INFORMATION_LEVEL.SystemPowerPolicyDc;
pub const VerifySystemPolicyAc = POWER_INFORMATION_LEVEL.VerifySystemPolicyAc;
pub const VerifySystemPolicyDc = POWER_INFORMATION_LEVEL.VerifySystemPolicyDc;
pub const SystemPowerCapabilities = POWER_INFORMATION_LEVEL.SystemPowerCapabilities;
pub const SystemBatteryState = POWER_INFORMATION_LEVEL.SystemBatteryState;
pub const SystemPowerStateHandler = POWER_INFORMATION_LEVEL.SystemPowerStateHandler;
pub const ProcessorStateHandler = POWER_INFORMATION_LEVEL.ProcessorStateHandler;
pub const SystemPowerPolicyCurrent = POWER_INFORMATION_LEVEL.SystemPowerPolicyCurrent;
pub const AdministratorPowerPolicy = POWER_INFORMATION_LEVEL.AdministratorPowerPolicy;
pub const SystemReserveHiberFile = POWER_INFORMATION_LEVEL.SystemReserveHiberFile;
pub const ProcessorInformation = POWER_INFORMATION_LEVEL.ProcessorInformation;
pub const SystemPowerInformation = POWER_INFORMATION_LEVEL.SystemPowerInformation;
pub const ProcessorStateHandler2 = POWER_INFORMATION_LEVEL.ProcessorStateHandler2;
pub const LastWakeTime = POWER_INFORMATION_LEVEL.LastWakeTime;
pub const LastSleepTime = POWER_INFORMATION_LEVEL.LastSleepTime;
pub const SystemExecutionState = POWER_INFORMATION_LEVEL.SystemExecutionState;
pub const SystemPowerStateNotifyHandler = POWER_INFORMATION_LEVEL.SystemPowerStateNotifyHandler;
pub const ProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyAc;
pub const ProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyDc;
pub const VerifyProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyAc;
pub const VerifyProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyDc;
pub const ProcessorPowerPolicyCurrent = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyCurrent;
pub const SystemPowerStateLogging = POWER_INFORMATION_LEVEL.SystemPowerStateLogging;
pub const SystemPowerLoggingEntry = POWER_INFORMATION_LEVEL.SystemPowerLoggingEntry;
pub const SetPowerSettingValue = POWER_INFORMATION_LEVEL.SetPowerSettingValue;
pub const NotifyUserPowerSetting = POWER_INFORMATION_LEVEL.NotifyUserPowerSetting;
pub const PowerInformationLevelUnused0 = POWER_INFORMATION_LEVEL.PowerInformationLevelUnused0;
pub const SystemMonitorHiberBootPowerOff = POWER_INFORMATION_LEVEL.SystemMonitorHiberBootPowerOff;
pub const SystemVideoState = POWER_INFORMATION_LEVEL.SystemVideoState;
pub const TraceApplicationPowerMessage = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessage;
pub const TraceApplicationPowerMessageEnd = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessageEnd;
pub const ProcessorPerfStates = POWER_INFORMATION_LEVEL.ProcessorPerfStates;
pub const ProcessorIdleStates = POWER_INFORMATION_LEVEL.ProcessorIdleStates;
pub const ProcessorCap = POWER_INFORMATION_LEVEL.ProcessorCap;
pub const SystemWakeSource = POWER_INFORMATION_LEVEL.SystemWakeSource;
pub const SystemHiberFileInformation = POWER_INFORMATION_LEVEL.SystemHiberFileInformation;
pub const TraceServicePowerMessage = POWER_INFORMATION_LEVEL.TraceServicePowerMessage;
pub const ProcessorLoad = POWER_INFORMATION_LEVEL.ProcessorLoad;
pub const PowerShutdownNotification = POWER_INFORMATION_LEVEL.PowerShutdownNotification;
pub const MonitorCapabilities = POWER_INFORMATION_LEVEL.MonitorCapabilities;
pub const SessionPowerInit = POWER_INFORMATION_LEVEL.SessionPowerInit;
pub const SessionDisplayState = POWER_INFORMATION_LEVEL.SessionDisplayState;
pub const PowerRequestCreate = POWER_INFORMATION_LEVEL.PowerRequestCreate;
pub const PowerRequestAction = POWER_INFORMATION_LEVEL.PowerRequestAction;
pub const GetPowerRequestList = POWER_INFORMATION_LEVEL.GetPowerRequestList;
pub const ProcessorInformationEx = POWER_INFORMATION_LEVEL.ProcessorInformationEx;
pub const NotifyUserModeLegacyPowerEvent = POWER_INFORMATION_LEVEL.NotifyUserModeLegacyPowerEvent;
pub const GroupPark = POWER_INFORMATION_LEVEL.GroupPark;
pub const ProcessorIdleDomains = POWER_INFORMATION_LEVEL.ProcessorIdleDomains;
pub const WakeTimerList = POWER_INFORMATION_LEVEL.WakeTimerList;
pub const SystemHiberFileSize = POWER_INFORMATION_LEVEL.SystemHiberFileSize;
pub const ProcessorIdleStatesHv = POWER_INFORMATION_LEVEL.ProcessorIdleStatesHv;
pub const ProcessorPerfStatesHv = POWER_INFORMATION_LEVEL.ProcessorPerfStatesHv;
pub const ProcessorPerfCapHv = POWER_INFORMATION_LEVEL.ProcessorPerfCapHv;
pub const ProcessorSetIdle = POWER_INFORMATION_LEVEL.ProcessorSetIdle;
pub const LogicalProcessorIdling = POWER_INFORMATION_LEVEL.LogicalProcessorIdling;
pub const UserPresence = POWER_INFORMATION_LEVEL.UserPresence;
pub const PowerSettingNotificationName = POWER_INFORMATION_LEVEL.PowerSettingNotificationName;
pub const GetPowerSettingValue = POWER_INFORMATION_LEVEL.GetPowerSettingValue;
pub const IdleResiliency = POWER_INFORMATION_LEVEL.IdleResiliency;
pub const SessionRITState = POWER_INFORMATION_LEVEL.SessionRITState;
pub const SessionConnectNotification = POWER_INFORMATION_LEVEL.SessionConnectNotification;
pub const SessionPowerCleanup = POWER_INFORMATION_LEVEL.SessionPowerCleanup;
pub const SessionLockState = POWER_INFORMATION_LEVEL.SessionLockState;
pub const SystemHiberbootState = POWER_INFORMATION_LEVEL.SystemHiberbootState;
pub const PlatformInformation = POWER_INFORMATION_LEVEL.PlatformInformation;
pub const PdcInvocation = POWER_INFORMATION_LEVEL.PdcInvocation;
pub const MonitorInvocation = POWER_INFORMATION_LEVEL.MonitorInvocation;
pub const FirmwareTableInformationRegistered = POWER_INFORMATION_LEVEL.FirmwareTableInformationRegistered;
pub const SetShutdownSelectedTime = POWER_INFORMATION_LEVEL.SetShutdownSelectedTime;
pub const SuspendResumeInvocation = POWER_INFORMATION_LEVEL.SuspendResumeInvocation;
pub const PlmPowerRequestCreate = POWER_INFORMATION_LEVEL.PlmPowerRequestCreate;
pub const ScreenOff = POWER_INFORMATION_LEVEL.ScreenOff;
pub const CsDeviceNotification = POWER_INFORMATION_LEVEL.CsDeviceNotification;
pub const PlatformRole = POWER_INFORMATION_LEVEL.PlatformRole;
pub const LastResumePerformance = POWER_INFORMATION_LEVEL.LastResumePerformance;
pub const DisplayBurst = POWER_INFORMATION_LEVEL.DisplayBurst;
pub const ExitLatencySamplingPercentage = POWER_INFORMATION_LEVEL.ExitLatencySamplingPercentage;
pub const RegisterSpmPowerSettings = POWER_INFORMATION_LEVEL.RegisterSpmPowerSettings;
pub const PlatformIdleStates = POWER_INFORMATION_LEVEL.PlatformIdleStates;
pub const ProcessorIdleVeto = POWER_INFORMATION_LEVEL.ProcessorIdleVeto;
pub const PlatformIdleVeto = POWER_INFORMATION_LEVEL.PlatformIdleVeto;
pub const SystemBatteryStatePrecise = POWER_INFORMATION_LEVEL.SystemBatteryStatePrecise;
pub const ThermalEvent = POWER_INFORMATION_LEVEL.ThermalEvent;
pub const PowerRequestActionInternal = POWER_INFORMATION_LEVEL.PowerRequestActionInternal;
pub const BatteryDeviceState = POWER_INFORMATION_LEVEL.BatteryDeviceState;
pub const PowerInformationInternal = POWER_INFORMATION_LEVEL.PowerInformationInternal;
pub const ThermalStandby = POWER_INFORMATION_LEVEL.ThermalStandby;
pub const SystemHiberFileType = POWER_INFORMATION_LEVEL.SystemHiberFileType;
pub const PhysicalPowerButtonPress = POWER_INFORMATION_LEVEL.PhysicalPowerButtonPress;
pub const QueryPotentialDripsConstraint = POWER_INFORMATION_LEVEL.QueryPotentialDripsConstraint;
pub const EnergyTrackerCreate = POWER_INFORMATION_LEVEL.EnergyTrackerCreate;
pub const EnergyTrackerQuery = POWER_INFORMATION_LEVEL.EnergyTrackerQuery;
pub const UpdateBlackBoxRecorder = POWER_INFORMATION_LEVEL.UpdateBlackBoxRecorder;
pub const SessionAllowExternalDmaDevices = POWER_INFORMATION_LEVEL.SessionAllowExternalDmaDevices;
pub const PowerInformationLevelMaximum = POWER_INFORMATION_LEVEL.PowerInformationLevelMaximum;

pub const POWER_USER_PRESENCE_TYPE = extern enum(i32) {
    NotPresent = 0,
    Present = 1,
    Unknown = 255,
};
pub const UserNotPresent = POWER_USER_PRESENCE_TYPE.NotPresent;
pub const UserPresent = POWER_USER_PRESENCE_TYPE.Present;
pub const UserUnknown = POWER_USER_PRESENCE_TYPE.Unknown;

pub const POWER_USER_PRESENCE = extern struct {
    UserPresence: POWER_USER_PRESENCE_TYPE,
};

pub const POWER_SESSION_CONNECT = extern struct {
    Connected: u8,
    Console: u8,
};

pub const POWER_SESSION_TIMEOUTS = extern struct {
    InputTimeout: u32,
    DisplayTimeout: u32,
};

pub const POWER_SESSION_RIT_STATE = extern struct {
    Active: u8,
    LastInputTime: u32,
};

pub const POWER_SESSION_WINLOGON = extern struct {
    SessionId: u32,
    Console: u8,
    Locked: u8,
};

pub const POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = extern struct {
    IsAllowed: u8,
};

pub const POWER_IDLE_RESILIENCY = extern struct {
    CoalescingTimeout: u32,
    IdleResiliencyPeriod: u32,
};

pub const POWER_MONITOR_REQUEST_REASON = extern enum(i32) {
    Unknown = 0,
    PowerButton = 1,
    RemoteConnection = 2,
    ScMonitorpower = 3,
    UserInput = 4,
    AcDcDisplayBurst = 5,
    UserDisplayBurst = 6,
    PoSetSystemState = 7,
    SetThreadExecutionState = 8,
    FullWake = 9,
    SessionUnlock = 10,
    ScreenOffRequest = 11,
    IdleTimeout = 12,
    PolicyChange = 13,
    SleepButton = 14,
    Lid = 15,
    BatteryCountChange = 16,
    GracePeriod = 17,
    PnP = 18,
    DP = 19,
    SxTransition = 20,
    SystemIdle = 21,
    NearProximity = 22,
    ThermalStandby = 23,
    ResumePdc = 24,
    ResumeS4 = 25,
    Terminal = 26,
    PdcSignal = 27,
    AcDcDisplayBurstSuppressed = 28,
    SystemStateEntered = 29,
    Winrt = 30,
    UserInputKeyboard = 31,
    UserInputMouse = 32,
    UserInputTouch = 33,
    UserInputPen = 34,
    UserInputAccelerometer = 35,
    UserInputHid = 36,
    UserInputPoUserPresent = 37,
    UserInputSessionSwitch = 38,
    UserInputInitialization = 39,
    PdcSignalWindowsMobilePwrNotif = 40,
    PdcSignalWindowsMobileShell = 41,
    PdcSignalHeyCortana = 42,
    PdcSignalHolographicShell = 43,
    PdcSignalFingerprint = 44,
    DirectedDrips = 45,
    Dim = 46,
    BuiltinPanel = 47,
    DisplayRequiredUnDim = 48,
    BatteryCountChangeSuppressed = 49,
    ResumeModernStandby = 50,
    Max = 51,
};
pub const MonitorRequestReasonUnknown = POWER_MONITOR_REQUEST_REASON.Unknown;
pub const MonitorRequestReasonPowerButton = POWER_MONITOR_REQUEST_REASON.PowerButton;
pub const MonitorRequestReasonRemoteConnection = POWER_MONITOR_REQUEST_REASON.RemoteConnection;
pub const MonitorRequestReasonScMonitorpower = POWER_MONITOR_REQUEST_REASON.ScMonitorpower;
pub const MonitorRequestReasonUserInput = POWER_MONITOR_REQUEST_REASON.UserInput;
pub const MonitorRequestReasonAcDcDisplayBurst = POWER_MONITOR_REQUEST_REASON.AcDcDisplayBurst;
pub const MonitorRequestReasonUserDisplayBurst = POWER_MONITOR_REQUEST_REASON.UserDisplayBurst;
pub const MonitorRequestReasonPoSetSystemState = POWER_MONITOR_REQUEST_REASON.PoSetSystemState;
pub const MonitorRequestReasonSetThreadExecutionState = POWER_MONITOR_REQUEST_REASON.SetThreadExecutionState;
pub const MonitorRequestReasonFullWake = POWER_MONITOR_REQUEST_REASON.FullWake;
pub const MonitorRequestReasonSessionUnlock = POWER_MONITOR_REQUEST_REASON.SessionUnlock;
pub const MonitorRequestReasonScreenOffRequest = POWER_MONITOR_REQUEST_REASON.ScreenOffRequest;
pub const MonitorRequestReasonIdleTimeout = POWER_MONITOR_REQUEST_REASON.IdleTimeout;
pub const MonitorRequestReasonPolicyChange = POWER_MONITOR_REQUEST_REASON.PolicyChange;
pub const MonitorRequestReasonSleepButton = POWER_MONITOR_REQUEST_REASON.SleepButton;
pub const MonitorRequestReasonLid = POWER_MONITOR_REQUEST_REASON.Lid;
pub const MonitorRequestReasonBatteryCountChange = POWER_MONITOR_REQUEST_REASON.BatteryCountChange;
pub const MonitorRequestReasonGracePeriod = POWER_MONITOR_REQUEST_REASON.GracePeriod;
pub const MonitorRequestReasonPnP = POWER_MONITOR_REQUEST_REASON.PnP;
pub const MonitorRequestReasonDP = POWER_MONITOR_REQUEST_REASON.DP;
pub const MonitorRequestReasonSxTransition = POWER_MONITOR_REQUEST_REASON.SxTransition;
pub const MonitorRequestReasonSystemIdle = POWER_MONITOR_REQUEST_REASON.SystemIdle;
pub const MonitorRequestReasonNearProximity = POWER_MONITOR_REQUEST_REASON.NearProximity;
pub const MonitorRequestReasonThermalStandby = POWER_MONITOR_REQUEST_REASON.ThermalStandby;
pub const MonitorRequestReasonResumePdc = POWER_MONITOR_REQUEST_REASON.ResumePdc;
pub const MonitorRequestReasonResumeS4 = POWER_MONITOR_REQUEST_REASON.ResumeS4;
pub const MonitorRequestReasonTerminal = POWER_MONITOR_REQUEST_REASON.Terminal;
pub const MonitorRequestReasonPdcSignal = POWER_MONITOR_REQUEST_REASON.PdcSignal;
pub const MonitorRequestReasonAcDcDisplayBurstSuppressed = POWER_MONITOR_REQUEST_REASON.AcDcDisplayBurstSuppressed;
pub const MonitorRequestReasonSystemStateEntered = POWER_MONITOR_REQUEST_REASON.SystemStateEntered;
pub const MonitorRequestReasonWinrt = POWER_MONITOR_REQUEST_REASON.Winrt;
pub const MonitorRequestReasonUserInputKeyboard = POWER_MONITOR_REQUEST_REASON.UserInputKeyboard;
pub const MonitorRequestReasonUserInputMouse = POWER_MONITOR_REQUEST_REASON.UserInputMouse;
pub const MonitorRequestReasonUserInputTouch = POWER_MONITOR_REQUEST_REASON.UserInputTouch;
pub const MonitorRequestReasonUserInputPen = POWER_MONITOR_REQUEST_REASON.UserInputPen;
pub const MonitorRequestReasonUserInputAccelerometer = POWER_MONITOR_REQUEST_REASON.UserInputAccelerometer;
pub const MonitorRequestReasonUserInputHid = POWER_MONITOR_REQUEST_REASON.UserInputHid;
pub const MonitorRequestReasonUserInputPoUserPresent = POWER_MONITOR_REQUEST_REASON.UserInputPoUserPresent;
pub const MonitorRequestReasonUserInputSessionSwitch = POWER_MONITOR_REQUEST_REASON.UserInputSessionSwitch;
pub const MonitorRequestReasonUserInputInitialization = POWER_MONITOR_REQUEST_REASON.UserInputInitialization;
pub const MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = POWER_MONITOR_REQUEST_REASON.PdcSignalWindowsMobilePwrNotif;
pub const MonitorRequestReasonPdcSignalWindowsMobileShell = POWER_MONITOR_REQUEST_REASON.PdcSignalWindowsMobileShell;
pub const MonitorRequestReasonPdcSignalHeyCortana = POWER_MONITOR_REQUEST_REASON.PdcSignalHeyCortana;
pub const MonitorRequestReasonPdcSignalHolographicShell = POWER_MONITOR_REQUEST_REASON.PdcSignalHolographicShell;
pub const MonitorRequestReasonPdcSignalFingerprint = POWER_MONITOR_REQUEST_REASON.PdcSignalFingerprint;
pub const MonitorRequestReasonDirectedDrips = POWER_MONITOR_REQUEST_REASON.DirectedDrips;
pub const MonitorRequestReasonDim = POWER_MONITOR_REQUEST_REASON.Dim;
pub const MonitorRequestReasonBuiltinPanel = POWER_MONITOR_REQUEST_REASON.BuiltinPanel;
pub const MonitorRequestReasonDisplayRequiredUnDim = POWER_MONITOR_REQUEST_REASON.DisplayRequiredUnDim;
pub const MonitorRequestReasonBatteryCountChangeSuppressed = POWER_MONITOR_REQUEST_REASON.BatteryCountChangeSuppressed;
pub const MonitorRequestReasonResumeModernStandby = POWER_MONITOR_REQUEST_REASON.ResumeModernStandby;
pub const MonitorRequestReasonMax = POWER_MONITOR_REQUEST_REASON.Max;

pub const POWER_MONITOR_REQUEST_TYPE = extern enum(i32) {
    Off = 0,
    OnAndPresent = 1,
    ToggleOn = 2,
};
pub const MonitorRequestTypeOff = POWER_MONITOR_REQUEST_TYPE.Off;
pub const MonitorRequestTypeOnAndPresent = POWER_MONITOR_REQUEST_TYPE.OnAndPresent;
pub const MonitorRequestTypeToggleOn = POWER_MONITOR_REQUEST_TYPE.ToggleOn;

pub const POWER_MONITOR_INVOCATION = extern struct {
    Console: u8,
    RequestReason: POWER_MONITOR_REQUEST_REASON,
};

pub const RESUME_PERFORMANCE = extern struct {
    PostTimeMs: u32,
    TotalResumeTimeMs: u64,
    ResumeCompleteTimestamp: u64,
};

pub const SYSTEM_POWER_CONDITION = extern enum(i32) {
    Ac = 0,
    Dc = 1,
    Hot = 2,
    ConditionMaximum = 3,
};
pub const PoAc = SYSTEM_POWER_CONDITION.Ac;
pub const PoDc = SYSTEM_POWER_CONDITION.Dc;
pub const PoHot = SYSTEM_POWER_CONDITION.Hot;
pub const PoConditionMaximum = SYSTEM_POWER_CONDITION.ConditionMaximum;

pub const SET_POWER_SETTING_VALUE = extern struct {
    Version: u32,
    Guid: Guid,
    PowerCondition: SYSTEM_POWER_CONDITION,
    DataLength: u32,
    Data: [1]u8,
};

pub const NOTIFY_USER_POWER_SETTING = extern struct {
    Guid: Guid,
};

pub const APPLICATIONLAUNCH_SETTING_VALUE = extern struct {
    ActivationTime: LARGE_INTEGER,
    Flags: u32,
    ButtonInstanceID: u32,
};

pub const POWER_PLATFORM_ROLE = extern enum(i32) {
    Unspecified = 0,
    Desktop = 1,
    Mobile = 2,
    Workstation = 3,
    EnterpriseServer = 4,
    SOHOServer = 5,
    AppliancePC = 6,
    PerformanceServer = 7,
    Slate = 8,
    Maximum = 9,
};
pub const PlatformRoleUnspecified = POWER_PLATFORM_ROLE.Unspecified;
pub const PlatformRoleDesktop = POWER_PLATFORM_ROLE.Desktop;
pub const PlatformRoleMobile = POWER_PLATFORM_ROLE.Mobile;
pub const PlatformRoleWorkstation = POWER_PLATFORM_ROLE.Workstation;
pub const PlatformRoleEnterpriseServer = POWER_PLATFORM_ROLE.EnterpriseServer;
pub const PlatformRoleSOHOServer = POWER_PLATFORM_ROLE.SOHOServer;
pub const PlatformRoleAppliancePC = POWER_PLATFORM_ROLE.AppliancePC;
pub const PlatformRolePerformanceServer = POWER_PLATFORM_ROLE.PerformanceServer;
pub const PlatformRoleSlate = POWER_PLATFORM_ROLE.Slate;
pub const PlatformRoleMaximum = POWER_PLATFORM_ROLE.Maximum;

pub const POWER_PLATFORM_INFORMATION = extern struct {
    AoAc: u8,
};

pub const BATTERY_REPORTING_SCALE = extern struct {
    Granularity: u32,
    Capacity: u32,
};

pub const PPM_WMI_LEGACY_PERFSTATE = extern struct {
    Frequency: u32,
    Flags: u32,
    PercentFrequency: u32,
};

pub const PPM_WMI_IDLE_STATE = extern struct {
    Latency: u32,
    Power: u32,
    TimeCheck: u32,
    PromotePercent: u8,
    DemotePercent: u8,
    StateType: u8,
    Reserved: u8,
    StateFlags: u32,
    Context: u32,
    IdleHandler: u32,
    Reserved1: u32,
};

pub const PPM_WMI_IDLE_STATES = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: u64,
    State: [1]PPM_WMI_IDLE_STATE,
};

pub const PPM_WMI_IDLE_STATES_EX = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: *c_void,
    State: [1]PPM_WMI_IDLE_STATE,
};

pub const PPM_WMI_PERF_STATE = extern struct {
    Frequency: u32,
    Power: u32,
    PercentFrequency: u8,
    IncreaseLevel: u8,
    DecreaseLevel: u8,
    Type: u8,
    IncreaseTime: u32,
    DecreaseTime: u32,
    Control: u64,
    Status: u64,
    HitCount: u32,
    Reserved1: u32,
    Reserved2: u64,
    Reserved3: u64,
};

pub const PPM_WMI_PERF_STATES = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: u64,
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: [1]PPM_WMI_PERF_STATE,
};

pub const PPM_WMI_PERF_STATES_EX = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: *c_void,
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: [1]PPM_WMI_PERF_STATE,
};

pub const PPM_IDLE_STATE_ACCOUNTING = extern struct {
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    TotalTime: u64,
    IdleTimeBuckets: [6]u32,
};

pub const PPM_IDLE_ACCOUNTING = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    StartTime: u64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING,
};

pub const PPM_IDLE_STATE_BUCKET_EX = extern struct {
    TotalTimeUs: u64,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    Count: u32,
};

pub const PPM_IDLE_STATE_ACCOUNTING_EX = extern struct {
    TotalTime: u64,
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    CancelledTransitions: u32,
    IdleTimeBuckets: [16]PPM_IDLE_STATE_BUCKET_EX,
};

pub const PPM_IDLE_ACCOUNTING_EX = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    AbortCount: u32,
    StartTime: u64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING_EX,
};

pub const PPM_PERFSTATE_EVENT = extern struct {
    State: u32,
    Status: u32,
    Latency: u32,
    Speed: u32,
    Processor: u32,
};

pub const PPM_PERFSTATE_DOMAIN_EVENT = extern struct {
    State: u32,
    Latency: u32,
    Speed: u32,
    Processors: u64,
};

pub const PPM_IDLESTATE_EVENT = extern struct {
    NewState: u32,
    OldState: u32,
    Processors: u64,
};

pub const PPM_THERMALCHANGE_EVENT = extern struct {
    ThermalConstraint: u32,
    Processors: u64,
};

pub const PPM_THERMAL_POLICY_EVENT = extern struct {
    Mode: u8,
    Processors: u64,
};

pub const POWER_ACTION_POLICY = extern struct {
    Action: POWER_ACTION,
    Flags: u32,
    EventCode: POWER_ACTION_POLICY_EVENT_CODE,
};

pub const SYSTEM_POWER_LEVEL = extern struct {
    Enable: u8,
    Spare: [3]u8,
    BatteryLevel: u32,
    PowerPolicy: POWER_ACTION_POLICY,
    MinSystemState: SYSTEM_POWER_STATE,
};

pub const SYSTEM_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButton: POWER_ACTION_POLICY,
    SleepButton: POWER_ACTION_POLICY,
    LidClose: POWER_ACTION_POLICY,
    LidOpenWake: SYSTEM_POWER_STATE,
    Reserved: u32,
    Idle: POWER_ACTION_POLICY,
    IdleTimeout: u32,
    IdleSensitivity: u8,
    DynamicThrottle: u8,
    Spare2: [2]u8,
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    ReducedLatencySleep: SYSTEM_POWER_STATE,
    WinLogonFlags: u32,
    Spare3: u32,
    DozeS4Timeout: u32,
    BroadcastCapacityResolution: u32,
    DischargePolicy: [4]SYSTEM_POWER_LEVEL,
    VideoTimeout: u32,
    VideoDimDisplay: u8,
    VideoReserved: [3]u32,
    SpindownTimeout: u32,
    OptimizeForPower: u8,
    FanThrottleTolerance: u8,
    ForcedThrottle: u8,
    MinThrottle: u8,
    OverThrottled: POWER_ACTION_POLICY,
};

pub const PROCESSOR_IDLESTATE_INFO = extern struct {
    TimeCheck: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: [2]u8,
};

pub const PROCESSOR_IDLESTATE_POLICY = extern struct {
    Revision: u16,
    Flags: _Flags_e__Union,
    PolicyCount: u32,
    Policy: [3]PROCESSOR_IDLESTATE_INFO,
    const _Flags_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESSOR_POWER_POLICY_INFO = extern struct {
    TimeCheck: u32,
    DemoteLimit: u32,
    PromoteLimit: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: [2]u8,
    _bitfield: u32,
};

pub const PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    DynamicThrottle: u8,
    Spare: [3]u8,
    _bitfield: u32,
    PolicyCount: u32,
    Policy: [3]PROCESSOR_POWER_POLICY_INFO,
};

pub const PROCESSOR_PERFSTATE_POLICY = extern struct {
    Revision: u32,
    MaxThrottle: u8,
    MinThrottle: u8,
    BusyAdjThreshold: u8,
    Anonymous: _Anonymous_e__Union,
    TimeCheck: u32,
    IncreaseTime: u32,
    DecreaseTime: u32,
    IncreasePercent: u32,
    DecreasePercent: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ADMINISTRATOR_POWER_POLICY = extern struct {
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    MinVideoTimeout: u32,
    MaxVideoTimeout: u32,
    MinSpindownTimeout: u32,
    MaxSpindownTimeout: u32,
};

pub const HIBERFILE_BUCKET_SIZE = extern enum(i32) {
    @"1GB" = 0,
    @"2GB" = 1,
    @"4GB" = 2,
    @"8GB" = 3,
    @"16GB" = 4,
    @"32GB" = 5,
    Unlimited = 6,
    Max = 7,
};
pub const HiberFileBucket1GB = HIBERFILE_BUCKET_SIZE.@"1GB";
pub const HiberFileBucket2GB = HIBERFILE_BUCKET_SIZE.@"2GB";
pub const HiberFileBucket4GB = HIBERFILE_BUCKET_SIZE.@"4GB";
pub const HiberFileBucket8GB = HIBERFILE_BUCKET_SIZE.@"8GB";
pub const HiberFileBucket16GB = HIBERFILE_BUCKET_SIZE.@"16GB";
pub const HiberFileBucket32GB = HIBERFILE_BUCKET_SIZE.@"32GB";
pub const HiberFileBucketUnlimited = HIBERFILE_BUCKET_SIZE.Unlimited;
pub const HiberFileBucketMax = HIBERFILE_BUCKET_SIZE.Max;

pub const HIBERFILE_BUCKET = extern struct {
    MaxPhysicalMemory: u64,
    PhysicalMemoryPercent: [3]u32,
};

pub const SYSTEM_POWER_CAPABILITIES = extern struct {
    PowerButtonPresent: u8,
    SleepButtonPresent: u8,
    LidPresent: u8,
    SystemS1: u8,
    SystemS2: u8,
    SystemS3: u8,
    SystemS4: u8,
    SystemS5: u8,
    HiberFilePresent: u8,
    FullWake: u8,
    VideoDimPresent: u8,
    ApmPresent: u8,
    UpsPresent: u8,
    ThermalControl: u8,
    ProcessorThrottle: u8,
    ProcessorMinThrottle: u8,
    ProcessorMaxThrottle: u8,
    FastSystemS4: u8,
    Hiberboot: u8,
    WakeAlarmPresent: u8,
    AoAc: u8,
    DiskSpinDown: u8,
    HiberFileType: u8,
    AoAcConnectivitySupported: u8,
    spare3: [6]u8,
    SystemBatteriesPresent: u8,
    BatteriesAreShortTerm: u8,
    BatteryScale: [3]BATTERY_REPORTING_SCALE,
    AcOnLineWake: SYSTEM_POWER_STATE,
    SoftLidWake: SYSTEM_POWER_STATE,
    RtcWake: SYSTEM_POWER_STATE,
    MinDeviceWakeState: SYSTEM_POWER_STATE,
    DefaultLowLatencyWake: SYSTEM_POWER_STATE,
};

pub const SYSTEM_BATTERY_STATE = extern struct {
    AcOnLine: u8,
    BatteryPresent: u8,
    Charging: u8,
    Discharging: u8,
    Spare1: [3]u8,
    Tag: u8,
    MaxCapacity: u32,
    RemainingCapacity: u32,
    Rate: u32,
    EstimatedTime: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
};

pub const IMAGE_DOS_HEADER = extern struct {
    e_magic: u16,
    e_cblp: u16,
    e_cp: u16,
    e_crlc: u16,
    e_cparhdr: u16,
    e_minalloc: u16,
    e_maxalloc: u16,
    e_ss: u16,
    e_sp: u16,
    e_csum: u16,
    e_ip: u16,
    e_cs: u16,
    e_lfarlc: u16,
    e_ovno: u16,
    e_res: [4]u16,
    e_oemid: u16,
    e_oeminfo: u16,
    e_res2: [10]u16,
    e_lfanew: i32,
};

pub const IMAGE_OS2_HEADER = extern struct {
    ne_magic: u16,
    ne_ver: CHAR,
    ne_rev: CHAR,
    ne_enttab: u16,
    ne_cbenttab: u16,
    ne_crc: i32,
    ne_flags: u16,
    ne_autodata: u16,
    ne_heap: u16,
    ne_stack: u16,
    ne_csip: i32,
    ne_sssp: i32,
    ne_cseg: u16,
    ne_cmod: u16,
    ne_cbnrestab: u16,
    ne_segtab: u16,
    ne_rsrctab: u16,
    ne_restab: u16,
    ne_modtab: u16,
    ne_imptab: u16,
    ne_nrestab: i32,
    ne_cmovent: u16,
    ne_align: u16,
    ne_cres: u16,
    ne_exetyp: u8,
    ne_flagsothers: u8,
    ne_pretthunks: u16,
    ne_psegrefbytes: u16,
    ne_swaparea: u16,
    ne_expver: u16,
};

pub const IMAGE_VXD_HEADER = extern struct {
    e32_magic: u16,
    e32_border: u8,
    e32_worder: u8,
    e32_level: u32,
    e32_cpu: u16,
    e32_os: u16,
    e32_ver: u32,
    e32_mflags: u32,
    e32_mpages: u32,
    e32_startobj: u32,
    e32_eip: u32,
    e32_stackobj: u32,
    e32_esp: u32,
    e32_pagesize: u32,
    e32_lastpagesize: u32,
    e32_fixupsize: u32,
    e32_fixupsum: u32,
    e32_ldrsize: u32,
    e32_ldrsum: u32,
    e32_objtab: u32,
    e32_objcnt: u32,
    e32_objmap: u32,
    e32_itermap: u32,
    e32_rsrctab: u32,
    e32_rsrccnt: u32,
    e32_restab: u32,
    e32_enttab: u32,
    e32_dirtab: u32,
    e32_dircnt: u32,
    e32_fpagetab: u32,
    e32_frectab: u32,
    e32_impmod: u32,
    e32_impmodcnt: u32,
    e32_impproc: u32,
    e32_pagesum: u32,
    e32_datapage: u32,
    e32_preload: u32,
    e32_nrestab: u32,
    e32_cbnrestab: u32,
    e32_nressum: u32,
    e32_autodata: u32,
    e32_debuginfo: u32,
    e32_debuglen: u32,
    e32_instpreload: u32,
    e32_instdemand: u32,
    e32_heapsize: u32,
    e32_res3: [12]u8,
    e32_winresoff: u32,
    e32_winreslen: u32,
    e32_devid: u16,
    e32_ddkver: u16,
};

pub const IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    BaseOfBss: u32,
    GprMask: u32,
    CprMask: [4]u32,
    GpValue: u32,
};

pub const IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};

pub const ANON_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
};

pub const ANON_OBJECT_HEADER_V2 = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
};

pub const ANON_OBJECT_HEADER_BIGOBJ = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
    NumberOfSections: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
};

pub const IMAGE_SYMBOL = extern struct {
    N: _N_e__Union,
    Value: u32,
    SectionNumber: i16,
    Type: u16,
    StorageClass: u8,
    NumberOfAuxSymbols: u8,
    const _N_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_SYMBOL_EX = extern struct {
    N: _N_e__Union,
    Value: u32,
    SectionNumber: i32,
    Type: u16,
    StorageClass: u8,
    NumberOfAuxSymbols: u8,
    const _N_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_AUX_SYMBOL_TOKEN_DEF = extern struct {
    bAuxType: u8,
    bReserved: u8,
    SymbolTableIndex: u32,
    rgbReserved: [12]u8,
};

pub const IMAGE_AUX_SYMBOL = extern union {
    Sym: _Sym_e__Struct,
    File: _File_e__Struct,
    Section: _Section_e__Struct,
    TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    CRC: _CRC_e__Struct,
    const _CRC_e__Struct = u32; // TODO: generate this nested type!
    const _File_e__Struct = u32; // TODO: generate this nested type!
    const _Sym_e__Struct = u32; // TODO: generate this nested type!
    const _Section_e__Struct = u32; // TODO: generate this nested type!
};

pub const IMAGE_AUX_SYMBOL_EX = extern union {
    Sym: _Sym_e__Struct,
    File: _File_e__Struct,
    Section: _Section_e__Struct,
    Anonymous: _Anonymous_e__Struct,
    CRC: _CRC_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
    const _File_e__Struct = u32; // TODO: generate this nested type!
    const _Section_e__Struct = u32; // TODO: generate this nested type!
    const _Sym_e__Struct = u32; // TODO: generate this nested type!
    const _CRC_e__Struct = u32; // TODO: generate this nested type!
};

pub const IMAGE_AUX_SYMBOL_TYPE = extern enum(i32) {
    F = 1,
};
pub const IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = IMAGE_AUX_SYMBOL_TYPE.F;

pub const IMAGE_RELOCATION = extern struct {
    Anonymous: _Anonymous_e__Union,
    SymbolTableIndex: u32,
    Type: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_LINENUMBER = extern struct {
    Type: _Type_e__Union,
    Linenumber: u16,
    const _Type_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_BASE_RELOCATION = extern struct {
    VirtualAddress: u32,
    SizeOfBlock: u32,
};

pub const IMAGE_ARCHIVE_MEMBER_HEADER = extern struct {
    Name: [16]u8,
    Date: [12]u8,
    UserID: [6]u8,
    GroupID: [6]u8,
    Mode: [8]u8,
    Size: [10]u8,
    EndHeader: [2]u8,
};

pub const IMAGE_EXPORT_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Name: u32,
    Base: u32,
    NumberOfFunctions: u32,
    NumberOfNames: u32,
    AddressOfFunctions: u32,
    AddressOfNames: u32,
    AddressOfNameOrdinals: u32,
};

pub const IMAGE_IMPORT_BY_NAME = extern struct {
    Hint: u16,
    Name: [1]CHAR,
};

pub const IMAGE_THUNK_DATA64 = extern struct {
    u1: _u1_e__Union,
    const _u1_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_THUNK_DATA32 = extern struct {
    u1: _u1_e__Union,
    const _u1_e__Union = u32; // TODO: generate this nested type!
};

pub const PIMAGE_TLS_CALLBACK = fn(
    DllHandle: *c_void,
    Reason: u32,
    Reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IMAGE_TLS_DIRECTORY64 = extern struct {
    StartAddressOfRawData: u64,
    EndAddressOfRawData: u64,
    AddressOfIndex: u64,
    AddressOfCallBacks: u64,
    SizeOfZeroFill: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_TLS_DIRECTORY32 = extern struct {
    StartAddressOfRawData: u32,
    EndAddressOfRawData: u32,
    AddressOfIndex: u32,
    AddressOfCallBacks: u32,
    SizeOfZeroFill: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_IMPORT_DESCRIPTOR = extern struct {
    Anonymous: _Anonymous_e__Union,
    TimeDateStamp: u32,
    ForwarderChain: u32,
    Name: u32,
    FirstThunk: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_BOUND_IMPORT_DESCRIPTOR = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    NumberOfModuleForwarderRefs: u16,
};

pub const IMAGE_BOUND_FORWARDER_REF = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    Reserved: u16,
};

pub const IMAGE_DELAYLOAD_DESCRIPTOR = extern struct {
    Attributes: _Attributes_e__Union,
    DllNameRVA: u32,
    ModuleHandleRVA: u32,
    ImportAddressTableRVA: u32,
    ImportNameTableRVA: u32,
    BoundImportAddressTableRVA: u32,
    UnloadInformationTableRVA: u32,
    TimeDateStamp: u32,
    const _Attributes_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_RESOURCE_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    NumberOfNamedEntries: u16,
    NumberOfIdEntries: u16,
};

pub const IMAGE_RESOURCE_DIRECTORY_ENTRY = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_RESOURCE_DIRECTORY_STRING = extern struct {
    Length: u16,
    NameString: [1]CHAR,
};

pub const IMAGE_RESOURCE_DIR_STRING_U = extern struct {
    Length: u16,
    NameString: [1]u16,
};

pub const IMAGE_RESOURCE_DATA_ENTRY = extern struct {
    OffsetToData: u32,
    Size: u32,
    CodePage: u32,
    Reserved: u32,
};

pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: u16,
    Catalog: u16,
    CatalogOffset: u32,
    Reserved: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION_TABLE = extern struct {
    Version: u32,
    Size: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION32 = extern struct {
    Symbol: u32,
    BaseRelocSize: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION64 = extern struct {
    Symbol: u64,
    BaseRelocSize: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION32_V2 = extern struct {
    HeaderSize: u32,
    FixupInfoSize: u32,
    Symbol: u32,
    SymbolGroup: u32,
    Flags: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION64_V2 = extern struct {
    HeaderSize: u32,
    FixupInfoSize: u32,
    Symbol: u64,
    SymbolGroup: u32,
    Flags: u32,
};

pub const IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    PrologueByteCount: u8,
};

pub const IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    EpilogueCount: u32,
    EpilogueByteCount: u8,
    BranchDescriptorElementSize: u8,
    BranchDescriptorCount: u16,
};

pub const IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u32,
};

pub const IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u16,
};

pub const IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u16,
};

pub const IMAGE_HOT_PATCH_INFO = extern struct {
    Version: u32,
    Size: u32,
    SequenceNumber: u32,
    BaseImageList: u32,
    BaseImageCount: u32,
    BufferOffset: u32,
    ExtraPatchSize: u32,
};

pub const IMAGE_HOT_PATCH_BASE = extern struct {
    SequenceNumber: u32,
    Flags: u32,
    OriginalTimeDateStamp: u32,
    OriginalCheckSum: u32,
    CodeIntegrityInfo: u32,
    CodeIntegritySize: u32,
    PatchTable: u32,
    BufferOffset: u32,
};

pub const IMAGE_HOT_PATCH_HASHES = extern struct {
    SHA256: [32]u8,
    SHA1: [20]u8,
};

pub const IMAGE_CE_RUNTIME_FUNCTION_ENTRY = extern struct {
    FuncStart: u32,
    _bitfield: u32,
};

pub const IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ARM64_FNPDATA_FLAGS = extern enum(i32) {
    RefToFullXdata = 0,
    PackedUnwindFunction = 1,
    PackedUnwindFragment = 2,
};
pub const PdataRefToFullXdata = ARM64_FNPDATA_FLAGS.RefToFullXdata;
pub const PdataPackedUnwindFunction = ARM64_FNPDATA_FLAGS.PackedUnwindFunction;
pub const PdataPackedUnwindFragment = ARM64_FNPDATA_FLAGS.PackedUnwindFragment;

pub const ARM64_FNPDATA_CR = extern enum(i32) {
    Unchained = 0,
    UnchainedSavedLr = 1,
    Chained = 3,
};
pub const PdataCrUnchained = ARM64_FNPDATA_CR.Unchained;
pub const PdataCrUnchainedSavedLr = ARM64_FNPDATA_CR.UnchainedSavedLr;
pub const PdataCrChained = ARM64_FNPDATA_CR.Chained;

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA = extern union {
    HeaderData: u32,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u64,
    EndAddress: u64,
    ExceptionHandler: u64,
    HandlerData: u64,
    PrologEndAddress: u64,
};

pub const IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    ExceptionHandler: u32,
    HandlerData: u32,
    PrologEndAddress: u32,
};

pub const IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_ENCLAVE_CONFIG32 = extern struct {
    Size: u32,
    MinimumRequiredConfigSize: u32,
    PolicyFlags: u32,
    NumberOfImports: u32,
    ImportList: u32,
    ImportEntrySize: u32,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImageVersion: u32,
    SecurityVersion: u32,
    EnclaveSize: u32,
    NumberOfThreads: u32,
    EnclaveFlags: u32,
};

pub const IMAGE_ENCLAVE_CONFIG64 = extern struct {
    Size: u32,
    MinimumRequiredConfigSize: u32,
    PolicyFlags: u32,
    NumberOfImports: u32,
    ImportList: u32,
    ImportEntrySize: u32,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImageVersion: u32,
    SecurityVersion: u32,
    EnclaveSize: u64,
    NumberOfThreads: u32,
    EnclaveFlags: u32,
};

pub const IMAGE_ENCLAVE_IMPORT = extern struct {
    MatchType: u32,
    MinimumSecurityVersion: u32,
    UniqueOrAuthorID: [32]u8,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImportName: u32,
    Reserved: u32,
};

pub const IMAGE_DEBUG_MISC = extern struct {
    DataType: u32,
    Length: u32,
    Unicode: u8,
    Reserved: [3]u8,
    Data: [1]u8,
};

pub const IMAGE_SEPARATE_DEBUG_HEADER = extern struct {
    Signature: u16,
    Flags: u16,
    Machine: u16,
    Characteristics: u16,
    TimeDateStamp: u32,
    CheckSum: u32,
    ImageBase: u32,
    SizeOfImage: u32,
    NumberOfSections: u32,
    ExportedNamesSize: u32,
    DebugDirectorySize: u32,
    SectionAlignment: u32,
    Reserved: [2]u32,
};

pub const NON_PAGED_DEBUG_INFO = extern struct {
    Signature: u16,
    Flags: u16,
    Size: u32,
    Machine: u16,
    Characteristics: u16,
    TimeDateStamp: u32,
    CheckSum: u32,
    SizeOfImage: u32,
    ImageBase: u64,
};

pub const IMAGE_ARCHITECTURE_HEADER = extern struct {
    _bitfield: u32,
    FirstEntryRVA: u32,
};

pub const IMAGE_ARCHITECTURE_ENTRY = extern struct {
    FixupInstRVA: u32,
    NewInst: u32,
};

pub const IMPORT_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    SizeOfData: u32,
    Anonymous: _Anonymous_e__Union,
    _bitfield: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMPORT_OBJECT_TYPE = extern enum(i32) {
    CODE = 0,
    DATA = 1,
    CONST = 2,
};
pub const IMPORT_OBJECT_CODE = IMPORT_OBJECT_TYPE.CODE;
pub const IMPORT_OBJECT_DATA = IMPORT_OBJECT_TYPE.DATA;
pub const IMPORT_OBJECT_CONST = IMPORT_OBJECT_TYPE.CONST;

pub const IMPORT_OBJECT_NAME_TYPE = extern enum(i32) {
    ORDINAL = 0,
    NAME = 1,
    NAME_NO_PREFIX = 2,
    NAME_UNDECORATE = 3,
    NAME_EXPORTAS = 4,
};
pub const IMPORT_OBJECT_ORDINAL = IMPORT_OBJECT_NAME_TYPE.ORDINAL;
pub const IMPORT_OBJECT_NAME = IMPORT_OBJECT_NAME_TYPE.NAME;
pub const IMPORT_OBJECT_NAME_NO_PREFIX = IMPORT_OBJECT_NAME_TYPE.NAME_NO_PREFIX;
pub const IMPORT_OBJECT_NAME_UNDECORATE = IMPORT_OBJECT_NAME_TYPE.NAME_UNDECORATE;
pub const IMPORT_OBJECT_NAME_EXPORTAS = IMPORT_OBJECT_NAME_TYPE.NAME_EXPORTAS;

pub const ReplacesCorHdrNumericDefines = extern enum(i32) {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COMIMAGE_FLAGS_32BITPREFERRED = 131072,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = 2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_MIH_METHODRVA = 1,
    IMAGE_COR_MIH_EHRVA = 2,
    IMAGE_COR_MIH_BASICBLOCK = 8,
    COR_VTABLE_32BIT = 1,
    COR_VTABLE_64BIT = 2,
    COR_VTABLE_FROM_UNMANAGED = 4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8,
    COR_VTABLE_CALL_MOST_DERIVED = 16,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024,
};
pub const COMIMAGE_FLAGS_ILONLY = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY;
pub const COMIMAGE_FLAGS_32BITREQUIRED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED;
pub const COMIMAGE_FLAGS_IL_LIBRARY = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY;
pub const COMIMAGE_FLAGS_STRONGNAMESIGNED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED;
pub const COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
pub const COMIMAGE_FLAGS_TRACKDEBUGDATA = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA;
pub const COMIMAGE_FLAGS_32BITPREFERRED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITPREFERRED;
pub const COR_VERSION_MAJOR_V2 = ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2;
pub const COR_VERSION_MAJOR = ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR;
pub const COR_VERSION_MINOR = ReplacesCorHdrNumericDefines.COR_VERSION_MINOR;
pub const COR_DELETED_NAME_LENGTH = ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH;
pub const COR_VTABLEGAP_NAME_LENGTH = ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH;
pub const NATIVE_TYPE_MAX_CB = ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB;
pub const COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE;
pub const IMAGE_COR_MIH_METHODRVA = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA;
pub const IMAGE_COR_MIH_EHRVA = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA;
pub const IMAGE_COR_MIH_BASICBLOCK = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK;
pub const COR_VTABLE_32BIT = ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT;
pub const COR_VTABLE_64BIT = ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT;
pub const COR_VTABLE_FROM_UNMANAGED = ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED;
pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN;
pub const COR_VTABLE_CALL_MOST_DERIVED = ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED;
pub const IMAGE_COR_EATJ_THUNK_SIZE = ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE;
pub const MAX_CLASS_NAME = ReplacesCorHdrNumericDefines.MAX_CLASS_NAME;
pub const MAX_PACKAGE_NAME = ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME;

pub const IMAGE_COR20_HEADER = extern struct {
    cb: u32,
    MajorRuntimeVersion: u16,
    MinorRuntimeVersion: u16,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: u32,
    Anonymous: _Anonymous_e__Union,
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const SLIST_HEADER = extern union {
    Anonymous: _Anonymous_e__Struct,
    HeaderX64: _HeaderX64_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
    const _HeaderX64_e__Struct = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub const RTL_RUN_ONCE = extern union {
    Ptr: *c_void,
};

pub const RTL_BARRIER = extern struct {
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: [2]usize,
    Reserved4: u32,
    Reserved5: u32,
};

pub const RTL_UMS_THREAD_INFO_CLASS = extern enum(i32) {
    InvalidInfoClass = 0,
    UserContext = 1,
    Priority = 2,
    Affinity = 3,
    Teb = 4,
    IsSuspended = 5,
    IsTerminated = 6,
    MaxInfoClass = 7,
};
pub const UmsThreadInvalidInfoClass = RTL_UMS_THREAD_INFO_CLASS.InvalidInfoClass;
pub const UmsThreadUserContext = RTL_UMS_THREAD_INFO_CLASS.UserContext;
pub const UmsThreadPriority = RTL_UMS_THREAD_INFO_CLASS.Priority;
pub const UmsThreadAffinity = RTL_UMS_THREAD_INFO_CLASS.Affinity;
pub const UmsThreadTeb = RTL_UMS_THREAD_INFO_CLASS.Teb;
pub const UmsThreadIsSuspended = RTL_UMS_THREAD_INFO_CLASS.IsSuspended;
pub const UmsThreadIsTerminated = RTL_UMS_THREAD_INFO_CLASS.IsTerminated;
pub const UmsThreadMaxInfoClass = RTL_UMS_THREAD_INFO_CLASS.MaxInfoClass;

pub const RTL_UMS_SCHEDULER_REASON = extern enum(i32) {
    Startup = 0,
    ThreadBlocked = 1,
    ThreadYield = 2,
};
pub const UmsSchedulerStartup = RTL_UMS_SCHEDULER_REASON.Startup;
pub const UmsSchedulerThreadBlocked = RTL_UMS_SCHEDULER_REASON.ThreadBlocked;
pub const UmsSchedulerThreadYield = RTL_UMS_SCHEDULER_REASON.ThreadYield;

pub const PRTL_UMS_SCHEDULER_ENTRY_POINT = fn(
    Reason: RTL_UMS_SCHEDULER_REASON,
    ActivationPayload: usize,
    SchedulerParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const OS_DEPLOYEMENT_STATE_VALUES = extern enum(i32) {
    STANDARD = 1,
    COMPACT = 2,
};
pub const OS_DEPLOYMENT_STANDARD = OS_DEPLOYEMENT_STATE_VALUES.STANDARD;
pub const OS_DEPLOYMENT_COMPACT = OS_DEPLOYEMENT_STATE_VALUES.COMPACT;

pub const NV_MEMORY_RANGE = extern struct {
    BaseAddress: *c_void,
    Length: usize,
};

pub const CORRELATION_VECTOR = extern struct {
    Version: CHAR,
    Vector: [129]CHAR,
};

pub const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = extern struct {
    Size: u32,
    TriggerId: [*:0]const u16,
};

pub const IMAGE_POLICY_ENTRY_TYPE = extern enum(i32) {
    None = 0,
    Bool = 1,
    Int8 = 2,
    UInt8 = 3,
    Int16 = 4,
    UInt16 = 5,
    Int32 = 6,
    UInt32 = 7,
    Int64 = 8,
    UInt64 = 9,
    AnsiString = 10,
    UnicodeString = 11,
    Override = 12,
    Maximum = 13,
};
pub const ImagePolicyEntryTypeNone = IMAGE_POLICY_ENTRY_TYPE.None;
pub const ImagePolicyEntryTypeBool = IMAGE_POLICY_ENTRY_TYPE.Bool;
pub const ImagePolicyEntryTypeInt8 = IMAGE_POLICY_ENTRY_TYPE.Int8;
pub const ImagePolicyEntryTypeUInt8 = IMAGE_POLICY_ENTRY_TYPE.UInt8;
pub const ImagePolicyEntryTypeInt16 = IMAGE_POLICY_ENTRY_TYPE.Int16;
pub const ImagePolicyEntryTypeUInt16 = IMAGE_POLICY_ENTRY_TYPE.UInt16;
pub const ImagePolicyEntryTypeInt32 = IMAGE_POLICY_ENTRY_TYPE.Int32;
pub const ImagePolicyEntryTypeUInt32 = IMAGE_POLICY_ENTRY_TYPE.UInt32;
pub const ImagePolicyEntryTypeInt64 = IMAGE_POLICY_ENTRY_TYPE.Int64;
pub const ImagePolicyEntryTypeUInt64 = IMAGE_POLICY_ENTRY_TYPE.UInt64;
pub const ImagePolicyEntryTypeAnsiString = IMAGE_POLICY_ENTRY_TYPE.AnsiString;
pub const ImagePolicyEntryTypeUnicodeString = IMAGE_POLICY_ENTRY_TYPE.UnicodeString;
pub const ImagePolicyEntryTypeOverride = IMAGE_POLICY_ENTRY_TYPE.Override;
pub const ImagePolicyEntryTypeMaximum = IMAGE_POLICY_ENTRY_TYPE.Maximum;

pub const IMAGE_POLICY_ID = extern enum(i32) {
    None = 0,
    Etw = 1,
    Debug = 2,
    CrashDump = 3,
    CrashDumpKey = 4,
    CrashDumpKeyGuid = 5,
    ParentSd = 6,
    ParentSdRev = 7,
    Svn = 8,
    DeviceId = 9,
    Capability = 10,
    ScenarioId = 11,
    Maximum = 12,
};
pub const ImagePolicyIdNone = IMAGE_POLICY_ID.None;
pub const ImagePolicyIdEtw = IMAGE_POLICY_ID.Etw;
pub const ImagePolicyIdDebug = IMAGE_POLICY_ID.Debug;
pub const ImagePolicyIdCrashDump = IMAGE_POLICY_ID.CrashDump;
pub const ImagePolicyIdCrashDumpKey = IMAGE_POLICY_ID.CrashDumpKey;
pub const ImagePolicyIdCrashDumpKeyGuid = IMAGE_POLICY_ID.CrashDumpKeyGuid;
pub const ImagePolicyIdParentSd = IMAGE_POLICY_ID.ParentSd;
pub const ImagePolicyIdParentSdRev = IMAGE_POLICY_ID.ParentSdRev;
pub const ImagePolicyIdSvn = IMAGE_POLICY_ID.Svn;
pub const ImagePolicyIdDeviceId = IMAGE_POLICY_ID.DeviceId;
pub const ImagePolicyIdCapability = IMAGE_POLICY_ID.Capability;
pub const ImagePolicyIdScenarioId = IMAGE_POLICY_ID.ScenarioId;
pub const ImagePolicyIdMaximum = IMAGE_POLICY_ID.Maximum;

pub const IMAGE_POLICY_ENTRY = extern struct {
    Type: IMAGE_POLICY_ENTRY_TYPE,
    PolicyId: IMAGE_POLICY_ID,
    u: _u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_POLICY_METADATA = extern struct {
    Version: u8,
    Reserved0: [7]u8,
    ApplicationId: u64,
    Policies: IMAGE_POLICY_ENTRY,
};

pub const RTL_CRITICAL_SECTION_DEBUG = extern struct {
    Type: u16,
    CreatorBackTraceIndex: u16,
    CriticalSection: *RTL_CRITICAL_SECTION,
    ProcessLocksList: LIST_ENTRY,
    EntryCount: u32,
    ContentionCount: u32,
    Flags: u32,
    CreatorBackTraceIndexHigh: u16,
    SpareWORD: u16,
};

pub const RTL_CRITICAL_SECTION = extern struct {
    DebugInfo: *RTL_CRITICAL_SECTION_DEBUG,
    LockCount: i32,
    RecursionCount: i32,
    OwningThread: HANDLE,
    LockSemaphore: HANDLE,
    SpinCount: usize,
};

pub const RTL_SRWLOCK = extern struct {
    Ptr: *c_void,
};

pub const RTL_CONDITION_VARIABLE = extern struct {
    Ptr: *c_void,
};

pub const PAPCFUNC = fn(
    Parameter: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const HEAP_INFORMATION_CLASS = extern enum(i32) {
    CompatibilityInformation = 0,
    EnableTerminationOnCorruption = 1,
    OptimizeResources = 3,
};
pub const HeapCompatibilityInformation = HEAP_INFORMATION_CLASS.CompatibilityInformation;
pub const HeapEnableTerminationOnCorruption = HEAP_INFORMATION_CLASS.EnableTerminationOnCorruption;
pub const HeapOptimizeResources = HEAP_INFORMATION_CLASS.OptimizeResources;

pub const HEAP_OPTIMIZE_RESOURCES_INFORMATION = extern struct {
    Version: u32,
    Flags: u32,
};

pub const WAITORTIMERCALLBACK = fn(
    param0: *c_void,
    param1: u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WORKERCALLBACKFUNC = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const APC_CALLBACK_FUNCTION = fn(
    param0: u32,
    param1: *c_void,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFLS_CALLBACK_FUNCTION = fn(
    lpFlsData: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSECURE_MEMORY_CACHE_CALLBACK = fn(
    // TODO: what to do with BytesParamIndex 1?
    Addr: *c_void,
    Range: usize,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const ACTIVATION_CONTEXT_INFO_CLASS = extern enum(i32) {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass = 8,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4,
};
pub const ActivationContextBasicInformation = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextBasicInformation;
pub const ActivationContextDetailedInformation = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextDetailedInformation;
pub const AssemblyDetailedInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContext;
pub const FileInformationInAssemblyOfAssemblyInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContext;
pub const RunlevelInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.RunlevelInformationInActivationContext;
pub const CompatibilityInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.CompatibilityInformationInActivationContext;
pub const ActivationContextManifestResourceName = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextManifestResourceName;
pub const MaxActivationContextInfoClass = ACTIVATION_CONTEXT_INFO_CLASS.MaxActivationContextInfoClass;
pub const AssemblyDetailedInformationInActivationContxt = ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContxt;
pub const FileInformationInAssemblyOfAssemblyInActivationContxt = ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContxt;

pub const SUPPORTED_OS_INFO = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const MAXVERSIONTESTED_INFO = extern struct {
    MaxVersionTested: u64,
};

pub const EVENTLOGRECORD = extern struct {
    Length: u32,
    Reserved: u32,
    RecordNumber: u32,
    TimeGenerated: u32,
    TimeWritten: u32,
    EventID: u32,
    EventType: REPORT_EVENT_TYPE,
    NumStrings: u16,
    EventCategory: u16,
    ReservedFlags: u16,
    ClosingRecordNumber: u32,
    StringOffset: u32,
    UserSidLength: u32,
    UserSidOffset: u32,
    DataLength: u32,
    DataOffset: u32,
};

pub const EVENTSFORLOGFILE = extern struct {
    ulSize: u32,
    szLogicalLogFile: [256]u16,
    ulNumRecords: u32,
    pEventLogRecords: EVENTLOGRECORD,
};

pub const PACKEDEVENTINFO = extern struct {
    ulSize: u32,
    ulNumEventsForLogFile: u32,
    ulOffsets: u32,
};

pub const CM_SERVICE_NODE_TYPE = extern enum(i32) {
    DriverType = 1,
    FileSystemType = 2,
    Win32ServiceOwnProcess = 16,
    Win32ServiceShareProcess = 32,
    AdapterType = 4,
    RecognizerType = 8,
};
pub const DriverType = CM_SERVICE_NODE_TYPE.DriverType;
pub const FileSystemType = CM_SERVICE_NODE_TYPE.FileSystemType;
pub const Win32ServiceOwnProcess = CM_SERVICE_NODE_TYPE.Win32ServiceOwnProcess;
pub const Win32ServiceShareProcess = CM_SERVICE_NODE_TYPE.Win32ServiceShareProcess;
pub const AdapterType = CM_SERVICE_NODE_TYPE.AdapterType;
pub const RecognizerType = CM_SERVICE_NODE_TYPE.RecognizerType;

pub const CM_SERVICE_LOAD_TYPE = extern enum(i32) {
    BootLoad = 0,
    SystemLoad = 1,
    AutoLoad = 2,
    DemandLoad = 3,
    DisableLoad = 4,
};
pub const BootLoad = CM_SERVICE_LOAD_TYPE.BootLoad;
pub const SystemLoad = CM_SERVICE_LOAD_TYPE.SystemLoad;
pub const AutoLoad = CM_SERVICE_LOAD_TYPE.AutoLoad;
pub const DemandLoad = CM_SERVICE_LOAD_TYPE.DemandLoad;
pub const DisableLoad = CM_SERVICE_LOAD_TYPE.DisableLoad;

pub const CM_ERROR_CONTROL_TYPE = extern enum(i32) {
    IgnoreError = 0,
    NormalError = 1,
    SevereError = 2,
    CriticalError = 3,
};
pub const IgnoreError = CM_ERROR_CONTROL_TYPE.IgnoreError;
pub const NormalError = CM_ERROR_CONTROL_TYPE.NormalError;
pub const SevereError = CM_ERROR_CONTROL_TYPE.SevereError;
pub const CriticalError = CM_ERROR_CONTROL_TYPE.CriticalError;

pub const TAPE_ERASE = extern struct {
    Type: ERASE_TAPE_TYPE,
    Immediate: u8,
};

pub const TAPE_PREPARE = extern struct {
    Operation: PREPARE_TAPE_OPERATION,
    Immediate: u8,
};

pub const TAPE_WRITE_MARKS = extern struct {
    Type: TAPEMARK_TYPE,
    Count: u32,
    Immediate: u8,
};

pub const TAPE_GET_POSITION = extern struct {
    Type: TAPE_POSITION_TYPE,
    Partition: u32,
    Offset: LARGE_INTEGER,
};

pub const TAPE_SET_POSITION = extern struct {
    Method: TAPE_POSITION_METHOD,
    Partition: u32,
    Offset: LARGE_INTEGER,
    Immediate: u8,
};

pub const TAPE_GET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    DefaultBlockSize: u32,
    MaximumBlockSize: u32,
    MinimumBlockSize: u32,
    MaximumPartitionCount: u32,
    FeaturesLow: u32,
    FeaturesHigh: TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH,
    EOTWarningZoneSize: u32,
};

pub const TAPE_SET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    EOTWarningZoneSize: u32,
};

pub const TAPE_GET_MEDIA_PARAMETERS = extern struct {
    Capacity: LARGE_INTEGER,
    Remaining: LARGE_INTEGER,
    BlockSize: u32,
    PartitionCount: u32,
    WriteProtected: u8,
};

pub const TAPE_SET_MEDIA_PARAMETERS = extern struct {
    BlockSize: u32,
};

pub const TAPE_CREATE_PARTITION = extern struct {
    Method: u32,
    Count: u32,
    Size: u32,
};

pub const TAPE_WMI_OPERATIONS = extern struct {
    Method: u32,
    DataBufferSize: u32,
    DataBuffer: *c_void,
};

pub const TAPE_DRIVE_PROBLEM_TYPE = extern enum(i32) {
    ProblemNone = 0,
    ReadWriteWarning = 1,
    ReadWriteError = 2,
    ReadWarning = 3,
    WriteWarning = 4,
    ReadError = 5,
    WriteError = 6,
    HardwareError = 7,
    UnsupportedMedia = 8,
    ScsiConnectionError = 9,
    TimetoClean = 10,
    CleanDriveNow = 11,
    MediaLifeExpired = 12,
    SnappedTape = 13,
};
pub const TapeDriveProblemNone = TAPE_DRIVE_PROBLEM_TYPE.ProblemNone;
pub const TapeDriveReadWriteWarning = TAPE_DRIVE_PROBLEM_TYPE.ReadWriteWarning;
pub const TapeDriveReadWriteError = TAPE_DRIVE_PROBLEM_TYPE.ReadWriteError;
pub const TapeDriveReadWarning = TAPE_DRIVE_PROBLEM_TYPE.ReadWarning;
pub const TapeDriveWriteWarning = TAPE_DRIVE_PROBLEM_TYPE.WriteWarning;
pub const TapeDriveReadError = TAPE_DRIVE_PROBLEM_TYPE.ReadError;
pub const TapeDriveWriteError = TAPE_DRIVE_PROBLEM_TYPE.WriteError;
pub const TapeDriveHardwareError = TAPE_DRIVE_PROBLEM_TYPE.HardwareError;
pub const TapeDriveUnsupportedMedia = TAPE_DRIVE_PROBLEM_TYPE.UnsupportedMedia;
pub const TapeDriveScsiConnectionError = TAPE_DRIVE_PROBLEM_TYPE.ScsiConnectionError;
pub const TapeDriveTimetoClean = TAPE_DRIVE_PROBLEM_TYPE.TimetoClean;
pub const TapeDriveCleanDriveNow = TAPE_DRIVE_PROBLEM_TYPE.CleanDriveNow;
pub const TapeDriveMediaLifeExpired = TAPE_DRIVE_PROBLEM_TYPE.MediaLifeExpired;
pub const TapeDriveSnappedTape = TAPE_DRIVE_PROBLEM_TYPE.SnappedTape;

pub const TRANSACTION_STATE = extern enum(i32) {
    Normal = 1,
    Indoubt = 2,
    CommittedNotify = 3,
};
pub const TransactionStateNormal = TRANSACTION_STATE.Normal;
pub const TransactionStateIndoubt = TRANSACTION_STATE.Indoubt;
pub const TransactionStateCommittedNotify = TRANSACTION_STATE.CommittedNotify;

pub const TRANSACTION_BASIC_INFORMATION = extern struct {
    TransactionId: Guid,
    State: u32,
    Outcome: u32,
};

pub const TRANSACTIONMANAGER_BASIC_INFORMATION = extern struct {
    TmIdentity: Guid,
    VirtualClock: LARGE_INTEGER,
};

pub const TRANSACTIONMANAGER_LOG_INFORMATION = extern struct {
    LogIdentity: Guid,
};

pub const TRANSACTIONMANAGER_LOGPATH_INFORMATION = extern struct {
    LogPathLength: u32,
    LogPath: [1]u16,
};

pub const TRANSACTIONMANAGER_RECOVERY_INFORMATION = extern struct {
    LastRecoveredLsn: u64,
};

pub const TRANSACTIONMANAGER_OLDEST_INFORMATION = extern struct {
    OldestTransactionGuid: Guid,
};

pub const TRANSACTION_PROPERTIES_INFORMATION = extern struct {
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: LARGE_INTEGER,
    Outcome: u32,
    DescriptionLength: u32,
    Description: [1]u16,
};

pub const TRANSACTION_BIND_INFORMATION = extern struct {
    TmHandle: HANDLE,
};

pub const TRANSACTION_ENLISTMENT_PAIR = extern struct {
    EnlistmentId: Guid,
    ResourceManagerId: Guid,
};

pub const TRANSACTION_ENLISTMENTS_INFORMATION = extern struct {
    NumberOfEnlistments: u32,
    EnlistmentPair: [1]TRANSACTION_ENLISTMENT_PAIR,
};

pub const TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = extern struct {
    SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
};

pub const RESOURCEMANAGER_BASIC_INFORMATION = extern struct {
    ResourceManagerId: Guid,
    DescriptionLength: u32,
    Description: [1]u16,
};

pub const RESOURCEMANAGER_COMPLETION_INFORMATION = extern struct {
    IoCompletionPortHandle: HANDLE,
    CompletionKey: usize,
};

pub const TRANSACTION_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    PropertiesInformation = 1,
    EnlistmentInformation = 2,
    SuperiorEnlistmentInformation = 3,
    BindInformation = 4,
    DTCPrivateInformation = 5,
};
pub const TransactionBasicInformation = TRANSACTION_INFORMATION_CLASS.BasicInformation;
pub const TransactionPropertiesInformation = TRANSACTION_INFORMATION_CLASS.PropertiesInformation;
pub const TransactionEnlistmentInformation = TRANSACTION_INFORMATION_CLASS.EnlistmentInformation;
pub const TransactionSuperiorEnlistmentInformation = TRANSACTION_INFORMATION_CLASS.SuperiorEnlistmentInformation;
pub const TransactionBindInformation = TRANSACTION_INFORMATION_CLASS.BindInformation;
pub const TransactionDTCPrivateInformation = TRANSACTION_INFORMATION_CLASS.DTCPrivateInformation;

pub const TRANSACTIONMANAGER_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    LogInformation = 1,
    LogPathInformation = 2,
    RecoveryInformation = 4,
    OnlineProbeInformation = 3,
    OldestTransactionInformation = 5,
};
pub const TransactionManagerBasicInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.BasicInformation;
pub const TransactionManagerLogInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.LogInformation;
pub const TransactionManagerLogPathInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.LogPathInformation;
pub const TransactionManagerRecoveryInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.RecoveryInformation;
pub const TransactionManagerOnlineProbeInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.OnlineProbeInformation;
pub const TransactionManagerOldestTransactionInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.OldestTransactionInformation;

pub const RESOURCEMANAGER_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    CompletionInformation = 1,
};
pub const ResourceManagerBasicInformation = RESOURCEMANAGER_INFORMATION_CLASS.BasicInformation;
pub const ResourceManagerCompletionInformation = RESOURCEMANAGER_INFORMATION_CLASS.CompletionInformation;

pub const ENLISTMENT_BASIC_INFORMATION = extern struct {
    EnlistmentId: Guid,
    TransactionId: Guid,
    ResourceManagerId: Guid,
};

pub const ENLISTMENT_CRM_INFORMATION = extern struct {
    CrmTransactionManagerId: Guid,
    CrmResourceManagerId: Guid,
    CrmEnlistmentId: Guid,
};

pub const ENLISTMENT_INFORMATION_CLASS = extern enum(i32) {
    BasicInformation = 0,
    RecoveryInformation = 1,
    CrmInformation = 2,
};
pub const EnlistmentBasicInformation = ENLISTMENT_INFORMATION_CLASS.BasicInformation;
pub const EnlistmentRecoveryInformation = ENLISTMENT_INFORMATION_CLASS.RecoveryInformation;
pub const EnlistmentCrmInformation = ENLISTMENT_INFORMATION_CLASS.CrmInformation;

pub const TRANSACTION_LIST_ENTRY = extern struct {
    UOW: Guid,
};

pub const TRANSACTION_LIST_INFORMATION = extern struct {
    NumberOfTransactions: u32,
    TransactionInformation: [1]TRANSACTION_LIST_ENTRY,
};

pub const KTMOBJECT_TYPE = extern enum(i32) {
    TRANSACTION = 0,
    TRANSACTION_MANAGER = 1,
    RESOURCE_MANAGER = 2,
    ENLISTMENT = 3,
    INVALID = 4,
};
pub const KTMOBJECT_TRANSACTION = KTMOBJECT_TYPE.TRANSACTION;
pub const KTMOBJECT_TRANSACTION_MANAGER = KTMOBJECT_TYPE.TRANSACTION_MANAGER;
pub const KTMOBJECT_RESOURCE_MANAGER = KTMOBJECT_TYPE.RESOURCE_MANAGER;
pub const KTMOBJECT_ENLISTMENT = KTMOBJECT_TYPE.ENLISTMENT;
pub const KTMOBJECT_INVALID = KTMOBJECT_TYPE.INVALID;

pub const KTMOBJECT_CURSOR = extern struct {
    LastQuery: Guid,
    ObjectIdCount: u32,
    ObjectIds: [1]Guid,
};

pub const PTP_SIMPLE_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_CALLBACK_PRIORITY = extern enum(i32) {
    HIGH = 0,
    NORMAL = 1,
    LOW = 2,
    INVALID = 3,
    COUNT = 3,
};
pub const TP_CALLBACK_PRIORITY_HIGH = TP_CALLBACK_PRIORITY.HIGH;
pub const TP_CALLBACK_PRIORITY_NORMAL = TP_CALLBACK_PRIORITY.NORMAL;
pub const TP_CALLBACK_PRIORITY_LOW = TP_CALLBACK_PRIORITY.LOW;
pub const TP_CALLBACK_PRIORITY_INVALID = TP_CALLBACK_PRIORITY.INVALID;
pub const TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY.COUNT;

pub const TP_POOL_STACK_INFORMATION = extern struct {
    StackReserve: usize,
    StackCommit: usize,
};

pub const PTP_CLEANUP_GROUP_CANCEL_CALLBACK = fn(
    ObjectContext: ?*c_void,
    CleanupContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_CALLBACK_ENVIRON_V3 = extern struct {
    Version: u32,
    Pool: PTP_POOL,
    CleanupGroup: isize,
    CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    RaceDll: *c_void,
    ActivationContext: isize,
    FinalizationCallback: PTP_SIMPLE_CALLBACK,
    u: _u_e__Union,
    CallbackPriority: TP_CALLBACK_PRIORITY,
    Size: u32,
    const _u_e__Union = u32; // TODO: generate this nested type!
    const _ACTIVATION_CONTEXT = u32; // TODO: generate this nested type!
};

pub const PTP_WORK_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Work: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTP_TIMER_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Timer: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTP_WAIT_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Wait: *TP_WAIT,
    WaitResult: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const APP_LOCAL_DEVICE_ID = extern struct {
    value: [32]u8,
};

pub const PINIT_ONCE_FN = fn(
    InitOnce: *RTL_RUN_ONCE,
    Parameter: ?*c_void,
    Context: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PTIMERAPCROUTINE = fn(
    lpArgToCompletionRoutine: ?*c_void,
    dwTimerLowValue: u32,
    dwTimerHighValue: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTP_WIN32_IO_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Overlapped: ?*c_void,
    IoResult: u32,
    NumberOfBytesTransferred: usize,
    Io: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: [*:0]const u16,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
};

pub const HRSRC = ?*opaque{};

pub const HSURF = ?*opaque{};

pub const LSTATUS = i32;

pub const NTSTATUS = i32;

pub const LRESULT = i32;

pub const BOOL = i32;

pub const PWSTR = [*:0]u16;

pub const PSTR = [*:0]u8;

// TODO: this type has a FreeFunc 'CloseHandle', what can Zig do with this information?
pub const HANDLE = ?*opaque{};

//TODO: type 'NonClosableHandle' is "AlsoUsableFor" 'HANDLE' which means this type is implicitly
//      convertible to 'HANDLE' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const NonClosableHandle = HANDLE;

// TODO: this type has a FreeFunc 'FreeLibrary', what can Zig do with this information?
pub const HINSTANCE = ?*opaque{};

// TODO: this type has a FreeFunc 'DeleteTimerQueueEx', what can Zig do with this information?
pub const TimerQueueHandle = isize;

// TODO: this type has a FreeFunc 'CloseThreadpool', what can Zig do with this information?
pub const PTP_POOL = isize;

// TODO: this type has a FreeFunc 'ClosePrivateNamespace', what can Zig do with this information?
pub const NamespaceHandle = isize;

// TODO: this type has a FreeFunc 'DeleteBoundaryDescriptor', what can Zig do with this information?
pub const BoundaryDescriptorHandle = isize;

// TODO: this type has a FreeFunc 'CloseEventLog', what can Zig do with this information?
pub const EventLogHandle = isize;

// TODO: this type has a FreeFunc 'DeregisterEventSource', what can Zig do with this information?
pub const EventSourceHandle = isize;

// TODO: this type has a FreeFunc 'HeapDestroy', what can Zig do with this information?
pub const HeapHandle = isize;

//TODO: type 'ProcessHeapHandle' is "AlsoUsableFor" 'HeapHandle' which means this type is implicitly
//      convertible to 'HeapHandle' but not the other way around.  I don't know how to do this
//      in Zig so for now I'm just defining it as an alias
pub const ProcessHeapHandle = HeapHandle;

// TODO: this type has a FreeFunc 'UnregisterPowerSettingNotification', what can Zig do with this information?
pub const HPOWERNOTIFY = ?*opaque{};

pub const DPI_AWARENESS_CONTEXT = isize;

pub const HUMPD = ?*opaque{};

pub const HSTR = ?*opaque{};

pub const HSPRITE = ?*opaque{};

// TODO: this type has a FreeFunc 'EngDeleteSemaphore', what can Zig do with this information?
pub const HSEMAPHORE = ?*opaque{};

pub const HLSURF = ?*opaque{};

pub const HFASTMUTEX = ?*opaque{};

pub const HDRVOBJ = ?*opaque{};

pub const HDEV = ?*opaque{};

pub const HBM = ?*opaque{};

pub const DHSURF = isize;

pub const DHPDEV = isize;

// TODO: this type has a FreeFunc 'ClosePseudoConsole', what can Zig do with this information?
pub const HPCON = ?*opaque{};

pub const LPPROC_THREAD_ATTRIBUTE_LIST = *c_void;

pub const CHAR = u8;

pub const SHANDLE_PTR = isize;

pub const HANDLE_PTR = usize;

pub const SECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: *c_void,
    bInheritHandle: BOOL,
};

pub const OVERLAPPED = extern struct {
    Internal: usize,
    InternalHigh: usize,
    Anonymous: _Anonymous_e__Union,
    hEvent: HANDLE,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_HEAP_ENTRY = extern struct {
    lpData: *c_void,
    cbData: u32,
    cbOverhead: u8,
    iRegionIndex: u8,
    wFlags: u16,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const REASON_CONTEXT = extern struct {
    Version: u32,
    Flags: POWER_REQUEST_CONTEXT_FLAGS,
    Reason: _Reason_e__Union,
    const _Reason_e__Union = u32; // TODO: generate this nested type!
};

pub const LPTHREAD_START_ROUTINE = fn(
    lpThreadParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPENCLAVE_ROUTINE = fn(
    lpThreadParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const HEAP_SUMMARY = extern struct {
    cb: u32,
    cbAllocated: usize,
    cbCommitted: usize,
    cbReserved: usize,
    cbMaxReserve: usize,
};

pub const MEMORY_RESOURCE_NOTIFICATION_TYPE = extern enum(i32) {
    LowMemoryResourceNotification = 0,
    HighMemoryResourceNotification = 1,
};
pub const LowMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification;
pub const HighMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification;

pub const WIN32_MEMORY_RANGE_ENTRY = extern struct {
    VirtualAddress: *c_void,
    NumberOfBytes: usize,
};

pub const PBAD_MEMORY_CALLBACK_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OFFER_PRIORITY = extern enum(i32) {
    VeryLow = 1,
    Low = 2,
    BelowNormal = 3,
    Normal = 4,
};
pub const VmOfferPriorityVeryLow = OFFER_PRIORITY.VeryLow;
pub const VmOfferPriorityLow = OFFER_PRIORITY.Low;
pub const VmOfferPriorityBelowNormal = OFFER_PRIORITY.BelowNormal;
pub const VmOfferPriorityNormal = OFFER_PRIORITY.Normal;

pub const WIN32_MEMORY_INFORMATION_CLASS = extern enum(i32) {
    o = 0,
};
pub const MemoryRegionInfo = WIN32_MEMORY_INFORMATION_CLASS.o;

pub const WIN32_MEMORY_REGION_INFORMATION = extern struct {
    AllocationBase: *c_void,
    AllocationProtect: u32,
    Anonymous: _Anonymous_e__Union,
    RegionSize: usize,
    CommitSize: usize,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ENUMUILANG = extern struct {
    NumOfEnumUILang: u32,
    SizeOfEnumUIBuffer: u32,
    pEnumUIBuffer: *u16,
};

pub const ENUMRESLANGPROCA = fn(
    hModule: isize,
    lpType: [*:0]const u8,
    lpName: [*:0]const u8,
    wLanguage: u16,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESLANGPROCW = fn(
    hModule: isize,
    lpType: [*:0]const u16,
    lpName: [*:0]const u16,
    wLanguage: u16,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXA = fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXW = fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REDIRECTION_FUNCTION_DESCRIPTOR = extern struct {
    DllName: [*:0]const u8,
    FunctionName: [*:0]const u8,
    RedirectionTarget: *c_void,
};

pub const REDIRECTION_DESCRIPTOR = extern struct {
    Version: u32,
    FunctionCount: u32,
    Redirections: *REDIRECTION_FUNCTION_DESCRIPTOR,
};

pub const COORD = extern struct {
    X: i16,
    Y: i16,
};

pub const SMALL_RECT = extern struct {
    Left: i16,
    Top: i16,
    Right: i16,
    Bottom: i16,
};

pub const KEY_EVENT_RECORD = extern struct {
    bKeyDown: BOOL,
    wRepeatCount: u16,
    wVirtualKeyCode: u16,
    wVirtualScanCode: u16,
    uChar: _uChar_e__Union,
    dwControlKeyState: u32,
    const _uChar_e__Union = u32; // TODO: generate this nested type!
};

pub const MOUSE_EVENT_RECORD = extern struct {
    dwMousePosition: COORD,
    dwButtonState: u32,
    dwControlKeyState: u32,
    dwEventFlags: u32,
};

pub const WINDOW_BUFFER_SIZE_RECORD = extern struct {
    dwSize: COORD,
};

pub const MENU_EVENT_RECORD = extern struct {
    dwCommandId: u32,
};

pub const FOCUS_EVENT_RECORD = extern struct {
    bSetFocus: BOOL,
};

pub const INPUT_RECORD = extern struct {
    EventType: u16,
    Event: _Event_e__Union,
    const _Event_e__Union = u32; // TODO: generate this nested type!
};

pub const CHAR_INFO = extern struct {
    Char: _Char_e__Union,
    Attributes: u16,
    const _Char_e__Union = u32; // TODO: generate this nested type!
};

pub const CONSOLE_FONT_INFO = extern struct {
    nFont: u32,
    dwFontSize: COORD,
};

pub const CONSOLE_READCONSOLE_CONTROL = extern struct {
    nLength: u32,
    nInitialChars: u32,
    dwCtrlWakeupMask: u32,
    dwControlKeyState: u32,
};

pub const PHANDLER_ROUTINE = fn(
    CtrlType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CONSOLE_CURSOR_INFO = extern struct {
    dwSize: u32,
    bVisible: BOOL,
};

pub const CONSOLE_SCREEN_BUFFER_INFO = extern struct {
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
};

pub const CONSOLE_SCREEN_BUFFER_INFOEX = extern struct {
    cbSize: u32,
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
    wPopupAttributes: u16,
    bFullscreenSupported: BOOL,
    ColorTable: [16]u32,
};

pub const CONSOLE_FONT_INFOEX = extern struct {
    cbSize: u32,
    nFont: u32,
    dwFontSize: COORD,
    FontFamily: u32,
    FontWeight: u32,
    FaceName: [32]u16,
};

pub const CONSOLE_SELECTION_INFO = extern struct {
    dwFlags: u32,
    dwSelectionAnchor: COORD,
    srSelection: SMALL_RECT,
};

pub const CONSOLE_HISTORY_INFO = extern struct {
    cbSize: u32,
    HistoryBufferSize: u32,
    NumberOfHistoryBuffers: u32,
    dwFlags: u32,
};

pub const MODEMDEVCAPS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwModemProviderVersion: u32,
    dwModemManufacturerOffset: u32,
    dwModemManufacturerSize: u32,
    dwModemModelOffset: u32,
    dwModemModelSize: u32,
    dwModemVersionOffset: u32,
    dwModemVersionSize: u32,
    dwDialOptions: MODEMDEVCAPS_DIAL_OPTIONS,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: MODEMDEVCAPS_SPEAKER_VOLUME,
    dwSpeakerMode: MODEMDEVCAPS_SPEAKER_MODE,
    dwModemOptions: u32,
    dwMaxDTERate: u32,
    dwMaxDCERate: u32,
    abVariablePortion: [1]u8,
};

pub const MODEMSETTINGS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: MODEM_SPEAKER_VOLUME,
    dwSpeakerMode: MODEMSETTINGS_SPEAKER_MODE,
    dwPreferredModemOptions: u32,
    dwNegotiatedModemOptions: u32,
    dwNegotiatedDCERate: u32,
    abVariablePortion: [1]u8,
};

pub const RPC_IMPORT_CONTEXT_P = extern struct {
    LookupContext: *c_void,
    ProposedHandle: *c_void,
    Bindings: *RPC_BINDING_VECTOR,
};

pub const RemHGLOBAL = extern struct {
    fNullHGlobal: i32,
    cbData: u32,
    data: [1]u8,
};

pub const RemHMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    cbData: u32,
    data: [1]u8,
};

pub const RemHENHMETAFILE = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemHBITMAP = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemHPALETTE = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemBRUSH = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const userCLIPFORMAT = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const GDI_NONREMOTE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHGLOBAL = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHMETAFILE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const remoteMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    hMF: *userHMETAFILE,
};

pub const userHMETAFILEPICT = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHENHMETAFILE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userBITMAP = extern struct {
    bmType: i32,
    bmWidth: i32,
    bmHeight: i32,
    bmWidthBytes: i32,
    bmPlanes: u16,
    bmBitsPixel: u16,
    cbSize: u32,
    pBuffer: [1]u8,
};

pub const userHBITMAP = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHPALETTE = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const RemotableHandle = extern struct {
    fContext: i32,
    u: _u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const CY = extern union {
    Anonymous: _Anonymous_e__Struct,
    int64: i64,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const DECIMAL = extern struct {
    wReserved: u16,
    Anonymous1: _Anonymous1_e__Union,
    Hi32: u32,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: *u8,
};

pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: *u8,
};

pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: _tagged_union_e__Struct,
    const _tagged_union_e__Struct = u32; // TODO: generate this nested type!
};

const IID_IServiceProvider_Value = @import("../zig.zig").Guid.initString("6d5140c1-7436-11ce-8034-00aa006009fa");
pub const IID_IServiceProvider = &IID_IServiceProvider_Value;
pub const IServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: fn(
            self: *const IServiceProvider,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceProvider_QueryService(self: *const T, guidService: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceProvider.VTable, self.vtable).QueryService(@ptrCast(*const IServiceProvider, self), guidService, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPTIMECALLBACK = fn(
    uTimerID: u32,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SCARD_IO_REQUEST = extern struct {
    dwProtocol: u32,
    cbPciLength: u32,
};

pub const SCARD_T0_COMMAND = extern struct {
    bCla: u8,
    bIns: u8,
    bP1: u8,
    bP2: u8,
    bP3: u8,
};

pub const SCARD_T0_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
    bSw1: u8,
    bSw2: u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SCARD_T1_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
};

pub const PRINTER_INFO_1A = extern struct {
    Flags: u32,
    pDescription: PSTR,
    pName: PSTR,
    pComment: PSTR,
};

pub const PRINTER_INFO_1W = extern struct {
    Flags: u32,
    pDescription: PWSTR,
    pName: PWSTR,
    pComment: PWSTR,
};

pub const PRINTER_INFO_2A = extern struct {
    pServerName: PSTR,
    pPrinterName: PSTR,
    pShareName: PSTR,
    pPortName: PSTR,
    pDriverName: PSTR,
    pComment: PSTR,
    pLocation: PSTR,
    pDevMode: *DEVMODEA,
    pSepFile: PSTR,
    pPrintProcessor: PSTR,
    pDatatype: PSTR,
    pParameters: PSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};

pub const PRINTER_INFO_2W = extern struct {
    pServerName: PWSTR,
    pPrinterName: PWSTR,
    pShareName: PWSTR,
    pPortName: PWSTR,
    pDriverName: PWSTR,
    pComment: PWSTR,
    pLocation: PWSTR,
    pDevMode: *DEVMODEW,
    pSepFile: PWSTR,
    pPrintProcessor: PWSTR,
    pDatatype: PWSTR,
    pParameters: PWSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};

pub const PRINTER_INFO_3 = extern struct {
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
};

pub const PRINTER_INFO_4A = extern struct {
    pPrinterName: PSTR,
    pServerName: PSTR,
    Attributes: u32,
};

pub const PRINTER_INFO_4W = extern struct {
    pPrinterName: PWSTR,
    pServerName: PWSTR,
    Attributes: u32,
};

pub const PRINTER_INFO_5A = extern struct {
    pPrinterName: PSTR,
    pPortName: PSTR,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};

pub const PRINTER_INFO_5W = extern struct {
    pPrinterName: PWSTR,
    pPortName: PWSTR,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};

pub const PRINTER_INFO_6 = extern struct {
    dwStatus: u32,
};

pub const PRINTER_INFO_7A = extern struct {
    pszObjectGUID: PSTR,
    dwAction: u32,
};

pub const PRINTER_INFO_7W = extern struct {
    pszObjectGUID: PWSTR,
    dwAction: u32,
};

pub const PRINTER_INFO_8A = extern struct {
    pDevMode: *DEVMODEA,
};

pub const PRINTER_INFO_8W = extern struct {
    pDevMode: *DEVMODEW,
};

pub const PRINTER_INFO_9A = extern struct {
    pDevMode: *DEVMODEA,
};

pub const PRINTER_INFO_9W = extern struct {
    pDevMode: *DEVMODEW,
};

pub const JOB_INFO_1A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pDatatype: PSTR,
    pStatus: PSTR,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};

pub const JOB_INFO_1W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pDatatype: PWSTR,
    pStatus: PWSTR,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};

pub const JOB_INFO_2A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pNotifyName: PSTR,
    pDatatype: PSTR,
    pPrintProcessor: PSTR,
    pParameters: PSTR,
    pDriverName: PSTR,
    pDevMode: *DEVMODEA,
    pStatus: PSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};

pub const JOB_INFO_2W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pNotifyName: PWSTR,
    pDatatype: PWSTR,
    pPrintProcessor: PWSTR,
    pParameters: PWSTR,
    pDriverName: PWSTR,
    pDevMode: *DEVMODEW,
    pStatus: PWSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};

pub const JOB_INFO_3 = extern struct {
    JobId: u32,
    NextJobId: u32,
    Reserved: u32,
};

pub const JOB_INFO_4A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pNotifyName: PSTR,
    pDatatype: PSTR,
    pPrintProcessor: PSTR,
    pParameters: PSTR,
    pDriverName: PSTR,
    pDevMode: *DEVMODEA,
    pStatus: PSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};

pub const JOB_INFO_4W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pNotifyName: PWSTR,
    pDatatype: PWSTR,
    pPrintProcessor: PWSTR,
    pParameters: PWSTR,
    pDriverName: PWSTR,
    pDevMode: *DEVMODEW,
    pStatus: PWSTR,
    pSecurityDescriptor: *SECURITY_DESCRIPTOR,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};

pub const ADDJOB_INFO_1A = extern struct {
    Path: PSTR,
    JobId: u32,
};

pub const ADDJOB_INFO_1W = extern struct {
    Path: PWSTR,
    JobId: u32,
};

pub const DRIVER_INFO_1A = extern struct {
    pName: PSTR,
};

pub const DRIVER_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const DRIVER_INFO_2A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
};

pub const DRIVER_INFO_2W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
};

pub const DRIVER_INFO_3A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
};

pub const DRIVER_INFO_3W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
};

pub const DRIVER_INFO_4A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
};

pub const DRIVER_INFO_4W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
};

pub const DRIVER_INFO_5A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};

pub const DRIVER_INFO_5W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};

pub const DRIVER_INFO_6A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PSTR,
    pszOEMUrl: PSTR,
    pszHardwareID: PSTR,
    pszProvider: PSTR,
};

pub const DRIVER_INFO_6W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PWSTR,
    pszOEMUrl: PWSTR,
    pszHardwareID: PWSTR,
    pszProvider: PWSTR,
};

pub const DRIVER_INFO_8A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PSTR,
    pszOEMUrl: PSTR,
    pszHardwareID: PSTR,
    pszProvider: PSTR,
    pszPrintProcessor: PSTR,
    pszVendorSetup: PSTR,
    pszzColorProfiles: PSTR,
    pszInfPath: PSTR,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: PSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};

pub const DRIVER_INFO_8W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PWSTR,
    pszOEMUrl: PWSTR,
    pszHardwareID: PWSTR,
    pszProvider: PWSTR,
    pszPrintProcessor: PWSTR,
    pszVendorSetup: PWSTR,
    pszzColorProfiles: PWSTR,
    pszInfPath: PWSTR,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: PWSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};

pub const DOC_INFO_1A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
};

pub const DOC_INFO_1W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
};

pub const FORM_INFO_1A = extern struct {
    Flags: u32,
    pName: PSTR,
    Size: SIZE,
    ImageableArea: RECTL,
};

pub const FORM_INFO_1W = extern struct {
    Flags: u32,
    pName: PWSTR,
    Size: SIZE,
    ImageableArea: RECTL,
};

pub const FORM_INFO_2A = extern struct {
    Flags: u32,
    pName: [*:0]const u8,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: [*:0]const u8,
    StringType: u32,
    pMuiDll: [*:0]const u8,
    dwResourceId: u32,
    pDisplayName: [*:0]const u8,
    wLangId: u16,
};

pub const FORM_INFO_2W = extern struct {
    Flags: u32,
    pName: [*:0]const u16,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: [*:0]const u8,
    StringType: u32,
    pMuiDll: [*:0]const u16,
    dwResourceId: u32,
    pDisplayName: [*:0]const u16,
    wLangId: u16,
};

pub const DOC_INFO_2A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
    dwMode: u32,
    JobId: u32,
};

pub const DOC_INFO_2W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
    dwMode: u32,
    JobId: u32,
};

pub const DOC_INFO_3A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
    dwFlags: u32,
};

pub const DOC_INFO_3W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
    dwFlags: u32,
};

pub const PRINTPROCESSOR_INFO_1A = extern struct {
    pName: PSTR,
};

pub const PRINTPROCESSOR_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PRINTPROCESSOR_CAPS_1 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
};

pub const PRINTPROCESSOR_CAPS_2 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
    dwDuplexHandlingCaps: u32,
    dwNupDirectionCaps: u32,
    dwNupBorderCaps: u32,
    dwBookletHandlingCaps: u32,
    dwScalingCaps: u32,
};

pub const PORT_INFO_1A = extern struct {
    pName: PSTR,
};

pub const PORT_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PORT_INFO_2A = extern struct {
    pPortName: PSTR,
    pMonitorName: PSTR,
    pDescription: PSTR,
    fPortType: u32,
    Reserved: u32,
};

pub const PORT_INFO_2W = extern struct {
    pPortName: PWSTR,
    pMonitorName: PWSTR,
    pDescription: PWSTR,
    fPortType: u32,
    Reserved: u32,
};

pub const PORT_INFO_3A = extern struct {
    dwStatus: u32,
    pszStatus: PSTR,
    dwSeverity: u32,
};

pub const PORT_INFO_3W = extern struct {
    dwStatus: u32,
    pszStatus: PWSTR,
    dwSeverity: u32,
};

pub const MONITOR_INFO_1A = extern struct {
    pName: PSTR,
};

pub const MONITOR_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const MONITOR_INFO_2A = extern struct {
    pName: PSTR,
    pEnvironment: PSTR,
    pDLLName: PSTR,
};

pub const MONITOR_INFO_2W = extern struct {
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDLLName: PWSTR,
};

pub const DATATYPES_INFO_1A = extern struct {
    pName: PSTR,
};

pub const DATATYPES_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PRINTER_DEFAULTSA = extern struct {
    pDatatype: PSTR,
    pDevMode: *DEVMODEA,
    DesiredAccess: u32,
};

pub const PRINTER_DEFAULTSW = extern struct {
    pDatatype: PWSTR,
    pDevMode: *DEVMODEW,
    DesiredAccess: u32,
};

pub const PRINTER_ENUM_VALUESA = extern struct {
    pValueName: PSTR,
    cbValueName: u32,
    dwType: u32,
    pData: *u8,
    cbData: u32,
};

pub const PRINTER_ENUM_VALUESW = extern struct {
    pValueName: PWSTR,
    cbValueName: u32,
    dwType: u32,
    pData: *u8,
    cbData: u32,
};

pub const PRINTER_NOTIFY_OPTIONS_TYPE = extern struct {
    Type: u16,
    Reserved0: u16,
    Reserved1: u32,
    Reserved2: u32,
    Count: u32,
    pFields: *u16,
};

pub const PRINTER_NOTIFY_OPTIONS = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    pTypes: *PRINTER_NOTIFY_OPTIONS_TYPE,
};

pub const PRINTER_NOTIFY_INFO_DATA = extern struct {
    Type: u16,
    Field: u16,
    Reserved: u32,
    Id: u32,
    NotifyData: _NotifyData_e__Union,
    const _NotifyData_e__Union = u32; // TODO: generate this nested type!
};

pub const PRINTER_NOTIFY_INFO = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]PRINTER_NOTIFY_INFO_DATA,
};

pub const BINARY_CONTAINER = extern struct {
    cbBuf: u32,
    pData: *u8,
};

pub const BIDI_DATA = extern struct {
    dwBidiType: u32,
    u: _u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const BIDI_REQUEST_DATA = extern struct {
    dwReqNumber: u32,
    pSchema: PWSTR,
    data: BIDI_DATA,
};

pub const BIDI_REQUEST_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]BIDI_REQUEST_DATA,
};

pub const BIDI_RESPONSE_DATA = extern struct {
    dwResult: u32,
    dwReqNumber: u32,
    pSchema: PWSTR,
    data: BIDI_DATA,
};

pub const BIDI_RESPONSE_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]BIDI_RESPONSE_DATA,
};

pub const BIDI_TYPE = extern enum(i32) {
    NULL = 0,
    INT = 1,
    FLOAT = 2,
    BOOL = 3,
    STRING = 4,
    TEXT = 5,
    ENUM = 6,
    BLOB = 7,
};
pub const BIDI_NULL = BIDI_TYPE.NULL;
pub const BIDI_INT = BIDI_TYPE.INT;
pub const BIDI_FLOAT = BIDI_TYPE.FLOAT;
pub const BIDI_BOOL = BIDI_TYPE.BOOL;
pub const BIDI_STRING = BIDI_TYPE.STRING;
pub const BIDI_TEXT = BIDI_TYPE.TEXT;
pub const BIDI_ENUM = BIDI_TYPE.ENUM;
pub const BIDI_BLOB = BIDI_TYPE.BLOB;

pub const PROVIDOR_INFO_1A = extern struct {
    pName: PSTR,
    pEnvironment: PSTR,
    pDLLName: PSTR,
};

pub const PROVIDOR_INFO_1W = extern struct {
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDLLName: PWSTR,
};

pub const PROVIDOR_INFO_2A = extern struct {
    pOrder: PSTR,
};

pub const PROVIDOR_INFO_2W = extern struct {
    pOrder: PWSTR,
};

pub const PRINTER_OPTION_FLAGS = extern enum(i32) {
    NO_CACHE = 1,
    CACHE = 2,
    CLIENT_CHANGE = 4,
    NO_CLIENT_DATA = 8,
};
pub const PRINTER_OPTION_NO_CACHE = PRINTER_OPTION_FLAGS.NO_CACHE;
pub const PRINTER_OPTION_CACHE = PRINTER_OPTION_FLAGS.CACHE;
pub const PRINTER_OPTION_CLIENT_CHANGE = PRINTER_OPTION_FLAGS.CLIENT_CHANGE;
pub const PRINTER_OPTION_NO_CLIENT_DATA = PRINTER_OPTION_FLAGS.NO_CLIENT_DATA;

pub const PRINTER_OPTIONSA = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const PRINTER_OPTIONSW = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const PRINTER_CONNECTION_INFO_1A = extern struct {
    dwFlags: u32,
    pszDriverName: PSTR,
};

pub const PRINTER_CONNECTION_INFO_1W = extern struct {
    dwFlags: u32,
    pszDriverName: PWSTR,
};

pub const CORE_PRINTER_DRIVERA = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: [260]CHAR,
};

pub const CORE_PRINTER_DRIVERW = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: [260]u16,
};

pub const EPrintPropertyType = extern enum(i32) {
    String = 1,
    Int32 = 2,
    Int64 = 3,
    Byte = 4,
    Time = 5,
    DevMode = 6,
    SD = 7,
    NotificationReply = 8,
    NotificationOptions = 9,
    Buffer = 10,
};
pub const kPropertyTypeString = EPrintPropertyType.String;
pub const kPropertyTypeInt32 = EPrintPropertyType.Int32;
pub const kPropertyTypeInt64 = EPrintPropertyType.Int64;
pub const kPropertyTypeByte = EPrintPropertyType.Byte;
pub const kPropertyTypeTime = EPrintPropertyType.Time;
pub const kPropertyTypeDevMode = EPrintPropertyType.DevMode;
pub const kPropertyTypeSD = EPrintPropertyType.SD;
pub const kPropertyTypeNotificationReply = EPrintPropertyType.NotificationReply;
pub const kPropertyTypeNotificationOptions = EPrintPropertyType.NotificationOptions;
pub const kPropertyTypeBuffer = EPrintPropertyType.Buffer;

pub const EPrintXPSJobProgress = extern enum(i32) {
    AddingDocumentSequence = 0,
    DocumentSequenceAdded = 1,
    AddingFixedDocument = 2,
    FixedDocumentAdded = 3,
    AddingFixedPage = 4,
    FixedPageAdded = 5,
    ResourceAdded = 6,
    FontAdded = 7,
    ImageAdded = 8,
    XpsDocumentCommitted = 9,
};
pub const kAddingDocumentSequence = EPrintXPSJobProgress.AddingDocumentSequence;
pub const kDocumentSequenceAdded = EPrintXPSJobProgress.DocumentSequenceAdded;
pub const kAddingFixedDocument = EPrintXPSJobProgress.AddingFixedDocument;
pub const kFixedDocumentAdded = EPrintXPSJobProgress.FixedDocumentAdded;
pub const kAddingFixedPage = EPrintXPSJobProgress.AddingFixedPage;
pub const kFixedPageAdded = EPrintXPSJobProgress.FixedPageAdded;
pub const kResourceAdded = EPrintXPSJobProgress.ResourceAdded;
pub const kFontAdded = EPrintXPSJobProgress.FontAdded;
pub const kImageAdded = EPrintXPSJobProgress.ImageAdded;
pub const kXpsDocumentCommitted = EPrintXPSJobProgress.XpsDocumentCommitted;

pub const EPrintXPSJobOperation = extern enum(i32) {
    Production = 1,
    Consumption = 2,
};
pub const kJobProduction = EPrintXPSJobOperation.Production;
pub const kJobConsumption = EPrintXPSJobOperation.Consumption;

pub const PrintPropertyValue = extern struct {
    ePropertyType: EPrintPropertyType,
    value: _value_e__Union,
    const _value_e__Union = u32; // TODO: generate this nested type!
};

pub const PrintNamedProperty = extern struct {
    propertyName: PWSTR,
    propertyValue: PrintPropertyValue,
};

pub const PrintPropertiesCollection = extern struct {
    numberOfProperties: u32,
    propertiesCollection: *PrintNamedProperty,
};

pub const PRINT_EXECUTION_CONTEXT = extern enum(i32) {
    APPLICATION = 0,
    SPOOLER_SERVICE = 1,
    SPOOLER_ISOLATION_HOST = 2,
    FILTER_PIPELINE = 3,
    WOW64 = 4,
};
pub const PRINT_EXECUTION_CONTEXT_APPLICATION = PRINT_EXECUTION_CONTEXT.APPLICATION;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = PRINT_EXECUTION_CONTEXT.SPOOLER_SERVICE;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = PRINT_EXECUTION_CONTEXT.SPOOLER_ISOLATION_HOST;
pub const PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = PRINT_EXECUTION_CONTEXT.FILTER_PIPELINE;
pub const PRINT_EXECUTION_CONTEXT_WOW64 = PRINT_EXECUTION_CONTEXT.WOW64;

pub const PRINT_EXECUTION_DATA = extern struct {
    context: PRINT_EXECUTION_CONTEXT,
    clientAppPID: u32,
};

pub const DISPATCHERQUEUE_THREAD_APARTMENTTYPE = extern enum(i32) {
    NONE = 0,
    ASTA = 1,
    STA = 2,
};
pub const DQTAT_COM_NONE = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.NONE;
pub const DQTAT_COM_ASTA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.ASTA;
pub const DQTAT_COM_STA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.STA;

pub const DISPATCHERQUEUE_THREAD_TYPE = extern enum(i32) {
    DEDICATED = 1,
    CURRENT = 2,
};
pub const DQTYPE_THREAD_DEDICATED = DISPATCHERQUEUE_THREAD_TYPE.DEDICATED;
pub const DQTYPE_THREAD_CURRENT = DISPATCHERQUEUE_THREAD_TYPE.CURRENT;

pub const DispatcherQueueOptions = extern struct {
    dwSize: u32,
    threadType: DISPATCHERQUEUE_THREAD_TYPE,
    apartmentType: DISPATCHERQUEUE_THREAD_APARTMENTTYPE,
};

pub const VDS_STORAGE_IDENTIFIER_CODE_SET = extern enum(i32) {
    Reserved = 0,
    Binary = 1,
    Ascii = 2,
    Utf8 = 3,
};
pub const VDSStorageIdCodeSetReserved = VDS_STORAGE_IDENTIFIER_CODE_SET.Reserved;
pub const VDSStorageIdCodeSetBinary = VDS_STORAGE_IDENTIFIER_CODE_SET.Binary;
pub const VDSStorageIdCodeSetAscii = VDS_STORAGE_IDENTIFIER_CODE_SET.Ascii;
pub const VDSStorageIdCodeSetUtf8 = VDS_STORAGE_IDENTIFIER_CODE_SET.Utf8;

pub const VDS_STORAGE_IDENTIFIER_TYPE = extern enum(i32) {
    VendorSpecific = 0,
    VendorId = 1,
    EUI64 = 2,
    FCPHName = 3,
    PortRelative = 4,
    TargetPortGroup = 5,
    LogicalUnitGroup = 6,
    MD5LogicalUnitIdentifier = 7,
    ScsiNameString = 8,
};
pub const VDSStorageIdTypeVendorSpecific = VDS_STORAGE_IDENTIFIER_TYPE.VendorSpecific;
pub const VDSStorageIdTypeVendorId = VDS_STORAGE_IDENTIFIER_TYPE.VendorId;
pub const VDSStorageIdTypeEUI64 = VDS_STORAGE_IDENTIFIER_TYPE.EUI64;
pub const VDSStorageIdTypeFCPHName = VDS_STORAGE_IDENTIFIER_TYPE.FCPHName;
pub const VDSStorageIdTypePortRelative = VDS_STORAGE_IDENTIFIER_TYPE.PortRelative;
pub const VDSStorageIdTypeTargetPortGroup = VDS_STORAGE_IDENTIFIER_TYPE.TargetPortGroup;
pub const VDSStorageIdTypeLogicalUnitGroup = VDS_STORAGE_IDENTIFIER_TYPE.LogicalUnitGroup;
pub const VDSStorageIdTypeMD5LogicalUnitIdentifier = VDS_STORAGE_IDENTIFIER_TYPE.MD5LogicalUnitIdentifier;
pub const VDSStorageIdTypeScsiNameString = VDS_STORAGE_IDENTIFIER_TYPE.ScsiNameString;

pub const VDS_STORAGE_BUS_TYPE = extern enum(i32) {
    Unknown = 0,
    Scsi = 1,
    Atapi = 2,
    Ata = 3,
    @"1394" = 4,
    Ssa = 5,
    Fibre = 6,
    Usb = 7,
    RAID = 8,
    iScsi = 9,
    Sas = 10,
    Sata = 11,
    Sd = 12,
    Mmc = 13,
    Max = 14,
    Virtual = 14,
    FileBackedVirtual = 15,
    Spaces = 16,
    NVMe = 17,
    Scm = 18,
    Ufs = 19,
    MaxReserved = 127,
};
pub const VDSBusTypeUnknown = VDS_STORAGE_BUS_TYPE.Unknown;
pub const VDSBusTypeScsi = VDS_STORAGE_BUS_TYPE.Scsi;
pub const VDSBusTypeAtapi = VDS_STORAGE_BUS_TYPE.Atapi;
pub const VDSBusTypeAta = VDS_STORAGE_BUS_TYPE.Ata;
pub const VDSBusType1394 = VDS_STORAGE_BUS_TYPE.@"1394";
pub const VDSBusTypeSsa = VDS_STORAGE_BUS_TYPE.Ssa;
pub const VDSBusTypeFibre = VDS_STORAGE_BUS_TYPE.Fibre;
pub const VDSBusTypeUsb = VDS_STORAGE_BUS_TYPE.Usb;
pub const VDSBusTypeRAID = VDS_STORAGE_BUS_TYPE.RAID;
pub const VDSBusTypeiScsi = VDS_STORAGE_BUS_TYPE.iScsi;
pub const VDSBusTypeSas = VDS_STORAGE_BUS_TYPE.Sas;
pub const VDSBusTypeSata = VDS_STORAGE_BUS_TYPE.Sata;
pub const VDSBusTypeSd = VDS_STORAGE_BUS_TYPE.Sd;
pub const VDSBusTypeMmc = VDS_STORAGE_BUS_TYPE.Mmc;
pub const VDSBusTypeMax = VDS_STORAGE_BUS_TYPE.Max;
pub const VDSBusTypeVirtual = VDS_STORAGE_BUS_TYPE.Virtual;
pub const VDSBusTypeFileBackedVirtual = VDS_STORAGE_BUS_TYPE.FileBackedVirtual;
pub const VDSBusTypeSpaces = VDS_STORAGE_BUS_TYPE.Spaces;
pub const VDSBusTypeNVMe = VDS_STORAGE_BUS_TYPE.NVMe;
pub const VDSBusTypeScm = VDS_STORAGE_BUS_TYPE.Scm;
pub const VDSBusTypeUfs = VDS_STORAGE_BUS_TYPE.Ufs;
pub const VDSBusTypeMaxReserved = VDS_STORAGE_BUS_TYPE.MaxReserved;

pub const VDS_STORAGE_IDENTIFIER = extern struct {
    m_CodeSet: VDS_STORAGE_IDENTIFIER_CODE_SET,
    m_Type: VDS_STORAGE_IDENTIFIER_TYPE,
    m_cbIdentifier: u32,
    m_rgbIdentifier: *u8,
};

pub const VDS_STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    m_version: u32,
    m_cIdentifiers: u32,
    m_rgIdentifiers: *VDS_STORAGE_IDENTIFIER,
};

pub const VDS_INTERCONNECT_ADDRESS_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    FCFS = 1,
    FCPH = 2,
    FCPH3 = 3,
    MAC = 4,
    SCSI = 5,
};
pub const VDS_IA_UNKNOWN = VDS_INTERCONNECT_ADDRESS_TYPE.UNKNOWN;
pub const VDS_IA_FCFS = VDS_INTERCONNECT_ADDRESS_TYPE.FCFS;
pub const VDS_IA_FCPH = VDS_INTERCONNECT_ADDRESS_TYPE.FCPH;
pub const VDS_IA_FCPH3 = VDS_INTERCONNECT_ADDRESS_TYPE.FCPH3;
pub const VDS_IA_MAC = VDS_INTERCONNECT_ADDRESS_TYPE.MAC;
pub const VDS_IA_SCSI = VDS_INTERCONNECT_ADDRESS_TYPE.SCSI;

pub const VDS_INTERCONNECT = extern struct {
    m_addressType: VDS_INTERCONNECT_ADDRESS_TYPE,
    m_cbPort: u32,
    m_pbPort: *u8,
    m_cbAddress: u32,
    m_pbAddress: *u8,
};

pub const VDS_LUN_INFORMATION = extern struct {
    m_version: u32,
    m_DeviceType: u8,
    m_DeviceTypeModifier: u8,
    m_bCommandQueueing: BOOL,
    m_BusType: VDS_STORAGE_BUS_TYPE,
    m_szVendorId: *u8,
    m_szProductId: *u8,
    m_szProductRevision: *u8,
    m_szSerialNumber: *u8,
    m_diskSignature: Guid,
    m_deviceIdDescriptor: VDS_STORAGE_DEVICE_ID_DESCRIPTOR,
    m_cInterconnects: u32,
    m_rgInterconnects: *VDS_INTERCONNECT,
};

pub const VDS_OBJECT_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    PROVIDER = 1,
    PACK = 10,
    VOLUME = 11,
    VOLUME_PLEX = 12,
    DISK = 13,
    SUB_SYSTEM = 30,
    CONTROLLER = 31,
    DRIVE = 32,
    LUN = 33,
    LUN_PLEX = 34,
    PORT = 35,
    PORTAL = 36,
    TARGET = 37,
    PORTAL_GROUP = 38,
    STORAGE_POOL = 39,
    HBAPORT = 90,
    INIT_ADAPTER = 91,
    INIT_PORTAL = 92,
    ASYNC = 100,
    ENUM = 101,
    VDISK = 200,
    OPEN_VDISK = 201,
};
pub const VDS_OT_UNKNOWN = VDS_OBJECT_TYPE.UNKNOWN;
pub const VDS_OT_PROVIDER = VDS_OBJECT_TYPE.PROVIDER;
pub const VDS_OT_PACK = VDS_OBJECT_TYPE.PACK;
pub const VDS_OT_VOLUME = VDS_OBJECT_TYPE.VOLUME;
pub const VDS_OT_VOLUME_PLEX = VDS_OBJECT_TYPE.VOLUME_PLEX;
pub const VDS_OT_DISK = VDS_OBJECT_TYPE.DISK;
pub const VDS_OT_SUB_SYSTEM = VDS_OBJECT_TYPE.SUB_SYSTEM;
pub const VDS_OT_CONTROLLER = VDS_OBJECT_TYPE.CONTROLLER;
pub const VDS_OT_DRIVE = VDS_OBJECT_TYPE.DRIVE;
pub const VDS_OT_LUN = VDS_OBJECT_TYPE.LUN;
pub const VDS_OT_LUN_PLEX = VDS_OBJECT_TYPE.LUN_PLEX;
pub const VDS_OT_PORT = VDS_OBJECT_TYPE.PORT;
pub const VDS_OT_PORTAL = VDS_OBJECT_TYPE.PORTAL;
pub const VDS_OT_TARGET = VDS_OBJECT_TYPE.TARGET;
pub const VDS_OT_PORTAL_GROUP = VDS_OBJECT_TYPE.PORTAL_GROUP;
pub const VDS_OT_STORAGE_POOL = VDS_OBJECT_TYPE.STORAGE_POOL;
pub const VDS_OT_HBAPORT = VDS_OBJECT_TYPE.HBAPORT;
pub const VDS_OT_INIT_ADAPTER = VDS_OBJECT_TYPE.INIT_ADAPTER;
pub const VDS_OT_INIT_PORTAL = VDS_OBJECT_TYPE.INIT_PORTAL;
pub const VDS_OT_ASYNC = VDS_OBJECT_TYPE.ASYNC;
pub const VDS_OT_ENUM = VDS_OBJECT_TYPE.ENUM;
pub const VDS_OT_VDISK = VDS_OBJECT_TYPE.VDISK;
pub const VDS_OT_OPEN_VDISK = VDS_OBJECT_TYPE.OPEN_VDISK;

pub const VDS_PROVIDER_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    SOFTWARE = 1,
    HARDWARE = 2,
    VIRTUALDISK = 3,
    MAX = 4,
};
pub const VDS_PT_UNKNOWN = VDS_PROVIDER_TYPE.UNKNOWN;
pub const VDS_PT_SOFTWARE = VDS_PROVIDER_TYPE.SOFTWARE;
pub const VDS_PT_HARDWARE = VDS_PROVIDER_TYPE.HARDWARE;
pub const VDS_PT_VIRTUALDISK = VDS_PROVIDER_TYPE.VIRTUALDISK;
pub const VDS_PT_MAX = VDS_PROVIDER_TYPE.MAX;

pub const VDS_PROVIDER_FLAG = extern enum(i32) {
    DYNAMIC = 1,
    INTERNAL_HARDWARE_PROVIDER = 2,
    ONE_DISK_ONLY_PER_PACK = 4,
    ONE_PACK_ONLINE_ONLY = 8,
    VOLUME_SPACE_MUST_BE_CONTIGUOUS = 16,
    SUPPORT_DYNAMIC = -2147483648,
    SUPPORT_FAULT_TOLERANT = 1073741824,
    SUPPORT_DYNAMIC_1394 = 536870912,
    SUPPORT_MIRROR = 32,
    SUPPORT_RAID5 = 64,
};
pub const VDS_PF_DYNAMIC = VDS_PROVIDER_FLAG.DYNAMIC;
pub const VDS_PF_INTERNAL_HARDWARE_PROVIDER = VDS_PROVIDER_FLAG.INTERNAL_HARDWARE_PROVIDER;
pub const VDS_PF_ONE_DISK_ONLY_PER_PACK = VDS_PROVIDER_FLAG.ONE_DISK_ONLY_PER_PACK;
pub const VDS_PF_ONE_PACK_ONLINE_ONLY = VDS_PROVIDER_FLAG.ONE_PACK_ONLINE_ONLY;
pub const VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = VDS_PROVIDER_FLAG.VOLUME_SPACE_MUST_BE_CONTIGUOUS;
pub const VDS_PF_SUPPORT_DYNAMIC = VDS_PROVIDER_FLAG.SUPPORT_DYNAMIC;
pub const VDS_PF_SUPPORT_FAULT_TOLERANT = VDS_PROVIDER_FLAG.SUPPORT_FAULT_TOLERANT;
pub const VDS_PF_SUPPORT_DYNAMIC_1394 = VDS_PROVIDER_FLAG.SUPPORT_DYNAMIC_1394;
pub const VDS_PF_SUPPORT_MIRROR = VDS_PROVIDER_FLAG.SUPPORT_MIRROR;
pub const VDS_PF_SUPPORT_RAID5 = VDS_PROVIDER_FLAG.SUPPORT_RAID5;

pub const VDS_RECOVER_ACTION = extern enum(i32) {
    UNKNOWN = 0,
    REFRESH = 1,
    RESTART = 2,
};
pub const VDS_RA_UNKNOWN = VDS_RECOVER_ACTION.UNKNOWN;
pub const VDS_RA_REFRESH = VDS_RECOVER_ACTION.REFRESH;
pub const VDS_RA_RESTART = VDS_RECOVER_ACTION.RESTART;

pub const VDS_NOTIFICATION_TARGET_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    PACK = 10,
    VOLUME = 11,
    DISK = 13,
    PARTITION = 60,
    DRIVE_LETTER = 61,
    FILE_SYSTEM = 62,
    MOUNT_POINT = 63,
    SUB_SYSTEM = 30,
    CONTROLLER = 31,
    DRIVE = 32,
    LUN = 33,
    PORT = 35,
    PORTAL = 36,
    TARGET = 37,
    PORTAL_GROUP = 38,
    SERVICE = 200,
};
pub const VDS_NTT_UNKNOWN = VDS_NOTIFICATION_TARGET_TYPE.UNKNOWN;
pub const VDS_NTT_PACK = VDS_NOTIFICATION_TARGET_TYPE.PACK;
pub const VDS_NTT_VOLUME = VDS_NOTIFICATION_TARGET_TYPE.VOLUME;
pub const VDS_NTT_DISK = VDS_NOTIFICATION_TARGET_TYPE.DISK;
pub const VDS_NTT_PARTITION = VDS_NOTIFICATION_TARGET_TYPE.PARTITION;
pub const VDS_NTT_DRIVE_LETTER = VDS_NOTIFICATION_TARGET_TYPE.DRIVE_LETTER;
pub const VDS_NTT_FILE_SYSTEM = VDS_NOTIFICATION_TARGET_TYPE.FILE_SYSTEM;
pub const VDS_NTT_MOUNT_POINT = VDS_NOTIFICATION_TARGET_TYPE.MOUNT_POINT;
pub const VDS_NTT_SUB_SYSTEM = VDS_NOTIFICATION_TARGET_TYPE.SUB_SYSTEM;
pub const VDS_NTT_CONTROLLER = VDS_NOTIFICATION_TARGET_TYPE.CONTROLLER;
pub const VDS_NTT_DRIVE = VDS_NOTIFICATION_TARGET_TYPE.DRIVE;
pub const VDS_NTT_LUN = VDS_NOTIFICATION_TARGET_TYPE.LUN;
pub const VDS_NTT_PORT = VDS_NOTIFICATION_TARGET_TYPE.PORT;
pub const VDS_NTT_PORTAL = VDS_NOTIFICATION_TARGET_TYPE.PORTAL;
pub const VDS_NTT_TARGET = VDS_NOTIFICATION_TARGET_TYPE.TARGET;
pub const VDS_NTT_PORTAL_GROUP = VDS_NOTIFICATION_TARGET_TYPE.PORTAL_GROUP;
pub const VDS_NTT_SERVICE = VDS_NOTIFICATION_TARGET_TYPE.SERVICE;

pub const VDS_PACK_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_PACK,
    packId: Guid,
};

pub const VDS_DISK_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_DISK,
    diskId: Guid,
};

pub const VDS_VOLUME_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
    plexId: Guid,
    ulPercentCompleted: u32,
};

pub const VDS_PARTITION_NOTIFICATION = extern struct {
    ulEvent: u32,
    diskId: Guid,
    ullOffset: u64,
};

pub const VDS_SERVICE_NOTIFICATION = extern struct {
    ulEvent: u32,
    action: VDS_RECOVER_ACTION,
};

pub const VDS_DRIVE_LETTER_NOTIFICATION = extern struct {
    ulEvent: u32,
    wcLetter: u16,
    volumeId: Guid,
};

pub const VDS_FILE_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_FILE_SYSTEM,
    volumeId: Guid,
    dwPercentCompleted: u32,
};

pub const VDS_MOUNT_POINT_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
};

pub const VDS_SUB_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: u32,
    subSystemId: Guid,
};

pub const VDS_CONTROLLER_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_CONTROLLER,
    controllerId: Guid,
};

pub const VDS_DRIVE_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_DRIVE,
    driveId: Guid,
};

pub const VDS_LUN_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_LUN,
    LunId: Guid,
};

pub const VDS_PORT_NOTIFICATION = extern struct {
    ulEvent: VDS_NF_PORT,
    portId: Guid,
};

pub const VDS_PORTAL_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalId: Guid,
};

pub const VDS_TARGET_NOTIFICATION = extern struct {
    ulEvent: u32,
    targetId: Guid,
};

pub const VDS_PORTAL_GROUP_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalGroupId: Guid,
};

pub const VDS_NOTIFICATION = extern struct {
    objectType: VDS_NOTIFICATION_TARGET_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_ASYNC_OUTPUT_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    CREATEVOLUME = 1,
    EXTENDVOLUME = 2,
    SHRINKVOLUME = 3,
    ADDVOLUMEPLEX = 4,
    BREAKVOLUMEPLEX = 5,
    REMOVEVOLUMEPLEX = 6,
    REPAIRVOLUMEPLEX = 7,
    RECOVERPACK = 8,
    REPLACEDISK = 9,
    CREATEPARTITION = 10,
    CLEAN = 11,
    CREATELUN = 50,
    ADDLUNPLEX = 52,
    REMOVELUNPLEX = 53,
    EXTENDLUN = 54,
    SHRINKLUN = 55,
    RECOVERLUN = 56,
    LOGINTOTARGET = 60,
    LOGOUTFROMTARGET = 61,
    CREATETARGET = 62,
    CREATEPORTALGROUP = 63,
    DELETETARGET = 64,
    ADDPORTAL = 65,
    REMOVEPORTAL = 66,
    DELETEPORTALGROUP = 67,
    FORMAT = 101,
    CREATE_VDISK = 200,
    ATTACH_VDISK = 201,
    COMPACT_VDISK = 202,
    MERGE_VDISK = 203,
    EXPAND_VDISK = 204,
};
pub const VDS_ASYNCOUT_UNKNOWN = VDS_ASYNC_OUTPUT_TYPE.UNKNOWN;
pub const VDS_ASYNCOUT_CREATEVOLUME = VDS_ASYNC_OUTPUT_TYPE.CREATEVOLUME;
pub const VDS_ASYNCOUT_EXTENDVOLUME = VDS_ASYNC_OUTPUT_TYPE.EXTENDVOLUME;
pub const VDS_ASYNCOUT_SHRINKVOLUME = VDS_ASYNC_OUTPUT_TYPE.SHRINKVOLUME;
pub const VDS_ASYNCOUT_ADDVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.ADDVOLUMEPLEX;
pub const VDS_ASYNCOUT_BREAKVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.BREAKVOLUMEPLEX;
pub const VDS_ASYNCOUT_REMOVEVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.REMOVEVOLUMEPLEX;
pub const VDS_ASYNCOUT_REPAIRVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.REPAIRVOLUMEPLEX;
pub const VDS_ASYNCOUT_RECOVERPACK = VDS_ASYNC_OUTPUT_TYPE.RECOVERPACK;
pub const VDS_ASYNCOUT_REPLACEDISK = VDS_ASYNC_OUTPUT_TYPE.REPLACEDISK;
pub const VDS_ASYNCOUT_CREATEPARTITION = VDS_ASYNC_OUTPUT_TYPE.CREATEPARTITION;
pub const VDS_ASYNCOUT_CLEAN = VDS_ASYNC_OUTPUT_TYPE.CLEAN;
pub const VDS_ASYNCOUT_CREATELUN = VDS_ASYNC_OUTPUT_TYPE.CREATELUN;
pub const VDS_ASYNCOUT_ADDLUNPLEX = VDS_ASYNC_OUTPUT_TYPE.ADDLUNPLEX;
pub const VDS_ASYNCOUT_REMOVELUNPLEX = VDS_ASYNC_OUTPUT_TYPE.REMOVELUNPLEX;
pub const VDS_ASYNCOUT_EXTENDLUN = VDS_ASYNC_OUTPUT_TYPE.EXTENDLUN;
pub const VDS_ASYNCOUT_SHRINKLUN = VDS_ASYNC_OUTPUT_TYPE.SHRINKLUN;
pub const VDS_ASYNCOUT_RECOVERLUN = VDS_ASYNC_OUTPUT_TYPE.RECOVERLUN;
pub const VDS_ASYNCOUT_LOGINTOTARGET = VDS_ASYNC_OUTPUT_TYPE.LOGINTOTARGET;
pub const VDS_ASYNCOUT_LOGOUTFROMTARGET = VDS_ASYNC_OUTPUT_TYPE.LOGOUTFROMTARGET;
pub const VDS_ASYNCOUT_CREATETARGET = VDS_ASYNC_OUTPUT_TYPE.CREATETARGET;
pub const VDS_ASYNCOUT_CREATEPORTALGROUP = VDS_ASYNC_OUTPUT_TYPE.CREATEPORTALGROUP;
pub const VDS_ASYNCOUT_DELETETARGET = VDS_ASYNC_OUTPUT_TYPE.DELETETARGET;
pub const VDS_ASYNCOUT_ADDPORTAL = VDS_ASYNC_OUTPUT_TYPE.ADDPORTAL;
pub const VDS_ASYNCOUT_REMOVEPORTAL = VDS_ASYNC_OUTPUT_TYPE.REMOVEPORTAL;
pub const VDS_ASYNCOUT_DELETEPORTALGROUP = VDS_ASYNC_OUTPUT_TYPE.DELETEPORTALGROUP;
pub const VDS_ASYNCOUT_FORMAT = VDS_ASYNC_OUTPUT_TYPE.FORMAT;
pub const VDS_ASYNCOUT_CREATE_VDISK = VDS_ASYNC_OUTPUT_TYPE.CREATE_VDISK;
pub const VDS_ASYNCOUT_ATTACH_VDISK = VDS_ASYNC_OUTPUT_TYPE.ATTACH_VDISK;
pub const VDS_ASYNCOUT_COMPACT_VDISK = VDS_ASYNC_OUTPUT_TYPE.COMPACT_VDISK;
pub const VDS_ASYNCOUT_MERGE_VDISK = VDS_ASYNC_OUTPUT_TYPE.MERGE_VDISK;
pub const VDS_ASYNCOUT_EXPAND_VDISK = VDS_ASYNC_OUTPUT_TYPE.EXPAND_VDISK;

pub const VDS_ASYNC_OUTPUT = extern struct {
    type: VDS_ASYNC_OUTPUT_TYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_IPADDRESS_TYPE = extern enum(i32) {
    TEXT = 0,
    IPV4 = 1,
    IPV6 = 2,
    EMPTY = 3,
};
pub const VDS_IPT_TEXT = VDS_IPADDRESS_TYPE.TEXT;
pub const VDS_IPT_IPV4 = VDS_IPADDRESS_TYPE.IPV4;
pub const VDS_IPT_IPV6 = VDS_IPADDRESS_TYPE.IPV6;
pub const VDS_IPT_EMPTY = VDS_IPADDRESS_TYPE.EMPTY;

pub const VDS_HEALTH = extern enum(i32) {
    UNKNOWN = 0,
    HEALTHY = 1,
    REBUILDING = 2,
    STALE = 3,
    FAILING = 4,
    FAILING_REDUNDANCY = 5,
    FAILED_REDUNDANCY = 6,
    FAILED_REDUNDANCY_FAILING = 7,
    FAILED = 8,
    REPLACED = 9,
    PENDING_FAILURE = 10,
    DEGRADED = 11,
};
pub const VDS_H_UNKNOWN = VDS_HEALTH.UNKNOWN;
pub const VDS_H_HEALTHY = VDS_HEALTH.HEALTHY;
pub const VDS_H_REBUILDING = VDS_HEALTH.REBUILDING;
pub const VDS_H_STALE = VDS_HEALTH.STALE;
pub const VDS_H_FAILING = VDS_HEALTH.FAILING;
pub const VDS_H_FAILING_REDUNDANCY = VDS_HEALTH.FAILING_REDUNDANCY;
pub const VDS_H_FAILED_REDUNDANCY = VDS_HEALTH.FAILED_REDUNDANCY;
pub const VDS_H_FAILED_REDUNDANCY_FAILING = VDS_HEALTH.FAILED_REDUNDANCY_FAILING;
pub const VDS_H_FAILED = VDS_HEALTH.FAILED;
pub const VDS_H_REPLACED = VDS_HEALTH.REPLACED;
pub const VDS_H_PENDING_FAILURE = VDS_HEALTH.PENDING_FAILURE;
pub const VDS_H_DEGRADED = VDS_HEALTH.DEGRADED;

pub const VDS_TRANSITION_STATE = extern enum(i32) {
    UNKNOWN = 0,
    STABLE = 1,
    EXTENDING = 2,
    SHRINKING = 3,
    RECONFIGING = 4,
    RESTRIPING = 5,
};
pub const VDS_TS_UNKNOWN = VDS_TRANSITION_STATE.UNKNOWN;
pub const VDS_TS_STABLE = VDS_TRANSITION_STATE.STABLE;
pub const VDS_TS_EXTENDING = VDS_TRANSITION_STATE.EXTENDING;
pub const VDS_TS_SHRINKING = VDS_TRANSITION_STATE.SHRINKING;
pub const VDS_TS_RECONFIGING = VDS_TRANSITION_STATE.RECONFIGING;
pub const VDS_TS_RESTRIPING = VDS_TRANSITION_STATE.RESTRIPING;

pub const VDS_FILE_SYSTEM_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    RAW = 1,
    FAT = 2,
    FAT32 = 3,
    NTFS = 4,
    CDFS = 5,
    UDF = 6,
    EXFAT = 7,
    CSVFS = 8,
    REFS = 9,
};
pub const VDS_FST_UNKNOWN = VDS_FILE_SYSTEM_TYPE.UNKNOWN;
pub const VDS_FST_RAW = VDS_FILE_SYSTEM_TYPE.RAW;
pub const VDS_FST_FAT = VDS_FILE_SYSTEM_TYPE.FAT;
pub const VDS_FST_FAT32 = VDS_FILE_SYSTEM_TYPE.FAT32;
pub const VDS_FST_NTFS = VDS_FILE_SYSTEM_TYPE.NTFS;
pub const VDS_FST_CDFS = VDS_FILE_SYSTEM_TYPE.CDFS;
pub const VDS_FST_UDF = VDS_FILE_SYSTEM_TYPE.UDF;
pub const VDS_FST_EXFAT = VDS_FILE_SYSTEM_TYPE.EXFAT;
pub const VDS_FST_CSVFS = VDS_FILE_SYSTEM_TYPE.CSVFS;
pub const VDS_FST_REFS = VDS_FILE_SYSTEM_TYPE.REFS;

pub const VDS_HBAPORT_TYPE = extern enum(i32) {
    UNKNOWN = 1,
    OTHER = 2,
    NOTPRESENT = 3,
    NPORT = 5,
    NLPORT = 6,
    FLPORT = 7,
    FPORT = 8,
    EPORT = 9,
    GPORT = 10,
    LPORT = 20,
    PTP = 21,
};
pub const VDS_HPT_UNKNOWN = VDS_HBAPORT_TYPE.UNKNOWN;
pub const VDS_HPT_OTHER = VDS_HBAPORT_TYPE.OTHER;
pub const VDS_HPT_NOTPRESENT = VDS_HBAPORT_TYPE.NOTPRESENT;
pub const VDS_HPT_NPORT = VDS_HBAPORT_TYPE.NPORT;
pub const VDS_HPT_NLPORT = VDS_HBAPORT_TYPE.NLPORT;
pub const VDS_HPT_FLPORT = VDS_HBAPORT_TYPE.FLPORT;
pub const VDS_HPT_FPORT = VDS_HBAPORT_TYPE.FPORT;
pub const VDS_HPT_EPORT = VDS_HBAPORT_TYPE.EPORT;
pub const VDS_HPT_GPORT = VDS_HBAPORT_TYPE.GPORT;
pub const VDS_HPT_LPORT = VDS_HBAPORT_TYPE.LPORT;
pub const VDS_HPT_PTP = VDS_HBAPORT_TYPE.PTP;

pub const VDS_HBAPORT_STATUS = extern enum(i32) {
    UNKNOWN = 1,
    ONLINE = 2,
    OFFLINE = 3,
    BYPASSED = 4,
    DIAGNOSTICS = 5,
    LINKDOWN = 6,
    ERROR = 7,
    LOOPBACK = 8,
};
pub const VDS_HPS_UNKNOWN = VDS_HBAPORT_STATUS.UNKNOWN;
pub const VDS_HPS_ONLINE = VDS_HBAPORT_STATUS.ONLINE;
pub const VDS_HPS_OFFLINE = VDS_HBAPORT_STATUS.OFFLINE;
pub const VDS_HPS_BYPASSED = VDS_HBAPORT_STATUS.BYPASSED;
pub const VDS_HPS_DIAGNOSTICS = VDS_HBAPORT_STATUS.DIAGNOSTICS;
pub const VDS_HPS_LINKDOWN = VDS_HBAPORT_STATUS.LINKDOWN;
pub const VDS_HPS_ERROR = VDS_HBAPORT_STATUS.ERROR;
pub const VDS_HPS_LOOPBACK = VDS_HBAPORT_STATUS.LOOPBACK;

pub const VDS_HBAPORT_SPEED_FLAG = extern enum(i32) {
    UNKNOWN = 0,
    @"1GBIT" = 1,
    @"2GBIT" = 2,
    @"10GBIT" = 4,
    @"4GBIT" = 8,
    NOT_NEGOTIATED = 32768,
};
pub const VDS_HSF_UNKNOWN = VDS_HBAPORT_SPEED_FLAG.UNKNOWN;
pub const VDS_HSF_1GBIT = VDS_HBAPORT_SPEED_FLAG.@"1GBIT";
pub const VDS_HSF_2GBIT = VDS_HBAPORT_SPEED_FLAG.@"2GBIT";
pub const VDS_HSF_10GBIT = VDS_HBAPORT_SPEED_FLAG.@"10GBIT";
pub const VDS_HSF_4GBIT = VDS_HBAPORT_SPEED_FLAG.@"4GBIT";
pub const VDS_HSF_NOT_NEGOTIATED = VDS_HBAPORT_SPEED_FLAG.NOT_NEGOTIATED;

pub const VDS_PATH_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    FAILED = 5,
    STANDBY = 7,
};
pub const VDS_MPS_UNKNOWN = VDS_PATH_STATUS.UNKNOWN;
pub const VDS_MPS_ONLINE = VDS_PATH_STATUS.ONLINE;
pub const VDS_MPS_FAILED = VDS_PATH_STATUS.FAILED;
pub const VDS_MPS_STANDBY = VDS_PATH_STATUS.STANDBY;

pub const VDS_LOADBALANCE_POLICY_ENUM = extern enum(i32) {
    UNKNOWN = 0,
    FAILOVER = 1,
    ROUND_ROBIN = 2,
    ROUND_ROBIN_WITH_SUBSET = 3,
    DYN_LEAST_QUEUE_DEPTH = 4,
    WEIGHTED_PATHS = 5,
    LEAST_BLOCKS = 6,
    VENDOR_SPECIFIC = 7,
};
pub const VDS_LBP_UNKNOWN = VDS_LOADBALANCE_POLICY_ENUM.UNKNOWN;
pub const VDS_LBP_FAILOVER = VDS_LOADBALANCE_POLICY_ENUM.FAILOVER;
pub const VDS_LBP_ROUND_ROBIN = VDS_LOADBALANCE_POLICY_ENUM.ROUND_ROBIN;
pub const VDS_LBP_ROUND_ROBIN_WITH_SUBSET = VDS_LOADBALANCE_POLICY_ENUM.ROUND_ROBIN_WITH_SUBSET;
pub const VDS_LBP_DYN_LEAST_QUEUE_DEPTH = VDS_LOADBALANCE_POLICY_ENUM.DYN_LEAST_QUEUE_DEPTH;
pub const VDS_LBP_WEIGHTED_PATHS = VDS_LOADBALANCE_POLICY_ENUM.WEIGHTED_PATHS;
pub const VDS_LBP_LEAST_BLOCKS = VDS_LOADBALANCE_POLICY_ENUM.LEAST_BLOCKS;
pub const VDS_LBP_VENDOR_SPECIFIC = VDS_LOADBALANCE_POLICY_ENUM.VENDOR_SPECIFIC;

pub const VDS_PROVIDER_LBSUPPORT_FLAG = extern enum(i32) {
    FAILOVER = 1,
    ROUND_ROBIN = 2,
    ROUND_ROBIN_WITH_SUBSET = 4,
    DYN_LEAST_QUEUE_DEPTH = 8,
    WEIGHTED_PATHS = 16,
    LEAST_BLOCKS = 32,
    VENDOR_SPECIFIC = 64,
};
pub const VDS_LBF_FAILOVER = VDS_PROVIDER_LBSUPPORT_FLAG.FAILOVER;
pub const VDS_LBF_ROUND_ROBIN = VDS_PROVIDER_LBSUPPORT_FLAG.ROUND_ROBIN;
pub const VDS_LBF_ROUND_ROBIN_WITH_SUBSET = VDS_PROVIDER_LBSUPPORT_FLAG.ROUND_ROBIN_WITH_SUBSET;
pub const VDS_LBF_DYN_LEAST_QUEUE_DEPTH = VDS_PROVIDER_LBSUPPORT_FLAG.DYN_LEAST_QUEUE_DEPTH;
pub const VDS_LBF_WEIGHTED_PATHS = VDS_PROVIDER_LBSUPPORT_FLAG.WEIGHTED_PATHS;
pub const VDS_LBF_LEAST_BLOCKS = VDS_PROVIDER_LBSUPPORT_FLAG.LEAST_BLOCKS;
pub const VDS_LBF_VENDOR_SPECIFIC = VDS_PROVIDER_LBSUPPORT_FLAG.VENDOR_SPECIFIC;

pub const VDS_VERSION_SUPPORT_FLAG = extern enum(i32) {
    @"1_0" = 1,
    @"1_1" = 2,
    @"2_0" = 4,
    @"2_1" = 8,
    @"3_0" = 16,
};
pub const VDS_VSF_1_0 = VDS_VERSION_SUPPORT_FLAG.@"1_0";
pub const VDS_VSF_1_1 = VDS_VERSION_SUPPORT_FLAG.@"1_1";
pub const VDS_VSF_2_0 = VDS_VERSION_SUPPORT_FLAG.@"2_0";
pub const VDS_VSF_2_1 = VDS_VERSION_SUPPORT_FLAG.@"2_1";
pub const VDS_VSF_3_0 = VDS_VERSION_SUPPORT_FLAG.@"3_0";

pub const VDS_HWPROVIDER_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    PCI_RAID = 1,
    FIBRE_CHANNEL = 2,
    ISCSI = 3,
    SAS = 4,
    HYBRID = 5,
};
pub const VDS_HWT_UNKNOWN = VDS_HWPROVIDER_TYPE.UNKNOWN;
pub const VDS_HWT_PCI_RAID = VDS_HWPROVIDER_TYPE.PCI_RAID;
pub const VDS_HWT_FIBRE_CHANNEL = VDS_HWPROVIDER_TYPE.FIBRE_CHANNEL;
pub const VDS_HWT_ISCSI = VDS_HWPROVIDER_TYPE.ISCSI;
pub const VDS_HWT_SAS = VDS_HWPROVIDER_TYPE.SAS;
pub const VDS_HWT_HYBRID = VDS_HWPROVIDER_TYPE.HYBRID;

pub const VDS_ISCSI_LOGIN_TYPE = extern enum(i32) {
    MANUAL = 0,
    PERSISTENT = 1,
    BOOT = 2,
};
pub const VDS_ILT_MANUAL = VDS_ISCSI_LOGIN_TYPE.MANUAL;
pub const VDS_ILT_PERSISTENT = VDS_ISCSI_LOGIN_TYPE.PERSISTENT;
pub const VDS_ILT_BOOT = VDS_ISCSI_LOGIN_TYPE.BOOT;

pub const VDS_ISCSI_AUTH_TYPE = extern enum(i32) {
    NONE = 0,
    CHAP = 1,
    MUTUAL_CHAP = 2,
};
pub const VDS_IAT_NONE = VDS_ISCSI_AUTH_TYPE.NONE;
pub const VDS_IAT_CHAP = VDS_ISCSI_AUTH_TYPE.CHAP;
pub const VDS_IAT_MUTUAL_CHAP = VDS_ISCSI_AUTH_TYPE.MUTUAL_CHAP;

pub const VDS_ISCSI_IPSEC_FLAG = extern enum(i32) {
    VALID = 1,
    IKE = 2,
    MAIN_MODE = 4,
    AGGRESSIVE_MODE = 8,
    PFS_ENABLE = 16,
    TRANSPORT_MODE_PREFERRED = 32,
    TUNNEL_MODE_PREFERRED = 64,
};
pub const VDS_IIF_VALID = VDS_ISCSI_IPSEC_FLAG.VALID;
pub const VDS_IIF_IKE = VDS_ISCSI_IPSEC_FLAG.IKE;
pub const VDS_IIF_MAIN_MODE = VDS_ISCSI_IPSEC_FLAG.MAIN_MODE;
pub const VDS_IIF_AGGRESSIVE_MODE = VDS_ISCSI_IPSEC_FLAG.AGGRESSIVE_MODE;
pub const VDS_IIF_PFS_ENABLE = VDS_ISCSI_IPSEC_FLAG.PFS_ENABLE;
pub const VDS_IIF_TRANSPORT_MODE_PREFERRED = VDS_ISCSI_IPSEC_FLAG.TRANSPORT_MODE_PREFERRED;
pub const VDS_IIF_TUNNEL_MODE_PREFERRED = VDS_ISCSI_IPSEC_FLAG.TUNNEL_MODE_PREFERRED;

pub const VDS_ISCSI_LOGIN_FLAG = extern enum(i32) {
    REQUIRE_IPSEC = 1,
    MULTIPATH_ENABLED = 2,
};
pub const VDS_ILF_REQUIRE_IPSEC = VDS_ISCSI_LOGIN_FLAG.REQUIRE_IPSEC;
pub const VDS_ILF_MULTIPATH_ENABLED = VDS_ISCSI_LOGIN_FLAG.MULTIPATH_ENABLED;

pub const VDS_PATH_ID = extern struct {
    ullSourceId: u64,
    ullPathId: u64,
};

pub const VDS_WWN = extern struct {
    rguchWwn: [8]u8,
};

pub const VDS_IPADDRESS = extern struct {
    type: VDS_IPADDRESS_TYPE,
    ipv4Address: u32,
    ipv6Address: [16]u8,
    ulIpv6FlowInfo: u32,
    ulIpv6ScopeId: u32,
    wszTextAddress: [257]u16,
    ulPort: u32,
};

pub const VDS_ISCSI_IPSEC_KEY = extern struct {
    pKey: *u8,
    ulKeySize: u32,
};

pub const VDS_ISCSI_SHARED_SECRET = extern struct {
    pSharedSecret: *u8,
    ulSharedSecretSize: u32,
};

pub const VDS_HBAPORT_PROP = extern struct {
    id: Guid,
    wwnNode: VDS_WWN,
    wwnPort: VDS_WWN,
    type: VDS_HBAPORT_TYPE,
    status: VDS_HBAPORT_STATUS,
    ulPortSpeed: u32,
    ulSupportedPortSpeed: u32,
};

pub const VDS_ISCSI_INITIATOR_ADAPTER_PROP = extern struct {
    id: Guid,
    pwszName: PWSTR,
};

pub const VDS_ISCSI_INITIATOR_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    ulPortIndex: u32,
};

pub const VDS_PROVIDER_PROP = extern struct {
    id: Guid,
    pwszName: PWSTR,
    guidVersionId: Guid,
    pwszVersion: PWSTR,
    type: VDS_PROVIDER_TYPE,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    sRebuildPriority: i16,
};

pub const VDS_PATH_INFO = extern struct {
    pathId: VDS_PATH_ID,
    type: VDS_HWPROVIDER_TYPE,
    status: VDS_PATH_STATUS,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_PATH_POLICY = extern struct {
    pathId: VDS_PATH_ID,
    bPrimaryPath: BOOL,
    ulWeight: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumVdsObject_Value = @import("../zig.zig").Guid.initString("118610b7-8d94-4030-b5b8-500889788e4e");
pub const IID_IEnumVdsObject = &IID_IEnumVdsObject_Value;
pub const IEnumVdsObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumVdsObject,
            celt: u32,
            ppObjectArray: [*]*IUnknown,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumVdsObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumVdsObject,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Next(self: *const T, celt: u32, ppObjectArray: [*]*IUnknown, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Next(@ptrCast(*const IEnumVdsObject, self), celt, ppObjectArray, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Skip(@ptrCast(*const IEnumVdsObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Reset(@ptrCast(*const IEnumVdsObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Clone(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Clone(@ptrCast(*const IEnumVdsObject, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsAsync_Value = @import("../zig.zig").Guid.initString("d5d23b6d-5a55-4492-9889-397a3c2d2dbc");
pub const IID_IVdsAsync = &IID_IVdsAsync_Value;
pub const IVdsAsync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Wait: fn(
            self: *const IVdsAsync,
            pHrResult: *HRESULT,
            pAsyncOut: *VDS_ASYNC_OUTPUT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatus: fn(
            self: *const IVdsAsync,
            pHrResult: *HRESULT,
            pulPercentCompleted: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).Cancel(@ptrCast(*const IVdsAsync, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_Wait(self: *const T, pHrResult: *HRESULT, pAsyncOut: *VDS_ASYNC_OUTPUT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).Wait(@ptrCast(*const IVdsAsync, self), pHrResult, pAsyncOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_QueryStatus(self: *const T, pHrResult: *HRESULT, pulPercentCompleted: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).QueryStatus(@ptrCast(*const IVdsAsync, self), pHrResult, pulPercentCompleted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsAdviseSink_Value = @import("../zig.zig").Guid.initString("8326cd1d-cf59-4936-b786-5efc08798e25");
pub const IID_IVdsAdviseSink = &IID_IVdsAdviseSink_Value;
pub const IVdsAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: fn(
            self: *const IVdsAdviseSink,
            lNumberOfNotifications: i32,
            pNotificationArray: [*]VDS_NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdviseSink_OnNotify(self: *const T, lNumberOfNotifications: i32, pNotificationArray: [*]VDS_NOTIFICATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdviseSink.VTable, self.vtable).OnNotify(@ptrCast(*const IVdsAdviseSink, self), lNumberOfNotifications, pNotificationArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsProvider_Value = @import("../zig.zig").Guid.initString("10c5e575-7984-4e81-a56b-431f5f92ae42");
pub const IID_IVdsProvider = &IID_IVdsProvider_Value;
pub const IVdsProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsProvider,
            pProviderProp: *VDS_PROVIDER_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProvider_GetProperties(self: *const T, pProviderProp: *VDS_PROVIDER_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProvider.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsProvider, self), pProviderProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsProviderSupport_Value = @import("../zig.zig").Guid.initString("1732be13-e8f9-4a03-bfbc-5f616aa66ce1");
pub const IID_IVdsProviderSupport = &IID_IVdsProviderSupport_Value;
pub const IVdsProviderSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVersionSupport: fn(
            self: *const IVdsProviderSupport,
            ulVersionSupport: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderSupport_GetVersionSupport(self: *const T, ulVersionSupport: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderSupport.VTable, self.vtable).GetVersionSupport(@ptrCast(*const IVdsProviderSupport, self), ulVersionSupport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsProviderPrivate_Value = @import("../zig.zig").Guid.initString("11f3cd41-b7e8-48ff-9472-9dff018aa292");
pub const IID_IVdsProviderPrivate = &IID_IVdsProviderPrivate_Value;
pub const IVdsProviderPrivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObject: fn(
            self: *const IVdsProviderPrivate,
            ObjectId: Guid,
            type: VDS_OBJECT_TYPE,
            ppObjectUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLoad: fn(
            self: *const IVdsProviderPrivate,
            pwszMachineName: PWSTR,
            pCallbackObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUnload: fn(
            self: *const IVdsProviderPrivate,
            bForceUnload: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_GetObject(self: *const T, ObjectId: Guid, type: VDS_OBJECT_TYPE, ppObjectUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).GetObject(@ptrCast(*const IVdsProviderPrivate, self), ObjectId, type, ppObjectUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_OnLoad(self: *const T, pwszMachineName: PWSTR, pCallbackObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).OnLoad(@ptrCast(*const IVdsProviderPrivate, self), pwszMachineName, pCallbackObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_OnUnload(self: *const T, bForceUnload: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).OnUnload(@ptrCast(*const IVdsProviderPrivate, self), bForceUnload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VDS_SUB_SYSTEM_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
    PARTIALLY_MANAGED = 9,
};
pub const VDS_SSS_UNKNOWN = VDS_SUB_SYSTEM_STATUS.UNKNOWN;
pub const VDS_SSS_ONLINE = VDS_SUB_SYSTEM_STATUS.ONLINE;
pub const VDS_SSS_NOT_READY = VDS_SUB_SYSTEM_STATUS.NOT_READY;
pub const VDS_SSS_OFFLINE = VDS_SUB_SYSTEM_STATUS.OFFLINE;
pub const VDS_SSS_FAILED = VDS_SUB_SYSTEM_STATUS.FAILED;
pub const VDS_SSS_PARTIALLY_MANAGED = VDS_SUB_SYSTEM_STATUS.PARTIALLY_MANAGED;

pub const VDS_SUB_SYSTEM_FLAG = extern enum(i32) {
    LUN_MASKING_CAPABLE = 1,
    LUN_PLEXING_CAPABLE = 2,
    LUN_REMAPPING_CAPABLE = 4,
    DRIVE_EXTENT_CAPABLE = 8,
    HARDWARE_CHECKSUM_CAPABLE = 16,
    RADIUS_CAPABLE = 32,
    READ_BACK_VERIFY_CAPABLE = 64,
    WRITE_THROUGH_CACHING_CAPABLE = 128,
    SUPPORTS_FAULT_TOLERANT_LUNS = 512,
    SUPPORTS_NON_FAULT_TOLERANT_LUNS = 1024,
    SUPPORTS_SIMPLE_LUNS = 2048,
    SUPPORTS_SPAN_LUNS = 4096,
    SUPPORTS_STRIPE_LUNS = 8192,
    SUPPORTS_MIRROR_LUNS = 16384,
    SUPPORTS_PARITY_LUNS = 32768,
    SUPPORTS_AUTH_CHAP = 65536,
    SUPPORTS_AUTH_MUTUAL_CHAP = 131072,
    SUPPORTS_SIMPLE_TARGET_CONFIG = 262144,
    SUPPORTS_LUN_NUMBER = 524288,
    SUPPORTS_MIRRORED_CACHE = 1048576,
    READ_CACHING_CAPABLE = 2097152,
    WRITE_CACHING_CAPABLE = 4194304,
    MEDIA_SCAN_CAPABLE = 8388608,
    CONSISTENCY_CHECK_CAPABLE = 16777216,
};
pub const VDS_SF_LUN_MASKING_CAPABLE = VDS_SUB_SYSTEM_FLAG.LUN_MASKING_CAPABLE;
pub const VDS_SF_LUN_PLEXING_CAPABLE = VDS_SUB_SYSTEM_FLAG.LUN_PLEXING_CAPABLE;
pub const VDS_SF_LUN_REMAPPING_CAPABLE = VDS_SUB_SYSTEM_FLAG.LUN_REMAPPING_CAPABLE;
pub const VDS_SF_DRIVE_EXTENT_CAPABLE = VDS_SUB_SYSTEM_FLAG.DRIVE_EXTENT_CAPABLE;
pub const VDS_SF_HARDWARE_CHECKSUM_CAPABLE = VDS_SUB_SYSTEM_FLAG.HARDWARE_CHECKSUM_CAPABLE;
pub const VDS_SF_RADIUS_CAPABLE = VDS_SUB_SYSTEM_FLAG.RADIUS_CAPABLE;
pub const VDS_SF_READ_BACK_VERIFY_CAPABLE = VDS_SUB_SYSTEM_FLAG.READ_BACK_VERIFY_CAPABLE;
pub const VDS_SF_WRITE_THROUGH_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.WRITE_THROUGH_CACHING_CAPABLE;
pub const VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_FAULT_TOLERANT_LUNS;
pub const VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_NON_FAULT_TOLERANT_LUNS;
pub const VDS_SF_SUPPORTS_SIMPLE_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_SIMPLE_LUNS;
pub const VDS_SF_SUPPORTS_SPAN_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_SPAN_LUNS;
pub const VDS_SF_SUPPORTS_STRIPE_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_STRIPE_LUNS;
pub const VDS_SF_SUPPORTS_MIRROR_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_MIRROR_LUNS;
pub const VDS_SF_SUPPORTS_PARITY_LUNS = VDS_SUB_SYSTEM_FLAG.SUPPORTS_PARITY_LUNS;
pub const VDS_SF_SUPPORTS_AUTH_CHAP = VDS_SUB_SYSTEM_FLAG.SUPPORTS_AUTH_CHAP;
pub const VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP = VDS_SUB_SYSTEM_FLAG.SUPPORTS_AUTH_MUTUAL_CHAP;
pub const VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG = VDS_SUB_SYSTEM_FLAG.SUPPORTS_SIMPLE_TARGET_CONFIG;
pub const VDS_SF_SUPPORTS_LUN_NUMBER = VDS_SUB_SYSTEM_FLAG.SUPPORTS_LUN_NUMBER;
pub const VDS_SF_SUPPORTS_MIRRORED_CACHE = VDS_SUB_SYSTEM_FLAG.SUPPORTS_MIRRORED_CACHE;
pub const VDS_SF_READ_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.READ_CACHING_CAPABLE;
pub const VDS_SF_WRITE_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.WRITE_CACHING_CAPABLE;
pub const VDS_SF_MEDIA_SCAN_CAPABLE = VDS_SUB_SYSTEM_FLAG.MEDIA_SCAN_CAPABLE;
pub const VDS_SF_CONSISTENCY_CHECK_CAPABLE = VDS_SUB_SYSTEM_FLAG.CONSISTENCY_CHECK_CAPABLE;

pub const VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG = extern enum(i32) {
    @"2_LUNS" = 1,
    @"3_LUNS" = 2,
    @"4_LUNS" = 4,
    @"5_LUNS" = 8,
    @"6_LUNS" = 16,
    @"01_LUNS" = 32,
    @"03_LUNS" = 64,
    @"05_LUNS" = 128,
    @"10_LUNS" = 256,
    @"15_LUNS" = 512,
    @"30_LUNS" = 1024,
    @"50_LUNS" = 2048,
    @"51_LUNS" = 4096,
    @"53_LUNS" = 8192,
    @"60_LUNS" = 16384,
    @"61_LUNS" = 32768,
};
pub const VDS_SF_SUPPORTS_RAID2_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"2_LUNS";
pub const VDS_SF_SUPPORTS_RAID3_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"3_LUNS";
pub const VDS_SF_SUPPORTS_RAID4_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"4_LUNS";
pub const VDS_SF_SUPPORTS_RAID5_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"5_LUNS";
pub const VDS_SF_SUPPORTS_RAID6_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"6_LUNS";
pub const VDS_SF_SUPPORTS_RAID01_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"01_LUNS";
pub const VDS_SF_SUPPORTS_RAID03_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"03_LUNS";
pub const VDS_SF_SUPPORTS_RAID05_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"05_LUNS";
pub const VDS_SF_SUPPORTS_RAID10_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"10_LUNS";
pub const VDS_SF_SUPPORTS_RAID15_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"15_LUNS";
pub const VDS_SF_SUPPORTS_RAID30_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"30_LUNS";
pub const VDS_SF_SUPPORTS_RAID50_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"50_LUNS";
pub const VDS_SF_SUPPORTS_RAID51_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"51_LUNS";
pub const VDS_SF_SUPPORTS_RAID53_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"53_LUNS";
pub const VDS_SF_SUPPORTS_RAID60_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"60_LUNS";
pub const VDS_SF_SUPPORTS_RAID61_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.@"61_LUNS";

pub const VDS_INTERCONNECT_FLAG = extern enum(i32) {
    PCI_RAID = 1,
    FIBRE_CHANNEL = 2,
    ISCSI = 4,
    SAS = 8,
};
pub const VDS_ITF_PCI_RAID = VDS_INTERCONNECT_FLAG.PCI_RAID;
pub const VDS_ITF_FIBRE_CHANNEL = VDS_INTERCONNECT_FLAG.FIBRE_CHANNEL;
pub const VDS_ITF_ISCSI = VDS_INTERCONNECT_FLAG.ISCSI;
pub const VDS_ITF_SAS = VDS_INTERCONNECT_FLAG.SAS;

pub const VDS_CONTROLLER_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
    REMOVED = 8,
};
pub const VDS_CS_UNKNOWN = VDS_CONTROLLER_STATUS.UNKNOWN;
pub const VDS_CS_ONLINE = VDS_CONTROLLER_STATUS.ONLINE;
pub const VDS_CS_NOT_READY = VDS_CONTROLLER_STATUS.NOT_READY;
pub const VDS_CS_OFFLINE = VDS_CONTROLLER_STATUS.OFFLINE;
pub const VDS_CS_FAILED = VDS_CONTROLLER_STATUS.FAILED;
pub const VDS_CS_REMOVED = VDS_CONTROLLER_STATUS.REMOVED;

pub const VDS_PORT_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
    REMOVED = 8,
};
pub const VDS_PRS_UNKNOWN = VDS_PORT_STATUS.UNKNOWN;
pub const VDS_PRS_ONLINE = VDS_PORT_STATUS.ONLINE;
pub const VDS_PRS_NOT_READY = VDS_PORT_STATUS.NOT_READY;
pub const VDS_PRS_OFFLINE = VDS_PORT_STATUS.OFFLINE;
pub const VDS_PRS_FAILED = VDS_PORT_STATUS.FAILED;
pub const VDS_PRS_REMOVED = VDS_PORT_STATUS.REMOVED;

pub const VDS_DRIVE_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
    REMOVED = 8,
};
pub const VDS_DRS_UNKNOWN = VDS_DRIVE_STATUS.UNKNOWN;
pub const VDS_DRS_ONLINE = VDS_DRIVE_STATUS.ONLINE;
pub const VDS_DRS_NOT_READY = VDS_DRIVE_STATUS.NOT_READY;
pub const VDS_DRS_OFFLINE = VDS_DRIVE_STATUS.OFFLINE;
pub const VDS_DRS_FAILED = VDS_DRIVE_STATUS.FAILED;
pub const VDS_DRS_REMOVED = VDS_DRIVE_STATUS.REMOVED;

pub const VDS_DRIVE_FLAG = extern enum(i32) {
    HOTSPARE = 1,
    ASSIGNED = 2,
    UNASSIGNED = 4,
    HOTSPARE_IN_USE = 8,
    HOTSPARE_STANDBY = 16,
};
pub const VDS_DRF_HOTSPARE = VDS_DRIVE_FLAG.HOTSPARE;
pub const VDS_DRF_ASSIGNED = VDS_DRIVE_FLAG.ASSIGNED;
pub const VDS_DRF_UNASSIGNED = VDS_DRIVE_FLAG.UNASSIGNED;
pub const VDS_DRF_HOTSPARE_IN_USE = VDS_DRIVE_FLAG.HOTSPARE_IN_USE;
pub const VDS_DRF_HOTSPARE_STANDBY = VDS_DRIVE_FLAG.HOTSPARE_STANDBY;

pub const VDS_LUN_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    DEFAULT = 1,
    FAULT_TOLERANT = 2,
    NON_FAULT_TOLERANT = 3,
    SIMPLE = 10,
    SPAN = 11,
    STRIPE = 12,
    MIRROR = 13,
    PARITY = 14,
    RAID2 = 15,
    RAID3 = 16,
    RAID4 = 17,
    RAID5 = 18,
    RAID6 = 19,
    RAID01 = 20,
    RAID03 = 21,
    RAID05 = 22,
    RAID10 = 23,
    RAID15 = 24,
    RAID30 = 25,
    RAID50 = 26,
    RAID51 = 27,
    RAID53 = 28,
    RAID60 = 29,
    RAID61 = 30,
};
pub const VDS_LT_UNKNOWN = VDS_LUN_TYPE.UNKNOWN;
pub const VDS_LT_DEFAULT = VDS_LUN_TYPE.DEFAULT;
pub const VDS_LT_FAULT_TOLERANT = VDS_LUN_TYPE.FAULT_TOLERANT;
pub const VDS_LT_NON_FAULT_TOLERANT = VDS_LUN_TYPE.NON_FAULT_TOLERANT;
pub const VDS_LT_SIMPLE = VDS_LUN_TYPE.SIMPLE;
pub const VDS_LT_SPAN = VDS_LUN_TYPE.SPAN;
pub const VDS_LT_STRIPE = VDS_LUN_TYPE.STRIPE;
pub const VDS_LT_MIRROR = VDS_LUN_TYPE.MIRROR;
pub const VDS_LT_PARITY = VDS_LUN_TYPE.PARITY;
pub const VDS_LT_RAID2 = VDS_LUN_TYPE.RAID2;
pub const VDS_LT_RAID3 = VDS_LUN_TYPE.RAID3;
pub const VDS_LT_RAID4 = VDS_LUN_TYPE.RAID4;
pub const VDS_LT_RAID5 = VDS_LUN_TYPE.RAID5;
pub const VDS_LT_RAID6 = VDS_LUN_TYPE.RAID6;
pub const VDS_LT_RAID01 = VDS_LUN_TYPE.RAID01;
pub const VDS_LT_RAID03 = VDS_LUN_TYPE.RAID03;
pub const VDS_LT_RAID05 = VDS_LUN_TYPE.RAID05;
pub const VDS_LT_RAID10 = VDS_LUN_TYPE.RAID10;
pub const VDS_LT_RAID15 = VDS_LUN_TYPE.RAID15;
pub const VDS_LT_RAID30 = VDS_LUN_TYPE.RAID30;
pub const VDS_LT_RAID50 = VDS_LUN_TYPE.RAID50;
pub const VDS_LT_RAID51 = VDS_LUN_TYPE.RAID51;
pub const VDS_LT_RAID53 = VDS_LUN_TYPE.RAID53;
pub const VDS_LT_RAID60 = VDS_LUN_TYPE.RAID60;
pub const VDS_LT_RAID61 = VDS_LUN_TYPE.RAID61;

pub const VDS_LUN_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
};
pub const VDS_LS_UNKNOWN = VDS_LUN_STATUS.UNKNOWN;
pub const VDS_LS_ONLINE = VDS_LUN_STATUS.ONLINE;
pub const VDS_LS_NOT_READY = VDS_LUN_STATUS.NOT_READY;
pub const VDS_LS_OFFLINE = VDS_LUN_STATUS.OFFLINE;
pub const VDS_LS_FAILED = VDS_LUN_STATUS.FAILED;

pub const VDS_LUN_FLAG = extern enum(i32) {
    LBN_REMAP_ENABLED = 1,
    READ_BACK_VERIFY_ENABLED = 2,
    WRITE_THROUGH_CACHING_ENABLED = 4,
    HARDWARE_CHECKSUM_ENABLED = 8,
    READ_CACHE_ENABLED = 16,
    WRITE_CACHE_ENABLED = 32,
    MEDIA_SCAN_ENABLED = 64,
    CONSISTENCY_CHECK_ENABLED = 128,
    SNAPSHOT = 256,
};
pub const VDS_LF_LBN_REMAP_ENABLED = VDS_LUN_FLAG.LBN_REMAP_ENABLED;
pub const VDS_LF_READ_BACK_VERIFY_ENABLED = VDS_LUN_FLAG.READ_BACK_VERIFY_ENABLED;
pub const VDS_LF_WRITE_THROUGH_CACHING_ENABLED = VDS_LUN_FLAG.WRITE_THROUGH_CACHING_ENABLED;
pub const VDS_LF_HARDWARE_CHECKSUM_ENABLED = VDS_LUN_FLAG.HARDWARE_CHECKSUM_ENABLED;
pub const VDS_LF_READ_CACHE_ENABLED = VDS_LUN_FLAG.READ_CACHE_ENABLED;
pub const VDS_LF_WRITE_CACHE_ENABLED = VDS_LUN_FLAG.WRITE_CACHE_ENABLED;
pub const VDS_LF_MEDIA_SCAN_ENABLED = VDS_LUN_FLAG.MEDIA_SCAN_ENABLED;
pub const VDS_LF_CONSISTENCY_CHECK_ENABLED = VDS_LUN_FLAG.CONSISTENCY_CHECK_ENABLED;
pub const VDS_LF_SNAPSHOT = VDS_LUN_FLAG.SNAPSHOT;

pub const VDS_LUN_PLEX_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    SIMPLE = 10,
    SPAN = 11,
    STRIPE = 12,
    PARITY = 14,
    RAID2 = 15,
    RAID3 = 16,
    RAID4 = 17,
    RAID5 = 18,
    RAID6 = 19,
    RAID03 = 21,
    RAID05 = 22,
    RAID10 = 23,
    RAID15 = 24,
    RAID30 = 25,
    RAID50 = 26,
    RAID53 = 28,
    RAID60 = 29,
};
pub const VDS_LPT_UNKNOWN = VDS_LUN_PLEX_TYPE.UNKNOWN;
pub const VDS_LPT_SIMPLE = VDS_LUN_PLEX_TYPE.SIMPLE;
pub const VDS_LPT_SPAN = VDS_LUN_PLEX_TYPE.SPAN;
pub const VDS_LPT_STRIPE = VDS_LUN_PLEX_TYPE.STRIPE;
pub const VDS_LPT_PARITY = VDS_LUN_PLEX_TYPE.PARITY;
pub const VDS_LPT_RAID2 = VDS_LUN_PLEX_TYPE.RAID2;
pub const VDS_LPT_RAID3 = VDS_LUN_PLEX_TYPE.RAID3;
pub const VDS_LPT_RAID4 = VDS_LUN_PLEX_TYPE.RAID4;
pub const VDS_LPT_RAID5 = VDS_LUN_PLEX_TYPE.RAID5;
pub const VDS_LPT_RAID6 = VDS_LUN_PLEX_TYPE.RAID6;
pub const VDS_LPT_RAID03 = VDS_LUN_PLEX_TYPE.RAID03;
pub const VDS_LPT_RAID05 = VDS_LUN_PLEX_TYPE.RAID05;
pub const VDS_LPT_RAID10 = VDS_LUN_PLEX_TYPE.RAID10;
pub const VDS_LPT_RAID15 = VDS_LUN_PLEX_TYPE.RAID15;
pub const VDS_LPT_RAID30 = VDS_LUN_PLEX_TYPE.RAID30;
pub const VDS_LPT_RAID50 = VDS_LUN_PLEX_TYPE.RAID50;
pub const VDS_LPT_RAID53 = VDS_LUN_PLEX_TYPE.RAID53;
pub const VDS_LPT_RAID60 = VDS_LUN_PLEX_TYPE.RAID60;

pub const VDS_LUN_PLEX_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
};
pub const VDS_LPS_UNKNOWN = VDS_LUN_PLEX_STATUS.UNKNOWN;
pub const VDS_LPS_ONLINE = VDS_LUN_PLEX_STATUS.ONLINE;
pub const VDS_LPS_NOT_READY = VDS_LUN_PLEX_STATUS.NOT_READY;
pub const VDS_LPS_OFFLINE = VDS_LUN_PLEX_STATUS.OFFLINE;
pub const VDS_LPS_FAILED = VDS_LUN_PLEX_STATUS.FAILED;

pub const VDS_LUN_PLEX_FLAG = extern enum(i32) {
    D = 1,
};
pub const VDS_LPF_LBN_REMAP_ENABLED = VDS_LUN_PLEX_FLAG.D;

pub const VDS_ISCSI_PORTAL_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
    FAILED = 5,
};
pub const VDS_IPS_UNKNOWN = VDS_ISCSI_PORTAL_STATUS.UNKNOWN;
pub const VDS_IPS_ONLINE = VDS_ISCSI_PORTAL_STATUS.ONLINE;
pub const VDS_IPS_NOT_READY = VDS_ISCSI_PORTAL_STATUS.NOT_READY;
pub const VDS_IPS_OFFLINE = VDS_ISCSI_PORTAL_STATUS.OFFLINE;
pub const VDS_IPS_FAILED = VDS_ISCSI_PORTAL_STATUS.FAILED;

pub const VDS_STORAGE_POOL_STATUS = extern enum(i32) {
    UNKNOWN = 0,
    ONLINE = 1,
    NOT_READY = 2,
    OFFLINE = 4,
};
pub const VDS_SPS_UNKNOWN = VDS_STORAGE_POOL_STATUS.UNKNOWN;
pub const VDS_SPS_ONLINE = VDS_STORAGE_POOL_STATUS.ONLINE;
pub const VDS_SPS_NOT_READY = VDS_STORAGE_POOL_STATUS.NOT_READY;
pub const VDS_SPS_OFFLINE = VDS_STORAGE_POOL_STATUS.OFFLINE;

pub const VDS_STORAGE_POOL_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    PRIMORDIAL = 1,
    CONCRETE = 2,
};
pub const VDS_SPT_UNKNOWN = VDS_STORAGE_POOL_TYPE.UNKNOWN;
pub const VDS_SPT_PRIMORDIAL = VDS_STORAGE_POOL_TYPE.PRIMORDIAL;
pub const VDS_SPT_CONCRETE = VDS_STORAGE_POOL_TYPE.CONCRETE;

pub const VDS_MAINTENANCE_OPERATION = extern enum(i32) {
    BlinkLight = 1,
    BeepAlarm = 2,
    SpinDown = 3,
    SpinUp = 4,
    Ping = 5,
};
pub const BlinkLight = VDS_MAINTENANCE_OPERATION.BlinkLight;
pub const BeepAlarm = VDS_MAINTENANCE_OPERATION.BeepAlarm;
pub const SpinDown = VDS_MAINTENANCE_OPERATION.SpinDown;
pub const SpinUp = VDS_MAINTENANCE_OPERATION.SpinUp;
pub const Ping = VDS_MAINTENANCE_OPERATION.Ping;

pub const VDS_HINTS = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    sRebuildPriority: i16,
};

pub const VDS_HINTS2 = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    ulReserved1: u32,
    ulReserved2: u32,
    ulReserved3: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    bAllocateHotSpare: BOOL,
    bUseMirroredCache: BOOL,
    bReadCachingEnabled: BOOL,
    bWriteCachingEnabled: BOOL,
    bMediaScanEnabled: BOOL,
    bConsistencyCheckEnabled: BOOL,
    BusType: VDS_STORAGE_BUS_TYPE,
    bReserved1: BOOL,
    bReserved2: BOOL,
    bReserved3: BOOL,
    sRebuildPriority: i16,
};

pub const VDS_SUB_SYSTEM_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
};

pub const VDS_SUB_SYSTEM_PROP2 = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    ulSupportedRaidTypeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
    ulNumberOfEnclosures: u32,
};

pub const VDS_CONTROLLER_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    status: VDS_CONTROLLER_STATUS,
    health: VDS_HEALTH,
    sNumberOfPorts: i16,
};

pub const VDS_DRIVE_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
};

pub const VDS_DRIVE_PROP2 = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
    ulEnclosureNumber: u32,
    busType: VDS_STORAGE_BUS_TYPE,
    ulSpindleSpeed: u32,
};

pub const VDS_DRIVE_EXTENT = extern struct {
    id: Guid,
    LunId: Guid,
    ullSize: u64,
    bUsed: BOOL,
};

pub const VDS_LUN_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    pwszUnmaskingList: PWSTR,
    ulFlags: u32,
    type: VDS_LUN_TYPE,
    status: VDS_LUN_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    sRebuildPriority: i16,
};

pub const VDS_LUN_PLEX_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    type: VDS_LUN_PLEX_TYPE,
    status: VDS_LUN_PLEX_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    ulFlags: u32,
    ulStripeSize: u32,
    sRebuildPriority: i16,
};

pub const VDS_PORT_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    status: VDS_PORT_STATUS,
};

pub const VDS_ISCSI_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    status: VDS_ISCSI_PORTAL_STATUS,
};

pub const VDS_ISCSI_TARGET_PROP = extern struct {
    id: Guid,
    pwszIscsiName: PWSTR,
    pwszFriendlyName: PWSTR,
    bChapEnabled: BOOL,
};

pub const VDS_ISCSI_PORTALGROUP_PROP = extern struct {
    id: Guid,
    tag: u16,
};

pub const VDS_RAID_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    RAID0 = 10,
    RAID1 = 11,
    RAID2 = 12,
    RAID3 = 13,
    RAID4 = 14,
    RAID5 = 15,
    RAID6 = 16,
    RAID01 = 17,
    RAID03 = 18,
    RAID05 = 19,
    RAID10 = 20,
    RAID15 = 21,
    RAID30 = 22,
    RAID50 = 23,
    RAID51 = 24,
    RAID53 = 25,
    RAID60 = 26,
    RAID61 = 27,
};
pub const VDS_RT_UNKNOWN = VDS_RAID_TYPE.UNKNOWN;
pub const VDS_RT_RAID0 = VDS_RAID_TYPE.RAID0;
pub const VDS_RT_RAID1 = VDS_RAID_TYPE.RAID1;
pub const VDS_RT_RAID2 = VDS_RAID_TYPE.RAID2;
pub const VDS_RT_RAID3 = VDS_RAID_TYPE.RAID3;
pub const VDS_RT_RAID4 = VDS_RAID_TYPE.RAID4;
pub const VDS_RT_RAID5 = VDS_RAID_TYPE.RAID5;
pub const VDS_RT_RAID6 = VDS_RAID_TYPE.RAID6;
pub const VDS_RT_RAID01 = VDS_RAID_TYPE.RAID01;
pub const VDS_RT_RAID03 = VDS_RAID_TYPE.RAID03;
pub const VDS_RT_RAID05 = VDS_RAID_TYPE.RAID05;
pub const VDS_RT_RAID10 = VDS_RAID_TYPE.RAID10;
pub const VDS_RT_RAID15 = VDS_RAID_TYPE.RAID15;
pub const VDS_RT_RAID30 = VDS_RAID_TYPE.RAID30;
pub const VDS_RT_RAID50 = VDS_RAID_TYPE.RAID50;
pub const VDS_RT_RAID51 = VDS_RAID_TYPE.RAID51;
pub const VDS_RT_RAID53 = VDS_RAID_TYPE.RAID53;
pub const VDS_RT_RAID60 = VDS_RAID_TYPE.RAID60;
pub const VDS_RT_RAID61 = VDS_RAID_TYPE.RAID61;

pub const VDS_POOL_CUSTOM_ATTRIBUTES = extern struct {
    pwszName: PWSTR,
    pwszValue: PWSTR,
};

pub const VDS_POOL_ATTRIBUTES = extern struct {
    ullAttributeMask: u64,
    raidType: VDS_RAID_TYPE,
    busType: VDS_STORAGE_BUS_TYPE,
    pwszIntendedUsage: PWSTR,
    bSpinDown: BOOL,
    bIsThinProvisioned: BOOL,
    ullProvisionedSpace: u64,
    bNoSinglePointOfFailure: BOOL,
    ulDataRedundancyMax: u32,
    ulDataRedundancyMin: u32,
    ulDataRedundancyDefault: u32,
    ulPackageRedundancyMax: u32,
    ulPackageRedundancyMin: u32,
    ulPackageRedundancyDefault: u32,
    ulStripeSize: u32,
    ulStripeSizeMax: u32,
    ulStripeSizeMin: u32,
    ulDefaultStripeSize: u32,
    ulNumberOfColumns: u32,
    ulNumberOfColumnsMax: u32,
    ulNumberOfColumnsMin: u32,
    ulDefaultNumberofColumns: u32,
    ulDataAvailabilityHint: u32,
    ulAccessRandomnessHint: u32,
    ulAccessDirectionHint: u32,
    ulAccessSizeHint: u32,
    ulAccessLatencyHint: u32,
    ulAccessBandwidthWeightHint: u32,
    ulStorageCostHint: u32,
    ulStorageEfficiencyHint: u32,
    ulNumOfCustomAttributes: u32,
    pPoolCustomAttributes: *VDS_POOL_CUSTOM_ATTRIBUTES,
    bReserved1: BOOL,
    bReserved2: BOOL,
    ulReserved1: u32,
    ulReserved2: u32,
    ullReserved1: u64,
    ullReserved2: u64,
};

pub const VDS_STORAGE_POOL_PROP = extern struct {
    id: Guid,
    status: VDS_STORAGE_POOL_STATUS,
    health: VDS_HEALTH,
    type: VDS_STORAGE_POOL_TYPE,
    pwszName: PWSTR,
    pwszDescription: PWSTR,
    ullTotalConsumedSpace: u64,
    ullTotalManagedSpace: u64,
    ullRemainingFreeSpace: u64,
};

pub const VDS_STORAGE_POOL_DRIVE_EXTENT = extern struct {
    id: Guid,
    ullSize: u64,
    bUsed: BOOL,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsHwProvider_Value = @import("../zig.zig").Guid.initString("d99bdaae-b13a-4178-9fdb-e27f16b4603e");
pub const IID_IVdsHwProvider = &IID_IVdsHwProvider_Value;
pub const IVdsHwProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QuerySubSystems: fn(
            self: *const IVdsHwProvider,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reenumerate: fn(
            self: *const IVdsHwProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IVdsHwProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_QuerySubSystems(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).QuerySubSystems(@ptrCast(*const IVdsHwProvider, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_Reenumerate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).Reenumerate(@ptrCast(*const IVdsHwProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).Refresh(@ptrCast(*const IVdsHwProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsHwProviderType_Value = @import("../zig.zig").Guid.initString("3e0f5166-542d-4fc6-947a-012174240b7e");
pub const IID_IVdsHwProviderType = &IID_IVdsHwProviderType_Value;
pub const IVdsHwProviderType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderType: fn(
            self: *const IVdsHwProviderType,
            pType: *VDS_HWPROVIDER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderType_GetProviderType(self: *const T, pType: *VDS_HWPROVIDER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderType.VTable, self.vtable).GetProviderType(@ptrCast(*const IVdsHwProviderType, self), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsHwProviderType2_Value = @import("../zig.zig").Guid.initString("8190236f-c4d0-4e81-8011-d69512fcc984");
pub const IID_IVdsHwProviderType2 = &IID_IVdsHwProviderType2_Value;
pub const IVdsHwProviderType2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderType2: fn(
            self: *const IVdsHwProviderType2,
            pType: *VDS_HWPROVIDER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderType2_GetProviderType2(self: *const T, pType: *VDS_HWPROVIDER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderType2.VTable, self.vtable).GetProviderType2(@ptrCast(*const IVdsHwProviderType2, self), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsHwProviderStoragePools_Value = @import("../zig.zig").Guid.initString("d5b5937a-f188-4c79-b86c-11c920ad11b8");
pub const IID_IVdsHwProviderStoragePools = &IID_IVdsHwProviderStoragePools_Value;
pub const IVdsHwProviderStoragePools = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryStoragePools: fn(
            self: *const IVdsHwProviderStoragePools,
            ulFlags: u32,
            ullRemainingFreeSpace: u64,
            pPoolAttributes: ?*VDS_POOL_ATTRIBUTES,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLunInStoragePool: fn(
            self: *const IVdsHwProviderStoragePools,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            StoragePoolId: Guid,
            pwszUnmaskingList: PWSTR,
            pHints2: ?*VDS_HINTS2,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSizeInStoragePool: fn(
            self: *const IVdsHwProviderStoragePools,
            type: VDS_LUN_TYPE,
            StoragePoolId: Guid,
            pHints2: ?*VDS_HINTS2,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_QueryStoragePools(self: *const T, ulFlags: u32, ullRemainingFreeSpace: u64, pPoolAttributes: ?*VDS_POOL_ATTRIBUTES, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).QueryStoragePools(@ptrCast(*const IVdsHwProviderStoragePools, self), ulFlags, ullRemainingFreeSpace, pPoolAttributes, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_CreateLunInStoragePool(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, StoragePoolId: Guid, pwszUnmaskingList: PWSTR, pHints2: ?*VDS_HINTS2, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).CreateLunInStoragePool(@ptrCast(*const IVdsHwProviderStoragePools, self), type, ullSizeInBytes, StoragePoolId, pwszUnmaskingList, pHints2, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_QueryMaxLunCreateSizeInStoragePool(self: *const T, type: VDS_LUN_TYPE, StoragePoolId: Guid, pHints2: ?*VDS_HINTS2, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).QueryMaxLunCreateSizeInStoragePool(@ptrCast(*const IVdsHwProviderStoragePools, self), type, StoragePoolId, pHints2, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsSubSystem_Value = @import("../zig.zig").Guid.initString("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8");
pub const IID_IVdsSubSystem = &IID_IVdsSubSystem_Value;
pub const IVdsSubSystem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsSubSystem,
            pSubSystemProp: *VDS_SUB_SYSTEM_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProvider: fn(
            self: *const IVdsSubSystem,
            ppProvider: ?*?*IVdsProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryControllers: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryLuns: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDrives: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrive: fn(
            self: *const IVdsSubSystem,
            sBusNumber: i16,
            sSlotNumber: i16,
            ppDrive: ?*?*IVdsDrive,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reenumerate: fn(
            self: *const IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControllerStatus: fn(
            self: *const IVdsSubSystem,
            pOnlineControllerIdArray: [*]Guid,
            lNumberOfOnlineControllers: i32,
            pOfflineControllerIdArray: [*]Guid,
            lNumberOfOfflineControllers: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLun: fn(
            self: *const IVdsSubSystem,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pwszUnmaskingList: PWSTR,
            pHints: ?*VDS_HINTS,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceDrive: fn(
            self: *const IVdsSubSystem,
            DriveToBeReplaced: Guid,
            ReplacementDrive: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsSubSystem,
            status: VDS_SUB_SYSTEM_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSize: fn(
            self: *const IVdsSubSystem,
            type: VDS_LUN_TYPE,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pHints: ?*VDS_HINTS,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetProperties(self: *const T, pSubSystemProp: *VDS_SUB_SYSTEM_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsSubSystem, self), pSubSystemProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetProvider(self: *const T, ppProvider: ?*?*IVdsProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetProvider(@ptrCast(*const IVdsSubSystem, self), ppProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryControllers(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryControllers(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryLuns(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryDrives(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryDrives(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetDrive(self: *const T, sBusNumber: i16, sSlotNumber: i16, ppDrive: ?*?*IVdsDrive) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetDrive(@ptrCast(*const IVdsSubSystem, self), sBusNumber, sSlotNumber, ppDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_Reenumerate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).Reenumerate(@ptrCast(*const IVdsSubSystem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_SetControllerStatus(self: *const T, pOnlineControllerIdArray: [*]Guid, lNumberOfOnlineControllers: i32, pOfflineControllerIdArray: [*]Guid, lNumberOfOfflineControllers: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).SetControllerStatus(@ptrCast(*const IVdsSubSystem, self), pOnlineControllerIdArray, lNumberOfOnlineControllers, pOfflineControllerIdArray, lNumberOfOfflineControllers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_CreateLun(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pwszUnmaskingList: PWSTR, pHints: ?*VDS_HINTS, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).CreateLun(@ptrCast(*const IVdsSubSystem, self), type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_ReplaceDrive(self: *const T, DriveToBeReplaced: Guid, ReplacementDrive: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).ReplaceDrive(@ptrCast(*const IVdsSubSystem, self), DriveToBeReplaced, ReplacementDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_SetStatus(self: *const T, status: VDS_SUB_SYSTEM_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsSubSystem, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryMaxLunCreateSize(self: *const T, type: VDS_LUN_TYPE, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pHints: ?*VDS_HINTS, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryMaxLunCreateSize(@ptrCast(*const IVdsSubSystem, self), type, pDriveIdArray, lNumberOfDrives, pHints, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsSubSystem2_Value = @import("../zig.zig").Guid.initString("be666735-7800-4a77-9d9c-40f85b87e292");
pub const IID_IVdsSubSystem2 = &IID_IVdsSubSystem2_Value;
pub const IVdsSubSystem2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties2: fn(
            self: *const IVdsSubSystem2,
            pSubSystemProp2: *VDS_SUB_SYSTEM_PROP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrive2: fn(
            self: *const IVdsSubSystem2,
            sBusNumber: i16,
            sSlotNumber: i16,
            ulEnclosureNumber: u32,
            ppDrive: ?*?*IVdsDrive,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLun2: fn(
            self: *const IVdsSubSystem2,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pwszUnmaskingList: PWSTR,
            pHints2: ?*VDS_HINTS2,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSize2: fn(
            self: *const IVdsSubSystem2,
            type: VDS_LUN_TYPE,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pHints2: ?*VDS_HINTS2,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_GetProperties2(self: *const T, pSubSystemProp2: *VDS_SUB_SYSTEM_PROP2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).GetProperties2(@ptrCast(*const IVdsSubSystem2, self), pSubSystemProp2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_GetDrive2(self: *const T, sBusNumber: i16, sSlotNumber: i16, ulEnclosureNumber: u32, ppDrive: ?*?*IVdsDrive) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).GetDrive2(@ptrCast(*const IVdsSubSystem2, self), sBusNumber, sSlotNumber, ulEnclosureNumber, ppDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_CreateLun2(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pwszUnmaskingList: PWSTR, pHints2: ?*VDS_HINTS2, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).CreateLun2(@ptrCast(*const IVdsSubSystem2, self), type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints2, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_QueryMaxLunCreateSize2(self: *const T, type: VDS_LUN_TYPE, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pHints2: ?*VDS_HINTS2, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).QueryMaxLunCreateSize2(@ptrCast(*const IVdsSubSystem2, self), type, pDriveIdArray, lNumberOfDrives, pHints2, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsSubSystemNaming_Value = @import("../zig.zig").Guid.initString("0d70faa3-9cd4-4900-aa20-6981b6aafc75");
pub const IID_IVdsSubSystemNaming = &IID_IVdsSubSystemNaming_Value;
pub const IVdsSubSystemNaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFriendlyName: fn(
            self: *const IVdsSubSystemNaming,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemNaming_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemNaming.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsSubSystemNaming, self), pwszFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsSubSystemIscsi_Value = @import("../zig.zig").Guid.initString("0027346f-40d0-4b45-8cec-5906dc0380c8");
pub const IID_IVdsSubSystemIscsi = &IID_IVdsSubSystemIscsi_Value;
pub const IVdsSubSystemIscsi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryTargets: fn(
            self: *const IVdsSubSystemIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPortals: fn(
            self: *const IVdsSubSystemIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTarget: fn(
            self: *const IVdsSubSystemIscsi,
            pwszIscsiName: ?PWSTR,
            pwszFriendlyName: PWSTR,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecGroupPresharedKey: fn(
            self: *const IVdsSubSystemIscsi,
            pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_QueryTargets(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).QueryTargets(@ptrCast(*const IVdsSubSystemIscsi, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_QueryPortals(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).QueryPortals(@ptrCast(*const IVdsSubSystemIscsi, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_CreateTarget(self: *const T, pwszIscsiName: ?PWSTR, pwszFriendlyName: PWSTR, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).CreateTarget(@ptrCast(*const IVdsSubSystemIscsi, self), pwszIscsiName, pwszFriendlyName, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(self: *const T, pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).SetIpsecGroupPresharedKey(@ptrCast(*const IVdsSubSystemIscsi, self), pIpsecKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsSubSystemInterconnect_Value = @import("../zig.zig").Guid.initString("9e6fa560-c141-477b-83ba-0b6c38f7febf");
pub const IID_IVdsSubSystemInterconnect = &IID_IVdsSubSystemInterconnect_Value;
pub const IVdsSubSystemInterconnect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSupportedInterconnects: fn(
            self: *const IVdsSubSystemInterconnect,
            pulSupportedInterconnectsFlag: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemInterconnect_GetSupportedInterconnects(self: *const T, pulSupportedInterconnectsFlag: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemInterconnect.VTable, self.vtable).GetSupportedInterconnects(@ptrCast(*const IVdsSubSystemInterconnect, self), pulSupportedInterconnectsFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsControllerPort_Value = @import("../zig.zig").Guid.initString("18691d0d-4e7f-43e8-92e4-cf44beeed11c");
pub const IID_IVdsControllerPort = &IID_IVdsControllerPort_Value;
pub const IVdsControllerPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsControllerPort,
            pPortProp: *VDS_PORT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetController: fn(
            self: *const IVdsControllerPort,
            ppController: ?*?*IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsControllerPort,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVdsControllerPort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsControllerPort,
            status: VDS_PORT_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_GetProperties(self: *const T, pPortProp: *VDS_PORT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsControllerPort, self), pPortProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_GetController(self: *const T, ppController: ?*?*IVdsController) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).GetController(@ptrCast(*const IVdsControllerPort, self), ppController);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsControllerPort, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).Reset(@ptrCast(*const IVdsControllerPort, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_SetStatus(self: *const T, status: VDS_PORT_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsControllerPort, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsController_Value = @import("../zig.zig").Guid.initString("cb53d96e-dffb-474a-a078-790d1e2bc082");
pub const IID_IVdsController = &IID_IVdsController_Value;
pub const IVdsController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsController,
            pControllerProp: *VDS_CONTROLLER_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsController,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPortProperties: fn(
            self: *const IVdsController,
            sPortNumber: i16,
            pPortProp: *VDS_PORT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCache: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateCache: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsController,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsController,
            status: VDS_CONTROLLER_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetProperties(self: *const T, pControllerProp: *VDS_CONTROLLER_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsController, self), pControllerProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsController, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetPortProperties(self: *const T, sPortNumber: i16, pPortProp: *VDS_PORT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetPortProperties(@ptrCast(*const IVdsController, self), sPortNumber, pPortProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_FlushCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).FlushCache(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_InvalidateCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).InvalidateCache(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).Reset(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsController, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_SetStatus(self: *const T, status: VDS_CONTROLLER_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsController, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsControllerControllerPort_Value = @import("../zig.zig").Guid.initString("ca5d735f-6bae-42c0-b30e-f2666045ce71");
pub const IID_IVdsControllerControllerPort = &IID_IVdsControllerControllerPort_Value;
pub const IVdsControllerControllerPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryControllerPorts: fn(
            self: *const IVdsControllerControllerPort,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerControllerPort_QueryControllerPorts(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerControllerPort.VTable, self.vtable).QueryControllerPorts(@ptrCast(*const IVdsControllerControllerPort, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsDrive_Value = @import("../zig.zig").Guid.initString("ff24efa4-aade-4b6b-898b-eaa6a20887c7");
pub const IID_IVdsDrive = &IID_IVdsDrive_Value;
pub const IVdsDrive = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsDrive,
            pDriveProp: *VDS_DRIVE_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsDrive,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryExtents: fn(
            self: *const IVdsDrive,
            ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IVdsDrive,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearFlags: fn(
            self: *const IVdsDrive,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsDrive,
            status: VDS_DRIVE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_GetProperties(self: *const T, pDriveProp: *VDS_DRIVE_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsDrive, self), pDriveProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsDrive, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_QueryExtents(self: *const T, ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).QueryExtents(@ptrCast(*const IVdsDrive, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_SetFlags(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).SetFlags(@ptrCast(*const IVdsDrive, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_ClearFlags(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).ClearFlags(@ptrCast(*const IVdsDrive, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_SetStatus(self: *const T, status: VDS_DRIVE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsDrive, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsDrive2_Value = @import("../zig.zig").Guid.initString("60b5a730-addf-4436-8ca7-5769e2d1ffa4");
pub const IID_IVdsDrive2 = &IID_IVdsDrive2_Value;
pub const IVdsDrive2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties2: fn(
            self: *const IVdsDrive2,
            pDriveProp2: *VDS_DRIVE_PROP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive2_GetProperties2(self: *const T, pDriveProp2: *VDS_DRIVE_PROP2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive2.VTable, self.vtable).GetProperties2(@ptrCast(*const IVdsDrive2, self), pDriveProp2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLun_Value = @import("../zig.zig").Guid.initString("3540a9c7-e60f-4111-a840-8bba6c2c83d8");
pub const IID_IVdsLun = &IID_IVdsLun_Value;
pub const IVdsLun = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsLun,
            pLunProp: *VDS_LUN_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsLun,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentificationData: fn(
            self: *const IVdsLun,
            pLunInfo: *VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryActiveControllers: fn(
            self: *const IVdsLun,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extend: fn(
            self: *const IVdsLun,
            ullNumberOfBytesToAdd: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shrink: fn(
            self: *const IVdsLun,
            ullNumberOfBytesToRemove: u64,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPlexes: fn(
            self: *const IVdsLun,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPlex: fn(
            self: *const IVdsLun,
            lunId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePlex: fn(
            self: *const IVdsLun,
            plexId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Recover: fn(
            self: *const IVdsLun,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMask: fn(
            self: *const IVdsLun,
            pwszUnmaskingList: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsLun,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateControllers: fn(
            self: *const IVdsLun,
            pActiveControllerIdArray: ?[*]Guid,
            lNumberOfActiveControllers: i32,
            pInactiveControllerIdArray: ?[*]Guid,
            lNumberOfInactiveControllers: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHints: fn(
            self: *const IVdsLun,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints: fn(
            self: *const IVdsLun,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsLun,
            status: VDS_LUN_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunExtendSize: fn(
            self: *const IVdsLun,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pullMaxBytesToBeAdded: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetProperties(self: *const T, pLunProp: *VDS_LUN_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsLun, self), pLunProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsLun, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetIdentificationData(self: *const T, pLunInfo: *VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetIdentificationData(@ptrCast(*const IVdsLun, self), pLunInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryActiveControllers(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryActiveControllers(@ptrCast(*const IVdsLun, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Extend(self: *const T, ullNumberOfBytesToAdd: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Extend(@ptrCast(*const IVdsLun, self), ullNumberOfBytesToAdd, pDriveIdArray, lNumberOfDrives, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Shrink(self: *const T, ullNumberOfBytesToRemove: u64, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Shrink(@ptrCast(*const IVdsLun, self), ullNumberOfBytesToRemove, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryPlexes(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryPlexes(@ptrCast(*const IVdsLun, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_AddPlex(self: *const T, lunId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).AddPlex(@ptrCast(*const IVdsLun, self), lunId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_RemovePlex(self: *const T, plexId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).RemovePlex(@ptrCast(*const IVdsLun, self), plexId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Recover(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Recover(@ptrCast(*const IVdsLun, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_SetMask(self: *const T, pwszUnmaskingList: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).SetMask(@ptrCast(*const IVdsLun, self), pwszUnmaskingList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Delete(@ptrCast(*const IVdsLun, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_AssociateControllers(self: *const T, pActiveControllerIdArray: ?[*]Guid, lNumberOfActiveControllers: i32, pInactiveControllerIdArray: ?[*]Guid, lNumberOfInactiveControllers: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).AssociateControllers(@ptrCast(*const IVdsLun, self), pActiveControllerIdArray, lNumberOfActiveControllers, pInactiveControllerIdArray, lNumberOfInactiveControllers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryHints(@ptrCast(*const IVdsLun, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_ApplyHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).ApplyHints(@ptrCast(*const IVdsLun, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_SetStatus(self: *const T, status: VDS_LUN_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsLun, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryMaxLunExtendSize(self: *const T, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pullMaxBytesToBeAdded: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryMaxLunExtendSize(@ptrCast(*const IVdsLun, self), pDriveIdArray, lNumberOfDrives, pullMaxBytesToBeAdded);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsLun2_Value = @import("../zig.zig").Guid.initString("e5b3a735-9efb-499a-8071-4394d9ee6fcb");
pub const IID_IVdsLun2 = &IID_IVdsLun2_Value;
pub const IVdsLun2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryHints2: fn(
            self: *const IVdsLun2,
            pHints2: *VDS_HINTS2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints2: fn(
            self: *const IVdsLun2,
            pHints2: *VDS_HINTS2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun2_QueryHints2(self: *const T, pHints2: *VDS_HINTS2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun2.VTable, self.vtable).QueryHints2(@ptrCast(*const IVdsLun2, self), pHints2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun2_ApplyHints2(self: *const T, pHints2: *VDS_HINTS2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun2.VTable, self.vtable).ApplyHints2(@ptrCast(*const IVdsLun2, self), pHints2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLunNaming_Value = @import("../zig.zig").Guid.initString("907504cb-6b4e-4d88-a34d-17ba661fbb06");
pub const IID_IVdsLunNaming = &IID_IVdsLunNaming_Value;
pub const IVdsLunNaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFriendlyName: fn(
            self: *const IVdsLunNaming,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunNaming_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunNaming.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsLunNaming, self), pwszFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsLunNumber_Value = @import("../zig.zig").Guid.initString("d3f95e46-54b3-41f9-b678-0f1871443a08");
pub const IID_IVdsLunNumber = &IID_IVdsLunNumber_Value;
pub const IVdsLunNumber = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLunNumber: fn(
            self: *const IVdsLunNumber,
            pulLunNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunNumber_GetLunNumber(self: *const T, pulLunNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunNumber.VTable, self.vtable).GetLunNumber(@ptrCast(*const IVdsLunNumber, self), pulLunNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLunControllerPorts_Value = @import("../zig.zig").Guid.initString("451fe266-da6d-406a-bb60-82e534f85aeb");
pub const IID_IVdsLunControllerPorts = &IID_IVdsLunControllerPorts_Value;
pub const IVdsLunControllerPorts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateControllerPorts: fn(
            self: *const IVdsLunControllerPorts,
            pActiveControllerPortIdArray: ?[*]Guid,
            lNumberOfActiveControllerPorts: i32,
            pInactiveControllerPortIdArray: ?[*]Guid,
            lNumberOfInactiveControllerPorts: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryActiveControllerPorts: fn(
            self: *const IVdsLunControllerPorts,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunControllerPorts_AssociateControllerPorts(self: *const T, pActiveControllerPortIdArray: ?[*]Guid, lNumberOfActiveControllerPorts: i32, pInactiveControllerPortIdArray: ?[*]Guid, lNumberOfInactiveControllerPorts: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunControllerPorts.VTable, self.vtable).AssociateControllerPorts(@ptrCast(*const IVdsLunControllerPorts, self), pActiveControllerPortIdArray, lNumberOfActiveControllerPorts, pInactiveControllerPortIdArray, lNumberOfInactiveControllerPorts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunControllerPorts_QueryActiveControllerPorts(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunControllerPorts.VTable, self.vtable).QueryActiveControllerPorts(@ptrCast(*const IVdsLunControllerPorts, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLunMpio_Value = @import("../zig.zig").Guid.initString("7c5fbae3-333a-48a1-a982-33c15788cde3");
pub const IID_IVdsLunMpio = &IID_IVdsLunMpio_Value;
pub const IVdsLunMpio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathInfo: fn(
            self: *const IVdsLunMpio,
            ppPaths: ?[*]?*VDS_PATH_INFO,
            plNumberOfPaths: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLoadBalancePolicy: fn(
            self: *const IVdsLunMpio,
            pPolicy: *VDS_LOADBALANCE_POLICY_ENUM,
            ppPaths: ?[*]?*VDS_PATH_POLICY,
            plNumberOfPaths: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLoadBalancePolicy: fn(
            self: *const IVdsLunMpio,
            policy: VDS_LOADBALANCE_POLICY_ENUM,
            pPaths: ?[*]VDS_PATH_POLICY,
            lNumberOfPaths: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedLbPolicies: fn(
            self: *const IVdsLunMpio,
            pulLbFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetPathInfo(self: *const T, ppPaths: ?[*]?*VDS_PATH_INFO, plNumberOfPaths: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetPathInfo(@ptrCast(*const IVdsLunMpio, self), ppPaths, plNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetLoadBalancePolicy(self: *const T, pPolicy: *VDS_LOADBALANCE_POLICY_ENUM, ppPaths: ?[*]?*VDS_PATH_POLICY, plNumberOfPaths: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetLoadBalancePolicy(@ptrCast(*const IVdsLunMpio, self), pPolicy, ppPaths, plNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_SetLoadBalancePolicy(self: *const T, policy: VDS_LOADBALANCE_POLICY_ENUM, pPaths: ?[*]VDS_PATH_POLICY, lNumberOfPaths: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).SetLoadBalancePolicy(@ptrCast(*const IVdsLunMpio, self), policy, pPaths, lNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetSupportedLbPolicies(self: *const T, pulLbFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetSupportedLbPolicies(@ptrCast(*const IVdsLunMpio, self), pulLbFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLunIscsi_Value = @import("../zig.zig").Guid.initString("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067");
pub const IID_IVdsLunIscsi = &IID_IVdsLunIscsi_Value;
pub const IVdsLunIscsi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateTargets: fn(
            self: *const IVdsLunIscsi,
            pTargetIdArray: ?[*]Guid,
            lNumberOfTargets: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedTargets: fn(
            self: *const IVdsLunIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunIscsi_AssociateTargets(self: *const T, pTargetIdArray: ?[*]Guid, lNumberOfTargets: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunIscsi.VTable, self.vtable).AssociateTargets(@ptrCast(*const IVdsLunIscsi, self), pTargetIdArray, lNumberOfTargets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunIscsi_QueryAssociatedTargets(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunIscsi.VTable, self.vtable).QueryAssociatedTargets(@ptrCast(*const IVdsLunIscsi, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsLunPlex_Value = @import("../zig.zig").Guid.initString("0ee1a790-5d2e-4abb-8c99-c481e8be2138");
pub const IID_IVdsLunPlex = &IID_IVdsLunPlex_Value;
pub const IVdsLunPlex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsLunPlex,
            pPlexProp: *VDS_LUN_PLEX_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLun: fn(
            self: *const IVdsLunPlex,
            ppLun: ?*?*IVdsLun,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryExtents: fn(
            self: *const IVdsLunPlex,
            ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHints: fn(
            self: *const IVdsLunPlex,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints: fn(
            self: *const IVdsLunPlex,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_GetProperties(self: *const T, pPlexProp: *VDS_LUN_PLEX_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsLunPlex, self), pPlexProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_GetLun(self: *const T, ppLun: ?*?*IVdsLun) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).GetLun(@ptrCast(*const IVdsLunPlex, self), ppLun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_QueryExtents(self: *const T, ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).QueryExtents(@ptrCast(*const IVdsLunPlex, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_QueryHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).QueryHints(@ptrCast(*const IVdsLunPlex, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_ApplyHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).ApplyHints(@ptrCast(*const IVdsLunPlex, self), pHints);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsIscsiPortal_Value = @import("../zig.zig").Guid.initString("7fa1499d-ec85-4a8a-a47b-ff69201fcd34");
pub const IID_IVdsIscsiPortal = &IID_IVdsIscsiPortal_Value;
pub const IVdsIscsiPortal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiPortal,
            pPortalProp: *VDS_ISCSI_PORTAL_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsIscsiPortal,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedPortalGroups: fn(
            self: *const IVdsIscsiPortal,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsIscsiPortal,
            status: VDS_ISCSI_PORTAL_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecTunnelAddress: fn(
            self: *const IVdsIscsiPortal,
            pTunnelAddress: *VDS_IPADDRESS,
            pDestinationAddress: *VDS_IPADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIpsecSecurity: fn(
            self: *const IVdsIscsiPortal,
            pInitiatorPortalAddress: *VDS_IPADDRESS,
            pullSecurityFlags: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecSecurity: fn(
            self: *const IVdsIscsiPortal,
            pInitiatorPortalAddress: *VDS_IPADDRESS,
            ullSecurityFlags: u64,
            pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetProperties(self: *const T, pPortalProp: *VDS_ISCSI_PORTAL_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiPortal, self), pPortalProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsIscsiPortal, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_QueryAssociatedPortalGroups(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).QueryAssociatedPortalGroups(@ptrCast(*const IVdsIscsiPortal, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetStatus(self: *const T, status: VDS_ISCSI_PORTAL_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsIscsiPortal, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetIpsecTunnelAddress(self: *const T, pTunnelAddress: *VDS_IPADDRESS, pDestinationAddress: *VDS_IPADDRESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetIpsecTunnelAddress(@ptrCast(*const IVdsIscsiPortal, self), pTunnelAddress, pDestinationAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetIpsecSecurity(self: *const T, pInitiatorPortalAddress: *VDS_IPADDRESS, pullSecurityFlags: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetIpsecSecurity(@ptrCast(*const IVdsIscsiPortal, self), pInitiatorPortalAddress, pullSecurityFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetIpsecSecurity(self: *const T, pInitiatorPortalAddress: *VDS_IPADDRESS, ullSecurityFlags: u64, pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetIpsecSecurity(@ptrCast(*const IVdsIscsiPortal, self), pInitiatorPortalAddress, ullSecurityFlags, pIpsecKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsIscsiTarget_Value = @import("../zig.zig").Guid.initString("aa8f5055-83e5-4bcc-aa73-19851a36a849");
pub const IID_IVdsIscsiTarget = &IID_IVdsIscsiTarget_Value;
pub const IVdsIscsiTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiTarget,
            pTargetProp: *VDS_ISCSI_TARGET_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsIscsiTarget,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPortalGroups: fn(
            self: *const IVdsIscsiTarget,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsIscsiTarget,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePortalGroup: fn(
            self: *const IVdsIscsiTarget,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsIscsiTarget,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFriendlyName: fn(
            self: *const IVdsIscsiTarget,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSharedSecret: fn(
            self: *const IVdsIscsiTarget,
            pTargetSharedSecret: ?*VDS_ISCSI_SHARED_SECRET,
            pwszInitiatorName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RememberInitiatorSharedSecret: fn(
            self: *const IVdsIscsiTarget,
            pwszInitiatorName: PWSTR,
            pInitiatorSharedSecret: ?*VDS_ISCSI_SHARED_SECRET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectedInitiators: fn(
            self: *const IVdsIscsiTarget,
            pppwszInitiatorList: ?[*]?*?PWSTR,
            plNumberOfInitiators: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetProperties(self: *const T, pTargetProp: *VDS_ISCSI_TARGET_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiTarget, self), pTargetProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsIscsiTarget, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_QueryPortalGroups(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).QueryPortalGroups(@ptrCast(*const IVdsIscsiTarget, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsIscsiTarget, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_CreatePortalGroup(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).CreatePortalGroup(@ptrCast(*const IVdsIscsiTarget, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_Delete(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).Delete(@ptrCast(*const IVdsIscsiTarget, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsIscsiTarget, self), pwszFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_SetSharedSecret(self: *const T, pTargetSharedSecret: ?*VDS_ISCSI_SHARED_SECRET, pwszInitiatorName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).SetSharedSecret(@ptrCast(*const IVdsIscsiTarget, self), pTargetSharedSecret, pwszInitiatorName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_RememberInitiatorSharedSecret(self: *const T, pwszInitiatorName: PWSTR, pInitiatorSharedSecret: ?*VDS_ISCSI_SHARED_SECRET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).RememberInitiatorSharedSecret(@ptrCast(*const IVdsIscsiTarget, self), pwszInitiatorName, pInitiatorSharedSecret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetConnectedInitiators(self: *const T, pppwszInitiatorList: ?[*]?*?PWSTR, plNumberOfInitiators: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetConnectedInitiators(@ptrCast(*const IVdsIscsiTarget, self), pppwszInitiatorList, plNumberOfInitiators);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsIscsiPortalGroup_Value = @import("../zig.zig").Guid.initString("fef5f89d-a3dd-4b36-bf28-e7dde045c593");
pub const IID_IVdsIscsiPortalGroup = &IID_IVdsIscsiPortalGroup_Value;
pub const IVdsIscsiPortalGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiPortalGroup,
            pPortalGroupProp: *VDS_ISCSI_PORTALGROUP_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTarget: fn(
            self: *const IVdsIscsiPortalGroup,
            ppTarget: ?*?*IVdsIscsiTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedPortals: fn(
            self: *const IVdsIscsiPortalGroup,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPortal: fn(
            self: *const IVdsIscsiPortalGroup,
            portalId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePortal: fn(
            self: *const IVdsIscsiPortalGroup,
            portalId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsIscsiPortalGroup,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_GetProperties(self: *const T, pPortalGroupProp: *VDS_ISCSI_PORTALGROUP_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiPortalGroup, self), pPortalGroupProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_GetTarget(self: *const T, ppTarget: ?*?*IVdsIscsiTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).GetTarget(@ptrCast(*const IVdsIscsiPortalGroup, self), ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_QueryAssociatedPortals(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).QueryAssociatedPortals(@ptrCast(*const IVdsIscsiPortalGroup, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_AddPortal(self: *const T, portalId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).AddPortal(@ptrCast(*const IVdsIscsiPortalGroup, self), portalId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_RemovePortal(self: *const T, portalId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).RemovePortal(@ptrCast(*const IVdsIscsiPortalGroup, self), portalId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_Delete(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).Delete(@ptrCast(*const IVdsIscsiPortalGroup, self), ppAsync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IVdsStoragePool_Value = @import("../zig.zig").Guid.initString("932ca8cf-0eb3-4ba8-9620-22665d7f8450");
pub const IID_IVdsStoragePool = &IID_IVdsStoragePool_Value;
pub const IVdsStoragePool = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProvider: fn(
            self: *const IVdsStoragePool,
            ppProvider: ?*?*IVdsProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IVdsStoragePool,
            pStoragePoolProp: *VDS_STORAGE_POOL_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IVdsStoragePool,
            pStoragePoolAttributes: *VDS_POOL_ATTRIBUTES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDriveExtents: fn(
            self: *const IVdsStoragePool,
            ppExtentArray: ?[*]?*VDS_STORAGE_POOL_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAllocatedLuns: fn(
            self: *const IVdsStoragePool,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAllocatedStoragePools: fn(
            self: *const IVdsStoragePool,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetProvider(self: *const T, ppProvider: ?*?*IVdsProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetProvider(@ptrCast(*const IVdsStoragePool, self), ppProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetProperties(self: *const T, pStoragePoolProp: *VDS_STORAGE_POOL_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsStoragePool, self), pStoragePoolProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetAttributes(self: *const T, pStoragePoolAttributes: *VDS_POOL_ATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetAttributes(@ptrCast(*const IVdsStoragePool, self), pStoragePoolAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryDriveExtents(self: *const T, ppExtentArray: ?[*]?*VDS_STORAGE_POOL_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryDriveExtents(@ptrCast(*const IVdsStoragePool, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryAllocatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryAllocatedLuns(@ptrCast(*const IVdsStoragePool, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryAllocatedStoragePools(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryAllocatedStoragePools(@ptrCast(*const IVdsStoragePool, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsMaintenance_Value = @import("../zig.zig").Guid.initString("daebeef3-8523-47ed-a2b9-05cecce2a1ae");
pub const IID_IVdsMaintenance = &IID_IVdsMaintenance_Value;
pub const IVdsMaintenance = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PulseMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_StartMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).StartMaintenance(@ptrCast(*const IVdsMaintenance, self), operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_StopMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).StopMaintenance(@ptrCast(*const IVdsMaintenance, self), operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_PulseMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).PulseMaintenance(@ptrCast(*const IVdsMaintenance, self), operation, ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsHwProviderPrivate_Value = @import("../zig.zig").Guid.initString("98f17bf3-9f33-4f12-8714-8b4075092c2e");
pub const IID_IVdsHwProviderPrivate = &IID_IVdsHwProviderPrivate_Value;
pub const IVdsHwProviderPrivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryIfCreatedLun: fn(
            self: *const IVdsHwProviderPrivate,
            pwszDevicePath: PWSTR,
            pVdsLunInformation: *VDS_LUN_INFORMATION,
            pLunId: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderPrivate_QueryIfCreatedLun(self: *const T, pwszDevicePath: PWSTR, pVdsLunInformation: *VDS_LUN_INFORMATION, pLunId: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderPrivate.VTable, self.vtable).QueryIfCreatedLun(@ptrCast(*const IVdsHwProviderPrivate, self), pwszDevicePath, pVdsLunInformation, pLunId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsHwProviderPrivateMpio_Value = @import("../zig.zig").Guid.initString("310a7715-ac2b-4c6f-9827-3d742f351676");
pub const IID_IVdsHwProviderPrivateMpio = &IID_IVdsHwProviderPrivateMpio_Value;
pub const IVdsHwProviderPrivateMpio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAllPathStatusesFromHbaPort: fn(
            self: *const IVdsHwProviderPrivateMpio,
            hbaPortProp: VDS_HBAPORT_PROP,
            status: VDS_PATH_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderPrivateMpio_SetAllPathStatusesFromHbaPort(self: *const T, hbaPortProp: VDS_HBAPORT_PROP, status: VDS_PATH_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderPrivateMpio.VTable, self.vtable).SetAllPathStatusesFromHbaPort(@ptrCast(*const IVdsHwProviderPrivateMpio, self), hbaPortProp, status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVdsAdmin_Value = @import("../zig.zig").Guid.initString("d188e97d-85aa-4d33-abc6-26299a10ffc1");
pub const IID_IVdsAdmin = &IID_IVdsAdmin_Value;
pub const IVdsAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProvider: fn(
            self: *const IVdsAdmin,
            providerId: Guid,
            providerClsid: Guid,
            pwszName: PWSTR,
            type: VDS_PROVIDER_TYPE,
            pwszMachineName: ?PWSTR,
            pwszVersion: PWSTR,
            guidVersionId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: fn(
            self: *const IVdsAdmin,
            providerId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdmin_RegisterProvider(self: *const T, providerId: Guid, providerClsid: Guid, pwszName: PWSTR, type: VDS_PROVIDER_TYPE, pwszMachineName: ?PWSTR, pwszVersion: PWSTR, guidVersionId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdmin.VTable, self.vtable).RegisterProvider(@ptrCast(*const IVdsAdmin, self), providerId, providerClsid, pwszName, type, pwszMachineName, pwszVersion, guidVersionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdmin_UnregisterProvider(self: *const T, providerId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdmin.VTable, self.vtable).UnregisterProvider(@ptrCast(*const IVdsAdmin, self), providerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VSS_OBJECT_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    NONE = 1,
    SNAPSHOT_SET = 2,
    SNAPSHOT = 3,
    PROVIDER = 4,
    TYPE_COUNT = 5,
};
pub const VSS_OBJECT_UNKNOWN = VSS_OBJECT_TYPE.UNKNOWN;
pub const VSS_OBJECT_NONE = VSS_OBJECT_TYPE.NONE;
pub const VSS_OBJECT_SNAPSHOT_SET = VSS_OBJECT_TYPE.SNAPSHOT_SET;
pub const VSS_OBJECT_SNAPSHOT = VSS_OBJECT_TYPE.SNAPSHOT;
pub const VSS_OBJECT_PROVIDER = VSS_OBJECT_TYPE.PROVIDER;
pub const VSS_OBJECT_TYPE_COUNT = VSS_OBJECT_TYPE.TYPE_COUNT;

pub const VSS_SNAPSHOT_STATE = extern enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    PROCESSING_PREPARE = 2,
    PREPARED = 3,
    PROCESSING_PRECOMMIT = 4,
    PRECOMMITTED = 5,
    PROCESSING_COMMIT = 6,
    COMMITTED = 7,
    PROCESSING_POSTCOMMIT = 8,
    PROCESSING_PREFINALCOMMIT = 9,
    PREFINALCOMMITTED = 10,
    PROCESSING_POSTFINALCOMMIT = 11,
    CREATED = 12,
    ABORTED = 13,
    DELETED = 14,
    POSTCOMMITTED = 15,
    COUNT = 16,
};
pub const VSS_SS_UNKNOWN = VSS_SNAPSHOT_STATE.UNKNOWN;
pub const VSS_SS_PREPARING = VSS_SNAPSHOT_STATE.PREPARING;
pub const VSS_SS_PROCESSING_PREPARE = VSS_SNAPSHOT_STATE.PROCESSING_PREPARE;
pub const VSS_SS_PREPARED = VSS_SNAPSHOT_STATE.PREPARED;
pub const VSS_SS_PROCESSING_PRECOMMIT = VSS_SNAPSHOT_STATE.PROCESSING_PRECOMMIT;
pub const VSS_SS_PRECOMMITTED = VSS_SNAPSHOT_STATE.PRECOMMITTED;
pub const VSS_SS_PROCESSING_COMMIT = VSS_SNAPSHOT_STATE.PROCESSING_COMMIT;
pub const VSS_SS_COMMITTED = VSS_SNAPSHOT_STATE.COMMITTED;
pub const VSS_SS_PROCESSING_POSTCOMMIT = VSS_SNAPSHOT_STATE.PROCESSING_POSTCOMMIT;
pub const VSS_SS_PROCESSING_PREFINALCOMMIT = VSS_SNAPSHOT_STATE.PROCESSING_PREFINALCOMMIT;
pub const VSS_SS_PREFINALCOMMITTED = VSS_SNAPSHOT_STATE.PREFINALCOMMITTED;
pub const VSS_SS_PROCESSING_POSTFINALCOMMIT = VSS_SNAPSHOT_STATE.PROCESSING_POSTFINALCOMMIT;
pub const VSS_SS_CREATED = VSS_SNAPSHOT_STATE.CREATED;
pub const VSS_SS_ABORTED = VSS_SNAPSHOT_STATE.ABORTED;
pub const VSS_SS_DELETED = VSS_SNAPSHOT_STATE.DELETED;
pub const VSS_SS_POSTCOMMITTED = VSS_SNAPSHOT_STATE.POSTCOMMITTED;
pub const VSS_SS_COUNT = VSS_SNAPSHOT_STATE.COUNT;

pub const VSS_VOLUME_SNAPSHOT_ATTRIBUTES = extern enum(i32) {
    PERSISTENT = 1,
    NO_AUTORECOVERY = 2,
    CLIENT_ACCESSIBLE = 4,
    NO_AUTO_RELEASE = 8,
    NO_WRITERS = 16,
    TRANSPORTABLE = 32,
    NOT_SURFACED = 64,
    NOT_TRANSACTED = 128,
    HARDWARE_ASSISTED = 65536,
    DIFFERENTIAL = 131072,
    PLEX = 262144,
    IMPORTED = 524288,
    EXPOSED_LOCALLY = 1048576,
    EXPOSED_REMOTELY = 2097152,
    AUTORECOVER = 4194304,
    ROLLBACK_RECOVERY = 8388608,
    DELAYED_POSTSNAPSHOT = 16777216,
    TXF_RECOVERY = 33554432,
    FILE_SHARE = 67108864,
};
pub const VSS_VOLSNAP_ATTR_PERSISTENT = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.PERSISTENT;
pub const VSS_VOLSNAP_ATTR_NO_AUTORECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.NO_AUTORECOVERY;
pub const VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.CLIENT_ACCESSIBLE;
pub const VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.NO_AUTO_RELEASE;
pub const VSS_VOLSNAP_ATTR_NO_WRITERS = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.NO_WRITERS;
pub const VSS_VOLSNAP_ATTR_TRANSPORTABLE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.TRANSPORTABLE;
pub const VSS_VOLSNAP_ATTR_NOT_SURFACED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.NOT_SURFACED;
pub const VSS_VOLSNAP_ATTR_NOT_TRANSACTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.NOT_TRANSACTED;
pub const VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.HARDWARE_ASSISTED;
pub const VSS_VOLSNAP_ATTR_DIFFERENTIAL = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.DIFFERENTIAL;
pub const VSS_VOLSNAP_ATTR_PLEX = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.PLEX;
pub const VSS_VOLSNAP_ATTR_IMPORTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.IMPORTED;
pub const VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.EXPOSED_LOCALLY;
pub const VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.EXPOSED_REMOTELY;
pub const VSS_VOLSNAP_ATTR_AUTORECOVER = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.AUTORECOVER;
pub const VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.ROLLBACK_RECOVERY;
pub const VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.DELAYED_POSTSNAPSHOT;
pub const VSS_VOLSNAP_ATTR_TXF_RECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.TXF_RECOVERY;
pub const VSS_VOLSNAP_ATTR_FILE_SHARE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.FILE_SHARE;

pub const VSS_SNAPSHOT_CONTEXT = extern enum(i32) {
    BACKUP = 0,
    FILE_SHARE_BACKUP = 16,
    NAS_ROLLBACK = 25,
    APP_ROLLBACK = 9,
    CLIENT_ACCESSIBLE = 29,
    CLIENT_ACCESSIBLE_WRITERS = 13,
    ALL = -1,
};
pub const VSS_CTX_BACKUP = VSS_SNAPSHOT_CONTEXT.BACKUP;
pub const VSS_CTX_FILE_SHARE_BACKUP = VSS_SNAPSHOT_CONTEXT.FILE_SHARE_BACKUP;
pub const VSS_CTX_NAS_ROLLBACK = VSS_SNAPSHOT_CONTEXT.NAS_ROLLBACK;
pub const VSS_CTX_APP_ROLLBACK = VSS_SNAPSHOT_CONTEXT.APP_ROLLBACK;
pub const VSS_CTX_CLIENT_ACCESSIBLE = VSS_SNAPSHOT_CONTEXT.CLIENT_ACCESSIBLE;
pub const VSS_CTX_CLIENT_ACCESSIBLE_WRITERS = VSS_SNAPSHOT_CONTEXT.CLIENT_ACCESSIBLE_WRITERS;
pub const VSS_CTX_ALL = VSS_SNAPSHOT_CONTEXT.ALL;

pub const VSS_PROVIDER_CAPABILITIES = extern enum(i32) {
    LEGACY = 1,
    COMPLIANT = 2,
    LUN_REPOINT = 4,
    LUN_RESYNC = 8,
    OFFLINE_CREATION = 16,
    MULTIPLE_IMPORT = 32,
    RECYCLING = 64,
    PLEX = 128,
    DIFFERENTIAL = 256,
    CLUSTERED = 512,
};
pub const VSS_PRV_CAPABILITY_LEGACY = VSS_PROVIDER_CAPABILITIES.LEGACY;
pub const VSS_PRV_CAPABILITY_COMPLIANT = VSS_PROVIDER_CAPABILITIES.COMPLIANT;
pub const VSS_PRV_CAPABILITY_LUN_REPOINT = VSS_PROVIDER_CAPABILITIES.LUN_REPOINT;
pub const VSS_PRV_CAPABILITY_LUN_RESYNC = VSS_PROVIDER_CAPABILITIES.LUN_RESYNC;
pub const VSS_PRV_CAPABILITY_OFFLINE_CREATION = VSS_PROVIDER_CAPABILITIES.OFFLINE_CREATION;
pub const VSS_PRV_CAPABILITY_MULTIPLE_IMPORT = VSS_PROVIDER_CAPABILITIES.MULTIPLE_IMPORT;
pub const VSS_PRV_CAPABILITY_RECYCLING = VSS_PROVIDER_CAPABILITIES.RECYCLING;
pub const VSS_PRV_CAPABILITY_PLEX = VSS_PROVIDER_CAPABILITIES.PLEX;
pub const VSS_PRV_CAPABILITY_DIFFERENTIAL = VSS_PROVIDER_CAPABILITIES.DIFFERENTIAL;
pub const VSS_PRV_CAPABILITY_CLUSTERED = VSS_PROVIDER_CAPABILITIES.CLUSTERED;

pub const VSS_HARDWARE_OPTIONS = extern enum(i32) {
    BREAKEX_FLAG_MASK_LUNS = 1,
    BREAKEX_FLAG_MAKE_READ_WRITE = 2,
    BREAKEX_FLAG_REVERT_IDENTITY_ALL = 4,
    BREAKEX_FLAG_REVERT_IDENTITY_NONE = 8,
    ONLUNSTATECHANGE_NOTIFY_READ_WRITE = 256,
    ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY = 512,
    ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY = 1024,
    ONLUNSTATECHANGE_DO_MASK_LUNS = 2048,
};
pub const VSS_BREAKEX_FLAG_MASK_LUNS = VSS_HARDWARE_OPTIONS.BREAKEX_FLAG_MASK_LUNS;
pub const VSS_BREAKEX_FLAG_MAKE_READ_WRITE = VSS_HARDWARE_OPTIONS.BREAKEX_FLAG_MAKE_READ_WRITE;
pub const VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL = VSS_HARDWARE_OPTIONS.BREAKEX_FLAG_REVERT_IDENTITY_ALL;
pub const VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE = VSS_HARDWARE_OPTIONS.BREAKEX_FLAG_REVERT_IDENTITY_NONE;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE = VSS_HARDWARE_OPTIONS.ONLUNSTATECHANGE_NOTIFY_READ_WRITE;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY = VSS_HARDWARE_OPTIONS.ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY = VSS_HARDWARE_OPTIONS.ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY;
pub const VSS_ONLUNSTATECHANGE_DO_MASK_LUNS = VSS_HARDWARE_OPTIONS.ONLUNSTATECHANGE_DO_MASK_LUNS;

pub const VSS_RECOVERY_OPTIONS = extern enum(i32) {
    REVERT_IDENTITY_ALL = 256,
    NO_VOLUME_CHECK = 512,
};
pub const VSS_RECOVERY_REVERT_IDENTITY_ALL = VSS_RECOVERY_OPTIONS.REVERT_IDENTITY_ALL;
pub const VSS_RECOVERY_NO_VOLUME_CHECK = VSS_RECOVERY_OPTIONS.NO_VOLUME_CHECK;

pub const VSS_WRITER_STATE = extern enum(i32) {
    UNKNOWN = 0,
    STABLE = 1,
    WAITING_FOR_FREEZE = 2,
    WAITING_FOR_THAW = 3,
    WAITING_FOR_POST_SNAPSHOT = 4,
    WAITING_FOR_BACKUP_COMPLETE = 5,
    FAILED_AT_IDENTIFY = 6,
    FAILED_AT_PREPARE_BACKUP = 7,
    FAILED_AT_PREPARE_SNAPSHOT = 8,
    FAILED_AT_FREEZE = 9,
    FAILED_AT_THAW = 10,
    FAILED_AT_POST_SNAPSHOT = 11,
    FAILED_AT_BACKUP_COMPLETE = 12,
    FAILED_AT_PRE_RESTORE = 13,
    FAILED_AT_POST_RESTORE = 14,
    FAILED_AT_BACKUPSHUTDOWN = 15,
    COUNT = 16,
};
pub const VSS_WS_UNKNOWN = VSS_WRITER_STATE.UNKNOWN;
pub const VSS_WS_STABLE = VSS_WRITER_STATE.STABLE;
pub const VSS_WS_WAITING_FOR_FREEZE = VSS_WRITER_STATE.WAITING_FOR_FREEZE;
pub const VSS_WS_WAITING_FOR_THAW = VSS_WRITER_STATE.WAITING_FOR_THAW;
pub const VSS_WS_WAITING_FOR_POST_SNAPSHOT = VSS_WRITER_STATE.WAITING_FOR_POST_SNAPSHOT;
pub const VSS_WS_WAITING_FOR_BACKUP_COMPLETE = VSS_WRITER_STATE.WAITING_FOR_BACKUP_COMPLETE;
pub const VSS_WS_FAILED_AT_IDENTIFY = VSS_WRITER_STATE.FAILED_AT_IDENTIFY;
pub const VSS_WS_FAILED_AT_PREPARE_BACKUP = VSS_WRITER_STATE.FAILED_AT_PREPARE_BACKUP;
pub const VSS_WS_FAILED_AT_PREPARE_SNAPSHOT = VSS_WRITER_STATE.FAILED_AT_PREPARE_SNAPSHOT;
pub const VSS_WS_FAILED_AT_FREEZE = VSS_WRITER_STATE.FAILED_AT_FREEZE;
pub const VSS_WS_FAILED_AT_THAW = VSS_WRITER_STATE.FAILED_AT_THAW;
pub const VSS_WS_FAILED_AT_POST_SNAPSHOT = VSS_WRITER_STATE.FAILED_AT_POST_SNAPSHOT;
pub const VSS_WS_FAILED_AT_BACKUP_COMPLETE = VSS_WRITER_STATE.FAILED_AT_BACKUP_COMPLETE;
pub const VSS_WS_FAILED_AT_PRE_RESTORE = VSS_WRITER_STATE.FAILED_AT_PRE_RESTORE;
pub const VSS_WS_FAILED_AT_POST_RESTORE = VSS_WRITER_STATE.FAILED_AT_POST_RESTORE;
pub const VSS_WS_FAILED_AT_BACKUPSHUTDOWN = VSS_WRITER_STATE.FAILED_AT_BACKUPSHUTDOWN;
pub const VSS_WS_COUNT = VSS_WRITER_STATE.COUNT;

pub const VSS_BACKUP_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    FULL = 1,
    INCREMENTAL = 2,
    DIFFERENTIAL = 3,
    LOG = 4,
    COPY = 5,
    OTHER = 6,
};
pub const VSS_BT_UNDEFINED = VSS_BACKUP_TYPE.UNDEFINED;
pub const VSS_BT_FULL = VSS_BACKUP_TYPE.FULL;
pub const VSS_BT_INCREMENTAL = VSS_BACKUP_TYPE.INCREMENTAL;
pub const VSS_BT_DIFFERENTIAL = VSS_BACKUP_TYPE.DIFFERENTIAL;
pub const VSS_BT_LOG = VSS_BACKUP_TYPE.LOG;
pub const VSS_BT_COPY = VSS_BACKUP_TYPE.COPY;
pub const VSS_BT_OTHER = VSS_BACKUP_TYPE.OTHER;

pub const VSS_RESTORE_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    BY_COPY = 1,
    IMPORT = 2,
    OTHER = 3,
};
pub const VSS_RTYPE_UNDEFINED = VSS_RESTORE_TYPE.UNDEFINED;
pub const VSS_RTYPE_BY_COPY = VSS_RESTORE_TYPE.BY_COPY;
pub const VSS_RTYPE_IMPORT = VSS_RESTORE_TYPE.IMPORT;
pub const VSS_RTYPE_OTHER = VSS_RESTORE_TYPE.OTHER;

pub const VSS_ROLLFORWARD_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    NONE = 1,
    ALL = 2,
    PARTIAL = 3,
};
pub const VSS_RF_UNDEFINED = VSS_ROLLFORWARD_TYPE.UNDEFINED;
pub const VSS_RF_NONE = VSS_ROLLFORWARD_TYPE.NONE;
pub const VSS_RF_ALL = VSS_ROLLFORWARD_TYPE.ALL;
pub const VSS_RF_PARTIAL = VSS_ROLLFORWARD_TYPE.PARTIAL;

pub const VSS_PROVIDER_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    SYSTEM = 1,
    SOFTWARE = 2,
    HARDWARE = 3,
    FILESHARE = 4,
};
pub const VSS_PROV_UNKNOWN = VSS_PROVIDER_TYPE.UNKNOWN;
pub const VSS_PROV_SYSTEM = VSS_PROVIDER_TYPE.SYSTEM;
pub const VSS_PROV_SOFTWARE = VSS_PROVIDER_TYPE.SOFTWARE;
pub const VSS_PROV_HARDWARE = VSS_PROVIDER_TYPE.HARDWARE;
pub const VSS_PROV_FILESHARE = VSS_PROVIDER_TYPE.FILESHARE;

pub const VSS_APPLICATION_LEVEL = extern enum(i32) {
    UNKNOWN = 0,
    SYSTEM = 1,
    BACK_END = 2,
    FRONT_END = 3,
    SYSTEM_RM = 4,
    AUTO = -1,
};
pub const VSS_APP_UNKNOWN = VSS_APPLICATION_LEVEL.UNKNOWN;
pub const VSS_APP_SYSTEM = VSS_APPLICATION_LEVEL.SYSTEM;
pub const VSS_APP_BACK_END = VSS_APPLICATION_LEVEL.BACK_END;
pub const VSS_APP_FRONT_END = VSS_APPLICATION_LEVEL.FRONT_END;
pub const VSS_APP_SYSTEM_RM = VSS_APPLICATION_LEVEL.SYSTEM_RM;
pub const VSS_APP_AUTO = VSS_APPLICATION_LEVEL.AUTO;

pub const VSS_SNAPSHOT_COMPATIBILITY = extern enum(i32) {
    DEFRAG = 1,
    CONTENTINDEX = 2,
};
pub const VSS_SC_DISABLE_DEFRAG = VSS_SNAPSHOT_COMPATIBILITY.DEFRAG;
pub const VSS_SC_DISABLE_CONTENTINDEX = VSS_SNAPSHOT_COMPATIBILITY.CONTENTINDEX;

pub const VSS_SNAPSHOT_PROPERTY_ID = extern enum(i32) {
    UNKNOWN = 0,
    SNAPSHOT_ID = 1,
    SNAPSHOT_SET_ID = 2,
    SNAPSHOTS_COUNT = 3,
    SNAPSHOT_DEVICE = 4,
    ORIGINAL_VOLUME = 5,
    ORIGINATING_MACHINE = 6,
    SERVICE_MACHINE = 7,
    EXPOSED_NAME = 8,
    EXPOSED_PATH = 9,
    PROVIDER_ID = 10,
    SNAPSHOT_ATTRIBUTES = 11,
    CREATION_TIMESTAMP = 12,
    STATUS = 13,
};
pub const VSS_SPROPID_UNKNOWN = VSS_SNAPSHOT_PROPERTY_ID.UNKNOWN;
pub const VSS_SPROPID_SNAPSHOT_ID = VSS_SNAPSHOT_PROPERTY_ID.SNAPSHOT_ID;
pub const VSS_SPROPID_SNAPSHOT_SET_ID = VSS_SNAPSHOT_PROPERTY_ID.SNAPSHOT_SET_ID;
pub const VSS_SPROPID_SNAPSHOTS_COUNT = VSS_SNAPSHOT_PROPERTY_ID.SNAPSHOTS_COUNT;
pub const VSS_SPROPID_SNAPSHOT_DEVICE = VSS_SNAPSHOT_PROPERTY_ID.SNAPSHOT_DEVICE;
pub const VSS_SPROPID_ORIGINAL_VOLUME = VSS_SNAPSHOT_PROPERTY_ID.ORIGINAL_VOLUME;
pub const VSS_SPROPID_ORIGINATING_MACHINE = VSS_SNAPSHOT_PROPERTY_ID.ORIGINATING_MACHINE;
pub const VSS_SPROPID_SERVICE_MACHINE = VSS_SNAPSHOT_PROPERTY_ID.SERVICE_MACHINE;
pub const VSS_SPROPID_EXPOSED_NAME = VSS_SNAPSHOT_PROPERTY_ID.EXPOSED_NAME;
pub const VSS_SPROPID_EXPOSED_PATH = VSS_SNAPSHOT_PROPERTY_ID.EXPOSED_PATH;
pub const VSS_SPROPID_PROVIDER_ID = VSS_SNAPSHOT_PROPERTY_ID.PROVIDER_ID;
pub const VSS_SPROPID_SNAPSHOT_ATTRIBUTES = VSS_SNAPSHOT_PROPERTY_ID.SNAPSHOT_ATTRIBUTES;
pub const VSS_SPROPID_CREATION_TIMESTAMP = VSS_SNAPSHOT_PROPERTY_ID.CREATION_TIMESTAMP;
pub const VSS_SPROPID_STATUS = VSS_SNAPSHOT_PROPERTY_ID.STATUS;

pub const VSS_FILE_SPEC_BACKUP_TYPE = extern enum(i32) {
    FULL_BACKUP_REQUIRED = 1,
    DIFFERENTIAL_BACKUP_REQUIRED = 2,
    INCREMENTAL_BACKUP_REQUIRED = 4,
    LOG_BACKUP_REQUIRED = 8,
    FULL_SNAPSHOT_REQUIRED = 256,
    DIFFERENTIAL_SNAPSHOT_REQUIRED = 512,
    INCREMENTAL_SNAPSHOT_REQUIRED = 1024,
    LOG_SNAPSHOT_REQUIRED = 2048,
    CREATED_DURING_BACKUP = 65536,
    ALL_BACKUP_REQUIRED = 15,
    ALL_SNAPSHOT_REQUIRED = 3840,
};
pub const VSS_FSBT_FULL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.FULL_BACKUP_REQUIRED;
pub const VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.DIFFERENTIAL_BACKUP_REQUIRED;
pub const VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.INCREMENTAL_BACKUP_REQUIRED;
pub const VSS_FSBT_LOG_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.LOG_BACKUP_REQUIRED;
pub const VSS_FSBT_FULL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.FULL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.DIFFERENTIAL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.INCREMENTAL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_LOG_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.LOG_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_CREATED_DURING_BACKUP = VSS_FILE_SPEC_BACKUP_TYPE.CREATED_DURING_BACKUP;
pub const VSS_FSBT_ALL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.ALL_BACKUP_REQUIRED;
pub const VSS_FSBT_ALL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.ALL_SNAPSHOT_REQUIRED;

pub const VSS_BACKUP_SCHEMA = extern enum(i32) {
    UNDEFINED = 0,
    DIFFERENTIAL = 1,
    INCREMENTAL = 2,
    EXCLUSIVE_INCREMENTAL_DIFFERENTIAL = 4,
    LOG = 8,
    COPY = 16,
    TIMESTAMPED = 32,
    LAST_MODIFY = 64,
    LSN = 128,
    WRITER_SUPPORTS_NEW_TARGET = 256,
    WRITER_SUPPORTS_RESTORE_WITH_MOVE = 512,
    INDEPENDENT_SYSTEM_STATE = 1024,
    ROLLFORWARD_RESTORE = 4096,
    RESTORE_RENAME = 8192,
    AUTHORITATIVE_RESTORE = 16384,
    WRITER_SUPPORTS_PARALLEL_RESTORES = 32768,
};
pub const VSS_BS_UNDEFINED = VSS_BACKUP_SCHEMA.UNDEFINED;
pub const VSS_BS_DIFFERENTIAL = VSS_BACKUP_SCHEMA.DIFFERENTIAL;
pub const VSS_BS_INCREMENTAL = VSS_BACKUP_SCHEMA.INCREMENTAL;
pub const VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL = VSS_BACKUP_SCHEMA.EXCLUSIVE_INCREMENTAL_DIFFERENTIAL;
pub const VSS_BS_LOG = VSS_BACKUP_SCHEMA.LOG;
pub const VSS_BS_COPY = VSS_BACKUP_SCHEMA.COPY;
pub const VSS_BS_TIMESTAMPED = VSS_BACKUP_SCHEMA.TIMESTAMPED;
pub const VSS_BS_LAST_MODIFY = VSS_BACKUP_SCHEMA.LAST_MODIFY;
pub const VSS_BS_LSN = VSS_BACKUP_SCHEMA.LSN;
pub const VSS_BS_WRITER_SUPPORTS_NEW_TARGET = VSS_BACKUP_SCHEMA.WRITER_SUPPORTS_NEW_TARGET;
pub const VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE = VSS_BACKUP_SCHEMA.WRITER_SUPPORTS_RESTORE_WITH_MOVE;
pub const VSS_BS_INDEPENDENT_SYSTEM_STATE = VSS_BACKUP_SCHEMA.INDEPENDENT_SYSTEM_STATE;
pub const VSS_BS_ROLLFORWARD_RESTORE = VSS_BACKUP_SCHEMA.ROLLFORWARD_RESTORE;
pub const VSS_BS_RESTORE_RENAME = VSS_BACKUP_SCHEMA.RESTORE_RENAME;
pub const VSS_BS_AUTHORITATIVE_RESTORE = VSS_BACKUP_SCHEMA.AUTHORITATIVE_RESTORE;
pub const VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES = VSS_BACKUP_SCHEMA.WRITER_SUPPORTS_PARALLEL_RESTORES;

pub const VSS_SNAPSHOT_PROP = extern struct {
    m_SnapshotId: Guid,
    m_SnapshotSetId: Guid,
    m_lSnapshotsCount: i32,
    m_pwszSnapshotDeviceObject: *u16,
    m_pwszOriginalVolumeName: *u16,
    m_pwszOriginatingMachine: *u16,
    m_pwszServiceMachine: *u16,
    m_pwszExposedName: *u16,
    m_pwszExposedPath: *u16,
    m_ProviderId: Guid,
    m_lSnapshotAttributes: i32,
    m_tsCreationTimestamp: i64,
    m_eStatus: VSS_SNAPSHOT_STATE,
};

pub const VSS_PROVIDER_PROP = extern struct {
    m_ProviderId: Guid,
    m_pwszProviderName: *u16,
    m_eProviderType: VSS_PROVIDER_TYPE,
    m_pwszProviderVersion: *u16,
    m_ProviderVersionId: Guid,
    m_ClassId: Guid,
};

pub const VSS_OBJECT_UNION = extern union {
    Snap: VSS_SNAPSHOT_PROP,
    Prov: VSS_PROVIDER_PROP,
};

pub const VSS_OBJECT_PROP = extern struct {
    Type: VSS_OBJECT_TYPE,
    Obj: VSS_OBJECT_UNION,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVssEnumObject_Value = @import("../zig.zig").Guid.initString("ae1c7110-2f60-11d3-8a39-00c04f72d8e3");
pub const IID_IVssEnumObject = &IID_IVssEnumObject_Value;
pub const IVssEnumObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IVssEnumObject,
            celt: u32,
            rgelt: [*]VSS_OBJECT_PROP,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IVssEnumObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IVssEnumObject,
            ppenum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Next(self: *const T, celt: u32, rgelt: [*]VSS_OBJECT_PROP, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Next(@ptrCast(*const IVssEnumObject, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Skip(@ptrCast(*const IVssEnumObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Reset(@ptrCast(*const IVssEnumObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Clone(self: *const T, ppenum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Clone(@ptrCast(*const IVssEnumObject, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVssAsync_Value = @import("../zig.zig").Guid.initString("507c37b4-cf5b-4e95-b0af-14eb9767467e");
pub const IID_IVssAsync = &IID_IVssAsync_Value;
pub const IVssAsync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Wait: fn(
            self: *const IVssAsync,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatus: fn(
            self: *const IVssAsync,
            pHrResult: *HRESULT,
            pReserved: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).Cancel(@ptrCast(*const IVssAsync, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_Wait(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).Wait(@ptrCast(*const IVssAsync, self), dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_QueryStatus(self: *const T, pHrResult: *HRESULT, pReserved: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).QueryStatus(@ptrCast(*const IVssAsync, self), pHrResult, pReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VSS_USAGE_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    BOOTABLESYSTEMSTATE = 1,
    SYSTEMSERVICE = 2,
    USERDATA = 3,
    OTHER = 4,
};
pub const VSS_UT_UNDEFINED = VSS_USAGE_TYPE.UNDEFINED;
pub const VSS_UT_BOOTABLESYSTEMSTATE = VSS_USAGE_TYPE.BOOTABLESYSTEMSTATE;
pub const VSS_UT_SYSTEMSERVICE = VSS_USAGE_TYPE.SYSTEMSERVICE;
pub const VSS_UT_USERDATA = VSS_USAGE_TYPE.USERDATA;
pub const VSS_UT_OTHER = VSS_USAGE_TYPE.OTHER;

pub const VSS_SOURCE_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    TRANSACTEDDB = 1,
    NONTRANSACTEDDB = 2,
    OTHER = 3,
};
pub const VSS_ST_UNDEFINED = VSS_SOURCE_TYPE.UNDEFINED;
pub const VSS_ST_TRANSACTEDDB = VSS_SOURCE_TYPE.TRANSACTEDDB;
pub const VSS_ST_NONTRANSACTEDDB = VSS_SOURCE_TYPE.NONTRANSACTEDDB;
pub const VSS_ST_OTHER = VSS_SOURCE_TYPE.OTHER;

pub const VSS_RESTOREMETHOD_ENUM = extern enum(i32) {
    UNDEFINED = 0,
    RESTORE_IF_NOT_THERE = 1,
    RESTORE_IF_CAN_REPLACE = 2,
    STOP_RESTORE_START = 3,
    RESTORE_TO_ALTERNATE_LOCATION = 4,
    RESTORE_AT_REBOOT = 5,
    RESTORE_AT_REBOOT_IF_CANNOT_REPLACE = 6,
    CUSTOM = 7,
    RESTORE_STOP_START = 8,
};
pub const VSS_RME_UNDEFINED = VSS_RESTOREMETHOD_ENUM.UNDEFINED;
pub const VSS_RME_RESTORE_IF_NOT_THERE = VSS_RESTOREMETHOD_ENUM.RESTORE_IF_NOT_THERE;
pub const VSS_RME_RESTORE_IF_CAN_REPLACE = VSS_RESTOREMETHOD_ENUM.RESTORE_IF_CAN_REPLACE;
pub const VSS_RME_STOP_RESTORE_START = VSS_RESTOREMETHOD_ENUM.STOP_RESTORE_START;
pub const VSS_RME_RESTORE_TO_ALTERNATE_LOCATION = VSS_RESTOREMETHOD_ENUM.RESTORE_TO_ALTERNATE_LOCATION;
pub const VSS_RME_RESTORE_AT_REBOOT = VSS_RESTOREMETHOD_ENUM.RESTORE_AT_REBOOT;
pub const VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE = VSS_RESTOREMETHOD_ENUM.RESTORE_AT_REBOOT_IF_CANNOT_REPLACE;
pub const VSS_RME_CUSTOM = VSS_RESTOREMETHOD_ENUM.CUSTOM;
pub const VSS_RME_RESTORE_STOP_START = VSS_RESTOREMETHOD_ENUM.RESTORE_STOP_START;

pub const VSS_WRITERRESTORE_ENUM = extern enum(i32) {
    UNDEFINED = 0,
    NEVER = 1,
    IF_REPLACE_FAILS = 2,
    ALWAYS = 3,
};
pub const VSS_WRE_UNDEFINED = VSS_WRITERRESTORE_ENUM.UNDEFINED;
pub const VSS_WRE_NEVER = VSS_WRITERRESTORE_ENUM.NEVER;
pub const VSS_WRE_IF_REPLACE_FAILS = VSS_WRITERRESTORE_ENUM.IF_REPLACE_FAILS;
pub const VSS_WRE_ALWAYS = VSS_WRITERRESTORE_ENUM.ALWAYS;

pub const VSS_COMPONENT_TYPE = extern enum(i32) {
    UNDEFINED = 0,
    DATABASE = 1,
    FILEGROUP = 2,
};
pub const VSS_CT_UNDEFINED = VSS_COMPONENT_TYPE.UNDEFINED;
pub const VSS_CT_DATABASE = VSS_COMPONENT_TYPE.DATABASE;
pub const VSS_CT_FILEGROUP = VSS_COMPONENT_TYPE.FILEGROUP;

pub const VSS_ALTERNATE_WRITER_STATE = extern enum(i32) {
    UNDEFINED = 0,
    NO_ALTERNATE_WRITER = 1,
    ALTERNATE_WRITER_EXISTS = 2,
    THIS_IS_ALTERNATE_WRITER = 3,
};
pub const VSS_AWS_UNDEFINED = VSS_ALTERNATE_WRITER_STATE.UNDEFINED;
pub const VSS_AWS_NO_ALTERNATE_WRITER = VSS_ALTERNATE_WRITER_STATE.NO_ALTERNATE_WRITER;
pub const VSS_AWS_ALTERNATE_WRITER_EXISTS = VSS_ALTERNATE_WRITER_STATE.ALTERNATE_WRITER_EXISTS;
pub const VSS_AWS_THIS_IS_ALTERNATE_WRITER = VSS_ALTERNATE_WRITER_STATE.THIS_IS_ALTERNATE_WRITER;

pub const VSS_SUBSCRIBE_MASK = extern enum(i32) {
    POST_SNAPSHOT_FLAG = 1,
    BACKUP_EVENTS_FLAG = 2,
    RESTORE_EVENTS_FLAG = 4,
    IO_THROTTLING_FLAG = 8,
    ALL_FLAGS = -1,
};
pub const VSS_SM_POST_SNAPSHOT_FLAG = VSS_SUBSCRIBE_MASK.POST_SNAPSHOT_FLAG;
pub const VSS_SM_BACKUP_EVENTS_FLAG = VSS_SUBSCRIBE_MASK.BACKUP_EVENTS_FLAG;
pub const VSS_SM_RESTORE_EVENTS_FLAG = VSS_SUBSCRIBE_MASK.RESTORE_EVENTS_FLAG;
pub const VSS_SM_IO_THROTTLING_FLAG = VSS_SUBSCRIBE_MASK.IO_THROTTLING_FLAG;
pub const VSS_SM_ALL_FLAGS = VSS_SUBSCRIBE_MASK.ALL_FLAGS;

pub const VSS_RESTORE_TARGET = extern enum(i32) {
    UNDEFINED = 0,
    ORIGINAL = 1,
    ALTERNATE = 2,
    DIRECTED = 3,
    ORIGINAL_LOCATION = 4,
};
pub const VSS_RT_UNDEFINED = VSS_RESTORE_TARGET.UNDEFINED;
pub const VSS_RT_ORIGINAL = VSS_RESTORE_TARGET.ORIGINAL;
pub const VSS_RT_ALTERNATE = VSS_RESTORE_TARGET.ALTERNATE;
pub const VSS_RT_DIRECTED = VSS_RESTORE_TARGET.DIRECTED;
pub const VSS_RT_ORIGINAL_LOCATION = VSS_RESTORE_TARGET.ORIGINAL_LOCATION;

pub const VSS_FILE_RESTORE_STATUS = extern enum(i32) {
    UNDEFINED = 0,
    NONE = 1,
    ALL = 2,
    FAILED = 3,
};
pub const VSS_RS_UNDEFINED = VSS_FILE_RESTORE_STATUS.UNDEFINED;
pub const VSS_RS_NONE = VSS_FILE_RESTORE_STATUS.NONE;
pub const VSS_RS_ALL = VSS_FILE_RESTORE_STATUS.ALL;
pub const VSS_RS_FAILED = VSS_FILE_RESTORE_STATUS.FAILED;

pub const VSS_COMPONENT_FLAGS = extern enum(i32) {
    BACKUP_RECOVERY = 1,
    APP_ROLLBACK_RECOVERY = 2,
    NOT_SYSTEM_STATE = 4,
};
pub const VSS_CF_BACKUP_RECOVERY = VSS_COMPONENT_FLAGS.BACKUP_RECOVERY;
pub const VSS_CF_APP_ROLLBACK_RECOVERY = VSS_COMPONENT_FLAGS.APP_ROLLBACK_RECOVERY;
pub const VSS_CF_NOT_SYSTEM_STATE = VSS_COMPONENT_FLAGS.NOT_SYSTEM_STATE;

pub const IVssWMFiledesc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: fn(
            self: *const IVssWMFiledesc,
            pbstrPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilespec: fn(
            self: *const IVssWMFiledesc,
            pbstrFilespec: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecursive: fn(
            self: *const IVssWMFiledesc,
            pbRecursive: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocation: fn(
            self: *const IVssWMFiledesc,
            pbstrAlternateLocation: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupTypeMask: fn(
            self: *const IVssWMFiledesc,
            pdwTypeMask: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetPath(self: *const T, pbstrPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetPath(@ptrCast(*const IVssWMFiledesc, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetFilespec(self: *const T, pbstrFilespec: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetFilespec(@ptrCast(*const IVssWMFiledesc, self), pbstrFilespec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetRecursive(self: *const T, pbRecursive: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetRecursive(@ptrCast(*const IVssWMFiledesc, self), pbRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetAlternateLocation(self: *const T, pbstrAlternateLocation: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetAlternateLocation(@ptrCast(*const IVssWMFiledesc, self), pbstrAlternateLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetBackupTypeMask(self: *const T, pdwTypeMask: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetBackupTypeMask(@ptrCast(*const IVssWMFiledesc, self), pdwTypeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWMDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWriterId: fn(
            self: *const IVssWMDependency,
            pWriterId: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogicalPath: fn(
            self: *const IVssWMDependency,
            pbstrLogicalPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentName: fn(
            self: *const IVssWMDependency,
            pbstrComponentName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetWriterId(self: *const T, pWriterId: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetWriterId(@ptrCast(*const IVssWMDependency, self), pWriterId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetLogicalPath(self: *const T, pbstrLogicalPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetLogicalPath(@ptrCast(*const IVssWMDependency, self), pbstrLogicalPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetComponentName(self: *const T, pbstrComponentName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetComponentName(@ptrCast(*const IVssWMDependency, self), pbstrComponentName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponent_Value = @import("../zig.zig").Guid.initString("d2c72c96-c121-4518-b627-e5a93d010ead");
pub const IID_IVssComponent = &IID_IVssComponent_Value;
pub const IVssComponent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLogicalPath: fn(
            self: *const IVssComponent,
            pbstrPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: fn(
            self: *const IVssComponent,
            pct: *VSS_COMPONENT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentName: fn(
            self: *const IVssComponent,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupSucceeded: fn(
            self: *const IVssComponent,
            pbSucceeded: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocationMappingCount: fn(
            self: *const IVssComponent,
            pcMappings: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocationMapping: fn(
            self: *const IVssComponent,
            iMapping: u32,
            ppFiledesc: **IVssWMFiledesc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupMetadata: fn(
            self: *const IVssComponent,
            wszData: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupMetadata: fn(
            self: *const IVssComponent,
            pbstrData: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPartialFile: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilename: [*:0]const u16,
            wszRanges: [*:0]const u16,
            wszMetadata: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartialFileCount: fn(
            self: *const IVssComponent,
            pcPartialFiles: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartialFile: fn(
            self: *const IVssComponent,
            iPartialFile: u32,
            pbstrPath: *BSTR,
            pbstrFilename: *BSTR,
            pbstrRange: *BSTR,
            pbstrMetadata: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSelectedForRestore: fn(
            self: *const IVssComponent,
            pbSelectedForRestore: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdditionalRestores: fn(
            self: *const IVssComponent,
            pbAdditionalRestores: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewTargetCount: fn(
            self: *const IVssComponent,
            pcNewTarget: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewTarget: fn(
            self: *const IVssComponent,
            iNewTarget: u32,
            ppFiledesc: **IVssWMFiledesc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDirectedTarget: fn(
            self: *const IVssComponent,
            wszSourcePath: [*:0]const u16,
            wszSourceFilename: [*:0]const u16,
            wszSourceRangeList: [*:0]const u16,
            wszDestinationPath: [*:0]const u16,
            wszDestinationFilename: [*:0]const u16,
            wszDestinationRangeList: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectedTargetCount: fn(
            self: *const IVssComponent,
            pcDirectedTarget: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectedTarget: fn(
            self: *const IVssComponent,
            iDirectedTarget: u32,
            pbstrSourcePath: *BSTR,
            pbstrSourceFileName: *BSTR,
            pbstrSourceRangeList: *BSTR,
            pbstrDestinationPath: *BSTR,
            pbstrDestinationFilename: *BSTR,
            pbstrDestinationRangeList: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMetadata: fn(
            self: *const IVssComponent,
            wszRestoreMetadata: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreMetadata: fn(
            self: *const IVssComponent,
            pbstrRestoreMetadata: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreTarget: fn(
            self: *const IVssComponent,
            target: VSS_RESTORE_TARGET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreTarget: fn(
            self: *const IVssComponent,
            pTarget: *VSS_RESTORE_TARGET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreRestoreFailureMsg: fn(
            self: *const IVssComponent,
            wszPreRestoreFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreRestoreFailureMsg: fn(
            self: *const IVssComponent,
            pbstrPreRestoreFailureMsg: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPostRestoreFailureMsg: fn(
            self: *const IVssComponent,
            wszPostRestoreFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPostRestoreFailureMsg: fn(
            self: *const IVssComponent,
            pbstrPostRestoreFailureMsg: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStamp: fn(
            self: *const IVssComponent,
            wszBackupStamp: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStamp: fn(
            self: *const IVssComponent,
            pbstrBackupStamp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousBackupStamp: fn(
            self: *const IVssComponent,
            pbstrBackupStamp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupOptions: fn(
            self: *const IVssComponent,
            pbstrBackupOptions: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreOptions: fn(
            self: *const IVssComponent,
            pbstrRestoreOptions: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreSubcomponentCount: fn(
            self: *const IVssComponent,
            pcRestoreSubcomponent: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreSubcomponent: fn(
            self: *const IVssComponent,
            iComponent: u32,
            pbstrLogicalPath: *BSTR,
            pbstrComponentName: *BSTR,
            pbRepair: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileRestoreStatus: fn(
            self: *const IVssComponent,
            pStatus: *VSS_FILE_RESTORE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDifferencedFilesByLastModifyTime: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: BOOL,
            ftLastModifyTime: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDifferencedFilesByLastModifyLSN: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: BOOL,
            bstrLsnString: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDifferencedFilesCount: fn(
            self: *const IVssComponent,
            pcDifferencedFiles: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDifferencedFile: fn(
            self: *const IVssComponent,
            iDifferencedFile: u32,
            pbstrPath: *BSTR,
            pbstrFilespec: *BSTR,
            pbRecursive: *BOOL,
            pbstrLsnString: *BSTR,
            pftLastModifyTime: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetLogicalPath(self: *const T, pbstrPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetLogicalPath(@ptrCast(*const IVssComponent, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetComponentType(self: *const T, pct: *VSS_COMPONENT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetComponentType(@ptrCast(*const IVssComponent, self), pct);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetComponentName(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetComponentName(@ptrCast(*const IVssComponent, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupSucceeded(self: *const T, pbSucceeded: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupSucceeded(@ptrCast(*const IVssComponent, self), pbSucceeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAlternateLocationMappingCount(self: *const T, pcMappings: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAlternateLocationMappingCount(@ptrCast(*const IVssComponent, self), pcMappings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAlternateLocationMapping(self: *const T, iMapping: u32, ppFiledesc: **IVssWMFiledesc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAlternateLocationMapping(@ptrCast(*const IVssComponent, self), iMapping, ppFiledesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetBackupMetadata(self: *const T, wszData: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetBackupMetadata(@ptrCast(*const IVssComponent, self), wszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupMetadata(self: *const T, pbstrData: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupMetadata(@ptrCast(*const IVssComponent, self), pbstrData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddPartialFile(self: *const T, wszPath: [*:0]const u16, wszFilename: [*:0]const u16, wszRanges: [*:0]const u16, wszMetadata: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddPartialFile(@ptrCast(*const IVssComponent, self), wszPath, wszFilename, wszRanges, wszMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPartialFileCount(self: *const T, pcPartialFiles: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPartialFileCount(@ptrCast(*const IVssComponent, self), pcPartialFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPartialFile(self: *const T, iPartialFile: u32, pbstrPath: *BSTR, pbstrFilename: *BSTR, pbstrRange: *BSTR, pbstrMetadata: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPartialFile(@ptrCast(*const IVssComponent, self), iPartialFile, pbstrPath, pbstrFilename, pbstrRange, pbstrMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_IsSelectedForRestore(self: *const T, pbSelectedForRestore: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).IsSelectedForRestore(@ptrCast(*const IVssComponent, self), pbSelectedForRestore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAdditionalRestores(self: *const T, pbAdditionalRestores: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAdditionalRestores(@ptrCast(*const IVssComponent, self), pbAdditionalRestores);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetNewTargetCount(self: *const T, pcNewTarget: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetNewTargetCount(@ptrCast(*const IVssComponent, self), pcNewTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetNewTarget(self: *const T, iNewTarget: u32, ppFiledesc: **IVssWMFiledesc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetNewTarget(@ptrCast(*const IVssComponent, self), iNewTarget, ppFiledesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDirectedTarget(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilename: [*:0]const u16, wszSourceRangeList: [*:0]const u16, wszDestinationPath: [*:0]const u16, wszDestinationFilename: [*:0]const u16, wszDestinationRangeList: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDirectedTarget(@ptrCast(*const IVssComponent, self), wszSourcePath, wszSourceFilename, wszSourceRangeList, wszDestinationPath, wszDestinationFilename, wszDestinationRangeList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDirectedTargetCount(self: *const T, pcDirectedTarget: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDirectedTargetCount(@ptrCast(*const IVssComponent, self), pcDirectedTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDirectedTarget(self: *const T, iDirectedTarget: u32, pbstrSourcePath: *BSTR, pbstrSourceFileName: *BSTR, pbstrSourceRangeList: *BSTR, pbstrDestinationPath: *BSTR, pbstrDestinationFilename: *BSTR, pbstrDestinationRangeList: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDirectedTarget(@ptrCast(*const IVssComponent, self), iDirectedTarget, pbstrSourcePath, pbstrSourceFileName, pbstrSourceRangeList, pbstrDestinationPath, pbstrDestinationFilename, pbstrDestinationRangeList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetRestoreMetadata(self: *const T, wszRestoreMetadata: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetRestoreMetadata(@ptrCast(*const IVssComponent, self), wszRestoreMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreMetadata(self: *const T, pbstrRestoreMetadata: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreMetadata(@ptrCast(*const IVssComponent, self), pbstrRestoreMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetRestoreTarget(self: *const T, target: VSS_RESTORE_TARGET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetRestoreTarget(@ptrCast(*const IVssComponent, self), target);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreTarget(self: *const T, pTarget: *VSS_RESTORE_TARGET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreTarget(@ptrCast(*const IVssComponent, self), pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetPreRestoreFailureMsg(self: *const T, wszPreRestoreFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetPreRestoreFailureMsg(@ptrCast(*const IVssComponent, self), wszPreRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPreRestoreFailureMsg(self: *const T, pbstrPreRestoreFailureMsg: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPreRestoreFailureMsg(@ptrCast(*const IVssComponent, self), pbstrPreRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetPostRestoreFailureMsg(self: *const T, wszPostRestoreFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetPostRestoreFailureMsg(@ptrCast(*const IVssComponent, self), wszPostRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPostRestoreFailureMsg(self: *const T, pbstrPostRestoreFailureMsg: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPostRestoreFailureMsg(@ptrCast(*const IVssComponent, self), pbstrPostRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetBackupStamp(self: *const T, wszBackupStamp: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetBackupStamp(@ptrCast(*const IVssComponent, self), wszBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupStamp(self: *const T, pbstrBackupStamp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupStamp(@ptrCast(*const IVssComponent, self), pbstrBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPreviousBackupStamp(self: *const T, pbstrBackupStamp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPreviousBackupStamp(@ptrCast(*const IVssComponent, self), pbstrBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupOptions(self: *const T, pbstrBackupOptions: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupOptions(@ptrCast(*const IVssComponent, self), pbstrBackupOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreOptions(self: *const T, pbstrRestoreOptions: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreOptions(@ptrCast(*const IVssComponent, self), pbstrRestoreOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreSubcomponentCount(self: *const T, pcRestoreSubcomponent: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreSubcomponentCount(@ptrCast(*const IVssComponent, self), pcRestoreSubcomponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreSubcomponent(self: *const T, iComponent: u32, pbstrLogicalPath: *BSTR, pbstrComponentName: *BSTR, pbRepair: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreSubcomponent(@ptrCast(*const IVssComponent, self), iComponent, pbstrLogicalPath, pbstrComponentName, pbRepair);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetFileRestoreStatus(self: *const T, pStatus: *VSS_FILE_RESTORE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetFileRestoreStatus(@ptrCast(*const IVssComponent, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDifferencedFilesByLastModifyTime(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: BOOL, ftLastModifyTime: FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDifferencedFilesByLastModifyTime(@ptrCast(*const IVssComponent, self), wszPath, wszFilespec, bRecursive, ftLastModifyTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDifferencedFilesByLastModifyLSN(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: BOOL, bstrLsnString: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDifferencedFilesByLastModifyLSN(@ptrCast(*const IVssComponent, self), wszPath, wszFilespec, bRecursive, bstrLsnString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDifferencedFilesCount(self: *const T, pcDifferencedFiles: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDifferencedFilesCount(@ptrCast(*const IVssComponent, self), pcDifferencedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDifferencedFile(self: *const T, iDifferencedFile: u32, pbstrPath: *BSTR, pbstrFilespec: *BSTR, pbRecursive: *BOOL, pbstrLsnString: *BSTR, pftLastModifyTime: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDifferencedFile(@ptrCast(*const IVssComponent, self), iDifferencedFile, pbstrPath, pbstrFilespec, pbRecursive, pbstrLsnString, pftLastModifyTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWriterComponents = extern struct {
    pub const VTable = extern struct {
        GetComponentCount: fn(
            self: *const IVssWriterComponents,
            pcComponents: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWriterInfo: fn(
            self: *const IVssWriterComponents,
            pidInstance: *Guid,
            pidWriter: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponent: fn(
            self: *const IVssWriterComponents,
            iComponent: u32,
            ppComponent: **IVssComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetComponentCount(self: *const T, pcComponents: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetComponentCount(@ptrCast(*const IVssWriterComponents, self), pcComponents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetWriterInfo(self: *const T, pidInstance: *Guid, pidWriter: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetWriterInfo(@ptrCast(*const IVssWriterComponents, self), pidInstance, pidWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetComponent(self: *const T, iComponent: u32, ppComponent: **IVssComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetComponent(@ptrCast(*const IVssWriterComponents, self), iComponent, ppComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponentEx_Value = @import("../zig.zig").Guid.initString("156c8b5e-f131-4bd7-9c97-d1923be7e1fa");
pub const IID_IVssComponentEx = &IID_IVssComponentEx_Value;
pub const IVssComponentEx = extern struct {
    pub const VTable = extern struct {
        base: IVssComponent.VTable,
        SetPrepareForBackupFailureMsg: fn(
            self: *const IVssComponentEx,
            wszFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPostSnapshotFailureMsg: fn(
            self: *const IVssComponentEx,
            wszFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrepareForBackupFailureMsg: fn(
            self: *const IVssComponentEx,
            pbstrFailureMsg: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPostSnapshotFailureMsg: fn(
            self: *const IVssComponentEx,
            pbstrFailureMsg: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthoritativeRestore: fn(
            self: *const IVssComponentEx,
            pbAuth: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRollForward: fn(
            self: *const IVssComponentEx,
            pRollType: *VSS_ROLLFORWARD_TYPE,
            pbstrPoint: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreName: fn(
            self: *const IVssComponentEx,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_SetPrepareForBackupFailureMsg(self: *const T, wszFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).SetPrepareForBackupFailureMsg(@ptrCast(*const IVssComponentEx, self), wszFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_SetPostSnapshotFailureMsg(self: *const T, wszFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).SetPostSnapshotFailureMsg(@ptrCast(*const IVssComponentEx, self), wszFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetPrepareForBackupFailureMsg(self: *const T, pbstrFailureMsg: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetPrepareForBackupFailureMsg(@ptrCast(*const IVssComponentEx, self), pbstrFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetPostSnapshotFailureMsg(self: *const T, pbstrFailureMsg: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetPostSnapshotFailureMsg(@ptrCast(*const IVssComponentEx, self), pbstrFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetAuthoritativeRestore(self: *const T, pbAuth: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetAuthoritativeRestore(@ptrCast(*const IVssComponentEx, self), pbAuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetRollForward(self: *const T, pRollType: *VSS_ROLLFORWARD_TYPE, pbstrPoint: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetRollForward(@ptrCast(*const IVssComponentEx, self), pRollType, pbstrPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetRestoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetRestoreName(@ptrCast(*const IVssComponentEx, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponentEx2_Value = @import("../zig.zig").Guid.initString("3b5be0f2-07a9-4e4b-bdd3-cfdc8e2c0d2d");
pub const IID_IVssComponentEx2 = &IID_IVssComponentEx2_Value;
pub const IVssComponentEx2 = extern struct {
    pub const VTable = extern struct {
        base: IVssComponentEx.VTable,
        SetFailure: fn(
            self: *const IVssComponentEx2,
            hr: HRESULT,
            hrApplication: HRESULT,
            wszApplicationMessage: ?[*:0]const u16,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFailure: fn(
            self: *const IVssComponentEx2,
            phr: *HRESULT,
            phrApplication: *HRESULT,
            pbstrApplicationMessage: *BSTR,
            pdwReserved: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssComponentEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx2_SetFailure(self: *const T, hr: HRESULT, hrApplication: HRESULT, wszApplicationMessage: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx2.VTable, self.vtable).SetFailure(@ptrCast(*const IVssComponentEx2, self), hr, hrApplication, wszApplicationMessage, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx2_GetFailure(self: *const T, phr: *HRESULT, phrApplication: *HRESULT, pbstrApplicationMessage: *BSTR, pdwReserved: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx2.VTable, self.vtable).GetFailure(@ptrCast(*const IVssComponentEx2, self), phr, phrApplication, pbstrApplicationMessage, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssCreateWriterMetadata = extern struct {
    pub const VTable = extern struct {
        AddIncludeFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExcludeFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponent: fn(
            self: *const IVssCreateWriterMetadata,
            ct: VSS_COMPONENT_TYPE,
            wszLogicalPath: [*:0]const u16,
            wszComponentName: [*:0]const u16,
            wszCaption: [*:0]const u16,
            pbIcon: *const u8,
            cbIcon: u32,
            bRestoreMetadata: u8,
            bNotifyOnBackupComplete: u8,
            bSelectable: u8,
            bSelectableForRestore: u8,
            dwComponentFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseLogFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateWriterMetadata,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAlternateLocationMapping: fn(
            self: *const IVssCreateWriterMetadata,
            wszSourcePath: [*:0]const u16,
            wszSourceFilespec: [*:0]const u16,
            bRecursive: u8,
            wszDestination: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateWriterMetadata,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateWriterMetadata,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocument: fn(
            self: *const IVssCreateWriterMetadata,
            pDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateWriterMetadata,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddIncludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddIncludeFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszPath, wszFilespec, bRecursive, wszAlternateLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddExcludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddExcludeFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszPath, wszFilespec, bRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddComponent(self: *const T, ct: VSS_COMPONENT_TYPE, wszLogicalPath: [*:0]const u16, wszComponentName: [*:0]const u16, wszCaption: [*:0]const u16, pbIcon: *const u8, cbIcon: u32, bRestoreMetadata: u8, bNotifyOnBackupComplete: u8, bSelectable: u8, bSelectableForRestore: u8, dwComponentFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddComponent(@ptrCast(*const IVssCreateWriterMetadata, self), ct, wszLogicalPath, wszComponentName, wszCaption, pbIcon, cbIcon, bRestoreMetadata, bNotifyOnBackupComplete, bSelectable, bSelectableForRestore, dwComponentFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddDatabaseFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddDatabaseFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddDatabaseLogFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddDatabaseLogFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateWriterMetadata, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddAlternateLocationMapping(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilespec: [*:0]const u16, bRecursive: u8, wszDestination: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddAlternateLocationMapping(@ptrCast(*const IVssCreateWriterMetadata, self), wszSourcePath, wszSourceFilespec, bRecursive, wszDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateWriterMetadata, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateWriterMetadata, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_GetDocument(self: *const T, pDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).GetDocument(@ptrCast(*const IVssCreateWriterMetadata, self), pDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateWriterMetadata, self), pbstrXML);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssCreateWriterMetadataEx_Value = @import("../zig.zig").Guid.initString("9f21981d-d469-4349-b807-39e64e4674e1");
pub const IID_IVssCreateWriterMetadataEx = &IID_IVssCreateWriterMetadataEx_Value;
pub const IVssCreateWriterMetadataEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDatabaseFiles: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseLogFiles: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateWriterMetadataEx,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAlternateLocationMapping: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszSourcePath: [*:0]const u16,
            wszSourceFilespec: [*:0]const u16,
            bRecursive: u8,
            wszDestination: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateWriterMetadataEx,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocument: fn(
            self: *const IVssCreateWriterMetadataEx,
            pDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateWriterMetadataEx,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInterface: fn(
            self: *const IVssCreateWriterMetadataEx,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: fn(
            self: *const IVssCreateWriterMetadataEx,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: fn(
            self: *const IVssCreateWriterMetadataEx,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddExcludeFilesFromSnapshot: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddDatabaseFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddDatabaseFiles(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddDatabaseLogFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddDatabaseLogFiles(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateWriterMetadataEx, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddAlternateLocationMapping(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilespec: [*:0]const u16, bRecursive: u8, wszDestination: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddAlternateLocationMapping(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszSourcePath, wszSourceFilespec, bRecursive, wszDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateWriterMetadataEx, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_GetDocument(self: *const T, pDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).GetDocument(@ptrCast(*const IVssCreateWriterMetadataEx, self), pDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateWriterMetadataEx, self), pbstrXML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_QueryInterface(self: *const T, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).QueryInterface(@ptrCast(*const IVssCreateWriterMetadataEx, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddRef(@ptrCast(*const IVssCreateWriterMetadataEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).Release(@ptrCast(*const IVssCreateWriterMetadataEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddExcludeFilesFromSnapshot(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddExcludeFilesFromSnapshot(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszPath, wszFilespec, bRecursive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWriterImpl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IVssWriterImpl,
            writerId: Guid,
            wszWriterName: [*:0]const u16,
            wszWriterInstanceName: ?[*:0]const u16,
            dwMajorVersion: u32,
            dwMinorVersion: u32,
            ut: VSS_USAGE_TYPE,
            st: VSS_SOURCE_TYPE,
            nLevel: VSS_APPLICATION_LEVEL,
            dwTimeout: u32,
            aws: VSS_ALTERNATE_WRITER_STATE,
            bIOThrottlingOnly: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Subscribe: fn(
            self: *const IVssWriterImpl,
            dwSubscribeTimeout: u32,
            dwEventFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unsubscribe: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetCurrentVolumeArray: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) *PWSTR,
        GetCurrentVolumeCount: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetSnapshotDeviceName: fn(
            self: *const IVssWriterImpl,
            wszOriginalVolume: [*:0]const u16,
            ppwszSnapshotDevice: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSnapshotSetId: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) Guid,
        GetContext: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetCurrentLevel: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_APPLICATION_LEVEL,
        IsPathAffected: fn(
            self: *const IVssWriterImpl,
            wszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsBootableSystemStateBackedUp: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        AreComponentsSelected: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetBackupType: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_BACKUP_TYPE,
        GetRestoreType: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_RESTORE_TYPE,
        SetWriterFailure: fn(
            self: *const IVssWriterImpl,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPartialFileSupportEnabled: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        InstallAlternateWriter: fn(
            self: *const IVssWriterImpl,
            idWriter: Guid,
            clsid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentityInformation: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) *IVssExamineWriterMetadata,
        SetWriterFailureEx: fn(
            self: *const IVssWriterImpl,
            hr: HRESULT,
            hrApplication: HRESULT,
            wszApplicationMessage: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionId: fn(
            self: *const IVssWriterImpl,
            idSession: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsWriterShuttingDown: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Initialize(self: *const T, writerId: Guid, wszWriterName: [*:0]const u16, wszWriterInstanceName: ?[*:0]const u16, dwMajorVersion: u32, dwMinorVersion: u32, ut: VSS_USAGE_TYPE, st: VSS_SOURCE_TYPE, nLevel: VSS_APPLICATION_LEVEL, dwTimeout: u32, aws: VSS_ALTERNATE_WRITER_STATE, bIOThrottlingOnly: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Initialize(@ptrCast(*const IVssWriterImpl, self), writerId, wszWriterName, wszWriterInstanceName, dwMajorVersion, dwMinorVersion, ut, st, nLevel, dwTimeout, aws, bIOThrottlingOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Subscribe(self: *const T, dwSubscribeTimeout: u32, dwEventFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Subscribe(@ptrCast(*const IVssWriterImpl, self), dwSubscribeTimeout, dwEventFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Unsubscribe(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Unsubscribe(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Uninitialize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Uninitialize(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentVolumeArray(self: *const T) callconv(.Inline) *PWSTR {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentVolumeArray(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentVolumeCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentVolumeCount(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetSnapshotDeviceName(self: *const T, wszOriginalVolume: [*:0]const u16, ppwszSnapshotDevice: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetSnapshotDeviceName(@ptrCast(*const IVssWriterImpl, self), wszOriginalVolume, ppwszSnapshotDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentSnapshotSetId(self: *const T) callconv(.Inline) Guid {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentSnapshotSetId(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetContext(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetContext(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentLevel(self: *const T) callconv(.Inline) VSS_APPLICATION_LEVEL {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentLevel(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsPathAffected(self: *const T, wszPath: [*:0]const u16) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsPathAffected(@ptrCast(*const IVssWriterImpl, self), wszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsBootableSystemStateBackedUp(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsBootableSystemStateBackedUp(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_AreComponentsSelected(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).AreComponentsSelected(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetBackupType(self: *const T) callconv(.Inline) VSS_BACKUP_TYPE {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetBackupType(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetRestoreType(self: *const T) callconv(.Inline) VSS_RESTORE_TYPE {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetRestoreType(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_SetWriterFailure(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).SetWriterFailure(@ptrCast(*const IVssWriterImpl, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsPartialFileSupportEnabled(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsPartialFileSupportEnabled(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_InstallAlternateWriter(self: *const T, idWriter: Guid, clsid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).InstallAlternateWriter(@ptrCast(*const IVssWriterImpl, self), idWriter, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetIdentityInformation(self: *const T) callconv(.Inline) *IVssExamineWriterMetadata {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetIdentityInformation(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_SetWriterFailureEx(self: *const T, hr: HRESULT, hrApplication: HRESULT, wszApplicationMessage: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).SetWriterFailureEx(@ptrCast(*const IVssWriterImpl, self), hr, hrApplication, wszApplicationMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetSessionId(self: *const T, idSession: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetSessionId(@ptrCast(*const IVssWriterImpl, self), idSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsWriterShuttingDown(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsWriterShuttingDown(@ptrCast(*const IVssWriterImpl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssCreateExpressWriterMetadata_Value = @import("../zig.zig").Guid.initString("9c772e77-b26e-427f-92dd-c996f41ea5e3");
pub const IID_IVssCreateExpressWriterMetadata = &IID_IVssCreateExpressWriterMetadata_Value;
pub const IVssCreateExpressWriterMetadata = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExcludeFiles: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponent: fn(
            self: *const IVssCreateExpressWriterMetadata,
            ct: VSS_COMPONENT_TYPE,
            wszLogicalPath: [*:0]const u16,
            wszComponentName: [*:0]const u16,
            wszCaption: [*:0]const u16,
            pbIcon: *const u8,
            cbIcon: u32,
            bRestoreMetadata: u8,
            bNotifyOnBackupComplete: u8,
            bSelectable: u8,
            bSelectableForRestore: u8,
            dwComponentFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateExpressWriterMetadata,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateExpressWriterMetadata,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateExpressWriterMetadata,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddExcludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddExcludeFiles(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszPath, wszFilespec, bRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddComponent(self: *const T, ct: VSS_COMPONENT_TYPE, wszLogicalPath: [*:0]const u16, wszComponentName: [*:0]const u16, wszCaption: [*:0]const u16, pbIcon: *const u8, cbIcon: u32, bRestoreMetadata: u8, bNotifyOnBackupComplete: u8, bSelectable: u8, bSelectableForRestore: u8, dwComponentFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddComponent(@ptrCast(*const IVssCreateExpressWriterMetadata, self), ct, wszLogicalPath, wszComponentName, wszCaption, pbIcon, cbIcon, bRestoreMetadata, bNotifyOnBackupComplete, bSelectable, bSelectableForRestore, dwComponentFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateExpressWriterMetadata, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateExpressWriterMetadata, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateExpressWriterMetadata, self), pbstrXML);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssExpressWriter_Value = @import("../zig.zig").Guid.initString("e33affdc-59c7-47b1-97d5-4266598f6235");
pub const IID_IVssExpressWriter = &IID_IVssExpressWriter_Value;
pub const IVssExpressWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMetadata: fn(
            self: *const IVssExpressWriter,
            writerId: Guid,
            writerName: [*:0]const u16,
            usageType: VSS_USAGE_TYPE,
            versionMajor: u32,
            versionMinor: u32,
            reserved: u32,
            ppMetadata: **IVssCreateExpressWriterMetadata,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadMetadata: fn(
            self: *const IVssExpressWriter,
            metadata: [*:0]const u16,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Register: fn(
            self: *const IVssExpressWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const IVssExpressWriter,
            writerId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_CreateMetadata(self: *const T, writerId: Guid, writerName: [*:0]const u16, usageType: VSS_USAGE_TYPE, versionMajor: u32, versionMinor: u32, reserved: u32, ppMetadata: **IVssCreateExpressWriterMetadata) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).CreateMetadata(@ptrCast(*const IVssExpressWriter, self), writerId, writerName, usageType, versionMajor, versionMinor, reserved, ppMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_LoadMetadata(self: *const T, metadata: [*:0]const u16, reserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).LoadMetadata(@ptrCast(*const IVssExpressWriter, self), metadata, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_Register(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).Register(@ptrCast(*const IVssExpressWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_Unregister(self: *const T, writerId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).Unregister(@ptrCast(*const IVssExpressWriter, self), writerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_VssSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("0b5a2c52-3eb9-470a-96e2-6c6d4570e40f");
pub const CLSID_VssSnapshotMgmt = &CLSID_VssSnapshotMgmt_Value;

pub const VSS_MGMT_OBJECT_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    VOLUME = 1,
    DIFF_VOLUME = 2,
    DIFF_AREA = 3,
};
pub const VSS_MGMT_OBJECT_UNKNOWN = VSS_MGMT_OBJECT_TYPE.UNKNOWN;
pub const VSS_MGMT_OBJECT_VOLUME = VSS_MGMT_OBJECT_TYPE.VOLUME;
pub const VSS_MGMT_OBJECT_DIFF_VOLUME = VSS_MGMT_OBJECT_TYPE.DIFF_VOLUME;
pub const VSS_MGMT_OBJECT_DIFF_AREA = VSS_MGMT_OBJECT_TYPE.DIFF_AREA;

pub const VSS_VOLUME_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszVolumeDisplayName: *u16,
};

pub const VSS_DIFF_VOLUME_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszVolumeDisplayName: *u16,
    m_llVolumeFreeSpace: i64,
    m_llVolumeTotalSpace: i64,
};

pub const VSS_DIFF_AREA_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszDiffAreaVolumeName: *u16,
    m_llMaximumDiffSpace: i64,
    m_llAllocatedDiffSpace: i64,
    m_llUsedDiffSpace: i64,
};

pub const VSS_MGMT_OBJECT_UNION = extern union {
    Vol: VSS_VOLUME_PROP,
    DiffVol: VSS_DIFF_VOLUME_PROP,
    DiffArea: VSS_DIFF_AREA_PROP,
};

pub const VSS_MGMT_OBJECT_PROP = extern struct {
    Type: VSS_MGMT_OBJECT_TYPE,
    Obj: VSS_MGMT_OBJECT_UNION,
};

pub const VSS_PROTECTION_LEVEL = extern enum(i32) {
    ORIGINAL_VOLUME = 0,
    SNAPSHOT = 1,
};
pub const VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME = VSS_PROTECTION_LEVEL.ORIGINAL_VOLUME;
pub const VSS_PROTECTION_LEVEL_SNAPSHOT = VSS_PROTECTION_LEVEL.SNAPSHOT;

pub const VSS_PROTECTION_FAULT = extern enum(i32) {
    NONE = 0,
    DIFF_AREA_MISSING = 1,
    IO_FAILURE_DURING_ONLINE = 2,
    META_DATA_CORRUPTION = 3,
    MEMORY_ALLOCATION_FAILURE = 4,
    MAPPED_MEMORY_FAILURE = 5,
    COW_READ_FAILURE = 6,
    COW_WRITE_FAILURE = 7,
    DIFF_AREA_FULL = 8,
    GROW_TOO_SLOW = 9,
    GROW_FAILED = 10,
    DESTROY_ALL_SNAPSHOTS = 11,
    FILE_SYSTEM_FAILURE = 12,
    IO_FAILURE = 13,
    DIFF_AREA_REMOVED = 14,
    EXTERNAL_WRITER_TO_DIFF_AREA = 15,
    MOUNT_DURING_CLUSTER_OFFLINE = 16,
};
pub const VSS_PROTECTION_FAULT_NONE = VSS_PROTECTION_FAULT.NONE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_MISSING = VSS_PROTECTION_FAULT.DIFF_AREA_MISSING;
pub const VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE = VSS_PROTECTION_FAULT.IO_FAILURE_DURING_ONLINE;
pub const VSS_PROTECTION_FAULT_META_DATA_CORRUPTION = VSS_PROTECTION_FAULT.META_DATA_CORRUPTION;
pub const VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE = VSS_PROTECTION_FAULT.MEMORY_ALLOCATION_FAILURE;
pub const VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE = VSS_PROTECTION_FAULT.MAPPED_MEMORY_FAILURE;
pub const VSS_PROTECTION_FAULT_COW_READ_FAILURE = VSS_PROTECTION_FAULT.COW_READ_FAILURE;
pub const VSS_PROTECTION_FAULT_COW_WRITE_FAILURE = VSS_PROTECTION_FAULT.COW_WRITE_FAILURE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_FULL = VSS_PROTECTION_FAULT.DIFF_AREA_FULL;
pub const VSS_PROTECTION_FAULT_GROW_TOO_SLOW = VSS_PROTECTION_FAULT.GROW_TOO_SLOW;
pub const VSS_PROTECTION_FAULT_GROW_FAILED = VSS_PROTECTION_FAULT.GROW_FAILED;
pub const VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS = VSS_PROTECTION_FAULT.DESTROY_ALL_SNAPSHOTS;
pub const VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE = VSS_PROTECTION_FAULT.FILE_SYSTEM_FAILURE;
pub const VSS_PROTECTION_FAULT_IO_FAILURE = VSS_PROTECTION_FAULT.IO_FAILURE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED = VSS_PROTECTION_FAULT.DIFF_AREA_REMOVED;
pub const VSS_PROTECTION_FAULT_EXTERNAL_WRITER_TO_DIFF_AREA = VSS_PROTECTION_FAULT.EXTERNAL_WRITER_TO_DIFF_AREA;
pub const VSS_PROTECTION_FAULT_MOUNT_DURING_CLUSTER_OFFLINE = VSS_PROTECTION_FAULT.MOUNT_DURING_CLUSTER_OFFLINE;

pub const VSS_VOLUME_PROTECTION_INFO = extern struct {
    m_protectionLevel: VSS_PROTECTION_LEVEL,
    m_volumeIsOfflineForProtection: BOOL,
    m_protectionFault: VSS_PROTECTION_FAULT,
    m_failureStatus: i32,
    m_volumeHasUnusedDiffArea: BOOL,
    m_reserved: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("fa7df749-66e7-4986-a27f-e2f04ae53772");
pub const IID_IVssSnapshotMgmt = &IID_IVssSnapshotMgmt_Value;
pub const IVssSnapshotMgmt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderMgmtInterface: fn(
            self: *const IVssSnapshotMgmt,
            ProviderId: Guid,
            InterfaceId: *const Guid,
            ppItf: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVolumesSupportedForSnapshots: fn(
            self: *const IVssSnapshotMgmt,
            ProviderId: Guid,
            lContext: i32,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySnapshotsByVolume: fn(
            self: *const IVssSnapshotMgmt,
            pwszVolumeName: *u16,
            ProviderId: Guid,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_GetProviderMgmtInterface(self: *const T, ProviderId: Guid, InterfaceId: *const Guid, ppItf: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).GetProviderMgmtInterface(@ptrCast(*const IVssSnapshotMgmt, self), ProviderId, InterfaceId, ppItf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots(self: *const T, ProviderId: Guid, lContext: i32, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).QueryVolumesSupportedForSnapshots(@ptrCast(*const IVssSnapshotMgmt, self), ProviderId, lContext, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_QuerySnapshotsByVolume(self: *const T, pwszVolumeName: *u16, ProviderId: Guid, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).QuerySnapshotsByVolume(@ptrCast(*const IVssSnapshotMgmt, self), pwszVolumeName, ProviderId, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssSnapshotMgmt2_Value = @import("../zig.zig").Guid.initString("0f61ec39-fe82-45f2-a3f0-768b5d427102");
pub const IID_IVssSnapshotMgmt2 = &IID_IVssSnapshotMgmt2_Value;
pub const IVssSnapshotMgmt2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMinDiffAreaSize: fn(
            self: *const IVssSnapshotMgmt2,
            pllMinDiffAreaSize: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt2_GetMinDiffAreaSize(self: *const T, pllMinDiffAreaSize: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt2.VTable, self.vtable).GetMinDiffAreaSize(@ptrCast(*const IVssSnapshotMgmt2, self), pllMinDiffAreaSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssDifferentialSoftwareSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("214a0f28-b737-4026-b847-4f9e37d79529");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt = &IID_IVssDifferentialSoftwareSnapshotMgmt_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDiffArea: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDiffAreaMaximumSize: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVolumesSupportedForDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszOriginalVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasForVolume: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasOnVolume: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasForSnapshot: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            SnapshotId: Guid,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).AddDiffArea(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).ChangeDiffAreaMaximumSize(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas(self: *const T, pwszOriginalVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryVolumesSupportedForDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszOriginalVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume(self: *const T, pwszVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasForVolume(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume(self: *const T, pwszVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasOnVolume(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot(self: *const T, SnapshotId: Guid, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasForSnapshot(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), SnapshotId, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssDifferentialSoftwareSnapshotMgmt2_Value = @import("../zig.zig").Guid.initString("949d7353-675f-4275-8969-f044c6277815");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt2 = &IID_IVssDifferentialSoftwareSnapshotMgmt2_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt2 = extern struct {
    pub const VTable = extern struct {
        base: IVssDifferentialSoftwareSnapshotMgmt.VTable,
        ChangeDiffAreaMaximumSizeEx: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
            bVolatile: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MigrateDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            pwszNewDiffAreaVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMigrationStatus: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotPriority: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            idSnapshot: Guid,
            priority: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssDifferentialSoftwareSnapshotMgmt.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSizeEx(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64, bVolatile: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).ChangeDiffAreaMaximumSizeEx(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace, bVolatile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_MigrateDiffAreas(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, pwszNewDiffAreaVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).MigrateDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, pwszNewDiffAreaVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_QueryMigrationStatus(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).QueryMigrationStatus(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_SetSnapshotPriority(self: *const T, idSnapshot: Guid, priority: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).SetSnapshotPriority(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), idSnapshot, priority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssDifferentialSoftwareSnapshotMgmt3_Value = @import("../zig.zig").Guid.initString("383f7e71-a4c5-401f-b27f-f826289f8458");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt3 = &IID_IVssDifferentialSoftwareSnapshotMgmt3_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt3 = extern struct {
    pub const VTable = extern struct {
        base: IVssDifferentialSoftwareSnapshotMgmt2.VTable,
        SetVolumeProtectLevel: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
            protectionLevel: VSS_PROTECTION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeProtectLevel: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
            protectionLevel: *VSS_VOLUME_PROTECTION_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearVolumeProtectFault: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteUnusedDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszDiffAreaVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySnapshotDeltaBitmap: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            idSnapshotOlder: Guid,
            idSnapshotYounger: Guid,
            pcBlockSizePerBit: *u32,
            pcBitmapLength: *u32,
            ppbBitmap: [*]*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssDifferentialSoftwareSnapshotMgmt2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_SetVolumeProtectLevel(self: *const T, pwszVolumeName: *u16, protectionLevel: VSS_PROTECTION_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).SetVolumeProtectLevel(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName, protectionLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_GetVolumeProtectLevel(self: *const T, pwszVolumeName: *u16, protectionLevel: *VSS_VOLUME_PROTECTION_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).GetVolumeProtectLevel(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName, protectionLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_ClearVolumeProtectFault(self: *const T, pwszVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).ClearVolumeProtectFault(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_DeleteUnusedDiffAreas(self: *const T, pwszDiffAreaVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).DeleteUnusedDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszDiffAreaVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_QuerySnapshotDeltaBitmap(self: *const T, idSnapshotOlder: Guid, idSnapshotYounger: Guid, pcBlockSizePerBit: *u32, pcBitmapLength: *u32, ppbBitmap: [*]*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).QuerySnapshotDeltaBitmap(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), idSnapshotOlder, idSnapshotYounger, pcBlockSizePerBit, pcBitmapLength, ppbBitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssEnumMgmtObject_Value = @import("../zig.zig").Guid.initString("01954e6b-9254-4e6e-808c-c9e05d007696");
pub const IID_IVssEnumMgmtObject = &IID_IVssEnumMgmtObject_Value;
pub const IVssEnumMgmtObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IVssEnumMgmtObject,
            celt: u32,
            rgelt: [*]VSS_MGMT_OBJECT_PROP,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IVssEnumMgmtObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IVssEnumMgmtObject,
            ppenum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Next(self: *const T, celt: u32, rgelt: [*]VSS_MGMT_OBJECT_PROP, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Next(@ptrCast(*const IVssEnumMgmtObject, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Skip(@ptrCast(*const IVssEnumMgmtObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Reset(@ptrCast(*const IVssEnumMgmtObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Clone(self: *const T, ppenum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Clone(@ptrCast(*const IVssEnumMgmtObject, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_VSSCoordinator_Value = @import("../zig.zig").Guid.initString("e579ab5f-1cc4-44b4-bed9-de0991ff0623");
pub const CLSID_VSSCoordinator = &CLSID_VSSCoordinator_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssAdmin_Value = @import("../zig.zig").Guid.initString("77ed5996-2f63-11d3-8a39-00c04f72d8e3");
pub const IID_IVssAdmin = &IID_IVssAdmin_Value;
pub const IVssAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProvider: fn(
            self: *const IVssAdmin,
            pProviderId: Guid,
            ClassId: Guid,
            pwszProviderName: *u16,
            eProviderType: VSS_PROVIDER_TYPE,
            pwszProviderVersion: *u16,
            ProviderVersionId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: fn(
            self: *const IVssAdmin,
            ProviderId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProviders: fn(
            self: *const IVssAdmin,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortAllSnapshotsInProgress: fn(
            self: *const IVssAdmin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_RegisterProvider(self: *const T, pProviderId: Guid, ClassId: Guid, pwszProviderName: *u16, eProviderType: VSS_PROVIDER_TYPE, pwszProviderVersion: *u16, ProviderVersionId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).RegisterProvider(@ptrCast(*const IVssAdmin, self), pProviderId, ClassId, pwszProviderName, eProviderType, pwszProviderVersion, ProviderVersionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_UnregisterProvider(self: *const T, ProviderId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).UnregisterProvider(@ptrCast(*const IVssAdmin, self), ProviderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_QueryProviders(self: *const T, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).QueryProviders(@ptrCast(*const IVssAdmin, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_AbortAllSnapshotsInProgress(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).AbortAllSnapshotsInProgress(@ptrCast(*const IVssAdmin, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssAdminEx_Value = @import("../zig.zig").Guid.initString("7858a9f8-b1fa-41a6-964f-b9b36b8cd8d8");
pub const IID_IVssAdminEx = &IID_IVssAdminEx_Value;
pub const IVssAdminEx = extern struct {
    pub const VTable = extern struct {
        base: IVssAdmin.VTable,
        GetProviderCapability: fn(
            self: *const IVssAdminEx,
            pProviderId: Guid,
            pllOriginalCapabilityMask: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderContext: fn(
            self: *const IVssAdminEx,
            ProviderId: Guid,
            plContext: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProviderContext: fn(
            self: *const IVssAdminEx,
            ProviderId: Guid,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssAdmin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_GetProviderCapability(self: *const T, pProviderId: Guid, pllOriginalCapabilityMask: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).GetProviderCapability(@ptrCast(*const IVssAdminEx, self), pProviderId, pllOriginalCapabilityMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_GetProviderContext(self: *const T, ProviderId: Guid, plContext: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).GetProviderContext(@ptrCast(*const IVssAdminEx, self), ProviderId, plContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_SetProviderContext(self: *const T, ProviderId: Guid, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).SetProviderContext(@ptrCast(*const IVssAdminEx, self), ProviderId, lContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssSoftwareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("609e123e-2c5a-44d3-8f01-0b1d9a47d1ff");
pub const IID_IVssSoftwareSnapshotProvider = &IID_IVssSoftwareSnapshotProvider_Value;
pub const IVssSoftwareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: fn(
            self: *const IVssSoftwareSnapshotProvider,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapshotProperties: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
            pProp: *VSS_SNAPSHOT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IVssSoftwareSnapshotProvider,
            QueriedObjectId: Guid,
            eQueriedObjectType: VSS_OBJECT_TYPE,
            eReturnedObjectsType: VSS_OBJECT_TYPE,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSnapshots: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SourceObjectId: Guid,
            eSourceObjectType: VSS_OBJECT_TYPE,
            bForceDelete: BOOL,
            plDeletedSnapshots: *i32,
            pNondeletedSnapshotID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            pwszVolumeName: *u16,
            lNewContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVolumeSupported: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolumeName: *u16,
            pbSupportedByThisProvider: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVolumeSnapshotted: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolumeName: *u16,
            pbSnapshotsPresent: *BOOL,
            plSnapshotCompatibility: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotProperty: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
            eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID,
            vProperty: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToSnapshot: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRevertStatus: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolume: *u16,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_SetContext(self: *const T, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).SetContext(@ptrCast(*const IVssSoftwareSnapshotProvider, self), lContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_GetSnapshotProperties(self: *const T, SnapshotId: Guid, pProp: *VSS_SNAPSHOT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).GetSnapshotProperties(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId, pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_Query(self: *const T, QueriedObjectId: Guid, eQueriedObjectType: VSS_OBJECT_TYPE, eReturnedObjectsType: VSS_OBJECT_TYPE, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).Query(@ptrCast(*const IVssSoftwareSnapshotProvider, self), QueriedObjectId, eQueriedObjectType, eReturnedObjectsType, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_DeleteSnapshots(self: *const T, SourceObjectId: Guid, eSourceObjectType: VSS_OBJECT_TYPE, bForceDelete: BOOL, plDeletedSnapshots: *i32, pNondeletedSnapshotID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).DeleteSnapshots(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SourceObjectId, eSourceObjectType, bForceDelete, plDeletedSnapshots, pNondeletedSnapshotID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, pwszVolumeName: *u16, lNewContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotSetId, SnapshotId, pwszVolumeName, lNewContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_IsVolumeSupported(self: *const T, pwszVolumeName: *u16, pbSupportedByThisProvider: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).IsVolumeSupported(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolumeName, pbSupportedByThisProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_IsVolumeSnapshotted(self: *const T, pwszVolumeName: *u16, pbSnapshotsPresent: *BOOL, plSnapshotCompatibility: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).IsVolumeSnapshotted(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolumeName, pbSnapshotsPresent, plSnapshotCompatibility);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_SetSnapshotProperty(self: *const T, SnapshotId: Guid, eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID, vProperty: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).SetSnapshotProperty(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId, eSnapshotPropertyId, vProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_RevertToSnapshot(self: *const T, SnapshotId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).RevertToSnapshot(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_QueryRevertStatus(self: *const T, pwszVolume: *u16, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).QueryRevertStatus(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolume, ppAsync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssProviderCreateSnapshotSet_Value = @import("../zig.zig").Guid.initString("5f894e5b-1e39-4778-8e23-9abad9f0e08c");
pub const IID_IVssProviderCreateSnapshotSet = &IID_IVssProviderCreateSnapshotSet_Value;
pub const IVssProviderCreateSnapshotSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EndPrepareSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
            lSnapshotsCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreFinalCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostFinalCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_EndPrepareSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).EndPrepareSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PreCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PreCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_CommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).CommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PostCommitSnapshots(self: *const T, SnapshotSetId: Guid, lSnapshotsCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PostCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId, lSnapshotsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PreFinalCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PreFinalCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PostFinalCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PostFinalCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_AbortSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).AbortSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVssProviderNotifications_Value = @import("../zig.zig").Guid.initString("e561901f-03a5-4afe-86d0-72baeece7004");
pub const IID_IVssProviderNotifications = &IID_IVssProviderNotifications_Value;
pub const IVssProviderNotifications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLoad: fn(
            self: *const IVssProviderNotifications,
            pCallback: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUnload: fn(
            self: *const IVssProviderNotifications,
            bForceUnload: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderNotifications_OnLoad(self: *const T, pCallback: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderNotifications.VTable, self.vtable).OnLoad(@ptrCast(*const IVssProviderNotifications, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderNotifications_OnUnload(self: *const T, bForceUnload: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderNotifications.VTable, self.vtable).OnUnload(@ptrCast(*const IVssProviderNotifications, self), bForceUnload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2003'
const IID_IVssHardwareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("9593a157-44e9-4344-bbeb-44fbf9b06b10");
pub const IID_IVssHardwareSnapshotProvider = &IID_IVssHardwareSnapshotProvider_Value;
pub const IVssHardwareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreLunsSupported: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            lContext: i32,
            rgwszDevices: [*]*u16,
            pLunInformation: [*]VDS_LUN_INFORMATION,
            pbIsSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillInLunInfo: fn(
            self: *const IVssHardwareSnapshotProvider,
            wszDeviceName: *u16,
            pLunInfo: *VDS_LUN_INFORMATION,
            pbIsSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssHardwareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            lContext: i32,
            lLunCount: i32,
            rgDeviceNames: [*]*u16,
            rgLunInformation: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetLuns: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            rgDeviceNames: [*]*u16,
            rgSourceLuns: [*]VDS_LUN_INFORMATION,
            rgDestinationLuns: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LocateLuns: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            rgSourceLuns: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLunEmpty: fn(
            self: *const IVssHardwareSnapshotProvider,
            wszDeviceName: *u16,
            pInformation: *VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_AreLunsSupported(self: *const T, lLunCount: i32, lContext: i32, rgwszDevices: [*]*u16, pLunInformation: [*]VDS_LUN_INFORMATION, pbIsSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).AreLunsSupported(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, lContext, rgwszDevices, pLunInformation, pbIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_FillInLunInfo(self: *const T, wszDeviceName: *u16, pLunInfo: *VDS_LUN_INFORMATION, pbIsSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).FillInLunInfo(@ptrCast(*const IVssHardwareSnapshotProvider, self), wszDeviceName, pLunInfo, pbIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, lContext: i32, lLunCount: i32, rgDeviceNames: [*]*u16, rgLunInformation: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssHardwareSnapshotProvider, self), SnapshotSetId, SnapshotId, lContext, lLunCount, rgDeviceNames, rgLunInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_GetTargetLuns(self: *const T, lLunCount: i32, rgDeviceNames: [*]*u16, rgSourceLuns: [*]VDS_LUN_INFORMATION, rgDestinationLuns: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).GetTargetLuns(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, rgDeviceNames, rgSourceLuns, rgDestinationLuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_LocateLuns(self: *const T, lLunCount: i32, rgSourceLuns: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).LocateLuns(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, rgSourceLuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_OnLunEmpty(self: *const T, wszDeviceName: *u16, pInformation: *VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).OnLunEmpty(@ptrCast(*const IVssHardwareSnapshotProvider, self), wszDeviceName, pInformation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IVssHardwareSnapshotProviderEx_Value = @import("../zig.zig").Guid.initString("7f5ba925-cdb1-4d11-a71f-339eb7e709fd");
pub const IID_IVssHardwareSnapshotProviderEx = &IID_IVssHardwareSnapshotProviderEx_Value;
pub const IVssHardwareSnapshotProviderEx = extern struct {
    pub const VTable = extern struct {
        base: IVssHardwareSnapshotProvider.VTable,
        GetProviderCapabilities: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pllOriginalCapabilityMask: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLunStateChange: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSnapshotLuns: [*]VDS_LUN_INFORMATION,
            pOriginalLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResyncLuns: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSourceLuns: [*]VDS_LUN_INFORMATION,
            pTargetLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnReuseLuns: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSnapshotLuns: [*]VDS_LUN_INFORMATION,
            pOriginalLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssHardwareSnapshotProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_GetProviderCapabilities(self: *const T, pllOriginalCapabilityMask: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).GetProviderCapabilities(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pllOriginalCapabilityMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_OnLunStateChange(self: *const T, pSnapshotLuns: [*]VDS_LUN_INFORMATION, pOriginalLuns: [*]VDS_LUN_INFORMATION, dwCount: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).OnLunStateChange(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSnapshotLuns, pOriginalLuns, dwCount, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_ResyncLuns(self: *const T, pSourceLuns: [*]VDS_LUN_INFORMATION, pTargetLuns: [*]VDS_LUN_INFORMATION, dwCount: u32, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).ResyncLuns(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSourceLuns, pTargetLuns, dwCount, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_OnReuseLuns(self: *const T, pSnapshotLuns: [*]VDS_LUN_INFORMATION, pOriginalLuns: [*]VDS_LUN_INFORMATION, dwCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).OnReuseLuns(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSnapshotLuns, pOriginalLuns, dwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IVssFileShareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("c8636060-7c2e-11df-8c4a-0800200c9a66");
pub const IID_IVssFileShareSnapshotProvider = &IID_IVssFileShareSnapshotProvider_Value;
pub const IVssFileShareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: fn(
            self: *const IVssFileShareSnapshotProvider,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapshotProperties: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotId: Guid,
            pProp: *VSS_SNAPSHOT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IVssFileShareSnapshotProvider,
            QueriedObjectId: Guid,
            eQueriedObjectType: VSS_OBJECT_TYPE,
            eReturnedObjectsType: VSS_OBJECT_TYPE,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSnapshots: fn(
            self: *const IVssFileShareSnapshotProvider,
            SourceObjectId: Guid,
            eSourceObjectType: VSS_OBJECT_TYPE,
            bForceDelete: BOOL,
            plDeletedSnapshots: *i32,
            pNondeletedSnapshotID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            pwszSharePath: *u16,
            lNewContext: i32,
            ProviderId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPathSupported: fn(
            self: *const IVssFileShareSnapshotProvider,
            pwszSharePath: *u16,
            pbSupportedByThisProvider: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPathSnapshotted: fn(
            self: *const IVssFileShareSnapshotProvider,
            pwszSharePath: *u16,
            pbSnapshotsPresent: *BOOL,
            plSnapshotCompatibility: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotProperty: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotId: Guid,
            eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID,
            vProperty: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_SetContext(self: *const T, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).SetContext(@ptrCast(*const IVssFileShareSnapshotProvider, self), lContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_GetSnapshotProperties(self: *const T, SnapshotId: Guid, pProp: *VSS_SNAPSHOT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).GetSnapshotProperties(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotId, pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_Query(self: *const T, QueriedObjectId: Guid, eQueriedObjectType: VSS_OBJECT_TYPE, eReturnedObjectsType: VSS_OBJECT_TYPE, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).Query(@ptrCast(*const IVssFileShareSnapshotProvider, self), QueriedObjectId, eQueriedObjectType, eReturnedObjectsType, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_DeleteSnapshots(self: *const T, SourceObjectId: Guid, eSourceObjectType: VSS_OBJECT_TYPE, bForceDelete: BOOL, plDeletedSnapshots: *i32, pNondeletedSnapshotID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).DeleteSnapshots(@ptrCast(*const IVssFileShareSnapshotProvider, self), SourceObjectId, eSourceObjectType, bForceDelete, plDeletedSnapshots, pNondeletedSnapshotID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, pwszSharePath: *u16, lNewContext: i32, ProviderId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotSetId, SnapshotId, pwszSharePath, lNewContext, ProviderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_IsPathSupported(self: *const T, pwszSharePath: *u16, pbSupportedByThisProvider: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).IsPathSupported(@ptrCast(*const IVssFileShareSnapshotProvider, self), pwszSharePath, pbSupportedByThisProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_IsPathSnapshotted(self: *const T, pwszSharePath: *u16, pbSnapshotsPresent: *BOOL, plSnapshotCompatibility: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).IsPathSnapshotted(@ptrCast(*const IVssFileShareSnapshotProvider, self), pwszSharePath, pbSnapshotsPresent, plSnapshotCompatibility);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_SetSnapshotProperty(self: *const T, SnapshotId: Guid, eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID, vProperty: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).SetSnapshotProperty(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotId, eSnapshotPropertyId, vProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPDDENUMVIDEOCALLBACK = fn(
    param0: *DDVIDEOPORTCAPS,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DDVIDEOPORTSTATUS = extern struct {
    dwSize: u32,
    bInUse: BOOL,
    dwFlags: u32,
    dwReserved1: u32,
    VideoPortType: DDVIDEOPORTCONNECT,
    dwReserved2: usize,
    dwReserved3: usize,
};

pub const DDVIDEOPORTNOTIFY = extern struct {
    ApproximateTimeStamp: LARGE_INTEGER,
    lField: i32,
    dwSurfaceIndex: u32,
    lDone: i32,
};

pub const PDD_SETCOLORKEY = fn(
    param0: *DD_DRVSETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_DESTROYDRIVER = fn(
    param0: *_DD_DESTROYDRIVERDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_SETMODE = fn(
    param0: *_DD_SETMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_ALPHABLT = fn(
    param0: *DD_BLTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_SURFCB_SETCLIPLIST = fn(
    param0: *DD_SETCLIPLISTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_VPORTCB_GETAUTOFLIPSURF = fn(
    param0: *_DD_GETVPORTAUTOFLIPSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DD_MORECAPS = extern struct {
    dwSize: u32,
    dwAlphaCaps: u32,
    dwSVBAlphaCaps: u32,
    dwVSBAlphaCaps: u32,
    dwSSBAlphaCaps: u32,
    dwFilterCaps: u32,
    dwSVBFilterCaps: u32,
    dwVSBFilterCaps: u32,
    dwSSBFilterCaps: u32,
};

pub const DDNTCORECAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwCaps2: u32,
    dwCKeyCaps: u32,
    dwFXCaps: u32,
    dwFXAlphaCaps: u32,
    dwPalCaps: u32,
    dwSVCaps: u32,
    dwAlphaBltConstBitDepths: u32,
    dwAlphaBltPixelBitDepths: u32,
    dwAlphaBltSurfaceBitDepths: u32,
    dwAlphaOverlayConstBitDepths: u32,
    dwAlphaOverlayPixelBitDepths: u32,
    dwAlphaOverlaySurfaceBitDepths: u32,
    dwZBufferBitDepths: u32,
    dwVidMemTotal: u32,
    dwVidMemFree: u32,
    dwMaxVisibleOverlays: u32,
    dwCurrVisibleOverlays: u32,
    dwNumFourCCCodes: u32,
    dwAlignBoundarySrc: u32,
    dwAlignSizeSrc: u32,
    dwAlignBoundaryDest: u32,
    dwAlignSizeDest: u32,
    dwAlignStrideAlign: u32,
    dwRops: [8]u32,
    ddsCaps: DDSCAPS,
    dwMinOverlayStretch: u32,
    dwMaxOverlayStretch: u32,
    dwMinLiveVideoStretch: u32,
    dwMaxLiveVideoStretch: u32,
    dwMinHwCodecStretch: u32,
    dwMaxHwCodecStretch: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwSVBCaps: u32,
    dwSVBCKeyCaps: u32,
    dwSVBFXCaps: u32,
    dwSVBRops: [8]u32,
    dwVSBCaps: u32,
    dwVSBCKeyCaps: u32,
    dwVSBFXCaps: u32,
    dwVSBRops: [8]u32,
    dwSSBCaps: u32,
    dwSSBCKeyCaps: u32,
    dwSSBFXCaps: u32,
    dwSSBRops: [8]u32,
    dwMaxVideoPorts: u32,
    dwCurrVideoPorts: u32,
    dwSVBCaps2: u32,
};

pub const DD_HALINFO_V4 = extern struct {
    dwSize: u32,
    vmiData: VIDEOMEMORYINFO,
    ddCaps: DDNTCORECAPS,
    GetDriverInfo: PDD_GETDRIVERINFO,
    dwFlags: u32,
};

pub const DD_SETCLIPLISTDATA = extern struct {
    lpDD: *DD_DIRECTDRAW_GLOBAL,
    lpDDSurface: *DD_SURFACE_LOCAL,
    ddRVal: HRESULT,
    SetClipList: *c_void,
};

pub const DD_DRVSETCOLORKEYDATA = extern struct {
    lpDDSurface: *DD_SURFACE_LOCAL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: *c_void,
};

pub const DD_DESTROYDDLOCALDATA = extern struct {
    dwFlags: u32,
    pDDLcl: *DD_DIRECTDRAW_LOCAL,
    ddRVal: HRESULT,
};

pub const LPD3DVALIDATECALLBACK = fn(
    lpUserArg: *c_void,
    dwOffset: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMTEXTUREFORMATSCALLBACK = fn(
    lpDdsd: *DDSURFACEDESC,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMPIXELFORMATSCALLBACK = fn(
    lpDDPixFmt: *DDPIXELFORMAT,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const D3DHVERTEX = extern struct {
    dwFlags: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DTLVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    Anonymous8: _Anonymous8_e__Union,
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous8_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    dwReserved: u32,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DVERTEX = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    Anonymous6: _Anonymous6_e__Union,
    Anonymous7: _Anonymous7_e__Union,
    Anonymous8: _Anonymous8_e__Union,
    const _Anonymous8_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DVIEWPORT = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvScaleX: f32,
    dvScaleY: f32,
    dvMaxX: f32,
    dvMaxY: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DVIEWPORT2 = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvClipX: f32,
    dvClipY: f32,
    dvClipWidth: f32,
    dvClipHeight: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DVIEWPORT7 = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DTRANSFORMDATA = extern struct {
    dwSize: u32,
    lpIn: *c_void,
    dwInSize: u32,
    lpOut: *c_void,
    dwOutSize: u32,
    lpHOut: *D3DHVERTEX,
    dwClip: u32,
    dwClipIntersection: u32,
    dwClipUnion: u32,
    drExtent: D3DRECT,
};

pub const D3DLIGHTINGELEMENT = extern struct {
    dvPosition: D3DVECTOR,
    dvNormal: D3DVECTOR,
};

pub const D3DMATERIAL = extern struct {
    dwSize: u32,
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    hTexture: u32,
    dwRampSize: u32,
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DMATERIAL7 = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    Anonymous4: _Anonymous4_e__Union,
    Anonymous5: _Anonymous5_e__Union,
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLIGHT = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: D3DCOLORVALUE,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};

pub const D3DLIGHT7 = extern struct {
    dltType: D3DLIGHTTYPE,
    dcvDiffuse: D3DCOLORVALUE,
    dcvSpecular: D3DCOLORVALUE,
    dcvAmbient: D3DCOLORVALUE,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};

pub const D3DLIGHT2 = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: D3DCOLORVALUE,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
    dwFlags: u32,
};

pub const D3DLIGHTDATA = extern struct {
    dwSize: u32,
    lpIn: *D3DLIGHTINGELEMENT,
    dwInSize: u32,
    lpOut: *D3DTLVERTEX,
    dwOutSize: u32,
};

pub const D3DOPCODE = extern enum(i32) {
    POINT = 1,
    LINE = 2,
    TRIANGLE = 3,
    MATRIXLOAD = 4,
    MATRIXMULTIPLY = 5,
    STATETRANSFORM = 6,
    STATELIGHT = 7,
    STATERENDER = 8,
    PROCESSVERTICES = 9,
    TEXTURELOAD = 10,
    EXIT = 11,
    BRANCHFORWARD = 12,
    SPAN = 13,
    SETSTATUS = 14,
    FORCE_DWORD = 2147483647,
};
pub const D3DOP_POINT = D3DOPCODE.POINT;
pub const D3DOP_LINE = D3DOPCODE.LINE;
pub const D3DOP_TRIANGLE = D3DOPCODE.TRIANGLE;
pub const D3DOP_MATRIXLOAD = D3DOPCODE.MATRIXLOAD;
pub const D3DOP_MATRIXMULTIPLY = D3DOPCODE.MATRIXMULTIPLY;
pub const D3DOP_STATETRANSFORM = D3DOPCODE.STATETRANSFORM;
pub const D3DOP_STATELIGHT = D3DOPCODE.STATELIGHT;
pub const D3DOP_STATERENDER = D3DOPCODE.STATERENDER;
pub const D3DOP_PROCESSVERTICES = D3DOPCODE.PROCESSVERTICES;
pub const D3DOP_TEXTURELOAD = D3DOPCODE.TEXTURELOAD;
pub const D3DOP_EXIT = D3DOPCODE.EXIT;
pub const D3DOP_BRANCHFORWARD = D3DOPCODE.BRANCHFORWARD;
pub const D3DOP_SPAN = D3DOPCODE.SPAN;
pub const D3DOP_SETSTATUS = D3DOPCODE.SETSTATUS;
pub const D3DOP_FORCE_DWORD = D3DOPCODE.FORCE_DWORD;

pub const D3DINSTRUCTION = extern struct {
    bOpcode: u8,
    bSize: u8,
    wCount: u16,
};

pub const D3DTEXTURELOAD = extern struct {
    hDestTexture: u32,
    hSrcTexture: u32,
};

pub const D3DPICKRECORD = extern struct {
    bOpcode: u8,
    bPad: u8,
    dwOffset: u32,
    dvZ: f32,
};

pub const D3DLINEPATTERN = extern struct {
    wRepeatFactor: u16,
    wLinePattern: u16,
};

pub const D3DTEXTUREFILTER = extern enum(i32) {
    NEAREST = 1,
    LINEAR = 2,
    MIPNEAREST = 3,
    MIPLINEAR = 4,
    LINEARMIPNEAREST = 5,
    LINEARMIPLINEAR = 6,
    FORCE_DWORD = 2147483647,
};
pub const D3DFILTER_NEAREST = D3DTEXTUREFILTER.NEAREST;
pub const D3DFILTER_LINEAR = D3DTEXTUREFILTER.LINEAR;
pub const D3DFILTER_MIPNEAREST = D3DTEXTUREFILTER.MIPNEAREST;
pub const D3DFILTER_MIPLINEAR = D3DTEXTUREFILTER.MIPLINEAR;
pub const D3DFILTER_LINEARMIPNEAREST = D3DTEXTUREFILTER.LINEARMIPNEAREST;
pub const D3DFILTER_LINEARMIPLINEAR = D3DTEXTUREFILTER.LINEARMIPLINEAR;
pub const D3DFILTER_FORCE_DWORD = D3DTEXTUREFILTER.FORCE_DWORD;

pub const D3DTEXTUREBLEND = extern enum(i32) {
    DECAL = 1,
    MODULATE = 2,
    DECALALPHA = 3,
    MODULATEALPHA = 4,
    DECALMASK = 5,
    MODULATEMASK = 6,
    COPY = 7,
    ADD = 8,
    FORCE_DWORD = 2147483647,
};
pub const D3DTBLEND_DECAL = D3DTEXTUREBLEND.DECAL;
pub const D3DTBLEND_MODULATE = D3DTEXTUREBLEND.MODULATE;
pub const D3DTBLEND_DECALALPHA = D3DTEXTUREBLEND.DECALALPHA;
pub const D3DTBLEND_MODULATEALPHA = D3DTEXTUREBLEND.MODULATEALPHA;
pub const D3DTBLEND_DECALMASK = D3DTEXTUREBLEND.DECALMASK;
pub const D3DTBLEND_MODULATEMASK = D3DTEXTUREBLEND.MODULATEMASK;
pub const D3DTBLEND_COPY = D3DTEXTUREBLEND.COPY;
pub const D3DTBLEND_ADD = D3DTEXTUREBLEND.ADD;
pub const D3DTBLEND_FORCE_DWORD = D3DTEXTUREBLEND.FORCE_DWORD;

pub const D3DANTIALIASMODE = extern enum(i32) {
    NONE = 0,
    SORTDEPENDENT = 1,
    SORTINDEPENDENT = 2,
    FORCE_DWORD = 2147483647,
};
pub const D3DANTIALIAS_NONE = D3DANTIALIASMODE.NONE;
pub const D3DANTIALIAS_SORTDEPENDENT = D3DANTIALIASMODE.SORTDEPENDENT;
pub const D3DANTIALIAS_SORTINDEPENDENT = D3DANTIALIASMODE.SORTINDEPENDENT;
pub const D3DANTIALIAS_FORCE_DWORD = D3DANTIALIASMODE.FORCE_DWORD;

pub const D3DVERTEXTYPE = extern enum(i32) {
    VERTEX = 1,
    LVERTEX = 2,
    TLVERTEX = 3,
    FORCE_DWORD = 2147483647,
};
pub const D3DVT_VERTEX = D3DVERTEXTYPE.VERTEX;
pub const D3DVT_LVERTEX = D3DVERTEXTYPE.LVERTEX;
pub const D3DVT_TLVERTEX = D3DVERTEXTYPE.TLVERTEX;
pub const D3DVT_FORCE_DWORD = D3DVERTEXTYPE.FORCE_DWORD;

pub const D3DLIGHTSTATETYPE = extern enum(i32) {
    MATERIAL = 1,
    AMBIENT = 2,
    COLORMODEL = 3,
    FOGMODE = 4,
    FOGSTART = 5,
    FOGEND = 6,
    FOGDENSITY = 7,
    COLORVERTEX = 8,
    FORCE_DWORD = 2147483647,
};
pub const D3DLIGHTSTATE_MATERIAL = D3DLIGHTSTATETYPE.MATERIAL;
pub const D3DLIGHTSTATE_AMBIENT = D3DLIGHTSTATETYPE.AMBIENT;
pub const D3DLIGHTSTATE_COLORMODEL = D3DLIGHTSTATETYPE.COLORMODEL;
pub const D3DLIGHTSTATE_FOGMODE = D3DLIGHTSTATETYPE.FOGMODE;
pub const D3DLIGHTSTATE_FOGSTART = D3DLIGHTSTATETYPE.FOGSTART;
pub const D3DLIGHTSTATE_FOGEND = D3DLIGHTSTATETYPE.FOGEND;
pub const D3DLIGHTSTATE_FOGDENSITY = D3DLIGHTSTATETYPE.FOGDENSITY;
pub const D3DLIGHTSTATE_COLORVERTEX = D3DLIGHTSTATETYPE.COLORVERTEX;
pub const D3DLIGHTSTATE_FORCE_DWORD = D3DLIGHTSTATETYPE.FORCE_DWORD;

pub const D3DSTATE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DMATRIXLOAD = extern struct {
    hDestMatrix: u32,
    hSrcMatrix: u32,
};

pub const D3DMATRIXMULTIPLY = extern struct {
    hDestMatrix: u32,
    hSrcMatrix1: u32,
    hSrcMatrix2: u32,
};

pub const D3DPROCESSVERTICES = extern struct {
    dwFlags: u32,
    wStart: u16,
    wDest: u16,
    dwCount: u32,
    dwReserved: u32,
};

pub const D3DTEXTUREMAGFILTER = extern enum(i32) {
    POINT = 1,
    LINEAR = 2,
    FLATCUBIC = 3,
    GAUSSIANCUBIC = 4,
    ANISOTROPIC = 5,
    FORCE_DWORD = 2147483647,
};
pub const D3DTFG_POINT = D3DTEXTUREMAGFILTER.POINT;
pub const D3DTFG_LINEAR = D3DTEXTUREMAGFILTER.LINEAR;
pub const D3DTFG_FLATCUBIC = D3DTEXTUREMAGFILTER.FLATCUBIC;
pub const D3DTFG_GAUSSIANCUBIC = D3DTEXTUREMAGFILTER.GAUSSIANCUBIC;
pub const D3DTFG_ANISOTROPIC = D3DTEXTUREMAGFILTER.ANISOTROPIC;
pub const D3DTFG_FORCE_DWORD = D3DTEXTUREMAGFILTER.FORCE_DWORD;

pub const D3DTEXTUREMINFILTER = extern enum(i32) {
    POINT = 1,
    LINEAR = 2,
    ANISOTROPIC = 3,
    FORCE_DWORD = 2147483647,
};
pub const D3DTFN_POINT = D3DTEXTUREMINFILTER.POINT;
pub const D3DTFN_LINEAR = D3DTEXTUREMINFILTER.LINEAR;
pub const D3DTFN_ANISOTROPIC = D3DTEXTUREMINFILTER.ANISOTROPIC;
pub const D3DTFN_FORCE_DWORD = D3DTEXTUREMINFILTER.FORCE_DWORD;

pub const D3DTEXTUREMIPFILTER = extern enum(i32) {
    NONE = 1,
    POINT = 2,
    LINEAR = 3,
    FORCE_DWORD = 2147483647,
};
pub const D3DTFP_NONE = D3DTEXTUREMIPFILTER.NONE;
pub const D3DTFP_POINT = D3DTEXTUREMIPFILTER.POINT;
pub const D3DTFP_LINEAR = D3DTEXTUREMIPFILTER.LINEAR;
pub const D3DTFP_FORCE_DWORD = D3DTEXTUREMIPFILTER.FORCE_DWORD;

pub const D3DTRIANGLE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    wFlags: u16,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLINE = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DSPAN = extern struct {
    wCount: u16,
    wFirst: u16,
};

pub const D3DPOINT = extern struct {
    wCount: u16,
    wFirst: u16,
};

pub const D3DBRANCH = extern struct {
    dwMask: u32,
    dwValue: u32,
    bNegate: BOOL,
    dwOffset: u32,
};

pub const D3DSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    drExtent: D3DRECT,
};

pub const D3DCLIPSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    minx: f32,
    maxx: f32,
    miny: f32,
    maxy: f32,
    minz: f32,
    maxz: f32,
};

pub const D3DSTATS = extern struct {
    dwSize: u32,
    dwTrianglesDrawn: u32,
    dwLinesDrawn: u32,
    dwPointsDrawn: u32,
    dwSpansDrawn: u32,
    dwVerticesProcessed: u32,
};

pub const D3DEXECUTEDATA = extern struct {
    dwSize: u32,
    dwVertexOffset: u32,
    dwVertexCount: u32,
    dwInstructionOffset: u32,
    dwInstructionLength: u32,
    dwHVertexOffset: u32,
    dsStatus: D3DSTATUS,
};

pub const D3DVERTEXBUFFERDESC = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwFVF: u32,
    dwNumVertices: u32,
};

pub const D3DDP_PTRSTRIDE = extern struct {
    lpvData: *c_void,
    dwStride: u32,
};

pub const D3DDRAWPRIMITIVESTRIDEDDATA = extern struct {
    position: D3DDP_PTRSTRIDE,
    normal: D3DDP_PTRSTRIDE,
    diffuse: D3DDP_PTRSTRIDE,
    specular: D3DDP_PTRSTRIDE,
    textureCoords: [8]D3DDP_PTRSTRIDE,
};

pub const D3DTRANSFORMCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
};

pub const D3DLIGHTINGCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwLightingModel: u32,
    dwNumLights: u32,
};

pub const _D3DPrimCaps = extern struct {
    dwSize: u32,
    dwMiscCaps: u32,
    dwRasterCaps: u32,
    dwZCmpCaps: u32,
    dwSrcBlendCaps: u32,
    dwDestBlendCaps: u32,
    dwAlphaCmpCaps: u32,
    dwShadeCaps: u32,
    dwTextureCaps: u32,
    dwTextureFilterCaps: u32,
    dwTextureBlendCaps: u32,
    dwTextureAddressCaps: u32,
    dwStippleWidth: u32,
    dwStippleHeight: u32,
};

pub const _D3DDeviceDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const _D3DDeviceDesc7 = extern struct {
    dwDevCaps: u32,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    deviceGUID: Guid,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};

pub const LPD3DENUMDEVICESCALLBACK = fn(
    lpGuid: *Guid,
    lpDeviceDescription: PSTR,
    lpDeviceName: PSTR,
    param3: *_D3DDeviceDesc,
    param4: *_D3DDeviceDesc,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMDEVICESCALLBACK7 = fn(
    lpDeviceDescription: PSTR,
    lpDeviceName: PSTR,
    param2: *_D3DDeviceDesc7,
    param3: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const D3DFINDDEVICESEARCH = extern struct {
    dwSize: u32,
    dwFlags: u32,
    bHardware: BOOL,
    dcmColorModel: u32,
    guid: Guid,
    dwCaps: u32,
    dpcPrimCaps: _D3DPrimCaps,
};

pub const D3DFINDDEVICERESULT = extern struct {
    dwSize: u32,
    guid: Guid,
    ddHwDesc: _D3DDeviceDesc,
    ddSwDesc: _D3DDeviceDesc,
};

pub const _D3DExecuteBufferDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwBufferSize: u32,
    lpData: *c_void,
};

pub const D3DDEVINFO_TEXTUREMANAGER = extern struct {
    bThrashing: BOOL,
    dwApproxBytesDownloaded: u32,
    dwNumEvicts: u32,
    dwNumVidCreates: u32,
    dwNumTexturesUsed: u32,
    dwNumUsedTexInVid: u32,
    dwWorkingSet: u32,
    dwWorkingSetBytes: u32,
    dwTotalManaged: u32,
    dwTotalBytes: u32,
    dwLastPri: u32,
};

pub const D3DDEVINFO_TEXTURING = extern struct {
    dwNumLoads: u32,
    dwApproxBytesLoaded: u32,
    dwNumPreLoads: u32,
    dwNumSet: u32,
    dwNumCreates: u32,
    dwNumDestroys: u32,
    dwNumSetPriorities: u32,
    dwNumSetLODs: u32,
    dwNumLocks: u32,
    dwNumGetDCs: u32,
};

pub const _D3DNTHALDeviceDesc_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
};

pub const _D3DNTHALDeviceDesc_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
};

pub const _D3DNTDeviceDesc_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const D3DNTHAL_GLOBALDRIVERDATA = extern struct {
    dwSize: u32,
    hwCaps: _D3DNTHALDeviceDesc_V1,
    dwNumVertices: u32,
    dwNumClipVertices: u32,
    dwNumTextureFormats: u32,
    lpTextureFormats: *DDSURFACEDESC,
};

pub const D3DNTHAL_D3DDX6EXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const D3DNTHAL_D3DEXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};

pub const D3DNTHAL_CONTEXTCREATEDATA = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    Anonymous3: _Anonymous3_e__Union,
    dwPID: u32,
    dwhContext: usize,
    ddrval: HRESULT,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_CONTEXTDESTROYDATA = extern struct {
    dwhContext: usize,
    ddrval: HRESULT,
};

pub const D3DNTHAL_CONTEXTDESTROYALLDATA = extern struct {
    dwPID: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_SCENECAPTUREDATA = extern struct {
    dwhContext: usize,
    dwFlag: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTURECREATEDATA = extern struct {
    dwhContext: usize,
    hDDS: HANDLE,
    dwHandle: usize,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTUREDESTROYDATA = extern struct {
    dwhContext: usize,
    dwHandle: usize,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTURESWAPDATA = extern struct {
    dwhContext: usize,
    dwHandle1: usize,
    dwHandle2: usize,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTUREGETSURFDATA = extern struct {
    dwhContext: usize,
    hDDS: HANDLE,
    dwHandle: usize,
    ddrval: HRESULT,
};

pub const LPD3DNTHAL_CONTEXTCREATECB = fn(
    param0: *D3DNTHAL_CONTEXTCREATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_CONTEXTDESTROYCB = fn(
    param0: *D3DNTHAL_CONTEXTDESTROYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_CONTEXTDESTROYALLCB = fn(
    param0: *D3DNTHAL_CONTEXTDESTROYALLDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_SCENECAPTURECB = fn(
    param0: *D3DNTHAL_SCENECAPTUREDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTURECREATECB = fn(
    param0: *D3DNTHAL_TEXTURECREATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTUREDESTROYCB = fn(
    param0: *D3DNTHAL_TEXTUREDESTROYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTURESWAPCB = fn(
    param0: *D3DNTHAL_TEXTURESWAPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTUREGETSURFCB = fn(
    param0: *D3DNTHAL_TEXTUREGETSURFDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS = extern struct {
    dwSize: u32,
    ContextCreate: LPD3DNTHAL_CONTEXTCREATECB,
    ContextDestroy: LPD3DNTHAL_CONTEXTDESTROYCB,
    ContextDestroyAll: LPD3DNTHAL_CONTEXTDESTROYALLCB,
    SceneCapture: LPD3DNTHAL_SCENECAPTURECB,
    dwReserved10: *c_void,
    dwReserved11: *c_void,
    dwReserved22: *c_void,
    dwReserved23: *c_void,
    dwReserved: usize,
    TextureCreate: LPD3DNTHAL_TEXTURECREATECB,
    TextureDestroy: LPD3DNTHAL_TEXTUREDESTROYCB,
    TextureSwap: LPD3DNTHAL_TEXTURESWAPCB,
    TextureGetSurf: LPD3DNTHAL_TEXTUREGETSURFCB,
    dwReserved12: *c_void,
    dwReserved13: *c_void,
    dwReserved14: *c_void,
    dwReserved15: *c_void,
    dwReserved16: *c_void,
    dwReserved17: *c_void,
    dwReserved18: *c_void,
    dwReserved19: *c_void,
    dwReserved20: *c_void,
    dwReserved21: *c_void,
    dwReserved24: *c_void,
    dwReserved0: usize,
    dwReserved1: usize,
    dwReserved2: usize,
    dwReserved3: usize,
    dwReserved4: usize,
    dwReserved5: usize,
    dwReserved6: usize,
    dwReserved7: usize,
    dwReserved8: usize,
    dwReserved9: usize,
};

pub const D3DNTHAL_SETRENDERTARGETDATA = extern struct {
    dwhContext: usize,
    lpDDS: *DD_SURFACE_LOCAL,
    lpDDSZ: *DD_SURFACE_LOCAL,
    ddrval: HRESULT,
};

pub const LPD3DNTHAL_SETRENDERTARGETCB = fn(
    param0: *D3DNTHAL_SETRENDERTARGETDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    SetRenderTarget: LPD3DNTHAL_SETRENDERTARGETCB,
    dwReserved1: *c_void,
    dwReserved2: *c_void,
    dwReserved3: *c_void,
    dwReserved4: *c_void,
};

pub const D3DNTHAL_CLEAR2DATA = extern struct {
    dwhContext: usize,
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    lpRects: *D3DRECT,
    dwNumRects: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA = extern struct {
    dwhContext: usize,
    dwFlags: u32,
    dwReserved: usize,
    dwNumPasses: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_DP2COMMAND = extern struct {
    bCommand: u8,
    bReserved: u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2OPERATION = extern enum(i32) {
    POINTS = 1,
    INDEXEDLINELIST = 2,
    INDEXEDTRIANGLELIST = 3,
    RENDERSTATE = 8,
    LINELIST = 15,
    LINESTRIP = 16,
    INDEXEDLINESTRIP = 17,
    TRIANGLELIST = 18,
    TRIANGLESTRIP = 19,
    INDEXEDTRIANGLESTRIP = 20,
    TRIANGLEFAN = 21,
    INDEXEDTRIANGLEFAN = 22,
    TRIANGLEFAN_IMM = 23,
    LINELIST_IMM = 24,
    TEXTURESTAGESTATE = 25,
    INDEXEDTRIANGLELIST2 = 26,
    INDEXEDLINELIST2 = 27,
    VIEWPORTINFO = 28,
    WINFO = 29,
    SETPALETTE = 30,
    UPDATEPALETTE = 31,
    ZRANGE = 32,
    SETMATERIAL = 33,
    SETLIGHT = 34,
    CREATELIGHT = 35,
    SETTRANSFORM = 36,
    TEXBLT = 38,
    STATESET = 39,
    SETPRIORITY = 40,
    SETRENDERTARGET = 41,
    CLEAR = 42,
    SETTEXLOD = 43,
    SETCLIPPLANE = 44,
};
pub const D3DNTDP2OP_POINTS = D3DNTHAL_DP2OPERATION.POINTS;
pub const D3DNTDP2OP_INDEXEDLINELIST = D3DNTHAL_DP2OPERATION.INDEXEDLINELIST;
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST = D3DNTHAL_DP2OPERATION.INDEXEDTRIANGLELIST;
pub const D3DNTDP2OP_RENDERSTATE = D3DNTHAL_DP2OPERATION.RENDERSTATE;
pub const D3DNTDP2OP_LINELIST = D3DNTHAL_DP2OPERATION.LINELIST;
pub const D3DNTDP2OP_LINESTRIP = D3DNTHAL_DP2OPERATION.LINESTRIP;
pub const D3DNTDP2OP_INDEXEDLINESTRIP = D3DNTHAL_DP2OPERATION.INDEXEDLINESTRIP;
pub const D3DNTDP2OP_TRIANGLELIST = D3DNTHAL_DP2OPERATION.TRIANGLELIST;
pub const D3DNTDP2OP_TRIANGLESTRIP = D3DNTHAL_DP2OPERATION.TRIANGLESTRIP;
pub const D3DNTDP2OP_INDEXEDTRIANGLESTRIP = D3DNTHAL_DP2OPERATION.INDEXEDTRIANGLESTRIP;
pub const D3DNTDP2OP_TRIANGLEFAN = D3DNTHAL_DP2OPERATION.TRIANGLEFAN;
pub const D3DNTDP2OP_INDEXEDTRIANGLEFAN = D3DNTHAL_DP2OPERATION.INDEXEDTRIANGLEFAN;
pub const D3DNTDP2OP_TRIANGLEFAN_IMM = D3DNTHAL_DP2OPERATION.TRIANGLEFAN_IMM;
pub const D3DNTDP2OP_LINELIST_IMM = D3DNTHAL_DP2OPERATION.LINELIST_IMM;
pub const D3DNTDP2OP_TEXTURESTAGESTATE = D3DNTHAL_DP2OPERATION.TEXTURESTAGESTATE;
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST2 = D3DNTHAL_DP2OPERATION.INDEXEDTRIANGLELIST2;
pub const D3DNTDP2OP_INDEXEDLINELIST2 = D3DNTHAL_DP2OPERATION.INDEXEDLINELIST2;
pub const D3DNTDP2OP_VIEWPORTINFO = D3DNTHAL_DP2OPERATION.VIEWPORTINFO;
pub const D3DNTDP2OP_WINFO = D3DNTHAL_DP2OPERATION.WINFO;
pub const D3DNTDP2OP_SETPALETTE = D3DNTHAL_DP2OPERATION.SETPALETTE;
pub const D3DNTDP2OP_UPDATEPALETTE = D3DNTHAL_DP2OPERATION.UPDATEPALETTE;
pub const D3DNTDP2OP_ZRANGE = D3DNTHAL_DP2OPERATION.ZRANGE;
pub const D3DNTDP2OP_SETMATERIAL = D3DNTHAL_DP2OPERATION.SETMATERIAL;
pub const D3DNTDP2OP_SETLIGHT = D3DNTHAL_DP2OPERATION.SETLIGHT;
pub const D3DNTDP2OP_CREATELIGHT = D3DNTHAL_DP2OPERATION.CREATELIGHT;
pub const D3DNTDP2OP_SETTRANSFORM = D3DNTHAL_DP2OPERATION.SETTRANSFORM;
pub const D3DNTDP2OP_TEXBLT = D3DNTHAL_DP2OPERATION.TEXBLT;
pub const D3DNTDP2OP_STATESET = D3DNTHAL_DP2OPERATION.STATESET;
pub const D3DNTDP2OP_SETPRIORITY = D3DNTHAL_DP2OPERATION.SETPRIORITY;
pub const D3DNTDP2OP_SETRENDERTARGET = D3DNTHAL_DP2OPERATION.SETRENDERTARGET;
pub const D3DNTDP2OP_CLEAR = D3DNTHAL_DP2OPERATION.CLEAR;
pub const D3DNTDP2OP_SETTEXLOD = D3DNTHAL_DP2OPERATION.SETTEXLOD;
pub const D3DNTDP2OP_SETCLIPPLANE = D3DNTHAL_DP2OPERATION.SETCLIPPLANE;

pub const D3DNTHAL_DP2POINTS = extern struct {
    wCount: u16,
    wVStart: u16,
};

pub const D3DNTHAL_DP2STARTVERTEX = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2LINELIST = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDLINELIST = extern struct {
    wV1: u16,
    wV2: u16,
};

pub const D3DNTHAL_DP2LINESTRIP = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDLINESTRIP = extern struct {
    wV: [2]u16,
};

pub const D3DNTHAL_DP2TRIANGLELIST = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
    wFlags: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST2 = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
};

pub const D3DNTHAL_DP2TRIANGLESTRIP = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLESTRIP = extern struct {
    wV: [3]u16,
};

pub const D3DNTHAL_DP2TRIANGLEFAN = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLEFAN = extern struct {
    wV: [3]u16,
};

pub const D3DNTHAL_DP2TRIANGLEFAN_IMM = extern struct {
    dwEdgeFlags: u32,
};

pub const D3DNTHAL_DP2RENDERSTATE = extern struct {
    RenderState: D3DRENDERSTATETYPE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2TEXTURESTAGESTATE = extern struct {
    wStage: u16,
    TSState: u16,
    dwValue: u32,
};

pub const D3DNTHAL_DP2VIEWPORTINFO = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
};

pub const D3DNTHAL_DP2WINFO = extern struct {
    dvWNear: f32,
    dvWFar: f32,
};

pub const D3DNTHAL_DP2SETPALETTE = extern struct {
    dwPaletteHandle: u32,
    dwPaletteFlags: u32,
    dwSurfaceHandle: u32,
};

pub const D3DNTHAL_DP2UPDATEPALETTE = extern struct {
    dwPaletteHandle: u32,
    wStartIndex: u16,
    wNumEntries: u16,
};

pub const D3DNTHAL_DP2SETRENDERTARGET = extern struct {
    hRenderTarget: u32,
    hZBuffer: u32,
};

pub const D3DNTHAL_DP2STATESET = extern struct {
    dwOperation: u32,
    dwParam: u32,
    sbType: D3DSTATEBLOCKTYPE,
};

pub const D3DNTHAL_DP2ZRANGE = extern struct {
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DNTHAL_DP2SETLIGHT = extern struct {
    dwIndex: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2SETCLIPPLANE = extern struct {
    dwIndex: u32,
    plane: [4]f32,
};

pub const D3DNTHAL_DP2CREATELIGHT = extern struct {
    dwIndex: u32,
};

pub const D3DNTHAL_DP2SETTRANSFORM = extern struct {
    xfrmType: D3DTRANSFORMSTATETYPE,
    matrix: D3DMATRIX,
};

pub const D3DNTHAL_DP2EXT = extern struct {
    dwExtToken: u32,
    dwSize: u32,
};

pub const D3DNTHAL_DP2TEXBLT = extern struct {
    dwDDDestSurface: u32,
    dwDDSrcSurface: u32,
    pDest: POINT,
    rSrc: RECTL,
    dwFlags: u32,
};

pub const D3DNTHAL_DP2SETPRIORITY = extern struct {
    dwDDDestSurface: u32,
    dwPriority: u32,
};

pub const D3DNTHAL_DP2CLEAR = extern struct {
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    Rects: [1]RECT,
};

pub const D3DNTHAL_DP2SETTEXLOD = extern struct {
    dwDDSurface: u32,
    dwLOD: u32,
};

pub const D3DNTHAL_DRAWPRIMITIVES2DATA = extern struct {
    dwhContext: usize,
    dwFlags: u32,
    dwVertexType: u32,
    lpDDCommands: *DD_SURFACE_LOCAL,
    dwCommandOffset: u32,
    dwCommandLength: u32,
    Anonymous1: _Anonymous1_e__Union,
    dwVertexOffset: u32,
    dwVertexLength: u32,
    dwReqVertexBufSize: u32,
    dwReqCommandBufSize: u32,
    lpdwRStates: *u32,
    Anonymous2: _Anonymous2_e__Union,
    dwErrorOffset: u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const LPD3DNTHAL_CLEAR2CB = fn(
    param0: *D3DNTHAL_CLEAR2DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB = fn(
    param0: *D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_DRAWPRIMITIVES2CB = fn(
    param0: *D3DNTHAL_DRAWPRIMITIVES2DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Clear2: LPD3DNTHAL_CLEAR2CB,
    lpvReserved: *c_void,
    ValidateTextureStageState: LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB,
    DrawPrimitives2: LPD3DNTHAL_DRAWPRIMITIVES2CB,
};

pub const PFND3DNTPARSEUNKNOWNCOMMAND = fn(
    lpvCommands: *c_void,
    lplpvReturnedCommand: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const POINTE = extern struct {
    x: f32,
    y: f32,
};

pub const FLOAT_LONG = extern union {
    e: f32,
    l: i32,
};

pub const POINTFIX = extern struct {
    x: i32,
    y: i32,
};

pub const RECTFX = extern struct {
    xLeft: i32,
    yTop: i32,
    xRight: i32,
    yBottom: i32,
};

pub const LIGATURE = extern struct {
    culSize: u32,
    pwsz: PWSTR,
    chglyph: u32,
    ahglyph: [1]u32,
};

pub const FD_LIGATURE = extern struct {
    culThis: u32,
    ulType: u32,
    cLigatures: u32,
    alig: [1]LIGATURE,
};

pub const POINTQF = extern struct {
    x: LARGE_INTEGER,
    y: LARGE_INTEGER,
};

pub const PFN = fn(
) callconv(@import("std").os.windows.WINAPI) isize;

pub const CDDDXGK_REDIRBITMAPPRESENTINFO = extern struct {
    NumDirtyRects: u32,
    DirtyRect: *RECT,
    NumContexts: u32,
    hContext: [65]isize,
    bDoNotSynchronizeWithDxContent: u8,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const FREEOBJPROC = fn() callconv(@import("std").os.windows.WINAPI) void;

pub const XFORMOBJ = extern struct {
    ulReserved: u32,
};

pub const WNDOBJCHANGEPROC = fn(
    pwo: *WNDOBJ,
    fl: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const HSEMAPHORE__ = extern struct {
    unused: i32,
};

pub const SORTCOMP = fn(
    pv1: *const c_void,
    pv2: *const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENG_SYSTEM_ATTRIBUTE = extern enum(i32) {
    ProcessorFeature = 1,
    NumberOfProcessors = 2,
    OptimumAvailableUserMemory = 3,
    OptimumAvailableSystemMemory = 4,
};
pub const EngProcessorFeature = ENG_SYSTEM_ATTRIBUTE.ProcessorFeature;
pub const EngNumberOfProcessors = ENG_SYSTEM_ATTRIBUTE.NumberOfProcessors;
pub const EngOptimumAvailableUserMemory = ENG_SYSTEM_ATTRIBUTE.OptimumAvailableUserMemory;
pub const EngOptimumAvailableSystemMemory = ENG_SYSTEM_ATTRIBUTE.OptimumAvailableSystemMemory;

pub const ENG_DEVICE_ATTRIBUTE = extern enum(i32) {
    RESERVED = 0,
    ACCELERATION_LEVEL = 1,
};
pub const QDA_RESERVED = ENG_DEVICE_ATTRIBUTE.RESERVED;
pub const QDA_ACCELERATION_LEVEL = ENG_DEVICE_ATTRIBUTE.ACCELERATION_LEVEL;

pub const EMFINFO = extern struct {
    nSize: u32,
    hdc: HDC,
    pvEMF: *u8,
    pvCurrentRecord: *u8,
};

pub const PFN_DrvEnableDriver = fn(
    param0: u32,
    param1: u32,
    param2: *DRVENABLEDATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEnablePDEV = fn(
    param0: *DEVMODEW,
    param1: PWSTR,
    param2: u32,
    param3: *HSURF,
    param4: u32,
    param5: *GDIINFO,
    param6: u32,
    param7: *DEVINFO,
    param8: HDEV,
    param9: PWSTR,
    param10: HANDLE,
) callconv(@import("std").os.windows.WINAPI) DHPDEV;

pub const PFN_DrvCompletePDEV = fn(
    param0: DHPDEV,
    param1: HDEV,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvResetDevice = fn(
    param0: DHPDEV,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvDisablePDEV = fn(
    param0: DHPDEV,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSynchronize = fn(
    param0: DHPDEV,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvEnableSurface = fn(
    param0: DHPDEV,
) callconv(@import("std").os.windows.WINAPI) HSURF;

pub const PFN_DrvDisableDriver = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvDisableSurface = fn(
    param0: DHPDEV,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvAssertMode = fn(
    param0: DHPDEV,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvTextOut = fn(
    param0: *SURFOBJ,
    param1: *STROBJ,
    param2: *FONTOBJ,
    param3: *CLIPOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: *BRUSHOBJ,
    param7: *BRUSHOBJ,
    param8: *POINTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStretchBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *RECTL,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStretchBltROP = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *RECTL,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
    param11: *BRUSHOBJ,
    param12: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvTransparentBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: u32,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvPlgBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *POINTFIX,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvBitBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *RECTL,
    param6: *POINTL,
    param7: *POINTL,
    param8: *BRUSHOBJ,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvRealizeBrush = fn(
    param0: *BRUSHOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *SURFOBJ,
    param4: *XLATEOBJ,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvCopyBits = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDitherColor = fn(
    param0: DHPDEV,
    param1: u32,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvCreateDeviceBitmap = fn(
    param0: DHPDEV,
    param1: SIZE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvDeleteDeviceBitmap = fn(
    param0: DHSURF,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSetPalette = fn(
    param0: DHPDEV,
    param1: *PALOBJ,
    param2: u32,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEscape = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: u32,
    param3: *c_void,
    param4: u32,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvDrawEscape = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: *CLIPOBJ,
    param3: *RECTL,
    param4: u32,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvQueryFont = fn(
    param0: DHPDEV,
    param1: usize,
    param2: u32,
    param3: *usize,
) callconv(@import("std").os.windows.WINAPI) *IFIMETRICS;

pub const PFN_DrvQueryFontTree = fn(
    param0: DHPDEV,
    param1: usize,
    param2: u32,
    param3: u32,
    param4: *usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_DrvQueryFontData = fn(
    param0: DHPDEV,
    param1: *FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *GLYPHDATA,
    param5: *c_void,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvFree = fn(
    param0: *c_void,
    param1: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvDestroyFont = fn(
    param0: *FONTOBJ,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvQueryFontCaps = fn(
    param0: u32,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvLoadFontFile = fn(
    param0: u32,
    param1: *usize,
    param2: **c_void,
    param3: *u32,
    param4: *DESIGNVECTOR,
    param5: u32,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const PFN_DrvUnloadFontFile = fn(
    param0: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSetPointerShape = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *XLATEOBJ,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: i32,
    param8: *RECTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvMovePointer = fn(
    pso: *SURFOBJ,
    x: i32,
    y: i32,
    prcl: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSendPage = fn(
    param0: *SURFOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartPage = fn(
    pso: *SURFOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartDoc = fn(
    pso: *SURFOBJ,
    pwszDocName: PWSTR,
    dwJobId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEndDoc = fn(
    pso: *SURFOBJ,
    fl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQuerySpoolType = fn(
    dhpdev: DHPDEV,
    pwchType: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvLineTo = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *BRUSHOBJ,
    param3: i32,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: *RECTL,
    param8: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStrokePath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *XFORMOBJ,
    param4: *BRUSHOBJ,
    param5: *POINTL,
    param6: *LINEATTRS,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvFillPath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *BRUSHOBJ,
    param4: *POINTL,
    param5: u32,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStrokeAndFillPath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *XFORMOBJ,
    param4: *BRUSHOBJ,
    param5: *LINEATTRS,
    param6: *BRUSHOBJ,
    param7: *POINTL,
    param8: u32,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvPaint = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *BRUSHOBJ,
    param3: *POINTL,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvGetGlyphMode = fn(
    dhpdev: DHPDEV,
    pfo: *FONTOBJ,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvResetPDEV = fn(
    dhpdevOld: DHPDEV,
    dhpdevNew: DHPDEV,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSaveScreenBits = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: usize,
    param3: *RECTL,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const PFN_DrvGetModes = fn(
    param0: HANDLE,
    param1: u32,
    param2: *DEVMODEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvQueryTrueTypeTable = fn(
    param0: usize,
    param1: u32,
    param2: u32,
    param3: i32,
    param4: u32,
    param5: *u8,
    param6: **u8,
    param7: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryTrueTypeSection = fn(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: *HANDLE,
    param4: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryTrueTypeOutline = fn(
    param0: DHPDEV,
    param1: *FONTOBJ,
    param2: u32,
    param3: BOOL,
    param4: *GLYPHDATA,
    param5: u32,
    param6: *TTPOLYGONHEADER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvGetTrueTypeFile = fn(
    param0: usize,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_DrvQueryFontFile = fn(
    param0: usize,
    param1: u32,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryAdvanceWidths = fn(
    param0: DHPDEV,
    param1: *FONTOBJ,
    param2: u32,
    param3: *u32,
    param4: *c_void,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvFontManagement = fn(
    param0: *SURFOBJ,
    param1: *FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *c_void,
    param5: u32,
    param6: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvSetPixelFormat = fn(
    param0: *SURFOBJ,
    param1: i32,
    param2: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDescribePixelFormat = fn(
    param0: DHPDEV,
    param1: i32,
    param2: u32,
    param3: *PIXELFORMATDESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvSwapBuffers = fn(
    param0: *SURFOBJ,
    param1: *WNDOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartBanding = fn(
    param0: *SURFOBJ,
    ppointl: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvNextBand = fn(
    param0: *SURFOBJ,
    ppointl: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQueryPerBandInfo = fn(
    param0: *SURFOBJ,
    param1: *PERBANDINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEnableDirectDraw = fn(
    param0: DHPDEV,
    param1: *DD_CALLBACKS,
    param2: *DD_SURFACECALLBACKS,
    param3: *DD_PALETTECALLBACKS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDisableDirectDraw = fn(
    param0: DHPDEV,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvGetDirectDrawInfo = fn(
    param0: DHPDEV,
    param1: *DD_HALINFO,
    param2: *u32,
    param3: *VIDEOMEMORY,
    param4: *u32,
    param5: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmCreateColorTransform = fn(
    param0: DHPDEV,
    param1: *LOGCOLORSPACEW,
    param2: *c_void,
    param3: u32,
    param4: *c_void,
    param5: u32,
    param6: *c_void,
    param7: u32,
    param8: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PFN_DrvIcmDeleteColorTransform = fn(
    param0: DHPDEV,
    param1: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmCheckBitmapBits = fn(
    param0: DHPDEV,
    param1: HANDLE,
    param2: *SURFOBJ,
    param3: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmSetDeviceGammaRamp = fn(
    param0: DHPDEV,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvAlphaBlend = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: *BLENDOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvGradientFill = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *XLATEOBJ,
    param3: *TRIVERTEX,
    param4: u32,
    param5: *c_void,
    param6: u32,
    param7: *RECTL,
    param8: *POINTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQueryDeviceSupport = fn(
    param0: *SURFOBJ,
    param1: *XLATEOBJ,
    param2: *XFORMOBJ,
    param3: u32,
    param4: u32,
    param5: *c_void,
    param6: u32,
    param7: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDeriveSurface = fn(
    param0: *DD_DIRECTDRAW_GLOBAL,
    param1: *DD_SURFACE_LOCAL,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvSynchronizeSurface = fn(
    param0: *SURFOBJ,
    param1: *RECTL,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvNotify = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvRenderHint = fn(
    dhpdev: DHPDEV,
    NotifyCode: u32,
    Length: usize,
    // TODO: what to do with BytesParamIndex 2?
    Data: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DRH_APIBITMAPDATA = extern struct {
    pso: *SURFOBJ,
    b: BOOL,
};

pub const PFN_EngCreateRectRgn = fn(
    left: i32,
    top: i32,
    right: i32,
    bottom: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PFN_EngDeleteRgn = fn(
    hrgn: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_EngCombineRgn = fn(
    hrgnTrg: HANDLE,
    hrgnSrc1: HANDLE,
    hrgnSrc2: HANDLE,
    imode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngCopyRgn = fn(
    hrgnDst: HANDLE,
    hrgnSrc: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngIntersectRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngSubtractRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngUnionRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngXorRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvCreateDeviceBitmapEx = fn(
    param0: DHPDEV,
    param1: SIZE,
    param2: u32,
    param3: u32,
    param4: DHSURF,
    param5: u32,
    param6: u32,
    param7: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvDeleteDeviceBitmapEx = fn(
    param0: DHSURF,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvAssociateSharedSurface = fn(
    param0: *SURFOBJ,
    param1: HANDLE,
    param2: HANDLE,
    param3: SIZE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSynchronizeRedirectionBitmaps = fn(
    param0: DHPDEV,
    param1: *u64,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PFN_DrvAccumulateD3DDirtyRect = fn(
    param0: *SURFOBJ,
    param1: *CDDDXGK_REDIRBITMAPPRESENTINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartDxInterop = fn(
    param0: *SURFOBJ,
    param1: BOOL,
    KernelModeDeviceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEndDxInterop = fn(
    param0: *SURFOBJ,
    param1: BOOL,
    param2: *BOOL,
    KernelModeDeviceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvLockDisplayArea = fn(
    param0: DHPDEV,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvUnlockDisplayArea = fn(
    param0: DHPDEV,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSurfaceComplete = fn(
    param0: DHPDEV,
    param1: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const STORAGE_HOTPLUG_INFO = extern struct {
    Size: u32,
    MediaRemovable: u8,
    MediaHotplug: u8,
    DeviceHotplug: u8,
    WriteCacheEnableOverride: u8,
};

pub const STORAGE_DEVICE_NUMBER = extern struct {
    DeviceType: u32,
    DeviceNumber: u32,
    PartitionNumber: u32,
};

pub const STORAGE_DEVICE_NUMBERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfDevices: u32,
    Devices: [1]STORAGE_DEVICE_NUMBER,
};

pub const STORAGE_DEVICE_NUMBER_EX = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    DeviceType: u32,
    DeviceNumber: u32,
    DeviceGuid: Guid,
    PartitionNumber: u32,
};

pub const STORAGE_BUS_RESET_REQUEST = extern struct {
    PathId: u8,
};

pub const STORAGE_BREAK_RESERVATION_REQUEST = extern struct {
    Length: u32,
    _unused: u8,
    PathId: u8,
    TargetId: u8,
    Lun: u8,
};

pub const PREVENT_MEDIA_REMOVAL = extern struct {
    PreventMediaRemoval: u8,
};

pub const CLASS_MEDIA_CHANGE_CONTEXT = extern struct {
    MediaChangeCount: u32,
    NewState: u32,
};

pub const TAPE_STATISTICS = extern struct {
    Version: u32,
    Flags: u32,
    RecoveredWrites: LARGE_INTEGER,
    UnrecoveredWrites: LARGE_INTEGER,
    RecoveredReads: LARGE_INTEGER,
    UnrecoveredReads: LARGE_INTEGER,
    CompressionRatioReads: u8,
    CompressionRatioWrites: u8,
};

pub const TAPE_GET_STATISTICS = extern struct {
    Operation: u32,
};

pub const STORAGE_MEDIA_TYPE = extern enum(i32) {
    DDS_4mm = 32,
    MiniQic = 33,
    Travan = 34,
    QIC = 35,
    MP_8mm = 36,
    AME_8mm = 37,
    AIT1_8mm = 38,
    DLT = 39,
    NCTP = 40,
    IBM_3480 = 41,
    IBM_3490E = 42,
    IBM_Magstar_3590 = 43,
    IBM_Magstar_MP = 44,
    STK_DATA_D3 = 45,
    SONY_DTF = 46,
    DV_6mm = 47,
    DMI = 48,
    SONY_D2 = 49,
    CLEANER_CARTRIDGE = 50,
    CD_ROM = 51,
    CD_R = 52,
    CD_RW = 53,
    DVD_ROM = 54,
    DVD_R = 55,
    DVD_RW = 56,
    MO_3_RW = 57,
    MO_5_WO = 58,
    MO_5_RW = 59,
    MO_5_LIMDOW = 60,
    PC_5_WO = 61,
    PC_5_RW = 62,
    PD_5_RW = 63,
    ABL_5_WO = 64,
    PINNACLE_APEX_5_RW = 65,
    SONY_12_WO = 66,
    PHILIPS_12_WO = 67,
    HITACHI_12_WO = 68,
    CYGNET_12_WO = 69,
    KODAK_14_WO = 70,
    MO_NFR_525 = 71,
    NIKON_12_RW = 72,
    IOMEGA_ZIP = 73,
    IOMEGA_JAZ = 74,
    SYQUEST_EZ135 = 75,
    SYQUEST_EZFLYER = 76,
    SYQUEST_SYJET = 77,
    AVATAR_F2 = 78,
    MP2_8mm = 79,
    DST_S = 80,
    DST_M = 81,
    DST_L = 82,
    VXATape_1 = 83,
    VXATape_2 = 84,
    STK_9840 = 85,
    LTO_Ultrium = 86,
    LTO_Accelis = 87,
    DVD_RAM = 88,
    AIT_8mm = 89,
    ADR_1 = 90,
    ADR_2 = 91,
    STK_9940 = 92,
    SAIT = 93,
    VXATape = 94,
};
pub const DDS_4mm = STORAGE_MEDIA_TYPE.DDS_4mm;
pub const MiniQic = STORAGE_MEDIA_TYPE.MiniQic;
pub const Travan = STORAGE_MEDIA_TYPE.Travan;
pub const QIC = STORAGE_MEDIA_TYPE.QIC;
pub const MP_8mm = STORAGE_MEDIA_TYPE.MP_8mm;
pub const AME_8mm = STORAGE_MEDIA_TYPE.AME_8mm;
pub const AIT1_8mm = STORAGE_MEDIA_TYPE.AIT1_8mm;
pub const DLT = STORAGE_MEDIA_TYPE.DLT;
pub const NCTP = STORAGE_MEDIA_TYPE.NCTP;
pub const IBM_3480 = STORAGE_MEDIA_TYPE.IBM_3480;
pub const IBM_3490E = STORAGE_MEDIA_TYPE.IBM_3490E;
pub const IBM_Magstar_3590 = STORAGE_MEDIA_TYPE.IBM_Magstar_3590;
pub const IBM_Magstar_MP = STORAGE_MEDIA_TYPE.IBM_Magstar_MP;
pub const STK_DATA_D3 = STORAGE_MEDIA_TYPE.STK_DATA_D3;
pub const SONY_DTF = STORAGE_MEDIA_TYPE.SONY_DTF;
pub const DV_6mm = STORAGE_MEDIA_TYPE.DV_6mm;
pub const DMI = STORAGE_MEDIA_TYPE.DMI;
pub const SONY_D2 = STORAGE_MEDIA_TYPE.SONY_D2;
pub const CLEANER_CARTRIDGE = STORAGE_MEDIA_TYPE.CLEANER_CARTRIDGE;
pub const CD_ROM = STORAGE_MEDIA_TYPE.CD_ROM;
pub const CD_R = STORAGE_MEDIA_TYPE.CD_R;
pub const CD_RW = STORAGE_MEDIA_TYPE.CD_RW;
pub const DVD_ROM = STORAGE_MEDIA_TYPE.DVD_ROM;
pub const DVD_R = STORAGE_MEDIA_TYPE.DVD_R;
pub const DVD_RW = STORAGE_MEDIA_TYPE.DVD_RW;
pub const MO_3_RW = STORAGE_MEDIA_TYPE.MO_3_RW;
pub const MO_5_WO = STORAGE_MEDIA_TYPE.MO_5_WO;
pub const MO_5_RW = STORAGE_MEDIA_TYPE.MO_5_RW;
pub const MO_5_LIMDOW = STORAGE_MEDIA_TYPE.MO_5_LIMDOW;
pub const PC_5_WO = STORAGE_MEDIA_TYPE.PC_5_WO;
pub const PC_5_RW = STORAGE_MEDIA_TYPE.PC_5_RW;
pub const PD_5_RW = STORAGE_MEDIA_TYPE.PD_5_RW;
pub const ABL_5_WO = STORAGE_MEDIA_TYPE.ABL_5_WO;
pub const PINNACLE_APEX_5_RW = STORAGE_MEDIA_TYPE.PINNACLE_APEX_5_RW;
pub const SONY_12_WO = STORAGE_MEDIA_TYPE.SONY_12_WO;
pub const PHILIPS_12_WO = STORAGE_MEDIA_TYPE.PHILIPS_12_WO;
pub const HITACHI_12_WO = STORAGE_MEDIA_TYPE.HITACHI_12_WO;
pub const CYGNET_12_WO = STORAGE_MEDIA_TYPE.CYGNET_12_WO;
pub const KODAK_14_WO = STORAGE_MEDIA_TYPE.KODAK_14_WO;
pub const MO_NFR_525 = STORAGE_MEDIA_TYPE.MO_NFR_525;
pub const NIKON_12_RW = STORAGE_MEDIA_TYPE.NIKON_12_RW;
pub const IOMEGA_ZIP = STORAGE_MEDIA_TYPE.IOMEGA_ZIP;
pub const IOMEGA_JAZ = STORAGE_MEDIA_TYPE.IOMEGA_JAZ;
pub const SYQUEST_EZ135 = STORAGE_MEDIA_TYPE.SYQUEST_EZ135;
pub const SYQUEST_EZFLYER = STORAGE_MEDIA_TYPE.SYQUEST_EZFLYER;
pub const SYQUEST_SYJET = STORAGE_MEDIA_TYPE.SYQUEST_SYJET;
pub const AVATAR_F2 = STORAGE_MEDIA_TYPE.AVATAR_F2;
pub const MP2_8mm = STORAGE_MEDIA_TYPE.MP2_8mm;
pub const DST_S = STORAGE_MEDIA_TYPE.DST_S;
pub const DST_M = STORAGE_MEDIA_TYPE.DST_M;
pub const DST_L = STORAGE_MEDIA_TYPE.DST_L;
pub const VXATape_1 = STORAGE_MEDIA_TYPE.VXATape_1;
pub const VXATape_2 = STORAGE_MEDIA_TYPE.VXATape_2;
pub const STK_9840 = STORAGE_MEDIA_TYPE.STK_9840;
pub const LTO_Ultrium = STORAGE_MEDIA_TYPE.LTO_Ultrium;
pub const LTO_Accelis = STORAGE_MEDIA_TYPE.LTO_Accelis;
pub const DVD_RAM = STORAGE_MEDIA_TYPE.DVD_RAM;
pub const AIT_8mm = STORAGE_MEDIA_TYPE.AIT_8mm;
pub const ADR_1 = STORAGE_MEDIA_TYPE.ADR_1;
pub const ADR_2 = STORAGE_MEDIA_TYPE.ADR_2;
pub const STK_9940 = STORAGE_MEDIA_TYPE.STK_9940;
pub const SAIT = STORAGE_MEDIA_TYPE.SAIT;
pub const VXATape = STORAGE_MEDIA_TYPE.VXATape;

pub const STORAGE_BUS_TYPE = extern enum(i32) {
    Unknown = 0,
    Scsi = 1,
    Atapi = 2,
    Ata = 3,
    @"1394" = 4,
    Ssa = 5,
    Fibre = 6,
    Usb = 7,
    RAID = 8,
    iScsi = 9,
    Sas = 10,
    Sata = 11,
    Sd = 12,
    Mmc = 13,
    Virtual = 14,
    FileBackedVirtual = 15,
    Spaces = 16,
    Nvme = 17,
    SCM = 18,
    Ufs = 19,
    Max = 20,
    MaxReserved = 127,
};
pub const BusTypeUnknown = STORAGE_BUS_TYPE.Unknown;
pub const BusTypeScsi = STORAGE_BUS_TYPE.Scsi;
pub const BusTypeAtapi = STORAGE_BUS_TYPE.Atapi;
pub const BusTypeAta = STORAGE_BUS_TYPE.Ata;
pub const BusType1394 = STORAGE_BUS_TYPE.@"1394";
pub const BusTypeSsa = STORAGE_BUS_TYPE.Ssa;
pub const BusTypeFibre = STORAGE_BUS_TYPE.Fibre;
pub const BusTypeUsb = STORAGE_BUS_TYPE.Usb;
pub const BusTypeRAID = STORAGE_BUS_TYPE.RAID;
pub const BusTypeiScsi = STORAGE_BUS_TYPE.iScsi;
pub const BusTypeSas = STORAGE_BUS_TYPE.Sas;
pub const BusTypeSata = STORAGE_BUS_TYPE.Sata;
pub const BusTypeSd = STORAGE_BUS_TYPE.Sd;
pub const BusTypeMmc = STORAGE_BUS_TYPE.Mmc;
pub const BusTypeVirtual = STORAGE_BUS_TYPE.Virtual;
pub const BusTypeFileBackedVirtual = STORAGE_BUS_TYPE.FileBackedVirtual;
pub const BusTypeSpaces = STORAGE_BUS_TYPE.Spaces;
pub const BusTypeNvme = STORAGE_BUS_TYPE.Nvme;
pub const BusTypeSCM = STORAGE_BUS_TYPE.SCM;
pub const BusTypeUfs = STORAGE_BUS_TYPE.Ufs;
pub const BusTypeMax = STORAGE_BUS_TYPE.Max;
pub const BusTypeMaxReserved = STORAGE_BUS_TYPE.MaxReserved;

pub const DEVICE_MEDIA_INFO = extern struct {
    DeviceSpecific: _DeviceSpecific_e__Union,
    const _DeviceSpecific_e__Union = u32; // TODO: generate this nested type!
};

pub const GET_MEDIA_TYPES = extern struct {
    DeviceType: u32,
    MediaInfoCount: u32,
    MediaInfo: [1]DEVICE_MEDIA_INFO,
};

pub const STORAGE_PREDICT_FAILURE = extern struct {
    PredictFailure: u32,
    VendorSpecific: [512]u8,
};

pub const STORAGE_FAILURE_PREDICTION_CONFIG = extern struct {
    Version: u32,
    Size: u32,
    Set: u8,
    Enabled: u8,
    Reserved: u16,
};

pub const STORAGE_SET_TYPE = extern enum(i32) {
    StandardSet = 0,
    ExistsSet = 1,
    SetMaxDefined = 2,
};
pub const PropertyStandardSet = STORAGE_SET_TYPE.StandardSet;
pub const PropertyExistsSet = STORAGE_SET_TYPE.ExistsSet;
pub const PropertySetMaxDefined = STORAGE_SET_TYPE.SetMaxDefined;

pub const STORAGE_PROPERTY_SET = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    SetType: STORAGE_SET_TYPE,
    AdditionalParameters: [1]u8,
};

pub const STORAGE_IDENTIFIER_CODE_SET = extern enum(i32) {
    Reserved = 0,
    Binary = 1,
    Ascii = 2,
    Utf8 = 3,
};
pub const StorageIdCodeSetReserved = STORAGE_IDENTIFIER_CODE_SET.Reserved;
pub const StorageIdCodeSetBinary = STORAGE_IDENTIFIER_CODE_SET.Binary;
pub const StorageIdCodeSetAscii = STORAGE_IDENTIFIER_CODE_SET.Ascii;
pub const StorageIdCodeSetUtf8 = STORAGE_IDENTIFIER_CODE_SET.Utf8;

pub const STORAGE_IDENTIFIER_TYPE = extern enum(i32) {
    VendorSpecific = 0,
    VendorId = 1,
    EUI64 = 2,
    FCPHName = 3,
    PortRelative = 4,
    TargetPortGroup = 5,
    LogicalUnitGroup = 6,
    MD5LogicalUnitIdentifier = 7,
    ScsiNameString = 8,
};
pub const StorageIdTypeVendorSpecific = STORAGE_IDENTIFIER_TYPE.VendorSpecific;
pub const StorageIdTypeVendorId = STORAGE_IDENTIFIER_TYPE.VendorId;
pub const StorageIdTypeEUI64 = STORAGE_IDENTIFIER_TYPE.EUI64;
pub const StorageIdTypeFCPHName = STORAGE_IDENTIFIER_TYPE.FCPHName;
pub const StorageIdTypePortRelative = STORAGE_IDENTIFIER_TYPE.PortRelative;
pub const StorageIdTypeTargetPortGroup = STORAGE_IDENTIFIER_TYPE.TargetPortGroup;
pub const StorageIdTypeLogicalUnitGroup = STORAGE_IDENTIFIER_TYPE.LogicalUnitGroup;
pub const StorageIdTypeMD5LogicalUnitIdentifier = STORAGE_IDENTIFIER_TYPE.MD5LogicalUnitIdentifier;
pub const StorageIdTypeScsiNameString = STORAGE_IDENTIFIER_TYPE.ScsiNameString;

pub const STORAGE_ID_NAA_FORMAT = extern enum(i32) {
    Extended = 2,
    Registered = 3,
    ERegisteredExtended = 5,
};
pub const StorageIdNAAFormatIEEEExtended = STORAGE_ID_NAA_FORMAT.Extended;
pub const StorageIdNAAFormatIEEERegistered = STORAGE_ID_NAA_FORMAT.Registered;
pub const StorageIdNAAFormatIEEEERegisteredExtended = STORAGE_ID_NAA_FORMAT.ERegisteredExtended;

pub const STORAGE_ASSOCIATION_TYPE = extern enum(i32) {
    Device = 0,
    Port = 1,
    Target = 2,
};
pub const StorageIdAssocDevice = STORAGE_ASSOCIATION_TYPE.Device;
pub const StorageIdAssocPort = STORAGE_ASSOCIATION_TYPE.Port;
pub const StorageIdAssocTarget = STORAGE_ASSOCIATION_TYPE.Target;

pub const STORAGE_IDENTIFIER = extern struct {
    CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    Type: STORAGE_IDENTIFIER_TYPE,
    IdentifierSize: u16,
    NextOffset: u16,
    Association: STORAGE_ASSOCIATION_TYPE,
    Identifier: [1]u8,
};

pub const STORAGE_LB_PROVISIONING_MAP_RESOURCES = extern struct {
    Size: u32,
    Version: u32,
    _bitfield1: u8,
    Reserved1: [3]u8,
    _bitfield2: u8,
    Reserved3: [3]u8,
    AvailableMappingResources: u64,
    UsedMappingResources: u64,
};

pub const STORAGE_RPMB_FRAME_TYPE = extern enum(i32) {
    Unknown = 0,
    Standard = 1,
    Max = 2,
};
pub const StorageRpmbFrameTypeUnknown = STORAGE_RPMB_FRAME_TYPE.Unknown;
pub const StorageRpmbFrameTypeStandard = STORAGE_RPMB_FRAME_TYPE.Standard;
pub const StorageRpmbFrameTypeMax = STORAGE_RPMB_FRAME_TYPE.Max;

pub const STORAGE_RPMB_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    SizeInBytes: u32,
    MaxReliableWriteSizeInBytes: u32,
    FrameFormat: STORAGE_RPMB_FRAME_TYPE,
};

pub const STORAGE_CRYPTO_ALGORITHM_ID = extern enum(i32) {
    Unknown = 0,
    XTSAES = 1,
    BitlockerAESCBC = 2,
    AESECB = 3,
    ESSIVAESCBC = 4,
    Max = 5,
};
pub const StorageCryptoAlgorithmUnknown = STORAGE_CRYPTO_ALGORITHM_ID.Unknown;
pub const StorageCryptoAlgorithmXTSAES = STORAGE_CRYPTO_ALGORITHM_ID.XTSAES;
pub const StorageCryptoAlgorithmBitlockerAESCBC = STORAGE_CRYPTO_ALGORITHM_ID.BitlockerAESCBC;
pub const StorageCryptoAlgorithmAESECB = STORAGE_CRYPTO_ALGORITHM_ID.AESECB;
pub const StorageCryptoAlgorithmESSIVAESCBC = STORAGE_CRYPTO_ALGORITHM_ID.ESSIVAESCBC;
pub const StorageCryptoAlgorithmMax = STORAGE_CRYPTO_ALGORITHM_ID.Max;

pub const STORAGE_CRYPTO_KEY_SIZE = extern enum(i32) {
    Unknown = 0,
    @"128Bits" = 1,
    @"192Bits" = 2,
    @"256Bits" = 3,
    @"512Bits" = 4,
};
pub const StorageCryptoKeySizeUnknown = STORAGE_CRYPTO_KEY_SIZE.Unknown;
pub const StorageCryptoKeySize128Bits = STORAGE_CRYPTO_KEY_SIZE.@"128Bits";
pub const StorageCryptoKeySize192Bits = STORAGE_CRYPTO_KEY_SIZE.@"192Bits";
pub const StorageCryptoKeySize256Bits = STORAGE_CRYPTO_KEY_SIZE.@"256Bits";
pub const StorageCryptoKeySize512Bits = STORAGE_CRYPTO_KEY_SIZE.@"512Bits";

pub const STORAGE_CRYPTO_CAPABILITY = extern struct {
    Version: u32,
    Size: u32,
    CryptoCapabilityIndex: u32,
    AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    KeySize: STORAGE_CRYPTO_KEY_SIZE,
    DataUnitSizeBitmask: u32,
};

pub const STORAGE_CRYPTO_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumKeysSupported: u32,
    NumCryptoCapabilities: u32,
    CryptoCapabilities: [1]STORAGE_CRYPTO_CAPABILITY,
};

pub const STORAGE_TIER_MEDIA_TYPE = extern enum(i32) {
    Unspecified = 0,
    Disk = 1,
    Ssd = 2,
    Scm = 4,
    Max = 5,
};
pub const StorageTierMediaTypeUnspecified = STORAGE_TIER_MEDIA_TYPE.Unspecified;
pub const StorageTierMediaTypeDisk = STORAGE_TIER_MEDIA_TYPE.Disk;
pub const StorageTierMediaTypeSsd = STORAGE_TIER_MEDIA_TYPE.Ssd;
pub const StorageTierMediaTypeScm = STORAGE_TIER_MEDIA_TYPE.Scm;
pub const StorageTierMediaTypeMax = STORAGE_TIER_MEDIA_TYPE.Max;

pub const STORAGE_TIER_CLASS = extern enum(i32) {
    Unspecified = 0,
    Capacity = 1,
    Performance = 2,
    Max = 3,
};
pub const StorageTierClassUnspecified = STORAGE_TIER_CLASS.Unspecified;
pub const StorageTierClassCapacity = STORAGE_TIER_CLASS.Capacity;
pub const StorageTierClassPerformance = STORAGE_TIER_CLASS.Performance;
pub const StorageTierClassMax = STORAGE_TIER_CLASS.Max;

pub const STORAGE_TIER = extern struct {
    Id: Guid,
    Name: [256]u16,
    Description: [256]u16,
    Flags: u64,
    ProvisionedCapacity: u64,
    MediaType: STORAGE_TIER_MEDIA_TYPE,
    Class: STORAGE_TIER_CLASS,
};

pub const STORAGE_DEVICE_TIERING_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    TotalNumberOfTiers: u32,
    NumberOfTiersReturned: u32,
    Tiers: [1]STORAGE_TIER,
};

pub const STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumberOfFaultDomains: u32,
    FaultDomainIds: [1]Guid,
};

pub const STORAGE_PROTOCOL_UFS_DATA_TYPE = extern enum(i32) {
    Unknown = 0,
    QueryDescriptor = 1,
    Max = 2,
};
pub const UfsDataTypeUnknown = STORAGE_PROTOCOL_UFS_DATA_TYPE.Unknown;
pub const UfsDataTypeQueryDescriptor = STORAGE_PROTOCOL_UFS_DATA_TYPE.QueryDescriptor;
pub const UfsDataTypeMax = STORAGE_PROTOCOL_UFS_DATA_TYPE.Max;

pub const STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: u32,
    ProtocolDataValue: u32,
    ProtocolDataSubValue: u32,
    ProtocolDataOffset: u32,
    ProtocolDataLength: u32,
    FixedProtocolReturnData: u32,
    ProtocolDataSubValue2: u32,
    ProtocolDataSubValue3: u32,
    ProtocolDataSubValue4: u32,
    ProtocolDataSubValue5: u32,
    Reserved: [5]u32,
};

pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
};

pub const STORAGE_DISK_HEALTH_STATUS = extern enum(i32) {
    Unknown = 0,
    Unhealthy = 1,
    Warning = 2,
    Healthy = 3,
    Max = 4,
};
pub const DiskHealthUnknown = STORAGE_DISK_HEALTH_STATUS.Unknown;
pub const DiskHealthUnhealthy = STORAGE_DISK_HEALTH_STATUS.Unhealthy;
pub const DiskHealthWarning = STORAGE_DISK_HEALTH_STATUS.Warning;
pub const DiskHealthHealthy = STORAGE_DISK_HEALTH_STATUS.Healthy;
pub const DiskHealthMax = STORAGE_DISK_HEALTH_STATUS.Max;

pub const STORAGE_DISK_OPERATIONAL_STATUS = extern enum(i32) {
    None = 0,
    Unknown = 1,
    Ok = 2,
    PredictingFailure = 3,
    InService = 4,
    HardwareError = 5,
    NotUsable = 6,
    TransientError = 7,
    Missing = 8,
};
pub const DiskOpStatusNone = STORAGE_DISK_OPERATIONAL_STATUS.None;
pub const DiskOpStatusUnknown = STORAGE_DISK_OPERATIONAL_STATUS.Unknown;
pub const DiskOpStatusOk = STORAGE_DISK_OPERATIONAL_STATUS.Ok;
pub const DiskOpStatusPredictingFailure = STORAGE_DISK_OPERATIONAL_STATUS.PredictingFailure;
pub const DiskOpStatusInService = STORAGE_DISK_OPERATIONAL_STATUS.InService;
pub const DiskOpStatusHardwareError = STORAGE_DISK_OPERATIONAL_STATUS.HardwareError;
pub const DiskOpStatusNotUsable = STORAGE_DISK_OPERATIONAL_STATUS.NotUsable;
pub const DiskOpStatusTransientError = STORAGE_DISK_OPERATIONAL_STATUS.TransientError;
pub const DiskOpStatusMissing = STORAGE_DISK_OPERATIONAL_STATUS.Missing;

pub const STORAGE_OPERATIONAL_STATUS_REASON = extern enum(i32) {
    Unknown = 0,
    ScsiSenseCode = 1,
    Media = 2,
    Io = 3,
    ThresholdExceeded = 4,
    LostData = 5,
    EnergySource = 6,
    Configuration = 7,
    DeviceController = 8,
    MediaController = 9,
    Component = 10,
    NVDIMM_N = 11,
    BackgroundOperation = 12,
    InvalidFirmware = 13,
    HealthCheck = 14,
    LostDataPersistence = 15,
    DisabledByPlatform = 16,
    LostWritePersistence = 17,
    DataPersistenceLossImminent = 18,
    WritePersistenceLossImminent = 19,
    Max = 20,
};
pub const DiskOpReasonUnknown = STORAGE_OPERATIONAL_STATUS_REASON.Unknown;
pub const DiskOpReasonScsiSenseCode = STORAGE_OPERATIONAL_STATUS_REASON.ScsiSenseCode;
pub const DiskOpReasonMedia = STORAGE_OPERATIONAL_STATUS_REASON.Media;
pub const DiskOpReasonIo = STORAGE_OPERATIONAL_STATUS_REASON.Io;
pub const DiskOpReasonThresholdExceeded = STORAGE_OPERATIONAL_STATUS_REASON.ThresholdExceeded;
pub const DiskOpReasonLostData = STORAGE_OPERATIONAL_STATUS_REASON.LostData;
pub const DiskOpReasonEnergySource = STORAGE_OPERATIONAL_STATUS_REASON.EnergySource;
pub const DiskOpReasonConfiguration = STORAGE_OPERATIONAL_STATUS_REASON.Configuration;
pub const DiskOpReasonDeviceController = STORAGE_OPERATIONAL_STATUS_REASON.DeviceController;
pub const DiskOpReasonMediaController = STORAGE_OPERATIONAL_STATUS_REASON.MediaController;
pub const DiskOpReasonComponent = STORAGE_OPERATIONAL_STATUS_REASON.Component;
pub const DiskOpReasonNVDIMM_N = STORAGE_OPERATIONAL_STATUS_REASON.NVDIMM_N;
pub const DiskOpReasonBackgroundOperation = STORAGE_OPERATIONAL_STATUS_REASON.BackgroundOperation;
pub const DiskOpReasonInvalidFirmware = STORAGE_OPERATIONAL_STATUS_REASON.InvalidFirmware;
pub const DiskOpReasonHealthCheck = STORAGE_OPERATIONAL_STATUS_REASON.HealthCheck;
pub const DiskOpReasonLostDataPersistence = STORAGE_OPERATIONAL_STATUS_REASON.LostDataPersistence;
pub const DiskOpReasonDisabledByPlatform = STORAGE_OPERATIONAL_STATUS_REASON.DisabledByPlatform;
pub const DiskOpReasonLostWritePersistence = STORAGE_OPERATIONAL_STATUS_REASON.LostWritePersistence;
pub const DiskOpReasonDataPersistenceLossImminent = STORAGE_OPERATIONAL_STATUS_REASON.DataPersistenceLossImminent;
pub const DiskOpReasonWritePersistenceLossImminent = STORAGE_OPERATIONAL_STATUS_REASON.WritePersistenceLossImminent;
pub const DiskOpReasonMax = STORAGE_OPERATIONAL_STATUS_REASON.Max;

pub const STORAGE_OPERATIONAL_REASON = extern struct {
    Version: u32,
    Size: u32,
    Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    RawBytes: _RawBytes_e__Union,
    const _RawBytes_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_DEVICE_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: STORAGE_DISK_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: [16]STORAGE_DISK_OPERATIONAL_STATUS,
    AdditionalReasons: [1]STORAGE_OPERATIONAL_REASON,
};

pub const STORAGE_ZONED_DEVICE_TYPES = extern enum(i32) {
    Unknown = 0,
    HostManaged = 1,
    HostAware = 2,
    DeviceManaged = 3,
};
pub const ZonedDeviceTypeUnknown = STORAGE_ZONED_DEVICE_TYPES.Unknown;
pub const ZonedDeviceTypeHostManaged = STORAGE_ZONED_DEVICE_TYPES.HostManaged;
pub const ZonedDeviceTypeHostAware = STORAGE_ZONED_DEVICE_TYPES.HostAware;
pub const ZonedDeviceTypeDeviceManaged = STORAGE_ZONED_DEVICE_TYPES.DeviceManaged;

pub const STORAGE_ZONE_TYPES = extern enum(i32) {
    Unknown = 0,
    Conventional = 1,
    SequentialWriteRequired = 2,
    SequentialWritePreferred = 3,
    Max = 4,
};
pub const ZoneTypeUnknown = STORAGE_ZONE_TYPES.Unknown;
pub const ZoneTypeConventional = STORAGE_ZONE_TYPES.Conventional;
pub const ZoneTypeSequentialWriteRequired = STORAGE_ZONE_TYPES.SequentialWriteRequired;
pub const ZoneTypeSequentialWritePreferred = STORAGE_ZONE_TYPES.SequentialWritePreferred;
pub const ZoneTypeMax = STORAGE_ZONE_TYPES.Max;

pub const STORAGE_ZONE_GROUP = extern struct {
    ZoneCount: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneSize: u64,
};

pub const STORAGE_ZONED_DEVICE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    ZoneCount: u32,
    ZoneAttributes: _ZoneAttributes_e__Union,
    ZoneGroupCount: u32,
    ZoneGroup: [1]STORAGE_ZONE_GROUP,
    const _ZoneAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_LOCATION = extern struct {
    Socket: u32,
    Slot: u32,
    Adapter: u32,
    Port: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_DEVICE_LOCATION_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Location: DEVICE_LOCATION,
    StringOffset: u32,
};

pub const STORAGE_DEVICE_NUMA_PROPERTY = extern struct {
    Version: u32,
    Size: u32,
    NumaNode: u32,
};

pub const STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = extern struct {
    Version: u32,
    Size: u32,
    UnsafeShutdownCount: u32,
};

pub const STORAGE_HW_ENDURANCE_INFO = extern struct {
    ValidFields: u32,
    GroupId: u32,
    Flags: _Flags_e__Struct,
    LifePercentage: u32,
    BytesReadCount: [16]u8,
    ByteWriteCount: [16]u8,
    const _Flags_e__Struct = u32; // TODO: generate this nested type!
};

pub const STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
};

pub const DEVICE_DATA_SET_RANGE = extern struct {
    StartingOffset: i64,
    LengthInBytes: u64,
};

pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    ParameterBlockOffset: u32,
    ParameterBlockLength: u32,
    DataSetRangesOffset: u32,
    DataSetRangesLength: u32,
};

pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    OperationStatus: u32,
    ExtendedError: u32,
    TargetDetailedError: u32,
    ReservedStatus: u32,
    OutputBlockOffset: u32,
    OutputBlockLength: u32,
};

pub const DEVICE_DSM_DEFINITION = extern struct {
    Action: u32,
    SingleRange: u8,
    ParameterBlockAlignment: u32,
    ParameterBlockLength: u32,
    HasOutput: u8,
    OutputBlockAlignment: u32,
    OutputBlockLength: u32,
};

pub const DEVICE_DSM_NOTIFICATION_PARAMETERS = extern struct {
    Size: u32,
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: [1]Guid,
};

pub const STORAGE_OFFLOAD_TOKEN = extern struct {
    TokenType: [4]u8,
    Reserved: [2]u8,
    TokenIdLength: [2]u8,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_DSM_OFFLOAD_READ_PARAMETERS = extern struct {
    Flags: u32,
    TimeToLive: u32,
    Reserved: [2]u32,
};

pub const STORAGE_OFFLOAD_READ_OUTPUT = extern struct {
    OffloadReadFlags: u32,
    Reserved: u32,
    LengthProtected: u64,
    TokenLength: u32,
    Token: STORAGE_OFFLOAD_TOKEN,
};

pub const DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = extern struct {
    Flags: u32,
    Reserved: u32,
    TokenOffset: u64,
    Token: STORAGE_OFFLOAD_TOKEN,
};

pub const STORAGE_OFFLOAD_WRITE_OUTPUT = extern struct {
    OffloadWriteFlags: u32,
    Reserved: u32,
    LengthCopied: u64,
};

pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    OutputVersion: u32,
};

pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u32,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: [1]u32,
};

pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u64,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: [1]u32,
};

pub const DEVICE_DATA_SET_REPAIR_PARAMETERS = extern struct {
    NumberOfRepairCopies: u32,
    SourceCopy: u32,
    RepairCopies: [1]u32,
};

pub const DEVICE_DATA_SET_REPAIR_OUTPUT = extern struct {
    ParityExtent: DEVICE_DATA_SET_RANGE,
};

pub const DEVICE_DATA_SET_SCRUB_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
};

pub const DEVICE_DATA_SET_SCRUB_EX_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
    ParityExtent: DEVICE_DATA_SET_RANGE,
};

pub const DEVICE_DSM_TIERING_QUERY_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NumberOfTierIds: u32,
    TierIds: [1]Guid,
};

pub const STORAGE_TIER_REGION = extern struct {
    TierId: Guid,
    Offset: u64,
    Length: u64,
};

pub const DEVICE_DSM_TIERING_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
    Alignment: u64,
    TotalNumberOfRegions: u32,
    NumberOfRegionsReturned: u32,
    Regions: [1]STORAGE_TIER_REGION,
};

pub const DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = extern struct {
    Size: u32,
    TargetPriority: u8,
    Reserved: [3]u8,
};

pub const DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = extern struct {
    TopologyRangeBytes: u64,
    TopologyId: [16]u8,
};

pub const DEVICE_STORAGE_ADDRESS_RANGE = extern struct {
    StartAddress: i64,
    LengthInBytes: u64,
};

pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: [1]DEVICE_STORAGE_ADDRESS_RANGE,
};

pub const DEVICE_DSM_REPORT_ZONES_PARAMETERS = extern struct {
    Size: u32,
    ReportOption: u8,
    Partial: u8,
    Reserved: [2]u8,
};

pub const STORAGE_ZONES_ATTRIBUTES = extern enum(i32) {
    AndLengthMayDifferent = 0,
    SameLengthSame = 1,
    SameLastZoneLengthDifferent = 2,
    MayDifferentLengthSame = 3,
};
pub const ZonesAttributeTypeAndLengthMayDifferent = STORAGE_ZONES_ATTRIBUTES.AndLengthMayDifferent;
pub const ZonesAttributeTypeSameLengthSame = STORAGE_ZONES_ATTRIBUTES.SameLengthSame;
pub const ZonesAttributeTypeSameLastZoneLengthDifferent = STORAGE_ZONES_ATTRIBUTES.SameLastZoneLengthDifferent;
pub const ZonesAttributeTypeMayDifferentLengthSame = STORAGE_ZONES_ATTRIBUTES.MayDifferentLengthSame;

pub const STORAGE_ZONE_CONDITION = extern enum(i32) {
    Conventional = 0,
    Empty = 1,
    ImplicitlyOpened = 2,
    ExplicitlyOpened = 3,
    Closed = 4,
    ReadOnly = 13,
    Full = 14,
    Offline = 15,
};
pub const ZoneConditionConventional = STORAGE_ZONE_CONDITION.Conventional;
pub const ZoneConditionEmpty = STORAGE_ZONE_CONDITION.Empty;
pub const ZoneConditionImplicitlyOpened = STORAGE_ZONE_CONDITION.ImplicitlyOpened;
pub const ZoneConditionExplicitlyOpened = STORAGE_ZONE_CONDITION.ExplicitlyOpened;
pub const ZoneConditionClosed = STORAGE_ZONE_CONDITION.Closed;
pub const ZoneConditionReadOnly = STORAGE_ZONE_CONDITION.ReadOnly;
pub const ZoneConditionFull = STORAGE_ZONE_CONDITION.Full;
pub const ZoneConditionOffline = STORAGE_ZONE_CONDITION.Offline;

pub const STORAGE_ZONE_DESCRIPTOR = extern struct {
    Size: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneCondition: STORAGE_ZONE_CONDITION,
    ResetWritePointerRecommend: u8,
    Reserved0: [3]u8,
    ZoneSize: u64,
    WritePointerOffset: u64,
};

pub const DEVICE_DSM_REPORT_ZONES_DATA = extern struct {
    Size: u32,
    ZoneCount: u32,
    Attributes: STORAGE_ZONES_ATTRIBUTES,
    Reserved0: u32,
    ZoneDescriptors: [1]STORAGE_ZONE_DESCRIPTOR,
};

pub const DEVICE_STORAGE_RANGE_ATTRIBUTES = extern struct {
    LengthInBytes: u64,
    Anonymous: _Anonymous_e__Union,
    Reserved: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_DSM_RANGE_ERROR_INFO = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: [1]DEVICE_STORAGE_RANGE_ATTRIBUTES,
};

pub const DEVICE_DSM_LOST_QUERY_PARAMETERS = extern struct {
    Version: u32,
    Granularity: u64,
};

pub const DEVICE_DSM_LOST_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Alignment: u64,
    NumberOfBits: u32,
    BitMap: [1]u32,
};

pub const DEVICE_DSM_FREE_SPACE_OUTPUT = extern struct {
    Version: u32,
    FreeSpace: u64,
};

pub const DEVICE_DSM_CONVERSION_OUTPUT = extern struct {
    Version: u32,
    Source: Guid,
};

pub const STORAGE_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};

pub const STORAGE_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: u8,
    Discardable: u8,
    Reserved1: [2]u8,
    AccessType: u32,
    AccessMode: u32,
};

pub const STORAGE_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};

pub const STORAGE_PRIORITY_HINT_SUPPORT = extern struct {
    SupportFlags: u32,
};

pub const STORAGE_DIAGNOSTIC_LEVEL = extern enum(i32) {
    Default = 0,
    Max = 1,
};
pub const StorageDiagnosticLevelDefault = STORAGE_DIAGNOSTIC_LEVEL.Default;
pub const StorageDiagnosticLevelMax = STORAGE_DIAGNOSTIC_LEVEL.Max;

pub const STORAGE_DIAGNOSTIC_TARGET_TYPE = extern enum(i32) {
    Undefined = 0,
    Port = 1,
    Miniport = 2,
    HbaFirmware = 3,
    Max = 4,
};
pub const StorageDiagnosticTargetTypeUndefined = STORAGE_DIAGNOSTIC_TARGET_TYPE.Undefined;
pub const StorageDiagnosticTargetTypePort = STORAGE_DIAGNOSTIC_TARGET_TYPE.Port;
pub const StorageDiagnosticTargetTypeMiniport = STORAGE_DIAGNOSTIC_TARGET_TYPE.Miniport;
pub const StorageDiagnosticTargetTypeHbaFirmware = STORAGE_DIAGNOSTIC_TARGET_TYPE.HbaFirmware;
pub const StorageDiagnosticTargetTypeMax = STORAGE_DIAGNOSTIC_TARGET_TYPE.Max;

pub const STORAGE_DIAGNOSTIC_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    Reserved: u32,
    TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    Level: STORAGE_DIAGNOSTIC_LEVEL,
};

pub const STORAGE_DIAGNOSTIC_DATA = extern struct {
    Version: u32,
    Size: u32,
    ProviderId: Guid,
    BufferSize: u32,
    Reserved: u32,
    DiagnosticDataBuffer: [1]u8,
};

pub const PHYSICAL_ELEMENT_STATUS_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    StartingElement: u32,
    Filter: u8,
    ReportType: u8,
    Reserved: [2]u8,
};

pub const PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    ElementIdentifier: u32,
    PhysicalElementType: u8,
    PhysicalElementHealth: u8,
    Reserved1: [2]u8,
    AssociatedCapacity: u64,
    Reserved2: [4]u32,
};

pub const PHYSICAL_ELEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    DescriptorCount: u32,
    ReturnedDescriptorCount: u32,
    ElementIdentifierBeingDepoped: u32,
    Reserved: u32,
    Descriptors: [1]PHYSICAL_ELEMENT_STATUS_DESCRIPTOR,
};

pub const REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestCapacity: u64,
    ElementIdentifier: u32,
    Reserved: u32,
};

pub const DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = extern enum(i32) {
    InternalStatusDataRequestTypeUndefined = 0,
    CurrentInternalStatusDataHeader = 1,
    CurrentInternalStatusData = 2,
};
pub const DeviceInternalStatusDataRequestTypeUndefined = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.InternalStatusDataRequestTypeUndefined;
pub const DeviceCurrentInternalStatusDataHeader = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.CurrentInternalStatusDataHeader;
pub const DeviceCurrentInternalStatusData = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.CurrentInternalStatusData;

pub const DEVICE_INTERNAL_STATUS_DATA_SET = extern enum(i32) {
    Undefined = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    Max = 5,
};
pub const DeviceStatusDataSetUndefined = DEVICE_INTERNAL_STATUS_DATA_SET.Undefined;
pub const DeviceStatusDataSet1 = DEVICE_INTERNAL_STATUS_DATA_SET.@"1";
pub const DeviceStatusDataSet2 = DEVICE_INTERNAL_STATUS_DATA_SET.@"2";
pub const DeviceStatusDataSet3 = DEVICE_INTERNAL_STATUS_DATA_SET.@"3";
pub const DeviceStatusDataSet4 = DEVICE_INTERNAL_STATUS_DATA_SET.@"4";
pub const DeviceStatusDataSetMax = DEVICE_INTERNAL_STATUS_DATA_SET.Max;

pub const GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestDataType: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE,
    RequestDataSet: DEVICE_INTERNAL_STATUS_DATA_SET,
};

pub const DEVICE_INTERNAL_STATUS_DATA = extern struct {
    Version: u32,
    Size: u32,
    T10VendorId: u64,
    DataSet1Length: u32,
    DataSet2Length: u32,
    DataSet3Length: u32,
    DataSet4Length: u32,
    StatusDataVersion: u8,
    Reserved: [3]u8,
    ReasonIdentifier: [128]u8,
    StatusDataLength: u32,
    StatusData: [1]u8,
};

pub const STORAGE_MEDIA_SERIAL_NUMBER_DATA = extern struct {
    Reserved: u16,
    SerialNumberLength: u16,
    SerialNumber: [1]u8,
};

pub const STORAGE_READ_CAPACITY = extern struct {
    Version: u32,
    Size: u32,
    BlockLength: u32,
    NumberOfBlocks: LARGE_INTEGER,
    DiskLength: LARGE_INTEGER,
};

pub const PERSISTENT_RESERVE_COMMAND = extern struct {
    Version: u32,
    Size: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const _DEVICEDUMP_COLLECTION_TYPE = extern enum(i32) {
    BugCheck = 1,
    ApplicationRequested = 2,
    DeviceRequested = 3,
};
pub const TCCollectionBugCheck = _DEVICEDUMP_COLLECTION_TYPE.BugCheck;
pub const TCCollectionApplicationRequested = _DEVICEDUMP_COLLECTION_TYPE.ApplicationRequested;
pub const TCCollectionDeviceRequested = _DEVICEDUMP_COLLECTION_TYPE.DeviceRequested;

pub const DEVICEDUMP_SUBSECTION_POINTER = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwOffset: u32,
};

pub const DEVICEDUMP_STRUCTURE_VERSION = extern struct {
    dwSignature: u32,
    dwVersion: u32,
    dwSize: u32,
};

pub const DEVICEDUMP_SECTION_HEADER = extern struct {
    guidDeviceDataId: Guid,
    sOrganizationID: [16]u8,
    dwFirmwareRevision: u32,
    sModelNumber: [32]u8,
    szDeviceManufacturingID: [32]u8,
    dwFlags: u32,
    bRestrictedPrivateDataVersion: u32,
    dwFirmwareIssueId: u32,
    szIssueDescriptionString: [132]u8,
};

pub const GP_LOG_PAGE_DESCRIPTOR = extern struct {
    LogAddress: u16,
    LogSectors: u16,
};

pub const DEVICEDUMP_PUBLIC_SUBSECTION = extern struct {
    dwFlags: u32,
    GPLogTable: [16]GP_LOG_PAGE_DESCRIPTOR,
    szDescription: [16]CHAR,
    bData: [1]u8,
};

pub const DEVICEDUMP_RESTRICTED_SUBSECTION = extern struct {
    bData: [1]u8,
};

pub const DEVICEDUMP_PRIVATE_SUBSECTION = extern struct {
    dwFlags: u32,
    GPLogId: GP_LOG_PAGE_DESCRIPTOR,
    bData: [1]u8,
};

pub const DEVICEDUMP_STORAGEDEVICE_DATA = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    SectionHeader: DEVICEDUMP_SECTION_HEADER,
    dwBufferSize: u32,
    dwReasonForCollection: u32,
    PublicData: DEVICEDUMP_SUBSECTION_POINTER,
    RestrictedData: DEVICEDUMP_SUBSECTION_POINTER,
    PrivateData: DEVICEDUMP_SUBSECTION_POINTER,
};

pub const DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = extern struct {
    Cdb: [16]u8,
    Command: [16]u8,
    StartTime: u64,
    EndTime: u64,
    OperationStatus: u32,
    OperationError: u32,
    StackSpecific: _StackSpecific_e__Union,
    const _StackSpecific_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    dwReasonForCollection: u32,
    cDriverName: [16]u8,
    uiNumRecords: u32,
    RecordArray: [1]DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD,
};

pub const STORAGE_IDLE_POWER = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u32,
    D3IdleTimeout: u32,
};

pub const STORAGE_POWERUP_REASON_TYPE = extern enum(i32) {
    Unknown = 0,
    IO = 1,
    DeviceAttention = 2,
};
pub const StoragePowerupUnknown = STORAGE_POWERUP_REASON_TYPE.Unknown;
pub const StoragePowerupIO = STORAGE_POWERUP_REASON_TYPE.IO;
pub const StoragePowerupDeviceAttention = STORAGE_POWERUP_REASON_TYPE.DeviceAttention;

pub const STORAGE_IDLE_POWERUP_REASON = extern struct {
    Version: u32,
    Size: u32,
    PowerupReason: STORAGE_POWERUP_REASON_TYPE,
};

pub const STORAGE_RPMB_DATA_FRAME = extern struct {
    Stuff: [196]u8,
    KeyOrMAC: [32]u8,
    Data: [256]u8,
    Nonce: [16]u8,
    WriteCounter: [4]u8,
    Address: [2]u8,
    BlockCount: [2]u8,
    OperationResult: [2]u8,
    RequestOrResponseType: [2]u8,
};

pub const STORAGE_RPMB_COMMAND_TYPE = extern enum(i32) {
    ProgramAuthKey = 1,
    QueryWriteCounter = 2,
    AuthenticatedWrite = 3,
    AuthenticatedRead = 4,
    ReadResultRequest = 5,
    AuthenticatedDeviceConfigWrite = 6,
    AuthenticatedDeviceConfigRead = 7,
};
pub const StorRpmbProgramAuthKey = STORAGE_RPMB_COMMAND_TYPE.ProgramAuthKey;
pub const StorRpmbQueryWriteCounter = STORAGE_RPMB_COMMAND_TYPE.QueryWriteCounter;
pub const StorRpmbAuthenticatedWrite = STORAGE_RPMB_COMMAND_TYPE.AuthenticatedWrite;
pub const StorRpmbAuthenticatedRead = STORAGE_RPMB_COMMAND_TYPE.AuthenticatedRead;
pub const StorRpmbReadResultRequest = STORAGE_RPMB_COMMAND_TYPE.ReadResultRequest;
pub const StorRpmbAuthenticatedDeviceConfigWrite = STORAGE_RPMB_COMMAND_TYPE.AuthenticatedDeviceConfigWrite;
pub const StorRpmbAuthenticatedDeviceConfigRead = STORAGE_RPMB_COMMAND_TYPE.AuthenticatedDeviceConfigRead;

pub const STORAGE_EVENT_NOTIFICATION = extern struct {
    Version: u32,
    Size: u32,
    Events: u64,
};

pub const STORAGE_COUNTER_TYPE = extern enum(i32) {
    Unknown = 0,
    TemperatureCelsius = 1,
    TemperatureCelsiusMax = 2,
    ReadErrorsTotal = 3,
    ReadErrorsCorrected = 4,
    ReadErrorsUncorrected = 5,
    WriteErrorsTotal = 6,
    WriteErrorsCorrected = 7,
    WriteErrorsUncorrected = 8,
    ManufactureDate = 9,
    StartStopCycleCount = 10,
    StartStopCycleCountMax = 11,
    LoadUnloadCycleCount = 12,
    LoadUnloadCycleCountMax = 13,
    WearPercentage = 14,
    WearPercentageWarning = 15,
    WearPercentageMax = 16,
    PowerOnHours = 17,
    ReadLatency100NSMax = 18,
    WriteLatency100NSMax = 19,
    FlushLatency100NSMax = 20,
    Max = 21,
};
pub const StorageCounterTypeUnknown = STORAGE_COUNTER_TYPE.Unknown;
pub const StorageCounterTypeTemperatureCelsius = STORAGE_COUNTER_TYPE.TemperatureCelsius;
pub const StorageCounterTypeTemperatureCelsiusMax = STORAGE_COUNTER_TYPE.TemperatureCelsiusMax;
pub const StorageCounterTypeReadErrorsTotal = STORAGE_COUNTER_TYPE.ReadErrorsTotal;
pub const StorageCounterTypeReadErrorsCorrected = STORAGE_COUNTER_TYPE.ReadErrorsCorrected;
pub const StorageCounterTypeReadErrorsUncorrected = STORAGE_COUNTER_TYPE.ReadErrorsUncorrected;
pub const StorageCounterTypeWriteErrorsTotal = STORAGE_COUNTER_TYPE.WriteErrorsTotal;
pub const StorageCounterTypeWriteErrorsCorrected = STORAGE_COUNTER_TYPE.WriteErrorsCorrected;
pub const StorageCounterTypeWriteErrorsUncorrected = STORAGE_COUNTER_TYPE.WriteErrorsUncorrected;
pub const StorageCounterTypeManufactureDate = STORAGE_COUNTER_TYPE.ManufactureDate;
pub const StorageCounterTypeStartStopCycleCount = STORAGE_COUNTER_TYPE.StartStopCycleCount;
pub const StorageCounterTypeStartStopCycleCountMax = STORAGE_COUNTER_TYPE.StartStopCycleCountMax;
pub const StorageCounterTypeLoadUnloadCycleCount = STORAGE_COUNTER_TYPE.LoadUnloadCycleCount;
pub const StorageCounterTypeLoadUnloadCycleCountMax = STORAGE_COUNTER_TYPE.LoadUnloadCycleCountMax;
pub const StorageCounterTypeWearPercentage = STORAGE_COUNTER_TYPE.WearPercentage;
pub const StorageCounterTypeWearPercentageWarning = STORAGE_COUNTER_TYPE.WearPercentageWarning;
pub const StorageCounterTypeWearPercentageMax = STORAGE_COUNTER_TYPE.WearPercentageMax;
pub const StorageCounterTypePowerOnHours = STORAGE_COUNTER_TYPE.PowerOnHours;
pub const StorageCounterTypeReadLatency100NSMax = STORAGE_COUNTER_TYPE.ReadLatency100NSMax;
pub const StorageCounterTypeWriteLatency100NSMax = STORAGE_COUNTER_TYPE.WriteLatency100NSMax;
pub const StorageCounterTypeFlushLatency100NSMax = STORAGE_COUNTER_TYPE.FlushLatency100NSMax;
pub const StorageCounterTypeMax = STORAGE_COUNTER_TYPE.Max;

pub const STORAGE_COUNTER = extern struct {
    Type: STORAGE_COUNTER_TYPE,
    Value: _Value_e__Union,
    const _Value_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_COUNTERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfCounters: u32,
    Counters: [1]STORAGE_COUNTER,
};

pub const STORAGE_HW_FIRMWARE_INFO_QUERY = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
};

pub const STORAGE_HW_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: [6]u8,
    Revision: [16]u8,
};

pub const STORAGE_HW_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u8,
    SlotCount: u8,
    ActiveSlot: u8,
    PendingActivateSlot: u8,
    FirmwareShared: u8,
    Reserved: [3]u8,
    ImagePayloadAlignment: u32,
    ImagePayloadMaxSize: u32,
    Slot: [1]STORAGE_HW_FIRMWARE_SLOT_INFO,
};

pub const STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: [3]u8,
    Offset: u64,
    BufferSize: u64,
    ImageSize: u32,
    Reserved2: u32,
    ImageBuffer: [1]u8,
};

pub const STORAGE_ATTRIBUTE_MGMT_ACTION = extern enum(i32) {
    ClearAttribute = 0,
    SetAttribute = 1,
    ResetAttribute = 2,
};
pub const StorAttributeMgmt_ClearAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.ClearAttribute;
pub const StorAttributeMgmt_SetAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.SetAttribute;
pub const StorAttributeMgmt_ResetAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.ResetAttribute;

pub const STORAGE_ATTRIBUTE_MGMT = extern struct {
    Version: u32,
    Size: u32,
    Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    Attribute: u32,
};

pub const SCM_PD_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};

pub const SCM_LOGICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    SymbolicLink: [256]u16,
};

pub const SCM_LOGICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: [1]SCM_LOGICAL_DEVICE_INSTANCE,
};

pub const SCM_PHYSICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    NfitHandle: u32,
    SymbolicLink: [256]u16,
};

pub const SCM_PHYSICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: [1]SCM_PHYSICAL_DEVICE_INSTANCE,
};

pub const SCM_REGION_FLAG = extern enum(i32) {
    None = 0,
    Label = 1,
};
pub const ScmRegionFlagNone = SCM_REGION_FLAG.None;
pub const ScmRegionFlagLabel = SCM_REGION_FLAG.Label;

pub const SCM_REGION = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NfitHandle: u32,
    LogicalDeviceGuid: Guid,
    AddressRangeType: Guid,
    AssociatedId: u32,
    Length: u64,
    StartingDPA: u64,
    BaseSPA: u64,
    SPAOffset: u64,
    RegionOffset: u64,
};

pub const SCM_REGIONS = extern struct {
    Version: u32,
    Size: u32,
    RegionCount: u32,
    Regions: [1]SCM_REGION,
};

pub const SCM_INTERLEAVED_PD_INFO = extern struct {
    DeviceHandle: u32,
    DeviceGuid: Guid,
};

pub const SCM_LD_INTERLEAVE_SET_INFO = extern struct {
    Version: u32,
    Size: u32,
    InterleaveSetSize: u32,
    InterleaveSet: [1]SCM_INTERLEAVED_PD_INFO,
};

pub const SCM_PD_QUERY_TYPE = extern enum(i32) {
    Descriptor = 0,
    IsSupported = 1,
    Max = 2,
};
pub const ScmPhysicalDeviceQuery_Descriptor = SCM_PD_QUERY_TYPE.Descriptor;
pub const ScmPhysicalDeviceQuery_IsSupported = SCM_PD_QUERY_TYPE.IsSupported;
pub const ScmPhysicalDeviceQuery_Max = SCM_PD_QUERY_TYPE.Max;

pub const SCM_PD_PROPERTY_ID = extern enum(i32) {
    DeviceInfo = 0,
    ManagementStatus = 1,
    FirmwareInfo = 2,
    LocationString = 3,
    DeviceSpecificInfo = 4,
    DeviceHandle = 5,
    Max = 6,
};
pub const ScmPhysicalDeviceProperty_DeviceInfo = SCM_PD_PROPERTY_ID.DeviceInfo;
pub const ScmPhysicalDeviceProperty_ManagementStatus = SCM_PD_PROPERTY_ID.ManagementStatus;
pub const ScmPhysicalDeviceProperty_FirmwareInfo = SCM_PD_PROPERTY_ID.FirmwareInfo;
pub const ScmPhysicalDeviceProperty_LocationString = SCM_PD_PROPERTY_ID.LocationString;
pub const ScmPhysicalDeviceProperty_DeviceSpecificInfo = SCM_PD_PROPERTY_ID.DeviceSpecificInfo;
pub const ScmPhysicalDeviceProperty_DeviceHandle = SCM_PD_PROPERTY_ID.DeviceHandle;
pub const ScmPhysicalDeviceProperty_Max = SCM_PD_PROPERTY_ID.Max;

pub const SCM_PD_PROPERTY_QUERY = extern struct {
    Version: u32,
    Size: u32,
    PropertyId: SCM_PD_PROPERTY_ID,
    QueryType: SCM_PD_QUERY_TYPE,
    AdditionalParameters: [1]u8,
};

pub const SCM_PD_DESCRIPTOR_HEADER = extern struct {
    Version: u32,
    Size: u32,
};

pub const SCM_PD_DEVICE_HANDLE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    DeviceHandle: u32,
};

pub const SCM_PD_DEVICE_INFO = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    UnsafeShutdownCount: u32,
    PersistentMemorySizeInBytes: u64,
    VolatileMemorySizeInBytes: u64,
    TotalMemorySizeInBytes: u64,
    SlotNumber: u32,
    DeviceHandle: u32,
    PhysicalId: u16,
    NumberOfFormatInterfaceCodes: u8,
    FormatInterfaceCodes: [8]u16,
    VendorId: u32,
    ProductId: u32,
    SubsystemDeviceId: u32,
    SubsystemVendorId: u32,
    ManufacturingLocation: u8,
    ManufacturingWeek: u8,
    ManufacturingYear: u8,
    SerialNumber4Byte: u32,
    SerialNumberLengthInChars: u32,
    SerialNumber: [1]CHAR,
};

pub const SCM_PD_DEVICE_SPECIFIC_PROPERTY = extern struct {
    Name: [128]u16,
    Value: i64,
};

pub const SCM_PD_DEVICE_SPECIFIC_INFO = extern struct {
    Version: u32,
    Size: u32,
    NumberOfProperties: u32,
    DeviceSpecificProperties: [1]SCM_PD_DEVICE_SPECIFIC_PROPERTY,
};

pub const SCM_PD_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: [6]u8,
    Revision: [32]u8,
};

pub const SCM_PD_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    ActiveSlot: u8,
    NextActiveSlot: u8,
    SlotCount: u8,
    Slots: [1]SCM_PD_FIRMWARE_SLOT_INFO,
};

pub const SCM_PD_HEALTH_STATUS = extern enum(i32) {
    Unknown = 0,
    Unhealthy = 1,
    Warning = 2,
    Healthy = 3,
    Max = 4,
};
pub const ScmPhysicalDeviceHealth_Unknown = SCM_PD_HEALTH_STATUS.Unknown;
pub const ScmPhysicalDeviceHealth_Unhealthy = SCM_PD_HEALTH_STATUS.Unhealthy;
pub const ScmPhysicalDeviceHealth_Warning = SCM_PD_HEALTH_STATUS.Warning;
pub const ScmPhysicalDeviceHealth_Healthy = SCM_PD_HEALTH_STATUS.Healthy;
pub const ScmPhysicalDeviceHealth_Max = SCM_PD_HEALTH_STATUS.Max;

pub const SCM_PD_OPERATIONAL_STATUS = extern enum(i32) {
    Unknown = 0,
    Ok = 1,
    PredictingFailure = 2,
    InService = 3,
    HardwareError = 4,
    NotUsable = 5,
    TransientError = 6,
    Missing = 7,
    Max = 8,
};
pub const ScmPhysicalDeviceOpStatus_Unknown = SCM_PD_OPERATIONAL_STATUS.Unknown;
pub const ScmPhysicalDeviceOpStatus_Ok = SCM_PD_OPERATIONAL_STATUS.Ok;
pub const ScmPhysicalDeviceOpStatus_PredictingFailure = SCM_PD_OPERATIONAL_STATUS.PredictingFailure;
pub const ScmPhysicalDeviceOpStatus_InService = SCM_PD_OPERATIONAL_STATUS.InService;
pub const ScmPhysicalDeviceOpStatus_HardwareError = SCM_PD_OPERATIONAL_STATUS.HardwareError;
pub const ScmPhysicalDeviceOpStatus_NotUsable = SCM_PD_OPERATIONAL_STATUS.NotUsable;
pub const ScmPhysicalDeviceOpStatus_TransientError = SCM_PD_OPERATIONAL_STATUS.TransientError;
pub const ScmPhysicalDeviceOpStatus_Missing = SCM_PD_OPERATIONAL_STATUS.Missing;
pub const ScmPhysicalDeviceOpStatus_Max = SCM_PD_OPERATIONAL_STATUS.Max;

pub const SCM_PD_OPERATIONAL_STATUS_REASON = extern enum(i32) {
    Unknown = 0,
    Media = 1,
    ThresholdExceeded = 2,
    LostData = 3,
    EnergySource = 4,
    Configuration = 5,
    DeviceController = 6,
    MediaController = 7,
    Component = 8,
    BackgroundOperation = 9,
    InvalidFirmware = 10,
    HealthCheck = 11,
    LostDataPersistence = 12,
    DisabledByPlatform = 13,
    PermanentError = 14,
    LostWritePersistence = 15,
    FatalError = 16,
    DataPersistenceLossImminent = 17,
    WritePersistenceLossImminent = 18,
    MediaRemainingSpareBlock = 19,
    PerformanceDegradation = 20,
    ExcessiveTemperature = 21,
    Max = 22,
};
pub const ScmPhysicalDeviceOpReason_Unknown = SCM_PD_OPERATIONAL_STATUS_REASON.Unknown;
pub const ScmPhysicalDeviceOpReason_Media = SCM_PD_OPERATIONAL_STATUS_REASON.Media;
pub const ScmPhysicalDeviceOpReason_ThresholdExceeded = SCM_PD_OPERATIONAL_STATUS_REASON.ThresholdExceeded;
pub const ScmPhysicalDeviceOpReason_LostData = SCM_PD_OPERATIONAL_STATUS_REASON.LostData;
pub const ScmPhysicalDeviceOpReason_EnergySource = SCM_PD_OPERATIONAL_STATUS_REASON.EnergySource;
pub const ScmPhysicalDeviceOpReason_Configuration = SCM_PD_OPERATIONAL_STATUS_REASON.Configuration;
pub const ScmPhysicalDeviceOpReason_DeviceController = SCM_PD_OPERATIONAL_STATUS_REASON.DeviceController;
pub const ScmPhysicalDeviceOpReason_MediaController = SCM_PD_OPERATIONAL_STATUS_REASON.MediaController;
pub const ScmPhysicalDeviceOpReason_Component = SCM_PD_OPERATIONAL_STATUS_REASON.Component;
pub const ScmPhysicalDeviceOpReason_BackgroundOperation = SCM_PD_OPERATIONAL_STATUS_REASON.BackgroundOperation;
pub const ScmPhysicalDeviceOpReason_InvalidFirmware = SCM_PD_OPERATIONAL_STATUS_REASON.InvalidFirmware;
pub const ScmPhysicalDeviceOpReason_HealthCheck = SCM_PD_OPERATIONAL_STATUS_REASON.HealthCheck;
pub const ScmPhysicalDeviceOpReason_LostDataPersistence = SCM_PD_OPERATIONAL_STATUS_REASON.LostDataPersistence;
pub const ScmPhysicalDeviceOpReason_DisabledByPlatform = SCM_PD_OPERATIONAL_STATUS_REASON.DisabledByPlatform;
pub const ScmPhysicalDeviceOpReason_PermanentError = SCM_PD_OPERATIONAL_STATUS_REASON.PermanentError;
pub const ScmPhysicalDeviceOpReason_LostWritePersistence = SCM_PD_OPERATIONAL_STATUS_REASON.LostWritePersistence;
pub const ScmPhysicalDeviceOpReason_FatalError = SCM_PD_OPERATIONAL_STATUS_REASON.FatalError;
pub const ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = SCM_PD_OPERATIONAL_STATUS_REASON.DataPersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = SCM_PD_OPERATIONAL_STATUS_REASON.WritePersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = SCM_PD_OPERATIONAL_STATUS_REASON.MediaRemainingSpareBlock;
pub const ScmPhysicalDeviceOpReason_PerformanceDegradation = SCM_PD_OPERATIONAL_STATUS_REASON.PerformanceDegradation;
pub const ScmPhysicalDeviceOpReason_ExcessiveTemperature = SCM_PD_OPERATIONAL_STATUS_REASON.ExcessiveTemperature;
pub const ScmPhysicalDeviceOpReason_Max = SCM_PD_OPERATIONAL_STATUS_REASON.Max;

pub const SCM_PD_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: SCM_PD_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: [16]SCM_PD_OPERATIONAL_STATUS,
    AdditionalReasons: [1]SCM_PD_OPERATIONAL_STATUS_REASON,
};

pub const SCM_PD_LOCATION_STRING = extern struct {
    Version: u32,
    Size: u32,
    Location: [1]u16,
};

pub const SCM_PD_FIRMWARE_DOWNLOAD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: [3]u8,
    Offset: u64,
    FirmwareImageSizeInBytes: u32,
    FirmwareImage: [1]u8,
};

pub const SCM_PD_FIRMWARE_ACTIVATE = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
};

pub const SCM_PD_PASSTHROUGH_INPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_INVDIMM_INPUT = extern struct {
    Opcode: u32,
    OpcodeParametersLength: u32,
    OpcodeParameters: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = extern struct {
    GeneralStatus: u16,
    ExtendedStatus: u16,
    OutputDataLength: u32,
    OutputData: [1]u8,
};

pub const SCM_PD_REINITIALIZE_MEDIA_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Options: _Options_e__Struct,
    const _Options_e__Struct = u32; // TODO: generate this nested type!
};

pub const SCM_PD_MEDIA_REINITIALIZATION_STATUS = extern enum(i32) {
    Success = 0,
    RebootNeeded = 1,
    ColdBootNeeded = 2,
    Max = 3,
};
pub const ScmPhysicalDeviceReinit_Success = SCM_PD_MEDIA_REINITIALIZATION_STATUS.Success;
pub const ScmPhysicalDeviceReinit_RebootNeeded = SCM_PD_MEDIA_REINITIALIZATION_STATUS.RebootNeeded;
pub const ScmPhysicalDeviceReinit_ColdBootNeeded = SCM_PD_MEDIA_REINITIALIZATION_STATUS.ColdBootNeeded;
pub const ScmPhysicalDeviceReinit_Max = SCM_PD_MEDIA_REINITIALIZATION_STATUS.Max;

pub const SCM_PD_REINITIALIZE_MEDIA_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
};

pub const SET_PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DETECTION_TYPE = extern enum(i32) {
    None = 0,
    Int13 = 1,
    ExInt13 = 2,
};
pub const DetectNone = DETECTION_TYPE.None;
pub const DetectInt13 = DETECTION_TYPE.Int13;
pub const DetectExInt13 = DETECTION_TYPE.ExInt13;

pub const DISK_CONTROLLER_NUMBER = extern struct {
    ControllerNumber: u32,
    DiskNumber: u32,
};

pub const DISK_CACHE_RETENTION_PRIORITY = extern enum(i32) {
    EqualPriority = 0,
    KeepPrefetchedData = 1,
    KeepReadData = 2,
};
pub const EqualPriority = DISK_CACHE_RETENTION_PRIORITY.EqualPriority;
pub const KeepPrefetchedData = DISK_CACHE_RETENTION_PRIORITY.KeepPrefetchedData;
pub const KeepReadData = DISK_CACHE_RETENTION_PRIORITY.KeepReadData;

pub const HISTOGRAM_BUCKET = extern struct {
    Reads: u32,
    Writes: u32,
};

pub const DISK_HISTOGRAM = extern struct {
    DiskSize: LARGE_INTEGER,
    Start: LARGE_INTEGER,
    End: LARGE_INTEGER,
    Average: LARGE_INTEGER,
    AverageRead: LARGE_INTEGER,
    AverageWrite: LARGE_INTEGER,
    Granularity: u32,
    Size: u32,
    ReadCount: u32,
    WriteCount: u32,
    Histogram: *HISTOGRAM_BUCKET,
};

pub const DISK_RECORD = extern struct {
    ByteOffset: LARGE_INTEGER,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    VirtualAddress: *c_void,
    NumberOfBytes: u32,
    DeviceNumber: u8,
    ReadRequest: u8,
};

pub const DISK_LOGGING = extern struct {
    Function: u8,
    BufferAddress: *c_void,
    BufferSize: u32,
};

pub const BIN_TYPES = extern enum(i32) {
    Size = 0,
    Location = 1,
};
pub const RequestSize = BIN_TYPES.Size;
pub const RequestLocation = BIN_TYPES.Location;

pub const BIN_RANGE = extern struct {
    StartValue: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};

pub const PERF_BIN = extern struct {
    NumberOfBins: u32,
    TypeOfBin: u32,
    BinsRanges: [1]BIN_RANGE,
};

pub const BIN_COUNT = extern struct {
    BinRange: BIN_RANGE,
    BinCount: u32,
};

pub const BIN_RESULTS = extern struct {
    NumberOfBins: u32,
    BinCounts: [1]BIN_COUNT,
};

pub const GETVERSIONINPARAMS = extern struct {
    bVersion: u8,
    bRevision: u8,
    bReserved: u8,
    bIDEDeviceMap: u8,
    fCapabilities: u32,
    dwReserved: [4]u32,
};

pub const IDEREGS = extern struct {
    bFeaturesReg: u8,
    bSectorCountReg: u8,
    bSectorNumberReg: u8,
    bCylLowReg: u8,
    bCylHighReg: u8,
    bDriveHeadReg: u8,
    bCommandReg: u8,
    bReserved: u8,
};

pub const SENDCMDINPARAMS = extern struct {
    cBufferSize: u32,
    irDriveRegs: IDEREGS,
    bDriveNumber: u8,
    bReserved: [3]u8,
    dwReserved: [4]u32,
    bBuffer: [1]u8,
};

pub const DRIVERSTATUS = extern struct {
    bDriverError: u8,
    bIDEError: u8,
    bReserved: [2]u8,
    dwReserved: [2]u32,
};

pub const SENDCMDOUTPARAMS = extern struct {
    cBufferSize: u32,
    DriverStatus: DRIVERSTATUS,
    bBuffer: [1]u8,
};

pub const ELEMENT_TYPE = extern enum(i32) {
    AllElements = 0,
    ChangerTransport = 1,
    ChangerSlot = 2,
    ChangerIEPort = 3,
    ChangerDrive = 4,
    ChangerDoor = 5,
    ChangerKeypad = 6,
    ChangerMaxElement = 7,
};
pub const AllElements = ELEMENT_TYPE.AllElements;
pub const ChangerTransport = ELEMENT_TYPE.ChangerTransport;
pub const ChangerSlot = ELEMENT_TYPE.ChangerSlot;
pub const ChangerIEPort = ELEMENT_TYPE.ChangerIEPort;
pub const ChangerDrive = ELEMENT_TYPE.ChangerDrive;
pub const ChangerDoor = ELEMENT_TYPE.ChangerDoor;
pub const ChangerKeypad = ELEMENT_TYPE.ChangerKeypad;
pub const ChangerMaxElement = ELEMENT_TYPE.ChangerMaxElement;

pub const CHANGER_ELEMENT = extern struct {
    ElementType: ELEMENT_TYPE,
    ElementAddress: u32,
};

pub const CHANGER_ELEMENT_LIST = extern struct {
    Element: CHANGER_ELEMENT,
    NumberOfElements: u32,
};

pub const GET_CHANGER_PARAMETERS = extern struct {
    Size: u32,
    NumberTransportElements: u16,
    NumberStorageElements: u16,
    NumberCleanerSlots: u16,
    NumberIEElements: u16,
    NumberDataTransferElements: u16,
    NumberOfDoors: u16,
    FirstSlotNumber: u16,
    FirstDriveNumber: u16,
    FirstTransportNumber: u16,
    FirstIEPortNumber: u16,
    FirstCleanerSlotAddress: u16,
    MagazineSize: u16,
    DriveCleanTimeout: u32,
    Features0: CHANGER_FEATURES,
    Features1: GET_CHANGER_PARAMETERS_FEATURES1,
    MoveFromTransport: u8,
    MoveFromSlot: u8,
    MoveFromIePort: u8,
    MoveFromDrive: u8,
    ExchangeFromTransport: u8,
    ExchangeFromSlot: u8,
    ExchangeFromIePort: u8,
    ExchangeFromDrive: u8,
    LockUnlockCapabilities: u8,
    PositionCapabilities: u8,
    Reserved1: [2]u8,
    Reserved2: [2]u32,
};

pub const CHANGER_PRODUCT_DATA = extern struct {
    VendorId: [8]u8,
    ProductId: [16]u8,
    Revision: [4]u8,
    SerialNumber: [32]u8,
    DeviceType: u8,
};

pub const CHANGER_SET_ACCESS = extern struct {
    Element: CHANGER_ELEMENT,
    Control: u32,
};

pub const CHANGER_READ_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    VolumeTagInfo: u8,
};

pub const CHANGER_ELEMENT_STATUS = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: CHANGER_ELEMENT_STATUS_FLAGS,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: [36]u8,
    AlternateVolumeID: [36]u8,
};

pub const CHANGER_ELEMENT_STATUS_EX = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: CHANGER_ELEMENT_STATUS_FLAGS,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: [36]u8,
    AlternateVolumeID: [36]u8,
    VendorIdentification: [8]u8,
    ProductIdentification: [16]u8,
    SerialNumber: [32]u8,
};

pub const CHANGER_INITIALIZE_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    BarCodeScan: u8,
};

pub const CHANGER_SET_POSITION = extern struct {
    Transport: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};

pub const CHANGER_EXCHANGE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination1: CHANGER_ELEMENT,
    Destination2: CHANGER_ELEMENT,
    Flip1: u8,
    Flip2: u8,
};

pub const CHANGER_MOVE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};

pub const CHANGER_SEND_VOLUME_TAG_INFORMATION = extern struct {
    StartingElement: CHANGER_ELEMENT,
    ActionCode: u32,
    VolumeIDTemplate: [40]u8,
};

pub const READ_ELEMENT_ADDRESS_INFO = extern struct {
    NumberOfElements: u32,
    ElementStatus: [1]CHANGER_ELEMENT_STATUS,
};

pub const CHANGER_DEVICE_PROBLEM_TYPE = extern enum(i32) {
    None = 0,
    Hardware = 1,
    CHMError = 2,
    DoorOpen = 3,
    CalibrationError = 4,
    TargetFailure = 5,
    CHMMoveError = 6,
    CHMZeroError = 7,
    CartridgeInsertError = 8,
    PositionError = 9,
    SensorError = 10,
    CartridgeEjectError = 11,
    GripperError = 12,
    DriveError = 13,
};
pub const DeviceProblemNone = CHANGER_DEVICE_PROBLEM_TYPE.None;
pub const DeviceProblemHardware = CHANGER_DEVICE_PROBLEM_TYPE.Hardware;
pub const DeviceProblemCHMError = CHANGER_DEVICE_PROBLEM_TYPE.CHMError;
pub const DeviceProblemDoorOpen = CHANGER_DEVICE_PROBLEM_TYPE.DoorOpen;
pub const DeviceProblemCalibrationError = CHANGER_DEVICE_PROBLEM_TYPE.CalibrationError;
pub const DeviceProblemTargetFailure = CHANGER_DEVICE_PROBLEM_TYPE.TargetFailure;
pub const DeviceProblemCHMMoveError = CHANGER_DEVICE_PROBLEM_TYPE.CHMMoveError;
pub const DeviceProblemCHMZeroError = CHANGER_DEVICE_PROBLEM_TYPE.CHMZeroError;
pub const DeviceProblemCartridgeInsertError = CHANGER_DEVICE_PROBLEM_TYPE.CartridgeInsertError;
pub const DeviceProblemPositionError = CHANGER_DEVICE_PROBLEM_TYPE.PositionError;
pub const DeviceProblemSensorError = CHANGER_DEVICE_PROBLEM_TYPE.SensorError;
pub const DeviceProblemCartridgeEjectError = CHANGER_DEVICE_PROBLEM_TYPE.CartridgeEjectError;
pub const DeviceProblemGripperError = CHANGER_DEVICE_PROBLEM_TYPE.GripperError;
pub const DeviceProblemDriveError = CHANGER_DEVICE_PROBLEM_TYPE.DriveError;

pub const PATHNAME_BUFFER = extern struct {
    PathNameLength: u32,
    Name: [1]u16,
};

pub const FSCTL_QUERY_FAT_BPB_BUFFER = extern struct {
    First0x24BytesOfBootSector: [36]u8,
};

pub const REFS_VOLUME_DATA_BUFFER = extern struct {
    ByteCount: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    BytesPerPhysicalSector: u32,
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: u32,
    BytesPerCluster: u32,
    MaximumSizeOfResidentFile: LARGE_INTEGER,
    FastTierDataFillRatio: u16,
    SlowTierDataFillRatio: u16,
    DestagesFastTierToSlowTierRate: u32,
    Reserved: [9]LARGE_INTEGER,
};

pub const STARTING_LCN_INPUT_BUFFER_EX = extern struct {
    StartingLcn: LARGE_INTEGER,
    Flags: u32,
};

pub const RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = extern struct {
    ExtentCount: u32,
    StartingVcn: LARGE_INTEGER,
    Extents: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const RETRIEVAL_POINTER_COUNT = extern struct {
    ExtentCount: u32,
};

pub const MOVE_FILE_RECORD_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileRecord: LARGE_INTEGER,
    TargetFileRecord: LARGE_INTEGER,
};

pub const USN_RECORD_UNION = extern union {
    Header: USN_RECORD_COMMON_HEADER,
    V2: USN_RECORD_V2,
    V3: USN_RECORD_V3,
    V4: USN_RECORD_V4,
};

pub const BULK_SECURITY_TEST_DATA = extern struct {
    DesiredAccess: u32,
    SecurityIds: [1]u32,
};

pub const FILE_PREFETCH = extern struct {
    Type: u32,
    Count: u32,
    Prefetch: [1]u64,
};

pub const FILE_PREFETCH_EX = extern struct {
    Type: u32,
    Count: u32,
    Context: *c_void,
    Prefetch: [1]u64,
};

pub const FILE_ZERO_DATA_INFORMATION_EX = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
    Flags: u32,
};

pub const ENCRYPTION_BUFFER = extern struct {
    EncryptionOperation: u32,
    Private: [1]u8,
};

pub const DECRYPTION_STATUS_BUFFER = extern struct {
    NoEncryptedStreams: u8,
};

pub const REQUEST_RAW_ENCRYPTED_DATA = extern struct {
    FileOffset: i64,
    Length: u32,
};

pub const ENCRYPTED_DATA_INFO = extern struct {
    StartingFileOffset: u64,
    OutputBufferOffset: u32,
    BytesWithinFileSize: u32,
    BytesWithinValidDataLength: u32,
    CompressionFormat: u16,
    DataUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    EncryptionFormat: u8,
    NumberOfDataBlocks: u16,
    DataBlockSize: [1]u32,
};

pub const EXTENDED_ENCRYPTED_DATA_INFO = extern struct {
    ExtendedCode: u32,
    Length: u32,
    Flags: u32,
    Reserved: u32,
};

pub const SI_COPYFILE = extern struct {
    SourceFileNameLength: u32,
    DestinationFileNameLength: u32,
    Flags: u32,
    FileNameBuffer: [1]u16,
};

pub const FILE_INITIATE_REPAIR_OUTPUT_BUFFER = extern struct {
    Hint1: u64,
    Hint2: u64,
    Clsn: u64,
    Status: u32,
};

pub const SHRINK_VOLUME_REQUEST_TYPES = extern enum(i32) {
    Prepare = 1,
    Commit = 2,
    Abort = 3,
};
pub const ShrinkPrepare = SHRINK_VOLUME_REQUEST_TYPES.Prepare;
pub const ShrinkCommit = SHRINK_VOLUME_REQUEST_TYPES.Commit;
pub const ShrinkAbort = SHRINK_VOLUME_REQUEST_TYPES.Abort;

pub const TXFS_ROLLFORWARD_REDO_INFORMATION = extern struct {
    LastVirtualClock: LARGE_INTEGER,
    LastRedoLsn: u64,
    HighestRecoveryLsn: u64,
    Flags: u32,
};

pub const TXFS_START_RM_INFORMATION = extern struct {
    Flags: u32,
    LogContainerSize: u64,
    LogContainerCountMin: u32,
    LogContainerCountMax: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    TmLogPathOffset: u32,
    TmLogPathLength: u16,
    LoggingMode: u16,
    LogPathLength: u16,
    Reserved: u16,
    LogPath: [1]u16,
};

pub const FILE_FS_PERSISTENT_VOLUME_INFORMATION = extern struct {
    VolumeFlags: u32,
    FlagMask: u32,
    Version: u32,
    Reserved: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = extern struct {
    RequestLevel: u32,
    RequestFlags: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    AncestorLevel: u32,
    HostVolumeNameOffset: u32,
    HostVolumeNameSize: u32,
    DependentVolumeNameOffset: u32,
    DependentVolumeNameSize: u32,
    RelativePathOffset: u32,
    RelativePathSize: u32,
    DependentDeviceNameOffset: u32,
    DependentDeviceNameSize: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = extern struct {
    ResponseLevel: u32,
    NumberEntries: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SD_CHANGE_MACHINE_SID_INPUT = extern struct {
    CurrentMachineSIDOffset: u16,
    CurrentMachineSIDLength: u16,
    NewMachineSIDOffset: u16,
    NewMachineSIDLength: u16,
};

pub const SD_CHANGE_MACHINE_SID_OUTPUT = extern struct {
    NumSDChangedSuccess: u64,
    NumSDChangedFail: u64,
    NumSDUnused: u64,
    NumSDTotal: u64,
    NumMftSDChangedSuccess: u64,
    NumMftSDChangedFail: u64,
    NumMftSDTotal: u64,
};

pub const SD_QUERY_STATS_INPUT = extern struct {
    Reserved: u32,
};

pub const SD_QUERY_STATS_OUTPUT = extern struct {
    SdsStreamSize: u64,
    SdsAllocationSize: u64,
    SiiStreamSize: u64,
    SiiAllocationSize: u64,
    SdhStreamSize: u64,
    SdhAllocationSize: u64,
    NumSDTotal: u64,
    NumSDUnused: u64,
};

pub const SD_ENUM_SDS_INPUT = extern struct {
    StartingOffset: u64,
    MaxSDEntriesToReturn: u64,
};

pub const SD_ENUM_SDS_ENTRY = extern struct {
    Hash: u32,
    SecurityId: u32,
    Offset: u64,
    Length: u32,
    Descriptor: [1]u8,
};

pub const SD_ENUM_SDS_OUTPUT = extern struct {
    NextOffset: u64,
    NumSDEntriesReturned: u64,
    NumSDBytesReturned: u64,
    SDEntry: [1]SD_ENUM_SDS_ENTRY,
};

pub const SD_GLOBAL_CHANGE_INPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SD_GLOBAL_CHANGE_OUTPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const FILE_TYPE_NOTIFICATION_INPUT = extern struct {
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: [1]Guid,
};

pub const CSV_MGMT_LOCK = extern struct {
    Flags: u32,
};

pub const CSV_QUERY_FILE_REVISION_FILE_ID_128 = extern struct {
    FileId: FILE_ID_128,
    FileRevision: [3]i64,
};

pub const CSVFS_DISK_CONNECTIVITY = extern enum(i32) {
    None = 0,
    MdsNodeOnly = 1,
    SubsetOfNodes = 2,
    AllNodes = 3,
};
pub const CsvFsDiskConnectivityNone = CSVFS_DISK_CONNECTIVITY.None;
pub const CsvFsDiskConnectivityMdsNodeOnly = CSVFS_DISK_CONNECTIVITY.MdsNodeOnly;
pub const CsvFsDiskConnectivitySubsetOfNodes = CSVFS_DISK_CONNECTIVITY.SubsetOfNodes;
pub const CsvFsDiskConnectivityAllNodes = CSVFS_DISK_CONNECTIVITY.AllNodes;

pub const CSV_QUERY_VOLUME_REDIRECT_STATE = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    IsDiskConnected: u8,
    ClusterEnableDirectIo: u8,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
};

pub const CSV_QUERY_MDS_PATH_V2 = extern struct {
    Version: i64,
    RequiredSize: u32,
    MdsNodeId: u32,
    DsNodeId: u32,
    Flags: u32,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    VolumeId: Guid,
    IpAddressOffset: u32,
    IpAddressLength: u32,
    PathOffset: u32,
    PathLength: u32,
};

pub const STORAGE_RESERVE_ID = extern enum(i32) {
    None = 0,
    Hard = 1,
    Soft = 2,
    UpdateScratch = 3,
    Max = 4,
};
pub const StorageReserveIdNone = STORAGE_RESERVE_ID.None;
pub const StorageReserveIdHard = STORAGE_RESERVE_ID.Hard;
pub const StorageReserveIdSoft = STORAGE_RESERVE_ID.Soft;
pub const StorageReserveIdUpdateScratch = STORAGE_RESERVE_ID.UpdateScratch;
pub const StorageReserveIdMax = STORAGE_RESERVE_ID.Max;

pub const QUERY_FILE_LAYOUT_FILTER_TYPE = extern enum(i32) {
    FILTER_TYPE_NONE = 0,
    FILTER_TYPE_CLUSTERS = 1,
    FILTER_TYPE_FILEID = 2,
    FILTER_TYPE_STORAGE_RESERVE_ID = 3,
    NUM_FILTER_TYPES = 4,
};
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = QUERY_FILE_LAYOUT_FILTER_TYPE.FILTER_TYPE_NONE;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = QUERY_FILE_LAYOUT_FILTER_TYPE.FILTER_TYPE_CLUSTERS;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = QUERY_FILE_LAYOUT_FILTER_TYPE.FILTER_TYPE_FILEID;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = QUERY_FILE_LAYOUT_FILTER_TYPE.FILTER_TYPE_STORAGE_RESERVE_ID;
pub const QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = QUERY_FILE_LAYOUT_FILTER_TYPE.NUM_FILTER_TYPES;

pub const CLUSTER_RANGE = extern struct {
    StartingCluster: LARGE_INTEGER,
    ClusterCount: LARGE_INTEGER,
};

pub const FILE_REFERENCE_RANGE = extern struct {
    StartingFileReferenceNumber: u64,
    EndingFileReferenceNumber: u64,
};

pub const QUERY_FILE_LAYOUT_INPUT = extern struct {
    Anonymous: _Anonymous_e__Union,
    Flags: u32,
    FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    Reserved: u32,
    Filter: _Filter_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
    const _Filter_e__Union = u32; // TODO: generate this nested type!
};

pub const QUERY_FILE_LAYOUT_OUTPUT = extern struct {
    FileEntryCount: u32,
    FirstFileOffset: u32,
    Flags: u32,
    Reserved: u32,
};

pub const FILE_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextFileOffset: u32,
    Flags: u32,
    FileAttributes: u32,
    FileReferenceNumber: u64,
    FirstNameOffset: u32,
    FirstStreamOffset: u32,
    ExtraInfoOffset: u32,
    ExtraInfoLength: u32,
};

pub const FILE_LAYOUT_NAME_ENTRY = extern struct {
    NextNameOffset: u32,
    Flags: u32,
    ParentFileReferenceNumber: u64,
    FileNameLength: u32,
    Reserved: u32,
    FileName: [1]u16,
};

pub const FILE_LAYOUT_INFO_ENTRY = extern struct {
    BasicInformation: _BasicInformation_e__Struct,
    OwnerId: u32,
    SecurityId: u32,
    Usn: i64,
    StorageReserveId: STORAGE_RESERVE_ID,
    const _BasicInformation_e__Struct = u32; // TODO: generate this nested type!
};

pub const STREAM_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextStreamOffset: u32,
    Flags: u32,
    ExtentInformationOffset: u32,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    StreamInformationOffset: u32,
    AttributeTypeCode: u32,
    AttributeFlags: u32,
    StreamIdentifierLength: u32,
    StreamIdentifier: [1]u16,
};

pub const STREAM_EXTENT_ENTRY = extern struct {
    Flags: u32,
    ExtentInformation: _ExtentInformation_e__Union,
    const _ExtentInformation_e__Union = u32; // TODO: generate this nested type!
};

pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = extern struct {
    EnableIntegrity: u8,
    KeepIntegrityStateUnchanged: u8,
    Reserved: u16,
    Flags: u32,
    Version: u8,
    Reserved2: [7]u8,
};

pub const FSCTL_OFFLOAD_READ_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    TokenTimeToLive: u32,
    Reserved: u32,
    FileOffset: u64,
    CopyLength: u64,
};

pub const FSCTL_OFFLOAD_READ_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    TransferLength: u64,
    Token: [512]u8,
};

pub const FSCTL_OFFLOAD_WRITE_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    FileOffset: u64,
    CopyLength: u64,
    TransferOffset: u64,
    Token: [512]u8,
};

pub const FSCTL_OFFLOAD_WRITE_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    LengthWritten: u64,
};

pub const SET_PURGE_FAILURE_MODE_INPUT = extern struct {
    Flags: u32,
};

pub const FILE_REGION_INFO = extern struct {
    FileOffset: i64,
    Length: i64,
    Usage: u32,
    Reserved: u32,
};

pub const FILE_REGION_OUTPUT = extern struct {
    Flags: u32,
    TotalRegionEntryCount: u32,
    RegionEntryCount: u32,
    Reserved: u32,
    Region: [1]FILE_REGION_INFO,
};

pub const FILE_REGION_INPUT = extern struct {
    FileOffset: i64,
    Length: i64,
    DesiredUsage: u32,
};

pub const WRITE_USN_REASON_INPUT = extern struct {
    Flags: u32,
    UsnReasonToWrite: u32,
};

pub const FILE_STORAGE_TIER_CLASS = extern enum(i32) {
    Unspecified = 0,
    Capacity = 1,
    Performance = 2,
    Max = 3,
};
pub const FileStorageTierClassUnspecified = FILE_STORAGE_TIER_CLASS.Unspecified;
pub const FileStorageTierClassCapacity = FILE_STORAGE_TIER_CLASS.Capacity;
pub const FileStorageTierClassPerformance = FILE_STORAGE_TIER_CLASS.Performance;
pub const FileStorageTierClassMax = FILE_STORAGE_TIER_CLASS.Max;

pub const STREAM_INFORMATION_ENTRY = extern struct {
    Version: u32,
    Flags: u32,
    StreamInformation: _StreamInformation,
    const _StreamInformation = u32; // TODO: generate this nested type!
};

pub const FILE_DESIRED_STORAGE_CLASS_INFORMATION = extern struct {
    Class: FILE_STORAGE_TIER_CLASS,
    Flags: u32,
};

pub const DUPLICATE_EXTENTS_DATA_EX = extern struct {
    Size: usize,
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: u32,
};

pub const REFS_SMR_VOLUME_GC_STATE = extern enum(i32) {
    Inactive = 0,
    Paused = 1,
    Active = 2,
    ActiveFullSpeed = 3,
};
pub const SmrGcStateInactive = REFS_SMR_VOLUME_GC_STATE.Inactive;
pub const SmrGcStatePaused = REFS_SMR_VOLUME_GC_STATE.Paused;
pub const SmrGcStateActive = REFS_SMR_VOLUME_GC_STATE.Active;
pub const SmrGcStateActiveFullSpeed = REFS_SMR_VOLUME_GC_STATE.ActiveFullSpeed;

pub const REFS_SMR_VOLUME_INFO_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    SizeOfRandomlyWritableTier: LARGE_INTEGER,
    FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    SizeofSMRTier: LARGE_INTEGER,
    FreeSpaceInSMRTier: LARGE_INTEGER,
    UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    VolumeGcLastStatus: u32,
    Unused: [7]u64,
};

pub const REFS_SMR_VOLUME_GC_ACTION = extern enum(i32) {
    Start = 1,
    StartFullSpeed = 2,
    Pause = 3,
    Stop = 4,
};
pub const SmrGcActionStart = REFS_SMR_VOLUME_GC_ACTION.Start;
pub const SmrGcActionStartFullSpeed = REFS_SMR_VOLUME_GC_ACTION.StartFullSpeed;
pub const SmrGcActionPause = REFS_SMR_VOLUME_GC_ACTION.Pause;
pub const SmrGcActionStop = REFS_SMR_VOLUME_GC_ACTION.Stop;

pub const REFS_SMR_VOLUME_GC_METHOD = extern enum(i32) {
    Compaction = 1,
    Compression = 2,
    Rotation = 3,
};
pub const SmrGcMethodCompaction = REFS_SMR_VOLUME_GC_METHOD.Compaction;
pub const SmrGcMethodCompression = REFS_SMR_VOLUME_GC_METHOD.Compression;
pub const SmrGcMethodRotation = REFS_SMR_VOLUME_GC_METHOD.Rotation;

pub const REFS_SMR_VOLUME_GC_PARAMETERS = extern struct {
    Version: u32,
    Flags: u32,
    Action: REFS_SMR_VOLUME_GC_ACTION,
    Method: REFS_SMR_VOLUME_GC_METHOD,
    IoGranularity: u32,
    CompressionFormat: u32,
    Unused: [8]u64,
};

pub const STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = extern struct {
    OptimalWriteSize: u32,
    StreamGranularitySize: u32,
    StreamIdMin: u32,
    StreamIdMax: u32,
};

pub const STREAMS_ASSOCIATE_ID_INPUT_BUFFER = extern struct {
    Flags: u32,
    StreamId: u32,
};

pub const STREAMS_QUERY_ID_OUTPUT_BUFFER = extern struct {
    StreamId: u32,
};

pub const QUERY_BAD_RANGES_INPUT_RANGE = extern struct {
    StartOffset: u64,
    LengthInBytes: u64,
};

pub const QUERY_BAD_RANGES_INPUT = extern struct {
    Flags: u32,
    NumRanges: u32,
    Ranges: [1]QUERY_BAD_RANGES_INPUT_RANGE,
};

pub const QUERY_BAD_RANGES_OUTPUT_RANGE = extern struct {
    Flags: u32,
    Reserved: u32,
    StartOffset: u64,
    LengthInBytes: u64,
};

pub const QUERY_BAD_RANGES_OUTPUT = extern struct {
    Flags: u32,
    NumBadRanges: u32,
    NextOffsetToLookUp: u64,
    BadRanges: [1]QUERY_BAD_RANGES_OUTPUT_RANGE,
};

pub const SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = extern struct {
    Flags: u32,
    AlignmentShift: u32,
    FileOffsetToAlign: u64,
    FallbackAlignmentShift: u32,
};

pub const VIRTUAL_STORAGE_BEHAVIOR_CODE = extern enum(i32) {
    Undefined = 0,
    CacheWriteThrough = 1,
    CacheWriteBack = 2,
};
pub const VirtualStorageBehaviorUndefined = VIRTUAL_STORAGE_BEHAVIOR_CODE.Undefined;
pub const VirtualStorageBehaviorCacheWriteThrough = VIRTUAL_STORAGE_BEHAVIOR_CODE.CacheWriteThrough;
pub const VirtualStorageBehaviorCacheWriteBack = VIRTUAL_STORAGE_BEHAVIOR_CODE.CacheWriteBack;

pub const VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = extern struct {
    Size: u32,
    BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
};

pub const ENCRYPTION_KEY_CTRL_INPUT = extern struct {
    HeaderSize: u32,
    StructureSize: u32,
    KeyOffset: u16,
    KeySize: u16,
    DplLock: u32,
    DplUserId: u64,
    DplCredentialId: u64,
};

pub const WOF_EXTERNAL_INFO = extern struct {
    Version: u32,
    Provider: u32,
};

pub const WOF_EXTERNAL_FILE_ID = extern struct {
    FileId: FILE_ID_128,
};

pub const WOF_VERSION_INFO = extern struct {
    WofVersion: u32,
};

pub const WIM_PROVIDER_EXTERNAL_INFO = extern struct {
    Version: u32,
    Flags: u32,
    DataSourceId: LARGE_INTEGER,
    ResourceHash: [20]u8,
};

pub const WIM_PROVIDER_ADD_OVERLAY_INPUT = extern struct {
    WimType: u32,
    WimIndex: u32,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};

pub const WIM_PROVIDER_UPDATE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};

pub const WIM_PROVIDER_REMOVE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};

pub const WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};

pub const WIM_PROVIDER_OVERLAY_ENTRY = extern struct {
    NextEntryOffset: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimFileNameOffset: u32,
    WimType: u32,
    WimIndex: u32,
    Flags: u32,
};

pub const FILE_PROVIDER_EXTERNAL_INFO_V0 = extern struct {
    Version: u32,
    Algorithm: u32,
};

pub const FILE_PROVIDER_EXTERNAL_INFO_V1 = extern struct {
    Version: u32,
    Algorithm: u32,
    Flags: u32,
};

pub const CONTAINER_VOLUME_STATE = extern struct {
    Flags: u32,
};

pub const CONTAINER_ROOT_INFO_INPUT = extern struct {
    Flags: u32,
};

pub const CONTAINER_ROOT_INFO_OUTPUT = extern struct {
    ContainerRootIdLength: u16,
    ContainerRootId: [1]u8,
};

pub const VIRTUALIZATION_INSTANCE_INFO_INPUT = extern struct {
    NumberOfWorkerThreads: u32,
    Flags: u32,
};

pub const VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = extern struct {
    HeaderSize: u16,
    Flags: u32,
    NotificationInfoSize: u32,
    NotificationInfoOffset: u16,
    ProviderMajorVersion: u16,
};

pub const VIRTUALIZATION_INSTANCE_INFO_OUTPUT = extern struct {
    VirtualizationInstanceID: Guid,
};

pub const GET_FILTER_FILE_IDENTIFIER_INPUT = extern struct {
    AltitudeLength: u16,
    Altitude: [1]u16,
};

pub const GET_FILTER_FILE_IDENTIFIER_OUTPUT = extern struct {
    FilterFileIdentifierLength: u16,
    FilterFileIdentifier: [1]u8,
};

pub const PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = fn(
    SourceContext: *IO_IRP_EXT_TRACK_OFFSET_HEADER,
    TargetContext: *IO_IRP_EXT_TRACK_OFFSET_HEADER,
    RelativeOffset: i64,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IO_IRP_EXT_TRACK_OFFSET_HEADER = extern struct {
    Validation: u16,
    Flags: u16,
    TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
};

pub const DEVICE_EVENT_MOUNT = extern struct {
    Version: u32,
    Flags: u32,
    FileSystemNameLength: u32,
    FileSystemNameOffset: u32,
};

pub const DEVICE_EVENT_BECOMING_READY = extern struct {
    Version: u32,
    Reason: u32,
    Estimated100msToReady: u32,
};

pub const DEVICE_EVENT_EXTERNAL_REQUEST = extern struct {
    Version: u32,
    DeviceClass: u32,
    ButtonStatus: u16,
    Request: u16,
    SystemTime: LARGE_INTEGER,
};

pub const DEVICE_EVENT_GENERIC_DATA = extern struct {
    EventNumber: u32,
};

pub const DEVICE_EVENT_RBC_DATA = extern struct {
    EventNumber: u32,
    SenseQualifier: u8,
    SenseCode: u8,
    SenseKey: u8,
    Reserved: u8,
    Information: u32,
};

pub const GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION = extern struct {
    DiskNumber: u32,
};

pub const DISK_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};

pub const DEVPROPKEY = extern struct {
    fmtid: Guid,
    pid: u32,
};

pub const DEVPROPSTORE = extern enum(i32) {
    SYSTEM = 0,
    USER = 1,
};
pub const DEVPROP_STORE_SYSTEM = DEVPROPSTORE.SYSTEM;
pub const DEVPROP_STORE_USER = DEVPROPSTORE.USER;

pub const DEVPROPCOMPKEY = extern struct {
    Key: DEVPROPKEY,
    Store: DEVPROPSTORE,
    LocaleName: [*:0]const u16,
};

pub const DEVPROPERTY = extern struct {
    CompKey: DEVPROPCOMPKEY,
    Type: u32,
    BufferSize: u32,
    Buffer: *c_void,
};

pub const REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO = extern struct {
    Version: u32,
    Accurate: u32,
    Supported: u32,
    AccurateMask0: u32,
};

pub const DEV_BROADCAST_HDR = extern struct {
    dbch_size: u32,
    dbch_devicetype: DEV_BROADCAST_HDR_DEVICE_TYPE,
    dbch_reserved: u32,
};

pub const VolLockBroadcast = extern struct {
    vlb_dbh: DEV_BROADCAST_HDR,
    vlb_owner: u32,
    vlb_perms: u8,
    vlb_lockType: u8,
    vlb_drive: u8,
    vlb_flags: u8,
};

pub const _DEV_BROADCAST_HEADER = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
};

pub const DEV_BROADCAST_OEM = extern struct {
    dbco_size: u32,
    dbco_devicetype: u32,
    dbco_reserved: u32,
    dbco_identifier: u32,
    dbco_suppfunc: u32,
};

pub const DEV_BROADCAST_DEVNODE = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
    dbcd_devnode: u32,
};

pub const DEV_BROADCAST_VOLUME = extern struct {
    dbcv_size: u32,
    dbcv_devicetype: u32,
    dbcv_reserved: u32,
    dbcv_unitmask: u32,
    dbcv_flags: DEV_BROADCAST_VOLUME_FLAGS,
};

pub const DEV_BROADCAST_PORT_A = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: [1]CHAR,
};

pub const DEV_BROADCAST_PORT_W = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: [1]u16,
};

pub const DEV_BROADCAST_NET = extern struct {
    dbcn_size: u32,
    dbcn_devicetype: u32,
    dbcn_reserved: u32,
    dbcn_resource: u32,
    dbcn_flags: u32,
};

pub const DEV_BROADCAST_DEVICEINTERFACE_A = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: [1]CHAR,
};

pub const DEV_BROADCAST_DEVICEINTERFACE_W = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: [1]u16,
};

pub const DEV_BROADCAST_HANDLE = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: HANDLE,
    dbch_hdevnotify: *c_void,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const DEV_BROADCAST_HANDLE32 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u32,
    dbch_hdevnotify: u32,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const DEV_BROADCAST_HANDLE64 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u64,
    dbch_hdevnotify: u64,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const _DEV_BROADCAST_USERDEFINED = extern struct {
    dbud_dbh: DEV_BROADCAST_HDR,
    dbud_szName: [1]CHAR,
};

pub const PWM_CONTROLLER_INFO = extern struct {
    Size: usize,
    PinCount: u32,
    MinimumPeriod: u64,
    MaximumPeriod: u64,
};

pub const PWM_CONTROLLER_GET_ACTUAL_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};

pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_INPUT = extern struct {
    DesiredPeriod: u64,
};

pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};

pub const PWM_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE_OUTPUT = extern struct {
    Percentage: u64,
};

pub const PWM_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE_INPUT = extern struct {
    Percentage: u64,
};

pub const PWM_POLARITY = extern enum(i32) {
    HIGH = 0,
    LOW = 1,
};
pub const PWM_ACTIVE_HIGH = PWM_POLARITY.HIGH;
pub const PWM_ACTIVE_LOW = PWM_POLARITY.LOW;

pub const PWM_PIN_GET_POLARITY_OUTPUT = extern struct {
    Polarity: PWM_POLARITY,
};

pub const PWM_PIN_SET_POLARITY_INPUT = extern struct {
    Polarity: PWM_POLARITY,
};

pub const PWM_PIN_IS_STARTED_OUTPUT = extern struct {
    IsStarted: u8,
};

pub const ENCLAVE_SEALING_IDENTITY_POLICY = extern enum(i32) {
    INVALID = 0,
    EXACT_CODE = 1,
    SAME_PRIMARY_CODE = 2,
    SAME_IMAGE = 3,
    SAME_FAMILY = 4,
    SAME_AUTHOR = 5,
};
pub const ENCLAVE_IDENTITY_POLICY_SEAL_INVALID = ENCLAVE_SEALING_IDENTITY_POLICY.INVALID;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_EXACT_CODE = ENCLAVE_SEALING_IDENTITY_POLICY.EXACT_CODE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_PRIMARY_CODE = ENCLAVE_SEALING_IDENTITY_POLICY.SAME_PRIMARY_CODE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_IMAGE = ENCLAVE_SEALING_IDENTITY_POLICY.SAME_IMAGE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_FAMILY = ENCLAVE_SEALING_IDENTITY_POLICY.SAME_FAMILY;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_AUTHOR = ENCLAVE_SEALING_IDENTITY_POLICY.SAME_AUTHOR;

pub const ENCLAVE_IDENTITY = extern struct {
    OwnerId: [32]u8,
    UniqueId: [32]u8,
    AuthorId: [32]u8,
    FamilyId: [16]u8,
    ImageId: [16]u8,
    EnclaveSvn: u32,
    SecureKernelSvn: u32,
    PlatformSvn: u32,
    Flags: u32,
    SigningLevel: u32,
    EnclaveType: u32,
};

pub const VBS_ENCLAVE_REPORT_PKG_HEADER = extern struct {
    PackageSize: u32,
    Version: u32,
    SignatureScheme: u32,
    SignedStatementSize: u32,
    SignatureSize: u32,
    Reserved: u32,
};

pub const VBS_ENCLAVE_REPORT = extern struct {
    ReportSize: u32,
    ReportVersion: u32,
    EnclaveData: [64]u8,
    EnclaveIdentity: ENCLAVE_IDENTITY,
};

pub const VBS_ENCLAVE_REPORT_VARDATA_HEADER = extern struct {
    DataType: u32,
    Size: u32,
};

pub const VBS_ENCLAVE_REPORT_MODULE = extern struct {
    Header: VBS_ENCLAVE_REPORT_VARDATA_HEADER,
    UniqueId: [32]u8,
    AuthorId: [32]u8,
    FamilyId: [16]u8,
    ImageId: [16]u8,
    Svn: u32,
    ModuleName: [1]u16,
};

pub const ENCLAVE_INFORMATION = extern struct {
    EnclaveType: u32,
    Reserved: u32,
    BaseAddress: *c_void,
    Size: usize,
    Identity: ENCLAVE_IDENTITY,
};

pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32 = extern struct {
    ThreadContext: [4]u32,
    EntryPoint: u32,
    StackPointer: u32,
    ExceptionEntryPoint: u32,
    ExceptionStack: u32,
    ExceptionActive: u32,
};

pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64 = extern struct {
    ThreadContext: [4]u64,
    EntryPoint: u64,
    StackPointer: u64,
    ExceptionEntryPoint: u64,
    ExceptionStack: u64,
    ExceptionActive: u32,
};

pub const VBS_BASIC_ENCLAVE_EXCEPTION_AMD64 = extern struct {
    ExceptionCode: u32,
    NumberParameters: u32,
    ExceptionInformation: [3]usize,
    ExceptionRAX: usize,
    ExceptionRCX: usize,
    ExceptionRIP: usize,
    ExceptionRFLAGS: usize,
    ExceptionRSP: usize,
};

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE = fn(
    ReturnValue: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION = fn(
    ExceptionRecord: *VBS_BASIC_ENCLAVE_EXCEPTION_AMD64,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfBytes: usize,
    SourceAddress: ?*c_void,
    PageProtection: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfBytes: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfytes: usize,
    PageProtection: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION = fn(
    EnclaveInfo: *ENCLAVE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENCLAVE_VBS_BASIC_KEY_REQUEST = extern struct {
    RequestSize: u32,
    Flags: u32,
    EnclaveSVN: u32,
    SystemKeyID: u32,
    CurrentSystemKeyID: u32,
};

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY = fn(
    KeyRequest: *ENCLAVE_VBS_BASIC_KEY_REQUEST,
    RequestedKeySize: u32,
    ReturnedKey: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT = fn(
    EnclaveData: ?*const u8,
    // TODO: what to do with BytesParamIndex 2?
    Report: ?*c_void,
    BufferSize: u32,
    OutputSize: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT = fn(
    // TODO: what to do with BytesParamIndex 1?
    Report: *const c_void,
    ReportSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA = fn(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *u8,
    NumberOfBytes: u32,
    Generation: *u64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_SYSCALL_PAGE = extern struct {
    ReturnFromEnclave: VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE,
    ReturnFromException: VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION,
    TerminateThread: VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD,
    InterruptThread: VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD,
    CommitPages: VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES,
    DecommitPages: VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES,
    ProtectPages: VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES,
    CreateThread: VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD,
    GetEnclaveInformation: VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION,
    GenerateKey: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY,
    GenerateReport: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT,
    VerifyReport: VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT,
    GenerateRandomData: VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA,
};

pub const EFFECTIVE_POWER_MODE = extern enum(i32) {
    BatterySaver = 0,
    BetterBattery = 1,
    Balanced = 2,
    HighPerformance = 3,
    MaxPerformance = 4,
    GameMode = 5,
    MixedReality = 6,
};
pub const EffectivePowerModeBatterySaver = EFFECTIVE_POWER_MODE.BatterySaver;
pub const EffectivePowerModeBetterBattery = EFFECTIVE_POWER_MODE.BetterBattery;
pub const EffectivePowerModeBalanced = EFFECTIVE_POWER_MODE.Balanced;
pub const EffectivePowerModeHighPerformance = EFFECTIVE_POWER_MODE.HighPerformance;
pub const EffectivePowerModeMaxPerformance = EFFECTIVE_POWER_MODE.MaxPerformance;
pub const EffectivePowerModeGameMode = EFFECTIVE_POWER_MODE.GameMode;
pub const EffectivePowerModeMixedReality = EFFECTIVE_POWER_MODE.MixedReality;

// TODO: this type is limited to platform 'windows10.0.17763'
pub const EFFECTIVE_POWER_MODE_CALLBACK = fn(
    Mode: EFFECTIVE_POWER_MODE,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const GLOBAL_MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    LidOpenWakeAc: SYSTEM_POWER_STATE,
    LidOpenWakeDc: SYSTEM_POWER_STATE,
    BroadcastCapacityResolution: u32,
};

pub const GLOBAL_USER_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButtonAc: POWER_ACTION_POLICY,
    PowerButtonDc: POWER_ACTION_POLICY,
    SleepButtonAc: POWER_ACTION_POLICY,
    SleepButtonDc: POWER_ACTION_POLICY,
    LidCloseAc: POWER_ACTION_POLICY,
    LidCloseDc: POWER_ACTION_POLICY,
    DischargePolicy: [4]SYSTEM_POWER_LEVEL,
    GlobalFlags: u32,
};

pub const GLOBAL_POWER_POLICY = extern struct {
    user: GLOBAL_USER_POWER_POLICY,
    mach: GLOBAL_MACHINE_POWER_POLICY,
};

pub const MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    MinSleepAc: SYSTEM_POWER_STATE,
    MinSleepDc: SYSTEM_POWER_STATE,
    ReducedLatencySleepAc: SYSTEM_POWER_STATE,
    ReducedLatencySleepDc: SYSTEM_POWER_STATE,
    DozeTimeoutAc: u32,
    DozeTimeoutDc: u32,
    DozeS4TimeoutAc: u32,
    DozeS4TimeoutDc: u32,
    MinThrottleAc: u8,
    MinThrottleDc: u8,
    pad1: [2]u8,
    OverThrottledAc: POWER_ACTION_POLICY,
    OverThrottledDc: POWER_ACTION_POLICY,
};

pub const MACHINE_PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    ProcessorPolicyAc: PROCESSOR_POWER_POLICY,
    ProcessorPolicyDc: PROCESSOR_POWER_POLICY,
};

pub const USER_POWER_POLICY = extern struct {
    Revision: u32,
    IdleAc: POWER_ACTION_POLICY,
    IdleDc: POWER_ACTION_POLICY,
    IdleTimeoutAc: u32,
    IdleTimeoutDc: u32,
    IdleSensitivityAc: u8,
    IdleSensitivityDc: u8,
    ThrottlePolicyAc: u8,
    ThrottlePolicyDc: u8,
    MaxSleepAc: SYSTEM_POWER_STATE,
    MaxSleepDc: SYSTEM_POWER_STATE,
    Reserved: [2]u32,
    VideoTimeoutAc: u32,
    VideoTimeoutDc: u32,
    SpindownTimeoutAc: u32,
    SpindownTimeoutDc: u32,
    OptimizeForPowerAc: u8,
    OptimizeForPowerDc: u8,
    FanThrottleToleranceAc: u8,
    FanThrottleToleranceDc: u8,
    ForcedThrottleAc: u8,
    ForcedThrottleDc: u8,
};

pub const POWER_POLICY = extern struct {
    user: USER_POWER_POLICY,
    mach: MACHINE_POWER_POLICY,
};

pub const PWRSCHEMESENUMPROC_V1 = fn(
    Index: u32,
    NameSize: u32,
    // TODO: what to do with BytesParamIndex 1?
    Name: *i8,
    DescriptionSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    Description: *i8,
    Policy: *POWER_POLICY,
    Context: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PWRSCHEMESENUMPROC = fn(
    Index: u32,
    NameSize: u32,
    // TODO: what to do with BytesParamIndex 1?
    Name: PWSTR,
    DescriptionSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    Description: PWSTR,
    Policy: *POWER_POLICY,
    Context: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const POWER_DATA_ACCESSOR = extern enum(i32) {
    AC_POWER_SETTING_INDEX = 0,
    DC_POWER_SETTING_INDEX = 1,
    FRIENDLY_NAME = 2,
    DESCRIPTION = 3,
    POSSIBLE_POWER_SETTING = 4,
    POSSIBLE_POWER_SETTING_FRIENDLY_NAME = 5,
    POSSIBLE_POWER_SETTING_DESCRIPTION = 6,
    DEFAULT_AC_POWER_SETTING = 7,
    DEFAULT_DC_POWER_SETTING = 8,
    POSSIBLE_VALUE_MIN = 9,
    POSSIBLE_VALUE_MAX = 10,
    POSSIBLE_VALUE_INCREMENT = 11,
    POSSIBLE_VALUE_UNITS = 12,
    ICON_RESOURCE = 13,
    DEFAULT_SECURITY_DESCRIPTOR = 14,
    ATTRIBUTES = 15,
    SCHEME = 16,
    SUBGROUP = 17,
    INDIVIDUAL_SETTING = 18,
    ACTIVE_SCHEME = 19,
    CREATE_SCHEME = 20,
    AC_POWER_SETTING_MAX = 21,
    DC_POWER_SETTING_MAX = 22,
    AC_POWER_SETTING_MIN = 23,
    DC_POWER_SETTING_MIN = 24,
    PROFILE = 25,
    OVERLAY_SCHEME = 26,
    ACTIVE_OVERLAY_SCHEME = 27,
};
pub const ACCESS_AC_POWER_SETTING_INDEX = POWER_DATA_ACCESSOR.AC_POWER_SETTING_INDEX;
pub const ACCESS_DC_POWER_SETTING_INDEX = POWER_DATA_ACCESSOR.DC_POWER_SETTING_INDEX;
pub const ACCESS_FRIENDLY_NAME = POWER_DATA_ACCESSOR.FRIENDLY_NAME;
pub const ACCESS_DESCRIPTION = POWER_DATA_ACCESSOR.DESCRIPTION;
pub const ACCESS_POSSIBLE_POWER_SETTING = POWER_DATA_ACCESSOR.POSSIBLE_POWER_SETTING;
pub const ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME = POWER_DATA_ACCESSOR.POSSIBLE_POWER_SETTING_FRIENDLY_NAME;
pub const ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION = POWER_DATA_ACCESSOR.POSSIBLE_POWER_SETTING_DESCRIPTION;
pub const ACCESS_DEFAULT_AC_POWER_SETTING = POWER_DATA_ACCESSOR.DEFAULT_AC_POWER_SETTING;
pub const ACCESS_DEFAULT_DC_POWER_SETTING = POWER_DATA_ACCESSOR.DEFAULT_DC_POWER_SETTING;
pub const ACCESS_POSSIBLE_VALUE_MIN = POWER_DATA_ACCESSOR.POSSIBLE_VALUE_MIN;
pub const ACCESS_POSSIBLE_VALUE_MAX = POWER_DATA_ACCESSOR.POSSIBLE_VALUE_MAX;
pub const ACCESS_POSSIBLE_VALUE_INCREMENT = POWER_DATA_ACCESSOR.POSSIBLE_VALUE_INCREMENT;
pub const ACCESS_POSSIBLE_VALUE_UNITS = POWER_DATA_ACCESSOR.POSSIBLE_VALUE_UNITS;
pub const ACCESS_ICON_RESOURCE = POWER_DATA_ACCESSOR.ICON_RESOURCE;
pub const ACCESS_DEFAULT_SECURITY_DESCRIPTOR = POWER_DATA_ACCESSOR.DEFAULT_SECURITY_DESCRIPTOR;
pub const ACCESS_ATTRIBUTES = POWER_DATA_ACCESSOR.ATTRIBUTES;
pub const ACCESS_SCHEME = POWER_DATA_ACCESSOR.SCHEME;
pub const ACCESS_SUBGROUP = POWER_DATA_ACCESSOR.SUBGROUP;
pub const ACCESS_INDIVIDUAL_SETTING = POWER_DATA_ACCESSOR.INDIVIDUAL_SETTING;
pub const ACCESS_ACTIVE_SCHEME = POWER_DATA_ACCESSOR.ACTIVE_SCHEME;
pub const ACCESS_CREATE_SCHEME = POWER_DATA_ACCESSOR.CREATE_SCHEME;
pub const ACCESS_AC_POWER_SETTING_MAX = POWER_DATA_ACCESSOR.AC_POWER_SETTING_MAX;
pub const ACCESS_DC_POWER_SETTING_MAX = POWER_DATA_ACCESSOR.DC_POWER_SETTING_MAX;
pub const ACCESS_AC_POWER_SETTING_MIN = POWER_DATA_ACCESSOR.AC_POWER_SETTING_MIN;
pub const ACCESS_DC_POWER_SETTING_MIN = POWER_DATA_ACCESSOR.DC_POWER_SETTING_MIN;
pub const ACCESS_PROFILE = POWER_DATA_ACCESSOR.PROFILE;
pub const ACCESS_OVERLAY_SCHEME = POWER_DATA_ACCESSOR.OVERLAY_SCHEME;
pub const ACCESS_ACTIVE_OVERLAY_SCHEME = POWER_DATA_ACCESSOR.ACTIVE_OVERLAY_SCHEME;

pub const PDEVICE_NOTIFY_CALLBACK_ROUTINE = fn(
    Context: ?*c_void,
    Type: u32,
    Setting: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS = extern struct {
    Callback: PDEVICE_NOTIFY_CALLBACK_ROUTINE,
    Context: *c_void,
};

pub const THERMAL_EVENT = extern struct {
    Version: u32,
    Size: u32,
    Type: u32,
    Temperature: u32,
    TripPointTemperature: u32,
    Initiator: PWSTR,
};

pub const BATTERY_QUERY_INFORMATION_LEVEL = extern enum(i32) {
    Information = 0,
    GranularityInformation = 1,
    Temperature = 2,
    EstimatedTime = 3,
    DeviceName = 4,
    ManufactureDate = 5,
    ManufactureName = 6,
    UniqueID = 7,
    SerialNumber = 8,
};
pub const BatteryInformation = BATTERY_QUERY_INFORMATION_LEVEL.Information;
pub const BatteryGranularityInformation = BATTERY_QUERY_INFORMATION_LEVEL.GranularityInformation;
pub const BatteryTemperature = BATTERY_QUERY_INFORMATION_LEVEL.Temperature;
pub const BatteryEstimatedTime = BATTERY_QUERY_INFORMATION_LEVEL.EstimatedTime;
pub const BatteryDeviceName = BATTERY_QUERY_INFORMATION_LEVEL.DeviceName;
pub const BatteryManufactureDate = BATTERY_QUERY_INFORMATION_LEVEL.ManufactureDate;
pub const BatteryManufactureName = BATTERY_QUERY_INFORMATION_LEVEL.ManufactureName;
pub const BatteryUniqueID = BATTERY_QUERY_INFORMATION_LEVEL.UniqueID;
pub const BatterySerialNumber = BATTERY_QUERY_INFORMATION_LEVEL.SerialNumber;

pub const BATTERY_QUERY_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_QUERY_INFORMATION_LEVEL,
    AtRate: u32,
};

pub const BATTERY_INFORMATION = extern struct {
    Capabilities: u32,
    Technology: u8,
    Reserved: [3]u8,
    Chemistry: [4]u8,
    DesignedCapacity: u32,
    FullChargedCapacity: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
    CriticalBias: u32,
    CycleCount: u32,
};

pub const BATTERY_CHARGING_SOURCE_TYPE = extern enum(i32) {
    AC = 1,
    USB = 2,
    Wireless = 3,
    Max = 4,
};
pub const BatteryChargingSourceType_AC = BATTERY_CHARGING_SOURCE_TYPE.AC;
pub const BatteryChargingSourceType_USB = BATTERY_CHARGING_SOURCE_TYPE.USB;
pub const BatteryChargingSourceType_Wireless = BATTERY_CHARGING_SOURCE_TYPE.Wireless;
pub const BatteryChargingSourceType_Max = BATTERY_CHARGING_SOURCE_TYPE.Max;

pub const BATTERY_CHARGING_SOURCE = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    MaxCurrent: u32,
};

pub const BATTERY_CHARGING_SOURCE_INFORMATION = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    SourceOnline: u8,
};

pub const USB_CHARGER_PORT = extern enum(i32) {
    Legacy = 0,
    TypeC = 1,
    Max = 2,
};
pub const UsbChargerPort_Legacy = USB_CHARGER_PORT.Legacy;
pub const UsbChargerPort_TypeC = USB_CHARGER_PORT.TypeC;
pub const UsbChargerPort_Max = USB_CHARGER_PORT.Max;

pub const BATTERY_SET_INFORMATION_LEVEL = extern enum(i32) {
    CriticalBias = 0,
    Charge = 1,
    Discharge = 2,
    ChargingSource = 3,
    ChargerId = 4,
    ChargerStatus = 5,
};
pub const BatteryCriticalBias = BATTERY_SET_INFORMATION_LEVEL.CriticalBias;
pub const BatteryCharge = BATTERY_SET_INFORMATION_LEVEL.Charge;
pub const BatteryDischarge = BATTERY_SET_INFORMATION_LEVEL.Discharge;
pub const BatteryChargingSource = BATTERY_SET_INFORMATION_LEVEL.ChargingSource;
pub const BatteryChargerId = BATTERY_SET_INFORMATION_LEVEL.ChargerId;
pub const BatteryChargerStatus = BATTERY_SET_INFORMATION_LEVEL.ChargerStatus;

pub const BATTERY_SET_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_SET_INFORMATION_LEVEL,
    Buffer: [1]u8,
};

pub const BATTERY_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    VaData: [1]u32,
};

pub const BATTERY_USB_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    Reserved: u32,
    Flags: u32,
    MaxCurrent: u32,
    Voltage: u32,
    PortType: USB_CHARGER_PORT,
    PortId: u64,
    PowerSourceInformation: *c_void,
    OemCharger: Guid,
};

pub const BATTERY_WAIT_STATUS = extern struct {
    BatteryTag: u32,
    Timeout: u32,
    PowerState: u32,
    LowCapacity: u32,
    HighCapacity: u32,
};

pub const BATTERY_STATUS = extern struct {
    PowerState: u32,
    Capacity: u32,
    Voltage: u32,
    Rate: i32,
};

pub const BATTERY_MANUFACTURE_DATE = extern struct {
    Day: u8,
    Month: u8,
    Year: u16,
};

pub const THERMAL_INFORMATION = extern struct {
    ThermalStamp: u32,
    ThermalConstant1: u32,
    ThermalConstant2: u32,
    Processors: usize,
    SamplingPeriod: u32,
    CurrentTemperature: u32,
    PassiveTripPoint: u32,
    CriticalTripPoint: u32,
    ActiveTripPointCount: u8,
    ActiveTripPoint: [10]u32,
};

pub const THERMAL_WAIT_READ = extern struct {
    Timeout: u32,
    LowTemperature: u32,
    HighTemperature: u32,
};

pub const THERMAL_POLICY = extern struct {
    Version: u32,
    WaitForUpdate: u8,
    Hibernate: u8,
    Critical: u8,
    ThermalStandby: u8,
    ActivationReasons: u32,
    PassiveLimit: u32,
    ActiveLevel: u32,
    OverThrottled: u8,
};

pub const PROCESSOR_OBJECT_INFO = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
};

pub const PROCESSOR_OBJECT_INFO_EX = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
    InitialApicId: u32,
};

pub const WAKE_ALARM_INFORMATION = extern struct {
    TimerIdentifier: u32,
    Timeout: u32,
};

pub const ACPI_REAL_TIME = extern struct {
    Year: u16,
    Month: u8,
    Day: u8,
    Hour: u8,
    Minute: u8,
    Second: u8,
    Valid: u8,
    Milliseconds: u16,
    TimeZone: i16,
    DayLight: u8,
    Reserved1: [3]u8,
};

pub const INDIRECT_DISPLAY_INFO = extern struct {
    DisplayAdapterLuid: LUID,
    Flags: u32,
    NumMonitors: u32,
    DisplayAdapterTargetBase: u32,
};

pub const VIDEO_VDM = extern struct {
    ProcessHandle: HANDLE,
};

pub const VIDEO_REGISTER_VDM = extern struct {
    MinimumStateSize: u32,
};

pub const VIDEO_MONITOR_DESCRIPTOR = extern struct {
    DescriptorSize: u32,
    Descriptor: [1]u8,
};

pub const VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE = extern enum(i32) {
    PowerNotifyCallout = 1,
    EnumChildPdoNotifyCallout = 3,
    FindAdapterCallout = 4,
    PnpNotifyCallout = 7,
    DxgkDisplaySwitchCallout = 8,
    DxgkFindAdapterTdrCallout = 10,
    DxgkHardwareProtectionTeardown = 11,
    RepaintDesktop = 12,
    UpdateCursor = 13,
    DisableMultiPlaneOverlay = 14,
    DesktopDuplicationChange = 15,
    BlackScreenDiagnostics = 16,
};
pub const VideoPowerNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.PowerNotifyCallout;
pub const VideoEnumChildPdoNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.EnumChildPdoNotifyCallout;
pub const VideoFindAdapterCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.FindAdapterCallout;
pub const VideoPnpNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.PnpNotifyCallout;
pub const VideoDxgkDisplaySwitchCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.DxgkDisplaySwitchCallout;
pub const VideoDxgkFindAdapterTdrCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.DxgkFindAdapterTdrCallout;
pub const VideoDxgkHardwareProtectionTeardown = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.DxgkHardwareProtectionTeardown;
pub const VideoRepaintDesktop = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.RepaintDesktop;
pub const VideoUpdateCursor = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.UpdateCursor;
pub const VideoDisableMultiPlaneOverlay = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.DisableMultiPlaneOverlay;
pub const VideoDesktopDuplicationChange = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.DesktopDuplicationChange;
pub const VideoBlackScreenDiagnostics = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.BlackScreenDiagnostics;

pub const BlackScreenDiagnosticsCalloutParam = extern enum(i32) {
    agnosticsData = 1,
    splayRecovery = 2,
};
pub const BlackScreenDiagnosticsData = BlackScreenDiagnosticsCalloutParam.agnosticsData;
pub const BlackScreenDisplayRecovery = BlackScreenDiagnosticsCalloutParam.splayRecovery;

pub const DXGK_WIN32K_PARAM_DATA = extern struct {
    PathsArray: *c_void,
    ModesArray: *c_void,
    NumPathArrayElements: u32,
    NumModeArrayElements: u32,
    SDCFlags: u32,
};

pub const VIDEO_WIN32K_CALLBACKS_PARAMS = extern struct {
    CalloutType: VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE,
    PhysDisp: *c_void,
    Param: usize,
    Status: i32,
    LockUserSession: u8,
    IsPostDevice: u8,
    SurpriseRemoval: u8,
    WaitForQueueReady: u8,
};

pub const PVIDEO_WIN32K_CALLOUT = fn(
    Params: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const VIDEO_WIN32K_CALLBACKS = extern struct {
    PhysDisp: *c_void,
    Callout: PVIDEO_WIN32K_CALLOUT,
    bACPI: u32,
    pPhysDeviceObject: HANDLE,
    DualviewFlags: u32,
};

pub const VIDEO_DEVICE_SESSION_STATUS = extern struct {
    bEnable: u32,
    bSuccess: u32,
};

pub const VIDEO_HARDWARE_STATE_HEADER = extern struct {
    Length: u32,
    PortValue: [48]u8,
    AttribIndexDataState: u32,
    BasicSequencerOffset: u32,
    BasicCrtContOffset: u32,
    BasicGraphContOffset: u32,
    BasicAttribContOffset: u32,
    BasicDacOffset: u32,
    BasicLatchesOffset: u32,
    ExtendedSequencerOffset: u32,
    ExtendedCrtContOffset: u32,
    ExtendedGraphContOffset: u32,
    ExtendedAttribContOffset: u32,
    ExtendedDacOffset: u32,
    ExtendedValidatorStateOffset: u32,
    ExtendedMiscDataOffset: u32,
    PlaneLength: u32,
    Plane1Offset: u32,
    Plane2Offset: u32,
    Plane3Offset: u32,
    Plane4Offset: u32,
    VGAStateFlags: u32,
    DIBOffset: u32,
    DIBBitsPerPixel: u32,
    DIBXResolution: u32,
    DIBYResolution: u32,
    DIBXlatOffset: u32,
    DIBXlatLength: u32,
    VesaInfoOffset: u32,
    FrameBufferData: *c_void,
};

pub const VIDEO_HARDWARE_STATE = extern struct {
    StateHeader: *VIDEO_HARDWARE_STATE_HEADER,
    StateLength: u32,
};

pub const VIDEO_NUM_MODES = extern struct {
    NumModes: u32,
    ModeInformationLength: u32,
};

pub const VIDEO_MODE = extern struct {
    RequestedMode: u32,
};

pub const VIDEO_MODE_INFORMATION = extern struct {
    Length: u32,
    ModeIndex: u32,
    VisScreenWidth: u32,
    VisScreenHeight: u32,
    ScreenStride: u32,
    NumberOfPlanes: u32,
    BitsPerPlane: u32,
    Frequency: u32,
    XMillimeter: u32,
    YMillimeter: u32,
    NumberRedBits: u32,
    NumberGreenBits: u32,
    NumberBlueBits: u32,
    RedMask: u32,
    GreenMask: u32,
    BlueMask: u32,
    AttributeFlags: u32,
    VideoMemoryBitmapWidth: u32,
    VideoMemoryBitmapHeight: u32,
    DriverSpecificAttributeFlags: u32,
};

pub const VIDEO_LOAD_FONT_INFORMATION = extern struct {
    WidthInPixels: u16,
    HeightInPixels: u16,
    FontSize: u32,
    Font: [1]u8,
};

pub const VIDEO_PALETTE_DATA = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    Colors: [1]u16,
};

pub const VIDEO_CLUTDATA = extern struct {
    Red: u8,
    Green: u8,
    Blue: u8,
    Unused: u8,
};

pub const VIDEO_CLUT = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    LookupTable: [1]_Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VIDEO_CURSOR_POSITION = extern struct {
    Column: i16,
    Row: i16,
};

pub const VIDEO_CURSOR_ATTRIBUTES = extern struct {
    Width: u16,
    Height: u16,
    Column: i16,
    Row: i16,
    Rate: u8,
    Enable: u8,
};

pub const VIDEO_POINTER_POSITION = extern struct {
    Column: i16,
    Row: i16,
};

pub const VIDEO_POINTER_ATTRIBUTES = extern struct {
    Flags: u32,
    Width: u32,
    Height: u32,
    WidthInBytes: u32,
    Enable: u32,
    Column: i16,
    Row: i16,
    Pixels: [1]u8,
};

pub const VIDEO_POINTER_CAPABILITIES = extern struct {
    Flags: u32,
    MaxWidth: u32,
    MaxHeight: u32,
    HWPtrBitmapStart: u32,
    HWPtrBitmapEnd: u32,
};

pub const VIDEO_BANK_SELECT = extern struct {
    Length: u32,
    Size: u32,
    BankingFlags: u32,
    BankingType: u32,
    PlanarHCBankingType: u32,
    BitmapWidthInBytes: u32,
    BitmapSize: u32,
    Granularity: u32,
    PlanarHCGranularity: u32,
    CodeOffset: u32,
    PlanarHCBankCodeOffset: u32,
    PlanarHCEnableCodeOffset: u32,
    PlanarHCDisableCodeOffset: u32,
};

pub const VIDEO_BANK_TYPE = extern enum(i32) {
    VideoNotBanked = 0,
    VideoBanked1RW = 1,
    VideoBanked1R1W = 2,
    VideoBanked2RW = 3,
    NumVideoBankTypes = 4,
};
pub const VideoNotBanked = VIDEO_BANK_TYPE.VideoNotBanked;
pub const VideoBanked1RW = VIDEO_BANK_TYPE.VideoBanked1RW;
pub const VideoBanked1R1W = VIDEO_BANK_TYPE.VideoBanked1R1W;
pub const VideoBanked2RW = VIDEO_BANK_TYPE.VideoBanked2RW;
pub const NumVideoBankTypes = VIDEO_BANK_TYPE.NumVideoBankTypes;

pub const VIDEO_MEMORY = extern struct {
    RequestedVirtualAddress: *c_void,
};

pub const VIDEO_SHARE_MEMORY = extern struct {
    ProcessHandle: HANDLE,
    ViewOffset: u32,
    ViewSize: u32,
    RequestedVirtualAddress: *c_void,
};

pub const VIDEO_SHARE_MEMORY_INFORMATION = extern struct {
    SharedViewOffset: u32,
    SharedViewSize: u32,
    VirtualAddress: *c_void,
};

pub const VIDEO_MEMORY_INFORMATION = extern struct {
    VideoRamBase: *c_void,
    VideoRamLength: u32,
    FrameBufferBase: *c_void,
    FrameBufferLength: u32,
};

pub const VIDEO_PUBLIC_ACCESS_RANGES = extern struct {
    InIoSpace: u32,
    MappedInIoSpace: u32,
    VirtualAddress: *c_void,
};

pub const VIDEO_COLOR_CAPABILITIES = extern struct {
    Length: u32,
    AttributeFlags: u32,
    RedPhosphoreDecay: i32,
    GreenPhosphoreDecay: i32,
    BluePhosphoreDecay: i32,
    WhiteChromaticity_x: i32,
    WhiteChromaticity_y: i32,
    WhiteChromaticity_Y: i32,
    RedChromaticity_x: i32,
    RedChromaticity_y: i32,
    GreenChromaticity_x: i32,
    GreenChromaticity_y: i32,
    BlueChromaticity_x: i32,
    BlueChromaticity_y: i32,
    WhiteGamma: i32,
    RedGamma: i32,
    GreenGamma: i32,
    BlueGamma: i32,
};

pub const VIDEO_POWER_STATE = extern enum(i32) {
    Unspecified = 0,
    On = 1,
    StandBy = 2,
    Suspend = 3,
    Off = 4,
    Hibernate = 5,
    Shutdown = 6,
    Maximum = 7,
};
pub const VideoPowerUnspecified = VIDEO_POWER_STATE.Unspecified;
pub const VideoPowerOn = VIDEO_POWER_STATE.On;
pub const VideoPowerStandBy = VIDEO_POWER_STATE.StandBy;
pub const VideoPowerSuspend = VIDEO_POWER_STATE.Suspend;
pub const VideoPowerOff = VIDEO_POWER_STATE.Off;
pub const VideoPowerHibernate = VIDEO_POWER_STATE.Hibernate;
pub const VideoPowerShutdown = VIDEO_POWER_STATE.Shutdown;
pub const VideoPowerMaximum = VIDEO_POWER_STATE.Maximum;

pub const VIDEO_POWER_MANAGEMENT = extern struct {
    Length: u32,
    DPMSVersion: u32,
    PowerState: u32,
};

pub const VIDEO_COLOR_LUT_DATA = extern struct {
    Length: u32,
    LutDataFormat: u32,
    LutData: [1]u8,
};

pub const VIDEO_LUT_RGB256WORDS = extern struct {
    Red: [256]u16,
    Green: [256]u16,
    Blue: [256]u16,
};

pub const BANK_POSITION = extern struct {
    ReadBankPosition: u32,
    WriteBankPosition: u32,
};

pub const DISPLAY_BRIGHTNESS = extern struct {
    ucDisplayPolicy: u8,
    ucACBrightness: u8,
    ucDCBrightness: u8,
};

pub const VIDEO_BRIGHTNESS_POLICY = extern struct {
    DefaultToBiosPolicy: u8,
    LevelCount: u8,
    Level: [1]_Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const FSCNTL_SCREEN_INFO = extern struct {
    Position: COORD,
    ScreenSize: COORD,
    nNumberOfChars: u32,
};

pub const FONT_IMAGE_INFO = extern struct {
    FontSize: COORD,
    ImageBits: *u8,
};

pub const CHAR_IMAGE_INFO = extern struct {
    CharInfo: CHAR_INFO,
    FontImageInfo: FONT_IMAGE_INFO,
};

pub const VGA_CHAR = extern struct {
    Char: CHAR,
    Attributes: CHAR,
};

pub const FSVIDEO_COPY_FRAME_BUFFER = extern struct {
    SrcScreen: FSCNTL_SCREEN_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};

pub const FSVIDEO_WRITE_TO_FRAME_BUFFER = extern struct {
    SrcBuffer: *CHAR_IMAGE_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};

pub const FSVIDEO_REVERSE_MOUSE_POINTER = extern struct {
    Screen: FSCNTL_SCREEN_INFO,
    dwType: u32,
};

pub const FSVIDEO_MODE_INFORMATION = extern struct {
    VideoMode: VIDEO_MODE_INFORMATION,
    VideoMemory: VIDEO_MEMORY_INFORMATION,
};

pub const FSVIDEO_SCREEN_INFORMATION = extern struct {
    ScreenSize: COORD,
    FontSize: COORD,
};

pub const FSVIDEO_CURSOR_POSITION = extern struct {
    Coord: VIDEO_CURSOR_POSITION,
    dwType: u32,
};

pub const ENG_EVENT = extern struct {
    pKEvent: *c_void,
    fFlags: u32,
};

pub const VIDEO_PERFORMANCE_COUNTER = extern struct {
    NbOfAllocationEvicted: [10]u64,
    NbOfAllocationMarked: [10]u64,
    NbOfAllocationRestored: [10]u64,
    KBytesEvicted: [10]u64,
    KBytesMarked: [10]u64,
    KBytesRestored: [10]u64,
    NbProcessCommited: u64,
    NbAllocationCommited: u64,
    NbAllocationMarked: u64,
    KBytesAllocated: u64,
    KBytesAvailable: u64,
    KBytesCurMarked: u64,
    Reference: u64,
    Unreference: u64,
    TrueReference: u64,
    NbOfPageIn: u64,
    KBytesPageIn: u64,
    NbOfPageOut: u64,
    KBytesPageOut: u64,
    NbOfRotateOut: u64,
    KBytesRotateOut: u64,
};

pub const VIDEO_QUERY_PERFORMANCE_COUNTER = extern struct {
    BufferSize: u32,
    Buffer: *VIDEO_PERFORMANCE_COUNTER,
};

pub const BRIGHTNESS_INTERFACE_VERSION = extern enum(i32) {
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
};
pub const BRIGHTNESS_INTERFACE_VERSION_1 = BRIGHTNESS_INTERFACE_VERSION.@"1";
pub const BRIGHTNESS_INTERFACE_VERSION_2 = BRIGHTNESS_INTERFACE_VERSION.@"2";
pub const BRIGHTNESS_INTERFACE_VERSION_3 = BRIGHTNESS_INTERFACE_VERSION.@"3";

pub const PANEL_QUERY_BRIGHTNESS_CAPS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const BRIGHTNESS_LEVEL = extern struct {
    Count: u8,
    Level: [103]u8,
};

pub const BRIGHTNESS_NIT_RANGE = extern struct {
    MinLevelInMillinit: u32,
    MaxLevelInMillinit: u32,
    StepSizeInMillinit: u32,
};

pub const BRIGHTNESS_NIT_RANGES = extern struct {
    NormalRangeCount: u32,
    RangeCount: u32,
    PreferredMaximumBrightness: u32,
    SupportedRanges: [16]BRIGHTNESS_NIT_RANGE,
};

pub const PANEL_QUERY_BRIGHTNESS_RANGES = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_GET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHROMATICITY_COORDINATE = extern struct {
    x: f32,
    y: f32,
};

pub const PANEL_BRIGHTNESS_SENSOR_DATA = extern struct {
    Anonymous: _Anonymous_e__Union,
    AlsReading: f32,
    ChromaticityCoordinate: CHROMATICITY_COORDINATE,
    ColorTemperature: f32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_SET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_SET_BRIGHTNESS_STATE = extern struct {
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const BACKLIGHT_OPTIMIZATION_LEVEL = extern enum(i32) {
    Disable = 0,
    Desktop = 1,
    Dynamic = 2,
    Dimmed = 3,
    EDR = 4,
};
pub const BacklightOptimizationDisable = BACKLIGHT_OPTIMIZATION_LEVEL.Disable;
pub const BacklightOptimizationDesktop = BACKLIGHT_OPTIMIZATION_LEVEL.Desktop;
pub const BacklightOptimizationDynamic = BACKLIGHT_OPTIMIZATION_LEVEL.Dynamic;
pub const BacklightOptimizationDimmed = BACKLIGHT_OPTIMIZATION_LEVEL.Dimmed;
pub const BacklightOptimizationEDR = BACKLIGHT_OPTIMIZATION_LEVEL.EDR;

pub const PANEL_SET_BACKLIGHT_OPTIMIZATION = extern struct {
    Level: BACKLIGHT_OPTIMIZATION_LEVEL,
};

pub const BACKLIGHT_REDUCTION_GAMMA_RAMP = extern struct {
    R: [256]u16,
    G: [256]u16,
    B: [256]u16,
};

pub const PANEL_GET_BACKLIGHT_REDUCTION = extern struct {
    BacklightUsersetting: u16,
    BacklightEffective: u16,
    GammaRamp: BACKLIGHT_REDUCTION_GAMMA_RAMP,
};

pub const COLORSPACE_TRANSFORM_DATA_TYPE = extern enum(i32) {
    IXED_POINT = 0,
    LOAT = 1,
};
pub const COLORSPACE_TRANSFORM_DATA_TYPE_FIXED_POINT = COLORSPACE_TRANSFORM_DATA_TYPE.IXED_POINT;
pub const COLORSPACE_TRANSFORM_DATA_TYPE_FLOAT = COLORSPACE_TRANSFORM_DATA_TYPE.LOAT;

pub const COLORSPACE_TRANSFORM_DATA_CAP = extern struct {
    DataType: COLORSPACE_TRANSFORM_DATA_TYPE,
    Anonymous: _Anonymous_e__Union,
    NumericRangeMin: f32,
    NumericRangeMax: f32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_1DLUT_CAP = extern struct {
    NumberOfLUTEntries: u32,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
};

pub const COLORSPACE_TRANSFORM_MATRIX_CAP = extern struct {
    Anonymous: _Anonymous_e__Union,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION = extern enum(i32) {
    DEFAULT = 0,
    @"1" = 1,
    NOT_SUPPORTED = 0,
};
pub const COLORSPACE_TRANSFORM_VERSION_DEFAULT = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.DEFAULT;
pub const COLORSPACE_TRANSFORM_VERSION_1 = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.@"1";
pub const COLORSPACE_TRANSFORM_VERSION_NOT_SUPPORTED = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.NOT_SUPPORTED;

pub const COLORSPACE_TRANSFORM_TARGET_CAPS = extern struct {
    Version: COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION,
    LookupTable1DDegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
    ColorMatrix3x3Cap: COLORSPACE_TRANSFORM_MATRIX_CAP,
    LookupTable1DRegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
};

pub const COLORSPACE_TRANSFORM_TYPE = extern enum(i32) {
    UNINITIALIZED = 0,
    DEFAULT = 1,
    RGB256x3x16 = 2,
    DXGI_1 = 3,
    MATRIX_3x4 = 4,
    MATRIX_V2 = 5,
};
pub const COLORSPACE_TRANSFORM_TYPE_UNINITIALIZED = COLORSPACE_TRANSFORM_TYPE.UNINITIALIZED;
pub const COLORSPACE_TRANSFORM_TYPE_DEFAULT = COLORSPACE_TRANSFORM_TYPE.DEFAULT;
pub const COLORSPACE_TRANSFORM_TYPE_RGB256x3x16 = COLORSPACE_TRANSFORM_TYPE.RGB256x3x16;
pub const COLORSPACE_TRANSFORM_TYPE_DXGI_1 = COLORSPACE_TRANSFORM_TYPE.DXGI_1;
pub const COLORSPACE_TRANSFORM_TYPE_MATRIX_3x4 = COLORSPACE_TRANSFORM_TYPE.MATRIX_3x4;
pub const COLORSPACE_TRANSFORM_TYPE_MATRIX_V2 = COLORSPACE_TRANSFORM_TYPE.MATRIX_V2;

pub const GAMMA_RAMP_RGB256x3x16 = extern struct {
    Red: [256]u16,
    Green: [256]u16,
    Blue: [256]u16,
};

pub const GAMMA_RAMP_RGB = extern struct {
    Red: f32,
    Green: f32,
    Blue: f32,
};

pub const GAMMA_RAMP_DXGI_1 = extern struct {
    Scale: GAMMA_RAMP_RGB,
    Offset: GAMMA_RAMP_RGB,
    GammaCurve: [1025]GAMMA_RAMP_RGB,
};

pub const COLORSPACE_TRANSFORM_3x4 = extern struct {
    ColorMatrix3x4: [12]f32,
    ScalarMultiplier: f32,
    LookupTable1D: [4096]GAMMA_RAMP_RGB,
};

pub const OUTPUT_WIRE_COLOR_SPACE_TYPE = extern enum(i32) {
    G22_P709 = 0,
    RESERVED = 4,
    G2084_P2020 = 12,
    G22_P709_WCG = 30,
    G22_P2020 = 31,
    G2084_P2020_HDR10PLUS = 32,
    G2084_P2020_DVLL = 33,
};
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P709 = OUTPUT_WIRE_COLOR_SPACE_TYPE.G22_P709;
pub const OUTPUT_WIRE_COLOR_SPACE_RESERVED = OUTPUT_WIRE_COLOR_SPACE_TYPE.RESERVED;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020 = OUTPUT_WIRE_COLOR_SPACE_TYPE.G2084_P2020;
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P709_WCG = OUTPUT_WIRE_COLOR_SPACE_TYPE.G22_P709_WCG;
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P2020 = OUTPUT_WIRE_COLOR_SPACE_TYPE.G22_P2020;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_HDR10PLUS = OUTPUT_WIRE_COLOR_SPACE_TYPE.G2084_P2020_HDR10PLUS;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_DVLL = OUTPUT_WIRE_COLOR_SPACE_TYPE.G2084_P2020_DVLL;

pub const OUTPUT_COLOR_ENCODING = extern enum(i32) {
    RGB = 0,
    YCBCR444 = 1,
    YCBCR422 = 2,
    YCBCR420 = 3,
    INTENSITY = 4,
    FORCE_UINT32 = -1,
};
pub const OUTPUT_COLOR_ENCODING_RGB = OUTPUT_COLOR_ENCODING.RGB;
pub const OUTPUT_COLOR_ENCODING_YCBCR444 = OUTPUT_COLOR_ENCODING.YCBCR444;
pub const OUTPUT_COLOR_ENCODING_YCBCR422 = OUTPUT_COLOR_ENCODING.YCBCR422;
pub const OUTPUT_COLOR_ENCODING_YCBCR420 = OUTPUT_COLOR_ENCODING.YCBCR420;
pub const OUTPUT_COLOR_ENCODING_INTENSITY = OUTPUT_COLOR_ENCODING.INTENSITY;
pub const OUTPUT_COLOR_ENCODING_FORCE_UINT32 = OUTPUT_COLOR_ENCODING.FORCE_UINT32;

pub const OUTPUT_WIRE_FORMAT = extern struct {
    ColorEncoding: OUTPUT_COLOR_ENCODING,
    BitsPerPixel: u32,
};

pub const COLORSPACE_TRANSFORM_STAGE_CONTROL = extern enum(i32) {
    No_Change = 0,
    Enable = 1,
    Bypass = 2,
};
pub const ColorSpaceTransformStageControl_No_Change = COLORSPACE_TRANSFORM_STAGE_CONTROL.No_Change;
pub const ColorSpaceTransformStageControl_Enable = COLORSPACE_TRANSFORM_STAGE_CONTROL.Enable;
pub const ColorSpaceTransformStageControl_Bypass = COLORSPACE_TRANSFORM_STAGE_CONTROL.Bypass;

pub const COLORSPACE_TRANSFORM_MATRIX_V2 = extern struct {
    StageControlLookupTable1DDegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DDegamma: [4096]GAMMA_RAMP_RGB,
    StageControlColorMatrix3x3: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    ColorMatrix3x3: [9]f32,
    StageControlLookupTable1DRegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DRegamma: [4096]GAMMA_RAMP_RGB,
};

pub const COLORSPACE_TRANSFORM = extern struct {
    Type: COLORSPACE_TRANSFORM_TYPE,
    Data: _Data_e__Union,
    const _Data_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_SET_INPUT = extern struct {
    OutputWireColorSpaceExpected: OUTPUT_WIRE_COLOR_SPACE_TYPE,
    OutputWireFormatExpected: OUTPUT_WIRE_FORMAT,
    ColorSpaceTransform: COLORSPACE_TRANSFORM,
};

pub const SET_ACTIVE_COLOR_PROFILE_NAME = extern struct {
    ColorProfileName: [1]u16,
};

pub const MIPI_DSI_CAPS = extern struct {
    DSITypeMajor: u8,
    DSITypeMinor: u8,
    SpecVersionMajor: u8,
    SpecVersionMinor: u8,
    SpecVersionPatch: u8,
    TargetMaximumReturnPacketSize: u16,
    ResultCodeFlags: u8,
    ResultCodeStatus: u8,
    Revision: u8,
    Level: u8,
    DeviceClassHi: u8,
    DeviceClassLo: u8,
    ManufacturerHi: u8,
    ManufacturerLo: u8,
    ProductHi: u8,
    ProductLo: u8,
    LengthHi: u8,
    LengthLo: u8,
};

pub const DSI_CONTROL_TRANSMISSION_MODE = extern enum(i32) {
    DEFAULT = 0,
    FORCE_LOW_POWER = 1,
    FORCE_HIGH_PERFORMANCE = 2,
};
pub const DCT_DEFAULT = DSI_CONTROL_TRANSMISSION_MODE.DEFAULT;
pub const DCT_FORCE_LOW_POWER = DSI_CONTROL_TRANSMISSION_MODE.FORCE_LOW_POWER;
pub const DCT_FORCE_HIGH_PERFORMANCE = DSI_CONTROL_TRANSMISSION_MODE.FORCE_HIGH_PERFORMANCE;

pub const MIPI_DSI_PACKET = extern struct {
    Anonymous1: _Anonymous1_e__Union,
    Anonymous2: _Anonymous2_e__Union,
    EccFiller: u8,
    Payload: [8]u8,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const MIPI_DSI_TRANSMISSION = extern struct {
    TotalBufferSize: u32,
    PacketCount: u8,
    FailedPacket: u8,
    Anonymous: _Anonymous_e__Struct,
    ReadWordCount: u16,
    FinalCommandExtraPayload: u16,
    MipiErrors: u16,
    HostErrors: u16,
    Packets: [1]MIPI_DSI_PACKET,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIPI_DSI_RESET = extern struct {
    Flags: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const XSAVE_FORMAT = extern struct {
    ControlWord: u16,
    StatusWord: u16,
    TagWord: u8,
    Reserved1: u8,
    ErrorOpcode: u16,
    ErrorOffset: u32,
    ErrorSelector: u16,
    Reserved2: u16,
    DataOffset: u32,
    DataSelector: u16,
    Reserved3: u16,
    MxCsr: u32,
    MxCsr_Mask: u32,
    FloatRegisters: [8]M128A,
    XmmRegisters: [8]M128A,
    Reserved4: [224]u8,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const XSTATE_CONTEXT = extern struct {
    Mask: u64,
    Length: u32,
    Reserved1: u32,
    Area: *XSAVE_AREA,
    Reserved2: u32,
    Buffer: *c_void,
    Reserved3: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {
    Dummy: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const MEMORY_BASIC_INFORMATION = extern struct {
    BaseAddress: *c_void,
    AllocationBase: *c_void,
    AllocationProtect: u32,
    RegionSize: usize,
    State: u32,
    Protect: u32,
    Type: u32,
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const SLIST_HEADER = extern union {
    Alignment: u64,
    Anonymous: _Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const FARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const NEARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const PROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86 => struct {

pub const SLIST_ENTRY = extern struct {
    Next: *SLIST_ENTRY,
};

}, else => struct { } };

pub const PROCESSOR_NUMBER = extern struct {
    Group: u16,
    Number: u8,
    Reserved: u8,
};

pub const GROUP_AFFINITY = extern struct {
    Mask: usize,
    Group: u16,
    Reserved: [3]u16,
};

pub const POWERBROADCAST_SETTING = extern struct {
    PowerSetting: Guid,
    DataLength: u32,
    Data: [1]u8,
};

pub const AR_STATE = extern enum(i32) {
    ENABLED = 0,
    DISABLED = 1,
    SUPPRESSED = 2,
    REMOTESESSION = 4,
    MULTIMON = 8,
    NOSENSOR = 16,
    NOT_SUPPORTED = 32,
    DOCKED = 64,
    LAPTOP = 128,
};
pub const AR_ENABLED = AR_STATE.ENABLED;
pub const AR_DISABLED = AR_STATE.DISABLED;
pub const AR_SUPPRESSED = AR_STATE.SUPPRESSED;
pub const AR_REMOTESESSION = AR_STATE.REMOTESESSION;
pub const AR_MULTIMON = AR_STATE.MULTIMON;
pub const AR_NOSENSOR = AR_STATE.NOSENSOR;
pub const AR_NOT_SUPPORTED = AR_STATE.NOT_SUPPORTED;
pub const AR_DOCKED = AR_STATE.DOCKED;
pub const AR_LAPTOP = AR_STATE.LAPTOP;

pub const ORIENTATION_PREFERENCE = extern enum(i32) {
    NONE = 0,
    LANDSCAPE = 1,
    PORTRAIT = 2,
    LANDSCAPE_FLIPPED = 4,
    PORTRAIT_FLIPPED = 8,
};
pub const ORIENTATION_PREFERENCE_NONE = ORIENTATION_PREFERENCE.NONE;
pub const ORIENTATION_PREFERENCE_LANDSCAPE = ORIENTATION_PREFERENCE.LANDSCAPE;
pub const ORIENTATION_PREFERENCE_PORTRAIT = ORIENTATION_PREFERENCE.PORTRAIT;
pub const ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = ORIENTATION_PREFERENCE.LANDSCAPE_FLIPPED;
pub const ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = ORIENTATION_PREFERENCE.PORTRAIT_FLIPPED;

pub const PROCESS_INFORMATION = extern struct {
    hProcess: HANDLE,
    hThread: HANDLE,
    dwProcessId: u32,
    dwThreadId: u32,
};

pub const STARTUPINFOA = extern struct {
    cb: u32,
    lpReserved: PSTR,
    lpDesktop: PSTR,
    lpTitle: PSTR,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: STARTUPINFOW_FLAGS,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: *u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};

pub const STARTUPINFOW = extern struct {
    cb: u32,
    lpReserved: PWSTR,
    lpDesktop: PWSTR,
    lpTitle: PWSTR,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: STARTUPINFOW_FLAGS,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: *u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};

pub const MEMORY_PRIORITY_INFORMATION = extern struct {
    MemoryPriority: MEMORY_PRIORITY,
};

pub const THREAD_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};

pub const APP_MEMORY_INFORMATION = extern struct {
    AvailableCommit: u64,
    PrivateCommitUsage: u64,
    PeakPrivateCommitUsage: u64,
    TotalCommitUsage: u64,
};

pub const PROCESS_MEMORY_EXHAUSTION_TYPE = extern enum(i32) {
    FailFastOnCommitFailure = 0,
    Max = 1,
};
pub const PMETypeFailFastOnCommitFailure = PROCESS_MEMORY_EXHAUSTION_TYPE.FailFastOnCommitFailure;
pub const PMETypeMax = PROCESS_MEMORY_EXHAUSTION_TYPE.Max;

pub const PROCESS_MEMORY_EXHAUSTION_INFO = extern struct {
    Version: u16,
    Reserved: u16,
    Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
    Value: usize,
};

pub const PROCESS_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};

pub const PROCESS_PROTECTION_LEVEL_INFORMATION = extern struct {
    ProtectionLevel: PROCESS_PROTECTION_LEVEL,
};

pub const PROCESS_LEAP_SECOND_INFO = extern struct {
    Flags: u32,
    Reserved: u32,
};

pub const MEMORYSTATUSEX = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    ullTotalPhys: u64,
    ullAvailPhys: u64,
    ullTotalPageFile: u64,
    ullAvailPageFile: u64,
    ullTotalVirtual: u64,
    ullAvailVirtual: u64,
    ullAvailExtendedVirtual: u64,
};

pub const COMMPROP = extern struct {
    wPacketLength: u16,
    wPacketVersion: u16,
    dwServiceMask: u32,
    dwReserved1: u32,
    dwMaxTxQueue: u32,
    dwMaxRxQueue: u32,
    dwMaxBaud: u32,
    dwProvSubType: u32,
    dwProvCapabilities: u32,
    dwSettableParams: u32,
    dwSettableBaud: u32,
    wSettableData: u16,
    wSettableStopParity: COMMPROP_STOP_PARITY,
    dwCurrentTxQueue: u32,
    dwCurrentRxQueue: u32,
    dwProvSpec1: u32,
    dwProvSpec2: u32,
    wcProvChar: [1]u16,
};

pub const COMSTAT = extern struct {
    _bitfield: u32,
    cbInQue: u32,
    cbOutQue: u32,
};

pub const DCB = extern struct {
    DCBlength: u32,
    BaudRate: u32,
    _bitfield: u32,
    wReserved: u16,
    XonLim: u16,
    XoffLim: u16,
    ByteSize: u8,
    Parity: u8,
    StopBits: u8,
    XonChar: CHAR,
    XoffChar: CHAR,
    ErrorChar: CHAR,
    EofChar: CHAR,
    EvtChar: CHAR,
    wReserved1: u16,
};

pub const COMMTIMEOUTS = extern struct {
    ReadIntervalTimeout: u32,
    ReadTotalTimeoutMultiplier: u32,
    ReadTotalTimeoutConstant: u32,
    WriteTotalTimeoutMultiplier: u32,
    WriteTotalTimeoutConstant: u32,
};

pub const COMMCONFIG = extern struct {
    dwSize: u32,
    wVersion: u16,
    wReserved: u16,
    dcb: DCB,
    dwProviderSubType: u32,
    dwProviderOffset: u32,
    dwProviderSize: u32,
    wcProviderData: [1]u16,
};

pub const MEMORYSTATUS = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    dwTotalPhys: usize,
    dwAvailPhys: usize,
    dwTotalPageFile: usize,
    dwAvailPageFile: usize,
    dwTotalVirtual: usize,
    dwAvailVirtual: usize,
};

pub const UMS_SCHEDULER_STARTUP_INFO = extern struct {
    UmsVersion: u32,
    CompletionList: *c_void,
    SchedulerProc: PRTL_UMS_SCHEDULER_ENTRY_POINT,
    SchedulerParam: *c_void,
};

pub const UMS_SYSTEM_THREAD_INFORMATION = extern struct {
    UmsVersion: u32,
    Anonymous: _Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WIN32_STREAM_ID = extern struct {
    dwStreamId: WIN_STREAM_ID,
    dwStreamAttributes: u32,
    Size: LARGE_INTEGER,
    dwStreamNameSize: u32,
    cStreamName: [1]u16,
};

pub const STARTUPINFOEXA = extern struct {
    StartupInfo: STARTUPINFOA,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
};

pub const STARTUPINFOEXW = extern struct {
    StartupInfo: STARTUPINFOW,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
};

pub const EVENTLOG_FULL_INFORMATION = extern struct {
    dwFull: u32,
};

pub const SYSTEM_POWER_STATUS = extern struct {
    ACLineStatus: u8,
    BatteryFlag: u8,
    BatteryLifePercent: u8,
    SystemStatusFlag: u8,
    BatteryLifeTime: u32,
    BatteryFullLifeTime: u32,
};

pub const PEB_LDR_DATA = extern struct {
    Reserved1: [8]u8,
    Reserved2: [3]*c_void,
    InMemoryOrderModuleList: LIST_ENTRY,
};

pub const RTL_USER_PROCESS_PARAMETERS = extern struct {
    Reserved1: [16]u8,
    Reserved2: [10]*c_void,
    ImagePathName: UNICODE_STRING,
    CommandLine: UNICODE_STRING,
};

pub const PEB = extern struct {
    Reserved1: [2]u8,
    BeingDebugged: u8,
    Reserved2: [1]u8,
    Reserved3: [2]*c_void,
    Ldr: *PEB_LDR_DATA,
    ProcessParameters: *RTL_USER_PROCESS_PARAMETERS,
    Reserved4: [3]*c_void,
    AtlThunkSListPtr: *c_void,
    Reserved5: *c_void,
    Reserved6: u32,
    Reserved7: *c_void,
    Reserved8: u32,
    AtlThunkSListPtr32: u32,
    Reserved9: [45]*c_void,
    Reserved10: [96]u8,
    PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    Reserved11: [128]u8,
    Reserved12: [1]*c_void,
    SessionId: u32,
};

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const THREAD_CREATION_FLAGS = extern enum(u32) {
    CREATE_RUN_IMMEDIATELY = 0,
    CREATE_SUSPENDED = 4,
    STACK_SIZE_PARAM_IS_A_RESERVATION = 65536,
    _,
};
pub const CREATE_RUN_IMMEDIATELY = THREAD_CREATION_FLAGS.CREATE_RUN_IMMEDIATELY;
pub const CREATE_SUSPENDED = THREAD_CREATION_FLAGS.CREATE_SUSPENDED;
pub const STACK_SIZE_PARAM_IS_A_RESERVATION = THREAD_CREATION_FLAGS.STACK_SIZE_PARAM_IS_A_RESERVATION;

pub const ALERT_SYSTEM_SEV = extern enum(u32) {
    INFORMATIONAL = 1,
    WARNING = 2,
    ERROR = 3,
    QUERY = 4,
    CRITICAL = 5,
};
pub const ALERT_SYSTEM_INFORMATIONAL = ALERT_SYSTEM_SEV.INFORMATIONAL;
pub const ALERT_SYSTEM_WARNING = ALERT_SYSTEM_SEV.WARNING;
pub const ALERT_SYSTEM_ERROR = ALERT_SYSTEM_SEV.ERROR;
pub const ALERT_SYSTEM_QUERY = ALERT_SYSTEM_SEV.QUERY;
pub const ALERT_SYSTEM_CRITICAL = ALERT_SYSTEM_SEV.CRITICAL;

pub const APPCOMMAND_ID = extern enum(u32) {
    BROWSER_BACKWARD = 1,
    BROWSER_FORWARD = 2,
    BROWSER_REFRESH = 3,
    BROWSER_STOP = 4,
    BROWSER_SEARCH = 5,
    BROWSER_FAVORITES = 6,
    BROWSER_HOME = 7,
    VOLUME_MUTE = 8,
    VOLUME_DOWN = 9,
    VOLUME_UP = 10,
    MEDIA_NEXTTRACK = 11,
    MEDIA_PREVIOUSTRACK = 12,
    MEDIA_STOP = 13,
    MEDIA_PLAY_PAUSE = 14,
    LAUNCH_MAIL = 15,
    LAUNCH_MEDIA_SELECT = 16,
    LAUNCH_APP1 = 17,
    LAUNCH_APP2 = 18,
    BASS_DOWN = 19,
    BASS_BOOST = 20,
    BASS_UP = 21,
    TREBLE_DOWN = 22,
    TREBLE_UP = 23,
    MICROPHONE_VOLUME_MUTE = 24,
    MICROPHONE_VOLUME_DOWN = 25,
    MICROPHONE_VOLUME_UP = 26,
    HELP = 27,
    FIND = 28,
    NEW = 29,
    OPEN = 30,
    CLOSE = 31,
    SAVE = 32,
    PRINT = 33,
    UNDO = 34,
    REDO = 35,
    COPY = 36,
    CUT = 37,
    PASTE = 38,
    REPLY_TO_MAIL = 39,
    FORWARD_MAIL = 40,
    SEND_MAIL = 41,
    SPELL_CHECK = 42,
    DICTATE_OR_COMMAND_CONTROL_TOGGLE = 43,
    MIC_ON_OFF_TOGGLE = 44,
    CORRECTION_LIST = 45,
    MEDIA_PLAY = 46,
    MEDIA_PAUSE = 47,
    MEDIA_RECORD = 48,
    MEDIA_FAST_FORWARD = 49,
    MEDIA_REWIND = 50,
    MEDIA_CHANNEL_UP = 51,
    MEDIA_CHANNEL_DOWN = 52,
    DELETE = 53,
    DWM_FLIP3D = 54,
};
pub const APPCOMMAND_BROWSER_BACKWARD = APPCOMMAND_ID.BROWSER_BACKWARD;
pub const APPCOMMAND_BROWSER_FORWARD = APPCOMMAND_ID.BROWSER_FORWARD;
pub const APPCOMMAND_BROWSER_REFRESH = APPCOMMAND_ID.BROWSER_REFRESH;
pub const APPCOMMAND_BROWSER_STOP = APPCOMMAND_ID.BROWSER_STOP;
pub const APPCOMMAND_BROWSER_SEARCH = APPCOMMAND_ID.BROWSER_SEARCH;
pub const APPCOMMAND_BROWSER_FAVORITES = APPCOMMAND_ID.BROWSER_FAVORITES;
pub const APPCOMMAND_BROWSER_HOME = APPCOMMAND_ID.BROWSER_HOME;
pub const APPCOMMAND_VOLUME_MUTE = APPCOMMAND_ID.VOLUME_MUTE;
pub const APPCOMMAND_VOLUME_DOWN = APPCOMMAND_ID.VOLUME_DOWN;
pub const APPCOMMAND_VOLUME_UP = APPCOMMAND_ID.VOLUME_UP;
pub const APPCOMMAND_MEDIA_NEXTTRACK = APPCOMMAND_ID.MEDIA_NEXTTRACK;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK = APPCOMMAND_ID.MEDIA_PREVIOUSTRACK;
pub const APPCOMMAND_MEDIA_STOP = APPCOMMAND_ID.MEDIA_STOP;
pub const APPCOMMAND_MEDIA_PLAY_PAUSE = APPCOMMAND_ID.MEDIA_PLAY_PAUSE;
pub const APPCOMMAND_LAUNCH_MAIL = APPCOMMAND_ID.LAUNCH_MAIL;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT = APPCOMMAND_ID.LAUNCH_MEDIA_SELECT;
pub const APPCOMMAND_LAUNCH_APP1 = APPCOMMAND_ID.LAUNCH_APP1;
pub const APPCOMMAND_LAUNCH_APP2 = APPCOMMAND_ID.LAUNCH_APP2;
pub const APPCOMMAND_BASS_DOWN = APPCOMMAND_ID.BASS_DOWN;
pub const APPCOMMAND_BASS_BOOST = APPCOMMAND_ID.BASS_BOOST;
pub const APPCOMMAND_BASS_UP = APPCOMMAND_ID.BASS_UP;
pub const APPCOMMAND_TREBLE_DOWN = APPCOMMAND_ID.TREBLE_DOWN;
pub const APPCOMMAND_TREBLE_UP = APPCOMMAND_ID.TREBLE_UP;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE = APPCOMMAND_ID.MICROPHONE_VOLUME_MUTE;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN = APPCOMMAND_ID.MICROPHONE_VOLUME_DOWN;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP = APPCOMMAND_ID.MICROPHONE_VOLUME_UP;
pub const APPCOMMAND_HELP = APPCOMMAND_ID.HELP;
pub const APPCOMMAND_FIND = APPCOMMAND_ID.FIND;
pub const APPCOMMAND_NEW = APPCOMMAND_ID.NEW;
pub const APPCOMMAND_OPEN = APPCOMMAND_ID.OPEN;
pub const APPCOMMAND_CLOSE = APPCOMMAND_ID.CLOSE;
pub const APPCOMMAND_SAVE = APPCOMMAND_ID.SAVE;
pub const APPCOMMAND_PRINT = APPCOMMAND_ID.PRINT;
pub const APPCOMMAND_UNDO = APPCOMMAND_ID.UNDO;
pub const APPCOMMAND_REDO = APPCOMMAND_ID.REDO;
pub const APPCOMMAND_COPY = APPCOMMAND_ID.COPY;
pub const APPCOMMAND_CUT = APPCOMMAND_ID.CUT;
pub const APPCOMMAND_PASTE = APPCOMMAND_ID.PASTE;
pub const APPCOMMAND_REPLY_TO_MAIL = APPCOMMAND_ID.REPLY_TO_MAIL;
pub const APPCOMMAND_FORWARD_MAIL = APPCOMMAND_ID.FORWARD_MAIL;
pub const APPCOMMAND_SEND_MAIL = APPCOMMAND_ID.SEND_MAIL;
pub const APPCOMMAND_SPELL_CHECK = APPCOMMAND_ID.SPELL_CHECK;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE = APPCOMMAND_ID.DICTATE_OR_COMMAND_CONTROL_TOGGLE;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE = APPCOMMAND_ID.MIC_ON_OFF_TOGGLE;
pub const APPCOMMAND_CORRECTION_LIST = APPCOMMAND_ID.CORRECTION_LIST;
pub const APPCOMMAND_MEDIA_PLAY = APPCOMMAND_ID.MEDIA_PLAY;
pub const APPCOMMAND_MEDIA_PAUSE = APPCOMMAND_ID.MEDIA_PAUSE;
pub const APPCOMMAND_MEDIA_RECORD = APPCOMMAND_ID.MEDIA_RECORD;
pub const APPCOMMAND_MEDIA_FAST_FORWARD = APPCOMMAND_ID.MEDIA_FAST_FORWARD;
pub const APPCOMMAND_MEDIA_REWIND = APPCOMMAND_ID.MEDIA_REWIND;
pub const APPCOMMAND_MEDIA_CHANNEL_UP = APPCOMMAND_ID.MEDIA_CHANNEL_UP;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN = APPCOMMAND_ID.MEDIA_CHANNEL_DOWN;
pub const APPCOMMAND_DELETE = APPCOMMAND_ID.DELETE;
pub const APPCOMMAND_DWM_FLIP3D = APPCOMMAND_ID.DWM_FLIP3D;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ATF_FLAGS = extern enum(u32) {
    TIMEOUTON = 1,
    ONOFFFEEDBACK = 2,
    _,
};
pub const ATF_TIMEOUTON = ATF_FLAGS.TIMEOUTON;
pub const ATF_ONOFFFEEDBACK = ATF_FLAGS.ONOFFFEEDBACK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const BUTTON_STYLE = extern enum(u32) {
    PUSHBUTTON = 0,
    DEFPUSHBUTTON = 1,
    CHECKBOX = 2,
    AUTOCHECKBOX = 3,
    RADIOBUTTON = 4,
    @"3STATE" = 5,
    AUTO3STATE = 6,
    GROUPBOX = 7,
    USERBUTTON = 8,
    AUTORADIOBUTTON = 9,
    PUSHBOX = 10,
    OWNERDRAW = 11,
    TYPEMASK = 15,
    LEFTTEXT = 32,
    TEXT = 0,
    ICON = 64,
    BITMAP = 128,
    LEFT = 256,
    RIGHT = 512,
    CENTER = 768,
    TOP = 1024,
    BOTTOM = 2048,
    VCENTER = 3072,
    PUSHLIKE = 4096,
    MULTILINE = 8192,
    NOTIFY = 16384,
    FLAT = 32768,
    RIGHTBUTTON = 32,
    _,
};
pub const BS_PUSHBUTTON = BUTTON_STYLE.PUSHBUTTON;
pub const BS_DEFPUSHBUTTON = BUTTON_STYLE.DEFPUSHBUTTON;
pub const BS_CHECKBOX = BUTTON_STYLE.CHECKBOX;
pub const BS_AUTOCHECKBOX = BUTTON_STYLE.AUTOCHECKBOX;
pub const BS_RADIOBUTTON = BUTTON_STYLE.RADIOBUTTON;
pub const BS_3STATE = BUTTON_STYLE.@"3STATE";
pub const BS_AUTO3STATE = BUTTON_STYLE.AUTO3STATE;
pub const BS_GROUPBOX = BUTTON_STYLE.GROUPBOX;
pub const BS_USERBUTTON = BUTTON_STYLE.USERBUTTON;
pub const BS_AUTORADIOBUTTON = BUTTON_STYLE.AUTORADIOBUTTON;
pub const BS_PUSHBOX = BUTTON_STYLE.PUSHBOX;
pub const BS_OWNERDRAW = BUTTON_STYLE.OWNERDRAW;
pub const BS_TYPEMASK = BUTTON_STYLE.TYPEMASK;
pub const BS_LEFTTEXT = BUTTON_STYLE.LEFTTEXT;
pub const BS_TEXT = BUTTON_STYLE.TEXT;
pub const BS_ICON = BUTTON_STYLE.ICON;
pub const BS_BITMAP = BUTTON_STYLE.BITMAP;
pub const BS_LEFT = BUTTON_STYLE.LEFT;
pub const BS_RIGHT = BUTTON_STYLE.RIGHT;
pub const BS_CENTER = BUTTON_STYLE.CENTER;
pub const BS_TOP = BUTTON_STYLE.TOP;
pub const BS_BOTTOM = BUTTON_STYLE.BOTTOM;
pub const BS_VCENTER = BUTTON_STYLE.VCENTER;
pub const BS_PUSHLIKE = BUTTON_STYLE.PUSHLIKE;
pub const BS_MULTILINE = BUTTON_STYLE.MULTILINE;
pub const BS_NOTIFY = BUTTON_STYLE.NOTIFY;
pub const BS_FLAT = BUTTON_STYLE.FLAT;
pub const BS_RIGHTBUTTON = BUTTON_STYLE.RIGHTBUTTON;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const COMBOBOX_STYLE = extern enum(u32) {
    SIMPLE = 1,
    DROPDOWN = 2,
    DROPDOWNLIST = 3,
    OWNERDRAWFIXED = 16,
    OWNERDRAWVARIABLE = 32,
    AUTOHSCROLL = 64,
    OEMCONVERT = 128,
    SORT = 256,
    HASSTRINGS = 512,
    NOINTEGRALHEIGHT = 1024,
    DISABLENOSCROLL = 2048,
    UPPERCASE = 8192,
    LOWERCASE = 16384,
    _,
};
pub const CBS_SIMPLE = COMBOBOX_STYLE.SIMPLE;
pub const CBS_DROPDOWN = COMBOBOX_STYLE.DROPDOWN;
pub const CBS_DROPDOWNLIST = COMBOBOX_STYLE.DROPDOWNLIST;
pub const CBS_OWNERDRAWFIXED = COMBOBOX_STYLE.OWNERDRAWFIXED;
pub const CBS_OWNERDRAWVARIABLE = COMBOBOX_STYLE.OWNERDRAWVARIABLE;
pub const CBS_AUTOHSCROLL = COMBOBOX_STYLE.AUTOHSCROLL;
pub const CBS_OEMCONVERT = COMBOBOX_STYLE.OEMCONVERT;
pub const CBS_SORT = COMBOBOX_STYLE.SORT;
pub const CBS_HASSTRINGS = COMBOBOX_STYLE.HASSTRINGS;
pub const CBS_NOINTEGRALHEIGHT = COMBOBOX_STYLE.NOINTEGRALHEIGHT;
pub const CBS_DISABLENOSCROLL = COMBOBOX_STYLE.DISABLENOSCROLL;
pub const CBS_UPPERCASE = COMBOBOX_STYLE.UPPERCASE;
pub const CBS_LOWERCASE = COMBOBOX_STYLE.LOWERCASE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CHOOSECOLOR_FLAGS = extern enum(u32) {
    RGBINIT = 1,
    FULLOPEN = 2,
    PREVENTFULLOPEN = 4,
    SHOWHELP = 8,
    ENABLEHOOK = 16,
    ENABLETEMPLATE = 32,
    ENABLETEMPLATEHANDLE = 64,
    SOLIDCOLOR = 128,
    ANYCOLOR = 256,
    _,
};
pub const CC_RGBINIT = CHOOSECOLOR_FLAGS.RGBINIT;
pub const CC_FULLOPEN = CHOOSECOLOR_FLAGS.FULLOPEN;
pub const CC_PREVENTFULLOPEN = CHOOSECOLOR_FLAGS.PREVENTFULLOPEN;
pub const CC_SHOWHELP = CHOOSECOLOR_FLAGS.SHOWHELP;
pub const CC_ENABLEHOOK = CHOOSECOLOR_FLAGS.ENABLEHOOK;
pub const CC_ENABLETEMPLATE = CHOOSECOLOR_FLAGS.ENABLETEMPLATE;
pub const CC_ENABLETEMPLATEHANDLE = CHOOSECOLOR_FLAGS.ENABLETEMPLATEHANDLE;
pub const CC_SOLIDCOLOR = CHOOSECOLOR_FLAGS.SOLIDCOLOR;
pub const CC_ANYCOLOR = CHOOSECOLOR_FLAGS.ANYCOLOR;

pub const CLIPBOARD_FORMATS = extern enum(u32) {
    TEXT = 1,
    BITMAP = 2,
    METAFILEPICT = 3,
    SYLK = 4,
    DIF = 5,
    TIFF = 6,
    OEMTEXT = 7,
    DIB = 8,
    PALETTE = 9,
    PENDATA = 10,
    RIFF = 11,
    WAVE = 12,
    UNICODETEXT = 13,
    ENHMETAFILE = 14,
    HDROP = 15,
    LOCALE = 16,
    DIBV5 = 17,
    MAX = 18,
    OWNERDISPLAY = 128,
    DSPTEXT = 129,
    DSPBITMAP = 130,
    DSPMETAFILEPICT = 131,
    DSPENHMETAFILE = 142,
    PRIVATEFIRST = 512,
    PRIVATELAST = 767,
    GDIOBJFIRST = 768,
    GDIOBJLAST = 1023,
};
pub const CF_TEXT = CLIPBOARD_FORMATS.TEXT;
pub const CF_BITMAP = CLIPBOARD_FORMATS.BITMAP;
pub const CF_METAFILEPICT = CLIPBOARD_FORMATS.METAFILEPICT;
pub const CF_SYLK = CLIPBOARD_FORMATS.SYLK;
pub const CF_DIF = CLIPBOARD_FORMATS.DIF;
pub const CF_TIFF = CLIPBOARD_FORMATS.TIFF;
pub const CF_OEMTEXT = CLIPBOARD_FORMATS.OEMTEXT;
pub const CF_DIB = CLIPBOARD_FORMATS.DIB;
pub const CF_PALETTE = CLIPBOARD_FORMATS.PALETTE;
pub const CF_PENDATA = CLIPBOARD_FORMATS.PENDATA;
pub const CF_RIFF = CLIPBOARD_FORMATS.RIFF;
pub const CF_WAVE = CLIPBOARD_FORMATS.WAVE;
pub const CF_UNICODETEXT = CLIPBOARD_FORMATS.UNICODETEXT;
pub const CF_ENHMETAFILE = CLIPBOARD_FORMATS.ENHMETAFILE;
pub const CF_HDROP = CLIPBOARD_FORMATS.HDROP;
pub const CF_LOCALE = CLIPBOARD_FORMATS.LOCALE;
pub const CF_DIBV5 = CLIPBOARD_FORMATS.DIBV5;
pub const CF_MAX = CLIPBOARD_FORMATS.MAX;
pub const CF_OWNERDISPLAY = CLIPBOARD_FORMATS.OWNERDISPLAY;
pub const CF_DSPTEXT = CLIPBOARD_FORMATS.DSPTEXT;
pub const CF_DSPBITMAP = CLIPBOARD_FORMATS.DSPBITMAP;
pub const CF_DSPMETAFILEPICT = CLIPBOARD_FORMATS.DSPMETAFILEPICT;
pub const CF_DSPENHMETAFILE = CLIPBOARD_FORMATS.DSPENHMETAFILE;
pub const CF_PRIVATEFIRST = CLIPBOARD_FORMATS.PRIVATEFIRST;
pub const CF_PRIVATELAST = CLIPBOARD_FORMATS.PRIVATELAST;
pub const CF_GDIOBJFIRST = CLIPBOARD_FORMATS.GDIOBJFIRST;
pub const CF_GDIOBJLAST = CLIPBOARD_FORMATS.GDIOBJLAST;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const DIALOGBOX_STYLE = extern enum(u32) {
    ABSALIGN = 1,
    SYSMODAL = 2,
    LOCALEDIT = 32,
    SETFONT = 64,
    MODALFRAME = 128,
    NOIDLEMSG = 256,
    SETFOREGROUND = 512,
    @"3DLOOK" = 4,
    FIXEDSYS = 8,
    NOFAILCREATE = 16,
    CONTROL = 1024,
    CENTER = 2048,
    CENTERMOUSE = 4096,
    CONTEXTHELP = 8192,
    SHELLFONT = 72,
    USEPIXELS = 32768,
    _,
};
pub const DS_ABSALIGN = DIALOGBOX_STYLE.ABSALIGN;
pub const DS_SYSMODAL = DIALOGBOX_STYLE.SYSMODAL;
pub const DS_LOCALEDIT = DIALOGBOX_STYLE.LOCALEDIT;
pub const DS_SETFONT = DIALOGBOX_STYLE.SETFONT;
pub const DS_MODALFRAME = DIALOGBOX_STYLE.MODALFRAME;
pub const DS_NOIDLEMSG = DIALOGBOX_STYLE.NOIDLEMSG;
pub const DS_SETFOREGROUND = DIALOGBOX_STYLE.SETFOREGROUND;
pub const DS_3DLOOK = DIALOGBOX_STYLE.@"3DLOOK";
pub const DS_FIXEDSYS = DIALOGBOX_STYLE.FIXEDSYS;
pub const DS_NOFAILCREATE = DIALOGBOX_STYLE.NOFAILCREATE;
pub const DS_CONTROL = DIALOGBOX_STYLE.CONTROL;
pub const DS_CENTER = DIALOGBOX_STYLE.CENTER;
pub const DS_CENTERMOUSE = DIALOGBOX_STYLE.CENTERMOUSE;
pub const DS_CONTEXTHELP = DIALOGBOX_STYLE.CONTEXTHELP;
pub const DS_SHELLFONT = DIALOGBOX_STYLE.SHELLFONT;
pub const DS_USEPIXELS = DIALOGBOX_STYLE.USEPIXELS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const EDITCONTROL_STYLE = extern enum(u32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
    MULTILINE = 4,
    UPPERCASE = 8,
    LOWERCASE = 16,
    PASSWORD = 32,
    AUTOVSCROLL = 64,
    AUTOHSCROLL = 128,
    NOHIDESEL = 256,
    OEMCONVERT = 1024,
    READONLY = 2048,
    WANTRETURN = 4096,
    NUMBER = 8192,
    _,
};
pub const ES_LEFT = EDITCONTROL_STYLE.LEFT;
pub const ES_CENTER = EDITCONTROL_STYLE.CENTER;
pub const ES_RIGHT = EDITCONTROL_STYLE.RIGHT;
pub const ES_MULTILINE = EDITCONTROL_STYLE.MULTILINE;
pub const ES_UPPERCASE = EDITCONTROL_STYLE.UPPERCASE;
pub const ES_LOWERCASE = EDITCONTROL_STYLE.LOWERCASE;
pub const ES_PASSWORD = EDITCONTROL_STYLE.PASSWORD;
pub const ES_AUTOVSCROLL = EDITCONTROL_STYLE.AUTOVSCROLL;
pub const ES_AUTOHSCROLL = EDITCONTROL_STYLE.AUTOHSCROLL;
pub const ES_NOHIDESEL = EDITCONTROL_STYLE.NOHIDESEL;
pub const ES_OEMCONVERT = EDITCONTROL_STYLE.OEMCONVERT;
pub const ES_READONLY = EDITCONTROL_STYLE.READONLY;
pub const ES_WANTRETURN = EDITCONTROL_STYLE.WANTRETURN;
pub const ES_NUMBER = EDITCONTROL_STYLE.NUMBER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GESTURECONFIG_FLAGS = extern enum(u32) {
    ALLGESTURES = 1,
    ZOOM = 1,
    PAN = 1,
    PAN_WITH_SINGLE_FINGER_VERTICALLY = 2,
    PAN_WITH_SINGLE_FINGER_HORIZONTALLY = 4,
    PAN_WITH_GUTTER = 8,
    PAN_WITH_INERTIA = 16,
    ROTATE = 1,
    TWOFINGERTAP = 1,
    PRESSANDTAP = 1,
    ROLLOVER = 1,
    _,
};
pub const GC_ALLGESTURES = GESTURECONFIG_FLAGS.ALLGESTURES;
pub const GC_ZOOM = GESTURECONFIG_FLAGS.ZOOM;
pub const GC_PAN = GESTURECONFIG_FLAGS.PAN;
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY = GESTURECONFIG_FLAGS.PAN_WITH_SINGLE_FINGER_VERTICALLY;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY = GESTURECONFIG_FLAGS.PAN_WITH_SINGLE_FINGER_HORIZONTALLY;
pub const GC_PAN_WITH_GUTTER = GESTURECONFIG_FLAGS.PAN_WITH_GUTTER;
pub const GC_PAN_WITH_INERTIA = GESTURECONFIG_FLAGS.PAN_WITH_INERTIA;
pub const GC_ROTATE = GESTURECONFIG_FLAGS.ROTATE;
pub const GC_TWOFINGERTAP = GESTURECONFIG_FLAGS.TWOFINGERTAP;
pub const GC_PRESSANDTAP = GESTURECONFIG_FLAGS.PRESSANDTAP;
pub const GC_ROLLOVER = GESTURECONFIG_FLAGS.ROLLOVER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LISTBOX_STYLE = extern enum(u32) {
    STANDARD = 10485763,
    NOTIFY = 1,
    SORT = 2,
    NOREDRAW = 4,
    MULTIPLESEL = 8,
    OWNERDRAWFIXED = 16,
    OWNERDRAWVARIABLE = 32,
    HASSTRINGS = 64,
    USETABSTOPS = 128,
    NOINTEGRALHEIGHT = 256,
    MULTICOLUMN = 512,
    WANTKEYBOARDINPUT = 1024,
    EXTENDEDSEL = 2048,
    DISABLENOSCROLL = 4096,
    NODATA = 8192,
    NOSEL = 16384,
    COMBOBOX = 32768,
    _,
};
pub const LBS_STANDARD = LISTBOX_STYLE.STANDARD;
pub const LBS_NOTIFY = LISTBOX_STYLE.NOTIFY;
pub const LBS_SORT = LISTBOX_STYLE.SORT;
pub const LBS_NOREDRAW = LISTBOX_STYLE.NOREDRAW;
pub const LBS_MULTIPLESEL = LISTBOX_STYLE.MULTIPLESEL;
pub const LBS_OWNERDRAWFIXED = LISTBOX_STYLE.OWNERDRAWFIXED;
pub const LBS_OWNERDRAWVARIABLE = LISTBOX_STYLE.OWNERDRAWVARIABLE;
pub const LBS_HASSTRINGS = LISTBOX_STYLE.HASSTRINGS;
pub const LBS_USETABSTOPS = LISTBOX_STYLE.USETABSTOPS;
pub const LBS_NOINTEGRALHEIGHT = LISTBOX_STYLE.NOINTEGRALHEIGHT;
pub const LBS_MULTICOLUMN = LISTBOX_STYLE.MULTICOLUMN;
pub const LBS_WANTKEYBOARDINPUT = LISTBOX_STYLE.WANTKEYBOARDINPUT;
pub const LBS_EXTENDEDSEL = LISTBOX_STYLE.EXTENDEDSEL;
pub const LBS_DISABLENOSCROLL = LISTBOX_STYLE.DISABLENOSCROLL;
pub const LBS_NODATA = LISTBOX_STYLE.NODATA;
pub const LBS_NOSEL = LISTBOX_STYLE.NOSEL;
pub const LBS_COMBOBOX = LISTBOX_STYLE.COMBOBOX;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SCROLLBAR_STYLE = extern enum(u32) {
    HORZ = 0,
    VERT = 1,
    TOPALIGN = 2,
    LEFTALIGN = 2,
    BOTTOMALIGN = 4,
    RIGHTALIGN = 4,
    SIZEBOXTOPLEFTALIGN = 2,
    SIZEBOXBOTTOMRIGHTALIGN = 4,
    SIZEBOX = 8,
    SIZEGRIP = 16,
    _,
};
pub const SBS_HORZ = SCROLLBAR_STYLE.HORZ;
pub const SBS_VERT = SCROLLBAR_STYLE.VERT;
pub const SBS_TOPALIGN = SCROLLBAR_STYLE.TOPALIGN;
pub const SBS_LEFTALIGN = SCROLLBAR_STYLE.LEFTALIGN;
pub const SBS_BOTTOMALIGN = SCROLLBAR_STYLE.BOTTOMALIGN;
pub const SBS_RIGHTALIGN = SCROLLBAR_STYLE.RIGHTALIGN;
pub const SBS_SIZEBOXTOPLEFTALIGN = SCROLLBAR_STYLE.SIZEBOXTOPLEFTALIGN;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN = SCROLLBAR_STYLE.SIZEBOXBOTTOMRIGHTALIGN;
pub const SBS_SIZEBOX = SCROLLBAR_STYLE.SIZEBOX;
pub const SBS_SIZEGRIP = SCROLLBAR_STYLE.SIZEGRIP;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const STATIC_CONTROL_STYLE = extern enum(u32) {
    LEFT = 0,
    CENTER = 1,
    RIGHT = 2,
    ICON = 3,
    BLACKRECT = 4,
    GRAYRECT = 5,
    WHITERECT = 6,
    BLACKFRAME = 7,
    GRAYFRAME = 8,
    WHITEFRAME = 9,
    USERITEM = 10,
    SIMPLE = 11,
    LEFTNOWORDWRAP = 12,
    OWNERDRAW = 13,
    BITMAP = 14,
    ENHMETAFILE = 15,
    ETCHEDHORZ = 16,
    ETCHEDVERT = 17,
    ETCHEDFRAME = 18,
    TYPEMASK = 31,
    REALSIZECONTROL = 64,
    NOPREFIX = 128,
    NOTIFY = 256,
    CENTERIMAGE = 512,
    RIGHTJUST = 1024,
    REALSIZEIMAGE = 2048,
    SUNKEN = 4096,
    EDITCONTROL = 8192,
    ENDELLIPSIS = 16384,
    PATHELLIPSIS = 32768,
    WORDELLIPSIS = 49152,
    ELLIPSISMASK = 49152,
    _,
};
pub const SS_LEFT = STATIC_CONTROL_STYLE.LEFT;
pub const SS_CENTER = STATIC_CONTROL_STYLE.CENTER;
pub const SS_RIGHT = STATIC_CONTROL_STYLE.RIGHT;
pub const SS_ICON = STATIC_CONTROL_STYLE.ICON;
pub const SS_BLACKRECT = STATIC_CONTROL_STYLE.BLACKRECT;
pub const SS_GRAYRECT = STATIC_CONTROL_STYLE.GRAYRECT;
pub const SS_WHITERECT = STATIC_CONTROL_STYLE.WHITERECT;
pub const SS_BLACKFRAME = STATIC_CONTROL_STYLE.BLACKFRAME;
pub const SS_GRAYFRAME = STATIC_CONTROL_STYLE.GRAYFRAME;
pub const SS_WHITEFRAME = STATIC_CONTROL_STYLE.WHITEFRAME;
pub const SS_USERITEM = STATIC_CONTROL_STYLE.USERITEM;
pub const SS_SIMPLE = STATIC_CONTROL_STYLE.SIMPLE;
pub const SS_LEFTNOWORDWRAP = STATIC_CONTROL_STYLE.LEFTNOWORDWRAP;
pub const SS_OWNERDRAW = STATIC_CONTROL_STYLE.OWNERDRAW;
pub const SS_BITMAP = STATIC_CONTROL_STYLE.BITMAP;
pub const SS_ENHMETAFILE = STATIC_CONTROL_STYLE.ENHMETAFILE;
pub const SS_ETCHEDHORZ = STATIC_CONTROL_STYLE.ETCHEDHORZ;
pub const SS_ETCHEDVERT = STATIC_CONTROL_STYLE.ETCHEDVERT;
pub const SS_ETCHEDFRAME = STATIC_CONTROL_STYLE.ETCHEDFRAME;
pub const SS_TYPEMASK = STATIC_CONTROL_STYLE.TYPEMASK;
pub const SS_REALSIZECONTROL = STATIC_CONTROL_STYLE.REALSIZECONTROL;
pub const SS_NOPREFIX = STATIC_CONTROL_STYLE.NOPREFIX;
pub const SS_NOTIFY = STATIC_CONTROL_STYLE.NOTIFY;
pub const SS_CENTERIMAGE = STATIC_CONTROL_STYLE.CENTERIMAGE;
pub const SS_RIGHTJUST = STATIC_CONTROL_STYLE.RIGHTJUST;
pub const SS_REALSIZEIMAGE = STATIC_CONTROL_STYLE.REALSIZEIMAGE;
pub const SS_SUNKEN = STATIC_CONTROL_STYLE.SUNKEN;
pub const SS_EDITCONTROL = STATIC_CONTROL_STYLE.EDITCONTROL;
pub const SS_ENDELLIPSIS = STATIC_CONTROL_STYLE.ENDELLIPSIS;
pub const SS_PATHELLIPSIS = STATIC_CONTROL_STYLE.PATHELLIPSIS;
pub const SS_WORDELLIPSIS = STATIC_CONTROL_STYLE.WORDELLIPSIS;
pub const SS_ELLIPSISMASK = STATIC_CONTROL_STYLE.ELLIPSISMASK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CFE_UNDERLINE = extern enum(u32) {
    CF1UNDERLINE = 255,
    INVERT = 254,
    UNDERLINETHICKLONGDASH = 18,
    UNDERLINETHICKDOTTED = 17,
    UNDERLINETHICKDASHDOTDOT = 16,
    UNDERLINETHICKDASHDOT = 15,
    UNDERLINETHICKDASH = 14,
    UNDERLINELONGDASH = 13,
    UNDERLINEHEAVYWAVE = 12,
    UNDERLINEDOUBLEWAVE = 11,
    UNDERLINEHAIRLINE = 10,
    UNDERLINETHICK = 9,
    UNDERLINEWAVE = 8,
    UNDERLINEDASHDOTDOT = 7,
    UNDERLINEDASHDOT = 6,
    UNDERLINEDASH = 5,
    UNDERLINEDOTTED = 4,
    UNDERLINEDOUBLE = 3,
    UNDERLINEWORD = 2,
    UNDERLINE = 1,
    UNDERLINENONE = 0,
    _,
};
pub const CFU_CF1UNDERLINE = CFE_UNDERLINE.CF1UNDERLINE;
pub const CFU_INVERT = CFE_UNDERLINE.INVERT;
pub const CFU_UNDERLINETHICKLONGDASH = CFE_UNDERLINE.UNDERLINETHICKLONGDASH;
pub const CFU_UNDERLINETHICKDOTTED = CFE_UNDERLINE.UNDERLINETHICKDOTTED;
pub const CFU_UNDERLINETHICKDASHDOTDOT = CFE_UNDERLINE.UNDERLINETHICKDASHDOTDOT;
pub const CFU_UNDERLINETHICKDASHDOT = CFE_UNDERLINE.UNDERLINETHICKDASHDOT;
pub const CFU_UNDERLINETHICKDASH = CFE_UNDERLINE.UNDERLINETHICKDASH;
pub const CFU_UNDERLINELONGDASH = CFE_UNDERLINE.UNDERLINELONGDASH;
pub const CFU_UNDERLINEHEAVYWAVE = CFE_UNDERLINE.UNDERLINEHEAVYWAVE;
pub const CFU_UNDERLINEDOUBLEWAVE = CFE_UNDERLINE.UNDERLINEDOUBLEWAVE;
pub const CFU_UNDERLINEHAIRLINE = CFE_UNDERLINE.UNDERLINEHAIRLINE;
pub const CFU_UNDERLINETHICK = CFE_UNDERLINE.UNDERLINETHICK;
pub const CFU_UNDERLINEWAVE = CFE_UNDERLINE.UNDERLINEWAVE;
pub const CFU_UNDERLINEDASHDOTDOT = CFE_UNDERLINE.UNDERLINEDASHDOTDOT;
pub const CFU_UNDERLINEDASHDOT = CFE_UNDERLINE.UNDERLINEDASHDOT;
pub const CFU_UNDERLINEDASH = CFE_UNDERLINE.UNDERLINEDASH;
pub const CFU_UNDERLINEDOTTED = CFE_UNDERLINE.UNDERLINEDOTTED;
pub const CFU_UNDERLINEDOUBLE = CFE_UNDERLINE.UNDERLINEDOUBLE;
pub const CFU_UNDERLINEWORD = CFE_UNDERLINE.UNDERLINEWORD;
pub const CFU_UNDERLINE = CFE_UNDERLINE.UNDERLINE;
pub const CFU_UNDERLINENONE = CFE_UNDERLINE.UNDERLINENONE;

pub const IGP_ID = extern enum(u32) {
    GETIMEVERSION = 4294967292,
    PROPERTY = 4,
    CONVERSION = 8,
    SENTENCE = 12,
    UI = 16,
    SETCOMPSTR = 20,
    SELECT = 24,
};
pub const IGP_GETIMEVERSION = IGP_ID.GETIMEVERSION;
pub const IGP_PROPERTY = IGP_ID.PROPERTY;
pub const IGP_CONVERSION = IGP_ID.CONVERSION;
pub const IGP_SENTENCE = IGP_ID.SENTENCE;
pub const IGP_UI = IGP_ID.UI;
pub const IGP_SETCOMPSTR = IGP_ID.SETCOMPSTR;
pub const IGP_SELECT = IGP_ID.SELECT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SECTION_FLAGS = extern enum(u32) {
    ALL_ACCESS = 983071,
    QUERY = 1,
    MAP_WRITE = 2,
    MAP_READ = 4,
    MAP_EXECUTE = 8,
    EXTEND_SIZE = 16,
    MAP_EXECUTE_EXPLICIT = 32,
    _,
};
pub const SECTION_ALL_ACCESS = SECTION_FLAGS.ALL_ACCESS;
pub const SECTION_QUERY = SECTION_FLAGS.QUERY;
pub const SECTION_MAP_WRITE = SECTION_FLAGS.MAP_WRITE;
pub const SECTION_MAP_READ = SECTION_FLAGS.MAP_READ;
pub const SECTION_MAP_EXECUTE = SECTION_FLAGS.MAP_EXECUTE;
pub const SECTION_EXTEND_SIZE = SECTION_FLAGS.EXTEND_SIZE;
pub const SECTION_MAP_EXECUTE_EXPLICIT = SECTION_FLAGS.MAP_EXECUTE_EXPLICIT;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FILE_MAP = extern enum(u32) {
    WRITE = 2,
    READ = 4,
    ALL_ACCESS = 983071,
    EXECUTE = 32,
    COPY = 1,
    RESERVE = 2147483648,
    TARGETS_INVALID = 1073741824,
    LARGE_PAGES = 536870912,
    _,
};
pub const FILE_MAP_WRITE = FILE_MAP.WRITE;
pub const FILE_MAP_READ = FILE_MAP.READ;
pub const FILE_MAP_ALL_ACCESS = FILE_MAP.ALL_ACCESS;
pub const FILE_MAP_EXECUTE = FILE_MAP.EXECUTE;
pub const FILE_MAP_COPY = FILE_MAP.COPY;
pub const FILE_MAP_RESERVE = FILE_MAP.RESERVE;
pub const FILE_MAP_TARGETS_INVALID = FILE_MAP.TARGETS_INVALID;
pub const FILE_MAP_LARGE_PAGES = FILE_MAP.LARGE_PAGES;

pub const THREAD_PRIORITY = extern enum(i32) {
    MODE_BACKGROUND_BEGIN = 65536,
    MODE_BACKGROUND_END = 131072,
    PRIORITY_ABOVE_NORMAL = 1,
    PRIORITY_BELOW_NORMAL = -1,
    PRIORITY_HIGHEST = 2,
    PRIORITY_IDLE = -15,
    PRIORITY_LOWEST = -2,
    PRIORITY_NORMAL = 0,
    PRIORITY_TIME_CRITICAL = 15,
};
pub const THREAD_MODE_BACKGROUND_BEGIN = THREAD_PRIORITY.MODE_BACKGROUND_BEGIN;
pub const THREAD_MODE_BACKGROUND_END = THREAD_PRIORITY.MODE_BACKGROUND_END;
pub const THREAD_PRIORITY_ABOVE_NORMAL = THREAD_PRIORITY.PRIORITY_ABOVE_NORMAL;
pub const THREAD_PRIORITY_BELOW_NORMAL = THREAD_PRIORITY.PRIORITY_BELOW_NORMAL;
pub const THREAD_PRIORITY_HIGHEST = THREAD_PRIORITY.PRIORITY_HIGHEST;
pub const THREAD_PRIORITY_IDLE = THREAD_PRIORITY.PRIORITY_IDLE;
pub const THREAD_PRIORITY_LOWEST = THREAD_PRIORITY.PRIORITY_LOWEST;
pub const THREAD_PRIORITY_NORMAL = THREAD_PRIORITY.PRIORITY_NORMAL;
pub const THREAD_PRIORITY_TIME_CRITICAL = THREAD_PRIORITY.PRIORITY_TIME_CRITICAL;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const URI_CREATE_FLAGS = extern enum(u32) {
    ALLOW_RELATIVE = 1,
    ALLOW_IMPLICIT_WILDCARD_SCHEME = 2,
    ALLOW_IMPLICIT_FILE_SCHEME = 4,
    NOFRAG = 8,
    NO_CANONICALIZE = 16,
    CANONICALIZE = 256,
    FILE_USE_DOS_PATH = 32,
    DECODE_EXTRA_INFO = 64,
    NO_DECODE_EXTRA_INFO = 128,
    CRACK_UNKNOWN_SCHEMES = 512,
    NO_CRACK_UNKNOWN_SCHEMES = 1024,
    PRE_PROCESS_HTML_URI = 2048,
    NO_PRE_PROCESS_HTML_URI = 4096,
    IE_SETTINGS = 8192,
    NO_IE_SETTINGS = 16384,
    NO_ENCODE_FORBIDDEN_CHARACTERS = 32768,
    NORMALIZE_INTL_CHARACTERS = 65536,
    CANONICALIZE_ABSOLUTE = 131072,
    _,
};
pub const Uri_CREATE_ALLOW_RELATIVE = URI_CREATE_FLAGS.ALLOW_RELATIVE;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME;
pub const Uri_CREATE_NOFRAG = URI_CREATE_FLAGS.NOFRAG;
pub const Uri_CREATE_NO_CANONICALIZE = URI_CREATE_FLAGS.NO_CANONICALIZE;
pub const Uri_CREATE_CANONICALIZE = URI_CREATE_FLAGS.CANONICALIZE;
pub const Uri_CREATE_FILE_USE_DOS_PATH = URI_CREATE_FLAGS.FILE_USE_DOS_PATH;
pub const Uri_CREATE_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.DECODE_EXTRA_INFO;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_IE_SETTINGS = URI_CREATE_FLAGS.IE_SETTINGS;
pub const Uri_CREATE_NO_IE_SETTINGS = URI_CREATE_FLAGS.NO_IE_SETTINGS;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LOAD_LIBRARY_FLAGS = extern enum(u32) {
    DONT_RESOLVE_DLL_REFERENCES = 1,
    LOAD_LIBRARY_AS_DATAFILE = 2,
    LOAD_WITH_ALTERED_SEARCH_PATH = 8,
    LOAD_IGNORE_CODE_AUTHZ_LEVEL = 16,
    LOAD_LIBRARY_AS_IMAGE_RESOURCE = 32,
    LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 64,
    LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = 128,
    LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 256,
    LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 512,
    LOAD_LIBRARY_SEARCH_USER_DIRS = 1024,
    LOAD_LIBRARY_SEARCH_SYSTEM32 = 2048,
    LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 4096,
    LOAD_LIBRARY_SAFE_CURRENT_DIRS = 8192,
    LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER = 16384,
    _,
};
pub const DONT_RESOLVE_DLL_REFERENCES = LOAD_LIBRARY_FLAGS.DONT_RESOLVE_DLL_REFERENCES;
pub const LOAD_LIBRARY_AS_DATAFILE = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_AS_DATAFILE;
pub const LOAD_WITH_ALTERED_SEARCH_PATH = LOAD_LIBRARY_FLAGS.LOAD_WITH_ALTERED_SEARCH_PATH;
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL = LOAD_LIBRARY_FLAGS.LOAD_IGNORE_CODE_AUTHZ_LEVEL;
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_AS_IMAGE_RESOURCE;
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE;
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_REQUIRE_SIGNED_TARGET;
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_APPLICATION_DIR;
pub const LOAD_LIBRARY_SEARCH_USER_DIRS = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_USER_DIRS;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32 = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_SYSTEM32;
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SAFE_CURRENT_DIRS;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER = LOAD_LIBRARY_FLAGS.LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const HEAP_FLAGS = extern enum(u32) {
    NONE = 0,
    NO_SERIALIZE = 1,
    GROWABLE = 2,
    GENERATE_EXCEPTIONS = 4,
    ZERO_MEMORY = 8,
    REALLOC_IN_PLACE_ONLY = 16,
    TAIL_CHECKING_ENABLED = 32,
    FREE_CHECKING_ENABLED = 64,
    DISABLE_COALESCE_ON_FREE = 128,
    CREATE_ALIGN_16 = 65536,
    CREATE_ENABLE_TRACING = 131072,
    CREATE_ENABLE_EXECUTE = 262144,
    MAXIMUM_TAG = 4095,
    PSEUDO_TAG_FLAG = 32768,
    TAG_SHIFT = 18,
    CREATE_SEGMENT_HEAP = 256,
    CREATE_HARDENED = 512,
    _,
};
pub const HEAP_NONE = HEAP_FLAGS.NONE;
pub const HEAP_NO_SERIALIZE = HEAP_FLAGS.NO_SERIALIZE;
pub const HEAP_GROWABLE = HEAP_FLAGS.GROWABLE;
pub const HEAP_GENERATE_EXCEPTIONS = HEAP_FLAGS.GENERATE_EXCEPTIONS;
pub const HEAP_ZERO_MEMORY = HEAP_FLAGS.ZERO_MEMORY;
pub const HEAP_REALLOC_IN_PLACE_ONLY = HEAP_FLAGS.REALLOC_IN_PLACE_ONLY;
pub const HEAP_TAIL_CHECKING_ENABLED = HEAP_FLAGS.TAIL_CHECKING_ENABLED;
pub const HEAP_FREE_CHECKING_ENABLED = HEAP_FLAGS.FREE_CHECKING_ENABLED;
pub const HEAP_DISABLE_COALESCE_ON_FREE = HEAP_FLAGS.DISABLE_COALESCE_ON_FREE;
pub const HEAP_CREATE_ALIGN_16 = HEAP_FLAGS.CREATE_ALIGN_16;
pub const HEAP_CREATE_ENABLE_TRACING = HEAP_FLAGS.CREATE_ENABLE_TRACING;
pub const HEAP_CREATE_ENABLE_EXECUTE = HEAP_FLAGS.CREATE_ENABLE_EXECUTE;
pub const HEAP_MAXIMUM_TAG = HEAP_FLAGS.MAXIMUM_TAG;
pub const HEAP_PSEUDO_TAG_FLAG = HEAP_FLAGS.PSEUDO_TAG_FLAG;
pub const HEAP_TAG_SHIFT = HEAP_FLAGS.TAG_SHIFT;
pub const HEAP_CREATE_SEGMENT_HEAP = HEAP_FLAGS.CREATE_SEGMENT_HEAP;
pub const HEAP_CREATE_HARDENED = HEAP_FLAGS.CREATE_HARDENED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SHUTDOWN_REASON = extern enum(u32) {
    NONE = 0,
    FLAG_COMMENT_REQUIRED = 16777216,
    FLAG_DIRTY_PROBLEM_ID_REQUIRED = 33554432,
    FLAG_CLEAN_UI = 67108864,
    FLAG_DIRTY_UI = 134217728,
    FLAG_MOBILE_UI_RESERVED = 268435456,
    FLAG_USER_DEFINED = 1073741824,
    FLAG_PLANNED = 2147483648,
    MAJOR_OTHER = 0,
    MAJOR_NONE = 0,
    MAJOR_HARDWARE = 65536,
    MAJOR_OPERATINGSYSTEM = 131072,
    MAJOR_SOFTWARE = 196608,
    MAJOR_APPLICATION = 262144,
    MAJOR_SYSTEM = 327680,
    MAJOR_POWER = 393216,
    MAJOR_LEGACY_API = 458752,
    MINOR_OTHER = 0,
    MINOR_NONE = 255,
    MINOR_MAINTENANCE = 1,
    MINOR_INSTALLATION = 2,
    MINOR_UPGRADE = 3,
    MINOR_RECONFIG = 4,
    MINOR_HUNG = 5,
    MINOR_UNSTABLE = 6,
    MINOR_DISK = 7,
    MINOR_PROCESSOR = 8,
    MINOR_NETWORKCARD = 9,
    MINOR_POWER_SUPPLY = 10,
    MINOR_CORDUNPLUGGED = 11,
    MINOR_ENVIRONMENT = 12,
    MINOR_HARDWARE_DRIVER = 13,
    MINOR_OTHERDRIVER = 14,
    MINOR_BLUESCREEN = 15,
    MINOR_SERVICEPACK = 16,
    MINOR_HOTFIX = 17,
    MINOR_SECURITYFIX = 18,
    MINOR_SECURITY = 19,
    MINOR_NETWORK_CONNECTIVITY = 20,
    MINOR_WMI = 21,
    MINOR_SERVICEPACK_UNINSTALL = 22,
    MINOR_HOTFIX_UNINSTALL = 23,
    MINOR_SECURITYFIX_UNINSTALL = 24,
    MINOR_MMC = 25,
    MINOR_SYSTEMRESTORE = 26,
    MINOR_TERMSRV = 32,
    MINOR_DC_PROMOTION = 33,
    MINOR_DC_DEMOTION = 34,
    UNKNOWN = 255,
    LEGACY_API = 2147942400,
    VALID_BIT_MASK = 3238002687,
    _,
};
pub const SHTDN_REASON_NONE = SHUTDOWN_REASON.NONE;
pub const SHTDN_REASON_FLAG_COMMENT_REQUIRED = SHUTDOWN_REASON.FLAG_COMMENT_REQUIRED;
pub const SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED = SHUTDOWN_REASON.FLAG_DIRTY_PROBLEM_ID_REQUIRED;
pub const SHTDN_REASON_FLAG_CLEAN_UI = SHUTDOWN_REASON.FLAG_CLEAN_UI;
pub const SHTDN_REASON_FLAG_DIRTY_UI = SHUTDOWN_REASON.FLAG_DIRTY_UI;
pub const SHTDN_REASON_FLAG_MOBILE_UI_RESERVED = SHUTDOWN_REASON.FLAG_MOBILE_UI_RESERVED;
pub const SHTDN_REASON_FLAG_USER_DEFINED = SHUTDOWN_REASON.FLAG_USER_DEFINED;
pub const SHTDN_REASON_FLAG_PLANNED = SHUTDOWN_REASON.FLAG_PLANNED;
pub const SHTDN_REASON_MAJOR_OTHER = SHUTDOWN_REASON.MAJOR_OTHER;
pub const SHTDN_REASON_MAJOR_NONE = SHUTDOWN_REASON.MAJOR_NONE;
pub const SHTDN_REASON_MAJOR_HARDWARE = SHUTDOWN_REASON.MAJOR_HARDWARE;
pub const SHTDN_REASON_MAJOR_OPERATINGSYSTEM = SHUTDOWN_REASON.MAJOR_OPERATINGSYSTEM;
pub const SHTDN_REASON_MAJOR_SOFTWARE = SHUTDOWN_REASON.MAJOR_SOFTWARE;
pub const SHTDN_REASON_MAJOR_APPLICATION = SHUTDOWN_REASON.MAJOR_APPLICATION;
pub const SHTDN_REASON_MAJOR_SYSTEM = SHUTDOWN_REASON.MAJOR_SYSTEM;
pub const SHTDN_REASON_MAJOR_POWER = SHUTDOWN_REASON.MAJOR_POWER;
pub const SHTDN_REASON_MAJOR_LEGACY_API = SHUTDOWN_REASON.MAJOR_LEGACY_API;
pub const SHTDN_REASON_MINOR_OTHER = SHUTDOWN_REASON.MINOR_OTHER;
pub const SHTDN_REASON_MINOR_NONE = SHUTDOWN_REASON.MINOR_NONE;
pub const SHTDN_REASON_MINOR_MAINTENANCE = SHUTDOWN_REASON.MINOR_MAINTENANCE;
pub const SHTDN_REASON_MINOR_INSTALLATION = SHUTDOWN_REASON.MINOR_INSTALLATION;
pub const SHTDN_REASON_MINOR_UPGRADE = SHUTDOWN_REASON.MINOR_UPGRADE;
pub const SHTDN_REASON_MINOR_RECONFIG = SHUTDOWN_REASON.MINOR_RECONFIG;
pub const SHTDN_REASON_MINOR_HUNG = SHUTDOWN_REASON.MINOR_HUNG;
pub const SHTDN_REASON_MINOR_UNSTABLE = SHUTDOWN_REASON.MINOR_UNSTABLE;
pub const SHTDN_REASON_MINOR_DISK = SHUTDOWN_REASON.MINOR_DISK;
pub const SHTDN_REASON_MINOR_PROCESSOR = SHUTDOWN_REASON.MINOR_PROCESSOR;
pub const SHTDN_REASON_MINOR_NETWORKCARD = SHUTDOWN_REASON.MINOR_NETWORKCARD;
pub const SHTDN_REASON_MINOR_POWER_SUPPLY = SHUTDOWN_REASON.MINOR_POWER_SUPPLY;
pub const SHTDN_REASON_MINOR_CORDUNPLUGGED = SHUTDOWN_REASON.MINOR_CORDUNPLUGGED;
pub const SHTDN_REASON_MINOR_ENVIRONMENT = SHUTDOWN_REASON.MINOR_ENVIRONMENT;
pub const SHTDN_REASON_MINOR_HARDWARE_DRIVER = SHUTDOWN_REASON.MINOR_HARDWARE_DRIVER;
pub const SHTDN_REASON_MINOR_OTHERDRIVER = SHUTDOWN_REASON.MINOR_OTHERDRIVER;
pub const SHTDN_REASON_MINOR_BLUESCREEN = SHUTDOWN_REASON.MINOR_BLUESCREEN;
pub const SHTDN_REASON_MINOR_SERVICEPACK = SHUTDOWN_REASON.MINOR_SERVICEPACK;
pub const SHTDN_REASON_MINOR_HOTFIX = SHUTDOWN_REASON.MINOR_HOTFIX;
pub const SHTDN_REASON_MINOR_SECURITYFIX = SHUTDOWN_REASON.MINOR_SECURITYFIX;
pub const SHTDN_REASON_MINOR_SECURITY = SHUTDOWN_REASON.MINOR_SECURITY;
pub const SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY = SHUTDOWN_REASON.MINOR_NETWORK_CONNECTIVITY;
pub const SHTDN_REASON_MINOR_WMI = SHUTDOWN_REASON.MINOR_WMI;
pub const SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL = SHUTDOWN_REASON.MINOR_SERVICEPACK_UNINSTALL;
pub const SHTDN_REASON_MINOR_HOTFIX_UNINSTALL = SHUTDOWN_REASON.MINOR_HOTFIX_UNINSTALL;
pub const SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL = SHUTDOWN_REASON.MINOR_SECURITYFIX_UNINSTALL;
pub const SHTDN_REASON_MINOR_MMC = SHUTDOWN_REASON.MINOR_MMC;
pub const SHTDN_REASON_MINOR_SYSTEMRESTORE = SHUTDOWN_REASON.MINOR_SYSTEMRESTORE;
pub const SHTDN_REASON_MINOR_TERMSRV = SHUTDOWN_REASON.MINOR_TERMSRV;
pub const SHTDN_REASON_MINOR_DC_PROMOTION = SHUTDOWN_REASON.MINOR_DC_PROMOTION;
pub const SHTDN_REASON_MINOR_DC_DEMOTION = SHUTDOWN_REASON.MINOR_DC_DEMOTION;
pub const SHTDN_REASON_UNKNOWN = SHUTDOWN_REASON.UNKNOWN;
pub const SHTDN_REASON_LEGACY_API = SHUTDOWN_REASON.LEGACY_API;
pub const SHTDN_REASON_VALID_BIT_MASK = SHUTDOWN_REASON.VALID_BIT_MASK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const SHUTDOWN_FLAGS = extern enum(u32) {
    FORCE_OTHERS = 1,
    FORCE_SELF = 2,
    RESTART = 4,
    POWEROFF = 8,
    NOREBOOT = 16,
    GRACE_OVERRIDE = 32,
    INSTALL_UPDATES = 64,
    RESTARTAPPS = 128,
    SKIP_SVC_PRESHUTDOWN = 256,
    HYBRID = 512,
    RESTART_BOOTOPTIONS = 1024,
    SOFT_REBOOT = 2048,
    MOBILE_UI = 4096,
    ARSO = 8192,
    _,
};
pub const SHUTDOWN_FORCE_OTHERS = SHUTDOWN_FLAGS.FORCE_OTHERS;
pub const SHUTDOWN_FORCE_SELF = SHUTDOWN_FLAGS.FORCE_SELF;
pub const SHUTDOWN_RESTART = SHUTDOWN_FLAGS.RESTART;
pub const SHUTDOWN_POWEROFF = SHUTDOWN_FLAGS.POWEROFF;
pub const SHUTDOWN_NOREBOOT = SHUTDOWN_FLAGS.NOREBOOT;
pub const SHUTDOWN_GRACE_OVERRIDE = SHUTDOWN_FLAGS.GRACE_OVERRIDE;
pub const SHUTDOWN_INSTALL_UPDATES = SHUTDOWN_FLAGS.INSTALL_UPDATES;
pub const SHUTDOWN_RESTARTAPPS = SHUTDOWN_FLAGS.RESTARTAPPS;
pub const SHUTDOWN_SKIP_SVC_PRESHUTDOWN = SHUTDOWN_FLAGS.SKIP_SVC_PRESHUTDOWN;
pub const SHUTDOWN_HYBRID = SHUTDOWN_FLAGS.HYBRID;
pub const SHUTDOWN_RESTART_BOOTOPTIONS = SHUTDOWN_FLAGS.RESTART_BOOTOPTIONS;
pub const SHUTDOWN_SOFT_REBOOT = SHUTDOWN_FLAGS.SOFT_REBOOT;
pub const SHUTDOWN_MOBILE_UI = SHUTDOWN_FLAGS.MOBILE_UI;
pub const SHUTDOWN_ARSO = SHUTDOWN_FLAGS.ARSO;

pub const NTSTATUS_FACILITY_CODE = extern enum(u32) {
    DEBUGGER = 1,
    RPC_RUNTIME = 2,
    RPC_STUBS = 3,
    IO_ERROR_CODE = 4,
    CODCLASS_ERROR_CODE = 6,
    NTWIN32 = 7,
    NTCERT = 8,
    NTSSPI = 9,
    TERMINAL_SERVER = 10,
    USB_ERROR_CODE = 16,
    HID_ERROR_CODE = 17,
    FIREWIRE_ERROR_CODE = 18,
    CLUSTER_ERROR_CODE = 19,
    ACPI_ERROR_CODE = 20,
    SXS_ERROR_CODE = 21,
    TRANSACTION = 25,
    COMMONLOG = 26,
    VIDEO = 27,
    FILTER_MANAGER = 28,
    MONITOR = 29,
    GRAPHICS_KERNEL = 30,
    DRIVER_FRAMEWORK = 32,
    FVE_ERROR_CODE = 33,
    FWP_ERROR_CODE = 34,
    NDIS_ERROR_CODE = 35,
    QUIC_ERROR_CODE = 36,
    TPM = 41,
    RTPM = 42,
    HYPERVISOR = 53,
    IPSEC = 54,
    VIRTUALIZATION = 55,
    VOLMGR = 56,
    BCD_ERROR_CODE = 57,
    WIN32K_NTUSER = 62,
    WIN32K_NTGDI = 63,
    RESUME_KEY_FILTER = 64,
    RDBSS = 65,
    BTH_ATT = 66,
    SECUREBOOT = 67,
    AUDIO_KERNEL = 68,
    VSM = 69,
    VOLSNAP = 80,
    SDBUS = 81,
    SHARED_VHDX = 92,
    SMB = 93,
    XVS = 94,
    INTERIX = 153,
    SPACES = 231,
    SECURITY_CORE = 232,
    SYSTEM_INTEGRITY = 233,
    LICENSING = 234,
    PLATFORM_MANIFEST = 235,
    APP_EXEC = 236,
    MAXIMUM_VALUE = 237,
};
pub const FACILITY_DEBUGGER = NTSTATUS_FACILITY_CODE.DEBUGGER;
pub const FACILITY_RPC_RUNTIME = NTSTATUS_FACILITY_CODE.RPC_RUNTIME;
pub const FACILITY_RPC_STUBS = NTSTATUS_FACILITY_CODE.RPC_STUBS;
pub const FACILITY_IO_ERROR_CODE = NTSTATUS_FACILITY_CODE.IO_ERROR_CODE;
pub const FACILITY_CODCLASS_ERROR_CODE = NTSTATUS_FACILITY_CODE.CODCLASS_ERROR_CODE;
pub const FACILITY_NTWIN32 = NTSTATUS_FACILITY_CODE.NTWIN32;
pub const FACILITY_NTCERT = NTSTATUS_FACILITY_CODE.NTCERT;
pub const FACILITY_NTSSPI = NTSTATUS_FACILITY_CODE.NTSSPI;
pub const FACILITY_TERMINAL_SERVER = NTSTATUS_FACILITY_CODE.TERMINAL_SERVER;
pub const FACILITY_USB_ERROR_CODE = NTSTATUS_FACILITY_CODE.USB_ERROR_CODE;
pub const FACILITY_HID_ERROR_CODE = NTSTATUS_FACILITY_CODE.HID_ERROR_CODE;
pub const FACILITY_FIREWIRE_ERROR_CODE = NTSTATUS_FACILITY_CODE.FIREWIRE_ERROR_CODE;
pub const FACILITY_CLUSTER_ERROR_CODE = NTSTATUS_FACILITY_CODE.CLUSTER_ERROR_CODE;
pub const FACILITY_ACPI_ERROR_CODE = NTSTATUS_FACILITY_CODE.ACPI_ERROR_CODE;
pub const FACILITY_SXS_ERROR_CODE = NTSTATUS_FACILITY_CODE.SXS_ERROR_CODE;
pub const FACILITY_TRANSACTION = NTSTATUS_FACILITY_CODE.TRANSACTION;
pub const FACILITY_COMMONLOG = NTSTATUS_FACILITY_CODE.COMMONLOG;
pub const FACILITY_VIDEO = NTSTATUS_FACILITY_CODE.VIDEO;
pub const FACILITY_FILTER_MANAGER = NTSTATUS_FACILITY_CODE.FILTER_MANAGER;
pub const FACILITY_MONITOR = NTSTATUS_FACILITY_CODE.MONITOR;
pub const FACILITY_GRAPHICS_KERNEL = NTSTATUS_FACILITY_CODE.GRAPHICS_KERNEL;
pub const FACILITY_DRIVER_FRAMEWORK = NTSTATUS_FACILITY_CODE.DRIVER_FRAMEWORK;
pub const FACILITY_FVE_ERROR_CODE = NTSTATUS_FACILITY_CODE.FVE_ERROR_CODE;
pub const FACILITY_FWP_ERROR_CODE = NTSTATUS_FACILITY_CODE.FWP_ERROR_CODE;
pub const FACILITY_NDIS_ERROR_CODE = NTSTATUS_FACILITY_CODE.NDIS_ERROR_CODE;
pub const FACILITY_QUIC_ERROR_CODE = NTSTATUS_FACILITY_CODE.QUIC_ERROR_CODE;
pub const FACILITY_TPM = NTSTATUS_FACILITY_CODE.TPM;
pub const FACILITY_RTPM = NTSTATUS_FACILITY_CODE.RTPM;
pub const FACILITY_HYPERVISOR = NTSTATUS_FACILITY_CODE.HYPERVISOR;
pub const FACILITY_IPSEC = NTSTATUS_FACILITY_CODE.IPSEC;
pub const FACILITY_VIRTUALIZATION = NTSTATUS_FACILITY_CODE.VIRTUALIZATION;
pub const FACILITY_VOLMGR = NTSTATUS_FACILITY_CODE.VOLMGR;
pub const FACILITY_BCD_ERROR_CODE = NTSTATUS_FACILITY_CODE.BCD_ERROR_CODE;
pub const FACILITY_WIN32K_NTUSER = NTSTATUS_FACILITY_CODE.WIN32K_NTUSER;
pub const FACILITY_WIN32K_NTGDI = NTSTATUS_FACILITY_CODE.WIN32K_NTGDI;
pub const FACILITY_RESUME_KEY_FILTER = NTSTATUS_FACILITY_CODE.RESUME_KEY_FILTER;
pub const FACILITY_RDBSS = NTSTATUS_FACILITY_CODE.RDBSS;
pub const FACILITY_BTH_ATT = NTSTATUS_FACILITY_CODE.BTH_ATT;
pub const FACILITY_SECUREBOOT = NTSTATUS_FACILITY_CODE.SECUREBOOT;
pub const FACILITY_AUDIO_KERNEL = NTSTATUS_FACILITY_CODE.AUDIO_KERNEL;
pub const FACILITY_VSM = NTSTATUS_FACILITY_CODE.VSM;
pub const FACILITY_VOLSNAP = NTSTATUS_FACILITY_CODE.VOLSNAP;
pub const FACILITY_SDBUS = NTSTATUS_FACILITY_CODE.SDBUS;
pub const FACILITY_SHARED_VHDX = NTSTATUS_FACILITY_CODE.SHARED_VHDX;
pub const FACILITY_SMB = NTSTATUS_FACILITY_CODE.SMB;
pub const FACILITY_XVS = NTSTATUS_FACILITY_CODE.XVS;
pub const FACILITY_INTERIX = NTSTATUS_FACILITY_CODE.INTERIX;
pub const FACILITY_SPACES = NTSTATUS_FACILITY_CODE.SPACES;
pub const FACILITY_SECURITY_CORE = NTSTATUS_FACILITY_CODE.SECURITY_CORE;
pub const FACILITY_SYSTEM_INTEGRITY = NTSTATUS_FACILITY_CODE.SYSTEM_INTEGRITY;
pub const FACILITY_LICENSING = NTSTATUS_FACILITY_CODE.LICENSING;
pub const FACILITY_PLATFORM_MANIFEST = NTSTATUS_FACILITY_CODE.PLATFORM_MANIFEST;
pub const FACILITY_APP_EXEC = NTSTATUS_FACILITY_CODE.APP_EXEC;
pub const FACILITY_MAXIMUM_VALUE = NTSTATUS_FACILITY_CODE.MAXIMUM_VALUE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PAGE_TYPE = extern enum(u32) {
    PAGE_NOACCESS = 1,
    PAGE_READONLY = 2,
    PAGE_READWRITE = 4,
    PAGE_WRITECOPY = 8,
    PAGE_EXECUTE = 16,
    PAGE_EXECUTE_READ = 32,
    PAGE_EXECUTE_READWRITE = 64,
    PAGE_EXECUTE_WRITECOPY = 128,
    PAGE_GUARD = 256,
    PAGE_NOCACHE = 512,
    PAGE_WRITECOMBINE = 1024,
    PAGE_GRAPHICS_NOACCESS = 2048,
    PAGE_GRAPHICS_READONLY = 4096,
    PAGE_GRAPHICS_READWRITE = 8192,
    PAGE_GRAPHICS_EXECUTE = 16384,
    PAGE_GRAPHICS_EXECUTE_READ = 32768,
    PAGE_GRAPHICS_EXECUTE_READWRITE = 65536,
    PAGE_GRAPHICS_COHERENT = 131072,
    PAGE_GRAPHICS_NOCACHE = 262144,
    PAGE_ENCLAVE_THREAD_CONTROL = 2147483648,
    PAGE_REVERT_TO_FILE_MAP = 2147483648,
    PAGE_TARGETS_NO_UPDATE = 1073741824,
    PAGE_TARGETS_INVALID = 1073741824,
    PAGE_ENCLAVE_UNVALIDATED = 536870912,
    PAGE_ENCLAVE_MASK = 268435456,
    PAGE_ENCLAVE_DECOMMIT = 268435456,
    PAGE_ENCLAVE_SS_FIRST = 268435457,
    PAGE_ENCLAVE_SS_REST = 268435458,
    SEC_PARTITION_OWNER_HANDLE = 262144,
    SEC_64K_PAGES = 524288,
    SEC_FILE = 8388608,
    SEC_IMAGE = 16777216,
    SEC_PROTECTED_IMAGE = 33554432,
    SEC_RESERVE = 67108864,
    SEC_COMMIT = 134217728,
    SEC_NOCACHE = 268435456,
    SEC_WRITECOMBINE = 1073741824,
    SEC_LARGE_PAGES = 2147483648,
    SEC_IMAGE_NO_EXECUTE = 285212672,
    _,
};
pub const PAGE_NOACCESS = PAGE_TYPE.PAGE_NOACCESS;
pub const PAGE_READONLY = PAGE_TYPE.PAGE_READONLY;
pub const PAGE_READWRITE = PAGE_TYPE.PAGE_READWRITE;
pub const PAGE_WRITECOPY = PAGE_TYPE.PAGE_WRITECOPY;
pub const PAGE_EXECUTE = PAGE_TYPE.PAGE_EXECUTE;
pub const PAGE_EXECUTE_READ = PAGE_TYPE.PAGE_EXECUTE_READ;
pub const PAGE_EXECUTE_READWRITE = PAGE_TYPE.PAGE_EXECUTE_READWRITE;
pub const PAGE_EXECUTE_WRITECOPY = PAGE_TYPE.PAGE_EXECUTE_WRITECOPY;
pub const PAGE_GUARD = PAGE_TYPE.PAGE_GUARD;
pub const PAGE_NOCACHE = PAGE_TYPE.PAGE_NOCACHE;
pub const PAGE_WRITECOMBINE = PAGE_TYPE.PAGE_WRITECOMBINE;
pub const PAGE_GRAPHICS_NOACCESS = PAGE_TYPE.PAGE_GRAPHICS_NOACCESS;
pub const PAGE_GRAPHICS_READONLY = PAGE_TYPE.PAGE_GRAPHICS_READONLY;
pub const PAGE_GRAPHICS_READWRITE = PAGE_TYPE.PAGE_GRAPHICS_READWRITE;
pub const PAGE_GRAPHICS_EXECUTE = PAGE_TYPE.PAGE_GRAPHICS_EXECUTE;
pub const PAGE_GRAPHICS_EXECUTE_READ = PAGE_TYPE.PAGE_GRAPHICS_EXECUTE_READ;
pub const PAGE_GRAPHICS_EXECUTE_READWRITE = PAGE_TYPE.PAGE_GRAPHICS_EXECUTE_READWRITE;
pub const PAGE_GRAPHICS_COHERENT = PAGE_TYPE.PAGE_GRAPHICS_COHERENT;
pub const PAGE_GRAPHICS_NOCACHE = PAGE_TYPE.PAGE_GRAPHICS_NOCACHE;
pub const PAGE_ENCLAVE_THREAD_CONTROL = PAGE_TYPE.PAGE_ENCLAVE_THREAD_CONTROL;
pub const PAGE_REVERT_TO_FILE_MAP = PAGE_TYPE.PAGE_REVERT_TO_FILE_MAP;
pub const PAGE_TARGETS_NO_UPDATE = PAGE_TYPE.PAGE_TARGETS_NO_UPDATE;
pub const PAGE_TARGETS_INVALID = PAGE_TYPE.PAGE_TARGETS_INVALID;
pub const PAGE_ENCLAVE_UNVALIDATED = PAGE_TYPE.PAGE_ENCLAVE_UNVALIDATED;
pub const PAGE_ENCLAVE_MASK = PAGE_TYPE.PAGE_ENCLAVE_MASK;
pub const PAGE_ENCLAVE_DECOMMIT = PAGE_TYPE.PAGE_ENCLAVE_DECOMMIT;
pub const PAGE_ENCLAVE_SS_FIRST = PAGE_TYPE.PAGE_ENCLAVE_SS_FIRST;
pub const PAGE_ENCLAVE_SS_REST = PAGE_TYPE.PAGE_ENCLAVE_SS_REST;
pub const SEC_PARTITION_OWNER_HANDLE = PAGE_TYPE.SEC_PARTITION_OWNER_HANDLE;
pub const SEC_64K_PAGES = PAGE_TYPE.SEC_64K_PAGES;
pub const SEC_FILE = PAGE_TYPE.SEC_FILE;
pub const SEC_IMAGE = PAGE_TYPE.SEC_IMAGE;
pub const SEC_PROTECTED_IMAGE = PAGE_TYPE.SEC_PROTECTED_IMAGE;
pub const SEC_RESERVE = PAGE_TYPE.SEC_RESERVE;
pub const SEC_COMMIT = PAGE_TYPE.SEC_COMMIT;
pub const SEC_NOCACHE = PAGE_TYPE.SEC_NOCACHE;
pub const SEC_WRITECOMBINE = PAGE_TYPE.SEC_WRITECOMBINE;
pub const SEC_LARGE_PAGES = PAGE_TYPE.SEC_LARGE_PAGES;
pub const SEC_IMAGE_NO_EXECUTE = PAGE_TYPE.SEC_IMAGE_NO_EXECUTE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MODEM_STATUS_FLAGS = extern enum(u32) {
    CTS_ON = 16,
    DSR_ON = 32,
    RING_ON = 64,
    RLSD_ON = 128,
    _,
};
pub const MS_CTS_ON = MODEM_STATUS_FLAGS.CTS_ON;
pub const MS_DSR_ON = MODEM_STATUS_FLAGS.DSR_ON;
pub const MS_RING_ON = MODEM_STATUS_FLAGS.RING_ON;
pub const MS_RLSD_ON = MODEM_STATUS_FLAGS.RLSD_ON;

pub const REPORT_EVENT_TYPE = extern enum(u32) {
    SUCCESS = 0,
    AUDIT_FAILURE = 16,
    AUDIT_SUCCESS = 8,
    ERROR_TYPE = 1,
    INFORMATION_TYPE = 4,
    WARNING_TYPE = 2,
};
pub const EVENTLOG_SUCCESS = REPORT_EVENT_TYPE.SUCCESS;
pub const EVENTLOG_AUDIT_FAILURE = REPORT_EVENT_TYPE.AUDIT_FAILURE;
pub const EVENTLOG_AUDIT_SUCCESS = REPORT_EVENT_TYPE.AUDIT_SUCCESS;
pub const EVENTLOG_ERROR_TYPE = REPORT_EVENT_TYPE.ERROR_TYPE;
pub const EVENTLOG_INFORMATION_TYPE = REPORT_EVENT_TYPE.INFORMATION_TYPE;
pub const EVENTLOG_WARNING_TYPE = REPORT_EVENT_TYPE.WARNING_TYPE;

pub const NAMED_PIPE_HANDLE_STATE = extern enum(u32) {
    NOWAIT = 1,
    READMODE_MESSAGE = 2,
};
pub const PIPE_NOWAIT = NAMED_PIPE_HANDLE_STATE.NOWAIT;
pub const PIPE_READMODE_MESSAGE = NAMED_PIPE_HANDLE_STATE.READMODE_MESSAGE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const WORKER_THREAD_FLAGS = extern enum(u32) {
    EXECUTEDEFAULT = 0,
    EXECUTEINIOTHREAD = 1,
    EXECUTEINPERSISTENTTHREAD = 128,
    EXECUTEINWAITTHREAD = 4,
    EXECUTELONGFUNCTION = 16,
    EXECUTEONLYONCE = 8,
    TRANSFER_IMPERSONATION = 256,
    EXECUTEINTIMERTHREAD = 32,
    _,
};
pub const WT_EXECUTEDEFAULT = WORKER_THREAD_FLAGS.EXECUTEDEFAULT;
pub const WT_EXECUTEINIOTHREAD = WORKER_THREAD_FLAGS.EXECUTEINIOTHREAD;
pub const WT_EXECUTEINPERSISTENTTHREAD = WORKER_THREAD_FLAGS.EXECUTEINPERSISTENTTHREAD;
pub const WT_EXECUTEINWAITTHREAD = WORKER_THREAD_FLAGS.EXECUTEINWAITTHREAD;
pub const WT_EXECUTELONGFUNCTION = WORKER_THREAD_FLAGS.EXECUTELONGFUNCTION;
pub const WT_EXECUTEONLYONCE = WORKER_THREAD_FLAGS.EXECUTEONLYONCE;
pub const WT_TRANSFER_IMPERSONATION = WORKER_THREAD_FLAGS.TRANSFER_IMPERSONATION;
pub const WT_EXECUTEINTIMERTHREAD = WORKER_THREAD_FLAGS.EXECUTEINTIMERTHREAD;

pub const WAIT_NAMED_PIPE_TIME_OUT_FLAGS = extern enum(u32) {
    USE_DEFAULT_WAIT = 0,
    WAIT_FOREVER = 4294967295,
};
pub const NMPWAIT_USE_DEFAULT_WAIT = WAIT_NAMED_PIPE_TIME_OUT_FLAGS.USE_DEFAULT_WAIT;
pub const NMPWAIT_WAIT_FOREVER = WAIT_NAMED_PIPE_TIME_OUT_FLAGS.WAIT_FOREVER;

pub const UNMAP_VIEW_OF_FILE_FLAGS = extern enum(u32) {
    UNMAP_NONE = 0,
    UNMAP_WITH_TRANSIENT_BOOST = 1,
    PRESERVE_PLACEHOLDER = 2,
};
pub const MEM_UNMAP_NONE = UNMAP_VIEW_OF_FILE_FLAGS.UNMAP_NONE;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST = UNMAP_VIEW_OF_FILE_FLAGS.UNMAP_WITH_TRANSIENT_BOOST;
pub const MEM_PRESERVE_PLACEHOLDER = UNMAP_VIEW_OF_FILE_FLAGS.PRESERVE_PLACEHOLDER;

pub const SERVICE_ERROR = extern enum(u32) {
    CRITICAL = 3,
    IGNORE = 0,
    NORMAL = 1,
    SEVERE = 2,
};
pub const SERVICE_ERROR_CRITICAL = SERVICE_ERROR.CRITICAL;
pub const SERVICE_ERROR_IGNORE = SERVICE_ERROR.IGNORE;
pub const SERVICE_ERROR_NORMAL = SERVICE_ERROR.NORMAL;
pub const SERVICE_ERROR_SEVERE = SERVICE_ERROR.SEVERE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CREATE_EVENT = extern enum(u32) {
    INITIAL_SET = 2,
    MANUAL_RESET = 1,
    _,
};
pub const CREATE_EVENT_INITIAL_SET = CREATE_EVENT.INITIAL_SET;
pub const CREATE_EVENT_MANUAL_RESET = CREATE_EVENT.MANUAL_RESET;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CLEAR_COMM_ERROR_FLAGS = extern enum(u32) {
    BREAK = 16,
    FRAME = 8,
    OVERRUN = 2,
    RXOVER = 1,
    RXPARITY = 4,
    _,
};
pub const CE_BREAK = CLEAR_COMM_ERROR_FLAGS.BREAK;
pub const CE_FRAME = CLEAR_COMM_ERROR_FLAGS.FRAME;
pub const CE_OVERRUN = CLEAR_COMM_ERROR_FLAGS.OVERRUN;
pub const CE_RXOVER = CLEAR_COMM_ERROR_FLAGS.RXOVER;
pub const CE_RXPARITY = CLEAR_COMM_ERROR_FLAGS.RXPARITY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PURGE_COMM_FLAGS = extern enum(u32) {
    RXABORT = 2,
    RXCLEAR = 8,
    TXABORT = 1,
    TXCLEAR = 4,
    _,
};
pub const PURGE_RXABORT = PURGE_COMM_FLAGS.RXABORT;
pub const PURGE_RXCLEAR = PURGE_COMM_FLAGS.RXCLEAR;
pub const PURGE_TXABORT = PURGE_COMM_FLAGS.TXABORT;
pub const PURGE_TXCLEAR = PURGE_COMM_FLAGS.TXCLEAR;

pub const VIRTUAL_FREE_TYPE = extern enum(u32) {
    DECOMMIT = 16384,
    RELEASE = 32768,
};
pub const MEM_DECOMMIT = VIRTUAL_FREE_TYPE.DECOMMIT;
pub const MEM_RELEASE = VIRTUAL_FREE_TYPE.RELEASE;

pub const CREATE_PROCESS_LOGON_FLAGS = extern enum(u32) {
    WITH_PROFILE = 1,
    NETCREDENTIALS_ONLY = 2,
};
pub const LOGON_WITH_PROFILE = CREATE_PROCESS_LOGON_FLAGS.WITH_PROFILE;
pub const LOGON_NETCREDENTIALS_ONLY = CREATE_PROCESS_LOGON_FLAGS.NETCREDENTIALS_ONLY;

pub const TAPE_POSITION_TYPE = extern enum(i32) {
    ABSOLUTE_POSITION = 0,
    LOGICAL_POSITION = 1,
};
pub const TAPE_ABSOLUTE_POSITION = TAPE_POSITION_TYPE.ABSOLUTE_POSITION;
pub const TAPE_LOGICAL_POSITION = TAPE_POSITION_TYPE.LOGICAL_POSITION;

pub const CREATE_TAPE_PARTITION_METHOD = extern enum(i32) {
    FIXED_PARTITIONS = 0,
    INITIATOR_PARTITIONS = 2,
    SELECT_PARTITIONS = 1,
};
pub const TAPE_FIXED_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.FIXED_PARTITIONS;
pub const TAPE_INITIATOR_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.INITIATOR_PARTITIONS;
pub const TAPE_SELECT_PARTITIONS = CREATE_TAPE_PARTITION_METHOD.SELECT_PARTITIONS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS = extern enum(u32) {
    NONE = 0,
    ALERTABLE = 2,
    INPUTAVAILABLE = 4,
    WAITALL = 1,
    _,
};
pub const MWMO_NONE = MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS.NONE;
pub const MWMO_ALERTABLE = MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS.ALERTABLE;
pub const MWMO_INPUTAVAILABLE = MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS.INPUTAVAILABLE;
pub const MWMO_WAITALL = MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS.WAITALL;

pub const POWER_PLATFORM_ROLE_VERSION = extern enum(u32) {
    ERSION = 2,
    @"1" = 1,
    @"2" = 2,
};
// TODO: enum 'POWER_PLATFORM_ROLE_VERSION' has known issues with its value aliases

pub const POWER_SETTING_REGISTER_NOTIFICATION_FLAGS = extern enum(u32) {
    SERVICE_HANDLE = 1,
    CALLBACK = 2,
    WINDOW_HANDLE = 0,
};
pub const DEVICE_NOTIFY_SERVICE_HANDLE = POWER_SETTING_REGISTER_NOTIFICATION_FLAGS.SERVICE_HANDLE;
pub const DEVICE_NOTIFY_CALLBACK = POWER_SETTING_REGISTER_NOTIFICATION_FLAGS.CALLBACK;
pub const DEVICE_NOTIFY_WINDOW_HANDLE = POWER_SETTING_REGISTER_NOTIFICATION_FLAGS.WINDOW_HANDLE;

pub const VIRTUAL_ALLOCATION_TYPE = extern enum(u32) {
    COMMIT = 4096,
    RESERVE = 8192,
    RESET = 524288,
    RESET_UNDO = 16777216,
    REPLACE_PLACEHOLDER = 16384,
    LARGE_PAGES = 536870912,
    RESERVE_PLACEHOLDER = 262144,
    FREE = 65536,
};
pub const MEM_COMMIT = VIRTUAL_ALLOCATION_TYPE.COMMIT;
pub const MEM_RESERVE = VIRTUAL_ALLOCATION_TYPE.RESERVE;
pub const MEM_RESET = VIRTUAL_ALLOCATION_TYPE.RESET;
pub const MEM_RESET_UNDO = VIRTUAL_ALLOCATION_TYPE.RESET_UNDO;
pub const MEM_REPLACE_PLACEHOLDER = VIRTUAL_ALLOCATION_TYPE.REPLACE_PLACEHOLDER;
pub const MEM_LARGE_PAGES = VIRTUAL_ALLOCATION_TYPE.LARGE_PAGES;
pub const MEM_RESERVE_PLACEHOLDER = VIRTUAL_ALLOCATION_TYPE.RESERVE_PLACEHOLDER;
pub const MEM_FREE = VIRTUAL_ALLOCATION_TYPE.FREE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const COMM_EVENT_MASK = extern enum(u32) {
    BREAK = 64,
    CTS = 8,
    DSR = 16,
    ERR = 128,
    EVENT1 = 2048,
    EVENT2 = 4096,
    PERR = 512,
    RING = 256,
    RLSD = 32,
    RX80FULL = 1024,
    RXCHAR = 1,
    RXFLAG = 2,
    TXEMPTY = 4,
    _,
};
pub const EV_BREAK = COMM_EVENT_MASK.BREAK;
pub const EV_CTS = COMM_EVENT_MASK.CTS;
pub const EV_DSR = COMM_EVENT_MASK.DSR;
pub const EV_ERR = COMM_EVENT_MASK.ERR;
pub const EV_EVENT1 = COMM_EVENT_MASK.EVENT1;
pub const EV_EVENT2 = COMM_EVENT_MASK.EVENT2;
pub const EV_PERR = COMM_EVENT_MASK.PERR;
pub const EV_RING = COMM_EVENT_MASK.RING;
pub const EV_RLSD = COMM_EVENT_MASK.RLSD;
pub const EV_RX80FULL = COMM_EVENT_MASK.RX80FULL;
pub const EV_RXCHAR = COMM_EVENT_MASK.RXCHAR;
pub const EV_RXFLAG = COMM_EVENT_MASK.RXFLAG;
pub const EV_TXEMPTY = COMM_EVENT_MASK.TXEMPTY;

pub const TAPEMARK_TYPE = extern enum(i32) {
    FILEMARKS = 1,
    LONG_FILEMARKS = 3,
    SETMARKS = 0,
    SHORT_FILEMARKS = 2,
};
pub const TAPE_FILEMARKS = TAPEMARK_TYPE.FILEMARKS;
pub const TAPE_LONG_FILEMARKS = TAPEMARK_TYPE.LONG_FILEMARKS;
pub const TAPE_SETMARKS = TAPEMARK_TYPE.SETMARKS;
pub const TAPE_SHORT_FILEMARKS = TAPEMARK_TYPE.SHORT_FILEMARKS;

pub const SERVICE_START_TYPE = extern enum(u32) {
    AUTO_START = 2,
    BOOT_START = 0,
    DEMAND_START = 3,
    DISABLED = 4,
    SYSTEM_START = 1,
};
pub const SERVICE_AUTO_START = SERVICE_START_TYPE.AUTO_START;
pub const SERVICE_BOOT_START = SERVICE_START_TYPE.BOOT_START;
pub const SERVICE_DEMAND_START = SERVICE_START_TYPE.DEMAND_START;
pub const SERVICE_DISABLED = SERVICE_START_TYPE.DISABLED;
pub const SERVICE_SYSTEM_START = SERVICE_START_TYPE.SYSTEM_START;

pub const TAPE_POSITION_METHOD = extern enum(i32) {
    ABSOLUTE_BLOCK = 1,
    LOGICAL_BLOCK = 2,
    REWIND = 0,
    SPACE_END_OF_DATA = 4,
    SPACE_FILEMARKS = 6,
    SPACE_RELATIVE_BLOCKS = 5,
    SPACE_SEQUENTIAL_FMKS = 7,
    SPACE_SEQUENTIAL_SMKS = 9,
    SPACE_SETMARKS = 8,
};
pub const TAPE_ABSOLUTE_BLOCK = TAPE_POSITION_METHOD.ABSOLUTE_BLOCK;
pub const TAPE_LOGICAL_BLOCK = TAPE_POSITION_METHOD.LOGICAL_BLOCK;
pub const TAPE_REWIND = TAPE_POSITION_METHOD.REWIND;
pub const TAPE_SPACE_END_OF_DATA = TAPE_POSITION_METHOD.SPACE_END_OF_DATA;
pub const TAPE_SPACE_FILEMARKS = TAPE_POSITION_METHOD.SPACE_FILEMARKS;
pub const TAPE_SPACE_RELATIVE_BLOCKS = TAPE_POSITION_METHOD.SPACE_RELATIVE_BLOCKS;
pub const TAPE_SPACE_SEQUENTIAL_FMKS = TAPE_POSITION_METHOD.SPACE_SEQUENTIAL_FMKS;
pub const TAPE_SPACE_SEQUENTIAL_SMKS = TAPE_POSITION_METHOD.SPACE_SEQUENTIAL_SMKS;
pub const TAPE_SPACE_SETMARKS = TAPE_POSITION_METHOD.SPACE_SETMARKS;

pub const PROCESS_AFFINITY_AUTO_UPDATE_FLAGS = extern enum(u32) {
    DISABLE_AUTO_UPDATE = 0,
    ENABLE_AUTO_UPDATE = 1,
};
pub const PROCESS_AFFINITY_DISABLE_AUTO_UPDATE = PROCESS_AFFINITY_AUTO_UPDATE_FLAGS.DISABLE_AUTO_UPDATE;
pub const PROCESS_AFFINITY_ENABLE_AUTO_UPDATE = PROCESS_AFFINITY_AUTO_UPDATE_FLAGS.ENABLE_AUTO_UPDATE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const NAMED_PIPE_INFO_FLAGS = extern enum(u32) {
    CLIENT_END = 0,
    SERVER_END = 1,
    TYPE_BYTE = 0,
    TYPE_MESSAGE = 4,
    _,
};
pub const PIPE_CLIENT_END = NAMED_PIPE_INFO_FLAGS.CLIENT_END;
pub const PIPE_SERVER_END = NAMED_PIPE_INFO_FLAGS.SERVER_END;
pub const PIPE_TYPE_BYTE = NAMED_PIPE_INFO_FLAGS.TYPE_BYTE;
pub const PIPE_TYPE_MESSAGE = NAMED_PIPE_INFO_FLAGS.TYPE_MESSAGE;

pub const TAPE_INFORMATION_TYPE = extern enum(u32) {
    DRIVE_INFORMATION = 1,
    MEDIA_INFORMATION = 0,
};
pub const SET_TAPE_DRIVE_INFORMATION = TAPE_INFORMATION_TYPE.DRIVE_INFORMATION;
pub const SET_TAPE_MEDIA_INFORMATION = TAPE_INFORMATION_TYPE.MEDIA_INFORMATION;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PROCESS_DEP_FLAGS = extern enum(u32) {
    ENABLE = 1,
    DISABLE_ATL_THUNK_EMULATION = 2,
    NONE = 0,
    _,
};
pub const PROCESS_DEP_ENABLE = PROCESS_DEP_FLAGS.ENABLE;
pub const PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION = PROCESS_DEP_FLAGS.DISABLE_ATL_THUNK_EMULATION;
pub const PROCESS_DEP_NONE = PROCESS_DEP_FLAGS.NONE;

pub const HATCH_BRUSH_STYLE = extern enum(u32) {
    BDIAGONAL = 3,
    CROSS = 4,
    DIAGCROSS = 5,
    FDIAGONAL = 2,
    HORIZONTAL = 0,
    VERTICAL = 1,
};
pub const HS_BDIAGONAL = HATCH_BRUSH_STYLE.BDIAGONAL;
pub const HS_CROSS = HATCH_BRUSH_STYLE.CROSS;
pub const HS_DIAGCROSS = HATCH_BRUSH_STYLE.DIAGCROSS;
pub const HS_FDIAGONAL = HATCH_BRUSH_STYLE.FDIAGONAL;
pub const HS_HORIZONTAL = HATCH_BRUSH_STYLE.HORIZONTAL;
pub const HS_VERTICAL = HATCH_BRUSH_STYLE.VERTICAL;

pub const PROCESS_NAME_FORMAT = extern enum(u32) {
    WIN32 = 0,
    NATIVE = 1,
};
pub const PROCESS_NAME_WIN32 = PROCESS_NAME_FORMAT.WIN32;
pub const PROCESS_NAME_NATIVE = PROCESS_NAME_FORMAT.NATIVE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const EXECUTION_STATE = extern enum(u32) {
    AWAYMODE_REQUIRED = 64,
    CONTINUOUS = 2147483648,
    DISPLAY_REQUIRED = 2,
    SYSTEM_REQUIRED = 1,
    USER_PRESENT = 4,
    _,
};
pub const ES_AWAYMODE_REQUIRED = EXECUTION_STATE.AWAYMODE_REQUIRED;
pub const ES_CONTINUOUS = EXECUTION_STATE.CONTINUOUS;
pub const ES_DISPLAY_REQUIRED = EXECUTION_STATE.DISPLAY_REQUIRED;
pub const ES_SYSTEM_REQUIRED = EXECUTION_STATE.SYSTEM_REQUIRED;
pub const ES_USER_PRESENT = EXECUTION_STATE.USER_PRESENT;

pub const ESCAPE_COMM_FUNCTION = extern enum(u32) {
    CLRBREAK = 9,
    CLRDTR = 6,
    CLRRTS = 4,
    SETBREAK = 8,
    SETDTR = 5,
    SETRTS = 3,
    SETXOFF = 1,
    SETXON = 2,
};
pub const CLRBREAK = ESCAPE_COMM_FUNCTION.CLRBREAK;
pub const CLRDTR = ESCAPE_COMM_FUNCTION.CLRDTR;
pub const CLRRTS = ESCAPE_COMM_FUNCTION.CLRRTS;
pub const SETBREAK = ESCAPE_COMM_FUNCTION.SETBREAK;
pub const SETDTR = ESCAPE_COMM_FUNCTION.SETDTR;
pub const SETRTS = ESCAPE_COMM_FUNCTION.SETRTS;
pub const SETXOFF = ESCAPE_COMM_FUNCTION.SETXOFF;
pub const SETXON = ESCAPE_COMM_FUNCTION.SETXON;

pub const READ_EVENT_LOG_READ_FLAGS = extern enum(u32) {
    EK_READ = 2,
    QUENTIAL_READ = 1,
};
pub const EVENTLOG_SEEK_READ = READ_EVENT_LOG_READ_FLAGS.EK_READ;
pub const EVENTLOG_SEQUENTIAL_READ = READ_EVENT_LOG_READ_FLAGS.QUENTIAL_READ;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const LOCAL_ALLOC_FLAGS = extern enum(u32) {
    LHND = 66,
    LMEM_FIXED = 0,
    LMEM_MOVEABLE = 2,
    LMEM_ZEROINIT = 64,
    LPTR = 64,
    NONZEROLHND = 2,
    NONZEROLPTR = 0,
    _,
};
pub const LHND = LOCAL_ALLOC_FLAGS.LHND;
pub const LMEM_FIXED = LOCAL_ALLOC_FLAGS.LMEM_FIXED;
pub const LMEM_MOVEABLE = LOCAL_ALLOC_FLAGS.LMEM_MOVEABLE;
pub const LMEM_ZEROINIT = LOCAL_ALLOC_FLAGS.LMEM_ZEROINIT;
pub const LPTR = LOCAL_ALLOC_FLAGS.LPTR;
pub const NONZEROLHND = LOCAL_ALLOC_FLAGS.NONZEROLHND;
pub const NONZEROLPTR = LOCAL_ALLOC_FLAGS.NONZEROLPTR;

pub const EXIT_WINDOWS_FLAGS = extern enum(u32) {
    HYBRID_SHUTDOWN = 4194304,
    LOGOFF = 0,
    POWEROFF = 8,
    REBOOT = 2,
    RESTARTAPPS = 64,
    SHUTDOWN = 1,
};
pub const EWX_HYBRID_SHUTDOWN = EXIT_WINDOWS_FLAGS.HYBRID_SHUTDOWN;
pub const EWX_LOGOFF = EXIT_WINDOWS_FLAGS.LOGOFF;
pub const EWX_POWEROFF = EXIT_WINDOWS_FLAGS.POWEROFF;
pub const EWX_REBOOT = EXIT_WINDOWS_FLAGS.REBOOT;
pub const EWX_RESTARTAPPS = EXIT_WINDOWS_FLAGS.RESTARTAPPS;
pub const EWX_SHUTDOWN = EXIT_WINDOWS_FLAGS.SHUTDOWN;

pub const PREPARE_TAPE_OPERATION = extern enum(i32) {
    FORMAT = 5,
    LOAD = 0,
    LOCK = 3,
    TENSION = 2,
    UNLOAD = 1,
    UNLOCK = 4,
};
pub const TAPE_FORMAT = PREPARE_TAPE_OPERATION.FORMAT;
pub const TAPE_LOAD = PREPARE_TAPE_OPERATION.LOAD;
pub const TAPE_LOCK = PREPARE_TAPE_OPERATION.LOCK;
pub const TAPE_TENSION = PREPARE_TAPE_OPERATION.TENSION;
pub const TAPE_UNLOAD = PREPARE_TAPE_OPERATION.UNLOAD;
pub const TAPE_UNLOCK = PREPARE_TAPE_OPERATION.UNLOCK;

pub const IMAGE_LIST_ITEM_FLAGS = extern enum(u32) {
    ALPHA = 1,
    LOWQUALITY = 2,
};
pub const ILIF_ALPHA = IMAGE_LIST_ITEM_FLAGS.ALPHA;
pub const ILIF_LOWQUALITY = IMAGE_LIST_ITEM_FLAGS.LOWQUALITY;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GLOBAL_ALLOC_FLAGS = extern enum(u32) {
    HND = 66,
    MEM_FIXED = 0,
    MEM_MOVEABLE = 2,
    MEM_ZEROINIT = 64,
    PTR = 64,
    _,
};
pub const GHND = GLOBAL_ALLOC_FLAGS.HND;
pub const GMEM_FIXED = GLOBAL_ALLOC_FLAGS.MEM_FIXED;
pub const GMEM_MOVEABLE = GLOBAL_ALLOC_FLAGS.MEM_MOVEABLE;
pub const GMEM_ZEROINIT = GLOBAL_ALLOC_FLAGS.MEM_ZEROINIT;
pub const GPTR = GLOBAL_ALLOC_FLAGS.PTR;

pub const GET_TAPE_DRIVE_PARAMETERS_OPERATION = extern enum(u32) {
    DRIVE_INFORMATION = 1,
    MEDIA_INFORMATION = 0,
};
pub const GET_TAPE_DRIVE_INFORMATION = GET_TAPE_DRIVE_PARAMETERS_OPERATION.DRIVE_INFORMATION;
pub const GET_TAPE_MEDIA_INFORMATION = GET_TAPE_DRIVE_PARAMETERS_OPERATION.MEDIA_INFORMATION;

pub const ERASE_TAPE_TYPE = extern enum(i32) {
    LONG = 1,
    SHORT = 0,
};
pub const TAPE_ERASE_LONG = ERASE_TAPE_TYPE.LONG;
pub const TAPE_ERASE_SHORT = ERASE_TAPE_TYPE.SHORT;

pub const GET_GUI_RESOURCES_FLAGS = extern enum(u32) {
    GDIOBJECTS = 0,
    GDIOBJECTS_PEAK = 2,
    USEROBJECTS = 1,
    USEROBJECTS_PEAK = 4,
};
pub const GR_GDIOBJECTS = GET_GUI_RESOURCES_FLAGS.GDIOBJECTS;
pub const GR_GDIOBJECTS_PEAK = GET_GUI_RESOURCES_FLAGS.GDIOBJECTS_PEAK;
pub const GR_USEROBJECTS = GET_GUI_RESOURCES_FLAGS.USEROBJECTS;
pub const GR_USEROBJECTS_PEAK = GET_GUI_RESOURCES_FLAGS.USEROBJECTS_PEAK;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MODEMDEVCAPS_DIAL_OPTIONS = extern enum(u32) {
    BILLING = 64,
    DIALTONE = 256,
    QUIET = 128,
    _,
};
pub const DIALOPTION_BILLING = MODEMDEVCAPS_DIAL_OPTIONS.BILLING;
pub const DIALOPTION_DIALTONE = MODEMDEVCAPS_DIAL_OPTIONS.DIALTONE;
pub const DIALOPTION_QUIET = MODEMDEVCAPS_DIAL_OPTIONS.QUIET;

pub const JOB_OBJECT_CPU_RATE_CONTROL = extern enum(u32) {
    CPU_RATE_CONTROL_ENABLE = 1,
    CPU_RATE_CONTROL_WEIGHT_BASED = 2,
    CPU_RATE_CONTROL_HARD_CAP = 4,
    CPU_RATE_CONTROL_NOTIFY = 8,
    _CPU_RATE_CONTROL_MIN_MAX_RATE = 16,
};
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE = JOB_OBJECT_CPU_RATE_CONTROL.CPU_RATE_CONTROL_ENABLE;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED = JOB_OBJECT_CPU_RATE_CONTROL.CPU_RATE_CONTROL_WEIGHT_BASED;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP = JOB_OBJECT_CPU_RATE_CONTROL.CPU_RATE_CONTROL_HARD_CAP;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY = JOB_OBJECT_CPU_RATE_CONTROL.CPU_RATE_CONTROL_NOTIFY;
pub const JOB_OBJECT__CPU_RATE_CONTROL_MIN_MAX_RATE = JOB_OBJECT_CPU_RATE_CONTROL._CPU_RATE_CONTROL_MIN_MAX_RATE;

pub const VDS_NF_PACK = extern enum(u32) {
    ARRIVE = 1,
    DEPART = 2,
    MODIFY = 3,
};
pub const VDS_NF_PACK_ARRIVE = VDS_NF_PACK.ARRIVE;
pub const VDS_NF_PACK_DEPART = VDS_NF_PACK.DEPART;
pub const VDS_NF_PACK_MODIFY = VDS_NF_PACK.MODIFY;

pub const VDS_NF_FILE_SYSTEM = extern enum(u32) {
    MODIFY = 203,
    FORMAT_PROGRESS = 204,
};
pub const VDS_NF_FILE_SYSTEM_MODIFY = VDS_NF_FILE_SYSTEM.MODIFY;
pub const VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS = VDS_NF_FILE_SYSTEM.FORMAT_PROGRESS;

pub const MODEMSETTINGS_SPEAKER_MODE = extern enum(u32) {
    CALLSETUP = 8,
    DIAL = 2,
    OFF = 1,
    ON = 4,
};
pub const MDMSPKR_CALLSETUP = MODEMSETTINGS_SPEAKER_MODE.CALLSETUP;
pub const MDMSPKR_DIAL = MODEMSETTINGS_SPEAKER_MODE.DIAL;
pub const MDMSPKR_OFF = MODEMSETTINGS_SPEAKER_MODE.OFF;
pub const MDMSPKR_ON = MODEMSETTINGS_SPEAKER_MODE.ON;

pub const VDS_NF_CONTROLLER = extern enum(u32) {
    ARRIVE = 103,
    DEPART = 104,
    MODIFY = 350,
    REMOVED = 351,
};
pub const VDS_NF_CONTROLLER_ARRIVE = VDS_NF_CONTROLLER.ARRIVE;
pub const VDS_NF_CONTROLLER_DEPART = VDS_NF_CONTROLLER.DEPART;
pub const VDS_NF_CONTROLLER_MODIFY = VDS_NF_CONTROLLER.MODIFY;
pub const VDS_NF_CONTROLLER_REMOVED = VDS_NF_CONTROLLER.REMOVED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CHANGER_FEATURES = extern enum(u32) {
    BAR_CODE_SCANNER_INSTALLED = 1,
    CARTRIDGE_MAGAZINE = 256,
    CLEANER_ACCESS_NOT_VALID = 262144,
    CLEANER_SLOT = 64,
    CLOSE_IEPORT = 4,
    DEVICE_REINITIALIZE_CAPABLE = 134217728,
    DRIVE_CLEANING_REQUIRED = 65536,
    DRIVE_EMPTY_ON_DOOR_ACCESS = 536870912,
    EXCHANGE_MEDIA = 32,
    INIT_ELEM_STAT_WITH_RANGE = 2,
    KEYPAD_ENABLE_DISABLE = 268435456,
    LOCK_UNLOCK = 128,
    MEDIUM_FLIP = 512,
    OPEN_IEPORT = 8,
    POSITION_TO_ELEMENT = 1024,
    PREDISMOUNT_EJECT_REQUIRED = 131072,
    PREMOUNT_EJECT_REQUIRED = 524288,
    REPORT_IEPORT_STATE = 2048,
    SERIAL_NUMBER_VALID = 67108864,
    STATUS_NON_VOLATILE = 16,
    STORAGE_DRIVE = 4096,
    STORAGE_IEPORT = 8192,
    STORAGE_SLOT = 16384,
    STORAGE_TRANSPORT = 32768,
    VOLUME_ASSERT = 4194304,
    VOLUME_IDENTIFICATION = 1048576,
    VOLUME_REPLACE = 8388608,
    VOLUME_SEARCH = 2097152,
    VOLUME_UNDEFINE = 16777216,
    _,
};
pub const CHANGER_BAR_CODE_SCANNER_INSTALLED = CHANGER_FEATURES.BAR_CODE_SCANNER_INSTALLED;
pub const CHANGER_CARTRIDGE_MAGAZINE = CHANGER_FEATURES.CARTRIDGE_MAGAZINE;
pub const CHANGER_CLEANER_ACCESS_NOT_VALID = CHANGER_FEATURES.CLEANER_ACCESS_NOT_VALID;
pub const CHANGER_CLEANER_SLOT = CHANGER_FEATURES.CLEANER_SLOT;
pub const CHANGER_CLOSE_IEPORT = CHANGER_FEATURES.CLOSE_IEPORT;
pub const CHANGER_DEVICE_REINITIALIZE_CAPABLE = CHANGER_FEATURES.DEVICE_REINITIALIZE_CAPABLE;
pub const CHANGER_DRIVE_CLEANING_REQUIRED = CHANGER_FEATURES.DRIVE_CLEANING_REQUIRED;
pub const CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS = CHANGER_FEATURES.DRIVE_EMPTY_ON_DOOR_ACCESS;
pub const CHANGER_EXCHANGE_MEDIA = CHANGER_FEATURES.EXCHANGE_MEDIA;
pub const CHANGER_INIT_ELEM_STAT_WITH_RANGE = CHANGER_FEATURES.INIT_ELEM_STAT_WITH_RANGE;
pub const CHANGER_KEYPAD_ENABLE_DISABLE = CHANGER_FEATURES.KEYPAD_ENABLE_DISABLE;
pub const CHANGER_LOCK_UNLOCK = CHANGER_FEATURES.LOCK_UNLOCK;
pub const CHANGER_MEDIUM_FLIP = CHANGER_FEATURES.MEDIUM_FLIP;
pub const CHANGER_OPEN_IEPORT = CHANGER_FEATURES.OPEN_IEPORT;
pub const CHANGER_POSITION_TO_ELEMENT = CHANGER_FEATURES.POSITION_TO_ELEMENT;
pub const CHANGER_PREDISMOUNT_EJECT_REQUIRED = CHANGER_FEATURES.PREDISMOUNT_EJECT_REQUIRED;
pub const CHANGER_PREMOUNT_EJECT_REQUIRED = CHANGER_FEATURES.PREMOUNT_EJECT_REQUIRED;
pub const CHANGER_REPORT_IEPORT_STATE = CHANGER_FEATURES.REPORT_IEPORT_STATE;
pub const CHANGER_SERIAL_NUMBER_VALID = CHANGER_FEATURES.SERIAL_NUMBER_VALID;
pub const CHANGER_STATUS_NON_VOLATILE = CHANGER_FEATURES.STATUS_NON_VOLATILE;
pub const CHANGER_STORAGE_DRIVE = CHANGER_FEATURES.STORAGE_DRIVE;
pub const CHANGER_STORAGE_IEPORT = CHANGER_FEATURES.STORAGE_IEPORT;
pub const CHANGER_STORAGE_SLOT = CHANGER_FEATURES.STORAGE_SLOT;
pub const CHANGER_STORAGE_TRANSPORT = CHANGER_FEATURES.STORAGE_TRANSPORT;
pub const CHANGER_VOLUME_ASSERT = CHANGER_FEATURES.VOLUME_ASSERT;
pub const CHANGER_VOLUME_IDENTIFICATION = CHANGER_FEATURES.VOLUME_IDENTIFICATION;
pub const CHANGER_VOLUME_REPLACE = CHANGER_FEATURES.VOLUME_REPLACE;
pub const CHANGER_VOLUME_SEARCH = CHANGER_FEATURES.VOLUME_SEARCH;
pub const CHANGER_VOLUME_UNDEFINE = CHANGER_FEATURES.VOLUME_UNDEFINE;

pub const VDS_NF_DRIVE = extern enum(u32) {
    ARRIVE = 105,
    DEPART = 106,
    MODIFY = 107,
    REMOVED = 354,
};
pub const VDS_NF_DRIVE_ARRIVE = VDS_NF_DRIVE.ARRIVE;
pub const VDS_NF_DRIVE_DEPART = VDS_NF_DRIVE.DEPART;
pub const VDS_NF_DRIVE_MODIFY = VDS_NF_DRIVE.MODIFY;
pub const VDS_NF_DRIVE_REMOVED = VDS_NF_DRIVE.REMOVED;

pub const VDS_NF_PORT = extern enum(u32) {
    ARRIVE = 121,
    DEPART = 122,
    MODIFY = 352,
    REMOVED = 353,
};
pub const VDS_NF_PORT_ARRIVE = VDS_NF_PORT.ARRIVE;
pub const VDS_NF_PORT_DEPART = VDS_NF_PORT.DEPART;
pub const VDS_NF_PORT_MODIFY = VDS_NF_PORT.MODIFY;
pub const VDS_NF_PORT_REMOVED = VDS_NF_PORT.REMOVED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TTTOOLINFO_FLAGS = extern enum(u32) {
    ABSOLUTE = 128,
    CENTERTIP = 2,
    IDISHWND = 1,
    PARSELINKS = 4096,
    RTLREADING = 4,
    SUBCLASS = 16,
    TRACK = 32,
    TRANSPARENT = 256,
    _,
};
pub const TTF_ABSOLUTE = TTTOOLINFO_FLAGS.ABSOLUTE;
pub const TTF_CENTERTIP = TTTOOLINFO_FLAGS.CENTERTIP;
pub const TTF_IDISHWND = TTTOOLINFO_FLAGS.IDISHWND;
pub const TTF_PARSELINKS = TTTOOLINFO_FLAGS.PARSELINKS;
pub const TTF_RTLREADING = TTTOOLINFO_FLAGS.RTLREADING;
pub const TTF_SUBCLASS = TTTOOLINFO_FLAGS.SUBCLASS;
pub const TTF_TRACK = TTTOOLINFO_FLAGS.TRACK;
pub const TTF_TRANSPARENT = TTTOOLINFO_FLAGS.TRANSPARENT;

pub const JOB_OBJECT_TERMINATE_AT_END_ACTION = extern enum(u32) {
    TERMINATE_AT_END_OF_JOB = 0,
    POST_AT_END_OF_JOB = 1,
};
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB = JOB_OBJECT_TERMINATE_AT_END_ACTION.TERMINATE_AT_END_OF_JOB;
pub const JOB_OBJECT_POST_AT_END_OF_JOB = JOB_OBJECT_TERMINATE_AT_END_ACTION.POST_AT_END_OF_JOB;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const COMMPROP_STOP_PARITY = extern enum(u32) {
    STOPBITS_10 = 1,
    STOPBITS_15 = 2,
    STOPBITS_20 = 4,
    PARITY_NONE = 256,
    PARITY_ODD = 512,
    PARITY_EVEN = 1024,
    PARITY_MARK = 2048,
    PARITY_SPACE = 4096,
    _,
};
pub const STOPBITS_10 = COMMPROP_STOP_PARITY.STOPBITS_10;
pub const STOPBITS_15 = COMMPROP_STOP_PARITY.STOPBITS_15;
pub const STOPBITS_20 = COMMPROP_STOP_PARITY.STOPBITS_20;
pub const PARITY_NONE = COMMPROP_STOP_PARITY.PARITY_NONE;
pub const PARITY_ODD = COMMPROP_STOP_PARITY.PARITY_ODD;
pub const PARITY_EVEN = COMMPROP_STOP_PARITY.PARITY_EVEN;
pub const PARITY_MARK = COMMPROP_STOP_PARITY.PARITY_MARK;
pub const PARITY_SPACE = COMMPROP_STOP_PARITY.PARITY_SPACE;

pub const MODEM_SPEAKER_VOLUME = extern enum(u32) {
    HIGH = 2,
    LOW = 0,
    MEDIUM = 1,
};
pub const MDMVOL_HIGH = MODEM_SPEAKER_VOLUME.HIGH;
pub const MDMVOL_LOW = MODEM_SPEAKER_VOLUME.LOW;
pub const MDMVOL_MEDIUM = MODEM_SPEAKER_VOLUME.MEDIUM;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MODEMDEVCAPS_SPEAKER_VOLUME = extern enum(u32) {
    HIGH = 4,
    LOW = 1,
    MEDIUM = 2,
    _,
};
pub const MDMVOLFLAG_HIGH = MODEMDEVCAPS_SPEAKER_VOLUME.HIGH;
pub const MDMVOLFLAG_LOW = MODEMDEVCAPS_SPEAKER_VOLUME.LOW;
pub const MDMVOLFLAG_MEDIUM = MODEMDEVCAPS_SPEAKER_VOLUME.MEDIUM;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const MODEMDEVCAPS_SPEAKER_MODE = extern enum(u32) {
    CALLSETUP = 8,
    DIAL = 2,
    OFF = 1,
    ON = 4,
    _,
};
pub const MDMSPKRFLAG_CALLSETUP = MODEMDEVCAPS_SPEAKER_MODE.CALLSETUP;
pub const MDMSPKRFLAG_DIAL = MODEMDEVCAPS_SPEAKER_MODE.DIAL;
pub const MDMSPKRFLAG_OFF = MODEMDEVCAPS_SPEAKER_MODE.OFF;
pub const MDMSPKRFLAG_ON = MODEMDEVCAPS_SPEAKER_MODE.ON;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CHANGER_ELEMENT_STATUS_FLAGS = extern enum(u32) {
    ACCESS = 8,
    AVOLTAG = 536870912,
    EXCEPT = 4,
    EXENAB = 16,
    FULL = 1,
    ID_VALID = 8192,
    IMPEXP = 2,
    INENAB = 32,
    INVERT = 4194304,
    LUN_VALID = 4096,
    NOT_BUS = 32768,
    PVOLTAG = 268435456,
    SVALID = 8388608,
    PRODUCT_DATA = 64,
    _,
};
pub const ELEMENT_STATUS_ACCESS = CHANGER_ELEMENT_STATUS_FLAGS.ACCESS;
pub const ELEMENT_STATUS_AVOLTAG = CHANGER_ELEMENT_STATUS_FLAGS.AVOLTAG;
pub const ELEMENT_STATUS_EXCEPT = CHANGER_ELEMENT_STATUS_FLAGS.EXCEPT;
pub const ELEMENT_STATUS_EXENAB = CHANGER_ELEMENT_STATUS_FLAGS.EXENAB;
pub const ELEMENT_STATUS_FULL = CHANGER_ELEMENT_STATUS_FLAGS.FULL;
pub const ELEMENT_STATUS_ID_VALID = CHANGER_ELEMENT_STATUS_FLAGS.ID_VALID;
pub const ELEMENT_STATUS_IMPEXP = CHANGER_ELEMENT_STATUS_FLAGS.IMPEXP;
pub const ELEMENT_STATUS_INENAB = CHANGER_ELEMENT_STATUS_FLAGS.INENAB;
pub const ELEMENT_STATUS_INVERT = CHANGER_ELEMENT_STATUS_FLAGS.INVERT;
pub const ELEMENT_STATUS_LUN_VALID = CHANGER_ELEMENT_STATUS_FLAGS.LUN_VALID;
pub const ELEMENT_STATUS_NOT_BUS = CHANGER_ELEMENT_STATUS_FLAGS.NOT_BUS;
pub const ELEMENT_STATUS_PVOLTAG = CHANGER_ELEMENT_STATUS_FLAGS.PVOLTAG;
pub const ELEMENT_STATUS_SVALID = CHANGER_ELEMENT_STATUS_FLAGS.SVALID;
pub const ELEMENT_STATUS_PRODUCT_DATA = CHANGER_ELEMENT_STATUS_FLAGS.PRODUCT_DATA;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const STARTUPINFOW_FLAGS = extern enum(u32) {
    FORCEONFEEDBACK = 64,
    FORCEOFFFEEDBACK = 128,
    PREVENTPINNING = 8192,
    RUNFULLSCREEN = 32,
    TITLEISAPPID = 4096,
    TITLEISLINKNAME = 2048,
    UNTRUSTEDSOURCE = 32768,
    USECOUNTCHARS = 8,
    USEFILLATTRIBUTE = 16,
    USEHOTKEY = 512,
    USEPOSITION = 4,
    USESHOWWINDOW = 1,
    USESIZE = 2,
    USESTDHANDLES = 256,
    _,
};
pub const STARTF_FORCEONFEEDBACK = STARTUPINFOW_FLAGS.FORCEONFEEDBACK;
pub const STARTF_FORCEOFFFEEDBACK = STARTUPINFOW_FLAGS.FORCEOFFFEEDBACK;
pub const STARTF_PREVENTPINNING = STARTUPINFOW_FLAGS.PREVENTPINNING;
pub const STARTF_RUNFULLSCREEN = STARTUPINFOW_FLAGS.RUNFULLSCREEN;
pub const STARTF_TITLEISAPPID = STARTUPINFOW_FLAGS.TITLEISAPPID;
pub const STARTF_TITLEISLINKNAME = STARTUPINFOW_FLAGS.TITLEISLINKNAME;
pub const STARTF_UNTRUSTEDSOURCE = STARTUPINFOW_FLAGS.UNTRUSTEDSOURCE;
pub const STARTF_USECOUNTCHARS = STARTUPINFOW_FLAGS.USECOUNTCHARS;
pub const STARTF_USEFILLATTRIBUTE = STARTUPINFOW_FLAGS.USEFILLATTRIBUTE;
pub const STARTF_USEHOTKEY = STARTUPINFOW_FLAGS.USEHOTKEY;
pub const STARTF_USEPOSITION = STARTUPINFOW_FLAGS.USEPOSITION;
pub const STARTF_USESHOWWINDOW = STARTUPINFOW_FLAGS.USESHOWWINDOW;
pub const STARTF_USESIZE = STARTUPINFOW_FLAGS.USESIZE;
pub const STARTF_USESTDHANDLES = STARTUPINFOW_FLAGS.USESTDHANDLES;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH = extern enum(u32) {
    ABS_BLK_IMMED = 2147491840,
    ABSOLUTE_BLK = 2147487744,
    END_OF_DATA = 2147549184,
    FILEMARKS = 2147745792,
    LOAD_UNLOAD = 2147483649,
    LOAD_UNLD_IMMED = 2147483680,
    LOCK_UNLOCK = 2147483652,
    LOCK_UNLK_IMMED = 2147483776,
    LOG_BLK_IMMED = 2147516416,
    LOGICAL_BLK = 2147500032,
    RELATIVE_BLKS = 2147614720,
    REVERSE_POSITION = 2151677952,
    REWIND_IMMEDIATE = 2147483656,
    SEQUENTIAL_FMKS = 2148007936,
    SEQUENTIAL_SMKS = 2149580800,
    SET_BLOCK_SIZE = 2147483664,
    SET_COMPRESSION = 2147484160,
    SET_ECC = 2147483904,
    SET_PADDING = 2147484672,
    SET_REPORT_SMKS = 2147485696,
    SETMARKS = 2148532224,
    SPACE_IMMEDIATE = 2155872256,
    TENSION = 2147483650,
    TENSION_IMMED = 2147483712,
    WRITE_FILEMARKS = 2181038080,
    WRITE_LONG_FMKS = 2281701376,
    WRITE_MARK_IMMED = 2415919104,
    WRITE_SETMARKS = 2164260864,
    WRITE_SHORT_FMKS = 2214592512,
    _,
};
pub const TAPE_DRIVE_ABS_BLK_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.ABS_BLK_IMMED;
pub const TAPE_DRIVE_ABSOLUTE_BLK = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.ABSOLUTE_BLK;
pub const TAPE_DRIVE_END_OF_DATA = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.END_OF_DATA;
pub const TAPE_DRIVE_FILEMARKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.FILEMARKS;
pub const TAPE_DRIVE_LOAD_UNLOAD = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOAD_UNLOAD;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOAD_UNLD_IMMED;
pub const TAPE_DRIVE_LOCK_UNLOCK = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOCK_UNLOCK;
pub const TAPE_DRIVE_LOCK_UNLK_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOCK_UNLK_IMMED;
pub const TAPE_DRIVE_LOG_BLK_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOG_BLK_IMMED;
pub const TAPE_DRIVE_LOGICAL_BLK = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.LOGICAL_BLK;
pub const TAPE_DRIVE_RELATIVE_BLKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.RELATIVE_BLKS;
pub const TAPE_DRIVE_REVERSE_POSITION = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.REVERSE_POSITION;
pub const TAPE_DRIVE_REWIND_IMMEDIATE = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.REWIND_IMMEDIATE;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SEQUENTIAL_FMKS;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SEQUENTIAL_SMKS;
pub const TAPE_DRIVE_SET_BLOCK_SIZE = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SET_BLOCK_SIZE;
pub const TAPE_DRIVE_SET_COMPRESSION = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SET_COMPRESSION;
pub const TAPE_DRIVE_SET_ECC = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SET_ECC;
pub const TAPE_DRIVE_SET_PADDING = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SET_PADDING;
pub const TAPE_DRIVE_SET_REPORT_SMKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SET_REPORT_SMKS;
pub const TAPE_DRIVE_SETMARKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SETMARKS;
pub const TAPE_DRIVE_SPACE_IMMEDIATE = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.SPACE_IMMEDIATE;
pub const TAPE_DRIVE_TENSION = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.TENSION;
pub const TAPE_DRIVE_TENSION_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.TENSION_IMMED;
pub const TAPE_DRIVE_WRITE_FILEMARKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.WRITE_FILEMARKS;
pub const TAPE_DRIVE_WRITE_LONG_FMKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.WRITE_LONG_FMKS;
pub const TAPE_DRIVE_WRITE_MARK_IMMED = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.WRITE_MARK_IMMED;
pub const TAPE_DRIVE_WRITE_SETMARKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.WRITE_SETMARKS;
pub const TAPE_DRIVE_WRITE_SHORT_FMKS = TAPE_GET_DRIVE_PARAMETERS_FEATURES_HIGH.WRITE_SHORT_FMKS;

pub const MEMORY_PRIORITY = extern enum(u32) {
    VERY_LOW = 1,
    LOW = 2,
    MEDIUM = 3,
    BELOW_NORMAL = 4,
    NORMAL = 5,
};
pub const MEMORY_PRIORITY_VERY_LOW = MEMORY_PRIORITY.VERY_LOW;
pub const MEMORY_PRIORITY_LOW = MEMORY_PRIORITY.LOW;
pub const MEMORY_PRIORITY_MEDIUM = MEMORY_PRIORITY.MEDIUM;
pub const MEMORY_PRIORITY_BELOW_NORMAL = MEMORY_PRIORITY.BELOW_NORMAL;
pub const MEMORY_PRIORITY_NORMAL = MEMORY_PRIORITY.NORMAL;

pub const VDS_NF_LUN = extern enum(u32) {
    ARRIVE = 108,
    DEPART = 109,
    MODIFY = 110,
};
pub const VDS_NF_LUN_ARRIVE = VDS_NF_LUN.ARRIVE;
pub const VDS_NF_LUN_DEPART = VDS_NF_LUN.DEPART;
pub const VDS_NF_LUN_MODIFY = VDS_NF_LUN.MODIFY;

pub const WIN_STREAM_ID = extern enum(u32) {
    ALTERNATE_DATA = 4,
    DATA = 1,
    EA_DATA = 2,
    LINK = 5,
    OBJECT_ID = 7,
    PROPERTY_DATA = 6,
    REPARSE_DATA = 8,
    SECURITY_DATA = 3,
    SPARSE_BLOCK = 9,
    TXFS_DATA = 10,
};
pub const BACKUP_ALTERNATE_DATA = WIN_STREAM_ID.ALTERNATE_DATA;
pub const BACKUP_DATA = WIN_STREAM_ID.DATA;
pub const BACKUP_EA_DATA = WIN_STREAM_ID.EA_DATA;
pub const BACKUP_LINK = WIN_STREAM_ID.LINK;
pub const BACKUP_OBJECT_ID = WIN_STREAM_ID.OBJECT_ID;
pub const BACKUP_PROPERTY_DATA = WIN_STREAM_ID.PROPERTY_DATA;
pub const BACKUP_REPARSE_DATA = WIN_STREAM_ID.REPARSE_DATA;
pub const BACKUP_SECURITY_DATA = WIN_STREAM_ID.SECURITY_DATA;
pub const BACKUP_SPARSE_BLOCK = WIN_STREAM_ID.SPARSE_BLOCK;
pub const BACKUP_TXFS_DATA = WIN_STREAM_ID.TXFS_DATA;

pub const PROCESS_PROTECTION_LEVEL = extern enum(u32) {
    WINTCB_LIGHT = 0,
    WINDOWS = 1,
    WINDOWS_LIGHT = 2,
    ANTIMALWARE_LIGHT = 3,
    LSA_LIGHT = 4,
    WINTCB = 5,
    CODEGEN_LIGHT = 6,
    AUTHENTICODE = 7,
    PPL_APP = 8,
    NONE = 4294967294,
};
pub const PROTECTION_LEVEL_WINTCB_LIGHT = PROCESS_PROTECTION_LEVEL.WINTCB_LIGHT;
pub const PROTECTION_LEVEL_WINDOWS = PROCESS_PROTECTION_LEVEL.WINDOWS;
pub const PROTECTION_LEVEL_WINDOWS_LIGHT = PROCESS_PROTECTION_LEVEL.WINDOWS_LIGHT;
pub const PROTECTION_LEVEL_ANTIMALWARE_LIGHT = PROCESS_PROTECTION_LEVEL.ANTIMALWARE_LIGHT;
pub const PROTECTION_LEVEL_LSA_LIGHT = PROCESS_PROTECTION_LEVEL.LSA_LIGHT;
pub const PROTECTION_LEVEL_WINTCB = PROCESS_PROTECTION_LEVEL.WINTCB;
pub const PROTECTION_LEVEL_CODEGEN_LIGHT = PROCESS_PROTECTION_LEVEL.CODEGEN_LIGHT;
pub const PROTECTION_LEVEL_AUTHENTICODE = PROCESS_PROTECTION_LEVEL.AUTHENTICODE;
pub const PROTECTION_LEVEL_PPL_APP = PROCESS_PROTECTION_LEVEL.PPL_APP;
pub const PROTECTION_LEVEL_NONE = PROCESS_PROTECTION_LEVEL.NONE;

pub const DEV_BROADCAST_HDR_DEVICE_TYPE = extern enum(u32) {
    DEVICEINTERFACE = 5,
    HANDLE = 6,
    OEM = 0,
    PORT = 3,
    VOLUME = 2,
};
pub const DBT_DEVTYP_DEVICEINTERFACE = DEV_BROADCAST_HDR_DEVICE_TYPE.DEVICEINTERFACE;
pub const DBT_DEVTYP_HANDLE = DEV_BROADCAST_HDR_DEVICE_TYPE.HANDLE;
pub const DBT_DEVTYP_OEM = DEV_BROADCAST_HDR_DEVICE_TYPE.OEM;
pub const DBT_DEVTYP_PORT = DEV_BROADCAST_HDR_DEVICE_TYPE.PORT;
pub const DBT_DEVTYP_VOLUME = DEV_BROADCAST_HDR_DEVICE_TYPE.VOLUME;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GET_CHANGER_PARAMETERS_FEATURES1 = extern enum(u32) {
    CLEANER_AUTODISMOUNT = 2147483652,
    CLEANER_OPS_NOT_SUPPORTED = 2147483712,
    IEPORT_USER_CONTROL_CLOSE = 2147483904,
    IEPORT_USER_CONTROL_OPEN = 2147483776,
    MOVE_EXTENDS_IEPORT = 2147484160,
    MOVE_RETRACTS_IEPORT = 2147484672,
    PREDISMOUNT_ALIGN_TO_DRIVE = 2147483650,
    PREDISMOUNT_ALIGN_TO_SLOT = 2147483649,
    RTN_MEDIA_TO_ORIGINAL_ADDR = 2147483680,
    SLOTS_USE_TRAYS = 2147483664,
    TRUE_EXCHANGE_CAPABLE = 2147483656,
    _,
};
pub const CHANGER_CLEANER_AUTODISMOUNT = GET_CHANGER_PARAMETERS_FEATURES1.CLEANER_AUTODISMOUNT;
pub const CHANGER_CLEANER_OPS_NOT_SUPPORTED = GET_CHANGER_PARAMETERS_FEATURES1.CLEANER_OPS_NOT_SUPPORTED;
pub const CHANGER_IEPORT_USER_CONTROL_CLOSE = GET_CHANGER_PARAMETERS_FEATURES1.IEPORT_USER_CONTROL_CLOSE;
pub const CHANGER_IEPORT_USER_CONTROL_OPEN = GET_CHANGER_PARAMETERS_FEATURES1.IEPORT_USER_CONTROL_OPEN;
pub const CHANGER_MOVE_EXTENDS_IEPORT = GET_CHANGER_PARAMETERS_FEATURES1.MOVE_EXTENDS_IEPORT;
pub const CHANGER_MOVE_RETRACTS_IEPORT = GET_CHANGER_PARAMETERS_FEATURES1.MOVE_RETRACTS_IEPORT;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE = GET_CHANGER_PARAMETERS_FEATURES1.PREDISMOUNT_ALIGN_TO_DRIVE;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_SLOT = GET_CHANGER_PARAMETERS_FEATURES1.PREDISMOUNT_ALIGN_TO_SLOT;
pub const CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR = GET_CHANGER_PARAMETERS_FEATURES1.RTN_MEDIA_TO_ORIGINAL_ADDR;
pub const CHANGER_SLOTS_USE_TRAYS = GET_CHANGER_PARAMETERS_FEATURES1.SLOTS_USE_TRAYS;
pub const CHANGER_TRUE_EXCHANGE_CAPABLE = GET_CHANGER_PARAMETERS_FEATURES1.TRUE_EXCHANGE_CAPABLE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const POWER_ACTION_POLICY_EVENT_CODE = extern enum(u32) {
    FORCE_TRIGGER_RESET = 2147483648,
    LEVEL_USER_NOTIFY_EXEC = 4,
    LEVEL_USER_NOTIFY_SOUND = 2,
    LEVEL_USER_NOTIFY_TEXT = 1,
    USER_NOTIFY_BUTTON = 8,
    USER_NOTIFY_SHUTDOWN = 16,
    _,
};
pub const POWER_FORCE_TRIGGER_RESET = POWER_ACTION_POLICY_EVENT_CODE.FORCE_TRIGGER_RESET;
pub const POWER_LEVEL_USER_NOTIFY_EXEC = POWER_ACTION_POLICY_EVENT_CODE.LEVEL_USER_NOTIFY_EXEC;
pub const POWER_LEVEL_USER_NOTIFY_SOUND = POWER_ACTION_POLICY_EVENT_CODE.LEVEL_USER_NOTIFY_SOUND;
pub const POWER_LEVEL_USER_NOTIFY_TEXT = POWER_ACTION_POLICY_EVENT_CODE.LEVEL_USER_NOTIFY_TEXT;
pub const POWER_USER_NOTIFY_BUTTON = POWER_ACTION_POLICY_EVENT_CODE.USER_NOTIFY_BUTTON;
pub const POWER_USER_NOTIFY_SHUTDOWN = POWER_ACTION_POLICY_EVENT_CODE.USER_NOTIFY_SHUTDOWN;

pub const VDS_NF_DISK = extern enum(u32) {
    ARRIVE = 8,
    DEPART = 9,
    MODIFY = 10,
};
pub const VDS_NF_DISK_ARRIVE = VDS_NF_DISK.ARRIVE;
pub const VDS_NF_DISK_DEPART = VDS_NF_DISK.DEPART;
pub const VDS_NF_DISK_MODIFY = VDS_NF_DISK.MODIFY;

pub const DEV_BROADCAST_VOLUME_FLAGS = extern enum(u32) {
    MEDIA = 1,
    NET = 2,
};
pub const DBTF_MEDIA = DEV_BROADCAST_VOLUME_FLAGS.MEDIA;
pub const DBTF_NET = DEV_BROADCAST_VOLUME_FLAGS.NET;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const CERT_VIEWPROPERTIES_STRUCT_FLAGS = extern enum(u32) {
    ENABLEHOOK = 1,
    SHOW_HELP = 2,
    SHOW_HELPICON = 4,
    ENABLETEMPLATE = 8,
    HIDE_ADVANCEPAGE = 16,
    HIDE_TRUSTPAGE = 32,
    NO_NAMECHANGE = 64,
    NO_EDITTRUST = 128,
    HIDE_DETAILPAGE = 256,
    ADD_CERT_STORES = 512,
    _,
};
pub const CM_ENABLEHOOK = CERT_VIEWPROPERTIES_STRUCT_FLAGS.ENABLEHOOK;
pub const CM_SHOW_HELP = CERT_VIEWPROPERTIES_STRUCT_FLAGS.SHOW_HELP;
pub const CM_SHOW_HELPICON = CERT_VIEWPROPERTIES_STRUCT_FLAGS.SHOW_HELPICON;
pub const CM_ENABLETEMPLATE = CERT_VIEWPROPERTIES_STRUCT_FLAGS.ENABLETEMPLATE;
pub const CM_HIDE_ADVANCEPAGE = CERT_VIEWPROPERTIES_STRUCT_FLAGS.HIDE_ADVANCEPAGE;
pub const CM_HIDE_TRUSTPAGE = CERT_VIEWPROPERTIES_STRUCT_FLAGS.HIDE_TRUSTPAGE;
pub const CM_NO_NAMECHANGE = CERT_VIEWPROPERTIES_STRUCT_FLAGS.NO_NAMECHANGE;
pub const CM_NO_EDITTRUST = CERT_VIEWPROPERTIES_STRUCT_FLAGS.NO_EDITTRUST;
pub const CM_HIDE_DETAILPAGE = CERT_VIEWPROPERTIES_STRUCT_FLAGS.HIDE_DETAILPAGE;
pub const CM_ADD_CERT_STORES = CERT_VIEWPROPERTIES_STRUCT_FLAGS.ADD_CERT_STORES;

pub const POWER_REQUEST_CONTEXT_FLAGS = extern enum(u32) {
    DETAILED_STRING = 2,
    SIMPLE_STRING = 1,
};
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING = POWER_REQUEST_CONTEXT_FLAGS.DETAILED_STRING;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING = POWER_REQUEST_CONTEXT_FLAGS.SIMPLE_STRING;


//--------------------------------------------------------------------------------
// Section: Functions (932)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlGetNonVolatileToken(
    // TODO: what to do with BytesParamIndex 1?
    NvBuffer: *c_void,
    Size: usize,
    NvToken: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlFreeNonVolatileToken(
    NvToken: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlFlushNonVolatileMemory(
    NvToken: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    NvBuffer: *c_void,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlDrainNonVolatileFlush(
    NvToken: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlWriteNonVolatileMemory(
    NvToken: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    NvDestination: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    Source: *const c_void,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlFillNonVolatileMemory(
    NvToken: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    NvDestination: *c_void,
    Size: usize,
    Value: u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "ntdll" fn RtlFlushNonVolatileMemoryRanges(
    NvToken: *c_void,
    NvRanges: [*]NV_MEMORY_RANGE,
    NumRanges: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlCaptureContext2(
    ContextRecord: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub extern "KERNEL32" fn RtlCompareMemory(
    Source1: *const c_void,
    Source2: *const c_void,
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlInitializeSListHead(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlFirstEntrySList(
    ListHead: *const SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlInterlockedPopEntrySList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlInterlockedPushEntrySList(
    ListHead: *SLIST_HEADER,
    ListEntry: *SLIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

pub extern "ntdll" fn RtlInterlockedPushListSListEx(
    ListHead: *SLIST_HEADER,
    List: *SLIST_ENTRY,
    ListEnd: *SLIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlInterlockedFlushSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlQueryDepthSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "ntdll" fn RtlGetReturnAddressHijackTarget(
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "ntdll" fn RtlGetProductInfo(
    OSMajorVersion: u32,
    OSMinorVersion: u32,
    SpMajorVersion: u32,
    SpMinorVersion: u32,
    ReturnedProductType: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlCrc32(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *const c_void,
    Size: usize,
    InitialCrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlCrc64(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: *const c_void,
    Size: usize,
    InitialCrc: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "ntdll" fn RtlOsDeploymentState(
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) OS_DEPLOYEMENT_STATE_VALUES;

pub extern "ntdll" fn RtlInitializeCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
    Version: i32,
    Guid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlIncrementCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlExtendCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlValidateCorrelationVector(
    Vector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlRaiseCustomSystemEventTrigger(
    TriggerConfig: *CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlIsZeroMemory(
    Buffer: *c_void,
    Length: usize,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlNormalizeSecurityDescriptor(
    SecurityDescriptor: **SECURITY_DESCRIPTOR,
    SecurityDescriptorLength: u32,
    NewSecurityDescriptor: ?*?*SECURITY_DESCRIPTOR,
    NewSecurityDescriptorLength: ?*u32,
    CheckOnly: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlGetDeviceFamilyInfoEnum(
    pullUAPInfo: ?*u64,
    pulDeviceFamily: ?*u32,
    pulDeviceForm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlConvertDeviceFamilyInfoToString(
    pulDeviceFamilyBufferSize: *u32,
    pulDeviceFormBufferSize: *u32,
    // TODO: what to do with BytesParamIndex 0?
    DeviceFamily: PWSTR,
    // TODO: what to do with BytesParamIndex 1?
    DeviceForm: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlSwitchedVVI(
    VersionInfo: *OSVERSIONINFOEXW,
    TypeMask: u32,
    ConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FlsAlloc(
    lpCallback: ?PFLS_CALLBACK_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FlsGetValue(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FlsSetValue(
    dwFlsIndex: u32,
    lpFlsData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FlsFree(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsThreadAFiber(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitializeSRWLock(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ReleaseSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ReleaseSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AcquireSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AcquireSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn TryAcquireSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn TryAcquireSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InitializeCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LeaveCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InitializeCriticalSectionAndSpinCount(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitializeCriticalSectionEx(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCriticalSectionSpinCount(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TryEnterCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitOnceInitialize(
    InitOnce: *RTL_RUN_ONCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitOnceExecuteOnce(
    InitOnce: *RTL_RUN_ONCE,
    InitFn: PINIT_ONCE_FN,
    Parameter: ?*c_void,
    Context: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitOnceBeginInitialize(
    lpInitOnce: *RTL_RUN_ONCE,
    dwFlags: u32,
    fPending: *BOOL,
    lpContext: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitOnceComplete(
    lpInitOnce: *RTL_RUN_ONCE,
    dwFlags: u32,
    lpContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitializeConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WakeConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WakeAllConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SleepConditionVariableCS(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
    CriticalSection: *RTL_CRITICAL_SECTION,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SleepConditionVariableSRW(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
    SRWLock: *RTL_SRWLOCK,
    dwMilliseconds: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ResetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReleaseSemaphore(
    hSemaphore: HANDLE,
    lReleaseCount: i32,
    lpPreviousCount: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReleaseMutex(
    hMutex: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitForSingleObject(
    hHandle: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) WAIT_RETURN_CAUSE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SleepEx(
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitForSingleObjectEx(
    hHandle: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) WAIT_RETURN_CAUSE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitForMultipleObjectsEx(
    nCount: u32,
    lpHandles: [*]const HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) WAIT_RETURN_CAUSE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateMutexA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateMutexW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenMutexW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateEventA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateEventW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenEventA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenEventW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenSemaphoreW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenWaitableTimerW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetWaitableTimerEx(
    hTimer: HANDLE,
    lpDueTime: *const LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: ?PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*c_void,
    WakeContext: ?*REASON_CONTEXT,
    TolerableDelay: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetWaitableTimer(
    hTimer: HANDLE,
    lpDueTime: *const LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: ?PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*c_void,
    fResume: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CancelWaitableTimer(
    hTimer: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateMutexExA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateMutexExW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateEventExA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
    dwFlags: CREATE_EVENT,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateEventExW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
    dwFlags: CREATE_EVENT,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSemaphoreExW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateWaitableTimerExW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn EnterSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn InitializeSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
    lTotalThreads: i32,
    lSpinCount: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn DeleteSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn Sleep(
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "vertdll" fn WaitOnAddress(
    // TODO: what to do with BytesParamIndex 2?
    Address: *c_void,
    // TODO: what to do with BytesParamIndex 2?
    CompareAddress: *c_void,
    AddressSize: usize,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "vertdll" fn WakeByAddressSingle(
    Address: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "vertdll" fn WakeByAddressAll(
    Address: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitForMultipleObjects(
    nCount: u32,
    lpHandles: [*]const HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) WAIT_RETURN_CAUSE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateSemaphoreW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateWaitableTimerW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InitializeSListHead(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InterlockedPopEntrySList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InterlockedPushEntrySList(
    ListHead: *SLIST_HEADER,
    ListEntry: *SLIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn InterlockedPushListSListEx(
    ListHead: *SLIST_HEADER,
    List: *SLIST_ENTRY,
    ListEnd: *SLIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn InterlockedFlushSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SLIST_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryDepthSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueueUserWorkItem(
    Function: LPTHREAD_START_ROUTINE,
    Context: ?*c_void,
    Flags: WORKER_THREAD_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnregisterWaitEx(
    WaitHandle: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateTimerQueue(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateTimerQueueTimer(
    phNewTimer: *HANDLE,
    TimerQueue: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Parameter: ?*c_void,
    DueTime: u32,
    Period: u32,
    Flags: WORKER_THREAD_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ChangeTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    DueTime: u32,
    Period: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteTimerQueueEx(
    TimerQueue: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpool(
    reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) PTP_POOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadpoolThreadMaximum(
    ptpp: PTP_POOL,
    cthrdMost: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadpoolThreadMinimum(
    ptpp: PTP_POOL,
    cthrdMic: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: *TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn QueryThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: *TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpool(
    ptpp: PTP_POOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpoolCleanupGroup(
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolCleanupGroupMembers(
    ptpcg: isize,
    fCancelPendingCallbacks: BOOL,
    pvCleanupContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolCleanupGroup(
    ptpcg: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetEventWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    evt: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ReleaseSemaphoreWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    sem: HANDLE,
    crel: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ReleaseMutexWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    mut: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn LeaveCriticalSectionWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    pcs: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FreeLibraryWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    mod: isize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CallbackMayRunLong(
    pci: *TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn DisassociateCurrentThreadFromCallback(
    pci: *TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn TrySubmitThreadpoolCallback(
    pfns: PTP_SIMPLE_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpoolWork(
    pfnwk: PTP_WORK_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_WORK;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SubmitThreadpoolWork(
    pwk: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WaitForThreadpoolWorkCallbacks(
    pwk: *TP_WORK,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolWork(
    pwk: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpoolTimer(
    pfnti: PTP_TIMER_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_TIMER;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadpoolTimer(
    pti: *TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsThreadpoolTimerSet(
    pti: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WaitForThreadpoolTimerCallbacks(
    pti: *TP_TIMER,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolTimer(
    pti: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpoolWait(
    pfnwa: PTP_WAIT_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_WAIT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadpoolWait(
    pwa: *TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WaitForThreadpoolWaitCallbacks(
    pwa: *TP_WAIT,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolWait(
    pwa: *TP_WAIT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateThreadpoolIo(
    fl: HANDLE,
    pfnio: PTP_WIN32_IO_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_IO;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn StartThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CancelThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn WaitForThreadpoolIoCallbacks(
    pio: *TP_IO,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CloseThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetThreadpoolTimerEx(
    pti: *TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetThreadpoolWaitEx(
    pwa: *TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
    Reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsProcessInJob(
    ProcessHandle: HANDLE,
    JobHandle: HANDLE,
    Result: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateJobObjectW(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn FreeMemoryJobObject(
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenJobObjectW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AssignProcessToJobObject(
    hJob: HANDLE,
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TerminateJobObject(
    hJob: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpJobObjectInformation: *c_void,
    cbJobObjectInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn SetIoRateControlInformationJobObject(
    hJob: HANDLE,
    IoRateControlInfo: *JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpJobObjectInformation: *c_void,
    cbJobObjectInformationLength: u32,
    lpReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn QueryIoRateControlInformationJobObject(
    hJob: HANDLE,
    VolumeName: ?[*:0]const u16,
    InfoBlocks: **JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
    InfoBlockCount: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreatePrivateNamespaceW(
    lpPrivateNamespaceAttributes: ?*SECURITY_ATTRIBUTES,
    lpBoundaryDescriptor: *c_void,
    lpAliasPrefix: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

pub extern "KERNEL32" fn OpenPrivateNamespaceW(
    lpBoundaryDescriptor: *c_void,
    lpAliasPrefix: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ClosePrivateNamespace(
    Handle: NamespaceHandle,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "KERNEL32" fn CreateBoundaryDescriptorW(
    Name: [*:0]const u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AddSIDToBoundaryDescriptor(
    BoundaryDescriptor: *HANDLE,
    RequiredSid: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn DeleteBoundaryDescriptor(
    BoundaryDescriptor: BoundaryDescriptorHandle,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumaHighestNodeNumber(
    HighestNodeNumber: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNumaNodeProcessorMaskEx(
    Node: u16,
    ProcessorMask: *GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNumaProximityNodeEx(
    ProximityId: u32,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetProcessGroupAffinity(
    hProcess: HANDLE,
    GroupCount: *u16,
    GroupArray: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: *GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: *const GROUP_AFFINITY,
    PreviousGroupAffinity: ?*GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CreatePipe(
    hReadPipe: *HANDLE,
    hWritePipe: *HANDLE,
    lpPipeAttributes: ?*SECURITY_ATTRIBUTES,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn ConnectNamedPipe(
    hNamedPipe: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn DisconnectNamedPipe(
    hNamedPipe: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetNamedPipeHandleState(
    hNamedPipe: HANDLE,
    lpMode: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn PeekNamedPipe(
    hNamedPipe: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*c_void,
    nBufferSize: u32,
    lpBytesRead: ?*u32,
    lpTotalBytesAvail: ?*u32,
    lpBytesLeftThisMessage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn TransactNamedPipe(
    hNamedPipe: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpInBuffer: ?*c_void,
    nInBufferSize: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpOutBuffer: ?*c_void,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateNamedPipeW(
    lpName: [*:0]const u16,
    dwOpenMode: u32,
    dwPipeMode: u32,
    nMaxInstances: u32,
    nOutBufferSize: u32,
    nInBufferSize: u32,
    nDefaultTimeOut: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn WaitNamedPipeW(
    lpNamedPipeName: [*:0]const u16,
    nTimeOut: WAIT_NAMED_PIPE_TIME_OUT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeClientComputerNameW(
    Pipe: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    ClientComputerName: PWSTR,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetNamedPipeInfo(
    hNamedPipe: HANDLE,
    lpFlags: ?*NAMED_PIPE_INFO_FLAGS,
    lpOutBufferSize: ?*u32,
    lpInBufferSize: ?*u32,
    lpMaxInstances: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeHandleStateW(
    hNamedPipe: HANDLE,
    lpState: ?*NAMED_PIPE_HANDLE_STATE,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?[*:0]u16,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CallNamedPipeW(
    lpNamedPipeName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpInBuffer: ?*c_void,
    nInBufferSize: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpOutBuffer: ?*c_void,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapCreate(
    flOptions: HEAP_FLAGS,
    dwInitialSize: usize,
    dwMaximumSize: usize,
) callconv(@import("std").os.windows.WINAPI) HeapHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapDestroy(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapAlloc(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapReAlloc(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*c_void,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapFree(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapSize(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessHeap(
) callconv(@import("std").os.windows.WINAPI) ProcessHeapHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapCompact(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapSetInformation(
    HeapHandle: HeapHandle,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    HeapInformation: ?*c_void,
    HeapInformationLength: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapValidate(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapSummary(
    hHeap: HANDLE,
    dwFlags: u32,
    lpSummary: *HEAP_SUMMARY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessHeaps(
    NumberOfHeaps: u32,
    ProcessHeaps: [*]ProcessHeapHandle,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapLock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapUnlock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapWalk(
    hHeap: HeapHandle,
    lpEntry: *PROCESS_HEAP_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapQueryInformation(
    HeapHandle: HeapHandle,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    HeapInformation: ?*c_void,
    HeapInformationLength: usize,
    ReturnLength: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualAlloc(
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualProtect(
    lpAddress: *c_void,
    dwSize: usize,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualFree(
    lpAddress: *c_void,
    dwSize: usize,
    dwFreeType: VIRTUAL_FREE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualQuery(
    lpAddress: ?*const c_void,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *MEMORY_BASIC_INFORMATION,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualAllocEx(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualProtectEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: usize,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualQueryEx(
    hProcess: HANDLE,
    lpAddress: ?*const c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *MEMORY_BASIC_INFORMATION,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenFileMappingW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: FILE_MAP,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapViewOfFileEx(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: FILE_MAP,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: usize,
    lpBaseAddress: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualFreeEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: usize,
    dwFreeType: VIRTUAL_FREE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FlushViewOfFile(
    lpBaseAddress: *const c_void,
    dwNumberOfBytesToFlush: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnmapViewOfFile(
    lpBaseAddress: *const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLargePageMinimum(
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: *usize,
    lpMaximumWorkingSetSize: *usize,
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: usize,
    dwMaximumWorkingSetSize: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualLock(
    lpAddress: *c_void,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualUnlock(
    lpAddress: *c_void,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetWriteWatch(
    dwFlags: u32,
    lpBaseAddress: *c_void,
    dwRegionSize: usize,
    lpAddresses: ?[*]?*c_void,
    lpdwCount: ?*usize,
    lpdwGranularity: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ResetWriteWatch(
    lpBaseAddress: *c_void,
    dwRegionSize: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateMemoryResourceNotification(
    NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryMemoryResourceNotification(
    ResourceNotificationHandle: HANDLE,
    ResourceState: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemFileCacheSize(
    lpMinimumFileCacheSize: *usize,
    lpMaximumFileCacheSize: *usize,
    lpFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetSystemFileCacheSize(
    MinimumFileCacheSize: usize,
    MaximumFileCacheSize: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateFileMappingNumaW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PrefetchVirtualMemory(
    hProcess: HANDLE,
    NumberOfEntries: usize,
    VirtualAddresses: [*]WIN32_MEMORY_RANGE_ENTRY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CreateFileMappingFromApp(
    hFile: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    PageProtection: PAGE_TYPE,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn MapViewOfFileFromApp(
    hFileMappingObject: HANDLE,
    DesiredAccess: FILE_MAP,
    FileOffset: u64,
    NumberOfBytesToMap: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn UnmapViewOfFileEx(
    BaseAddress: *c_void,
    UnmapFlags: UNMAP_VIEW_OF_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AllocateUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapUserPhysicalPages(
    VirtualAddress: *c_void,
    NumberOfPages: usize,
    PageArray: ?[*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AllocateUserPhysicalPagesNuma(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn VirtualAllocExNuma(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetMemoryErrorHandlingCapabilities(
    Capabilities: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn RegisterBadMemoryNotification(
    Callback: PBAD_MEMORY_CALLBACK_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn UnregisterBadMemoryNotification(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn OfferVirtualMemory(
    VirtualAddress: [*]u8,
    Size: usize,
    Priority: OFFER_PRIORITY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn ReclaimVirtualMemory(
    VirtualAddress: [*]const u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn DiscardVirtualMemory(
    VirtualAddress: [*]u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn SetProcessValidCallTargets(
    hProcess: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: usize,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-7" fn SetProcessValidCallTargetsForMappedView(
    Process: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: usize,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
    Section: HANDLE,
    ExpectedFileOffset: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualAllocFromApp(
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    Protection: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualProtectFromApp(
    Address: *c_void,
    Size: usize,
    NewProtection: u32,
    OldProtection: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn OpenFileMappingFromApp(
    DesiredAccess: u32,
    InheritHandle: BOOL,
    Name: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows10.0.14393'
pub extern "api-ms-win-core-memory-l1-1-4" fn QueryVirtualMemoryInformation(
    Process: HANDLE,
    VirtualAddress: *const c_void,
    MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 4?
    MemoryInformation: *c_void,
    MemoryInformationSize: usize,
    ReturnSize: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*c_void,
    ViewSize: usize,
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-memory-l1-1-5" fn UnmapViewOfFile2(
    Process: HANDLE,
    BaseAddress: *c_void,
    UnmapFlags: UNMAP_VIEW_OF_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-5" fn VirtualUnlockEx(
    Process: HANDLE,
    Address: *c_void,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2FromApp(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3FromApp(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-7" fn CreateFileMapping2(
    File: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    DesiredAccess: u32,
    PageProtection: PAGE_TYPE,
    AllocationAttributes: u32,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn IsEnclaveTypeSupported(
    flEnclaveType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn CreateEnclave(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: usize,
    dwInitialCommitment: usize,
    flEnclaveType: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpEnclaveInformation: *const c_void,
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn LoadEnclaveData(
    hProcess: HANDLE,
    lpAddress: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *const c_void,
    nSize: usize,
    flProtect: u32,
    // TODO: what to do with BytesParamIndex 6?
    lpPageInformation: *const c_void,
    dwInfoLength: u32,
    lpNumberOfBytesWritten: *usize,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn InitializeEnclave(
    hProcess: HANDLE,
    lpAddress: *c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpEnclaveInformation: *const c_void,
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageA(
    lpEnclaveAddress: *c_void,
    lpImageName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageW(
    lpEnclaveAddress: *c_void,
    lpImageName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn CallEnclave(
    lpRoutine: LPENCLAVE_ROUTINE,
    lpParameter: *c_void,
    fWaitForThread: BOOL,
    lpReturnValue: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn TerminateEnclave(
    lpAddress: *c_void,
    fWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "api-ms-win-core-enclave-l1-1-1" fn DeleteEnclave(
    lpAddress: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DisableThreadLibraryCalls(
    hLibModule: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FindResourceExW(
    hModule: isize,
    lpType: [*:0]const u16,
    lpName: [*:0]const u16,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) HRSRC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeLibrary(
    hLibModule: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeLibraryAndExitThread(
    hLibModule: isize,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleFileNameA(
    hModule: isize,
    lpFilename: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleFileNameW(
    hModule: isize,
    lpFilename: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleHandleA(
    lpModuleName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleHandleW(
    lpModuleName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleHandleExA(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetModuleHandleExW(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: *isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcAddress(
    hModule: isize,
    lpProcName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) FARPROC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LoadLibraryExA(
    lpLibFileName: [*:0]const u8,
    hFile: HANDLE,
    dwFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LoadLibraryExW(
    lpLibFileName: [*:0]const u16,
    hFile: HANDLE,
    dwFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn AddDllDirectory(
    NewDirectory: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn RemoveDllDirectory(
    Cookie: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetDefaultDllDirectories(
    DirectoryFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FindResourceW(
    hModule: isize,
    lpName: [*:0]const u16,
    lpType: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRSRC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LoadLibraryA(
    lpLibFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LoadLibraryW(
    lpLibFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) isize;

pub extern "KERNEL32" fn EnumResourceNamesW(
    hModule: isize,
    lpType: [*:0]const u16,
    lpEnumFunc: ENUMRESNAMEPROCW,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AllocConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FreeConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AttachConsole(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCP(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOutputCP(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleMode(
    hConsoleHandle: HANDLE,
    lpMode: *CONSOLE_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleMode(
    hConsoleHandle: HANDLE,
    dwMode: CONSOLE_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumberOfConsoleInputEvents(
    hConsoleInput: HANDLE,
    lpNumberOfEvents: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PeekConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PeekConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleA(
    hConsoleInput: HANDLE,
    lpBuffer: *c_void,
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: *u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleW(
    hConsoleInput: HANDLE,
    lpBuffer: *c_void,
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: *u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleA(
    hConsoleOutput: HANDLE,
    lpBuffer: [*]const u8,
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleW(
    hConsoleOutput: HANDLE,
    lpBuffer: [*]const u8,
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCtrlHandler(
    HandlerRoutine: ?PHANDLER_ROUTINE,
    Add: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreatePseudoConsole(
    size: COORD,
    hInput: HANDLE,
    hOutput: HANDLE,
    dwFlags: u32,
    phPC: *HPCON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ResizePseudoConsole(
    hPC: HPCON,
    size: COORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ClosePseudoConsole(
    hPC: HPCON,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn FillConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    cCharacter: CHAR,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FillConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    cCharacter: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FillConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    wAttribute: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GenerateConsoleCtrlEvent(
    dwCtrlEvent: u32,
    dwProcessGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateConsoleScreenBuffer(
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    dwFlags: u32,
    lpScreenBufferData: *c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn SetConsoleActiveScreenBuffer(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FlushConsoleInputBuffer(
    hConsoleInput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleOutputCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: *CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleScreenBufferInfo(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfo: *CONSOLE_SCREEN_BUFFER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: *CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: *CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleScreenBufferSize(
    hConsoleOutput: HANDLE,
    dwSize: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCursorPosition(
    hConsoleOutput: HANDLE,
    dwCursorPosition: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetLargestConsoleWindowSize(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) COORD;

pub extern "KERNEL32" fn SetConsoleTextAttribute(
    hConsoleOutput: HANDLE,
    wAttributes: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleWindowInfo(
    hConsoleOutput: HANDLE,
    bAbsolute: BOOL,
    lpConsoleWindow: *const SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]const u8,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]const u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: [*:0]const u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]u8,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: [*:0]u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfAttrsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]const INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]const INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ScrollConsoleScreenBufferA(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: ?*const SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: *const CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ScrollConsoleScreenBufferW(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: ?*const SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: *const CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: *const CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: *const CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: *CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: *CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleTitleA(
    lpConsoleTitle: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleTitleW(
    lpConsoleTitle: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOriginalTitleA(
    lpConsoleTitle: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOriginalTitleW(
    lpConsoleTitle: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetConsoleTitleA(
    lpConsoleTitle: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleTitleW(
    lpConsoleTitle: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumberOfConsoleMouseButtons(
    lpNumberOfMouseButtons: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleFontSize(
    hConsoleOutput: HANDLE,
    nFont: u32,
) callconv(@import("std").os.windows.WINAPI) COORD;

pub extern "KERNEL32" fn GetCurrentConsoleFont(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFont: *CONSOLE_FONT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: *CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: *CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleSelectionInfo(
    lpConsoleSelectionInfo: *CONSOLE_SELECTION_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleHistoryInfo(
    lpConsoleHistoryInfo: *CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleHistoryInfo(
    lpConsoleHistoryInfo: *CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleDisplayMode(
    lpModeFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleDisplayMode(
    hConsoleOutput: HANDLE,
    dwFlags: u32,
    lpNewScreenBufferDimensions: ?*COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleWindow(
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "KERNEL32" fn AddConsoleAliasA(
    Source: PSTR,
    Target: PSTR,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AddConsoleAliasW(
    Source: PWSTR,
    Target: PWSTR,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleAliasA(
    Source: PSTR,
    TargetBuffer: [*:0]u8,
    TargetBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasW(
    Source: PWSTR,
    TargetBuffer: [*:0]u16,
    TargetBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesLengthA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesLengthW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesLengthA(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesLengthW(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesA(
    AliasBuffer: [*:0]u8,
    AliasBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesW(
    AliasBuffer: [*:0]u16,
    AliasBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesA(
    ExeNameBuffer: [*:0]u8,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesW(
    ExeNameBuffer: [*:0]u16,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SetConsoleNumberOfCommandsA(
    Number: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleNumberOfCommandsW(
    Number: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryA(
    // TODO: what to do with BytesParamIndex 1?
    Commands: PSTR,
    CommandBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryW(
    // TODO: what to do with BytesParamIndex 1?
    Commands: PWSTR,
    CommandBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleProcessList(
    lpdwProcessList: [*]u32,
    dwProcessCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "RPCNS4" fn I_RpcNsGetBuffer(
    Message: *RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) RPC_STATUS;

pub extern "RPCNS4" fn I_RpcNsSendReceive(
    Message: *RPC_MESSAGE,
    Handle: **c_void,
) callconv(@import("std").os.windows.WINAPI) RPC_STATUS;

pub extern "RPCNS4" fn I_RpcNsRaiseException(
    Message: *RPC_MESSAGE,
    Status: RPC_STATUS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCNS4" fn I_RpcReBindBuffer(
    Message: *RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) RPC_STATUS;

pub extern "WINMM" fn timeSetEvent(
    uDelay: u32,
    uResolution: u32,
    fptc: LPTIMECALLBACK,
    dwUser: usize,
    fuEvent: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeKillEvent(
    uTimerID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrintersA(
    Flags: u32,
    Name: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrinterEnum: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintersW(
    Flags: u32,
    Name: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrinterEnum: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetSpoolFileHandle(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn CommitSpoolData(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
    cbCommit: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn CloseSpoolFileHandle(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinterA(
    pPrinterName: ?PSTR,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinterW(
    pPrinterName: ?PWSTR,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ResetPrinterA(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ResetPrinterW(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumJobsA(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    // TODO: what to do with BytesParamIndex 5?
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumJobsW(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    // TODO: what to do with BytesParamIndex 5?
    pJob: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterA(
    pName: ?PSTR,
    Level: u32,
    pPrinter: *u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn AddPrinterW(
    pName: ?PWSTR,
    Level: u32,
    pPrinter: *u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn DeletePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pPrinter: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pPrinter: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterDriverA(
    pName: ?PSTR,
    Level: u32,
    pDriverInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrinterDriverW(
    pName: ?PWSTR,
    Level: u32,
    pDriverInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterDriverExA(
    pName: ?PSTR,
    Level: u32,
    lpbDriverInfo: *u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrinterDriverExW(
    pName: ?PWSTR,
    Level: u32,
    lpbDriverInfo: *u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrinterDriversA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrinterDriversW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverA(
    hPrinter: HANDLE,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverW(
    hPrinter: HANDLE,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverDirectoryA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverDirectory: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverDirectoryW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDriverDirectory: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterDriverA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pDriverName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrinterDriverW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pDriverName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterDriverExA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pDriverName: PSTR,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrinterDriverExW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pDriverName: PWSTR,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrintProcessorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPathName: PSTR,
    pPrintProcessorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrintProcessorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPathName: PWSTR,
    pPrintProcessorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintProcessorsA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumPrintProcessorsW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrintProcessorDirectoryA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetPrintProcessorDirectoryW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pPrintProcessorInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintProcessorDatatypesA(
    pName: ?PSTR,
    pPrintProcessorName: PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDatatypes: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumPrintProcessorDatatypesW(
    pName: ?PWSTR,
    pPrintProcessorName: PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pDatatypes: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrintProcessorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPrintProcessorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrintProcessorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPrintProcessorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn StartDocPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn StartDocPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn StartPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn WritePrinter(
    hPrinter: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pBuf: *c_void,
    cbBuf: u32,
    pcWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn FlushPrinter(
    hPrinter: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pBuf: ?*c_void,
    cbBuf: u32,
    pcWritten: *u32,
    cSleep: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EndPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AbortPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ReadPrinter(
    hPrinter: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pBuf: *c_void,
    cbBuf: u32,
    pNoBytesRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EndDocPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddJobA(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pData: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddJobW(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pData: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ScheduleJob(
    hPrinter: HANDLE,
    JobId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn PrinterProperties(
    hWnd: HWND,
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PSTR,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn DocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PWSTR,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn AdvancedDocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PSTR,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn AdvancedDocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PWSTR,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn GetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
    pType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
    pType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
    pType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
    pType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pData: ?*u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterDataA(
    hPrinter: HANDLE,
    dwIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pValueName: PSTR,
    cbValueName: u32,
    pcbValueName: *u32,
    pType: ?*u32,
    pData: ?[*:0]u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterDataW(
    hPrinter: HANDLE,
    dwIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pValueName: PWSTR,
    cbValueName: u32,
    pcbValueName: *u32,
    pType: ?*u32,
    pData: ?[*:0]u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pEnumValues: ?*u8,
    cbEnumValues: u32,
    pcbEnumValues: *u32,
    pnEnumValues: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pEnumValues: ?*u8,
    cbEnumValues: u32,
    pcbEnumValues: *u32,
    pnEnumValues: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pSubkey: ?PSTR,
    cbSubkey: u32,
    pcbSubkey: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pSubkey: ?PWSTR,
    cbSubkey: u32,
    pcbSubkey: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
    Type: u32,
    // TODO: what to do with BytesParamIndex 4?
    pData: *u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
    Type: u32,
    // TODO: what to do with BytesParamIndex 4?
    pData: *u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
    Type: u32,
    // TODO: what to do with BytesParamIndex 5?
    pData: *u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
    Type: u32,
    // TODO: what to do with BytesParamIndex 5?
    pData: *u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn DeletePrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn WaitForPrinterChange(
    hPrinter: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn FindFirstPrinterChangeNotification(
    hPrinter: HANDLE,
    fdwFilter: u32,
    fdwOptions: u32,
    pPrinterNotifyOptions: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn FindNextPrinterChangeNotification(
    hChange: HANDLE,
    pdwChange: ?*u32,
    pvReserved: ?*c_void,
    ppPrinterNotifyInfo: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn FreePrinterNotifyInfo(
    pPrinterNotifyInfo: *PRINTER_NOTIFY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn FindClosePrinterChangeNotification(
    hChange: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn PrinterMessageBoxA(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: PSTR,
    pCaption: PSTR,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn PrinterMessageBoxW(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: PWSTR,
    pCaption: PWSTR,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn ClosePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddFormA(
    hPrinter: HANDLE,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddFormW(
    hPrinter: HANDLE,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeleteFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeleteFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 4?
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn SetFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumFormsA(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumFormsW(
    hPrinter: HANDLE,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pForm: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumMonitorsA(
    pName: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pMonitor: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumMonitorsW(
    pName: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pMonitor: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddMonitorA(
    pName: ?PSTR,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddMonitorW(
    pName: ?PWSTR,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeleteMonitorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pMonitorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeleteMonitorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pMonitorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPortsA(
    pName: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pPort: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPortsW(
    pName: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 3?
    pPort: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPortA(
    pName: ?PSTR,
    hWnd: HWND,
    pMonitorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pMonitorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ConfigurePortA(
    pName: ?PSTR,
    hWnd: HWND,
    pPortName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ConfigurePortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pPortName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePortA(
    pName: ?PSTR,
    hWnd: HWND,
    pPortName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pPortName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn XcvDataW(
    hXcv: HANDLE,
    pszDataName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pInputData: ?*u8,
    cbInputData: u32,
    // TODO: what to do with BytesParamIndex 5?
    pOutputData: ?*u8,
    cbOutputData: u32,
    pcbOutputNeeded: *u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetDefaultPrinterA(
    pszBuffer: ?[*:0]u8,
    pcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetDefaultPrinterW(
    pszBuffer: ?[*:0]u16,
    pcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetDefaultPrinterA(
    pszPrinter: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetDefaultPrinterW(
    pszPrinter: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPortA(
    pName: ?PSTR,
    pPortName: PSTR,
    dwLevel: u32,
    pPortInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn SetPortW(
    pName: ?PWSTR,
    pPortName: PWSTR,
    dwLevel: u32,
    pPortInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnectionA(
    pName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnectionW(
    pName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterConnectionA(
    pName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterConnectionW(
    pName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ConnectToPrinterDlg(
    hwnd: HWND,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn AddPrintProvidorA(
    pName: ?PSTR,
    Level: u32,
    pProvidorInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrintProvidorW(
    pName: ?PWSTR,
    Level: u32,
    pProvidorInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrintProvidorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPrintProvidorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrintProvidorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPrintProvidorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn IsValidDevmodeA(
    pDevmode: ?*DEVMODEA,
    DevmodeSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn IsValidDevmodeW(
    pDevmode: ?*DEVMODEW,
    DevmodeSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinter2A(
    pPrinterName: ?[*:0]const u8,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
    pOptions: ?*PRINTER_OPTIONSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn OpenPrinter2W(
    pPrinterName: ?[*:0]const u16,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
    pOptions: ?*PRINTER_OPTIONSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnection2A(
    hWnd: HWND,
    pszName: [*:0]const u8,
    dwLevel: u32,
    pConnectionInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnection2W(
    hWnd: HWND,
    pszName: [*:0]const u16,
    dwLevel: u32,
    pConnectionInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: ?[*:0]const u8,
    pszDriverName: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: ?[*:0]const u16,
    pszDriverName: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn UploadPrinterDriverPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: [*:0]u8,
    pcchDestInfPath: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn UploadPrinterDriverPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: [*:0]u16,
    pcchDestInfPath: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetCorePrinterDriversA(
    pszServer: ?[*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    pszzCoreDriverDependencies: [*:0]const u8,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: [*]CORE_PRINTER_DRIVERA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetCorePrinterDriversW(
    pszServer: ?[*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    pszzCoreDriverDependencies: [*:0]const u16,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: [*]CORE_PRINTER_DRIVERW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// This function from dll 'WINSPOOL' is being skipped because it has some sort of issue
pub fn CorePrinterDriverInstalledA() void { @panic("this function is not working"); }

// This function from dll 'WINSPOOL' is being skipped because it has some sort of issue
pub fn CorePrinterDriverInstalledW() void { @panic("this function is not working"); }

pub extern "WINSPOOL" fn GetPrinterDriverPackagePathA(
    pszServer: ?[*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    pszLanguage: ?[*:0]const u8,
    pszPackageID: [*:0]const u8,
    pszDriverPackageCab: ?[*:0]u8,
    cchDriverPackageCab: u32,
    pcchRequiredSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetPrinterDriverPackagePathW(
    pszServer: ?[*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    pszLanguage: ?[*:0]const u16,
    pszPackageID: [*:0]const u16,
    pszDriverPackageCab: ?[*:0]u16,
    cchDriverPackageCab: u32,
    pcchRequiredSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn DeletePrinterDriverPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn DeletePrinterDriverPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn ReportJobProcessingProgress(
    printerHandle: HANDLE,
    jobId: u32,
    jobOperation: EPrintXPSJobOperation,
    jobProgress: EPrintXPSJobProgress,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetPrinterDriver2A(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?PSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 5?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriver2W(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?PWSTR,
    Level: u32,
    // TODO: what to do with BytesParamIndex 5?
    pDriverInfo: ?*u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrintExecutionData(
    pData: *PRINT_EXECUTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetJobNamedPropertyValue(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: [*:0]const u16,
    pValue: *PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn FreePrintPropertyValue(
    pValue: *PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINSPOOL" fn FreePrintNamedPropertyArray(
    cProperties: u32,
    ppProperties: ?[*]?*PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINSPOOL" fn SetJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pProperty: *const PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn DeleteJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumJobNamedProperties(
    hPrinter: HANDLE,
    JobId: u32,
    pcProperties: *u32,
    ppProperties: **PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrintOutputInfo(
    hWnd: HWND,
    pszPrinter: [*:0]const u16,
    phFile: *HANDLE,
    ppszOutputFile: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "CoreMessaging" fn CreateDispatcherQueueController(
    options: DispatcherQueueOptions,
    dispatcherQueueController: **struct{comment: []const u8 = "MissingClrType DispatcherQueueController.Windows.System"},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "VSSAPI" fn CreateVssExpressWriterInternal(
    ppWriter: **IVssExpressWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "GDI32" fn EngQueryEMFInfo(
    hdev: HDEV,
    pEMFInfo: *EMFINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-libraryloader-l2-1-0" fn QueryOptionalDelayLoadedAPI(
    hParentModule: isize,
    lpDllName: [*:0]const u8,
    lpProcName: [*:0]const u8,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn EnclaveGetAttestationReport(
    EnclaveData: ?*const u8,
    // TODO: what to do with BytesParamIndex 2?
    Report: ?*c_void,
    BufferSize: u32,
    OutputSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn EnclaveVerifyAttestationReport(
    EnclaveType: u32,
    // TODO: what to do with BytesParamIndex 2?
    Report: *const c_void,
    ReportSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn EnclaveSealData(
    // TODO: what to do with BytesParamIndex 1?
    DataToEncrypt: *const c_void,
    DataToEncryptSize: u32,
    IdentityPolicy: ENCLAVE_SEALING_IDENTITY_POLICY,
    RuntimePolicy: u32,
    // TODO: what to do with BytesParamIndex 5?
    ProtectedBlob: ?*c_void,
    BufferSize: u32,
    ProtectedBlobSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn EnclaveUnsealData(
    // TODO: what to do with BytesParamIndex 1?
    ProtectedBlob: *const c_void,
    ProtectedBlobSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    DecryptedData: ?*c_void,
    BufferSize: u32,
    DecryptedDataSize: *u32,
    SealingIdentity: ?*ENCLAVE_IDENTITY,
    UnsealingFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "vertdll" fn EnclaveGetEnclaveInformation(
    InformationSize: u32,
    // TODO: what to do with BytesParamIndex 0?
    EnclaveInformation: *ENCLAVE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn CallNtPowerInformation(
    InformationLevel: POWER_INFORMATION_LEVEL,
    // TODO: what to do with BytesParamIndex 2?
    InputBuffer: ?*c_void,
    InputBufferLength: u32,
    // TODO: what to do with BytesParamIndex 4?
    OutputBuffer: ?*c_void,
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn GetPwrCapabilities(
    lpspc: *SYSTEM_POWER_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "POWRPROF" fn PowerDeterminePlatformRoleEx(
    Version: POWER_PLATFORM_ROLE_VERSION,
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "POWRPROF" fn PowerRegisterSuspendResumeNotification(
    Flags: u32,
    Recipient: HANDLE,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "POWRPROF" fn PowerUnregisterSuspendResumeNotification(
    RegistrationHandle: HPOWERNOTIFY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadACValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    Buffer: ?*u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadDCValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerGetActiveScheme(
    UserRootPowerKey: HKEY,
    ActivePolicyGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerSetActiveScheme(
    UserRootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "POWRPROF" fn PowerSettingRegisterNotification(
    SettingGuid: *Guid,
    Flags: POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
    Recipient: HANDLE,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "POWRPROF" fn PowerSettingUnregisterNotification(
    RegistrationHandle: HPOWERNOTIFY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "POWRPROF" fn PowerRegisterForEffectivePowerModeNotifications(
    Version: u32,
    Callback: EFFECTIVE_POWER_MODE_CALLBACK,
    Context: ?*c_void,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.17763'
pub extern "POWRPROF" fn PowerUnregisterFromEffectivePowerModeNotifications(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn GetPwrDiskSpindownRange(
    puiMax: *u32,
    puiMin: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn EnumPwrSchemes(
    lpfn: PWRSCHEMESENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn ReadGlobalPwrPolicy(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn ReadPwrScheme(
    uiID: u32,
    pPowerPolicy: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn WritePwrScheme(
    puiID: *u32,
    lpszSchemeName: [*:0]const u16,
    lpszDescription: ?[*:0]const u16,
    lpScheme: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn WriteGlobalPwrPolicy(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn DeletePwrScheme(
    uiID: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn GetActivePwrScheme(
    puiID: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn SetActivePwrScheme(
    uiID: u32,
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn IsPwrSuspendAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn IsPwrHibernateAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn IsPwrShutdownAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn IsAdminOverrideActive(
    papp: *ADMINISTRATOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn SetSuspendState(
    bHibernate: u8,
    bForce: u8,
    bWakeupEventsDisabled: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn GetCurrentPowerPolicies(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
    pPowerPolicy: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn CanUserWritePwrScheme(
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn ReadProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: *MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "POWRPROF" fn WriteProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: *MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn ValidatePowerPolicies(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "POWRPROF" fn PowerIsSettingRangeDefined(
    SubKeyGuid: ?*const Guid,
    SettingGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.1'
pub extern "POWRPROF" fn PowerSettingAccessCheckEx(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*const Guid,
    AccessType: REG_SAM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerSettingAccessCheck(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadDescription(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadPossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 6?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadPossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadPossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMinimum: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMaximum: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueIncrement: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReadSettingAttributes(
    SubGroupGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteDescription(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWritePossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: u32,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 6?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWritePossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWritePossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMinimum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMaximum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueIncrement: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    // TODO: what to do with BytesParamIndex 5?
    Buffer: *u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerWriteSettingAttributes(
    SubGroupGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerDuplicateScheme(
    RootPowerKey: HKEY,
    SourceSchemeGuid: *const Guid,
    DestinationSchemeGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerImportPowerScheme(
    RootPowerKey: HKEY,
    ImportFileNamePath: [*:0]const u16,
    DestinationSchemeGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerDeleteScheme(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerRemovePowerSetting(
    PowerSettingSubKeyGuid: *const Guid,
    PowerSettingGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerCreateSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: *const Guid,
    PowerSettingGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerCreatePossibleSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: *const Guid,
    PowerSettingGuid: *const Guid,
    PossibleSettingIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerEnumerate(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    AccessFlags: POWER_DATA_ACCESSOR,
    Index: u32,
    // TODO: what to do with BytesParamIndex 6?
    Buffer: ?*u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerOpenUserPowerKey(
    phUserPowerKey: *HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerOpenSystemPowerKey(
    phSystemPowerKey: *HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerCanRestoreIndividualDefaultPowerScheme(
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerRestoreIndividualDefaultPowerScheme(
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerRestoreDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerReplaceDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn PowerDeterminePlatformRole(
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn DevicePowerEnumDevices(
    QueryIndex: u32,
    QueryInterpretationFlags: u32,
    QueryFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pReturnBuffer: ?*u8,
    pBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn DevicePowerSetDeviceState(
    DeviceDescription: [*:0]const u16,
    SetFlags: u32,
    SetData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn DevicePowerOpen(
    DebugMask: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "POWRPROF" fn DevicePowerClose(
) callconv(@import("std").os.windows.WINAPI) u8;

// TODO: this type is limited to platform 'windows8.0'
pub extern "POWRPROF" fn PowerReportThermalEvent(
    Event: *THERMAL_EVENT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn ExitWindowsEx(
    uFlags: EXIT_WINDOWS_FLAGS,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn IsWow64Message(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn RegisterDeviceNotificationA(
    hRecipient: HANDLE,
    NotificationFilter: *c_void,
    Flags: POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn RegisterDeviceNotificationW(
    hRecipient: HANDLE,
    NotificationFilter: *c_void,
    Flags: POWER_SETTING_REGISTER_NOTIFICATION_FLAGS,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn UnregisterDeviceNotification(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn RegisterPowerSettingNotification(
    hRecipient: HANDLE,
    PowerSettingGuid: *Guid,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HPOWERNOTIFY;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn UnregisterPowerSettingNotification(
    Handle: HPOWERNOTIFY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn RegisterSuspendResumeNotification(
    hRecipient: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HPOWERNOTIFY;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn UnregisterSuspendResumeNotification(
    Handle: HPOWERNOTIFY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn AttachThreadInput(
    idAttach: u32,
    idAttachTo: u32,
    fAttach: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn WaitForInputIdle(
    hProcess: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn MsgWaitForMultipleObjects(
    nCount: u32,
    pHandles: ?[*]const HANDLE,
    fWaitAll: BOOL,
    dwMilliseconds: u32,
    dwWakeMask: QUEUE_STATUS_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn MsgWaitForMultipleObjectsEx(
    nCount: u32,
    pHandles: ?[*]const HANDLE,
    dwMilliseconds: u32,
    dwWakeMask: QUEUE_STATUS_FLAGS,
    dwFlags: MSG_WAIT_FOR_MULTIPLE_OBJECTS_EX_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn GetGuiResources(
    hProcess: HANDLE,
    uiFlags: GET_GUI_RESOURCES_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn LockWorkStation(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn UserHandleGrantAccess(
    hUserHandle: HANDLE,
    hJob: HANDLE,
    bGrant: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ShutdownBlockReasonCreate(
    hWnd: HWND,
    pwszReason: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ShutdownBlockReasonQuery(
    hWnd: HWND,
    pwszBuff: ?[*:0]u16,
    pcchBuff: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USER32" fn ShutdownBlockReasonDestroy(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetAutoRotationState(
    pState: *AR_STATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetDisplayAutoRotationPreferences(
    pOrientation: *ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetDisplayAutoRotationPreferences(
    orientation: ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn IsImmersiveProcess(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "USER32" fn SetProcessRestrictionExemption(
    fEnableExemption: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommandLineA(
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommandLineW(
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetEnvironmentStrings(
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetEnvironmentStringsW(
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeEnvironmentStringsA(
    penv: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeEnvironmentStringsW(
    penv: [*]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetEnvironmentVariableA(
    lpName: ?[*:0]const u8,
    lpBuffer: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetEnvironmentVariableW(
    lpName: ?[*:0]const u16,
    lpBuffer: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathA(
    ExeName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathW(
    ExeName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueueUserAPC(
    pfnAPC: PAPCFUNC,
    hThread: HANDLE,
    dwData: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessTimes(
    hProcess: HANDLE,
    lpCreationTime: *FILETIME,
    lpExitTime: *FILETIME,
    lpKernelTime: *FILETIME,
    lpUserTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) NonClosableHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentProcessId(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ExitProcess(
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) noreturn;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TerminateProcess(
    hProcess: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetExitCodeProcess(
    hProcess: HANDLE,
    lpExitCode: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SwitchToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateThread(
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: usize,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: THREAD_CREATION_FLAGS,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateRemoteThread(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: usize,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: u32,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentThread(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentThreadId(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenThread(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwThreadId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadPriority(
    hThread: HANDLE,
    nPriority: THREAD_PRIORITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadPriorityBoost(
    hThread: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetThreadPriorityBoost(
    hThread: HANDLE,
    pDisablePriorityBoost: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetThreadPriority(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ExitThread(
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TerminateThread(
    hThread: HANDLE,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetExitCodeThread(
    hThread: HANDLE,
    lpExitCode: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SuspendThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ResumeThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TlsAlloc(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TlsGetValue(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TlsSetValue(
    dwTlsIndex: u32,
    lpTlsValue: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TlsFree(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateProcessA(
    lpApplicationName: ?[*:0]const u8,
    lpCommandLine: ?PSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u8,
    lpStartupInfo: *STARTUPINFOA,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateProcessW(
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetProcessShutdownParameters(
    dwLevel: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessVersion(
    ProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetStartupInfoW(
    lpStartupInfo: *STARTUPINFOW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateProcessAsUserW(
    hToken: HANDLE,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetPriorityClass(
    hProcess: HANDLE,
    dwPriorityClass: PROCESS_CREATION_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetPriorityClass(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetThreadStackGuarantee(
    StackSizeInBytes: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessId(
    Process: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetThreadId(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn FlushProcessWriteBuffers(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessIdOfThread(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn InitializeProcThreadAttributeList(
    // TODO: what to do with BytesParamIndex 3?
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
    dwAttributeCount: u32,
    dwFlags: u32,
    lpSize: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn DeleteProcThreadAttributeList(
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn UpdateProcThreadAttribute(
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
    dwFlags: u32,
    Attribute: usize,
    // TODO: what to do with BytesParamIndex 4?
    lpValue: ?*c_void,
    cbSize: usize,
    // TODO: what to do with BytesParamIndex 4?
    lpPreviousValue: ?*c_void,
    lpReturnSize: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetProcessAffinityUpdateMode(
    hProcess: HANDLE,
    dwFlags: PROCESS_AFFINITY_AUTO_UPDATE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryProcessAffinityUpdateMode(
    hProcess: HANDLE,
    lpdwFlags: ?*PROCESS_AFFINITY_AUTO_UPDATE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn CreateRemoteThreadEx(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: usize,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: u32,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentThreadStackLimits(
    LowLimit: *usize,
    HighLimit: *usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetProcessMitigationPolicy(
    hProcess: HANDLE,
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetProcessMitigationPolicy(
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *c_void,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetThreadTimes(
    hThread: HANDLE,
    lpCreationTime: *FILETIME,
    lpExitTime: *FILETIME,
    lpKernelTime: *FILETIME,
    lpUserTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenProcess(
    dwDesiredAccess: PROCESS_ACCESS_RIGHTS,
    bInheritHandle: BOOL,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessHandleCount(
    hProcess: HANDLE,
    pdwHandleCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetCurrentProcessorNumber(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: *PROCESSOR_NUMBER,
    lpPreviousIdealProcessor: ?*PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: *PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetCurrentProcessorNumberEx(
    ProcNumber: *PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessPriorityBoost(
    hProcess: HANDLE,
    pDisablePriorityBoost: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetProcessPriorityBoost(
    hProcess: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetThreadIOPendingFlag(
    hThread: HANDLE,
    lpIOIsPending: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ThreadInformation: *c_void,
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ThreadInformation: *c_void,
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn IsProcessCritical(
    hProcess: HANDLE,
    Critical: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetProtectedPolicy(
    PolicyGuid: *Guid,
    PolicyValue: usize,
    OldPolicyValue: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn QueryProtectedPolicy(
    PolicyGuid: *Guid,
    PolicyValue: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadIdealProcessor(
    hThread: HANDLE,
    dwIdealProcessor: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn SetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ProcessInformation: *c_void,
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ProcessInformation: *c_void,
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateProcessAsUserA(
    hToken: HANDLE,
    lpApplicationName: ?[*:0]const u8,
    lpCommandLine: ?PSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u8,
    lpStartupInfo: *STARTUPINFOA,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessShutdownParameters(
    lpdwLevel: *u32,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.14393'
pub extern "KERNEL32" fn SetThreadDescription(
    hThread: HANDLE,
    lpThreadDescription: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.14393'
pub extern "KERNEL32" fn GetThreadDescription(
    hThread: HANDLE,
    ppszThreadDescription: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalMemoryStatusEx(
    lpBuffer: *MEMORYSTATUSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLogicalProcessorInformation(
    // TODO: what to do with BytesParamIndex 1?
    Buffer: ?*SYSTEM_LOGICAL_PROCESSOR_INFORMATION,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetLogicalProcessorInformationEx(
    RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: ?*SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetPhysicallyInstalledSystemMemory(
    TotalMemoryInKilobytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetProcessorSystemCycleTime(
    Group: u16,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: ?*SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryThreadCycleTime(
    ThreadHandle: HANDLE,
    CycleTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryProcessCycleTime(
    ProcessHandle: HANDLE,
    CycleTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryIdleProcessorCycleTime(
    BufferLength: *u32,
    // TODO: what to do with BytesParamIndex 0?
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn QueryIdleProcessorCycleTimeEx(
    Group: u16,
    BufferLength: *u32,
    // TODO: what to do with BytesParamIndex 1?
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalAlloc(
    uFlags: GLOBAL_ALLOC_FLAGS,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalReAlloc(
    hMem: isize,
    dwBytes: usize,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalSize(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalUnlock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalLock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalFlags(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalFree(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalMemoryStatus(
    lpBuffer: *MEMORYSTATUS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalAlloc(
    uFlags: LOCAL_ALLOC_FLAGS,
    uBytes: usize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalReAlloc(
    hMem: isize,
    uBytes: usize,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalLock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalUnlock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalSize(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalFlags(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalFree(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessAffinityMask(
    hProcess: HANDLE,
    lpProcessAffinityMask: *usize,
    lpSystemAffinityMask: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetProcessAffinityMask(
    hProcess: HANDLE,
    dwProcessAffinityMask: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessIoCounters(
    hProcess: HANDLE,
    lpIoCounters: *IO_COUNTERS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessWorkingSetSize(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: *usize,
    lpMaximumWorkingSetSize: *usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetProcessWorkingSetSize(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: usize,
    dwMaximumWorkingSetSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SwitchToFiber(
    lpFiber: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteFiber(
    lpFiber: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ConvertFiberToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFiberEx(
    dwStackCommitSize: usize,
    dwStackReserveSize: usize,
    dwFlags: u32,
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn ConvertThreadToFiberEx(
    lpParameter: ?*c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFiber(
    dwStackSize: usize,
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ConvertThreadToFiber(
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn CreateUmsCompletionList(
    UmsCompletionList: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn DequeueUmsCompletionListItems(
    UmsCompletionList: *c_void,
    WaitTimeOut: u32,
    UmsThreadList: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetUmsCompletionListEvent(
    UmsCompletionList: *c_void,
    UmsCompletionEvent: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn ExecuteUmsThread(
    UmsThread: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn UmsThreadYield(
    SchedulerParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn DeleteUmsCompletionList(
    UmsCompletionList: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetCurrentUmsThread(
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNextUmsListItem(
    UmsContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn QueryUmsThreadInformation(
    UmsThread: *c_void,
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    UmsThreadInformation: *c_void,
    UmsThreadInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetUmsThreadInformation(
    UmsThread: *c_void,
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: *c_void,
    UmsThreadInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn DeleteUmsThreadContext(
    UmsThread: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn CreateUmsThreadContext(
    lpUmsThread: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn EnterUmsSchedulingMode(
    SchedulerStartupInfo: *UMS_SCHEDULER_STARTUP_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetUmsSystemThreadInformation(
    ThreadHandle: HANDLE,
    SystemThreadInfo: *UMS_SYSTEM_THREAD_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadAffinityMask(
    hThread: HANDLE,
    dwThreadAffinityMask: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetProcessDEPPolicy(
    dwFlags: PROCESS_DEP_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessDEPPolicy(
    hProcess: HANDLE,
    lpFlags: *u32,
    lpPermanent: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RequestWakeupLatency(
    latency: LATENCY_TIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsSystemResumeAutomatic(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadExecutionState(
    esFlags: EXECUTION_STATE,
) callconv(@import("std").os.windows.WINAPI) EXECUTION_STATE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn PowerCreateRequest(
    Context: *REASON_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn PowerSetRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn PowerClearRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn PulseEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDevicePowerState(
    hDevice: HANDLE,
    pfOn: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LoadModule(
    lpModuleName: [*:0]const u8,
    lpParameterBlock: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WinExec(
    lpCmdLine: [*:0]const u8,
    uCmdShow: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ClearCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ClearCommError(
    hFile: HANDLE,
    lpErrors: ?*CLEAR_COMM_ERROR_FLAGS,
    lpStat: ?*COMSTAT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetupComm(
    hFile: HANDLE,
    dwInQueue: u32,
    dwOutQueue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn EscapeCommFunction(
    hFile: HANDLE,
    dwFunc: ESCAPE_COMM_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommConfig(
    hCommDev: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: ?*COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommMask(
    hFile: HANDLE,
    lpEvtMask: *COMM_EVENT_MASK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommProperties(
    hFile: HANDLE,
    lpCommProp: *COMMPROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommModemStatus(
    hFile: HANDLE,
    lpModemStat: *MODEM_STATUS_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommState(
    hFile: HANDLE,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn PurgeComm(
    hFile: HANDLE,
    dwFlags: PURGE_COMM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCommConfig(
    hCommDev: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: *COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCommMask(
    hFile: HANDLE,
    dwEvtMask: COMM_EVENT_MASK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCommState(
    hFile: HANDLE,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn TransmitCommChar(
    hFile: HANDLE,
    cChar: CHAR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitCommEvent(
    hFile: HANDLE,
    lpEvtMask: *COMM_EVENT_MASK,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "api-ms-win-core-comm-l1-1-1" fn OpenCommPort(
    uPortNumber: u32,
    dwDesiredAccess: u32,
    dwFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "api-ms-win-core-comm-l1-1-2" fn GetCommPorts(
    lpPortNumbers: [*]u32,
    uPortNumbersCount: u32,
    puPortNumbersFound: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetTapePosition(
    hDevice: HANDLE,
    dwPositionMethod: TAPE_POSITION_METHOD,
    dwPartition: u32,
    dwOffsetLow: u32,
    dwOffsetHigh: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTapePosition(
    hDevice: HANDLE,
    dwPositionType: TAPE_POSITION_TYPE,
    lpdwPartition: *u32,
    lpdwOffsetLow: *u32,
    lpdwOffsetHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn PrepareTape(
    hDevice: HANDLE,
    dwOperation: PREPARE_TAPE_OPERATION,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn EraseTape(
    hDevice: HANDLE,
    dwEraseType: ERASE_TAPE_TYPE,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateTapePartition(
    hDevice: HANDLE,
    dwPartitionMethod: CREATE_TAPE_PARTITION_METHOD,
    dwCount: u32,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WriteTapemark(
    hDevice: HANDLE,
    dwTapemarkType: TAPEMARK_TYPE,
    dwTapemarkCount: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTapeStatus(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetTapeParameters(
    hDevice: HANDLE,
    dwOperation: GET_TAPE_DRIVE_PARAMETERS_OPERATION,
    lpdwSize: *u32,
    // TODO: what to do with BytesParamIndex 2?
    lpTapeInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetTapeParameters(
    hDevice: HANDLE,
    dwOperation: TAPE_INFORMATION_TYPE,
    lpTapeInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemDEPPolicy(
) callconv(@import("std").os.windows.WINAPI) DEP_SYSTEM_POLICY_TYPE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CreateMailslotA(
    lpName: [*:0]const u8,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CreateMailslotW(
    lpName: [*:0]const u16,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetMailslotInfo(
    hMailslot: HANDLE,
    lpMaxMessageSize: ?*u32,
    lpNextSize: ?*u32,
    lpMessageCount: ?*u32,
    lpReadTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn SetMailslotInfo(
    hMailslot: HANDLE,
    lReadTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SignalObjectAndWait(
    hObjectToSignal: HANDLE,
    hObjectToWaitOn: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BackupRead(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *u8,
    nNumberOfBytesToRead: u32,
    lpNumberOfBytesRead: *u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BackupSeek(
    hFile: HANDLE,
    dwLowBytesToSeek: u32,
    dwHighBytesToSeek: u32,
    lpdwLowByteSeeked: *u32,
    lpdwHighByteSeeked: *u32,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BackupWrite(
    hFile: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *u8,
    nNumberOfBytesToWrite: u32,
    lpNumberOfBytesWritten: *u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateSemaphoreA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateSemaphoreExA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFileMappingA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateFileMappingNumaA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u8,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenFileMappingA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn LoadPackagedLibrary(
    lpwLibFileName: [*:0]const u16,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryFullProcessImageNameA(
    hProcess: HANDLE,
    dwFlags: PROCESS_NAME_FORMAT,
    lpExeName: [*:0]u8,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryFullProcessImageNameW(
    hProcess: HANDLE,
    dwFlags: PROCESS_NAME_FORMAT,
    lpExeName: [*:0]u16,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetDllDirectoryA(
    lpPathName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetDllDirectoryW(
    lpPathName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDllDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetDllDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CreateNamedPipeA(
    lpName: [*:0]const u8,
    dwOpenMode: u32,
    dwPipeMode: u32,
    nMaxInstances: u32,
    nOutBufferSize: u32,
    nInBufferSize: u32,
    nDefaultTimeOut: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn GetNamedPipeHandleStateA(
    hNamedPipe: HANDLE,
    lpState: ?*NAMED_PIPE_HANDLE_STATE,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?[*:0]u8,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn CallNamedPipeA(
    lpNamedPipeName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpInBuffer: ?*c_void,
    nInBufferSize: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpOutBuffer: ?*c_void,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "KERNEL32" fn WaitNamedPipeA(
    lpNamedPipeName: [*:0]const u8,
    nTimeOut: WAIT_NAMED_PIPE_TIME_OUT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNamedPipeClientComputerNameA(
    Pipe: HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    ClientComputerName: PSTR,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNamedPipeClientProcessId(
    Pipe: HANDLE,
    ClientProcessId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNamedPipeClientSessionId(
    Pipe: HANDLE,
    ClientSessionId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNamedPipeServerProcessId(
    Pipe: HANDLE,
    ServerProcessId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNamedPipeServerSessionId(
    Pipe: HANDLE,
    ServerSessionId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ClearEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ClearEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn BackupEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn BackupEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn CloseEventLog(
    hEventLog: EventLogHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn DeregisterEventSource(
    hEventLog: EventSourceHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn NotifyChangeEventLog(
    hEventLog: HANDLE,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetNumberOfEventLogRecords(
    hEventLog: HANDLE,
    NumberOfRecords: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetOldestEventLogRecord(
    hEventLog: HANDLE,
    OldestRecord: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn OpenEventLogA(
    lpUNCServerName: ?[*:0]const u8,
    lpSourceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn OpenEventLogW(
    lpUNCServerName: ?[*:0]const u16,
    lpSourceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegisterEventSourceA(
    lpUNCServerName: ?[*:0]const u8,
    lpSourceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventSourceHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegisterEventSourceW(
    lpUNCServerName: ?[*:0]const u16,
    lpSourceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn OpenBackupEventLogA(
    lpUNCServerName: ?[*:0]const u8,
    lpFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn OpenBackupEventLogW(
    lpUNCServerName: ?[*:0]const u16,
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ReadEventLogA(
    hEventLog: HANDLE,
    dwReadFlags: READ_EVENT_LOG_READ_FLAGS,
    dwRecordOffset: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpBuffer: *c_void,
    nNumberOfBytesToRead: u32,
    pnBytesRead: *u32,
    pnMinNumberOfBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ReadEventLogW(
    hEventLog: HANDLE,
    dwReadFlags: READ_EVENT_LOG_READ_FLAGS,
    dwRecordOffset: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpBuffer: *c_void,
    nNumberOfBytesToRead: u32,
    pnBytesRead: *u32,
    pnMinNumberOfBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ReportEventA(
    hEventLog: HANDLE,
    wType: REPORT_EVENT_TYPE,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: PSID,
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?[*]?PSTR,
    // TODO: what to do with BytesParamIndex 6?
    lpRawData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn ReportEventW(
    hEventLog: HANDLE,
    wType: REPORT_EVENT_TYPE,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: PSID,
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?[*]?PWSTR,
    // TODO: what to do with BytesParamIndex 6?
    lpRawData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn GetEventLogInformation(
    hEventLog: HANDLE,
    dwInfoLevel: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *c_void,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn MapViewOfFileExNuma(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: FILE_MAP,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: usize,
    lpBaseAddress: ?*c_void,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsBadReadPtr(
    lp: ?*const c_void,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsBadWritePtr(
    lp: ?*c_void,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsBadCodePtr(
    lpfn: ?FARPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsBadStringPtrA(
    lpsz: ?[*:0]const u8,
    ucchMax: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsBadStringPtrW(
    lpsz: ?[*:0]const u16,
    ucchMax: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BuildCommDCBA(
    lpDef: [*:0]const u8,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BuildCommDCBW(
    lpDef: [*:0]const u16,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsA(
    lpDef: [*:0]const u8,
    lpDCB: *DCB,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsW(
    lpDef: [*:0]const u16,
    lpDCB: *DCB,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CommConfigDialogA(
    lpszName: [*:0]const u8,
    hWnd: HWND,
    lpCC: *COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CommConfigDialogW(
    lpszName: [*:0]const u16,
    hWnd: HWND,
    lpCC: *COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDefaultCommConfigA(
    lpszName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: *COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetDefaultCommConfigW(
    lpszName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: *COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetDefaultCommConfigA(
    lpszName: [*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: *COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetDefaultCommConfigW(
    lpszName: [*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    lpCC: *COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateProcessWithLogonW(
    lpUsername: [*:0]const u16,
    lpDomain: ?[*:0]const u16,
    lpPassword: [*:0]const u16,
    dwLogonFlags: CREATE_PROCESS_LOGON_FLAGS,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CreateProcessWithTokenW(
    hToken: HANDLE,
    dwLogonFlags: CREATE_PROCESS_LOGON_FLAGS,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RegisterWaitForSingleObject(
    phNewWaitObject: *HANDLE,
    hObject: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Context: ?*c_void,
    dwMilliseconds: u32,
    dwFlags: WORKER_THREAD_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnregisterWait(
    WaitHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn BindIoCompletionCallback(
    FileHandle: HANDLE,
    Function: LPOVERLAPPED_COMPLETION_ROUTINE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeleteTimerQueue(
    TimerQueue: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateBoundaryDescriptorA(
    Name: [*:0]const u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn AddIntegrityLabelToBoundaryDescriptor(
    BoundaryDescriptor: *HANDLE,
    IntegrityLabel: PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetSystemPowerState(
    fSuspend: BOOL,
    fForce: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetSystemPowerStatus(
    lpSystemPowerStatus: *SYSTEM_POWER_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapUserPhysicalPagesScatter(
    VirtualAddresses: [*]*c_void,
    NumberOfPages: usize,
    PageArray: ?[*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateJobObjectA(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenJobObjectA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetActiveProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetMaximumProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetActiveProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetMaximumProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumaProcessorNode(
    Processor: u8,
    NodeNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNumaNodeNumberFromHandle(
    hFile: HANDLE,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNumaProcessorNodeEx(
    Processor: *PROCESSOR_NUMBER,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumaNodeProcessorMask(
    Node: u8,
    ProcessorMask: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumaAvailableMemoryNode(
    Node: u8,
    AvailableBytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetNumaAvailableMemoryNodeEx(
    Node: u16,
    AvailableBytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetNumaProximityNode(
    ProximityId: u32,
    NodeNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AddSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn RemoveSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitiateSystemShutdownA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitiateSystemShutdownW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AbortSystemShutdownA(
    lpMachineName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AbortSystemShutdownW(
    lpMachineName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitiateSystemShutdownExA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: SHUTDOWN_REASON,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitiateSystemShutdownExW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: SHUTDOWN_REASON,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn InitiateShutdownA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwGracePeriod: u32,
    dwShutdownFlags: SHUTDOWN_FLAGS,
    dwReason: SHUTDOWN_REASON,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn InitiateShutdownW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwGracePeriod: u32,
    dwShutdownFlags: SHUTDOWN_FLAGS,
    dwReason: SHUTDOWN_REASON,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn NtQueryInformationProcess(
    ProcessHandle: HANDLE,
    ProcessInformationClass: PROCESSINFOCLASS,
    ProcessInformation: *c_void,
    ProcessInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryInformationThread(
    ThreadHandle: HANDLE,
    ThreadInformationClass: THREADINFOCLASS,
    ThreadInformation: *c_void,
    ThreadInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeviceIoControl(
    hDevice: HANDLE,
    dwIoControlCode: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpInBuffer: ?*c_void,
    nInBufferSize: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpOutBuffer: ?*c_void,
    nOutBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetOverlappedResult(
    hFile: HANDLE,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetOverlappedResultEx(
    hFile: HANDLE,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn IsWow64Process(
    hProcess: HANDLE,
    Wow64Process: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10586'
pub extern "KERNEL32" fn IsWow64Process2(
    hProcess: HANDLE,
    pProcessMachine: *u16,
    pNativeMachine: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ChangeServiceConfigA(
    hService: SC_HANDLE,
    dwServiceType: u32,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: ?[*:0]const u8,
    lpLoadOrderGroup: ?[*:0]const u8,
    lpdwTagId: ?*u32,
    lpDependencies: ?[*:0]const u8,
    lpServiceStartName: ?[*:0]const u8,
    lpPassword: ?[*:0]const u8,
    lpDisplayName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ChangeServiceConfigW(
    hService: SC_HANDLE,
    dwServiceType: u32,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: ?[*:0]const u16,
    lpLoadOrderGroup: ?[*:0]const u16,
    lpdwTagId: ?*u32,
    lpDependencies: ?[*:0]const u16,
    lpServiceStartName: ?[*:0]const u16,
    lpPassword: ?[*:0]const u16,
    lpDisplayName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateServiceA(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u8,
    lpDisplayName: ?[*:0]const u8,
    dwDesiredAccess: u32,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: ?[*:0]const u8,
    lpLoadOrderGroup: ?[*:0]const u8,
    lpdwTagId: ?*u32,
    lpDependencies: ?[*:0]const u8,
    lpServiceStartName: ?[*:0]const u8,
    lpPassword: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateServiceW(
    hSCManager: SC_HANDLE,
    lpServiceName: [*:0]const u16,
    lpDisplayName: ?[*:0]const u16,
    dwDesiredAccess: u32,
    dwServiceType: ENUM_SERVICE_TYPE,
    dwStartType: SERVICE_START_TYPE,
    dwErrorControl: SERVICE_ERROR,
    lpBinaryPathName: ?[*:0]const u16,
    lpLoadOrderGroup: ?[*:0]const u16,
    lpdwTagId: ?*u32,
    lpDependencies: ?[*:0]const u16,
    lpServiceStartName: ?[*:0]const u16,
    lpPassword: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) SC_HANDLE;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (187)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCA;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXA;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1A;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2A;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4A;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5A;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7A;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8A;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9A;
        pub const JOB_INFO_1 = JOB_INFO_1A;
        pub const JOB_INFO_2 = JOB_INFO_2A;
        pub const JOB_INFO_4 = JOB_INFO_4A;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1A;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1A;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2A;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3A;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4A;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5A;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6A;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8A;
        pub const DOC_INFO_1 = DOC_INFO_1A;
        pub const FORM_INFO_1 = FORM_INFO_1A;
        pub const FORM_INFO_2 = FORM_INFO_2A;
        pub const DOC_INFO_2 = DOC_INFO_2A;
        pub const DOC_INFO_3 = DOC_INFO_3A;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1A;
        pub const PORT_INFO_1 = PORT_INFO_1A;
        pub const PORT_INFO_2 = PORT_INFO_2A;
        pub const PORT_INFO_3 = PORT_INFO_3A;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1A;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2A;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1A;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSA;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESA;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1A;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2A;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSA;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1A;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERA;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_A;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_A;
        pub const STARTUPINFO = STARTUPINFOA;
        pub const STARTUPINFOEX = STARTUPINFOEXA;
        pub const CreateMutex = CreateMutexA;
        pub const CreateEvent = CreateEventA;
        pub const OpenEvent = OpenEventA;
        pub const CreateMutexEx = CreateMutexExA;
        pub const CreateEventEx = CreateEventExA;
        pub const CreateSemaphoreEx = CreateSemaphoreExA;
        pub const CreateSemaphore = CreateSemaphoreA;
        pub const CreateJobObject = CreateJobObjectA;
        pub const OpenJobObject = OpenJobObjectA;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
        pub const CreateNamedPipe = CreateNamedPipeA;
        pub const WaitNamedPipe = WaitNamedPipeA;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateA;
        pub const CallNamedPipe = CallNamedPipeA;
        pub const CreateFileMapping = CreateFileMappingA;
        pub const OpenFileMapping = OpenFileMappingA;
        pub const CreateFileMappingNuma = CreateFileMappingNumaA;
        pub const LoadEnclaveImage = LoadEnclaveImageA;
        pub const GetModuleFileName = GetModuleFileNameA;
        pub const GetModuleHandle = GetModuleHandleA;
        pub const GetModuleHandleEx = GetModuleHandleExA;
        pub const LoadLibraryEx = LoadLibraryExA;
        pub const LoadLibrary = LoadLibraryA;
        pub const ReadConsoleInput = ReadConsoleInputA;
        pub const PeekConsoleInput = PeekConsoleInputA;
        pub const ReadConsole = ReadConsoleA;
        pub const WriteConsole = WriteConsoleA;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
        pub const WriteConsoleInput = WriteConsoleInputA;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
        pub const WriteConsoleOutput = WriteConsoleOutputA;
        pub const ReadConsoleOutput = ReadConsoleOutputA;
        pub const GetConsoleTitle = GetConsoleTitleA;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleA;
        pub const SetConsoleTitle = SetConsoleTitleA;
        pub const AddConsoleAlias = AddConsoleAliasA;
        pub const GetConsoleAlias = GetConsoleAliasA;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthA;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthA;
        pub const GetConsoleAliases = GetConsoleAliasesA;
        pub const GetConsoleAliasExes = GetConsoleAliasExesA;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryA;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsA;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthA;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryA;
        pub const EnumPrinters = EnumPrintersA;
        pub const OpenPrinter = OpenPrinterA;
        pub const ResetPrinter = ResetPrinterA;
        pub const SetJob = SetJobA;
        pub const GetJob = GetJobA;
        pub const EnumJobs = EnumJobsA;
        pub const AddPrinter = AddPrinterA;
        pub const SetPrinter = SetPrinterA;
        pub const GetPrinter = GetPrinterA;
        pub const AddPrinterDriver = AddPrinterDriverA;
        pub const AddPrinterDriverEx = AddPrinterDriverExA;
        pub const EnumPrinterDrivers = EnumPrinterDriversA;
        pub const GetPrinterDriver = GetPrinterDriverA;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryA;
        pub const DeletePrinterDriver = DeletePrinterDriverA;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExA;
        pub const AddPrintProcessor = AddPrintProcessorA;
        pub const EnumPrintProcessors = EnumPrintProcessorsA;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryA;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesA;
        pub const DeletePrintProcessor = DeletePrintProcessorA;
        pub const StartDocPrinter = StartDocPrinterA;
        pub const AddJob = AddJobA;
        pub const DocumentProperties = DocumentPropertiesA;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesA;
        pub const GetPrinterData = GetPrinterDataA;
        pub const GetPrinterDataEx = GetPrinterDataExA;
        pub const EnumPrinterData = EnumPrinterDataA;
        pub const EnumPrinterDataEx = EnumPrinterDataExA;
        pub const EnumPrinterKey = EnumPrinterKeyA;
        pub const SetPrinterData = SetPrinterDataA;
        pub const SetPrinterDataEx = SetPrinterDataExA;
        pub const DeletePrinterData = DeletePrinterDataA;
        pub const DeletePrinterDataEx = DeletePrinterDataExA;
        pub const DeletePrinterKey = DeletePrinterKeyA;
        pub const PrinterMessageBox = PrinterMessageBoxA;
        pub const AddForm = AddFormA;
        pub const DeleteForm = DeleteFormA;
        pub const GetForm = GetFormA;
        pub const SetForm = SetFormA;
        pub const EnumForms = EnumFormsA;
        pub const EnumMonitors = EnumMonitorsA;
        pub const AddMonitor = AddMonitorA;
        pub const DeleteMonitor = DeleteMonitorA;
        pub const EnumPorts = EnumPortsA;
        pub const AddPort = AddPortA;
        pub const ConfigurePort = ConfigurePortA;
        pub const DeletePort = DeletePortA;
        pub const GetDefaultPrinter = GetDefaultPrinterA;
        pub const SetDefaultPrinter = SetDefaultPrinterA;
        pub const SetPort = SetPortA;
        pub const AddPrinterConnection = AddPrinterConnectionA;
        pub const DeletePrinterConnection = DeletePrinterConnectionA;
        pub const AddPrintProvidor = AddPrintProvidorA;
        pub const DeletePrintProvidor = DeletePrintProvidorA;
        pub const IsValidDevmode = IsValidDevmodeA;
        pub const OpenPrinter2 = OpenPrinter2A;
        pub const AddPrinterConnection2 = AddPrinterConnection2A;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageA;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageA;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversA;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledA;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathA;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageA;
        pub const GetPrinterDriver2 = GetPrinterDriver2A;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationA;
        pub const GetCommandLine = GetCommandLineA;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsA;
        pub const GetEnvironmentVariable = GetEnvironmentVariableA;
        pub const SetEnvironmentVariable = SetEnvironmentVariableA;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathA;
        pub const CreateProcess = CreateProcessA;
        pub const CreateProcessAsUser = CreateProcessAsUserA;
        pub const CreateMailslot = CreateMailslotA;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameA;
        pub const SetDllDirectory = SetDllDirectoryA;
        pub const GetDllDirectory = GetDllDirectoryA;
        pub const ClearEventLog = ClearEventLogA;
        pub const BackupEventLog = BackupEventLogA;
        pub const OpenEventLog = OpenEventLogA;
        pub const RegisterEventSource = RegisterEventSourceA;
        pub const OpenBackupEventLog = OpenBackupEventLogA;
        pub const ReadEventLog = ReadEventLogA;
        pub const ReportEvent = ReportEventA;
        pub const IsBadStringPtr = IsBadStringPtrA;
        pub const BuildCommDCB = BuildCommDCBA;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
        pub const CommConfigDialog = CommConfigDialogA;
        pub const GetDefaultCommConfig = GetDefaultCommConfigA;
        pub const SetDefaultCommConfig = SetDefaultCommConfigA;
        pub const InitiateSystemShutdown = InitiateSystemShutdownA;
        pub const AbortSystemShutdown = AbortSystemShutdownA;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExA;
        pub const InitiateShutdown = InitiateShutdownA;
        pub const ChangeServiceConfig = ChangeServiceConfigA;
        pub const CreateService = CreateServiceA;
    },
    .wide => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCW;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXW;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1W;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2W;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4W;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5W;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7W;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8W;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9W;
        pub const JOB_INFO_1 = JOB_INFO_1W;
        pub const JOB_INFO_2 = JOB_INFO_2W;
        pub const JOB_INFO_4 = JOB_INFO_4W;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1W;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1W;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2W;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3W;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4W;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5W;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6W;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8W;
        pub const DOC_INFO_1 = DOC_INFO_1W;
        pub const FORM_INFO_1 = FORM_INFO_1W;
        pub const FORM_INFO_2 = FORM_INFO_2W;
        pub const DOC_INFO_2 = DOC_INFO_2W;
        pub const DOC_INFO_3 = DOC_INFO_3W;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1W;
        pub const PORT_INFO_1 = PORT_INFO_1W;
        pub const PORT_INFO_2 = PORT_INFO_2W;
        pub const PORT_INFO_3 = PORT_INFO_3W;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1W;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2W;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1W;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSW;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESW;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1W;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2W;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSW;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1W;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERW;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_W;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_W;
        pub const STARTUPINFO = STARTUPINFOW;
        pub const STARTUPINFOEX = STARTUPINFOEXW;
        pub const CreateMutex = CreateMutexW;
        pub const CreateEvent = CreateEventW;
        pub const OpenEvent = OpenEventW;
        pub const CreateMutexEx = CreateMutexExW;
        pub const CreateEventEx = CreateEventExW;
        pub const CreateSemaphoreEx = CreateSemaphoreExW;
        pub const CreateSemaphore = CreateSemaphoreW;
        pub const CreateJobObject = CreateJobObjectW;
        pub const OpenJobObject = OpenJobObjectW;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorW;
        pub const CreateNamedPipe = CreateNamedPipeW;
        pub const WaitNamedPipe = WaitNamedPipeW;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameW;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateW;
        pub const CallNamedPipe = CallNamedPipeW;
        pub const CreateFileMapping = CreateFileMappingW;
        pub const OpenFileMapping = OpenFileMappingW;
        pub const CreateFileMappingNuma = CreateFileMappingNumaW;
        pub const LoadEnclaveImage = LoadEnclaveImageW;
        pub const GetModuleFileName = GetModuleFileNameW;
        pub const GetModuleHandle = GetModuleHandleW;
        pub const GetModuleHandleEx = GetModuleHandleExW;
        pub const LoadLibraryEx = LoadLibraryExW;
        pub const LoadLibrary = LoadLibraryW;
        pub const ReadConsoleInput = ReadConsoleInputW;
        pub const PeekConsoleInput = PeekConsoleInputW;
        pub const ReadConsole = ReadConsoleW;
        pub const WriteConsole = WriteConsoleW;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterW;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterW;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterW;
        pub const WriteConsoleInput = WriteConsoleInputW;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferW;
        pub const WriteConsoleOutput = WriteConsoleOutputW;
        pub const ReadConsoleOutput = ReadConsoleOutputW;
        pub const GetConsoleTitle = GetConsoleTitleW;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleW;
        pub const SetConsoleTitle = SetConsoleTitleW;
        pub const AddConsoleAlias = AddConsoleAliasW;
        pub const GetConsoleAlias = GetConsoleAliasW;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthW;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthW;
        pub const GetConsoleAliases = GetConsoleAliasesW;
        pub const GetConsoleAliasExes = GetConsoleAliasExesW;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryW;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsW;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthW;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryW;
        pub const EnumPrinters = EnumPrintersW;
        pub const OpenPrinter = OpenPrinterW;
        pub const ResetPrinter = ResetPrinterW;
        pub const SetJob = SetJobW;
        pub const GetJob = GetJobW;
        pub const EnumJobs = EnumJobsW;
        pub const AddPrinter = AddPrinterW;
        pub const SetPrinter = SetPrinterW;
        pub const GetPrinter = GetPrinterW;
        pub const AddPrinterDriver = AddPrinterDriverW;
        pub const AddPrinterDriverEx = AddPrinterDriverExW;
        pub const EnumPrinterDrivers = EnumPrinterDriversW;
        pub const GetPrinterDriver = GetPrinterDriverW;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryW;
        pub const DeletePrinterDriver = DeletePrinterDriverW;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExW;
        pub const AddPrintProcessor = AddPrintProcessorW;
        pub const EnumPrintProcessors = EnumPrintProcessorsW;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryW;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesW;
        pub const DeletePrintProcessor = DeletePrintProcessorW;
        pub const StartDocPrinter = StartDocPrinterW;
        pub const AddJob = AddJobW;
        pub const DocumentProperties = DocumentPropertiesW;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesW;
        pub const GetPrinterData = GetPrinterDataW;
        pub const GetPrinterDataEx = GetPrinterDataExW;
        pub const EnumPrinterData = EnumPrinterDataW;
        pub const EnumPrinterDataEx = EnumPrinterDataExW;
        pub const EnumPrinterKey = EnumPrinterKeyW;
        pub const SetPrinterData = SetPrinterDataW;
        pub const SetPrinterDataEx = SetPrinterDataExW;
        pub const DeletePrinterData = DeletePrinterDataW;
        pub const DeletePrinterDataEx = DeletePrinterDataExW;
        pub const DeletePrinterKey = DeletePrinterKeyW;
        pub const PrinterMessageBox = PrinterMessageBoxW;
        pub const AddForm = AddFormW;
        pub const DeleteForm = DeleteFormW;
        pub const GetForm = GetFormW;
        pub const SetForm = SetFormW;
        pub const EnumForms = EnumFormsW;
        pub const EnumMonitors = EnumMonitorsW;
        pub const AddMonitor = AddMonitorW;
        pub const DeleteMonitor = DeleteMonitorW;
        pub const EnumPorts = EnumPortsW;
        pub const AddPort = AddPortW;
        pub const ConfigurePort = ConfigurePortW;
        pub const DeletePort = DeletePortW;
        pub const GetDefaultPrinter = GetDefaultPrinterW;
        pub const SetDefaultPrinter = SetDefaultPrinterW;
        pub const SetPort = SetPortW;
        pub const AddPrinterConnection = AddPrinterConnectionW;
        pub const DeletePrinterConnection = DeletePrinterConnectionW;
        pub const AddPrintProvidor = AddPrintProvidorW;
        pub const DeletePrintProvidor = DeletePrintProvidorW;
        pub const IsValidDevmode = IsValidDevmodeW;
        pub const OpenPrinter2 = OpenPrinter2W;
        pub const AddPrinterConnection2 = AddPrinterConnection2W;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageW;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageW;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversW;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledW;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathW;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageW;
        pub const GetPrinterDriver2 = GetPrinterDriver2W;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationW;
        pub const GetCommandLine = GetCommandLineW;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsW;
        pub const GetEnvironmentVariable = GetEnvironmentVariableW;
        pub const SetEnvironmentVariable = SetEnvironmentVariableW;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathW;
        pub const CreateProcess = CreateProcessW;
        pub const CreateProcessAsUser = CreateProcessAsUserW;
        pub const CreateMailslot = CreateMailslotW;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameW;
        pub const SetDllDirectory = SetDllDirectoryW;
        pub const GetDllDirectory = GetDllDirectoryW;
        pub const ClearEventLog = ClearEventLogW;
        pub const BackupEventLog = BackupEventLogW;
        pub const OpenEventLog = OpenEventLogW;
        pub const RegisterEventSource = RegisterEventSourceW;
        pub const OpenBackupEventLog = OpenBackupEventLogW;
        pub const ReadEventLog = ReadEventLogW;
        pub const ReportEvent = ReportEventW;
        pub const IsBadStringPtr = IsBadStringPtrW;
        pub const BuildCommDCB = BuildCommDCBW;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
        pub const CommConfigDialog = CommConfigDialogW;
        pub const GetDefaultCommConfig = GetDefaultCommConfigW;
        pub const SetDefaultCommConfig = SetDefaultCommConfigW;
        pub const InitiateSystemShutdown = InitiateSystemShutdownW;
        pub const AbortSystemShutdown = AbortSystemShutdownW;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExW;
        pub const InitiateShutdown = InitiateShutdownW;
        pub const ChangeServiceConfig = ChangeServiceConfigW;
        pub const CreateService = CreateServiceW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const ENUMRESLANGPROC = *opaque{};
        pub const PGET_MODULE_HANDLE_EX = *opaque{};
        pub const PRINTER_INFO_1 = *opaque{};
        pub const PRINTER_INFO_2 = *opaque{};
        pub const PRINTER_INFO_4 = *opaque{};
        pub const PRINTER_INFO_5 = *opaque{};
        pub const PRINTER_INFO_7 = *opaque{};
        pub const PRINTER_INFO_8 = *opaque{};
        pub const PRINTER_INFO_9 = *opaque{};
        pub const JOB_INFO_1 = *opaque{};
        pub const JOB_INFO_2 = *opaque{};
        pub const JOB_INFO_4 = *opaque{};
        pub const ADDJOB_INFO_1 = *opaque{};
        pub const DRIVER_INFO_1 = *opaque{};
        pub const DRIVER_INFO_2 = *opaque{};
        pub const DRIVER_INFO_3 = *opaque{};
        pub const DRIVER_INFO_4 = *opaque{};
        pub const DRIVER_INFO_5 = *opaque{};
        pub const DRIVER_INFO_6 = *opaque{};
        pub const DRIVER_INFO_8 = *opaque{};
        pub const DOC_INFO_1 = *opaque{};
        pub const FORM_INFO_1 = *opaque{};
        pub const FORM_INFO_2 = *opaque{};
        pub const DOC_INFO_2 = *opaque{};
        pub const DOC_INFO_3 = *opaque{};
        pub const PRINTPROCESSOR_INFO_1 = *opaque{};
        pub const PORT_INFO_1 = *opaque{};
        pub const PORT_INFO_2 = *opaque{};
        pub const PORT_INFO_3 = *opaque{};
        pub const MONITOR_INFO_1 = *opaque{};
        pub const MONITOR_INFO_2 = *opaque{};
        pub const DATATYPES_INFO_1 = *opaque{};
        pub const PRINTER_DEFAULTS = *opaque{};
        pub const PRINTER_ENUM_VALUES = *opaque{};
        pub const PROVIDOR_INFO_1 = *opaque{};
        pub const PROVIDOR_INFO_2 = *opaque{};
        pub const PRINTER_OPTIONS = *opaque{};
        pub const PRINTER_CONNECTION_INFO_1 = *opaque{};
        pub const CORE_PRINTER_DRIVER = *opaque{};
        pub const DEV_BROADCAST_PORT_ = *opaque{};
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = *opaque{};
        pub const STARTUPINFO = *opaque{};
        pub const STARTUPINFOEX = *opaque{};
        pub const CreateMutex = *opaque{};
        pub const CreateEvent = *opaque{};
        pub const OpenEvent = *opaque{};
        pub const CreateMutexEx = *opaque{};
        pub const CreateEventEx = *opaque{};
        pub const CreateSemaphoreEx = *opaque{};
        pub const CreateSemaphore = *opaque{};
        pub const CreateJobObject = *opaque{};
        pub const OpenJobObject = *opaque{};
        pub const CreateBoundaryDescriptor = *opaque{};
        pub const CreateNamedPipe = *opaque{};
        pub const WaitNamedPipe = *opaque{};
        pub const GetNamedPipeClientComputerName = *opaque{};
        pub const GetNamedPipeHandleState = *opaque{};
        pub const CallNamedPipe = *opaque{};
        pub const CreateFileMapping = *opaque{};
        pub const OpenFileMapping = *opaque{};
        pub const CreateFileMappingNuma = *opaque{};
        pub const LoadEnclaveImage = *opaque{};
        pub const GetModuleFileName = *opaque{};
        pub const GetModuleHandle = *opaque{};
        pub const GetModuleHandleEx = *opaque{};
        pub const LoadLibraryEx = *opaque{};
        pub const LoadLibrary = *opaque{};
        pub const ReadConsoleInput = *opaque{};
        pub const PeekConsoleInput = *opaque{};
        pub const ReadConsole = *opaque{};
        pub const WriteConsole = *opaque{};
        pub const FillConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleOutputCharacter = *opaque{};
        pub const ReadConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleInput = *opaque{};
        pub const ScrollConsoleScreenBuffer = *opaque{};
        pub const WriteConsoleOutput = *opaque{};
        pub const ReadConsoleOutput = *opaque{};
        pub const GetConsoleTitle = *opaque{};
        pub const GetConsoleOriginalTitle = *opaque{};
        pub const SetConsoleTitle = *opaque{};
        pub const AddConsoleAlias = *opaque{};
        pub const GetConsoleAlias = *opaque{};
        pub const GetConsoleAliasesLength = *opaque{};
        pub const GetConsoleAliasExesLength = *opaque{};
        pub const GetConsoleAliases = *opaque{};
        pub const GetConsoleAliasExes = *opaque{};
        pub const ExpungeConsoleCommandHistory = *opaque{};
        pub const SetConsoleNumberOfCommands = *opaque{};
        pub const GetConsoleCommandHistoryLength = *opaque{};
        pub const GetConsoleCommandHistory = *opaque{};
        pub const EnumPrinters = *opaque{};
        pub const OpenPrinter = *opaque{};
        pub const ResetPrinter = *opaque{};
        pub const SetJob = *opaque{};
        pub const GetJob = *opaque{};
        pub const EnumJobs = *opaque{};
        pub const AddPrinter = *opaque{};
        pub const SetPrinter = *opaque{};
        pub const GetPrinter = *opaque{};
        pub const AddPrinterDriver = *opaque{};
        pub const AddPrinterDriverEx = *opaque{};
        pub const EnumPrinterDrivers = *opaque{};
        pub const GetPrinterDriver = *opaque{};
        pub const GetPrinterDriverDirectory = *opaque{};
        pub const DeletePrinterDriver = *opaque{};
        pub const DeletePrinterDriverEx = *opaque{};
        pub const AddPrintProcessor = *opaque{};
        pub const EnumPrintProcessors = *opaque{};
        pub const GetPrintProcessorDirectory = *opaque{};
        pub const EnumPrintProcessorDatatypes = *opaque{};
        pub const DeletePrintProcessor = *opaque{};
        pub const StartDocPrinter = *opaque{};
        pub const AddJob = *opaque{};
        pub const DocumentProperties = *opaque{};
        pub const AdvancedDocumentProperties = *opaque{};
        pub const GetPrinterData = *opaque{};
        pub const GetPrinterDataEx = *opaque{};
        pub const EnumPrinterData = *opaque{};
        pub const EnumPrinterDataEx = *opaque{};
        pub const EnumPrinterKey = *opaque{};
        pub const SetPrinterData = *opaque{};
        pub const SetPrinterDataEx = *opaque{};
        pub const DeletePrinterData = *opaque{};
        pub const DeletePrinterDataEx = *opaque{};
        pub const DeletePrinterKey = *opaque{};
        pub const PrinterMessageBox = *opaque{};
        pub const AddForm = *opaque{};
        pub const DeleteForm = *opaque{};
        pub const GetForm = *opaque{};
        pub const SetForm = *opaque{};
        pub const EnumForms = *opaque{};
        pub const EnumMonitors = *opaque{};
        pub const AddMonitor = *opaque{};
        pub const DeleteMonitor = *opaque{};
        pub const EnumPorts = *opaque{};
        pub const AddPort = *opaque{};
        pub const ConfigurePort = *opaque{};
        pub const DeletePort = *opaque{};
        pub const GetDefaultPrinter = *opaque{};
        pub const SetDefaultPrinter = *opaque{};
        pub const SetPort = *opaque{};
        pub const AddPrinterConnection = *opaque{};
        pub const DeletePrinterConnection = *opaque{};
        pub const AddPrintProvidor = *opaque{};
        pub const DeletePrintProvidor = *opaque{};
        pub const IsValidDevmode = *opaque{};
        pub const OpenPrinter2 = *opaque{};
        pub const AddPrinterConnection2 = *opaque{};
        pub const InstallPrinterDriverFromPackage = *opaque{};
        pub const UploadPrinterDriverPackage = *opaque{};
        pub const GetCorePrinterDrivers = *opaque{};
        pub const CorePrinterDriverInstalled = *opaque{};
        pub const GetPrinterDriverPackagePath = *opaque{};
        pub const DeletePrinterDriverPackage = *opaque{};
        pub const GetPrinterDriver2 = *opaque{};
        pub const RegisterDeviceNotification = *opaque{};
        pub const GetCommandLine = *opaque{};
        pub const FreeEnvironmentStrings = *opaque{};
        pub const GetEnvironmentVariable = *opaque{};
        pub const SetEnvironmentVariable = *opaque{};
        pub const NeedCurrentDirectoryForExePath = *opaque{};
        pub const CreateProcess = *opaque{};
        pub const CreateProcessAsUser = *opaque{};
        pub const CreateMailslot = *opaque{};
        pub const QueryFullProcessImageName = *opaque{};
        pub const SetDllDirectory = *opaque{};
        pub const GetDllDirectory = *opaque{};
        pub const ClearEventLog = *opaque{};
        pub const BackupEventLog = *opaque{};
        pub const OpenEventLog = *opaque{};
        pub const RegisterEventSource = *opaque{};
        pub const OpenBackupEventLog = *opaque{};
        pub const ReadEventLog = *opaque{};
        pub const ReportEvent = *opaque{};
        pub const IsBadStringPtr = *opaque{};
        pub const BuildCommDCB = *opaque{};
        pub const BuildCommDCBAndTimeouts = *opaque{};
        pub const CommConfigDialog = *opaque{};
        pub const GetDefaultCommConfig = *opaque{};
        pub const SetDefaultCommConfig = *opaque{};
        pub const InitiateSystemShutdown = *opaque{};
        pub const AbortSystemShutdown = *opaque{};
        pub const InitiateSystemShutdownEx = *opaque{};
        pub const InitiateShutdown = *opaque{};
        pub const ChangeServiceConfig = *opaque{};
        pub const CreateService = *opaque{};
    } else struct {
        pub const ENUMRESLANGPROC = @compileError("'ENUMRESLANGPROC' requires that UNICODE be set to true or false in the root module");
        pub const PGET_MODULE_HANDLE_EX = @compileError("'PGET_MODULE_HANDLE_EX' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_1 = @compileError("'PRINTER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_2 = @compileError("'PRINTER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_4 = @compileError("'PRINTER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_5 = @compileError("'PRINTER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_7 = @compileError("'PRINTER_INFO_7' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_8 = @compileError("'PRINTER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_9 = @compileError("'PRINTER_INFO_9' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_1 = @compileError("'JOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_2 = @compileError("'JOB_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_4 = @compileError("'JOB_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const ADDJOB_INFO_1 = @compileError("'ADDJOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_1 = @compileError("'DRIVER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_2 = @compileError("'DRIVER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_3 = @compileError("'DRIVER_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_4 = @compileError("'DRIVER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_5 = @compileError("'DRIVER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_6 = @compileError("'DRIVER_INFO_6' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_8 = @compileError("'DRIVER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_1 = @compileError("'DOC_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_1 = @compileError("'FORM_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_2 = @compileError("'FORM_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_2 = @compileError("'DOC_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_3 = @compileError("'DOC_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const PRINTPROCESSOR_INFO_1 = @compileError("'PRINTPROCESSOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_1 = @compileError("'PORT_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_2 = @compileError("'PORT_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_3 = @compileError("'PORT_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_1 = @compileError("'MONITOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_2 = @compileError("'MONITOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DATATYPES_INFO_1 = @compileError("'DATATYPES_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_DEFAULTS = @compileError("'PRINTER_DEFAULTS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_ENUM_VALUES = @compileError("'PRINTER_ENUM_VALUES' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_1 = @compileError("'PROVIDOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_2 = @compileError("'PROVIDOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_OPTIONS = @compileError("'PRINTER_OPTIONS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_CONNECTION_INFO_1 = @compileError("'PRINTER_CONNECTION_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const CORE_PRINTER_DRIVER = @compileError("'CORE_PRINTER_DRIVER' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_PORT_ = @compileError("'DEV_BROADCAST_PORT_' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = @compileError("'DEV_BROADCAST_DEVICEINTERFACE_' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFO = @compileError("'STARTUPINFO' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFOEX = @compileError("'STARTUPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutex = @compileError("'CreateMutex' requires that UNICODE be set to true or false in the root module");
        pub const CreateEvent = @compileError("'CreateEvent' requires that UNICODE be set to true or false in the root module");
        pub const OpenEvent = @compileError("'OpenEvent' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutexEx = @compileError("'CreateMutexEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateEventEx = @compileError("'CreateEventEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphoreEx = @compileError("'CreateSemaphoreEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphore = @compileError("'CreateSemaphore' requires that UNICODE be set to true or false in the root module");
        pub const CreateJobObject = @compileError("'CreateJobObject' requires that UNICODE be set to true or false in the root module");
        pub const OpenJobObject = @compileError("'OpenJobObject' requires that UNICODE be set to true or false in the root module");
        pub const CreateBoundaryDescriptor = @compileError("'CreateBoundaryDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const CreateNamedPipe = @compileError("'CreateNamedPipe' requires that UNICODE be set to true or false in the root module");
        pub const WaitNamedPipe = @compileError("'WaitNamedPipe' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeClientComputerName = @compileError("'GetNamedPipeClientComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeHandleState = @compileError("'GetNamedPipeHandleState' requires that UNICODE be set to true or false in the root module");
        pub const CallNamedPipe = @compileError("'CallNamedPipe' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMapping = @compileError("'CreateFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const OpenFileMapping = @compileError("'OpenFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMappingNuma = @compileError("'CreateFileMappingNuma' requires that UNICODE be set to true or false in the root module");
        pub const LoadEnclaveImage = @compileError("'LoadEnclaveImage' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleFileName = @compileError("'GetModuleFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandle = @compileError("'GetModuleHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandleEx = @compileError("'GetModuleHandleEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibraryEx = @compileError("'LoadLibraryEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibrary = @compileError("'LoadLibrary' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleInput = @compileError("'ReadConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const PeekConsoleInput = @compileError("'PeekConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsole = @compileError("'ReadConsole' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsole = @compileError("'WriteConsole' requires that UNICODE be set to true or false in the root module");
        pub const FillConsoleOutputCharacter = @compileError("'FillConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutputCharacter = @compileError("'WriteConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutputCharacter = @compileError("'ReadConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleInput = @compileError("'WriteConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ScrollConsoleScreenBuffer = @compileError("'ScrollConsoleScreenBuffer' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutput = @compileError("'WriteConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutput = @compileError("'ReadConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleTitle = @compileError("'GetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleOriginalTitle = @compileError("'GetConsoleOriginalTitle' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleTitle = @compileError("'SetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const AddConsoleAlias = @compileError("'AddConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAlias = @compileError("'GetConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasesLength = @compileError("'GetConsoleAliasesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExesLength = @compileError("'GetConsoleAliasExesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliases = @compileError("'GetConsoleAliases' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExes = @compileError("'GetConsoleAliasExes' requires that UNICODE be set to true or false in the root module");
        pub const ExpungeConsoleCommandHistory = @compileError("'ExpungeConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleNumberOfCommands = @compileError("'SetConsoleNumberOfCommands' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistoryLength = @compileError("'GetConsoleCommandHistoryLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistory = @compileError("'GetConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinters = @compileError("'EnumPrinters' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter = @compileError("'OpenPrinter' requires that UNICODE be set to true or false in the root module");
        pub const ResetPrinter = @compileError("'ResetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetJob = @compileError("'SetJob' requires that UNICODE be set to true or false in the root module");
        pub const GetJob = @compileError("'GetJob' requires that UNICODE be set to true or false in the root module");
        pub const EnumJobs = @compileError("'EnumJobs' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinter = @compileError("'AddPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinter = @compileError("'SetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinter = @compileError("'GetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriver = @compileError("'AddPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriverEx = @compileError("'AddPrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDrivers = @compileError("'EnumPrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver = @compileError("'GetPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverDirectory = @compileError("'GetPrinterDriverDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriver = @compileError("'DeletePrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverEx = @compileError("'DeletePrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProcessor = @compileError("'AddPrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessors = @compileError("'EnumPrintProcessors' requires that UNICODE be set to true or false in the root module");
        pub const GetPrintProcessorDirectory = @compileError("'GetPrintProcessorDirectory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessorDatatypes = @compileError("'EnumPrintProcessorDatatypes' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProcessor = @compileError("'DeletePrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const StartDocPrinter = @compileError("'StartDocPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddJob = @compileError("'AddJob' requires that UNICODE be set to true or false in the root module");
        pub const DocumentProperties = @compileError("'DocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const AdvancedDocumentProperties = @compileError("'AdvancedDocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterData = @compileError("'GetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDataEx = @compileError("'GetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterData = @compileError("'EnumPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDataEx = @compileError("'EnumPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterKey = @compileError("'EnumPrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterData = @compileError("'SetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterDataEx = @compileError("'SetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterData = @compileError("'DeletePrinterData' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDataEx = @compileError("'DeletePrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterKey = @compileError("'DeletePrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const PrinterMessageBox = @compileError("'PrinterMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const AddForm = @compileError("'AddForm' requires that UNICODE be set to true or false in the root module");
        pub const DeleteForm = @compileError("'DeleteForm' requires that UNICODE be set to true or false in the root module");
        pub const GetForm = @compileError("'GetForm' requires that UNICODE be set to true or false in the root module");
        pub const SetForm = @compileError("'SetForm' requires that UNICODE be set to true or false in the root module");
        pub const EnumForms = @compileError("'EnumForms' requires that UNICODE be set to true or false in the root module");
        pub const EnumMonitors = @compileError("'EnumMonitors' requires that UNICODE be set to true or false in the root module");
        pub const AddMonitor = @compileError("'AddMonitor' requires that UNICODE be set to true or false in the root module");
        pub const DeleteMonitor = @compileError("'DeleteMonitor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPorts = @compileError("'EnumPorts' requires that UNICODE be set to true or false in the root module");
        pub const AddPort = @compileError("'AddPort' requires that UNICODE be set to true or false in the root module");
        pub const ConfigurePort = @compileError("'ConfigurePort' requires that UNICODE be set to true or false in the root module");
        pub const DeletePort = @compileError("'DeletePort' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultPrinter = @compileError("'GetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultPrinter = @compileError("'SetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPort = @compileError("'SetPort' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection = @compileError("'AddPrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterConnection = @compileError("'DeletePrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProvidor = @compileError("'AddPrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProvidor = @compileError("'DeletePrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const IsValidDevmode = @compileError("'IsValidDevmode' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter2 = @compileError("'OpenPrinter2' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection2 = @compileError("'AddPrinterConnection2' requires that UNICODE be set to true or false in the root module");
        pub const InstallPrinterDriverFromPackage = @compileError("'InstallPrinterDriverFromPackage' requires that UNICODE be set to true or false in the root module");
        pub const UploadPrinterDriverPackage = @compileError("'UploadPrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetCorePrinterDrivers = @compileError("'GetCorePrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const CorePrinterDriverInstalled = @compileError("'CorePrinterDriverInstalled' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverPackagePath = @compileError("'GetPrinterDriverPackagePath' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverPackage = @compileError("'DeletePrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver2 = @compileError("'GetPrinterDriver2' requires that UNICODE be set to true or false in the root module");
        pub const RegisterDeviceNotification = @compileError("'RegisterDeviceNotification' requires that UNICODE be set to true or false in the root module");
        pub const GetCommandLine = @compileError("'GetCommandLine' requires that UNICODE be set to true or false in the root module");
        pub const FreeEnvironmentStrings = @compileError("'FreeEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const GetEnvironmentVariable = @compileError("'GetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetEnvironmentVariable = @compileError("'SetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const NeedCurrentDirectoryForExePath = @compileError("'NeedCurrentDirectoryForExePath' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcess = @compileError("'CreateProcess' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcessAsUser = @compileError("'CreateProcessAsUser' requires that UNICODE be set to true or false in the root module");
        pub const CreateMailslot = @compileError("'CreateMailslot' requires that UNICODE be set to true or false in the root module");
        pub const QueryFullProcessImageName = @compileError("'QueryFullProcessImageName' requires that UNICODE be set to true or false in the root module");
        pub const SetDllDirectory = @compileError("'SetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetDllDirectory = @compileError("'GetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const ClearEventLog = @compileError("'ClearEventLog' requires that UNICODE be set to true or false in the root module");
        pub const BackupEventLog = @compileError("'BackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const OpenEventLog = @compileError("'OpenEventLog' requires that UNICODE be set to true or false in the root module");
        pub const RegisterEventSource = @compileError("'RegisterEventSource' requires that UNICODE be set to true or false in the root module");
        pub const OpenBackupEventLog = @compileError("'OpenBackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReadEventLog = @compileError("'ReadEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReportEvent = @compileError("'ReportEvent' requires that UNICODE be set to true or false in the root module");
        pub const IsBadStringPtr = @compileError("'IsBadStringPtr' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCB = @compileError("'BuildCommDCB' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCBAndTimeouts = @compileError("'BuildCommDCBAndTimeouts' requires that UNICODE be set to true or false in the root module");
        pub const CommConfigDialog = @compileError("'CommConfigDialog' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultCommConfig = @compileError("'GetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultCommConfig = @compileError("'SetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdown = @compileError("'InitiateSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const AbortSystemShutdown = @compileError("'AbortSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdownEx = @compileError("'InitiateSystemShutdownEx' requires that UNICODE be set to true or false in the root module");
        pub const InitiateShutdown = @compileError("'InitiateShutdown' requires that UNICODE be set to true or false in the root module");
        pub const ChangeServiceConfig = @compileError("'ChangeServiceConfig' requires that UNICODE be set to true or false in the root module");
        pub const CreateService = @compileError("'CreateService' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (115)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const FILETIME = @import("windows_programming.zig").FILETIME;
const D3DRECT = @import("direct3d9.zig").D3DRECT;
const TOKEN_PRIVILEGES = @import("security.zig").TOKEN_PRIVILEGES;
const DEVMODEA = @import("display_devices.zig").DEVMODEA;
const EXCEPTION_ROUTINE = @import("kernel.zig").EXCEPTION_ROUTINE;
const DD_PALETTECALLBACKS = @import("display_devices.zig").DD_PALETTECALLBACKS;
const XLATEOBJ = @import("display_devices.zig").XLATEOBJ;
const DDVIDEOPORTCONNECT = @import("core_audio.zig").DDVIDEOPORTCONNECT;
const SECURITY_DESCRIPTOR = @import("security.zig").SECURITY_DESCRIPTOR;
const GLYPHDATA = @import("display_devices.zig").GLYPHDATA;
const TOKEN_GROUPS = @import("security.zig").TOKEN_GROUPS;
const IMAGE_FILE_HEADER = @import("debug.zig").IMAGE_FILE_HEADER;
const RECT = @import("display_devices.zig").RECT;
const D3DVECTOR = @import("direct3d9.zig").D3DVECTOR;
const BRUSHOBJ = @import("display_devices.zig").BRUSHOBJ;
const DD_DIRECTDRAW_GLOBAL = @import("display_devices.zig").DD_DIRECTDRAW_GLOBAL;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const TRIVERTEX = @import("gdi.zig").TRIVERTEX;
const PARTITION_STYLE = @import("file_system.zig").PARTITION_STYLE;
const HDC = @import("gdi.zig").HDC;
const DDVIDEOPORTCAPS = @import("display_devices.zig").DDVIDEOPORTCAPS;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const PROCESS_INFORMATION_CLASS = @import("security.zig").PROCESS_INFORMATION_CLASS;
const HRESULT = @import("com.zig").HRESULT;
const RPC_BINDING_VECTOR = @import("rpc.zig").RPC_BINDING_VECTOR;
const PSID = @import("security.zig").PSID;
const LUID = @import("kernel.zig").LUID;
const PRIVILEGE_SET = @import("security.zig").PRIVILEGE_SET;
const WOW64_LDT_ENTRY = @import("debug.zig").WOW64_LDT_ENTRY;
const VIDEOMEMORY = @import("display_devices.zig").VIDEOMEMORY;
const IMAGE_DATA_DIRECTORY = @import("debug.zig").IMAGE_DATA_DIRECTORY;
const IFIMETRICS = @import("display_devices.zig").IFIMETRICS;
const STORAGE_PROTOCOL_TYPE = @import("file_system.zig").STORAGE_PROTOCOL_TYPE;
const CLIPOBJ = @import("display_devices.zig").CLIPOBJ;
const DD_SURFACECALLBACKS = @import("display_devices.zig").DD_SURFACECALLBACKS;
const RPC_MESSAGE = @import("rpc.zig").RPC_MESSAGE;
const REG_SAM_FLAGS = @import("windows_programming.zig").REG_SAM_FLAGS;
const THREADINFOCLASS = @import("windows_programming.zig").THREADINFOCLASS;
const OSVERSIONINFOEXW = @import("windows_programming.zig").OSVERSIONINFOEXW;
const IUnknown = @import("com.zig").IUnknown;
const LINEATTRS = @import("display_devices.zig").LINEATTRS;
const WNDOBJ = @import("display_devices.zig").WNDOBJ;
const GENERIC_MAPPING = @import("security.zig").GENERIC_MAPPING;
const SURFOBJ = @import("display_devices.zig").SURFOBJ;
const HBITMAP = @import("gdi.zig").HBITMAP;
const DESIGNVECTOR = @import("gdi.zig").DESIGNVECTOR;
const HWND = @import("windows_and_messaging.zig").HWND;
const SECURITY_IMPERSONATION_LEVEL = @import("security.zig").SECURITY_IMPERSONATION_LEVEL;
const VARIANT = @import("automation.zig").VARIANT;
const DDPIXELFORMAT = @import("direct_draw.zig").DDPIXELFORMAT;
const POINT = @import("display_devices.zig").POINT;
const RECTL = @import("display_devices.zig").RECTL;
const DDSCAPS = @import("direct_draw.zig").DDSCAPS;
const DD_BLTDATA = @import("display_devices.zig").DD_BLTDATA;
const PROCESS_CREATION_FLAGS = @import("windows_programming.zig").PROCESS_CREATION_FLAGS;
const DD_DIRECTDRAW_LOCAL = @import("display_devices.zig").DD_DIRECTDRAW_LOCAL;
const PIXELFORMATDESCRIPTOR = @import("open_gl.zig").PIXELFORMATDESCRIPTOR;
const LOGCOLORSPACEW = @import("windows_color_system.zig").LOGCOLORSPACEW;
const IXMLDOMDocument = @import("windows_programming.zig").IXMLDOMDocument;
const STORAGE_PROPERTY_ID = @import("file_system.zig").STORAGE_PROPERTY_ID;
const OBJECT_TYPE_LIST = @import("security.zig").OBJECT_TYPE_LIST;
const DD_CALLBACKS = @import("display_devices.zig").DD_CALLBACKS;
const CONTEXT = @import("debug.zig").CONTEXT;
const SC_HANDLE = @import("security.zig").SC_HANDLE;
const ENUMRESNAMEPROCW = @import("windows_and_messaging.zig").ENUMRESNAMEPROCW;
const THREAD_INFORMATION_CLASS = @import("windows_programming.zig").THREAD_INFORMATION_CLASS;
const PERBANDINFO = @import("display_devices.zig").PERBANDINFO;
const VIRTUAL_STORAGE_TYPE = @import("vhd.zig").VIRTUAL_STORAGE_TYPE;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const DDCOLORKEY = @import("direct_show.zig").DDCOLORKEY;
const STROBJ = @import("display_devices.zig").STROBJ;
const UNICODE_STRING = @import("security.zig").UNICODE_STRING;
const USN_RECORD_V2 = @import("file_system.zig").USN_RECORD_V2;
const FONTOBJ = @import("display_devices.zig").FONTOBJ;
const D3DTRANSFORMSTATETYPE = @import("direct3d9.zig").D3DTRANSFORMSTATETYPE;
const PALOBJ = @import("display_devices.zig").PALOBJ;
const BSTR = @import("automation.zig").BSTR;
const DEP_SYSTEM_POLICY_TYPE = @import("windows_programming.zig").DEP_SYSTEM_POLICY_TYPE;
const RPC_STATUS = @import("rpc.zig").RPC_STATUS;
const ACE_HEADER = @import("security.zig").ACE_HEADER;
const DD_HALINFO = @import("display_devices.zig").DD_HALINFO;
const D3DLIGHTTYPE = @import("direct3d9.zig").D3DLIGHTTYPE;
const DEVINFO = @import("display_devices.zig").DEVINFO;
const EXCEPTION_POINTERS = @import("debug.zig").EXCEPTION_POINTERS;
const QUEUE_STATUS_FLAGS = @import("windows_and_messaging.zig").QUEUE_STATUS_FLAGS;
const HKEY = @import("windows_programming.zig").HKEY;
const GDIINFO = @import("display_devices.zig").GDIINFO;
const LPOVERLAPPED_COMPLETION_ROUTINE = @import("file_system.zig").LPOVERLAPPED_COMPLETION_ROUTINE;
const POINTL = @import("display_devices.zig").POINTL;
const D3DCOLORVALUE = @import("direct3d9.zig").D3DCOLORVALUE;
const D3DSTATEBLOCKTYPE = @import("direct3d9.zig").D3DSTATEBLOCKTYPE;
const PPS_POST_PROCESS_INIT_ROUTINE = @import("windows_programming.zig").PPS_POST_PROCESS_INIT_ROUTINE;
const D3DRENDERSTATETYPE = @import("direct3d9.zig").D3DRENDERSTATETYPE;
const DDSURFACEDESC = @import("direct_draw.zig").DDSURFACEDESC;
const BLENDOBJ = @import("display_devices.zig").BLENDOBJ;
const PROPERTYKEY = @import("windows_properties_system.zig").PROPERTYKEY;
const COLORADJUSTMENT = @import("gdi.zig").COLORADJUSTMENT;
const USN_RECORD_COMMON_HEADER = @import("file_system.zig").USN_RECORD_COMMON_HEADER;
const USN_RECORD_V3 = @import("file_system.zig").USN_RECORD_V3;
const DRVENABLEDATA = @import("display_devices.zig").DRVENABLEDATA;
const ENUM_SERVICE_TYPE = @import("security.zig").ENUM_SERVICE_TYPE;
const PDD_GETDRIVERINFO = @import("display_devices.zig").PDD_GETDRIVERINFO;
const SID = @import("security.zig").SID;
const DEVMODEW = @import("display_devices.zig").DEVMODEW;
const LPFIBER_START_ROUTINE = @import("windows_programming.zig").LPFIBER_START_ROUTINE;
const USN_RECORD_V4 = @import("file_system.zig").USN_RECORD_V4;
const DD_SURFACE_LOCAL = @import("display_devices.zig").DD_SURFACE_LOCAL;
const FILE_ID_128 = @import("file_system.zig").FILE_ID_128;
const D3DMATRIX = @import("direct3d9.zig").D3DMATRIX;
const PATHOBJ = @import("display_devices.zig").PATHOBJ;
const VIDEOMEMORYINFO = @import("display_devices.zig").VIDEOMEMORYINFO;
const TTPOLYGONHEADER = @import("gdi.zig").TTPOLYGONHEADER;
const SIZE = @import("display_devices.zig").SIZE;
const PROCESSINFOCLASS = @import("windows_programming.zig").PROCESSINFOCLASS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PUMS_SCHEDULER_ENTRY_POINT")) { _ = PUMS_SCHEDULER_ENTRY_POINT; }
    if (@hasDecl(@This(), "PEXCEPTION_FILTER")) { _ = PEXCEPTION_FILTER; }
    if (@hasDecl(@This(), "PTERMINATION_HANDLER")) { _ = PTERMINATION_HANDLER; }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) { _ = PGET_RUNTIME_FUNCTION_CALLBACK; }
    if (@hasDecl(@This(), "POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK")) { _ = POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK; }
    if (@hasDecl(@This(), "FARPROC")) { _ = FARPROC; }
    if (@hasDecl(@This(), "NEARPROC")) { _ = NEARPROC; }
    if (@hasDecl(@This(), "PROC")) { _ = PROC; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD; }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) { _ = PGET_RUNTIME_FUNCTION_CALLBACK; }
    if (@hasDecl(@This(), "POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK")) { _ = POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK; }
    if (@hasDecl(@This(), "PEXCEPTION_FILTER")) { _ = PEXCEPTION_FILTER; }
    if (@hasDecl(@This(), "PTERMINATION_HANDLER")) { _ = PTERMINATION_HANDLER; }
    if (@hasDecl(@This(), "LPENCLAVE_TARGET_FUNCTION")) { _ = LPENCLAVE_TARGET_FUNCTION; }
    if (@hasDecl(@This(), "PIMAGE_TLS_CALLBACK")) { _ = PIMAGE_TLS_CALLBACK; }
    if (@hasDecl(@This(), "PRTL_UMS_SCHEDULER_ENTRY_POINT")) { _ = PRTL_UMS_SCHEDULER_ENTRY_POINT; }
    if (@hasDecl(@This(), "PAPCFUNC")) { _ = PAPCFUNC; }
    if (@hasDecl(@This(), "WAITORTIMERCALLBACK")) { _ = WAITORTIMERCALLBACK; }
    if (@hasDecl(@This(), "WORKERCALLBACKFUNC")) { _ = WORKERCALLBACKFUNC; }
    if (@hasDecl(@This(), "APC_CALLBACK_FUNCTION")) { _ = APC_CALLBACK_FUNCTION; }
    if (@hasDecl(@This(), "PFLS_CALLBACK_FUNCTION")) { _ = PFLS_CALLBACK_FUNCTION; }
    if (@hasDecl(@This(), "PSECURE_MEMORY_CACHE_CALLBACK")) { _ = PSECURE_MEMORY_CACHE_CALLBACK; }
    if (@hasDecl(@This(), "PTP_SIMPLE_CALLBACK")) { _ = PTP_SIMPLE_CALLBACK; }
    if (@hasDecl(@This(), "PTP_CLEANUP_GROUP_CANCEL_CALLBACK")) { _ = PTP_CLEANUP_GROUP_CANCEL_CALLBACK; }
    if (@hasDecl(@This(), "PTP_WORK_CALLBACK")) { _ = PTP_WORK_CALLBACK; }
    if (@hasDecl(@This(), "PTP_TIMER_CALLBACK")) { _ = PTP_TIMER_CALLBACK; }
    if (@hasDecl(@This(), "PTP_WAIT_CALLBACK")) { _ = PTP_WAIT_CALLBACK; }
    if (@hasDecl(@This(), "PINIT_ONCE_FN")) { _ = PINIT_ONCE_FN; }
    if (@hasDecl(@This(), "PTIMERAPCROUTINE")) { _ = PTIMERAPCROUTINE; }
    if (@hasDecl(@This(), "PTP_WIN32_IO_CALLBACK")) { _ = PTP_WIN32_IO_CALLBACK; }
    if (@hasDecl(@This(), "LPTHREAD_START_ROUTINE")) { _ = LPTHREAD_START_ROUTINE; }
    if (@hasDecl(@This(), "LPENCLAVE_ROUTINE")) { _ = LPENCLAVE_ROUTINE; }
    if (@hasDecl(@This(), "PBAD_MEMORY_CALLBACK_ROUTINE")) { _ = PBAD_MEMORY_CALLBACK_ROUTINE; }
    if (@hasDecl(@This(), "ENUMRESLANGPROCA")) { _ = ENUMRESLANGPROCA; }
    if (@hasDecl(@This(), "ENUMRESLANGPROCW")) { _ = ENUMRESLANGPROCW; }
    if (@hasDecl(@This(), "PGET_MODULE_HANDLE_EXA")) { _ = PGET_MODULE_HANDLE_EXA; }
    if (@hasDecl(@This(), "PGET_MODULE_HANDLE_EXW")) { _ = PGET_MODULE_HANDLE_EXW; }
    if (@hasDecl(@This(), "PHANDLER_ROUTINE")) { _ = PHANDLER_ROUTINE; }
    if (@hasDecl(@This(), "LPTIMECALLBACK")) { _ = LPTIMECALLBACK; }
    if (@hasDecl(@This(), "LPDDENUMVIDEOCALLBACK")) { _ = LPDDENUMVIDEOCALLBACK; }
    if (@hasDecl(@This(), "PDD_SETCOLORKEY")) { _ = PDD_SETCOLORKEY; }
    if (@hasDecl(@This(), "PDD_DESTROYDRIVER")) { _ = PDD_DESTROYDRIVER; }
    if (@hasDecl(@This(), "PDD_SETMODE")) { _ = PDD_SETMODE; }
    if (@hasDecl(@This(), "PDD_ALPHABLT")) { _ = PDD_ALPHABLT; }
    if (@hasDecl(@This(), "PDD_SURFCB_SETCLIPLIST")) { _ = PDD_SURFCB_SETCLIPLIST; }
    if (@hasDecl(@This(), "PDD_VPORTCB_GETAUTOFLIPSURF")) { _ = PDD_VPORTCB_GETAUTOFLIPSURF; }
    if (@hasDecl(@This(), "LPD3DVALIDATECALLBACK")) { _ = LPD3DVALIDATECALLBACK; }
    if (@hasDecl(@This(), "LPD3DENUMTEXTUREFORMATSCALLBACK")) { _ = LPD3DENUMTEXTUREFORMATSCALLBACK; }
    if (@hasDecl(@This(), "LPD3DENUMPIXELFORMATSCALLBACK")) { _ = LPD3DENUMPIXELFORMATSCALLBACK; }
    if (@hasDecl(@This(), "LPD3DENUMDEVICESCALLBACK")) { _ = LPD3DENUMDEVICESCALLBACK; }
    if (@hasDecl(@This(), "LPD3DENUMDEVICESCALLBACK7")) { _ = LPD3DENUMDEVICESCALLBACK7; }
    if (@hasDecl(@This(), "LPD3DNTHAL_CONTEXTCREATECB")) { _ = LPD3DNTHAL_CONTEXTCREATECB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_CONTEXTDESTROYCB")) { _ = LPD3DNTHAL_CONTEXTDESTROYCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_CONTEXTDESTROYALLCB")) { _ = LPD3DNTHAL_CONTEXTDESTROYALLCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_SCENECAPTURECB")) { _ = LPD3DNTHAL_SCENECAPTURECB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_TEXTURECREATECB")) { _ = LPD3DNTHAL_TEXTURECREATECB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_TEXTUREDESTROYCB")) { _ = LPD3DNTHAL_TEXTUREDESTROYCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_TEXTURESWAPCB")) { _ = LPD3DNTHAL_TEXTURESWAPCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_TEXTUREGETSURFCB")) { _ = LPD3DNTHAL_TEXTUREGETSURFCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_SETRENDERTARGETCB")) { _ = LPD3DNTHAL_SETRENDERTARGETCB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_CLEAR2CB")) { _ = LPD3DNTHAL_CLEAR2CB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB")) { _ = LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB; }
    if (@hasDecl(@This(), "LPD3DNTHAL_DRAWPRIMITIVES2CB")) { _ = LPD3DNTHAL_DRAWPRIMITIVES2CB; }
    if (@hasDecl(@This(), "PFND3DNTPARSEUNKNOWNCOMMAND")) { _ = PFND3DNTPARSEUNKNOWNCOMMAND; }
    if (@hasDecl(@This(), "PFN")) { _ = PFN; }
    if (@hasDecl(@This(), "WNDOBJCHANGEPROC")) { _ = WNDOBJCHANGEPROC; }
    if (@hasDecl(@This(), "SORTCOMP")) { _ = SORTCOMP; }
    if (@hasDecl(@This(), "PFN_DrvEnableDriver")) { _ = PFN_DrvEnableDriver; }
    if (@hasDecl(@This(), "PFN_DrvEnablePDEV")) { _ = PFN_DrvEnablePDEV; }
    if (@hasDecl(@This(), "PFN_DrvCompletePDEV")) { _ = PFN_DrvCompletePDEV; }
    if (@hasDecl(@This(), "PFN_DrvResetDevice")) { _ = PFN_DrvResetDevice; }
    if (@hasDecl(@This(), "PFN_DrvDisablePDEV")) { _ = PFN_DrvDisablePDEV; }
    if (@hasDecl(@This(), "PFN_DrvSynchronize")) { _ = PFN_DrvSynchronize; }
    if (@hasDecl(@This(), "PFN_DrvEnableSurface")) { _ = PFN_DrvEnableSurface; }
    if (@hasDecl(@This(), "PFN_DrvDisableDriver")) { _ = PFN_DrvDisableDriver; }
    if (@hasDecl(@This(), "PFN_DrvDisableSurface")) { _ = PFN_DrvDisableSurface; }
    if (@hasDecl(@This(), "PFN_DrvAssertMode")) { _ = PFN_DrvAssertMode; }
    if (@hasDecl(@This(), "PFN_DrvTextOut")) { _ = PFN_DrvTextOut; }
    if (@hasDecl(@This(), "PFN_DrvStretchBlt")) { _ = PFN_DrvStretchBlt; }
    if (@hasDecl(@This(), "PFN_DrvStretchBltROP")) { _ = PFN_DrvStretchBltROP; }
    if (@hasDecl(@This(), "PFN_DrvTransparentBlt")) { _ = PFN_DrvTransparentBlt; }
    if (@hasDecl(@This(), "PFN_DrvPlgBlt")) { _ = PFN_DrvPlgBlt; }
    if (@hasDecl(@This(), "PFN_DrvBitBlt")) { _ = PFN_DrvBitBlt; }
    if (@hasDecl(@This(), "PFN_DrvRealizeBrush")) { _ = PFN_DrvRealizeBrush; }
    if (@hasDecl(@This(), "PFN_DrvCopyBits")) { _ = PFN_DrvCopyBits; }
    if (@hasDecl(@This(), "PFN_DrvDitherColor")) { _ = PFN_DrvDitherColor; }
    if (@hasDecl(@This(), "PFN_DrvCreateDeviceBitmap")) { _ = PFN_DrvCreateDeviceBitmap; }
    if (@hasDecl(@This(), "PFN_DrvDeleteDeviceBitmap")) { _ = PFN_DrvDeleteDeviceBitmap; }
    if (@hasDecl(@This(), "PFN_DrvSetPalette")) { _ = PFN_DrvSetPalette; }
    if (@hasDecl(@This(), "PFN_DrvEscape")) { _ = PFN_DrvEscape; }
    if (@hasDecl(@This(), "PFN_DrvDrawEscape")) { _ = PFN_DrvDrawEscape; }
    if (@hasDecl(@This(), "PFN_DrvQueryFont")) { _ = PFN_DrvQueryFont; }
    if (@hasDecl(@This(), "PFN_DrvQueryFontTree")) { _ = PFN_DrvQueryFontTree; }
    if (@hasDecl(@This(), "PFN_DrvQueryFontData")) { _ = PFN_DrvQueryFontData; }
    if (@hasDecl(@This(), "PFN_DrvFree")) { _ = PFN_DrvFree; }
    if (@hasDecl(@This(), "PFN_DrvDestroyFont")) { _ = PFN_DrvDestroyFont; }
    if (@hasDecl(@This(), "PFN_DrvQueryFontCaps")) { _ = PFN_DrvQueryFontCaps; }
    if (@hasDecl(@This(), "PFN_DrvLoadFontFile")) { _ = PFN_DrvLoadFontFile; }
    if (@hasDecl(@This(), "PFN_DrvUnloadFontFile")) { _ = PFN_DrvUnloadFontFile; }
    if (@hasDecl(@This(), "PFN_DrvSetPointerShape")) { _ = PFN_DrvSetPointerShape; }
    if (@hasDecl(@This(), "PFN_DrvMovePointer")) { _ = PFN_DrvMovePointer; }
    if (@hasDecl(@This(), "PFN_DrvSendPage")) { _ = PFN_DrvSendPage; }
    if (@hasDecl(@This(), "PFN_DrvStartPage")) { _ = PFN_DrvStartPage; }
    if (@hasDecl(@This(), "PFN_DrvStartDoc")) { _ = PFN_DrvStartDoc; }
    if (@hasDecl(@This(), "PFN_DrvEndDoc")) { _ = PFN_DrvEndDoc; }
    if (@hasDecl(@This(), "PFN_DrvQuerySpoolType")) { _ = PFN_DrvQuerySpoolType; }
    if (@hasDecl(@This(), "PFN_DrvLineTo")) { _ = PFN_DrvLineTo; }
    if (@hasDecl(@This(), "PFN_DrvStrokePath")) { _ = PFN_DrvStrokePath; }
    if (@hasDecl(@This(), "PFN_DrvFillPath")) { _ = PFN_DrvFillPath; }
    if (@hasDecl(@This(), "PFN_DrvStrokeAndFillPath")) { _ = PFN_DrvStrokeAndFillPath; }
    if (@hasDecl(@This(), "PFN_DrvPaint")) { _ = PFN_DrvPaint; }
    if (@hasDecl(@This(), "PFN_DrvGetGlyphMode")) { _ = PFN_DrvGetGlyphMode; }
    if (@hasDecl(@This(), "PFN_DrvResetPDEV")) { _ = PFN_DrvResetPDEV; }
    if (@hasDecl(@This(), "PFN_DrvSaveScreenBits")) { _ = PFN_DrvSaveScreenBits; }
    if (@hasDecl(@This(), "PFN_DrvGetModes")) { _ = PFN_DrvGetModes; }
    if (@hasDecl(@This(), "PFN_DrvQueryTrueTypeTable")) { _ = PFN_DrvQueryTrueTypeTable; }
    if (@hasDecl(@This(), "PFN_DrvQueryTrueTypeSection")) { _ = PFN_DrvQueryTrueTypeSection; }
    if (@hasDecl(@This(), "PFN_DrvQueryTrueTypeOutline")) { _ = PFN_DrvQueryTrueTypeOutline; }
    if (@hasDecl(@This(), "PFN_DrvGetTrueTypeFile")) { _ = PFN_DrvGetTrueTypeFile; }
    if (@hasDecl(@This(), "PFN_DrvQueryFontFile")) { _ = PFN_DrvQueryFontFile; }
    if (@hasDecl(@This(), "PFN_DrvQueryAdvanceWidths")) { _ = PFN_DrvQueryAdvanceWidths; }
    if (@hasDecl(@This(), "PFN_DrvFontManagement")) { _ = PFN_DrvFontManagement; }
    if (@hasDecl(@This(), "PFN_DrvSetPixelFormat")) { _ = PFN_DrvSetPixelFormat; }
    if (@hasDecl(@This(), "PFN_DrvDescribePixelFormat")) { _ = PFN_DrvDescribePixelFormat; }
    if (@hasDecl(@This(), "PFN_DrvSwapBuffers")) { _ = PFN_DrvSwapBuffers; }
    if (@hasDecl(@This(), "PFN_DrvStartBanding")) { _ = PFN_DrvStartBanding; }
    if (@hasDecl(@This(), "PFN_DrvNextBand")) { _ = PFN_DrvNextBand; }
    if (@hasDecl(@This(), "PFN_DrvQueryPerBandInfo")) { _ = PFN_DrvQueryPerBandInfo; }
    if (@hasDecl(@This(), "PFN_DrvEnableDirectDraw")) { _ = PFN_DrvEnableDirectDraw; }
    if (@hasDecl(@This(), "PFN_DrvDisableDirectDraw")) { _ = PFN_DrvDisableDirectDraw; }
    if (@hasDecl(@This(), "PFN_DrvGetDirectDrawInfo")) { _ = PFN_DrvGetDirectDrawInfo; }
    if (@hasDecl(@This(), "PFN_DrvIcmCreateColorTransform")) { _ = PFN_DrvIcmCreateColorTransform; }
    if (@hasDecl(@This(), "PFN_DrvIcmDeleteColorTransform")) { _ = PFN_DrvIcmDeleteColorTransform; }
    if (@hasDecl(@This(), "PFN_DrvIcmCheckBitmapBits")) { _ = PFN_DrvIcmCheckBitmapBits; }
    if (@hasDecl(@This(), "PFN_DrvIcmSetDeviceGammaRamp")) { _ = PFN_DrvIcmSetDeviceGammaRamp; }
    if (@hasDecl(@This(), "PFN_DrvAlphaBlend")) { _ = PFN_DrvAlphaBlend; }
    if (@hasDecl(@This(), "PFN_DrvGradientFill")) { _ = PFN_DrvGradientFill; }
    if (@hasDecl(@This(), "PFN_DrvQueryDeviceSupport")) { _ = PFN_DrvQueryDeviceSupport; }
    if (@hasDecl(@This(), "PFN_DrvDeriveSurface")) { _ = PFN_DrvDeriveSurface; }
    if (@hasDecl(@This(), "PFN_DrvSynchronizeSurface")) { _ = PFN_DrvSynchronizeSurface; }
    if (@hasDecl(@This(), "PFN_DrvNotify")) { _ = PFN_DrvNotify; }
    if (@hasDecl(@This(), "PFN_DrvRenderHint")) { _ = PFN_DrvRenderHint; }
    if (@hasDecl(@This(), "PFN_EngCreateRectRgn")) { _ = PFN_EngCreateRectRgn; }
    if (@hasDecl(@This(), "PFN_EngDeleteRgn")) { _ = PFN_EngDeleteRgn; }
    if (@hasDecl(@This(), "PFN_EngCombineRgn")) { _ = PFN_EngCombineRgn; }
    if (@hasDecl(@This(), "PFN_EngCopyRgn")) { _ = PFN_EngCopyRgn; }
    if (@hasDecl(@This(), "PFN_EngIntersectRgn")) { _ = PFN_EngIntersectRgn; }
    if (@hasDecl(@This(), "PFN_EngSubtractRgn")) { _ = PFN_EngSubtractRgn; }
    if (@hasDecl(@This(), "PFN_EngUnionRgn")) { _ = PFN_EngUnionRgn; }
    if (@hasDecl(@This(), "PFN_EngXorRgn")) { _ = PFN_EngXorRgn; }
    if (@hasDecl(@This(), "PFN_DrvCreateDeviceBitmapEx")) { _ = PFN_DrvCreateDeviceBitmapEx; }
    if (@hasDecl(@This(), "PFN_DrvDeleteDeviceBitmapEx")) { _ = PFN_DrvDeleteDeviceBitmapEx; }
    if (@hasDecl(@This(), "PFN_DrvAssociateSharedSurface")) { _ = PFN_DrvAssociateSharedSurface; }
    if (@hasDecl(@This(), "PFN_DrvSynchronizeRedirectionBitmaps")) { _ = PFN_DrvSynchronizeRedirectionBitmaps; }
    if (@hasDecl(@This(), "PFN_DrvAccumulateD3DDirtyRect")) { _ = PFN_DrvAccumulateD3DDirtyRect; }
    if (@hasDecl(@This(), "PFN_DrvStartDxInterop")) { _ = PFN_DrvStartDxInterop; }
    if (@hasDecl(@This(), "PFN_DrvEndDxInterop")) { _ = PFN_DrvEndDxInterop; }
    if (@hasDecl(@This(), "PFN_DrvLockDisplayArea")) { _ = PFN_DrvLockDisplayArea; }
    if (@hasDecl(@This(), "PFN_DrvUnlockDisplayArea")) { _ = PFN_DrvUnlockDisplayArea; }
    if (@hasDecl(@This(), "PFN_DrvSurfaceComplete")) { _ = PFN_DrvSurfaceComplete; }
    if (@hasDecl(@This(), "PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK")) { _ = PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA; }
    if (@hasDecl(@This(), "EFFECTIVE_POWER_MODE_CALLBACK")) { _ = EFFECTIVE_POWER_MODE_CALLBACK; }
    if (@hasDecl(@This(), "PWRSCHEMESENUMPROC_V1")) { _ = PWRSCHEMESENUMPROC_V1; }
    if (@hasDecl(@This(), "PWRSCHEMESENUMPROC")) { _ = PWRSCHEMESENUMPROC; }
    if (@hasDecl(@This(), "PDEVICE_NOTIFY_CALLBACK_ROUTINE")) { _ = PDEVICE_NOTIFY_CALLBACK_ROUTINE; }
    if (@hasDecl(@This(), "PVIDEO_WIN32K_CALLOUT")) { _ = PVIDEO_WIN32K_CALLOUT; }
    if (@hasDecl(@This(), "FARPROC")) { _ = FARPROC; }
    if (@hasDecl(@This(), "NEARPROC")) { _ = NEARPROC; }
    if (@hasDecl(@This(), "PROC")) { _ = PROC; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD; }
    if (@hasDecl(@This(), "VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD")) { _ = VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
