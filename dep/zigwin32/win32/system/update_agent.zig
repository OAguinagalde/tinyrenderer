//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (467)
//--------------------------------------------------------------------------------
pub const LIBID_WUApiLib = Guid.initString("b596cc9f-56e5-419e-a622-e01bb457431e");
pub const UPDATE_LOCKDOWN_WEBSITE_ACCESS = @as(u32, 1);
pub const WU_S_SERVICE_STOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359297));
pub const WU_S_SELFUPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359298));
pub const WU_S_UPDATE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359299));
pub const WU_S_MARKED_FOR_DISCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359300));
pub const WU_S_REBOOT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359301));
pub const WU_S_ALREADY_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359302));
pub const WU_S_ALREADY_UNINSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359303));
pub const WU_S_ALREADY_DOWNLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359304));
pub const WU_S_SOME_UPDATES_SKIPPED_ON_BATTERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359305));
pub const WU_S_ALREADY_REVERTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359306));
pub const WU_S_SEARCH_CRITERIA_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2359312));
pub const WU_S_UH_INSTALLSTILLPENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2367509));
pub const WU_S_UH_DOWNLOAD_SIZE_CALCULATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2367510));
pub const WU_S_SIH_NOOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2379777));
pub const WU_S_DM_ALREADYDOWNLOADING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2383873));
pub const WU_S_METADATA_SKIPPED_BY_ENFORCEMENTMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2388225));
pub const WU_S_METADATA_IGNORED_SIGNATURE_VERIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2388226));
pub const WU_S_SEARCH_LOAD_SHEDDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2392065));
pub const WU_E_NO_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124351));
pub const WU_E_MAX_CAPACITY_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124350));
pub const WU_E_UNKNOWN_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124349));
pub const WU_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124348));
pub const WU_E_RANGEOVERLAP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124347));
pub const WU_E_TOOMANYRANGES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124346));
pub const WU_E_INVALIDINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124345));
pub const WU_E_ITEMNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124344));
pub const WU_E_OPERATIONINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124343));
pub const WU_E_COULDNOTCANCEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124342));
pub const WU_E_CALL_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124341));
pub const WU_E_NOOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124340));
pub const WU_E_XML_MISSINGDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124339));
pub const WU_E_XML_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124338));
pub const WU_E_CYCLE_DETECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124337));
pub const WU_E_TOO_DEEP_RELATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124336));
pub const WU_E_INVALID_RELATIONSHIP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124335));
pub const WU_E_REG_VALUE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124334));
pub const WU_E_DUPLICATE_ITEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124333));
pub const WU_E_INVALID_INSTALL_REQUESTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124332));
pub const WU_E_INSTALL_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124330));
pub const WU_E_NOT_APPLICABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124329));
pub const WU_E_NO_USERTOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124328));
pub const WU_E_EXCLUSIVE_INSTALL_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124327));
pub const WU_E_POLICY_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124326));
pub const WU_E_SELFUPDATE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124325));
pub const WU_E_INVALID_UPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124323));
pub const WU_E_SERVICE_STOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124322));
pub const WU_E_NO_CONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124321));
pub const WU_E_NO_INTERACTIVE_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124320));
pub const WU_E_TIME_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124319));
pub const WU_E_ALL_UPDATES_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124318));
pub const WU_E_EULAS_DECLINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124317));
pub const WU_E_NO_UPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124316));
pub const WU_E_USER_ACCESS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124315));
pub const WU_E_INVALID_UPDATE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124314));
pub const WU_E_URL_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124313));
pub const WU_E_UNINSTALL_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124312));
pub const WU_E_INVALID_PRODUCT_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124311));
pub const WU_E_MISSING_HANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124310));
pub const WU_E_LEGACYSERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124309));
pub const WU_E_BIN_SOURCE_ABSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124308));
pub const WU_E_SOURCE_ABSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124307));
pub const WU_E_WU_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124306));
pub const WU_E_CALL_CANCELLED_BY_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124305));
pub const WU_E_INVALID_PROXY_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124304));
pub const WU_E_INVALID_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124303));
pub const WU_E_INVALID_CRITERIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124302));
pub const WU_E_EULA_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124301));
pub const WU_E_DOWNLOAD_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124300));
pub const WU_E_UPDATE_NOT_PROCESSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124299));
pub const WU_E_INVALID_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124298));
pub const WU_E_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124297));
pub const WU_E_WINHTTP_INVALID_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124296));
pub const WU_E_TOO_MANY_RESYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124295));
pub const WU_E_NO_SERVER_CORE_SUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124288));
pub const WU_E_SYSPREP_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124287));
pub const WU_E_UNKNOWN_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124286));
pub const WU_E_NO_UI_SUPPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124285));
pub const WU_E_PER_MACHINE_UPDATE_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124284));
pub const WU_E_UNSUPPORTED_SEARCHSCOPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124283));
pub const WU_E_BAD_FILE_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124282));
pub const WU_E_REVERT_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124281));
pub const WU_E_INVALID_NOTIFICATION_INFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124280));
pub const WU_E_OUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124279));
pub const WU_E_SETUP_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124278));
pub const WU_E_ORPHANED_DOWNLOAD_JOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124277));
pub const WU_E_LOW_BATTERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124276));
pub const WU_E_INFRASTRUCTUREFILE_INVALID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124275));
pub const WU_E_INFRASTRUCTUREFILE_REQUIRES_SSL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124274));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_DISCOVERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124273));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_SEARCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124272));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_DOWNLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124271));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_INSTALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124270));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_OTHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124269));
pub const WU_E_INTERACTIVE_CALL_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124268));
pub const WU_E_AU_CALL_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124267));
pub const WU_E_SYSTEM_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124266));
pub const WU_E_NO_SUCH_HANDLER_PLUGIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124265));
pub const WU_E_INVALID_SERIALIZATION_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124264));
pub const WU_E_NETWORK_COST_EXCEEDS_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124263));
pub const WU_E_CALL_CANCELLED_BY_HIDE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124262));
pub const WU_E_CALL_CANCELLED_BY_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124261));
pub const WU_E_INVALID_VOLUMEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124260));
pub const WU_E_UNRECOGNIZED_VOLUMEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124259));
pub const WU_E_EXTENDEDERROR_NOTSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124258));
pub const WU_E_EXTENDEDERROR_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124257));
pub const WU_E_IDLESHUTDOWN_OPCOUNT_SERVICEREGISTRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124256));
pub const WU_E_FILETRUST_SHA2SIGNATURE_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124255));
pub const WU_E_UPDATE_NOT_APPROVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124254));
pub const WU_E_CALL_CANCELLED_BY_INTERACTIVE_SEARCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124253));
pub const WU_E_INSTALL_JOB_RESUME_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124252));
pub const WU_E_INSTALL_JOB_NOT_SUSPENDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124251));
pub const WU_E_INSTALL_USERCONTEXT_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145124250));
pub const WU_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120257));
pub const WU_E_MSI_WRONG_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120255));
pub const WU_E_MSI_NOT_CONFIGURED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120254));
pub const WU_E_MSP_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120253));
pub const WU_E_MSI_WRONG_APP_CONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120252));
pub const WU_E_MSI_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145120251));
pub const WU_E_MSP_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116161));
pub const WU_E_PT_SOAPCLIENT_BASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107968));
pub const WU_E_PT_SOAPCLIENT_INITIALIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107967));
pub const WU_E_PT_SOAPCLIENT_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107966));
pub const WU_E_PT_SOAPCLIENT_GENERATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107965));
pub const WU_E_PT_SOAPCLIENT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107964));
pub const WU_E_PT_SOAPCLIENT_SEND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107963));
pub const WU_E_PT_SOAPCLIENT_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107962));
pub const WU_E_PT_SOAPCLIENT_SOAPFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107961));
pub const WU_E_PT_SOAPCLIENT_PARSEFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107960));
pub const WU_E_PT_SOAPCLIENT_READ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107959));
pub const WU_E_PT_SOAPCLIENT_PARSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107958));
pub const WU_E_PT_SOAP_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107957));
pub const WU_E_PT_SOAP_MUST_UNDERSTAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107956));
pub const WU_E_PT_SOAP_CLIENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107955));
pub const WU_E_PT_SOAP_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107954));
pub const WU_E_PT_WMI_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107953));
pub const WU_E_PT_EXCEEDED_MAX_SERVER_TRIPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107952));
pub const WU_E_PT_SUS_SERVER_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107951));
pub const WU_E_PT_DOUBLE_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107950));
pub const WU_E_PT_INVALID_COMPUTER_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107949));
pub const WU_E_PT_REFRESH_CACHE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107947));
pub const WU_E_PT_HTTP_STATUS_BAD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107946));
pub const WU_E_PT_HTTP_STATUS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107945));
pub const WU_E_PT_HTTP_STATUS_FORBIDDEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107944));
pub const WU_E_PT_HTTP_STATUS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107943));
pub const WU_E_PT_HTTP_STATUS_BAD_METHOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107942));
pub const WU_E_PT_HTTP_STATUS_PROXY_AUTH_REQ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107941));
pub const WU_E_PT_HTTP_STATUS_REQUEST_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107940));
pub const WU_E_PT_HTTP_STATUS_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107939));
pub const WU_E_PT_HTTP_STATUS_GONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107938));
pub const WU_E_PT_HTTP_STATUS_SERVER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107937));
pub const WU_E_PT_HTTP_STATUS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107936));
pub const WU_E_PT_HTTP_STATUS_BAD_GATEWAY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107935));
pub const WU_E_PT_HTTP_STATUS_SERVICE_UNAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107934));
pub const WU_E_PT_HTTP_STATUS_GATEWAY_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107933));
pub const WU_E_PT_HTTP_STATUS_VERSION_NOT_SUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107932));
pub const WU_E_PT_FILE_LOCATIONS_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107931));
pub const WU_E_PT_REGISTRATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107930));
pub const WU_E_PT_NO_AUTH_PLUGINS_REQUESTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107929));
pub const WU_E_PT_NO_AUTH_COOKIES_CREATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107928));
pub const WU_E_PT_INVALID_CONFIG_PROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107927));
pub const WU_E_PT_CONFIG_PROP_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107926));
pub const WU_E_PT_HTTP_STATUS_NOT_MAPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107925));
pub const WU_E_PT_WINHTTP_NAME_NOT_RESOLVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107924));
pub const WU_E_PT_LOAD_SHEDDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107923));
pub const WU_E_PT_SAME_REDIR_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103827));
pub const WU_E_PT_NO_MANAGED_RECOVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103826));
pub const WU_E_PT_ECP_SUCCEEDED_WITH_ERRORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107921));
pub const WU_E_PT_ECP_INIT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107920));
pub const WU_E_PT_ECP_INVALID_FILE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107919));
pub const WU_E_PT_ECP_INVALID_METADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107918));
pub const WU_E_PT_ECP_FAILURE_TO_EXTRACT_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107917));
pub const WU_E_PT_ECP_FAILURE_TO_DECOMPRESS_CAB_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107916));
pub const WU_E_PT_ECP_FILE_LOCATION_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107915));
pub const WU_E_PT_CATALOG_SYNC_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123274));
pub const WU_E_PT_SECURITY_VERIFICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123273));
pub const WU_E_PT_ENDPOINT_UNREACHABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123272));
pub const WU_E_PT_INVALID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123271));
pub const WU_E_PT_INVALID_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123270));
pub const WU_E_PT_NWS_NOT_LOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123269));
pub const WU_E_PT_PROXY_AUTH_SCHEME_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123268));
pub const WU_E_SERVICEPROP_NOTAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123267));
pub const WU_E_PT_ENDPOINT_REFRESH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123266));
pub const WU_E_PT_ENDPOINTURL_NOTAVAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123265));
pub const WU_E_PT_ENDPOINT_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123264));
pub const WU_E_PT_INVALID_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123263));
pub const WU_E_PT_OBJECT_FAULTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123262));
pub const WU_E_PT_NUMERIC_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123261));
pub const WU_E_PT_OPERATION_ABORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123260));
pub const WU_E_PT_OPERATION_ABANDONED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123259));
pub const WU_E_PT_QUOTA_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123258));
pub const WU_E_PT_NO_TRANSLATION_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123257));
pub const WU_E_PT_ADDRESS_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123256));
pub const WU_E_PT_ADDRESS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123255));
pub const WU_E_PT_OTHER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123254));
pub const WU_E_PT_SECURITY_SYSTEM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145123253));
pub const WU_E_PT_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103873));
pub const WU_E_REDIRECTOR_LOAD_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103871));
pub const WU_E_REDIRECTOR_S_FALSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103870));
pub const WU_E_REDIRECTOR_ID_SMALLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103869));
pub const WU_E_REDIRECTOR_UNKNOWN_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103868));
pub const WU_E_REDIRECTOR_UNSUPPORTED_CONTENTTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103867));
pub const WU_E_REDIRECTOR_INVALID_RESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103866));
pub const WU_E_REDIRECTOR_ATTRPROVIDER_EXCEEDED_MAX_NAMEVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103864));
pub const WU_E_REDIRECTOR_ATTRPROVIDER_INVALID_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103863));
pub const WU_E_REDIRECTOR_ATTRPROVIDER_INVALID_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103862));
pub const WU_E_REDIRECTOR_SLS_GENERIC_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103861));
pub const WU_E_REDIRECTOR_CONNECT_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103860));
pub const WU_E_REDIRECTOR_ONLINE_DISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103859));
pub const WU_E_REDIRECTOR_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103617));
pub const WU_E_SIH_VERIFY_DOWNLOAD_ENGINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103615));
pub const WU_E_SIH_VERIFY_DOWNLOAD_PAYLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103614));
pub const WU_E_SIH_VERIFY_STAGE_ENGINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103613));
pub const WU_E_SIH_VERIFY_STAGE_PAYLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103612));
pub const WU_E_SIH_ACTION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103611));
pub const WU_E_SIH_SLS_PARSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103610));
pub const WU_E_SIH_INVALIDHASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103609));
pub const WU_E_SIH_NO_ENGINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103608));
pub const WU_E_SIH_POST_REBOOT_INSTALL_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103607));
pub const WU_E_SIH_POST_REBOOT_NO_CACHED_SLS_RESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103606));
pub const WU_E_SIH_PARSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103605));
pub const WU_E_SIH_SECURITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103604));
pub const WU_E_SIH_PPL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103603));
pub const WU_E_SIH_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103602));
pub const WU_E_SIH_STDEXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103601));
pub const WU_E_SIH_NONSTDEXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103600));
pub const WU_E_SIH_ENGINE_EXCEPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103599));
pub const WU_E_SIH_BLOCKED_FOR_PLATFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103598));
pub const WU_E_SIH_ANOTHER_INSTANCE_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103597));
pub const WU_E_SIH_DNSRESILIENCY_OFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103596));
pub const WU_E_SIH_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145103361));
pub const WU_E_DRV_PRUNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075199));
pub const WU_E_DRV_NOPROP_OR_LEGACY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075198));
pub const WU_E_DRV_REG_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075197));
pub const WU_E_DRV_NO_METADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075196));
pub const WU_E_DRV_MISSING_ATTRIBUTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075195));
pub const WU_E_DRV_SYNC_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075194));
pub const WU_E_DRV_NO_PRINTER_CONTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075193));
pub const WU_E_DRV_DEVICE_PROBLEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145075192));
pub const WU_E_DRV_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071105));
pub const WU_E_DS_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091584));
pub const WU_E_DS_INUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091583));
pub const WU_E_DS_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091582));
pub const WU_E_DS_TABLEMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091581));
pub const WU_E_DS_TABLEINCORRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091580));
pub const WU_E_DS_INVALIDTABLENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091579));
pub const WU_E_DS_BADVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091578));
pub const WU_E_DS_NODATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091577));
pub const WU_E_DS_MISSINGDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091576));
pub const WU_E_DS_MISSINGREF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091575));
pub const WU_E_DS_UNKNOWNHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091574));
pub const WU_E_DS_CANTDELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091573));
pub const WU_E_DS_LOCKTIMEOUTEXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091572));
pub const WU_E_DS_NOCATEGORIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091571));
pub const WU_E_DS_ROWEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091570));
pub const WU_E_DS_STOREFILELOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091569));
pub const WU_E_DS_CANNOTREGISTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091568));
pub const WU_E_DS_UNABLETOSTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091567));
pub const WU_E_DS_DUPLICATEUPDATEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091565));
pub const WU_E_DS_UNKNOWNSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091564));
pub const WU_E_DS_SERVICEEXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091563));
pub const WU_E_DS_DECLINENOTALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091562));
pub const WU_E_DS_TABLESESSIONMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091561));
pub const WU_E_DS_SESSIONLOCKMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091560));
pub const WU_E_DS_NEEDWINDOWSSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091559));
pub const WU_E_DS_INVALIDOPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091558));
pub const WU_E_DS_SCHEMAMISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091557));
pub const WU_E_DS_RESETREQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091556));
pub const WU_E_DS_IMPERSONATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091555));
pub const WU_E_DS_DATANOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091554));
pub const WU_E_DS_DATANOTLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091553));
pub const WU_E_DS_NODATA_NOSUCHREVISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091552));
pub const WU_E_DS_NODATA_NOSUCHUPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091551));
pub const WU_E_DS_NODATA_EULA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091550));
pub const WU_E_DS_NODATA_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091549));
pub const WU_E_DS_NODATA_COOKIE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091548));
pub const WU_E_DS_NODATA_TIMER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091547));
pub const WU_E_DS_NODATA_CCR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091546));
pub const WU_E_DS_NODATA_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091545));
pub const WU_E_DS_NODATA_DOWNLOADJOB = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091544));
pub const WU_E_DS_NODATA_TMI = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091543));
pub const WU_E_DS_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087489));
pub const WU_E_INVENTORY_PARSEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087487));
pub const WU_E_INVENTORY_GET_INVENTORY_TYPE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087486));
pub const WU_E_INVENTORY_RESULT_UPLOAD_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087485));
pub const WU_E_INVENTORY_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087484));
pub const WU_E_INVENTORY_WMI_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145087483));
pub const WU_E_AU_NOSERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083392));
pub const WU_E_AU_NONLEGACYSERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083390));
pub const WU_E_AU_LEGACYCLIENTDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083389));
pub const WU_E_AU_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083388));
pub const WU_E_AU_NO_REGISTERED_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083387));
pub const WU_E_AU_DETECT_SVCID_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083386));
pub const WU_E_REBOOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083385));
pub const WU_E_AU_OOBE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145083384));
pub const WU_E_AU_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079297));
pub const WU_E_UH_REMOTEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116160));
pub const WU_E_UH_LOCALONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116159));
pub const WU_E_UH_UNKNOWNHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116158));
pub const WU_E_UH_REMOTEALREADYACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116157));
pub const WU_E_UH_DOESNOTSUPPORTACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116156));
pub const WU_E_UH_WRONGHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116155));
pub const WU_E_UH_INVALIDMETADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116154));
pub const WU_E_UH_INSTALLERHUNG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116153));
pub const WU_E_UH_OPERATIONCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116152));
pub const WU_E_UH_BADHANDLERXML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116151));
pub const WU_E_UH_CANREQUIREINPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116150));
pub const WU_E_UH_INSTALLERFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116149));
pub const WU_E_UH_FALLBACKTOSELFCONTAINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116148));
pub const WU_E_UH_NEEDANOTHERDOWNLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116147));
pub const WU_E_UH_NOTIFYFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116146));
pub const WU_E_UH_INCONSISTENT_FILE_NAMES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116145));
pub const WU_E_UH_FALLBACKERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116144));
pub const WU_E_UH_TOOMANYDOWNLOADREQUESTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116143));
pub const WU_E_UH_UNEXPECTEDCBSRESPONSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116142));
pub const WU_E_UH_BADCBSPACKAGEID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116141));
pub const WU_E_UH_POSTREBOOTSTILLPENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116140));
pub const WU_E_UH_POSTREBOOTRESULTUNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116139));
pub const WU_E_UH_POSTREBOOTUNEXPECTEDSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116138));
pub const WU_E_UH_NEW_SERVICING_STACK_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116137));
pub const WU_E_UH_CALLED_BACK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116136));
pub const WU_E_UH_CUSTOMINSTALLER_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116135));
pub const WU_E_UH_UNSUPPORTED_INSTALLCONTEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116134));
pub const WU_E_UH_INVALID_TARGETSESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116133));
pub const WU_E_UH_DECRYPTFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116132));
pub const WU_E_UH_HANDLER_DISABLEDUNTILREBOOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116131));
pub const WU_E_UH_APPX_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116130));
pub const WU_E_UH_NOTREADYTOCOMMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116129));
pub const WU_E_UH_APPX_INVALID_PACKAGE_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116128));
pub const WU_E_UH_APPX_DEFAULT_PACKAGE_VOLUME_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116127));
pub const WU_E_UH_APPX_INSTALLED_PACKAGE_VOLUME_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116126));
pub const WU_E_UH_APPX_PACKAGE_FAMILY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116125));
pub const WU_E_UH_APPX_SYSTEM_VOLUME_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145116124));
pub const WU_E_UH_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145112065));
pub const WU_E_DM_URLNOTAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099775));
pub const WU_E_DM_INCORRECTFILEHASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099774));
pub const WU_E_DM_UNKNOWNALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099773));
pub const WU_E_DM_NEEDDOWNLOADREQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099772));
pub const WU_E_DM_NONETWORK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099771));
pub const WU_E_DM_WRONGBITSVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099770));
pub const WU_E_DM_NOTDOWNLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099769));
pub const WU_E_DM_FAILTOCONNECTTOBITS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099768));
pub const WU_E_DM_BITSTRANSFERERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099767));
pub const WU_E_DM_DOWNLOADLOCATIONCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099766));
pub const WU_E_DM_CONTENTCHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099765));
pub const WU_E_DM_DOWNLOADLIMITEDBYUPDATESIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099764));
pub const WU_E_DM_UNAUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099762));
pub const WU_E_DM_BG_ERROR_TOKEN_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099761));
pub const WU_E_DM_DOWNLOADSANDBOXNOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099760));
pub const WU_E_DM_DOWNLOADFILEPATHUNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099759));
pub const WU_E_DM_DOWNLOADFILEMISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099758));
pub const WU_E_DM_UPDATEREMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099757));
pub const WU_E_DM_READRANGEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099756));
pub const WU_E_DM_UNAUTHORIZED_NO_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099754));
pub const WU_E_DM_UNAUTHORIZED_LOCAL_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099753));
pub const WU_E_DM_UNAUTHORIZED_DOMAIN_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099752));
pub const WU_E_DM_UNAUTHORIZED_MSA_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099751));
pub const WU_E_DM_FALLINGBACKTOBITS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099750));
pub const WU_E_DM_DOWNLOAD_VOLUME_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099749));
pub const WU_E_DM_SANDBOX_HASH_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099748));
pub const WU_E_DM_HARDRESERVEID_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099747));
pub const WU_E_DM_DOSVC_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145099746));
pub const WU_E_DM_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095681));
pub const WU_E_SETUP_INVALID_INFDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071103));
pub const WU_E_SETUP_INVALID_IDENTDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071102));
pub const WU_E_SETUP_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071101));
pub const WU_E_SETUP_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071100));
pub const WU_E_SETUP_SOURCE_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071099));
pub const WU_E_SETUP_TARGET_VERSION_GREATER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071098));
pub const WU_E_SETUP_REGISTRATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071097));
pub const WU_E_SELFUPDATE_SKIP_ON_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071096));
pub const WU_E_SETUP_SKIP_UPDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071095));
pub const WU_E_SETUP_UNSUPPORTED_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071094));
pub const WU_E_SETUP_BLOCKED_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071093));
pub const WU_E_SETUP_REBOOT_TO_FIX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071092));
pub const WU_E_SETUP_ALREADYRUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071091));
pub const WU_E_SETUP_REBOOTREQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071090));
pub const WU_E_SETUP_HANDLER_EXEC_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071089));
pub const WU_E_SETUP_INVALID_REGISTRY_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071088));
pub const WU_E_SELFUPDATE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071087));
pub const WU_E_SELFUPDATE_REQUIRED_ADMIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071086));
pub const WU_E_SETUP_WRONG_SERVER_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071085));
pub const WU_E_SETUP_DEFERRABLE_REBOOT_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071084));
pub const WU_E_SETUP_NON_DEFERRABLE_REBOOT_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071083));
pub const WU_E_SETUP_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145071082));
pub const WU_E_SETUP_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067009));
pub const WU_E_EE_UNKNOWN_EXPRESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067007));
pub const WU_E_EE_INVALID_EXPRESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067006));
pub const WU_E_EE_MISSING_METADATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067005));
pub const WU_E_EE_INVALID_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067004));
pub const WU_E_EE_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067003));
pub const WU_E_EE_INVALID_ATTRIBUTEDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067002));
pub const WU_E_EE_CLUSTER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145067001));
pub const WU_E_EE_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062913));
pub const WU_E_INSTALLATION_RESULTS_UNKNOWN_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145112063));
pub const WU_E_INSTALLATION_RESULTS_INVALID_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145112062));
pub const WU_E_INSTALLATION_RESULTS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145112061));
pub const WU_E_TRAYICON_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145112060));
pub const WU_E_NON_UI_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107971));
pub const WU_E_WUCLTUI_UNSUPPORTED_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107970));
pub const WU_E_AUCLIENT_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145107969));
pub const WU_E_REPORTER_EVENTCACHECORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062911));
pub const WU_E_REPORTER_EVENTNAMESPACEPARSEFAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062910));
pub const WU_E_INVALID_EVENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062909));
pub const WU_E_SERVER_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062908));
pub const WU_E_CALLBACK_COOKIE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145062907));
pub const WU_E_REPORTER_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145058817));
pub const WU_E_OL_INVALID_SCANFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095679));
pub const WU_E_OL_NEWCLIENT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095678));
pub const WU_E_INVALID_EVENT_PAYLOAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095677));
pub const WU_E_INVALID_EVENT_PAYLOADSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095676));
pub const WU_E_SERVICE_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095675));
pub const WU_E_OL_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145091585));
pub const WU_E_METADATA_NOOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095424));
pub const WU_E_METADATA_CONFIG_INVALID_BINARY_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095423));
pub const WU_E_METADATA_FETCH_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095422));
pub const WU_E_METADATA_INVALID_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095420));
pub const WU_E_METADATA_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095419));
pub const WU_E_METADATA_NO_VERIFICATION_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095418));
pub const WU_E_METADATA_BAD_FRAGMENTSIGNING_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095417));
pub const WU_E_METADATA_FAILURE_PROCESSING_FRAGMENTSIGNING_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095416));
pub const WU_E_METADATA_XML_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095392));
pub const WU_E_METADATA_XML_FRAGMENTSIGNING_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095391));
pub const WU_E_METADATA_XML_MODE_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095390));
pub const WU_E_METADATA_XML_MODE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095389));
pub const WU_E_METADATA_XML_VALIDITY_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095388));
pub const WU_E_METADATA_XML_LEAFCERT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095387));
pub const WU_E_METADATA_XML_INTERMEDIATECERT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095386));
pub const WU_E_METADATA_XML_LEAFCERT_ID_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095385));
pub const WU_E_METADATA_XML_BASE64CERDATA_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095384));
pub const WU_E_METADATA_BAD_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095360));
pub const WU_E_METADATA_UNSUPPORTED_HASH_ALG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095359));
pub const WU_E_METADATA_SIGNATURE_VERIFY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095358));
pub const WU_E_METADATATRUST_CERTIFICATECHAIN_VERIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095344));
pub const WU_E_METADATATRUST_UNTRUSTED_CERTIFICATECHAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095343));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095328));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095327));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095326));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_VALIDITY_WINDOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095325));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095324));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_CERTCHAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095323));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_REFRESHONLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095322));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_ALL_BAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095321));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_NODATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095320));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_CACHELOOKUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095319));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_VALIDITYWINDOW_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095298));
pub const WU_E_METADATA_TIMESTAMP_TOKEN_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095297));
pub const WU_E_METADATA_CERT_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095296));
pub const WU_E_METADATA_LEAFCERT_BAD_TRANSPORT_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095295));
pub const WU_E_METADATA_INTCERT_BAD_TRANSPORT_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095294));
pub const WU_E_METADATA_CERT_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145095293));
pub const WU_E_WUTASK_INPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079295));
pub const WU_E_WUTASK_STATUS_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079294));
pub const WU_E_WUTASK_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079293));
pub const WU_E_WUTASK_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079292));
pub const WU_E_WUTASK_CANCELINSTALL_DISALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079291));
pub const WU_E_UNKNOWN_HARDWARECAPABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079039));
pub const WU_E_BAD_XML_HARDWARECAPABILITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079038));
pub const WU_E_WMI_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079037));
pub const WU_E_UPDATE_MERGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079036));
pub const WU_E_SKIPPED_UPDATE_INSTALLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145079035));
pub const WU_E_SLS_INVALID_REVISION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145078783));
pub const WU_E_FILETRUST_DUALSIGNATURE_RSA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145078527));
pub const WU_E_FILETRUST_DUALSIGNATURE_ECC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145078526));
pub const WU_E_TRUST_SUBJECT_NOT_TRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145078525));
pub const WU_E_TRUST_PROVIDER_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2145078524));

//--------------------------------------------------------------------------------
// Section: Types (109)
//--------------------------------------------------------------------------------
const CLSID_StringCollection_Value = Guid.initString("72c97d74-7c3b-40ae-b77d-abdb22eba6fb");
pub const CLSID_StringCollection = &CLSID_StringCollection_Value;

const CLSID_UpdateSearcher_Value = Guid.initString("b699e5e8-67ff-4177-88b0-3684a3388bfb");
pub const CLSID_UpdateSearcher = &CLSID_UpdateSearcher_Value;

const CLSID_WebProxy_Value = Guid.initString("650503cf-9108-4ddc-a2ce-6c2341e1c582");
pub const CLSID_WebProxy = &CLSID_WebProxy_Value;

const CLSID_SystemInformation_Value = Guid.initString("c01b9ba0-bea7-41ba-b604-d0a36f469133");
pub const CLSID_SystemInformation = &CLSID_SystemInformation_Value;

const CLSID_WindowsUpdateAgentInfo_Value = Guid.initString("c2e88c2f-6f5b-4aaa-894b-55c847ad3a2d");
pub const CLSID_WindowsUpdateAgentInfo = &CLSID_WindowsUpdateAgentInfo_Value;

const CLSID_AutomaticUpdates_Value = Guid.initString("bfe18e9c-6d87-4450-b37c-e02f0b373803");
pub const CLSID_AutomaticUpdates = &CLSID_AutomaticUpdates_Value;

const CLSID_UpdateCollection_Value = Guid.initString("13639463-00db-4646-803d-528026140d88");
pub const CLSID_UpdateCollection = &CLSID_UpdateCollection_Value;

const CLSID_UpdateDownloader_Value = Guid.initString("5baf654a-5a07-4264-a255-9ff54c7151e7");
pub const CLSID_UpdateDownloader = &CLSID_UpdateDownloader_Value;

const CLSID_UpdateInstaller_Value = Guid.initString("d2e0fe7f-d23e-48e1-93c0-6fa8cc346474");
pub const CLSID_UpdateInstaller = &CLSID_UpdateInstaller_Value;

const CLSID_UpdateSession_Value = Guid.initString("4cb43d7f-7eee-4906-8698-60da1c38f2fe");
pub const CLSID_UpdateSession = &CLSID_UpdateSession_Value;

const CLSID_UpdateServiceManager_Value = Guid.initString("f8d253d9-89a4-4daa-87b6-1168369f0b21");
pub const CLSID_UpdateServiceManager = &CLSID_UpdateServiceManager_Value;

const CLSID_InstallationAgent_Value = Guid.initString("317e92fc-1679-46fd-a0b5-f08914dd8623");
pub const CLSID_InstallationAgent = &CLSID_InstallationAgent_Value;

pub const AutomaticUpdatesNotificationLevel = enum(i32) {
    NotConfigured = 0,
    Disabled = 1,
    NotifyBeforeDownload = 2,
    NotifyBeforeInstallation = 3,
    ScheduledInstallation = 4,
};
pub const aunlNotConfigured = AutomaticUpdatesNotificationLevel.NotConfigured;
pub const aunlDisabled = AutomaticUpdatesNotificationLevel.Disabled;
pub const aunlNotifyBeforeDownload = AutomaticUpdatesNotificationLevel.NotifyBeforeDownload;
pub const aunlNotifyBeforeInstallation = AutomaticUpdatesNotificationLevel.NotifyBeforeInstallation;
pub const aunlScheduledInstallation = AutomaticUpdatesNotificationLevel.ScheduledInstallation;

pub const AutomaticUpdatesScheduledInstallationDay = enum(i32) {
    Day = 0,
    Sunday = 1,
    Monday = 2,
    Tuesday = 3,
    Wednesday = 4,
    Thursday = 5,
    Friday = 6,
    Saturday = 7,
};
pub const ausidEveryDay = AutomaticUpdatesScheduledInstallationDay.Day;
pub const ausidEverySunday = AutomaticUpdatesScheduledInstallationDay.Sunday;
pub const ausidEveryMonday = AutomaticUpdatesScheduledInstallationDay.Monday;
pub const ausidEveryTuesday = AutomaticUpdatesScheduledInstallationDay.Tuesday;
pub const ausidEveryWednesday = AutomaticUpdatesScheduledInstallationDay.Wednesday;
pub const ausidEveryThursday = AutomaticUpdatesScheduledInstallationDay.Thursday;
pub const ausidEveryFriday = AutomaticUpdatesScheduledInstallationDay.Friday;
pub const ausidEverySaturday = AutomaticUpdatesScheduledInstallationDay.Saturday;

pub const DownloadPhase = enum(i32) {
    Initializing = 1,
    Downloading = 2,
    Verifying = 3,
};
pub const dphInitializing = DownloadPhase.Initializing;
pub const dphDownloading = DownloadPhase.Downloading;
pub const dphVerifying = DownloadPhase.Verifying;

pub const DownloadPriority = enum(i32) {
    Low = 1,
    Normal = 2,
    High = 3,
    ExtraHigh = 4,
};
pub const dpLow = DownloadPriority.Low;
pub const dpNormal = DownloadPriority.Normal;
pub const dpHigh = DownloadPriority.High;
pub const dpExtraHigh = DownloadPriority.ExtraHigh;

pub const AutoSelectionMode = enum(i32) {
    LetWindowsUpdateDecide = 0,
    AutoSelectIfDownloaded = 1,
    NeverAutoSelect = 2,
    AlwaysAutoSelect = 3,
};
pub const asLetWindowsUpdateDecide = AutoSelectionMode.LetWindowsUpdateDecide;
pub const asAutoSelectIfDownloaded = AutoSelectionMode.AutoSelectIfDownloaded;
pub const asNeverAutoSelect = AutoSelectionMode.NeverAutoSelect;
pub const asAlwaysAutoSelect = AutoSelectionMode.AlwaysAutoSelect;

pub const AutoDownloadMode = enum(i32) {
    LetWindowsUpdateDecide = 0,
    NeverAutoDownload = 1,
    AlwaysAutoDownload = 2,
};
pub const adLetWindowsUpdateDecide = AutoDownloadMode.LetWindowsUpdateDecide;
pub const adNeverAutoDownload = AutoDownloadMode.NeverAutoDownload;
pub const adAlwaysAutoDownload = AutoDownloadMode.AlwaysAutoDownload;

pub const InstallationImpact = enum(i32) {
    Normal = 0,
    Minor = 1,
    RequiresExclusiveHandling = 2,
};
pub const iiNormal = InstallationImpact.Normal;
pub const iiMinor = InstallationImpact.Minor;
pub const iiRequiresExclusiveHandling = InstallationImpact.RequiresExclusiveHandling;

pub const InstallationRebootBehavior = enum(i32) {
    NeverReboots = 0,
    AlwaysRequiresReboot = 1,
    CanRequestReboot = 2,
};
pub const irbNeverReboots = InstallationRebootBehavior.NeverReboots;
pub const irbAlwaysRequiresReboot = InstallationRebootBehavior.AlwaysRequiresReboot;
pub const irbCanRequestReboot = InstallationRebootBehavior.CanRequestReboot;

pub const OperationResultCode = enum(i32) {
    NotStarted = 0,
    InProgress = 1,
    Succeeded = 2,
    SucceededWithErrors = 3,
    Failed = 4,
    Aborted = 5,
};
pub const orcNotStarted = OperationResultCode.NotStarted;
pub const orcInProgress = OperationResultCode.InProgress;
pub const orcSucceeded = OperationResultCode.Succeeded;
pub const orcSucceededWithErrors = OperationResultCode.SucceededWithErrors;
pub const orcFailed = OperationResultCode.Failed;
pub const orcAborted = OperationResultCode.Aborted;

pub const ServerSelection = enum(i32) {
    Default = 0,
    ManagedServer = 1,
    WindowsUpdate = 2,
    Others = 3,
};
pub const ssDefault = ServerSelection.Default;
pub const ssManagedServer = ServerSelection.ManagedServer;
pub const ssWindowsUpdate = ServerSelection.WindowsUpdate;
pub const ssOthers = ServerSelection.Others;

pub const UpdateType = enum(i32) {
    Software = 1,
    Driver = 2,
};
pub const utSoftware = UpdateType.Software;
pub const utDriver = UpdateType.Driver;

pub const UpdateOperation = enum(i32) {
    Installation = 1,
    Uninstallation = 2,
};
pub const uoInstallation = UpdateOperation.Installation;
pub const uoUninstallation = UpdateOperation.Uninstallation;

pub const DeploymentAction = enum(i32) {
    None = 0,
    Installation = 1,
    Uninstallation = 2,
    Detection = 3,
    OptionalInstallation = 4,
};
pub const daNone = DeploymentAction.None;
pub const daInstallation = DeploymentAction.Installation;
pub const daUninstallation = DeploymentAction.Uninstallation;
pub const daDetection = DeploymentAction.Detection;
pub const daOptionalInstallation = DeploymentAction.OptionalInstallation;

pub const UpdateExceptionContext = enum(i32) {
    General = 1,
    WindowsDriver = 2,
    WindowsInstaller = 3,
    SearchIncomplete = 4,
};
pub const uecGeneral = UpdateExceptionContext.General;
pub const uecWindowsDriver = UpdateExceptionContext.WindowsDriver;
pub const uecWindowsInstaller = UpdateExceptionContext.WindowsInstaller;
pub const uecSearchIncomplete = UpdateExceptionContext.SearchIncomplete;

pub const AutomaticUpdatesUserType = enum(i32) {
    CurrentUser = 1,
    LocalAdministrator = 2,
};
pub const auutCurrentUser = AutomaticUpdatesUserType.CurrentUser;
pub const auutLocalAdministrator = AutomaticUpdatesUserType.LocalAdministrator;

pub const AutomaticUpdatesPermissionType = enum(i32) {
    SetNotificationLevel = 1,
    DisableAutomaticUpdates = 2,
    SetIncludeRecommendedUpdates = 3,
    SetFeaturedUpdatesEnabled = 4,
    SetNonAdministratorsElevated = 5,
};
pub const auptSetNotificationLevel = AutomaticUpdatesPermissionType.SetNotificationLevel;
pub const auptDisableAutomaticUpdates = AutomaticUpdatesPermissionType.DisableAutomaticUpdates;
pub const auptSetIncludeRecommendedUpdates = AutomaticUpdatesPermissionType.SetIncludeRecommendedUpdates;
pub const auptSetFeaturedUpdatesEnabled = AutomaticUpdatesPermissionType.SetFeaturedUpdatesEnabled;
pub const auptSetNonAdministratorsElevated = AutomaticUpdatesPermissionType.SetNonAdministratorsElevated;

pub const UpdateServiceRegistrationState = enum(i32) {
    NotRegistered = 1,
    RegistrationPending = 2,
    Registered = 3,
};
pub const usrsNotRegistered = UpdateServiceRegistrationState.NotRegistered;
pub const usrsRegistrationPending = UpdateServiceRegistrationState.RegistrationPending;
pub const usrsRegistered = UpdateServiceRegistrationState.Registered;

pub const SearchScope = enum(i32) {
    Default = 0,
    MachineOnly = 1,
    CurrentUserOnly = 2,
    MachineAndCurrentUser = 3,
    MachineAndAllUsers = 4,
    AllUsers = 5,
};
pub const searchScopeDefault = SearchScope.Default;
pub const searchScopeMachineOnly = SearchScope.MachineOnly;
pub const searchScopeCurrentUserOnly = SearchScope.CurrentUserOnly;
pub const searchScopeMachineAndCurrentUser = SearchScope.MachineAndCurrentUser;
pub const searchScopeMachineAndAllUsers = SearchScope.MachineAndAllUsers;
pub const searchScopeAllUsers = SearchScope.AllUsers;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateLockdown_Value = Guid.initString("a976c28d-75a1-42aa-94ae-8af8b872089a");
pub const IID_IUpdateLockdown = &IID_IUpdateLockdown_Value;
pub const IUpdateLockdown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateLockdown,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateLockdown,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateLockdown_LockDown(self: *const T, flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateLockdown.VTable, @ptrCast(self.vtable)).LockDown(@as(*const IUpdateLockdown, @ptrCast(self)), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStringCollection_Value = Guid.initString("eff90582-2ddc-480f-a06d-60f3fbc362c3");
pub const IID_IStringCollection = &IID_IStringCollection_Value;
pub const IStringCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStringCollection,
                index: i32,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStringCollection,
                index: i32,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStringCollection,
                index: i32,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStringCollection,
                index: i32,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStringCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStringCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStringCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStringCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStringCollection,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStringCollection,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringCollection,
                value: ?BSTR,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringCollection,
                value: ?BSTR,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringCollection,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringCollection,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Insert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringCollection,
                index: i32,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringCollection,
                index: i32,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringCollection,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringCollection,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_get_Item(self: *const T, index: i32, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IStringCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_put_Item(self: *const T, index: i32, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IStringCollection, @ptrCast(self)), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IStringCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IStringCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_get_ReadOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).get_ReadOnly(@as(*const IStringCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_Add(self: *const T, value: ?BSTR, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).Add(@as(*const IStringCollection, @ptrCast(self)), value, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).Clear(@as(*const IStringCollection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_Copy(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).Copy(@as(*const IStringCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_Insert(self: *const T, index: i32, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).Insert(@as(*const IStringCollection, @ptrCast(self)), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringCollection_RemoveAt(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @as(*const IStringCollection.VTable, @ptrCast(self.vtable)).RemoveAt(@as(*const IStringCollection, @ptrCast(self)), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebProxy_Value = Guid.initString("174c81fe-aecd-4dae-b8a0-2c6318dd86a8");
pub const IID_IWebProxy = &IID_IWebProxy_Value;
pub const IWebProxy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Address: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BypassList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BypassList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                value: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                value: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BypassProxyOnLocal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BypassProxyOnLocal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebProxy,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptForCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebProxy,
                parentWindow: ?*IUnknown,
                title: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebProxy,
                parentWindow: ?*IUnknown,
                title: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptForCredentialsFromHwnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebProxy,
                parentWindow: ?HWND,
                title: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebProxy,
                parentWindow: ?HWND,
                title: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoDetect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoDetect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWebProxy,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWebProxy,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_Address(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_Address(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_put_Address(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).put_Address(@as(*const IWebProxy, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_BypassList(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_BypassList(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_put_BypassList(self: *const T, value: ?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).put_BypassList(@as(*const IWebProxy, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_BypassProxyOnLocal(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_BypassProxyOnLocal(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_put_BypassProxyOnLocal(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).put_BypassProxyOnLocal(@as(*const IWebProxy, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_ReadOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_ReadOnly(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_UserName(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_UserName(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_put_UserName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).put_UserName(@as(*const IWebProxy, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_SetPassword(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).SetPassword(@as(*const IWebProxy, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_PromptForCredentials(self: *const T, parentWindow: ?*IUnknown, title: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).PromptForCredentials(@as(*const IWebProxy, @ptrCast(self)), parentWindow, title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_PromptForCredentialsFromHwnd(self: *const T, parentWindow: ?HWND, title: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).PromptForCredentialsFromHwnd(@as(*const IWebProxy, @ptrCast(self)), parentWindow, title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_get_AutoDetect(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).get_AutoDetect(@as(*const IWebProxy, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebProxy_put_AutoDetect(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IWebProxy.VTable, @ptrCast(self.vtable)).put_AutoDetect(@as(*const IWebProxy, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISystemInformation_Value = Guid.initString("ade87bf7-7b56-4275-8fab-b9b0e591844b");
pub const IID_ISystemInformation = &IID_ISystemInformation_Value;
pub const ISystemInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OemHardwareSupportLink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISystemInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISystemInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISystemInformation,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISystemInformation,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISystemInformation_get_OemHardwareSupportLink(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISystemInformation.VTable, @ptrCast(self.vtable)).get_OemHardwareSupportLink(@as(*const ISystemInformation, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISystemInformation_get_RebootRequired(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISystemInformation.VTable, @ptrCast(self.vtable)).get_RebootRequired(@as(*const ISystemInformation, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsUpdateAgentInfo_Value = Guid.initString("85713fa1-7796-4fa2-be3b-e2d6124dd373");
pub const IID_IWindowsUpdateAgentInfo = &IID_IWindowsUpdateAgentInfo_Value;
pub const IWindowsUpdateAgentInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowsUpdateAgentInfo,
                varInfoIdentifier: VARIANT,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowsUpdateAgentInfo,
                varInfoIdentifier: VARIANT,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsUpdateAgentInfo_GetInfo(self: *const T, varInfoIdentifier: VARIANT, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IWindowsUpdateAgentInfo.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IWindowsUpdateAgentInfo, @ptrCast(self)), varInfoIdentifier, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdatesResults_Value = Guid.initString("e7a4d634-7942-4dd9-a111-82228ba33901");
pub const IID_IAutomaticUpdatesResults = &IID_IAutomaticUpdatesResults_Value;
pub const IAutomaticUpdatesResults = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastSearchSuccessDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesResults,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesResults,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastInstallationSuccessDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesResults,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesResults,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesResults_get_LastSearchSuccessDate(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesResults.VTable, @ptrCast(self.vtable)).get_LastSearchSuccessDate(@as(*const IAutomaticUpdatesResults, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesResults_get_LastInstallationSuccessDate(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesResults.VTable, @ptrCast(self.vtable)).get_LastInstallationSuccessDate(@as(*const IAutomaticUpdatesResults, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdatesSettings_Value = Guid.initString("2ee48f22-af3c-405f-8970-f71be12ee9a2");
pub const IID_IAutomaticUpdatesSettings = &IID_IAutomaticUpdatesSettings_Value;
pub const IAutomaticUpdatesSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*AutomaticUpdatesNotificationLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*AutomaticUpdatesNotificationLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotificationLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                value: AutomaticUpdatesNotificationLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                value: AutomaticUpdatesNotificationLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Required: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScheduledInstallationDay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*AutomaticUpdatesScheduledInstallationDay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*AutomaticUpdatesScheduledInstallationDay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScheduledInstallationDay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                value: AutomaticUpdatesScheduledInstallationDay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                value: AutomaticUpdatesScheduledInstallationDay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScheduledInstallationTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScheduledInstallationTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_get_NotificationLevel(self: *const T, retval: ?*AutomaticUpdatesNotificationLevel) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).get_NotificationLevel(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_put_NotificationLevel(self: *const T, value: AutomaticUpdatesNotificationLevel) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).put_NotificationLevel(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_get_ReadOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).get_ReadOnly(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_get_Required(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).get_Required(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_get_ScheduledInstallationDay(self: *const T, retval: ?*AutomaticUpdatesScheduledInstallationDay) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).get_ScheduledInstallationDay(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_put_ScheduledInstallationDay(self: *const T, value: AutomaticUpdatesScheduledInstallationDay) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).put_ScheduledInstallationDay(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_get_ScheduledInstallationTime(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).get_ScheduledInstallationTime(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_put_ScheduledInstallationTime(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).put_ScheduledInstallationTime(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings_Save(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings.VTable, @ptrCast(self.vtable)).Save(@as(*const IAutomaticUpdatesSettings, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdatesSettings2_Value = Guid.initString("6abc136a-c3ca-4384-8171-cb2b1e59b8dc");
pub const IID_IAutomaticUpdatesSettings2 = &IID_IAutomaticUpdatesSettings2_Value;
pub const IAutomaticUpdatesSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IAutomaticUpdatesSettings.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludeRecommendedUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludeRecommendedUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckPermission: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings2,
                userType: AutomaticUpdatesUserType,
                permissionType: AutomaticUpdatesPermissionType,
                userHasPermission: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdatesSettings2,
                userType: AutomaticUpdatesUserType,
                permissionType: AutomaticUpdatesPermissionType,
                userHasPermission: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAutomaticUpdatesSettings.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings2_get_IncludeRecommendedUpdates(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings2.VTable, @ptrCast(self.vtable)).get_IncludeRecommendedUpdates(@as(*const IAutomaticUpdatesSettings2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings2_put_IncludeRecommendedUpdates(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings2.VTable, @ptrCast(self.vtable)).put_IncludeRecommendedUpdates(@as(*const IAutomaticUpdatesSettings2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings2_CheckPermission(self: *const T, userType: AutomaticUpdatesUserType, permissionType: AutomaticUpdatesPermissionType, userHasPermission: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings2.VTable, @ptrCast(self.vtable)).CheckPermission(@as(*const IAutomaticUpdatesSettings2, @ptrCast(self)), userType, permissionType, userHasPermission);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdatesSettings3_Value = Guid.initString("b587f5c3-f57e-485f-bbf5-0d181c5cd0dc");
pub const IID_IAutomaticUpdatesSettings3 = &IID_IAutomaticUpdatesSettings3_Value;
pub const IAutomaticUpdatesSettings3 = extern struct {
    pub const VTable = extern struct {
        base: IAutomaticUpdatesSettings2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonAdministratorsElevated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NonAdministratorsElevated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturedUpdatesEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FeaturedUpdatesEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdatesSettings3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdatesSettings3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAutomaticUpdatesSettings2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings3_get_NonAdministratorsElevated(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings3.VTable, @ptrCast(self.vtable)).get_NonAdministratorsElevated(@as(*const IAutomaticUpdatesSettings3, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings3_put_NonAdministratorsElevated(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings3.VTable, @ptrCast(self.vtable)).put_NonAdministratorsElevated(@as(*const IAutomaticUpdatesSettings3, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings3_get_FeaturedUpdatesEnabled(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings3.VTable, @ptrCast(self.vtable)).get_FeaturedUpdatesEnabled(@as(*const IAutomaticUpdatesSettings3, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdatesSettings3_put_FeaturedUpdatesEnabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdatesSettings3.VTable, @ptrCast(self.vtable)).put_FeaturedUpdatesEnabled(@as(*const IAutomaticUpdatesSettings3, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdates_Value = Guid.initString("673425bf-c082-4c7c-bdfd-569464b8e0ce");
pub const IID_IAutomaticUpdates = &IID_IAutomaticUpdates_Value;
pub const IAutomaticUpdates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        DetectNow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowSettingsDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Settings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdates,
                retval: ?*?*IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdates,
                retval: ?*?*IAutomaticUpdatesSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdates,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdates,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAutomaticUpdates,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_DetectNow(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).DetectNow(@as(*const IAutomaticUpdates, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).Pause(@as(*const IAutomaticUpdates, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).Resume(@as(*const IAutomaticUpdates, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_ShowSettingsDialog(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).ShowSettingsDialog(@as(*const IAutomaticUpdates, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_get_Settings(self: *const T, retval: ?*?*IAutomaticUpdatesSettings) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).get_Settings(@as(*const IAutomaticUpdates, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_get_ServiceEnabled(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).get_ServiceEnabled(@as(*const IAutomaticUpdates, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates_EnableService(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates.VTable, @ptrCast(self.vtable)).EnableService(@as(*const IAutomaticUpdates, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutomaticUpdates2_Value = Guid.initString("4a2f5c31-cfd9-410e-b7fb-29a653973a0f");
pub const IID_IAutomaticUpdates2 = &IID_IAutomaticUpdates2_Value;
pub const IAutomaticUpdates2 = extern struct {
    pub const VTable = extern struct {
        base: IAutomaticUpdates.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Results: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAutomaticUpdates2,
                retval: ?*?*IAutomaticUpdatesResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAutomaticUpdates2,
                retval: ?*?*IAutomaticUpdatesResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAutomaticUpdates.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutomaticUpdates2_get_Results(self: *const T, retval: ?*?*IAutomaticUpdatesResults) callconv(.Inline) HRESULT {
            return @as(*const IAutomaticUpdates2.VTable, @ptrCast(self.vtable)).get_Results(@as(*const IAutomaticUpdates2, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateIdentity_Value = Guid.initString("46297823-9940-4c09-aed9-cd3ea6d05968");
pub const IID_IUpdateIdentity = &IID_IUpdateIdentity_Value;
pub const IUpdateIdentity = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RevisionNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateIdentity,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateIdentity,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdateID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateIdentity,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateIdentity,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateIdentity_get_RevisionNumber(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateIdentity.VTable, @ptrCast(self.vtable)).get_RevisionNumber(@as(*const IUpdateIdentity, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateIdentity_get_UpdateID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateIdentity.VTable, @ptrCast(self.vtable)).get_UpdateID(@as(*const IUpdateIdentity, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IImageInformation_Value = Guid.initString("7c907864-346c-4aeb-8f3f-57da289f969f");
pub const IID_IImageInformation = &IID_IImageInformation_Value;
pub const IImageInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AltText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IImageInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IImageInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IImageInformation,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IImageInformation,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Source: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IImageInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IImageInformation,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IImageInformation,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IImageInformation,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageInformation_get_AltText(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IImageInformation.VTable, @ptrCast(self.vtable)).get_AltText(@as(*const IImageInformation, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageInformation_get_Height(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IImageInformation.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IImageInformation, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageInformation_get_Source(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IImageInformation.VTable, @ptrCast(self.vtable)).get_Source(@as(*const IImageInformation, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageInformation_get_Width(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IImageInformation.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IImageInformation, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategory_Value = Guid.initString("81ddc1b8-9d35-47a6-b471-5b80f519223b");
pub const IID_ICategory = &IID_ICategory_Value;
pub const ICategory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CategoryID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Image: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?*IImageInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?*IImageInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Order: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?*ICategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?*ICategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategory,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategory,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Name(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_CategoryID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_CategoryID(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Children(self: *const T, retval: ?*?*ICategoryCollection) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Children(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Description(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Description(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Image(self: *const T, retval: ?*?*IImageInformation) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Image(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Order(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Order(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Parent(self: *const T, retval: ?*?*ICategory) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Type(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Type(@as(*const ICategory, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategory_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const ICategory.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const ICategory, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategoryCollection_Value = Guid.initString("3a56bfb8-576c-43f7-9335-fe4838fd7e37");
pub const IID_ICategoryCollection = &IID_ICategoryCollection_Value;
pub const ICategoryCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategoryCollection,
                index: i32,
                retval: ?*?*ICategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategoryCollection,
                index: i32,
                retval: ?*?*ICategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategoryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategoryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICategoryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICategoryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryCollection_get_Item(self: *const T, index: i32, retval: ?*?*ICategory) callconv(.Inline) HRESULT {
            return @as(*const ICategoryCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ICategoryCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICategoryCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ICategoryCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICategoryCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ICategoryCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationBehavior_Value = Guid.initString("d9a59339-e245-4dbd-9686-4d5763e39624");
pub const IID_IInstallationBehavior = &IID_IInstallationBehavior_Value;
pub const IInstallationBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanRequestUserInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationBehavior,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationBehavior,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Impact: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationBehavior,
                retval: ?*InstallationImpact,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationBehavior,
                retval: ?*InstallationImpact,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootBehavior: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationBehavior,
                retval: ?*InstallationRebootBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationBehavior,
                retval: ?*InstallationRebootBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequiresNetworkConnectivity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationBehavior,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationBehavior,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationBehavior_get_CanRequestUserInput(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IInstallationBehavior.VTable, @ptrCast(self.vtable)).get_CanRequestUserInput(@as(*const IInstallationBehavior, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationBehavior_get_Impact(self: *const T, retval: ?*InstallationImpact) callconv(.Inline) HRESULT {
            return @as(*const IInstallationBehavior.VTable, @ptrCast(self.vtable)).get_Impact(@as(*const IInstallationBehavior, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationBehavior_get_RebootBehavior(self: *const T, retval: ?*InstallationRebootBehavior) callconv(.Inline) HRESULT {
            return @as(*const IInstallationBehavior.VTable, @ptrCast(self.vtable)).get_RebootBehavior(@as(*const IInstallationBehavior, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationBehavior_get_RequiresNetworkConnectivity(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IInstallationBehavior.VTable, @ptrCast(self.vtable)).get_RequiresNetworkConnectivity(@as(*const IInstallationBehavior, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateDownloadContent_Value = Guid.initString("54a2cb2d-9a0c-48b6-8a50-9abb69ee2d02");
pub const IID_IUpdateDownloadContent = &IID_IUpdateDownloadContent_Value;
pub const IUpdateDownloadContent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadContent,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadContent,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadContent_get_DownloadUrl(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadContent.VTable, @ptrCast(self.vtable)).get_DownloadUrl(@as(*const IUpdateDownloadContent, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateDownloadContent2_Value = Guid.initString("c97ad11b-f257-420b-9d9f-377f733f6f68");
pub const IID_IUpdateDownloadContent2 = &IID_IUpdateDownloadContent2_Value;
pub const IUpdateDownloadContent2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateDownloadContent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDeltaCompressedContent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadContent2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadContent2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateDownloadContent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadContent2_get_IsDeltaCompressedContent(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadContent2.VTable, @ptrCast(self.vtable)).get_IsDeltaCompressedContent(@as(*const IUpdateDownloadContent2, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateDownloadContentCollection_Value = Guid.initString("bc5513c8-b3b8-4bf7-a4d4-361c0d8c88ba");
pub const IID_IUpdateDownloadContentCollection = &IID_IUpdateDownloadContentCollection_Value;
pub const IUpdateDownloadContentCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadContentCollection,
                index: i32,
                retval: ?*?*IUpdateDownloadContent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadContentCollection,
                index: i32,
                retval: ?*?*IUpdateDownloadContent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadContentCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadContentCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadContentCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadContentCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadContentCollection_get_Item(self: *const T, index: i32, retval: ?*?*IUpdateDownloadContent) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadContentCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUpdateDownloadContentCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadContentCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadContentCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUpdateDownloadContentCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadContentCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadContentCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUpdateDownloadContentCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdate_Value = Guid.initString("6a92b07a-d821-4682-b423-5c805022cc4d");
pub const IID_IUpdate = &IID_IUpdate_Value;
pub const IUpdate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSelectOnWebSites: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BundledUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanRequireSource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Categories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Deadline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeltaCompressedContentAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeltaCompressedContentPreferred: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EulaAccepted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EulaText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HandlerID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Identity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateIdentity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateIdentity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Image: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IImageInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IImageInformation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallationBehavior: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IInstallationBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IInstallationBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBeta: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDownloaded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInstalled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMandatory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsUninstallable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Languages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastDeploymentChangeTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxDownloadSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinDownloadSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoUrls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MsrcSeverity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecommendedCpuSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecommendedHardDiskSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecommendedMemory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReleaseNotes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecurityBulletinIDs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupersededUpdateIDs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*UpdateType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*UpdateType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UninstallationNotes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UninstallationBehavior: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IInstallationBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IInstallationBehavior,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UninstallationSteps: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KBArticleIDs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcceptEula: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeploymentAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*DeploymentAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*DeploymentAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyFromCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdate,
                path: ?BSTR,
                toExtractCabFiles: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdate,
                path: ?BSTR,
                toExtractCabFiles: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadPriority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadContents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateDownloadContentCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate,
                retval: ?*?*IUpdateDownloadContentCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Title(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_AutoSelectOnWebSites(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_AutoSelectOnWebSites(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_BundledUpdates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_BundledUpdates(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_CanRequireSource(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_CanRequireSource(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Categories(self: *const T, retval: ?*?*ICategoryCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Categories(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Deadline(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Deadline(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_DeltaCompressedContentAvailable(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_DeltaCompressedContentAvailable(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_DeltaCompressedContentPreferred(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_DeltaCompressedContentPreferred(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Description(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_EulaAccepted(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_EulaAccepted(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_EulaText(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_EulaText(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_HandlerID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_HandlerID(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Identity(self: *const T, retval: ?*?*IUpdateIdentity) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Identity(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Image(self: *const T, retval: ?*?*IImageInformation) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Image(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_InstallationBehavior(self: *const T, retval: ?*?*IInstallationBehavior) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_InstallationBehavior(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsBeta(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsBeta(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsDownloaded(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsDownloaded(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsHidden(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsHidden(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_put_IsHidden(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).put_IsHidden(@as(*const IUpdate, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsInstalled(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsInstalled(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsMandatory(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsMandatory(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_IsUninstallable(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_IsUninstallable(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Languages(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Languages(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_LastDeploymentChangeTime(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_LastDeploymentChangeTime(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_MaxDownloadSize(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_MaxDownloadSize(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_MinDownloadSize(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_MinDownloadSize(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_MoreInfoUrls(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_MoreInfoUrls(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_MsrcSeverity(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_MsrcSeverity(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_RecommendedCpuSpeed(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_RecommendedCpuSpeed(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_RecommendedHardDiskSpace(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_RecommendedHardDiskSpace(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_RecommendedMemory(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_RecommendedMemory(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_ReleaseNotes(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_ReleaseNotes(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_SecurityBulletinIDs(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_SecurityBulletinIDs(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_SupersededUpdateIDs(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_SupersededUpdateIDs(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_SupportUrl(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_SupportUrl(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_Type(self: *const T, retval: ?*UpdateType) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_UninstallationNotes(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_UninstallationNotes(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_UninstallationBehavior(self: *const T, retval: ?*?*IInstallationBehavior) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_UninstallationBehavior(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_UninstallationSteps(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_UninstallationSteps(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_KBArticleIDs(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_KBArticleIDs(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_AcceptEula(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).AcceptEula(@as(*const IUpdate, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_DeploymentAction(self: *const T, retval: ?*DeploymentAction) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_DeploymentAction(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_CopyFromCache(self: *const T, path: ?BSTR, toExtractCabFiles: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).CopyFromCache(@as(*const IUpdate, @ptrCast(self)), path, toExtractCabFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_DownloadPriority(self: *const T, retval: ?*DownloadPriority) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_DownloadPriority(@as(*const IUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate_get_DownloadContents(self: *const T, retval: ?*?*IUpdateDownloadContentCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate.VTable, @ptrCast(self.vtable)).get_DownloadContents(@as(*const IUpdate, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdate_Value = Guid.initString("b383cd1a-5ce9-4504-9f63-764b1236f191");
pub const IID_IWindowsDriverUpdate = &IID_IWindowsDriverUpdate_Value;
pub const IWindowsDriverUpdate = extern struct {
    pub const VTable = extern struct {
        base: IUpdate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverHardwareID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverManufacturer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverModel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverProvider: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverVerDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceProblemNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverClass(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverClass(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverHardwareID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverHardwareID(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverManufacturer(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverManufacturer(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverModel(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverModel(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverProvider(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverProvider(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DriverVerDate(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DriverVerDate(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DeviceProblemNumber(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DeviceProblemNumber(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate_get_DeviceStatus(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate.VTable, @ptrCast(self.vtable)).get_DeviceStatus(@as(*const IWindowsDriverUpdate, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdate2_Value = Guid.initString("144fe9b0-d23d-4a8b-8634-fb4457533b7a");
pub const IID_IUpdate2 = &IID_IUpdate2_Value;
pub const IUpdate2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPresent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CveIDs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate2,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate2,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdate2,
                pFiles: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdate2,
                pFiles: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate2_get_RebootRequired(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate2.VTable, @ptrCast(self.vtable)).get_RebootRequired(@as(*const IUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate2_get_IsPresent(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate2.VTable, @ptrCast(self.vtable)).get_IsPresent(@as(*const IUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate2_get_CveIDs(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate2.VTable, @ptrCast(self.vtable)).get_CveIDs(@as(*const IUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate2_CopyToCache(self: *const T, pFiles: ?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdate2.VTable, @ptrCast(self.vtable)).CopyToCache(@as(*const IUpdate2, @ptrCast(self)), pFiles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdate3_Value = Guid.initString("112eda6b-95b3-476f-9d90-aee82c6b8181");
pub const IID_IUpdate3 = &IID_IUpdate3_Value;
pub const IUpdate3 = extern struct {
    pub const VTable = extern struct {
        base: IUpdate2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BrowseOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdate2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate3_get_BrowseOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate3.VTable, @ptrCast(self.vtable)).get_BrowseOnly(@as(*const IUpdate3, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdate4_Value = Guid.initString("27e94b0d-5139-49a2-9a61-93522dc54652");
pub const IID_IUpdate4 = &IID_IUpdate4_Value;
pub const IUpdate4 = extern struct {
    pub const VTable = extern struct {
        base: IUpdate3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PerUser: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate4,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate4,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdate3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate4_get_PerUser(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdate4.VTable, @ptrCast(self.vtable)).get_PerUser(@as(*const IUpdate4, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdate5_Value = Guid.initString("c1c2f21a-d2f4-4902-b5c6-8a081c19a890");
pub const IID_IUpdate5 = &IID_IUpdate5_Value;
pub const IUpdate5 = extern struct {
    pub const VTable = extern struct {
        base: IUpdate4.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate5,
                retval: ?*AutoSelectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate5,
                retval: ?*AutoSelectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoDownload: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdate5,
                retval: ?*AutoDownloadMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdate5,
                retval: ?*AutoDownloadMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdate4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate5_get_AutoSelection(self: *const T, retval: ?*AutoSelectionMode) callconv(.Inline) HRESULT {
            return @as(*const IUpdate5.VTable, @ptrCast(self.vtable)).get_AutoSelection(@as(*const IUpdate5, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdate5_get_AutoDownload(self: *const T, retval: ?*AutoDownloadMode) callconv(.Inline) HRESULT {
            return @as(*const IUpdate5.VTable, @ptrCast(self.vtable)).get_AutoDownload(@as(*const IUpdate5, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdate2_Value = Guid.initString("615c4269-7a48-43bd-96b7-bf6ca27d6c3e");
pub const IID_IWindowsDriverUpdate2 = &IID_IWindowsDriverUpdate2_Value;
pub const IWindowsDriverUpdate2 = extern struct {
    pub const VTable = extern struct {
        base: IWindowsDriverUpdate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPresent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CveIDs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate2,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowsDriverUpdate2,
                pFiles: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowsDriverUpdate2,
                pFiles: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowsDriverUpdate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate2_get_RebootRequired(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate2.VTable, @ptrCast(self.vtable)).get_RebootRequired(@as(*const IWindowsDriverUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate2_get_IsPresent(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate2.VTable, @ptrCast(self.vtable)).get_IsPresent(@as(*const IWindowsDriverUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate2_get_CveIDs(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate2.VTable, @ptrCast(self.vtable)).get_CveIDs(@as(*const IWindowsDriverUpdate2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate2_CopyToCache(self: *const T, pFiles: ?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate2.VTable, @ptrCast(self.vtable)).CopyToCache(@as(*const IWindowsDriverUpdate2, @ptrCast(self)), pFiles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdate3_Value = Guid.initString("49ebd502-4a96-41bd-9e3e-4c5057f4250c");
pub const IID_IWindowsDriverUpdate3 = &IID_IWindowsDriverUpdate3_Value;
pub const IWindowsDriverUpdate3 = extern struct {
    pub const VTable = extern struct {
        base: IWindowsDriverUpdate2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BrowseOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowsDriverUpdate2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate3_get_BrowseOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate3.VTable, @ptrCast(self.vtable)).get_BrowseOnly(@as(*const IWindowsDriverUpdate3, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdateEntry_Value = Guid.initString("ed8bfe40-a60b-42ea-9652-817dfcfa23ec");
pub const IID_IWindowsDriverUpdateEntry = &IID_IWindowsDriverUpdateEntry_Value;
pub const IWindowsDriverUpdateEntry = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverHardwareID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverManufacturer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverModel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverProvider: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DriverVerDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceProblemNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverClass(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverClass(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverHardwareID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverHardwareID(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverManufacturer(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverManufacturer(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverModel(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverModel(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverProvider(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverProvider(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DriverVerDate(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DriverVerDate(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DeviceProblemNumber(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DeviceProblemNumber(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntry_get_DeviceStatus(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntry.VTable, @ptrCast(self.vtable)).get_DeviceStatus(@as(*const IWindowsDriverUpdateEntry, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdateEntryCollection_Value = Guid.initString("0d521700-a372-4bef-828b-3d00c10adebd");
pub const IID_IWindowsDriverUpdateEntryCollection = &IID_IWindowsDriverUpdateEntryCollection_Value;
pub const IWindowsDriverUpdateEntryCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                index: i32,
                retval: ?*?*IWindowsDriverUpdateEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                index: i32,
                retval: ?*?*IWindowsDriverUpdateEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdateEntryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntryCollection_get_Item(self: *const T, index: i32, retval: ?*?*IWindowsDriverUpdateEntry) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntryCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IWindowsDriverUpdateEntryCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntryCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntryCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IWindowsDriverUpdateEntryCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdateEntryCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdateEntryCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IWindowsDriverUpdateEntryCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdate4_Value = Guid.initString("004c6a2b-0c19-4c69-9f5c-a269b2560db9");
pub const IID_IWindowsDriverUpdate4 = &IID_IWindowsDriverUpdate4_Value;
pub const IWindowsDriverUpdate4 = extern struct {
    pub const VTable = extern struct {
        base: IWindowsDriverUpdate3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowsDriverUpdateEntries: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate4,
                retval: ?*?*IWindowsDriverUpdateEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate4,
                retval: ?*?*IWindowsDriverUpdateEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PerUser: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate4,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate4,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowsDriverUpdate3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate4_get_WindowsDriverUpdateEntries(self: *const T, retval: ?*?*IWindowsDriverUpdateEntryCollection) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate4.VTable, @ptrCast(self.vtable)).get_WindowsDriverUpdateEntries(@as(*const IWindowsDriverUpdate4, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate4_get_PerUser(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate4.VTable, @ptrCast(self.vtable)).get_PerUser(@as(*const IWindowsDriverUpdate4, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWindowsDriverUpdate5_Value = Guid.initString("70cf5c82-8642-42bb-9dbc-0cfd263c6c4f");
pub const IID_IWindowsDriverUpdate5 = &IID_IWindowsDriverUpdate5_Value;
pub const IWindowsDriverUpdate5 = extern struct {
    pub const VTable = extern struct {
        base: IWindowsDriverUpdate4.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate5,
                retval: ?*AutoSelectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate5,
                retval: ?*AutoSelectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoDownload: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWindowsDriverUpdate5,
                retval: ?*AutoDownloadMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWindowsDriverUpdate5,
                retval: ?*AutoDownloadMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowsDriverUpdate4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate5_get_AutoSelection(self: *const T, retval: ?*AutoSelectionMode) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate5.VTable, @ptrCast(self.vtable)).get_AutoSelection(@as(*const IWindowsDriverUpdate5, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsDriverUpdate5_get_AutoDownload(self: *const T, retval: ?*AutoDownloadMode) callconv(.Inline) HRESULT {
            return @as(*const IWindowsDriverUpdate5.VTable, @ptrCast(self.vtable)).get_AutoDownload(@as(*const IWindowsDriverUpdate5, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateCollection_Value = Guid.initString("07f7438c-7709-4ca5-b518-91279288134e");
pub const IID_IUpdateCollection = &IID_IUpdateCollection_Value;
pub const IUpdateCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateCollection,
                index: i32,
                retval: ?*?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateCollection,
                index: i32,
                retval: ?*?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateCollection,
                index: i32,
                value: ?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateCollection,
                index: i32,
                value: ?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateCollection,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateCollection,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateCollection,
                value: ?*IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateCollection,
                value: ?*IUpdate,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateCollection,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateCollection,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Insert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateCollection,
                index: i32,
                value: ?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateCollection,
                index: i32,
                value: ?*IUpdate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateCollection,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateCollection,
                index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_get_Item(self: *const T, index: i32, retval: ?*?*IUpdate) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUpdateCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_put_Item(self: *const T, index: i32, value: ?*IUpdate) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IUpdateCollection, @ptrCast(self)), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUpdateCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUpdateCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_get_ReadOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).get_ReadOnly(@as(*const IUpdateCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_Add(self: *const T, value: ?*IUpdate, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).Add(@as(*const IUpdateCollection, @ptrCast(self)), value, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).Clear(@as(*const IUpdateCollection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_Copy(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).Copy(@as(*const IUpdateCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_Insert(self: *const T, index: i32, value: ?*IUpdate) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).Insert(@as(*const IUpdateCollection, @ptrCast(self)), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateCollection_RemoveAt(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateCollection.VTable, @ptrCast(self.vtable)).RemoveAt(@as(*const IUpdateCollection, @ptrCast(self)), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateException_Value = Guid.initString("a376dd5e-09d4-427f-af7c-fed5b6e1c1d6");
pub const IID_IUpdateException = &IID_IUpdateException_Value;
pub const IUpdateException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Message: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateException,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateException,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateException,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateException,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Context: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateException,
                retval: ?*UpdateExceptionContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateException,
                retval: ?*UpdateExceptionContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateException_get_Message(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateException.VTable, @ptrCast(self.vtable)).get_Message(@as(*const IUpdateException, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateException_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateException.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IUpdateException, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateException_get_Context(self: *const T, retval: ?*UpdateExceptionContext) callconv(.Inline) HRESULT {
            return @as(*const IUpdateException.VTable, @ptrCast(self.vtable)).get_Context(@as(*const IUpdateException, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInvalidProductLicenseException_Value = Guid.initString("a37d00f5-7bb0-4953-b414-f9e98326f2e8");
pub const IID_IInvalidProductLicenseException = &IID_IInvalidProductLicenseException_Value;
pub const IInvalidProductLicenseException = extern struct {
    pub const VTable = extern struct {
        base: IUpdateException.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Product: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInvalidProductLicenseException,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInvalidProductLicenseException,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateException.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInvalidProductLicenseException_get_Product(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IInvalidProductLicenseException.VTable, @ptrCast(self.vtable)).get_Product(@as(*const IInvalidProductLicenseException, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateExceptionCollection_Value = Guid.initString("503626a3-8e14-4729-9355-0fe664bd2321");
pub const IID_IUpdateExceptionCollection = &IID_IUpdateExceptionCollection_Value;
pub const IUpdateExceptionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateExceptionCollection,
                index: i32,
                retval: ?*?*IUpdateException,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateExceptionCollection,
                index: i32,
                retval: ?*?*IUpdateException,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateExceptionCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateExceptionCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateExceptionCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateExceptionCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateExceptionCollection_get_Item(self: *const T, index: i32, retval: ?*?*IUpdateException) callconv(.Inline) HRESULT {
            return @as(*const IUpdateExceptionCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUpdateExceptionCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateExceptionCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateExceptionCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUpdateExceptionCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateExceptionCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateExceptionCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUpdateExceptionCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchResult_Value = Guid.initString("d40cff62-e08c-4498-941a-01e25f0fd33c");
pub const IID_ISearchResult = &IID_ISearchResult_Value;
pub const ISearchResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootCategories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchResult,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchResult,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchResult,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchResult,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Warnings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchResult,
                retval: ?*?*IUpdateExceptionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchResult,
                retval: ?*?*IUpdateExceptionCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchResult_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const ISearchResult.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const ISearchResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchResult_get_RootCategories(self: *const T, retval: ?*?*ICategoryCollection) callconv(.Inline) HRESULT {
            return @as(*const ISearchResult.VTable, @ptrCast(self.vtable)).get_RootCategories(@as(*const ISearchResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchResult_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const ISearchResult.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const ISearchResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchResult_get_Warnings(self: *const T, retval: ?*?*IUpdateExceptionCollection) callconv(.Inline) HRESULT {
            return @as(*const ISearchResult.VTable, @ptrCast(self.vtable)).get_Warnings(@as(*const ISearchResult, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchJob_Value = Guid.initString("7366ea16-7a1a-4ea2-b042-973d3e9cd99b");
pub const IID_ISearchJob = &IID_ISearchJob_Value;
pub const ISearchJob = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AsyncState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsCompleted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISearchJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISearchJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CleanUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchJob_get_AsyncState(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISearchJob.VTable, @ptrCast(self.vtable)).get_AsyncState(@as(*const ISearchJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchJob_get_IsCompleted(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISearchJob.VTable, @ptrCast(self.vtable)).get_IsCompleted(@as(*const ISearchJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchJob_CleanUp(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISearchJob.VTable, @ptrCast(self.vtable)).CleanUp(@as(*const ISearchJob, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchJob_RequestAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISearchJob.VTable, @ptrCast(self.vtable)).RequestAbort(@as(*const ISearchJob, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCompletedCallbackArgs_Value = Guid.initString("a700a634-2850-4c47-938a-9e4b6e5af9a6");
pub const IID_ISearchCompletedCallbackArgs = &IID_ISearchCompletedCallbackArgs_Value;
pub const ISearchCompletedCallbackArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchCompletedCallback_Value = Guid.initString("88aee058-d4b0-4725-a2f1-814a67ae964c");
pub const IID_ISearchCompletedCallback = &IID_ISearchCompletedCallback_Value;
pub const ISearchCompletedCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISearchCompletedCallback,
                searchJob: ?*ISearchJob,
                callbackArgs: ?*ISearchCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISearchCompletedCallback,
                searchJob: ?*ISearchJob,
                callbackArgs: ?*ISearchCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCompletedCallback_Invoke(self: *const T, searchJob: ?*ISearchJob, callbackArgs: ?*ISearchCompletedCallbackArgs) callconv(.Inline) HRESULT {
            return @as(*const ISearchCompletedCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ISearchCompletedCallback, @ptrCast(self)), searchJob, callbackArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateHistoryEntry_Value = Guid.initString("be56a644-af0e-4e0e-a311-c1d8e695cbff");
pub const IID_IUpdateHistoryEntry = &IID_IUpdateHistoryEntry_Value;
pub const IUpdateHistoryEntry = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*UpdateOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*UpdateOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Date: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdateIdentity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?*IUpdateIdentity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?*IUpdateIdentity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnmappedResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServerSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UninstallationSteps: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UninstallationNotes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_Operation(self: *const T, retval: ?*UpdateOperation) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_Operation(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_Date(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_Date(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_UpdateIdentity(self: *const T, retval: ?*?*IUpdateIdentity) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_UpdateIdentity(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_Title(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_Description(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_UnmappedResultCode(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_UnmappedResultCode(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_ServerSelection(self: *const T, retval: ?*ServerSelection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_ServerSelection(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_ServiceID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_ServiceID(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_UninstallationSteps(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_UninstallationSteps(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_UninstallationNotes(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_UninstallationNotes(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry_get_SupportUrl(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry.VTable, @ptrCast(self.vtable)).get_SupportUrl(@as(*const IUpdateHistoryEntry, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateHistoryEntry2_Value = Guid.initString("c2bfb780-4539-4132-ab8c-0a8772013ab6");
pub const IID_IUpdateHistoryEntry2 = &IID_IUpdateHistoryEntry2_Value;
pub const IUpdateHistoryEntry2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateHistoryEntry.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Categories: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntry2,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntry2,
                retval: ?*?*ICategoryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateHistoryEntry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntry2_get_Categories(self: *const T, retval: ?*?*ICategoryCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntry2.VTable, @ptrCast(self.vtable)).get_Categories(@as(*const IUpdateHistoryEntry2, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateHistoryEntryCollection_Value = Guid.initString("a7f04f3c-a290-435b-aadf-a116c3357a5c");
pub const IID_IUpdateHistoryEntryCollection = &IID_IUpdateHistoryEntryCollection_Value;
pub const IUpdateHistoryEntryCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntryCollection,
                index: i32,
                retval: ?*?*IUpdateHistoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntryCollection,
                index: i32,
                retval: ?*?*IUpdateHistoryEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntryCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateHistoryEntryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateHistoryEntryCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntryCollection_get_Item(self: *const T, index: i32, retval: ?*?*IUpdateHistoryEntry) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntryCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUpdateHistoryEntryCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntryCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntryCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUpdateHistoryEntryCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateHistoryEntryCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateHistoryEntryCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUpdateHistoryEntryCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSearcher_Value = Guid.initString("8f45abf1-f9ae-4b95-a933-f0f66e5056ea");
pub const IID_IUpdateSearcher = &IID_IUpdateSearcher_Value;
pub const IUpdateSearcher = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanAutomaticallyUpgradeService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CanAutomaticallyUpgradeService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IncludePotentiallySupersededUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IncludePotentiallySupersededUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServerSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ServerSelection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: ServerSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                criteria: ?BSTR,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                criteria: ?BSTR,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*ISearchJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                searchJob: ?*ISearchJob,
                retval: ?*?*ISearchResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                searchJob: ?*ISearchJob,
                retval: ?*?*ISearchResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EscapeString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                unescaped: ?BSTR,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                unescaped: ?BSTR,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                startIndex: i32,
                count: i32,
                retval: ?*?*IUpdateHistoryEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                startIndex: i32,
                count: i32,
                retval: ?*?*IUpdateHistoryEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Search: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                criteria: ?BSTR,
                retval: ?*?*ISearchResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                criteria: ?BSTR,
                retval: ?*?*ISearchResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Online: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Online: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalHistoryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ServiceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_CanAutomaticallyUpgradeService(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_CanAutomaticallyUpgradeService(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_CanAutomaticallyUpgradeService(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_CanAutomaticallyUpgradeService(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_ClientApplicationID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_ClientApplicationID(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_IncludePotentiallySupersededUpdates(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_IncludePotentiallySupersededUpdates(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_IncludePotentiallySupersededUpdates(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_IncludePotentiallySupersededUpdates(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_ServerSelection(self: *const T, retval: ?*ServerSelection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_ServerSelection(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_ServerSelection(self: *const T, value: ServerSelection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_ServerSelection(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_BeginSearch(self: *const T, criteria: ?BSTR, onCompleted: ?*IUnknown, state: VARIANT, retval: ?*?*ISearchJob) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).BeginSearch(@as(*const IUpdateSearcher, @ptrCast(self)), criteria, onCompleted, state, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_EndSearch(self: *const T, searchJob: ?*ISearchJob, retval: ?*?*ISearchResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).EndSearch(@as(*const IUpdateSearcher, @ptrCast(self)), searchJob, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_EscapeString(self: *const T, unescaped: ?BSTR, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).EscapeString(@as(*const IUpdateSearcher, @ptrCast(self)), unescaped, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_QueryHistory(self: *const T, startIndex: i32, count: i32, retval: ?*?*IUpdateHistoryEntryCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).QueryHistory(@as(*const IUpdateSearcher, @ptrCast(self)), startIndex, count, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_Search(self: *const T, criteria: ?BSTR, retval: ?*?*ISearchResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).Search(@as(*const IUpdateSearcher, @ptrCast(self)), criteria, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_Online(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_Online(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_Online(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_Online(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_GetTotalHistoryCount(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).GetTotalHistoryCount(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_get_ServiceID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).get_ServiceID(@as(*const IUpdateSearcher, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher_put_ServiceID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher.VTable, @ptrCast(self.vtable)).put_ServiceID(@as(*const IUpdateSearcher, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSearcher2_Value = Guid.initString("4cbdcb2d-1589-4beb-bd1c-3e582ff0add0");
pub const IID_IUpdateSearcher2 = &IID_IUpdateSearcher2_Value;
pub const IUpdateSearcher2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateSearcher.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IgnoreDownloadPriority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IgnoreDownloadPriority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateSearcher.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher2_get_IgnoreDownloadPriority(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher2.VTable, @ptrCast(self.vtable)).get_IgnoreDownloadPriority(@as(*const IUpdateSearcher2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher2_put_IgnoreDownloadPriority(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher2.VTable, @ptrCast(self.vtable)).put_IgnoreDownloadPriority(@as(*const IUpdateSearcher2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSearcher3_Value = Guid.initString("04c6895d-eaf2-4034-97f3-311de9be413a");
pub const IID_IUpdateSearcher3 = &IID_IUpdateSearcher3_Value;
pub const IUpdateSearcher3 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateSearcher2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher3,
                retval: ?*SearchScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher3,
                retval: ?*SearchScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SearchScope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSearcher3,
                value: SearchScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSearcher3,
                value: SearchScope,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateSearcher2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher3_get_SearchScope(self: *const T, retval: ?*SearchScope) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher3.VTable, @ptrCast(self.vtable)).get_SearchScope(@as(*const IUpdateSearcher3, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSearcher3_put_SearchScope(self: *const T, value: SearchScope) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSearcher3.VTable, @ptrCast(self.vtable)).put_SearchScope(@as(*const IUpdateSearcher3, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateDownloadResult_Value = Guid.initString("bf99af76-b575-42ad-8aa4-33cbb5477af1");
pub const IID_IUpdateDownloadResult = &IID_IUpdateDownloadResult_Value;
pub const IUpdateDownloadResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloadResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloadResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadResult_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadResult.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IUpdateDownloadResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloadResult_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloadResult.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const IUpdateDownloadResult, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadResult_Value = Guid.initString("daa4fdd0-4727-4dbe-a1e7-745dca317144");
pub const IID_IDownloadResult = &IID_IDownloadResult_Value;
pub const IDownloadResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadResult,
                updateIndex: i32,
                retval: ?*?*IUpdateDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadResult,
                updateIndex: i32,
                retval: ?*?*IUpdateDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadResult_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDownloadResult.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IDownloadResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadResult_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const IDownloadResult.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const IDownloadResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadResult_GetUpdateResult(self: *const T, updateIndex: i32, retval: ?*?*IUpdateDownloadResult) callconv(.Inline) HRESULT {
            return @as(*const IDownloadResult.VTable, @ptrCast(self.vtable)).GetUpdateResult(@as(*const IDownloadResult, @ptrCast(self)), updateIndex, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadProgress_Value = Guid.initString("d31a5bac-f719-4178-9dbb-5e2cb47fd18a");
pub const IID_IDownloadProgress = &IID_IDownloadProgress_Value;
pub const IDownloadProgress = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdateBytesDownloaded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdateBytesToDownload: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdateIndex: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PercentComplete: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalBytesDownloaded: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalBytesToDownload: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*DECIMAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadProgress,
                updateIndex: i32,
                retval: ?*?*IUpdateDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadProgress,
                updateIndex: i32,
                retval: ?*?*IUpdateDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdateDownloadPhase: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*DownloadPhase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*DownloadPhase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdatePercentComplete: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_CurrentUpdateBytesDownloaded(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdateBytesDownloaded(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_CurrentUpdateBytesToDownload(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdateBytesToDownload(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_CurrentUpdateIndex(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdateIndex(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_PercentComplete(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_PercentComplete(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_TotalBytesDownloaded(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_TotalBytesDownloaded(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_TotalBytesToDownload(self: *const T, retval: ?*DECIMAL) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_TotalBytesToDownload(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_GetUpdateResult(self: *const T, updateIndex: i32, retval: ?*?*IUpdateDownloadResult) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).GetUpdateResult(@as(*const IDownloadProgress, @ptrCast(self)), updateIndex, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_CurrentUpdateDownloadPhase(self: *const T, retval: ?*DownloadPhase) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdateDownloadPhase(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgress_get_CurrentUpdatePercentComplete(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdatePercentComplete(@as(*const IDownloadProgress, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadJob_Value = Guid.initString("c574de85-7358-43f6-aae8-8697e62d8ba7");
pub const IID_IDownloadJob = &IID_IDownloadJob_Value;
pub const IDownloadJob = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AsyncState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsCompleted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadJob,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadJob,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CleanUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadJob,
                retval: ?*?*IDownloadProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadJob,
                retval: ?*?*IDownloadProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_get_AsyncState(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).get_AsyncState(@as(*const IDownloadJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_get_IsCompleted(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).get_IsCompleted(@as(*const IDownloadJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const IDownloadJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_CleanUp(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).CleanUp(@as(*const IDownloadJob, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_GetProgress(self: *const T, retval: ?*?*IDownloadProgress) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).GetProgress(@as(*const IDownloadJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadJob_RequestAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDownloadJob.VTable, @ptrCast(self.vtable)).RequestAbort(@as(*const IDownloadJob, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadCompletedCallbackArgs_Value = Guid.initString("fa565b23-498c-47a0-979d-e7d5b1813360");
pub const IID_IDownloadCompletedCallbackArgs = &IID_IDownloadCompletedCallbackArgs_Value;
pub const IDownloadCompletedCallbackArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadCompletedCallback_Value = Guid.initString("77254866-9f5b-4c8e-b9e2-c77a8530d64b");
pub const IID_IDownloadCompletedCallback = &IID_IDownloadCompletedCallback_Value;
pub const IDownloadCompletedCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadCompletedCallback,
                downloadJob: ?*IDownloadJob,
                callbackArgs: ?*IDownloadCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadCompletedCallback,
                downloadJob: ?*IDownloadJob,
                callbackArgs: ?*IDownloadCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadCompletedCallback_Invoke(self: *const T, downloadJob: ?*IDownloadJob, callbackArgs: ?*IDownloadCompletedCallbackArgs) callconv(.Inline) HRESULT {
            return @as(*const IDownloadCompletedCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IDownloadCompletedCallback, @ptrCast(self)), downloadJob, callbackArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadProgressChangedCallbackArgs_Value = Guid.initString("324ff2c6-4981-4b04-9412-57481745ab24");
pub const IID_IDownloadProgressChangedCallbackArgs = &IID_IDownloadProgressChangedCallbackArgs_Value;
pub const IDownloadProgressChangedCallbackArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Progress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDownloadProgressChangedCallbackArgs,
                retval: ?*?*IDownloadProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDownloadProgressChangedCallbackArgs,
                retval: ?*?*IDownloadProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgressChangedCallbackArgs_get_Progress(self: *const T, retval: ?*?*IDownloadProgress) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgressChangedCallbackArgs.VTable, @ptrCast(self.vtable)).get_Progress(@as(*const IDownloadProgressChangedCallbackArgs, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDownloadProgressChangedCallback_Value = Guid.initString("8c3f1cdd-6173-4591-aebd-a56a53ca77c1");
pub const IID_IDownloadProgressChangedCallback = &IID_IDownloadProgressChangedCallback_Value;
pub const IDownloadProgressChangedCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadProgressChangedCallback,
                downloadJob: ?*IDownloadJob,
                callbackArgs: ?*IDownloadProgressChangedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadProgressChangedCallback,
                downloadJob: ?*IDownloadJob,
                callbackArgs: ?*IDownloadProgressChangedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadProgressChangedCallback_Invoke(self: *const T, downloadJob: ?*IDownloadJob, callbackArgs: ?*IDownloadProgressChangedCallbackArgs) callconv(.Inline) HRESULT {
            return @as(*const IDownloadProgressChangedCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IDownloadProgressChangedCallback, @ptrCast(self)), downloadJob, callbackArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateDownloader_Value = Guid.initString("68f1c6f9-7ecc-4666-a464-247fe12496c3");
pub const IID_IUpdateDownloader = &IID_IUpdateDownloader_Value;
pub const IUpdateDownloader = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsForced: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsForced: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Priority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                retval: ?*DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                retval: ?*DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Priority: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                value: DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                value: DownloadPriority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateDownloader,
                value: ?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateDownloader,
                value: ?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateDownloader,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateDownloader,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IDownloadJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateDownloader,
                retval: ?*?*IDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateDownloader,
                retval: ?*?*IDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateDownloader,
                value: ?*IDownloadJob,
                retval: ?*?*IDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateDownloader,
                value: ?*IDownloadJob,
                retval: ?*?*IDownloadResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateDownloader, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_put_ClientApplicationID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).put_ClientApplicationID(@as(*const IUpdateDownloader, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_get_IsForced(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).get_IsForced(@as(*const IUpdateDownloader, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_put_IsForced(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).put_IsForced(@as(*const IUpdateDownloader, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_get_Priority(self: *const T, retval: ?*DownloadPriority) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).get_Priority(@as(*const IUpdateDownloader, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_put_Priority(self: *const T, value: DownloadPriority) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).put_Priority(@as(*const IUpdateDownloader, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const IUpdateDownloader, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_put_Updates(self: *const T, value: ?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).put_Updates(@as(*const IUpdateDownloader, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_BeginDownload(self: *const T, onProgressChanged: ?*IUnknown, onCompleted: ?*IUnknown, state: VARIANT, retval: ?*?*IDownloadJob) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).BeginDownload(@as(*const IUpdateDownloader, @ptrCast(self)), onProgressChanged, onCompleted, state, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_Download(self: *const T, retval: ?*?*IDownloadResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).Download(@as(*const IUpdateDownloader, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateDownloader_EndDownload(self: *const T, value: ?*IDownloadJob, retval: ?*?*IDownloadResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateDownloader.VTable, @ptrCast(self.vtable)).EndDownload(@as(*const IUpdateDownloader, @ptrCast(self)), value, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateInstallationResult_Value = Guid.initString("d940f0f8-3cbb-4fd0-993f-471e7f2328ad");
pub const IID_IUpdateInstallationResult = &IID_IUpdateInstallationResult_Value;
pub const IUpdateInstallationResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstallationResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstallationResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstallationResult,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstallationResult,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstallationResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstallationResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstallationResult_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstallationResult.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IUpdateInstallationResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstallationResult_get_RebootRequired(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstallationResult.VTable, @ptrCast(self.vtable)).get_RebootRequired(@as(*const IUpdateInstallationResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstallationResult_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstallationResult.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const IUpdateInstallationResult, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationResult_Value = Guid.initString("a43c56d6-7451-48d4-af96-b6cd2d0d9b7a");
pub const IID_IInstallationResult = &IID_IInstallationResult_Value;
pub const IInstallationResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationResult,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequired: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationResult,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationResult,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationResult,
                retval: ?*OperationResultCode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationResult,
                updateIndex: i32,
                retval: ?*?*IUpdateInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationResult,
                updateIndex: i32,
                retval: ?*?*IUpdateInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationResult_get_HResult(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IInstallationResult.VTable, @ptrCast(self.vtable)).get_HResult(@as(*const IInstallationResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationResult_get_RebootRequired(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IInstallationResult.VTable, @ptrCast(self.vtable)).get_RebootRequired(@as(*const IInstallationResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationResult_get_ResultCode(self: *const T, retval: ?*OperationResultCode) callconv(.Inline) HRESULT {
            return @as(*const IInstallationResult.VTable, @ptrCast(self.vtable)).get_ResultCode(@as(*const IInstallationResult, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationResult_GetUpdateResult(self: *const T, updateIndex: i32, retval: ?*?*IUpdateInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IInstallationResult.VTable, @ptrCast(self.vtable)).GetUpdateResult(@as(*const IInstallationResult, @ptrCast(self)), updateIndex, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationProgress_Value = Guid.initString("345c8244-43a3-4e32-a368-65f073b76f36");
pub const IID_IInstallationProgress = &IID_IInstallationProgress_Value;
pub const IInstallationProgress = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdateIndex: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentUpdatePercentComplete: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PercentComplete: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationProgress,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationProgress,
                updateIndex: i32,
                retval: ?*?*IUpdateInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationProgress,
                updateIndex: i32,
                retval: ?*?*IUpdateInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgress_get_CurrentUpdateIndex(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdateIndex(@as(*const IInstallationProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgress_get_CurrentUpdatePercentComplete(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgress.VTable, @ptrCast(self.vtable)).get_CurrentUpdatePercentComplete(@as(*const IInstallationProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgress_get_PercentComplete(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgress.VTable, @ptrCast(self.vtable)).get_PercentComplete(@as(*const IInstallationProgress, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgress_GetUpdateResult(self: *const T, updateIndex: i32, retval: ?*?*IUpdateInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgress.VTable, @ptrCast(self.vtable)).GetUpdateResult(@as(*const IInstallationProgress, @ptrCast(self)), updateIndex, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationJob_Value = Guid.initString("5c209f0b-bad5-432a-9556-4699bed2638a");
pub const IID_IInstallationJob = &IID_IInstallationJob_Value;
pub const IInstallationJob = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AsyncState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationJob,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsCompleted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationJob,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationJob,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationJob,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CleanUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationJob,
                retval: ?*?*IInstallationProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationJob,
                retval: ?*?*IInstallationProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_get_AsyncState(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).get_AsyncState(@as(*const IInstallationJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_get_IsCompleted(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).get_IsCompleted(@as(*const IInstallationJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const IInstallationJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_CleanUp(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).CleanUp(@as(*const IInstallationJob, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_GetProgress(self: *const T, retval: ?*?*IInstallationProgress) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).GetProgress(@as(*const IInstallationJob, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationJob_RequestAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IInstallationJob.VTable, @ptrCast(self.vtable)).RequestAbort(@as(*const IInstallationJob, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationCompletedCallbackArgs_Value = Guid.initString("250e2106-8efb-4705-9653-ef13c581b6a1");
pub const IID_IInstallationCompletedCallbackArgs = &IID_IInstallationCompletedCallbackArgs_Value;
pub const IInstallationCompletedCallbackArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationCompletedCallback_Value = Guid.initString("45f4f6f3-d602-4f98-9a8a-3efa152ad2d3");
pub const IID_IInstallationCompletedCallback = &IID_IInstallationCompletedCallback_Value;
pub const IInstallationCompletedCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationCompletedCallback,
                installationJob: ?*IInstallationJob,
                callbackArgs: ?*IInstallationCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationCompletedCallback,
                installationJob: ?*IInstallationJob,
                callbackArgs: ?*IInstallationCompletedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationCompletedCallback_Invoke(self: *const T, installationJob: ?*IInstallationJob, callbackArgs: ?*IInstallationCompletedCallbackArgs) callconv(.Inline) HRESULT {
            return @as(*const IInstallationCompletedCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IInstallationCompletedCallback, @ptrCast(self)), installationJob, callbackArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationProgressChangedCallbackArgs_Value = Guid.initString("e4f14e1e-689d-4218-a0b9-bc189c484a01");
pub const IID_IInstallationProgressChangedCallbackArgs = &IID_IInstallationProgressChangedCallbackArgs_Value;
pub const IInstallationProgressChangedCallbackArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Progress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IInstallationProgressChangedCallbackArgs,
                retval: ?*?*IInstallationProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IInstallationProgressChangedCallbackArgs,
                retval: ?*?*IInstallationProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgressChangedCallbackArgs_get_Progress(self: *const T, retval: ?*?*IInstallationProgress) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgressChangedCallbackArgs.VTable, @ptrCast(self.vtable)).get_Progress(@as(*const IInstallationProgressChangedCallbackArgs, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationProgressChangedCallback_Value = Guid.initString("e01402d5-f8da-43ba-a012-38894bd048f1");
pub const IID_IInstallationProgressChangedCallback = &IID_IInstallationProgressChangedCallback_Value;
pub const IInstallationProgressChangedCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationProgressChangedCallback,
                installationJob: ?*IInstallationJob,
                callbackArgs: ?*IInstallationProgressChangedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationProgressChangedCallback,
                installationJob: ?*IInstallationJob,
                callbackArgs: ?*IInstallationProgressChangedCallbackArgs,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationProgressChangedCallback_Invoke(self: *const T, installationJob: ?*IInstallationJob, callbackArgs: ?*IInstallationProgressChangedCallbackArgs) callconv(.Inline) HRESULT {
            return @as(*const IInstallationProgressChangedCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IInstallationProgressChangedCallback, @ptrCast(self)), installationJob, callbackArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateInstaller_Value = Guid.initString("7b929c68-ccdc-4226-96b1-8724600b54c2");
pub const IID_IUpdateInstaller = &IID_IUpdateInstaller_Value;
pub const IUpdateInstaller = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsForced: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsForced: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentHwnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentHwnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ParentWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentWindow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Updates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?*IUpdateCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginInstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginUninstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                onProgressChanged: ?*IUnknown,
                onCompleted: ?*IUnknown,
                state: VARIANT,
                retval: ?*?*IInstallationJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?*IInstallationJob,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?*IInstallationJob,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUninstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: ?*IInstallationJob,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                value: ?*IInstallationJob,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Install: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RunWizard: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                dialogTitle: ?BSTR,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                dialogTitle: ?BSTR,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBusy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Uninstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*?*IInstallationResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowSourcePrompts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowSourcePrompts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RebootRequiredBeforeInstallation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_ClientApplicationID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_ClientApplicationID(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_IsForced(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_IsForced(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_IsForced(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_IsForced(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_ParentHwnd(self: *const T, retval: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_ParentHwnd(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_ParentHwnd(self: *const T, value: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_ParentHwnd(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_ParentWindow(self: *const T, value: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_ParentWindow(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_ParentWindow(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_ParentWindow(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_Updates(self: *const T, retval: ?*?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_Updates(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_Updates(self: *const T, value: ?*IUpdateCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_Updates(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_BeginInstall(self: *const T, onProgressChanged: ?*IUnknown, onCompleted: ?*IUnknown, state: VARIANT, retval: ?*?*IInstallationJob) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).BeginInstall(@as(*const IUpdateInstaller, @ptrCast(self)), onProgressChanged, onCompleted, state, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_BeginUninstall(self: *const T, onProgressChanged: ?*IUnknown, onCompleted: ?*IUnknown, state: VARIANT, retval: ?*?*IInstallationJob) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).BeginUninstall(@as(*const IUpdateInstaller, @ptrCast(self)), onProgressChanged, onCompleted, state, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_EndInstall(self: *const T, value: ?*IInstallationJob, retval: ?*?*IInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).EndInstall(@as(*const IUpdateInstaller, @ptrCast(self)), value, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_EndUninstall(self: *const T, value: ?*IInstallationJob, retval: ?*?*IInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).EndUninstall(@as(*const IUpdateInstaller, @ptrCast(self)), value, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_Install(self: *const T, retval: ?*?*IInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).Install(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_RunWizard(self: *const T, dialogTitle: ?BSTR, retval: ?*?*IInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).RunWizard(@as(*const IUpdateInstaller, @ptrCast(self)), dialogTitle, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_IsBusy(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_IsBusy(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_Uninstall(self: *const T, retval: ?*?*IInstallationResult) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).Uninstall(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_AllowSourcePrompts(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_AllowSourcePrompts(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_put_AllowSourcePrompts(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).put_AllowSourcePrompts(@as(*const IUpdateInstaller, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller_get_RebootRequiredBeforeInstallation(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller.VTable, @ptrCast(self.vtable)).get_RebootRequiredBeforeInstallation(@as(*const IUpdateInstaller, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateInstaller2_Value = Guid.initString("3442d4fe-224d-4cee-98cf-30e0c4d229e6");
pub const IID_IUpdateInstaller2 = &IID_IUpdateInstaller2_Value;
pub const IUpdateInstaller2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateInstaller.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceQuiet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceQuiet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateInstaller.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller2_get_ForceQuiet(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller2.VTable, @ptrCast(self.vtable)).get_ForceQuiet(@as(*const IUpdateInstaller2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller2_put_ForceQuiet(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller2.VTable, @ptrCast(self.vtable)).put_ForceQuiet(@as(*const IUpdateInstaller2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IUpdateInstaller3_Value = Guid.initString("16d11c35-099a-48d0-8338-5fae64047f8e");
pub const IID_IUpdateInstaller3 = &IID_IUpdateInstaller3_Value;
pub const IUpdateInstaller3 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateInstaller2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttemptCloseAppsIfNecessary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller3,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttemptCloseAppsIfNecessary: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateInstaller3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateInstaller3,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateInstaller2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller3_get_AttemptCloseAppsIfNecessary(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller3.VTable, @ptrCast(self.vtable)).get_AttemptCloseAppsIfNecessary(@as(*const IUpdateInstaller3, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller3_put_AttemptCloseAppsIfNecessary(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller3.VTable, @ptrCast(self.vtable)).put_AttemptCloseAppsIfNecessary(@as(*const IUpdateInstaller3, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IUpdateInstaller4_Value = Guid.initString("ef8208ea-2304-492d-9109-23813b0958e1");
pub const IID_IUpdateInstaller4 = &IID_IUpdateInstaller4_Value;
pub const IUpdateInstaller4 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateInstaller3.VTable,
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateInstaller4,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateInstaller4,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateInstaller3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateInstaller4_Commit(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateInstaller4.VTable, @ptrCast(self.vtable)).Commit(@as(*const IUpdateInstaller4, @ptrCast(self)), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSession_Value = Guid.initString("816858a4-260d-4260-933a-2585f1abc76b");
pub const IID_IUpdateSession = &IID_IUpdateSession_Value;
pub const IUpdateSession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WebProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*?*IWebProxy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*?*IWebProxy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WebProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession,
                value: ?*IWebProxy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession,
                value: ?*IWebProxy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUpdateSearcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateSearcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateSearcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUpdateDownloader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateDownloader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateDownloader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUpdateInstaller: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateInstaller,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSession,
                retval: ?*?*IUpdateInstaller,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_put_ClientApplicationID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).put_ClientApplicationID(@as(*const IUpdateSession, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_get_ReadOnly(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).get_ReadOnly(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_get_WebProxy(self: *const T, retval: ?*?*IWebProxy) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).get_WebProxy(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_put_WebProxy(self: *const T, value: ?*IWebProxy) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).put_WebProxy(@as(*const IUpdateSession, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_CreateUpdateSearcher(self: *const T, retval: ?*?*IUpdateSearcher) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).CreateUpdateSearcher(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_CreateUpdateDownloader(self: *const T, retval: ?*?*IUpdateDownloader) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).CreateUpdateDownloader(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession_CreateUpdateInstaller(self: *const T, retval: ?*?*IUpdateInstaller) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession.VTable, @ptrCast(self.vtable)).CreateUpdateInstaller(@as(*const IUpdateSession, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSession2_Value = Guid.initString("91caf7b0-eb23-49ed-9937-c52d817f46f7");
pub const IID_IUpdateSession2 = &IID_IUpdateSession2_Value;
pub const IUpdateSession2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateSession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession2,
                retval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession2,
                retval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserLocale: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateSession2,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateSession2,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateSession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession2_get_UserLocale(self: *const T, retval: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession2.VTable, @ptrCast(self.vtable)).get_UserLocale(@as(*const IUpdateSession2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession2_put_UserLocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession2.VTable, @ptrCast(self.vtable)).put_UserLocale(@as(*const IUpdateSession2, @ptrCast(self)), lcid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateSession3_Value = Guid.initString("918efd1e-b5d8-4c90-8540-aeb9bdc56f9d");
pub const IID_IUpdateSession3 = &IID_IUpdateSession3_Value;
pub const IUpdateSession3 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateSession2.VTable,
        CreateUpdateServiceManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSession3,
                retval: ?*?*IUpdateServiceManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSession3,
                retval: ?*?*IUpdateServiceManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateSession3,
                criteria: ?BSTR,
                startIndex: i32,
                count: i32,
                retval: ?*?*IUpdateHistoryEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateSession3,
                criteria: ?BSTR,
                startIndex: i32,
                count: i32,
                retval: ?*?*IUpdateHistoryEntryCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateSession2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession3_CreateUpdateServiceManager(self: *const T, retval: ?*?*IUpdateServiceManager2) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession3.VTable, @ptrCast(self.vtable)).CreateUpdateServiceManager(@as(*const IUpdateSession3, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateSession3_QueryHistory(self: *const T, criteria: ?BSTR, startIndex: i32, count: i32, retval: ?*?*IUpdateHistoryEntryCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateSession3.VTable, @ptrCast(self.vtable)).QueryHistory(@as(*const IUpdateSession3, @ptrCast(self)), criteria, startIndex, count, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateService_Value = Guid.initString("76b3b17e-aed6-4da5-85f0-83587f81abe3");
pub const IID_IUpdateService = &IID_IUpdateService_Value;
pub const IUpdateService = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentValidationCert: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpirationDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsManaged: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRegisteredWithAU: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IssueDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OffersWindowsUpdates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RedirectUrls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScanPackageService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanRegisterWithAU: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SetupPrefix: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_Name(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_ContentValidationCert(self: *const T, retval: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_ContentValidationCert(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_ExpirationDate(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_ExpirationDate(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_IsManaged(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_IsManaged(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_IsRegisteredWithAU(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_IsRegisteredWithAU(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_IssueDate(self: *const T, retval: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_IssueDate(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_OffersWindowsUpdates(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_OffersWindowsUpdates(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_RedirectUrls(self: *const T, retval: ?*?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_RedirectUrls(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_ServiceID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_ServiceID(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_IsScanPackageService(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_IsScanPackageService(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_CanRegisterWithAU(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_CanRegisterWithAU(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_ServiceUrl(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_ServiceUrl(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService_get_SetupPrefix(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService.VTable, @ptrCast(self.vtable)).get_SetupPrefix(@as(*const IUpdateService, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateService2_Value = Guid.initString("1518b460-6518-4172-940f-c75883b24ceb");
pub const IID_IUpdateService2 = &IID_IUpdateService2_Value;
pub const IUpdateService2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateService.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefaultAUService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateService2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateService2,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateService.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateService2_get_IsDefaultAUService(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateService2.VTable, @ptrCast(self.vtable)).get_IsDefaultAUService(@as(*const IUpdateService2, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateServiceCollection_Value = Guid.initString("9b0353aa-0e52-44ff-b8b0-1f7fa0437f88");
pub const IID_IUpdateServiceCollection = &IID_IUpdateServiceCollection_Value;
pub const IUpdateServiceCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceCollection,
                index: i32,
                retval: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceCollection,
                index: i32,
                retval: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceCollection,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceCollection,
                retval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceCollection_get_Item(self: *const T, index: i32, retval: ?*?*IUpdateService) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceCollection.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUpdateServiceCollection, @ptrCast(self)), index, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceCollection_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUpdateServiceCollection, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceCollection_get_Count(self: *const T, retval: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUpdateServiceCollection, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateServiceRegistration_Value = Guid.initString("dde02280-12b3-4e0b-937b-6747f6acb286");
pub const IID_IUpdateServiceRegistration = &IID_IUpdateServiceRegistration_Value;
pub const IUpdateServiceRegistration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegistrationState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*UpdateServiceRegistrationState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*UpdateServiceRegistrationState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPendingRegistrationWithAU: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Service: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*?*IUpdateService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceRegistration,
                retval: ?*?*IUpdateService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceRegistration_get_RegistrationState(self: *const T, retval: ?*UpdateServiceRegistrationState) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceRegistration.VTable, @ptrCast(self.vtable)).get_RegistrationState(@as(*const IUpdateServiceRegistration, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceRegistration_get_ServiceID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceRegistration.VTable, @ptrCast(self.vtable)).get_ServiceID(@as(*const IUpdateServiceRegistration, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceRegistration_get_IsPendingRegistrationWithAU(self: *const T, retval: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceRegistration.VTable, @ptrCast(self.vtable)).get_IsPendingRegistrationWithAU(@as(*const IUpdateServiceRegistration, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceRegistration_get_Service(self: *const T, retval: ?*?*IUpdateService2) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceRegistration.VTable, @ptrCast(self.vtable)).get_Service(@as(*const IUpdateServiceRegistration, @ptrCast(self)), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateServiceManager_Value = Guid.initString("23857e3c-02ba-44a3-9423-b1c900805f37");
pub const IID_IUpdateServiceManager = &IID_IUpdateServiceManager_Value;
pub const IUpdateServiceManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Services: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                retval: ?*?*IUpdateServiceCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceManager,
                retval: ?*?*IUpdateServiceCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
                authorizationCabPath: ?BSTR,
                retval: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
                authorizationCabPath: ?BSTR,
                retval: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterServiceWithAU: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterServiceWithAU: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                serviceID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScanPackageService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                serviceName: ?BSTR,
                scanFileLocation: ?BSTR,
                flags: i32,
                ppService: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                serviceName: ?BSTR,
                scanFileLocation: ?BSTR,
                flags: i32,
                ppService: ?*?*IUpdateService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager,
                optionName: ?BSTR,
                optionValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager,
                optionName: ?BSTR,
                optionValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_get_Services(self: *const T, retval: ?*?*IUpdateServiceCollection) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).get_Services(@as(*const IUpdateServiceManager, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_AddService(self: *const T, serviceID: ?BSTR, authorizationCabPath: ?BSTR, retval: ?*?*IUpdateService) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).AddService(@as(*const IUpdateServiceManager, @ptrCast(self)), serviceID, authorizationCabPath, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_RegisterServiceWithAU(self: *const T, serviceID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).RegisterServiceWithAU(@as(*const IUpdateServiceManager, @ptrCast(self)), serviceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_RemoveService(self: *const T, serviceID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).RemoveService(@as(*const IUpdateServiceManager, @ptrCast(self)), serviceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_UnregisterServiceWithAU(self: *const T, serviceID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).UnregisterServiceWithAU(@as(*const IUpdateServiceManager, @ptrCast(self)), serviceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_AddScanPackageService(self: *const T, serviceName: ?BSTR, scanFileLocation: ?BSTR, flags: i32, ppService: ?*?*IUpdateService) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).AddScanPackageService(@as(*const IUpdateServiceManager, @ptrCast(self)), serviceName, scanFileLocation, flags, ppService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager_SetOption(self: *const T, optionName: ?BSTR, optionValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IUpdateServiceManager, @ptrCast(self)), optionName, optionValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUpdateServiceManager2_Value = Guid.initString("0bb8531d-7e8d-424f-986c-a0b8f60a3e7b");
pub const IID_IUpdateServiceManager2 = &IID_IUpdateServiceManager2_Value;
pub const IUpdateServiceManager2 = extern struct {
    pub const VTable = extern struct {
        base: IUpdateServiceManager.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceManager2,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceManager2,
                retval: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientApplicationID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUpdateServiceManager2,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUpdateServiceManager2,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryServiceRegistration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager2,
                serviceID: ?BSTR,
                retval: ?*?*IUpdateServiceRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager2,
                serviceID: ?BSTR,
                retval: ?*?*IUpdateServiceRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddService2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUpdateServiceManager2,
                serviceID: ?BSTR,
                flags: i32,
                authorizationCabPath: ?BSTR,
                retval: ?*?*IUpdateServiceRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUpdateServiceManager2,
                serviceID: ?BSTR,
                flags: i32,
                authorizationCabPath: ?BSTR,
                retval: ?*?*IUpdateServiceRegistration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUpdateServiceManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager2_get_ClientApplicationID(self: *const T, retval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager2.VTable, @ptrCast(self.vtable)).get_ClientApplicationID(@as(*const IUpdateServiceManager2, @ptrCast(self)), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager2_put_ClientApplicationID(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager2.VTable, @ptrCast(self.vtable)).put_ClientApplicationID(@as(*const IUpdateServiceManager2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager2_QueryServiceRegistration(self: *const T, serviceID: ?BSTR, retval: ?*?*IUpdateServiceRegistration) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager2.VTable, @ptrCast(self.vtable)).QueryServiceRegistration(@as(*const IUpdateServiceManager2, @ptrCast(self)), serviceID, retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateServiceManager2_AddService2(self: *const T, serviceID: ?BSTR, flags: i32, authorizationCabPath: ?BSTR, retval: ?*?*IUpdateServiceRegistration) callconv(.Inline) HRESULT {
            return @as(*const IUpdateServiceManager2.VTable, @ptrCast(self.vtable)).AddService2(@as(*const IUpdateServiceManager2, @ptrCast(self)), serviceID, flags, authorizationCabPath, retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInstallationAgent_Value = Guid.initString("925cbc18-a2ea-4648-bf1c-ec8badcfe20a");
pub const IID_IInstallationAgent = &IID_IInstallationAgent_Value;
pub const IInstallationAgent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        RecordInstallationResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInstallationAgent,
                installationResultCookie: ?BSTR,
                hresult: i32,
                extendedReportingData: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInstallationAgent,
                installationResultCookie: ?BSTR,
                hresult: i32,
                extendedReportingData: ?*IStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInstallationAgent_RecordInstallationResult(self: *const T, installationResultCookie: ?BSTR, hresult: i32, extendedReportingData: ?*IStringCollection) callconv(.Inline) HRESULT {
            return @as(*const IInstallationAgent.VTable, @ptrCast(self.vtable)).RecordInstallationResult(@as(*const IInstallationAgent, @ptrCast(self)), installationResultCookie, hresult, extendedReportingData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const UpdateLockdownOption = enum(i32) {
    s = 1,
};
pub const uloForWebsiteAccess = UpdateLockdownOption.s;

pub const AddServiceFlag = enum(i32) {
    AllowPendingRegistration = 1,
    AllowOnlineRegistration = 2,
    RegisterServiceWithAU = 4,
};
pub const asfAllowPendingRegistration = AddServiceFlag.AllowPendingRegistration;
pub const asfAllowOnlineRegistration = AddServiceFlag.AllowOnlineRegistration;
pub const asfRegisterServiceWithAU = AddServiceFlag.RegisterServiceWithAU;

pub const UpdateServiceOption = enum(i32) {
    e = 1,
};
pub const usoNonVolatileService = UpdateServiceOption.e;


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const DECIMAL = @import("../foundation.zig").DECIMAL;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
