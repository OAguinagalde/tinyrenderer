//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (66)
//--------------------------------------------------------------------------------
pub const PROPSETFLAG_DEFAULT = @as(u32, 0);
pub const PROPSETFLAG_NONSIMPLE = @as(u32, 1);
pub const PROPSETFLAG_ANSI = @as(u32, 2);
pub const PROPSETFLAG_UNBUFFERED = @as(u32, 4);
pub const PROPSETFLAG_CASE_SENSITIVE = @as(u32, 8);
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE = @as(u32, 1);
pub const PID_DICTIONARY = @as(u32, 0);
pub const PID_CODEPAGE = @as(u32, 1);
pub const PID_FIRST_USABLE = @as(u32, 2);
pub const PID_FIRST_NAME_DEFAULT = @as(u32, 4095);
pub const PID_LOCALE = @as(u32, 2147483648);
pub const PID_MODIFY_TIME = @as(u32, 2147483649);
pub const PID_SECURITY = @as(u32, 2147483650);
pub const PID_BEHAVIOR = @as(u32, 2147483651);
pub const PID_ILLEGAL = @as(u32, 4294967295);
pub const PID_MIN_READONLY = @as(u32, 2147483648);
pub const PID_MAX_READONLY = @as(u32, 3221225471);
pub const PRSPEC_INVALID = @as(u32, 4294967295);
pub const PROPSETHDR_OSVERSION_UNKNOWN = @as(u32, 4294967295);
pub const PIDDI_THUMBNAIL = @as(i32, 2);
pub const PIDSI_TITLE = @as(i32, 2);
pub const PIDSI_SUBJECT = @as(i32, 3);
pub const PIDSI_AUTHOR = @as(i32, 4);
pub const PIDSI_KEYWORDS = @as(i32, 5);
pub const PIDSI_COMMENTS = @as(i32, 6);
pub const PIDSI_TEMPLATE = @as(i32, 7);
pub const PIDSI_LASTAUTHOR = @as(i32, 8);
pub const PIDSI_REVNUMBER = @as(i32, 9);
pub const PIDSI_EDITTIME = @as(i32, 10);
pub const PIDSI_LASTPRINTED = @as(i32, 11);
pub const PIDSI_CREATE_DTM = @as(i32, 12);
pub const PIDSI_LASTSAVE_DTM = @as(i32, 13);
pub const PIDSI_PAGECOUNT = @as(i32, 14);
pub const PIDSI_WORDCOUNT = @as(i32, 15);
pub const PIDSI_CHARCOUNT = @as(i32, 16);
pub const PIDSI_THUMBNAIL = @as(i32, 17);
pub const PIDSI_APPNAME = @as(i32, 18);
pub const PIDSI_DOC_SECURITY = @as(i32, 19);
pub const PIDDSI_CATEGORY = @as(u32, 2);
pub const PIDDSI_PRESFORMAT = @as(u32, 3);
pub const PIDDSI_BYTECOUNT = @as(u32, 4);
pub const PIDDSI_LINECOUNT = @as(u32, 5);
pub const PIDDSI_PARCOUNT = @as(u32, 6);
pub const PIDDSI_SLIDECOUNT = @as(u32, 7);
pub const PIDDSI_NOTECOUNT = @as(u32, 8);
pub const PIDDSI_HIDDENCOUNT = @as(u32, 9);
pub const PIDDSI_MMCLIPCOUNT = @as(u32, 10);
pub const PIDDSI_SCALE = @as(u32, 11);
pub const PIDDSI_HEADINGPAIR = @as(u32, 12);
pub const PIDDSI_DOCPARTS = @as(u32, 13);
pub const PIDDSI_MANAGER = @as(u32, 14);
pub const PIDDSI_COMPANY = @as(u32, 15);
pub const PIDDSI_LINKSDIRTY = @as(u32, 16);
pub const PIDMSI_EDITOR = @as(i32, 2);
pub const PIDMSI_SUPPLIER = @as(i32, 3);
pub const PIDMSI_SOURCE = @as(i32, 4);
pub const PIDMSI_SEQUENCE_NO = @as(i32, 5);
pub const PIDMSI_PROJECT = @as(i32, 6);
pub const PIDMSI_STATUS = @as(i32, 7);
pub const PIDMSI_OWNER = @as(i32, 8);
pub const PIDMSI_RATING = @as(i32, 9);
pub const PIDMSI_PRODUCTION = @as(i32, 10);
pub const PIDMSI_COPYRIGHT = @as(i32, 11);
pub const CWCSTORAGENAME = @as(u32, 32);
pub const STGOPTIONS_VERSION = @as(u32, 1);
pub const CCH_MAX_PROPSTG_NAME = @as(u32, 31);

//--------------------------------------------------------------------------------
// Section: Types (58)
//--------------------------------------------------------------------------------
pub const PROPSPEC_KIND = enum(u32) {
    LPWSTR = 0,
    PROPID = 1,
};
pub const PRSPEC_LPWSTR = PROPSPEC_KIND.LPWSTR;
pub const PRSPEC_PROPID = PROPSPEC_KIND.PROPID;

pub const STGM = enum(u32) {
    DIRECT = 0,
    TRANSACTED = 65536,
    SIMPLE = 134217728,
    // READ = 0, this enum value conflicts with DIRECT
    WRITE = 1,
    READWRITE = 2,
    SHARE_DENY_NONE = 64,
    SHARE_DENY_READ = 48,
    SHARE_DENY_WRITE = 32,
    SHARE_EXCLUSIVE = 16,
    PRIORITY = 262144,
    DELETEONRELEASE = 67108864,
    NOSCRATCH = 1048576,
    CREATE = 4096,
    CONVERT = 131072,
    // FAILIFTHERE = 0, this enum value conflicts with DIRECT
    NOSNAPSHOT = 2097152,
    DIRECT_SWMR = 4194304,
    _,
    pub fn initFlags(o: struct {
        DIRECT: u1 = 0,
        TRANSACTED: u1 = 0,
        SIMPLE: u1 = 0,
        WRITE: u1 = 0,
        READWRITE: u1 = 0,
        SHARE_DENY_NONE: u1 = 0,
        SHARE_DENY_READ: u1 = 0,
        SHARE_DENY_WRITE: u1 = 0,
        SHARE_EXCLUSIVE: u1 = 0,
        PRIORITY: u1 = 0,
        DELETEONRELEASE: u1 = 0,
        NOSCRATCH: u1 = 0,
        CREATE: u1 = 0,
        CONVERT: u1 = 0,
        NOSNAPSHOT: u1 = 0,
        DIRECT_SWMR: u1 = 0,
    }) STGM {
        return @as(STGM, @enumFromInt(
              (if (o.DIRECT == 1) @intFromEnum(STGM.DIRECT) else 0)
            | (if (o.TRANSACTED == 1) @intFromEnum(STGM.TRANSACTED) else 0)
            | (if (o.SIMPLE == 1) @intFromEnum(STGM.SIMPLE) else 0)
            | (if (o.WRITE == 1) @intFromEnum(STGM.WRITE) else 0)
            | (if (o.READWRITE == 1) @intFromEnum(STGM.READWRITE) else 0)
            | (if (o.SHARE_DENY_NONE == 1) @intFromEnum(STGM.SHARE_DENY_NONE) else 0)
            | (if (o.SHARE_DENY_READ == 1) @intFromEnum(STGM.SHARE_DENY_READ) else 0)
            | (if (o.SHARE_DENY_WRITE == 1) @intFromEnum(STGM.SHARE_DENY_WRITE) else 0)
            | (if (o.SHARE_EXCLUSIVE == 1) @intFromEnum(STGM.SHARE_EXCLUSIVE) else 0)
            | (if (o.PRIORITY == 1) @intFromEnum(STGM.PRIORITY) else 0)
            | (if (o.DELETEONRELEASE == 1) @intFromEnum(STGM.DELETEONRELEASE) else 0)
            | (if (o.NOSCRATCH == 1) @intFromEnum(STGM.NOSCRATCH) else 0)
            | (if (o.CREATE == 1) @intFromEnum(STGM.CREATE) else 0)
            | (if (o.CONVERT == 1) @intFromEnum(STGM.CONVERT) else 0)
            | (if (o.NOSNAPSHOT == 1) @intFromEnum(STGM.NOSNAPSHOT) else 0)
            | (if (o.DIRECT_SWMR == 1) @intFromEnum(STGM.DIRECT_SWMR) else 0)
        ));
    }
};
pub const STGM_DIRECT = STGM.DIRECT;
pub const STGM_TRANSACTED = STGM.TRANSACTED;
pub const STGM_SIMPLE = STGM.SIMPLE;
pub const STGM_READ = STGM.DIRECT;
pub const STGM_WRITE = STGM.WRITE;
pub const STGM_READWRITE = STGM.READWRITE;
pub const STGM_SHARE_DENY_NONE = STGM.SHARE_DENY_NONE;
pub const STGM_SHARE_DENY_READ = STGM.SHARE_DENY_READ;
pub const STGM_SHARE_DENY_WRITE = STGM.SHARE_DENY_WRITE;
pub const STGM_SHARE_EXCLUSIVE = STGM.SHARE_EXCLUSIVE;
pub const STGM_PRIORITY = STGM.PRIORITY;
pub const STGM_DELETEONRELEASE = STGM.DELETEONRELEASE;
pub const STGM_NOSCRATCH = STGM.NOSCRATCH;
pub const STGM_CREATE = STGM.CREATE;
pub const STGM_CONVERT = STGM.CONVERT;
pub const STGM_FAILIFTHERE = STGM.DIRECT;
pub const STGM_NOSNAPSHOT = STGM.NOSNAPSHOT;
pub const STGM_DIRECT_SWMR = STGM.DIRECT_SWMR;

pub const STGFMT = enum(u32) {
    STORAGE = 0,
    NATIVE = 1,
    FILE = 3,
    ANY = 4,
    DOCFILE = 5,
    // DOCUMENT = 0, this enum value conflicts with STORAGE
};
pub const STGFMT_STORAGE = STGFMT.STORAGE;
pub const STGFMT_NATIVE = STGFMT.NATIVE;
pub const STGFMT_FILE = STGFMT.FILE;
pub const STGFMT_ANY = STGFMT.ANY;
pub const STGFMT_DOCFILE = STGFMT.DOCFILE;
pub const STGFMT_DOCUMENT = STGFMT.STORAGE;

pub const STGC = enum(u32) {
    DEFAULT = 0,
    OVERWRITE = 1,
    ONLYIFCURRENT = 2,
    DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    CONSOLIDATE = 8,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        OVERWRITE: u1 = 0,
        ONLYIFCURRENT: u1 = 0,
        DANGEROUSLYCOMMITMERELYTODISKCACHE: u1 = 0,
        CONSOLIDATE: u1 = 0,
    }) STGC {
        return @as(STGC, @enumFromInt(
              (if (o.DEFAULT == 1) @intFromEnum(STGC.DEFAULT) else 0)
            | (if (o.OVERWRITE == 1) @intFromEnum(STGC.OVERWRITE) else 0)
            | (if (o.ONLYIFCURRENT == 1) @intFromEnum(STGC.ONLYIFCURRENT) else 0)
            | (if (o.DANGEROUSLYCOMMITMERELYTODISKCACHE == 1) @intFromEnum(STGC.DANGEROUSLYCOMMITMERELYTODISKCACHE) else 0)
            | (if (o.CONSOLIDATE == 1) @intFromEnum(STGC.CONSOLIDATE) else 0)
        ));
    }
};
pub const STGC_DEFAULT = STGC.DEFAULT;
pub const STGC_OVERWRITE = STGC.OVERWRITE;
pub const STGC_ONLYIFCURRENT = STGC.ONLYIFCURRENT;
pub const STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = STGC.DANGEROUSLYCOMMITMERELYTODISKCACHE;
pub const STGC_CONSOLIDATE = STGC.CONSOLIDATE;

pub const STGMOVE = enum(i32) {
    MOVE = 0,
    COPY = 1,
    SHALLOWCOPY = 2,
};
pub const STGMOVE_MOVE = STGMOVE.MOVE;
pub const STGMOVE_COPY = STGMOVE.COPY;
pub const STGMOVE_SHALLOWCOPY = STGMOVE.SHALLOWCOPY;

pub const STATFLAG = enum(i32) {
    DEFAULT = 0,
    NONAME = 1,
    NOOPEN = 2,
};
pub const STATFLAG_DEFAULT = STATFLAG.DEFAULT;
pub const STATFLAG_NONAME = STATFLAG.NONAME;
pub const STATFLAG_NOOPEN = STATFLAG.NOOPEN;

pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: ?*u8,
};

pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: ?*u8,
};

pub const LOCKTYPE = enum(i32) {
    WRITE = 1,
    EXCLUSIVE = 2,
    ONLYONCE = 4,
};
pub const LOCK_WRITE = LOCKTYPE.WRITE;
pub const LOCK_EXCLUSIVE = LOCKTYPE.EXCLUSIVE;
pub const LOCK_ONLYONCE = LOCKTYPE.ONLYONCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATSTG_Value = Guid.initString("0000000d-0000-0000-c000-000000000046");
pub const IID_IEnumSTATSTG = &IID_IEnumSTATSTG_Value;
pub const IEnumSTATSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                celt: u32,
                rgelt: [*]STATSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                celt: u32,
                rgelt: [*]STATSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Next(self: *const T, celt: u32, rgelt: [*]STATSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RemSNB = extern struct {
    ulCntStr: u32,
    ulCntChar: u32,
    rgString: [1]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStorage_Value = Guid.initString("0000000b-0000-0000-c000-000000000046");
pub const IID_IStorage = &IID_IStorage_Value;
pub const IStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                reserved1: ?*anyopaque,
                grfMode: STGM,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                reserved1: ?*anyopaque,
                grfMode: STGM,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pstgPriority: ?*IStorage,
                grfMode: STGM,
                snbExclude: ?*?*u16,
                reserved: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pstgPriority: ?*IStorage,
                grfMode: STGM,
                snbExclude: ?*?*u16,
                reserved: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                ciidExclude: u32,
                rgiidExclude: ?[*]const Guid,
                snbExclude: ?*?*u16,
                pstgDest: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                ciidExclude: u32,
                rgiidExclude: ?[*]const Guid,
                snbExclude: ?*?*u16,
                pstgDest: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveElementTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pstgDest: ?*IStorage,
                pwcsNewName: ?[*:0]const u16,
                grfFlags: STGMOVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pstgDest: ?*IStorage,
                pwcsNewName: ?[*:0]const u16,
                grfFlags: STGMOVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                grfCommitFlags: STGC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                grfCommitFlags: STGC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                reserved1: u32,
                reserved2: ?*anyopaque,
                reserved3: u32,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                reserved1: u32,
                reserved2: ?*anyopaque,
                reserved3: u32,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsOldName: ?[*:0]const u16,
                pwcsNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsOldName: ?[*:0]const u16,
                pwcsNewName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetElementTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]const u16,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStateBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                grfStateBits: u32,
                grfMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                grfStateBits: u32,
                grfMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStream(self: *const T, pwcsName: ?[*:0]const u16, grfMode: STGM, reserved1: u32, reserved2: u32, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const IStorage, @ptrCast(self)), pwcsName, grfMode, reserved1, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStream(self: *const T, pwcsName: ?[*:0]const u16, reserved1: ?*anyopaque, grfMode: STGM, reserved2: u32, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStream(@as(*const IStorage, @ptrCast(self)), pwcsName, reserved1, grfMode, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStorage(self: *const T, pwcsName: ?[*:0]const u16, grfMode: STGM, reserved1: u32, reserved2: u32, ppstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStorage(@as(*const IStorage, @ptrCast(self)), pwcsName, grfMode, reserved1, reserved2, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStorage(self: *const T, pwcsName: ?[*:0]const u16, pstgPriority: ?*IStorage, grfMode: STGM, snbExclude: ?*?*u16, reserved: u32, ppstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStorage(@as(*const IStorage, @ptrCast(self)), pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CopyTo(self: *const T, ciidExclude: u32, rgiidExclude: ?[*]const Guid, snbExclude: ?*?*u16, pstgDest: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IStorage, @ptrCast(self)), ciidExclude, rgiidExclude, snbExclude, pstgDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_MoveElementTo(self: *const T, pwcsName: ?[*:0]const u16, pstgDest: ?*IStorage, pwcsNewName: ?[*:0]const u16, grfFlags: STGMOVE) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).MoveElementTo(@as(*const IStorage, @ptrCast(self)), pwcsName, pstgDest, pwcsNewName, grfFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Commit(self: *const T, grfCommitFlags: STGC) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IStorage, @ptrCast(self)), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_EnumElements(self: *const T, reserved1: u32, reserved2: ?*anyopaque, reserved3: u32, ppenum: ?*?*IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).EnumElements(@as(*const IStorage, @ptrCast(self)), reserved1, reserved2, reserved3, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_DestroyElement(self: *const T, pwcsName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).DestroyElement(@as(*const IStorage, @ptrCast(self)), pwcsName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_RenameElement(self: *const T, pwcsOldName: ?[*:0]const u16, pwcsNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).RenameElement(@as(*const IStorage, @ptrCast(self)), pwcsOldName, pwcsNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetElementTimes(self: *const T, pwcsName: ?[*:0]const u16, pctime: ?*const FILETIME, patime: ?*const FILETIME, pmtime: ?*const FILETIME) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetElementTimes(@as(*const IStorage, @ptrCast(self)), pwcsName, pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetClass(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IStorage, @ptrCast(self)), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetStateBits(self: *const T, grfStateBits: u32, grfMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetStateBits(@as(*const IStorage, @ptrCast(self)), grfStateBits, grfMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IStorage, @ptrCast(self)), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStorage_Value = Guid.initString("0000010a-0000-0000-c000-000000000046");
pub const IID_IPersistStorage = &IID_IPersistStorage_Value;
pub const IPersistStorage = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStgSave: ?*IStorage,
                fSameAsLoad: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStgSave: ?*IStorage,
                fSameAsLoad: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStgNew: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStgNew: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandsOffStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_InitNew(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistStorage, @ptrCast(self)), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Load(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStorage, @ptrCast(self)), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Save(self: *const T, pStgSave: ?*IStorage, fSameAsLoad: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStorage, @ptrCast(self)), pStgSave, fSameAsLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_SaveCompleted(self: *const T, pStgNew: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IPersistStorage, @ptrCast(self)), pStgNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_HandsOffStorage(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).HandsOffStorage(@as(*const IPersistStorage, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILockBytes_Value = Guid.initString("0000000a-0000-0000-c000-000000000046");
pub const IID_ILockBytes = &IID_ILockBytes_Value;
pub const ILockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                cb: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                cb: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_ReadAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).ReadAt(@as(*const ILockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_WriteAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).WriteAt(@as(*const ILockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Flush(@as(*const ILockBytes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_SetSize(self: *const T, cb: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).SetSize(@as(*const ILockBytes, @ptrCast(self)), cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_LockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).LockRegion(@as(*const ILockBytes, @ptrCast(self)), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_UnlockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).UnlockRegion(@as(*const ILockBytes, @ptrCast(self)), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Stat(@as(*const ILockBytes, @ptrCast(self)), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRootStorage_Value = Guid.initString("00000012-0000-0000-c000-000000000046");
pub const IID_IRootStorage = &IID_IRootStorage_Value;
pub const IRootStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchToFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRootStorage,
                pszFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRootStorage,
                pszFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRootStorage_SwitchToFile(self: *const T, pszFile: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IRootStorage.VTable, @ptrCast(self.vtable)).SwitchToFile(@as(*const IRootStorage, @ptrCast(self)), pszFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFillLockBytes_Value = Guid.initString("99caf010-415e-11cf-8814-00aa00b569f5");
pub const IID_IFillLockBytes = &IID_IFillLockBytes_Value;
pub const IFillLockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FillAppend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                ulOffset: ULARGE_INTEGER,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFillSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                ulSize: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                ulSize: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                bCanceled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                bCanceled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAppend(self: *const T, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAppend(@as(*const IFillLockBytes, @ptrCast(self)), pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAt(self: *const T, ulOffset: ULARGE_INTEGER, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAt(@as(*const IFillLockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_SetFillSize(self: *const T, ulSize: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).SetFillSize(@as(*const IFillLockBytes, @ptrCast(self)), ulSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_Terminate(self: *const T, bCanceled: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IFillLockBytes, @ptrCast(self)), bCanceled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILayoutStorage_Value = Guid.initString("0e6d4d90-6738-11cf-9608-00aa00680db4");
pub const IID_ILayoutStorage = &IID_ILayoutStorage_Value;
pub const ILayoutStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LayoutScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pStorageLayout: [*]StorageLayout,
                nEntries: u32,
                glfInterleavedFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pStorageLayout: [*]StorageLayout,
                nEntries: u32,
                glfInterleavedFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReLayoutDocfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pwcsNewDfName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pwcsNewDfName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReLayoutDocfileOnILockBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pILockBytes: ?*ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pILockBytes: ?*ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_LayoutScript(self: *const T, pStorageLayout: [*]StorageLayout, nEntries: u32, glfInterleavedFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).LayoutScript(@as(*const ILayoutStorage, @ptrCast(self)), pStorageLayout, nEntries, glfInterleavedFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_BeginMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).BeginMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_EndMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).EndMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfile(self: *const T, pwcsNewDfName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfile(@as(*const ILayoutStorage, @ptrCast(self)), pwcsNewDfName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfileOnILockBytes(self: *const T, pILockBytes: ?*ILockBytes) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfileOnILockBytes(@as(*const ILayoutStorage, @ptrCast(self)), pILockBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectWriterLock_Value = Guid.initString("0e6d4d92-6738-11cf-9608-00aa00680db4");
pub const IID_IDirectWriterLock = &IID_IDirectWriterLock_Value;
pub const IDirectWriterLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HaveWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_WaitForWriteAccess(self: *const T, dwTimeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).WaitForWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)), dwTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_ReleaseWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).ReleaseWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_HaveWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).HaveWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VERSIONEDSTREAM = extern struct {
    guidVersion: Guid,
    pStream: ?*IStream,
};

pub const CAC = extern struct {
    cElems: u32,
    pElems: ?PSTR,
};

pub const CAUB = extern struct {
    cElems: u32,
    pElems: ?*u8,
};

pub const CAI = extern struct {
    cElems: u32,
    pElems: ?*i16,
};

pub const CAUI = extern struct {
    cElems: u32,
    pElems: ?*u16,
};

pub const CAL = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAUL = extern struct {
    cElems: u32,
    pElems: ?*u32,
};

pub const CAFLT = extern struct {
    cElems: u32,
    pElems: ?*f32,
};

pub const CADBL = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CACY = extern struct {
    cElems: u32,
    pElems: ?*CY,
};

pub const CADATE = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CABSTR = extern struct {
    cElems: u32,
    pElems: ?*?BSTR,
};

pub const CABSTRBLOB = extern struct {
    cElems: u32,
    pElems: ?*BSTRBLOB,
};

pub const CABOOL = extern struct {
    cElems: u32,
    pElems: ?*i16,
};

pub const CASCODE = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAPROPVARIANT = extern struct {
    cElems: u32,
    pElems: ?*PROPVARIANT,
};

pub const CAH = extern struct {
    cElems: u32,
    pElems: ?*LARGE_INTEGER,
};

pub const CAUH = extern struct {
    cElems: u32,
    pElems: ?*ULARGE_INTEGER,
};

pub const CALPSTR = extern struct {
    cElems: u32,
    pElems: ?*?PSTR,
};

pub const CALPWSTR = extern struct {
    cElems: u32,
    pElems: ?*?PWSTR,
};

pub const CAFILETIME = extern struct {
    cElems: u32,
    pElems: ?*FILETIME,
};

pub const CACLIPDATA = extern struct {
    cElems: u32,
    pElems: ?*CLIPDATA,
};

pub const CACLSID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};

pub const PROPVARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                cVal: CHAR,
                bVal: u8,
                iVal: i16,
                uiVal: u16,
                lVal: i32,
                ulVal: u32,
                intVal: i32,
                uintVal: u32,
                hVal: LARGE_INTEGER,
                uhVal: ULARGE_INTEGER,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                filetime: FILETIME,
                puuid: ?*Guid,
                pclipdata: ?*CLIPDATA,
                bstrVal: ?BSTR,
                bstrblobVal: BSTRBLOB,
                blob: BLOB,
                pszVal: ?PSTR,
                pwszVal: ?PWSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                pStream: ?*IStream,
                pStorage: ?*IStorage,
                pVersionedStream: ?*VERSIONEDSTREAM,
                parray: ?*SAFEARRAY,
                cac: CAC,
                caub: CAUB,
                cai: CAI,
                caui: CAUI,
                cal: CAL,
                caul: CAUL,
                cah: CAH,
                cauh: CAUH,
                caflt: CAFLT,
                cadbl: CADBL,
                cabool: CABOOL,
                cascode: CASCODE,
                cacy: CACY,
                cadate: CADATE,
                cafiletime: CAFILETIME,
                cauuid: CACLSID,
                caclipdata: CACLIPDATA,
                cabstr: CABSTR,
                cabstrblob: CABSTRBLOB,
                calpstr: CALPSTR,
                calpwstr: CALPWSTR,
                capropvar: CAPROPVARIANT,
                pcVal: ?PSTR,
                pbVal: ?*u8,
                piVal: ?*i16,
                puiVal: ?*u16,
                plVal: ?*i32,
                pulVal: ?*u32,
                pintVal: ?*i32,
                puintVal: ?*u32,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                pdecVal: ?*DECIMAL,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*PROPVARIANT,
            },
        },
        decVal: DECIMAL,
    },
};

pub const PROPSPEC = extern struct {
    ulKind: PROPSPEC_KIND,
    Anonymous: extern union {
        propid: u32,
        lpwstr: ?PWSTR,
    },
};

pub const STATPROPSTG = extern struct {
    lpwstrName: ?PWSTR,
    propid: u32,
    vt: u16,
};

pub const STATPROPSETSTG = extern struct {
    fmtid: Guid,
    clsid: Guid,
    grfFlags: u32,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyStorage_Value = Guid.initString("00000138-0000-0000-c000-000000000046");
pub const IID_IPropertyStorage = &IID_IPropertyStorage_Value;
pub const IPropertyStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]const PROPVARIANT,
                propidNameFirst: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]const PROPVARIANT,
                propidNameFirst: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]const ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                pstatpsstg: ?*STATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                pstatpsstg: ?*STATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]PROPVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec, rgpropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WriteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]const PROPVARIANT, propidNameFirst: u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WriteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec, rgpropvar, propidNameFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeleteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeleteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadPropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadPropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WritePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]const ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WritePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeletePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeletePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IPropertyStorage, @ptrCast(self)), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IPropertyStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Enum(self: *const T, ppenum: ?*?*IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertyStorage, @ptrCast(self)), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetTimes(self: *const T, pctime: ?*const FILETIME, patime: ?*const FILETIME, pmtime: ?*const FILETIME) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetTimes(@as(*const IPropertyStorage, @ptrCast(self)), pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetClass(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IPropertyStorage, @ptrCast(self)), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Stat(self: *const T, pstatpsstg: ?*STATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IPropertyStorage, @ptrCast(self)), pstatpsstg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertySetStorage_Value = Guid.initString("0000013a-0000-0000-c000-000000000046");
pub const IID_IPropertySetStorage = &IID_IPropertySetStorage_Value;
pub const IPropertySetStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                pclsid: ?*const Guid,
                grfFlags: u32,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                pclsid: ?*const Guid,
                grfFlags: u32,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Create(self: *const T, rfmtid: ?*const Guid, pclsid: ?*const Guid, grfFlags: u32, grfMode: u32, ppprstg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Create(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid, pclsid, grfFlags, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Open(self: *const T, rfmtid: ?*const Guid, grfMode: u32, ppprstg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Open(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Delete(self: *const T, rfmtid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Delete(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Enum(self: *const T, ppenum: ?*?*IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertySetStorage, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSTG_Value = Guid.initString("00000139-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSTG = &IID_IEnumSTATPROPSTG_Value;
pub const IEnumSTATPROPSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
                rgelt: [*]STATPROPSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
                rgelt: [*]STATPROPSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSETSTG_Value = Guid.initString("0000013b-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSETSTG = &IID_IEnumSTATPROPSETSTG_Value;
pub const IEnumSTATPROPSETSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
                rgelt: [*]STATPROPSETSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
                rgelt: [*]STATPROPSETSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSETSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STGOPTIONS = extern struct {
    usVersion: u16,
    reserved: u16,
    ulSectorSize: u32,
    pwcsTemplateFile: ?[*:0]const u16,
};

pub const PIDMSI_STATUS_VALUE = enum(i32) {
    NORMAL = 0,
    NEW = 1,
    PRELIM = 2,
    DRAFT = 3,
    INPROGRESS = 4,
    EDIT = 5,
    REVIEW = 6,
    PROOF = 7,
    FINAL = 8,
    OTHER = 32767,
};
pub const PIDMSI_STATUS_NORMAL = PIDMSI_STATUS_VALUE.NORMAL;
pub const PIDMSI_STATUS_NEW = PIDMSI_STATUS_VALUE.NEW;
pub const PIDMSI_STATUS_PRELIM = PIDMSI_STATUS_VALUE.PRELIM;
pub const PIDMSI_STATUS_DRAFT = PIDMSI_STATUS_VALUE.DRAFT;
pub const PIDMSI_STATUS_INPROGRESS = PIDMSI_STATUS_VALUE.INPROGRESS;
pub const PIDMSI_STATUS_EDIT = PIDMSI_STATUS_VALUE.EDIT;
pub const PIDMSI_STATUS_REVIEW = PIDMSI_STATUS_VALUE.REVIEW;
pub const PIDMSI_STATUS_PROOF = PIDMSI_STATUS_VALUE.PROOF;
pub const PIDMSI_STATUS_FINAL = PIDMSI_STATUS_VALUE.FINAL;
pub const PIDMSI_STATUS_OTHER = PIDMSI_STATUS_VALUE.OTHER;

pub const SERIALIZEDPROPERTYVALUE = extern struct {
    dwType: u32,
    rgb: [1]u8,
};

pub const PMemoryAllocator = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IPropertyBag_Value = Guid.initString("55272a00-42cb-11ce-8135-00aa004bb851");
pub const IID_IPropertyBag = &IID_IPropertyBag_Value;
pub const IPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]const u16,
                pVar: ?*VARIANT,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]const u16,
                pVar: ?*VARIANT,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]const u16,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]const u16,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Read(self: *const T, pszPropName: ?[*:0]const u16, pVar: ?*VARIANT, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag, @ptrCast(self)), pszPropName, pVar, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Write(self: *const T, pszPropName: ?[*:0]const u16, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag, @ptrCast(self)), pszPropName, pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLESTREAMVTBL = extern struct {
    Get: isize,
    Put: isize,
};

pub const OLESTREAM = extern struct {
    lpstbl: ?*OLESTREAMVTBL,
};

pub const PROPBAG2 = extern struct {
    dwType: u32,
    vt: u16,
    cfType: u16,
    dwHint: u32,
    pstrName: ?PWSTR,
    clsid: Guid,
};

const IID_IPropertyBag2_Value = Guid.initString("22f55882-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPropertyBag2 = &IID_IPropertyBag2_Value;
pub const IPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pErrLog: ?*IErrorLog,
                pvarValue: [*]VARIANT,
                phrError: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pErrLog: ?*IErrorLog,
                pvarValue: [*]VARIANT,
                phrError: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pvarValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pvarValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CountProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                iProperty: u32,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                iProperty: u32,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                pstrName: ?[*:0]const u16,
                dwHint: u32,
                pUnkObject: ?*IUnknown,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                pstrName: ?[*:0]const u16,
                dwHint: u32,
                pUnkObject: ?*IUnknown,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Read(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pErrLog: ?*IErrorLog, pvarValue: [*]VARIANT, phrError: [*]HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag2, @ptrCast(self)), cProperties, pPropBag, pErrLog, pvarValue, phrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Write(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pvarValue: [*]VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag2, @ptrCast(self)), cProperties, pPropBag, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_CountProperties(self: *const T, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).CountProperties(@as(*const IPropertyBag2, @ptrCast(self)), pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_GetPropertyInfo(self: *const T, iProperty: u32, cProperties: u32, pPropBag: [*]PROPBAG2, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IPropertyBag2, @ptrCast(self)), iProperty, cProperties, pPropBag, pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_LoadObject(self: *const T, pstrName: ?[*:0]const u16, dwHint: u32, pUnkObject: ?*IUnknown, pErrLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).LoadObject(@as(*const IPropertyBag2, @ptrCast(self)), pstrName, dwHint, pUnkObject, pErrLog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (45)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromFile(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    grfMode: u32,
    pwszName: ?PWSTR,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromIStorage(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pstg: ?*IStorage,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(
    pflb: ?*IFillLockBytes,
    grfMode: u32,
    asyncFlags: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(
    pilb: ?*ILockBytes,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnFile(
    pwcsName: ?[*:0]const u16,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dflayout" fn StgOpenLayoutDocfile(
    pwcsDfName: ?[*:0]const u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateStreamOnHGlobal(
    hGlobal: isize,
    fDeleteOnRelease: BOOL,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromStream(
    pstm: ?*IStream,
    phglobal: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterfaceAndReleaseStream(
    pStm: ?*IStream,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantCopy(
    pvarDest: ?*PROPVARIANT,
    pvarSrc: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantClear(
    pvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FreePropVariantArray(
    cVariants: u32,
    rgvars: [*]PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfile(
    pwcsName: ?[*:0]const u16,
    grfMode: STGM,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfileOnILockBytes(
    plkbyt: ?*ILockBytes,
    grfMode: STGM,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorage(
    pwcsName: ?[*:0]const u16,
    pstgPriority: ?*IStorage,
    grfMode: STGM,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageOnILockBytes(
    plkbyt: ?*ILockBytes,
    pstgPriority: ?*IStorage,
    grfMode: u32,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageFile(
    pwcsName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageILockBytes(
    plkbyt: ?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgSetTimes(
    lpszName: ?[*:0]const u16,
    pctime: ?*const FILETIME,
    patime: ?*const FILETIME,
    pmtime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateStorageEx(
    pwcsName: ?[*:0]const u16,
    grfMode: STGM,
    stgfmt: STGFMT,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    ppObjectOpen: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageEx(
    pwcsName: ?[*:0]const u16,
    grfMode: STGM,
    stgfmt: STGFMT,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    ppObjectOpen: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropStg(
    pUnk: ?*IUnknown,
    fmtid: ?*const Guid,
    pclsid: ?*const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenPropStg(
    pUnk: ?*IUnknown,
    fmtid: ?*const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropSetStg(
    pStorage: ?*IStorage,
    dwReserved: u32,
    ppPropSetStg: ?*?*IPropertySetStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FmtIdToPropStgName(
    pfmtid: ?*const Guid,
    oszName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropStgNameToFmtId(
    oszName: ?[*:0]const u16,
    pfmtid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStg(
    pStg: ?*IStorage,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStg(
    pStg: ?*IStorage,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStm(
    pStm: ?*IStream,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStm(
    pStm: ?*IStream,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromILockBytes(
    plkbyt: ?*ILockBytes,
    phglobal: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateILockBytesOnHGlobal(
    hGlobal: isize,
    fDeleteOnRelease: BOOL,
    pplkbyt: ?*?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetConvertStg(
    pStg: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertVariantToProperty(
    pvar: ?*const PROPVARIANT,
    CodePage: u16,
    // TODO: what to do with BytesParamIndex 3?
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
    pid: u32,
    fReserved: BOOLEAN,
    pcIndirect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*SERIALIZEDPROPERTYVALUE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertPropertyToVariant(
    pprop: ?*const SERIALIZEDPROPERTYVALUE,
    CodePage: u16,
    pvar: ?*PROPVARIANT,
    pma: ?*PMemoryAllocator,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgPropertyLengthAsVariant(
    // TODO: what to do with BytesParamIndex 1?
    pProp: ?*const SERIALIZEDPROPERTYVALUE,
    cbProp: u32,
    CodePage: u16,
    bReserved: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteFmtUserTypeStg(
    pstg: ?*IStorage,
    cf: u16,
    lpszUserType: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadFmtUserTypeStg(
    pstg: ?*IStorage,
    pcf: ?*u16,
    lplpszUserType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(
    lpolestream: ?*OLESTREAM,
    pstg: ?*IStorage,
    ptd: ?*const DVTARGETDEVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(
    pstg: ?*IStorage,
    lpolestream: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn SetConvertStg(
    pStg: ?*IStorage,
    fConvert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(
    pstg: ?*IStorage,
    cfFormat: u16,
    lWidth: i32,
    lHeight: i32,
    dwSize: u32,
    pmedium: ?*STGMEDIUM,
    polestm: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(
    polestm: ?*OLESTREAM,
    pstg: ?*IStorage,
    pcfFormat: ?*u16,
    plwWidth: ?*i32,
    plHeight: ?*i32,
    pdwSize: ?*u32,
    pmedium: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgSerializePropVariant(
    ppropvar: ?*const PROPVARIANT,
    ppProp: ?*?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgDeserializePropVariant(
    pprop: ?*const SERIALIZEDPROPERTYVALUE,
    cbMax: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (29)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BLOB = @import("../../system/com.zig").BLOB;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const CLSCTX = @import("../../system/com.zig").CLSCTX;
const COSERVERINFO = @import("../../system/com.zig").COSERVERINFO;
const CY = @import("../../system/com.zig").CY;
const DECIMAL = @import("../../foundation.zig").DECIMAL;
const DVTARGETDEVICE = @import("../../system/com.zig").DVTARGETDEVICE;
const FILETIME = @import("../../foundation.zig").FILETIME;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IErrorLog = @import("../../system/com.zig").IErrorLog;
const IPersist = @import("../../system/com.zig").IPersist;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../../foundation.zig").LARGE_INTEGER;
const MULTI_QI = @import("../../system/com.zig").MULTI_QI;
const PSECURITY_DESCRIPTOR = @import("../../security.zig").PSECURITY_DESCRIPTOR;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const SAFEARRAY = @import("../../system/com.zig").SAFEARRAY;
const STATSTG = @import("../../system/com.zig").STATSTG;
const STGMEDIUM = @import("../../system/com.zig").STGMEDIUM;
const StorageLayout = @import("../../system/com.zig").StorageLayout;
const ULARGE_INTEGER = @import("../../foundation.zig").ULARGE_INTEGER;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
