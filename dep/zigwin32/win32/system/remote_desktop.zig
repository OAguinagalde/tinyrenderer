//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (260)
//--------------------------------------------------------------------------------
pub const WTS_DOMAIN_LENGTH = @as(u32, 255);
pub const WTS_USERNAME_LENGTH = @as(u32, 255);
pub const WTS_PASSWORD_LENGTH = @as(u32, 255);
pub const WTS_DIRECTORY_LENGTH = @as(u32, 256);
pub const WTS_INITIALPROGRAM_LENGTH = @as(u32, 256);
pub const WTS_PROTOCOL_NAME_LENGTH = @as(u32, 8);
pub const WTS_DRIVER_NAME_LENGTH = @as(u32, 8);
pub const WTS_DEVICE_NAME_LENGTH = @as(u32, 19);
pub const WTS_IMEFILENAME_LENGTH = @as(u32, 32);
pub const WTS_CLIENTNAME_LENGTH = @as(u32, 20);
pub const WTS_CLIENTADDRESS_LENGTH = @as(u32, 30);
pub const WTS_CLIENT_PRODUCT_ID_LENGTH = @as(u32, 32);
pub const WTS_MAX_PROTOCOL_CACHE = @as(u32, 4);
pub const WTS_MAX_CACHE_RESERVED = @as(u32, 20);
pub const WTS_MAX_RESERVED = @as(u32, 100);
pub const WTS_MAX_COUNTERS = @as(u32, 100);
pub const WTS_MAX_DISPLAY_IOCTL_DATA = @as(u32, 256);
pub const WTS_PERF_DISABLE_NOTHING = @as(u32, 0);
pub const WTS_PERF_DISABLE_WALLPAPER = @as(u32, 1);
pub const WTS_PERF_DISABLE_FULLWINDOWDRAG = @as(u32, 2);
pub const WTS_PERF_DISABLE_MENUANIMATIONS = @as(u32, 4);
pub const WTS_PERF_DISABLE_THEMING = @as(u32, 8);
pub const WTS_PERF_ENABLE_ENHANCED_GRAPHICS = @as(u32, 16);
pub const WTS_PERF_DISABLE_CURSOR_SHADOW = @as(u32, 32);
pub const WTS_PERF_DISABLE_CURSORSETTINGS = @as(u32, 64);
pub const WTS_PERF_ENABLE_FONT_SMOOTHING = @as(u32, 128);
pub const WTS_PERF_ENABLE_DESKTOP_COMPOSITION = @as(u32, 256);
pub const WTS_VALUE_TYPE_ULONG = @as(u32, 1);
pub const WTS_VALUE_TYPE_STRING = @as(u32, 2);
pub const WTS_VALUE_TYPE_BINARY = @as(u32, 3);
pub const WTS_VALUE_TYPE_GUID = @as(u32, 4);
pub const WTS_KEY_EXCHANGE_ALG_RSA = @as(u32, 1);
pub const WTS_KEY_EXCHANGE_ALG_DH = @as(u32, 2);
pub const WTS_LICENSE_PROTOCOL_VERSION = @as(u32, 65536);
pub const WTS_LICENSE_PREAMBLE_VERSION = @as(u32, 3);
pub const WRDS_DOMAIN_LENGTH = @as(u32, 255);
pub const WRDS_USERNAME_LENGTH = @as(u32, 255);
pub const WRDS_PASSWORD_LENGTH = @as(u32, 255);
pub const WRDS_DIRECTORY_LENGTH = @as(u32, 256);
pub const WRDS_INITIALPROGRAM_LENGTH = @as(u32, 256);
pub const WRDS_PROTOCOL_NAME_LENGTH = @as(u32, 8);
pub const WRDS_DRIVER_NAME_LENGTH = @as(u32, 8);
pub const WRDS_DEVICE_NAME_LENGTH = @as(u32, 19);
pub const WRDS_IMEFILENAME_LENGTH = @as(u32, 32);
pub const WRDS_CLIENTNAME_LENGTH = @as(u32, 20);
pub const WRDS_CLIENTADDRESS_LENGTH = @as(u32, 30);
pub const WRDS_CLIENT_PRODUCT_ID_LENGTH = @as(u32, 32);
pub const WRDS_MAX_PROTOCOL_CACHE = @as(u32, 4);
pub const WRDS_MAX_CACHE_RESERVED = @as(u32, 20);
pub const WRDS_MAX_RESERVED = @as(u32, 100);
pub const WRDS_MAX_COUNTERS = @as(u32, 100);
pub const WRDS_MAX_DISPLAY_IOCTL_DATA = @as(u32, 256);
pub const WRDS_PERF_DISABLE_NOTHING = @as(u32, 0);
pub const WRDS_PERF_DISABLE_WALLPAPER = @as(u32, 1);
pub const WRDS_PERF_DISABLE_FULLWINDOWDRAG = @as(u32, 2);
pub const WRDS_PERF_DISABLE_MENUANIMATIONS = @as(u32, 4);
pub const WRDS_PERF_DISABLE_THEMING = @as(u32, 8);
pub const WRDS_PERF_ENABLE_ENHANCED_GRAPHICS = @as(u32, 16);
pub const WRDS_PERF_DISABLE_CURSOR_SHADOW = @as(u32, 32);
pub const WRDS_PERF_DISABLE_CURSORSETTINGS = @as(u32, 64);
pub const WRDS_PERF_ENABLE_FONT_SMOOTHING = @as(u32, 128);
pub const WRDS_PERF_ENABLE_DESKTOP_COMPOSITION = @as(u32, 256);
pub const WRDS_VALUE_TYPE_ULONG = @as(u32, 1);
pub const WRDS_VALUE_TYPE_STRING = @as(u32, 2);
pub const WRDS_VALUE_TYPE_BINARY = @as(u32, 3);
pub const WRDS_VALUE_TYPE_GUID = @as(u32, 4);
pub const WRDS_KEY_EXCHANGE_ALG_RSA = @as(u32, 1);
pub const WRDS_KEY_EXCHANGE_ALG_DH = @as(u32, 2);
pub const WRDS_LICENSE_PROTOCOL_VERSION = @as(u32, 65536);
pub const WRDS_LICENSE_PREAMBLE_VERSION = @as(u32, 3);
pub const SINGLE_SESSION = @as(u32, 1);
pub const FORCE_REJOIN = @as(u32, 2);
pub const FORCE_REJOIN_IN_CLUSTERMODE = @as(u32, 3);
pub const RESERVED_FOR_LEGACY = @as(u32, 4);
pub const KEEP_EXISTING_SESSIONS = @as(u32, 8);
pub const CHANNEL_EVENT_INITIALIZED = @as(u32, 0);
pub const CHANNEL_EVENT_CONNECTED = @as(u32, 1);
pub const CHANNEL_EVENT_V1_CONNECTED = @as(u32, 2);
pub const CHANNEL_EVENT_DISCONNECTED = @as(u32, 3);
pub const CHANNEL_EVENT_TERMINATED = @as(u32, 4);
pub const CHANNEL_EVENT_DATA_RECEIVED = @as(u32, 10);
pub const CHANNEL_EVENT_WRITE_COMPLETE = @as(u32, 11);
pub const CHANNEL_EVENT_WRITE_CANCELLED = @as(u32, 12);
pub const CHANNEL_RC_OK = @as(u32, 0);
pub const CHANNEL_RC_ALREADY_INITIALIZED = @as(u32, 1);
pub const CHANNEL_RC_NOT_INITIALIZED = @as(u32, 2);
pub const CHANNEL_RC_ALREADY_CONNECTED = @as(u32, 3);
pub const CHANNEL_RC_NOT_CONNECTED = @as(u32, 4);
pub const CHANNEL_RC_TOO_MANY_CHANNELS = @as(u32, 5);
pub const CHANNEL_RC_BAD_CHANNEL = @as(u32, 6);
pub const CHANNEL_RC_BAD_CHANNEL_HANDLE = @as(u32, 7);
pub const CHANNEL_RC_NO_BUFFER = @as(u32, 8);
pub const CHANNEL_RC_BAD_INIT_HANDLE = @as(u32, 9);
pub const CHANNEL_RC_NOT_OPEN = @as(u32, 10);
pub const CHANNEL_RC_BAD_PROC = @as(u32, 11);
pub const CHANNEL_RC_NO_MEMORY = @as(u32, 12);
pub const CHANNEL_RC_UNKNOWN_CHANNEL_NAME = @as(u32, 13);
pub const CHANNEL_RC_ALREADY_OPEN = @as(u32, 14);
pub const CHANNEL_RC_NOT_IN_VIRTUALCHANNELENTRY = @as(u32, 15);
pub const CHANNEL_RC_NULL_DATA = @as(u32, 16);
pub const CHANNEL_RC_ZERO_LENGTH = @as(u32, 17);
pub const CHANNEL_RC_INVALID_INSTANCE = @as(u32, 18);
pub const CHANNEL_RC_UNSUPPORTED_VERSION = @as(u32, 19);
pub const CHANNEL_RC_INITIALIZATION_ERROR = @as(u32, 20);
pub const VIRTUAL_CHANNEL_VERSION_WIN2000 = @as(u32, 1);
pub const CHANNEL_CHUNK_LENGTH = @as(u32, 1600);
pub const CHANNEL_BUFFER_SIZE = @as(u32, 65535);
pub const CHANNEL_FLAG_FIRST = @as(u32, 1);
pub const CHANNEL_FLAG_LAST = @as(u32, 2);
pub const CHANNEL_FLAG_MIDDLE = @as(u32, 0);
pub const CHANNEL_FLAG_FAIL = @as(u32, 256);
pub const CHANNEL_OPTION_INITIALIZED = @as(u32, 2147483648);
pub const CHANNEL_OPTION_ENCRYPT_RDP = @as(u32, 1073741824);
pub const CHANNEL_OPTION_ENCRYPT_SC = @as(u32, 536870912);
pub const CHANNEL_OPTION_ENCRYPT_CS = @as(u32, 268435456);
pub const CHANNEL_OPTION_PRI_HIGH = @as(u32, 134217728);
pub const CHANNEL_OPTION_PRI_MED = @as(u32, 67108864);
pub const CHANNEL_OPTION_PRI_LOW = @as(u32, 33554432);
pub const CHANNEL_OPTION_COMPRESS_RDP = @as(u32, 8388608);
pub const CHANNEL_OPTION_COMPRESS = @as(u32, 4194304);
pub const CHANNEL_OPTION_SHOW_PROTOCOL = @as(u32, 2097152);
pub const CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT = @as(u32, 1048576);
pub const CHANNEL_MAX_COUNT = @as(u32, 30);
pub const CHANNEL_NAME_LEN = @as(u32, 7);
pub const MAX_POLICY_ATTRIBUTES = @as(u32, 20);
pub const WTS_CURRENT_SESSION = @as(u32, 4294967295);
pub const USERNAME_LENGTH = @as(u32, 20);
pub const CLIENTNAME_LENGTH = @as(u32, 20);
pub const CLIENTADDRESS_LENGTH = @as(u32, 30);
pub const WTS_WSD_LOGOFF = @as(u32, 1);
pub const WTS_WSD_SHUTDOWN = @as(u32, 2);
pub const WTS_WSD_REBOOT = @as(u32, 4);
pub const WTS_WSD_POWEROFF = @as(u32, 8);
pub const WTS_WSD_FASTREBOOT = @as(u32, 16);
pub const MAX_ELAPSED_TIME_LENGTH = @as(u32, 15);
pub const MAX_DATE_TIME_LENGTH = @as(u32, 56);
pub const WINSTATIONNAME_LENGTH = @as(u32, 32);
pub const DOMAIN_LENGTH = @as(u32, 17);
pub const WTS_DRIVE_LENGTH = @as(u32, 3);
pub const WTS_LISTENER_NAME_LENGTH = @as(u32, 32);
pub const WTS_COMMENT_LENGTH = @as(u32, 60);
pub const WTS_LISTENER_CREATE = @as(u32, 1);
pub const WTS_LISTENER_UPDATE = @as(u32, 16);
pub const WTS_SECURITY_QUERY_INFORMATION = @as(u32, 1);
pub const WTS_SECURITY_SET_INFORMATION = @as(u32, 2);
pub const WTS_SECURITY_RESET = @as(u32, 4);
pub const WTS_SECURITY_VIRTUAL_CHANNELS = @as(u32, 8);
pub const WTS_SECURITY_REMOTE_CONTROL = @as(u32, 16);
pub const WTS_SECURITY_LOGON = @as(u32, 32);
pub const WTS_SECURITY_LOGOFF = @as(u32, 64);
pub const WTS_SECURITY_MESSAGE = @as(u32, 128);
pub const WTS_SECURITY_CONNECT = @as(u32, 256);
pub const WTS_SECURITY_DISCONNECT = @as(u32, 512);
pub const WTS_SECURITY_GUEST_ACCESS = @as(u32, 32);
pub const WTS_PROTOCOL_TYPE_CONSOLE = @as(u32, 0);
pub const WTS_PROTOCOL_TYPE_ICA = @as(u32, 1);
pub const WTS_PROTOCOL_TYPE_RDP = @as(u32, 2);
pub const WTS_SESSIONSTATE_UNKNOWN = @as(u32, 4294967295);
pub const WTS_SESSIONSTATE_LOCK = @as(u32, 0);
pub const WTS_SESSIONSTATE_UNLOCK = @as(u32, 1);
pub const PRODUCTINFO_COMPANYNAME_LENGTH = @as(u32, 256);
pub const PRODUCTINFO_PRODUCTID_LENGTH = @as(u32, 4);
pub const VALIDATIONINFORMATION_LICENSE_LENGTH = @as(u32, 16384);
pub const VALIDATIONINFORMATION_HARDWAREID_LENGTH = @as(u32, 20);
pub const WTS_EVENT_NONE = @as(u32, 0);
pub const WTS_EVENT_CREATE = @as(u32, 1);
pub const WTS_EVENT_DELETE = @as(u32, 2);
pub const WTS_EVENT_RENAME = @as(u32, 4);
pub const WTS_EVENT_CONNECT = @as(u32, 8);
pub const WTS_EVENT_DISCONNECT = @as(u32, 16);
pub const WTS_EVENT_LOGON = @as(u32, 32);
pub const WTS_EVENT_LOGOFF = @as(u32, 64);
pub const WTS_EVENT_STATECHANGE = @as(u32, 128);
pub const WTS_EVENT_LICENSE = @as(u32, 256);
pub const WTS_EVENT_ALL = @as(u32, 2147483647);
pub const WTS_EVENT_FLUSH = @as(u32, 2147483648);
pub const REMOTECONTROL_KBDSHIFT_HOTKEY = @as(u32, 1);
pub const REMOTECONTROL_KBDCTRL_HOTKEY = @as(u32, 2);
pub const REMOTECONTROL_KBDALT_HOTKEY = @as(u32, 4);
pub const WTS_CHANNEL_OPTION_DYNAMIC = @as(u32, 1);
pub const WTS_CHANNEL_OPTION_DYNAMIC_PRI_LOW = @as(u32, 0);
pub const WTS_CHANNEL_OPTION_DYNAMIC_PRI_MED = @as(u32, 2);
pub const WTS_CHANNEL_OPTION_DYNAMIC_PRI_HIGH = @as(u32, 4);
pub const WTS_CHANNEL_OPTION_DYNAMIC_PRI_REAL = @as(u32, 6);
pub const WTS_CHANNEL_OPTION_DYNAMIC_NO_COMPRESS = @as(u32, 8);
pub const NOTIFY_FOR_ALL_SESSIONS = @as(u32, 1);
pub const NOTIFY_FOR_THIS_SESSION = @as(u32, 0);
pub const WTS_PROCESS_INFO_LEVEL_0 = @as(u32, 0);
pub const WTS_PROCESS_INFO_LEVEL_1 = @as(u32, 1);
pub const PLUGIN_CAPABILITY_EXTERNAL_REDIRECTION = @as(u32, 1);
pub const MaxFQDN_Len = @as(u32, 256);
pub const MaxNetBiosName_Len = @as(u32, 16);
pub const MaxNumOfExposed_IPs = @as(u32, 12);
pub const MaxUserName_Len = @as(u32, 104);
pub const MaxDomainName_Len = @as(u32, 256);
pub const MaxFarm_Len = @as(u32, 256);
pub const MaxAppName_Len = @as(u32, 256);
pub const WKS_FLAG_CLEAR_CREDS_ON_LAST_RESOURCE = @as(u32, 1);
pub const WKS_FLAG_PASSWORD_ENCRYPTED = @as(u32, 2);
pub const WKS_FLAG_CREDS_AUTHENTICATED = @as(u32, 4);
pub const SB_SYNCH_CONFLICT_MAX_WRITE_ATTEMPTS = @as(u32, 100);
pub const ACQUIRE_TARGET_LOCK_TIMEOUT = @as(u32, 300000);
pub const RENDER_HINT_CLEAR = @as(u32, 0);
pub const RENDER_HINT_VIDEO = @as(u32, 1);
pub const RENDER_HINT_MAPPEDWINDOW = @as(u32, 2);
pub const WTS_PROPERTY_DEFAULT_CONFIG = "DefaultConfig";
pub const TS_VC_LISTENER_STATIC_CHANNEL = @as(u32, 1);
pub const WRdsGraphicsChannels_LossyChannelMaxMessageSize = @as(u32, 988);
pub const RFX_RDP_MSG_PREFIX = @as(u32, 0);
pub const RFX_GFX_MSG_PREFIX = @as(u32, 48);
pub const RFX_GFX_MSG_PREFIX_MASK = @as(u32, 48);
pub const RFX_GFX_MAX_SUPPORTED_MONITORS = @as(u32, 16);
pub const RFX_CLIENT_ID_LENGTH = @as(u32, 32);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_CONNECT = @as(u32, 701);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_DISCONNECT = @as(u32, 702);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_RECONNECT = @as(u32, 703);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_DELETE_SAVED_CREDENTIALS = @as(u32, 704);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_UPDATE_SESSION_DISPLAYSETTINGS = @as(u32, 705);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_ATTACH_EVENT = @as(u32, 706);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_DETACH_EVENT = @as(u32, 707);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_SETTINGS = @as(u32, 710);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_ACTIONS = @as(u32, 711);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_TOUCH_POINTER = @as(u32, 712);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_SET_RDPPROPERTY = @as(u32, 720);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_GET_RDPPROPERTY = @as(u32, 721);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_APPLY_SETTINGS = @as(u32, 722);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_RETRIEVE_SETTINGS = @as(u32, 723);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_SUSPEND_SCREEN_UPDATES = @as(u32, 730);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_RESUME_SCREEN_UPDATES = @as(u32, 731);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_EXECUTE_REMOTE_ACTION = @as(u32, 732);
pub const DISPID_METHOD_REMOTEDESKTOPCLIENT_GET_SNAPSHOT = @as(u32, 733);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_TOUCHPOINTER_ENABLED = @as(u32, 740);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_TOUCHPOINTER_EVENTSENABLED = @as(u32, 741);
pub const DISPID_PROP_REMOTEDESKTOPCLIENT_TOUCHPOINTER_POINTERSPEED = @as(u32, 742);
pub const DISPID_AX_CONNECTING = @as(u32, 750);
pub const DISPID_AX_CONNECTED = @as(u32, 751);
pub const DISPID_AX_LOGINCOMPLETED = @as(u32, 752);
pub const DISPID_AX_DISCONNECTED = @as(u32, 753);
pub const DISPID_AX_STATUSCHANGED = @as(u32, 754);
pub const DISPID_AX_AUTORECONNECTING = @as(u32, 755);
pub const DISPID_AX_AUTORECONNECTED = @as(u32, 756);
pub const DISPID_AX_DIALOGDISPLAYING = @as(u32, 757);
pub const DISPID_AX_DIALOGDISMISSED = @as(u32, 758);
pub const DISPID_AX_NETWORKSTATUSCHANGED = @as(u32, 759);
pub const DISPID_AX_ADMINMESSAGERECEIVED = @as(u32, 760);
pub const DISPID_AX_KEYCOMBINATIONPRESSED = @as(u32, 761);
pub const DISPID_AX_REMOTEDESKTOPSIZECHANGED = @as(u32, 762);
pub const DISPID_AX_TOUCHPOINTERCURSORMOVED = @as(u32, 800);
pub const RDCLIENT_BITMAP_RENDER_SERVICE = Guid.initString("e4cc08cb-942e-4b19-8504-bd5a89a747f5");
pub const WTS_QUERY_ALLOWED_INITIAL_APP = Guid.initString("c77d1b30-5be1-4c6b-a0e1-bd6d2e5c9fcc");
pub const WTS_QUERY_LOGON_SCREEN_SIZE = Guid.initString("8b8e0fe7-0804-4a0e-b279-8660b1df0049");
pub const WTS_QUERY_AUDIOENUM_DLL = Guid.initString("9bf4fa97-c883-4c2a-80ab-5a39c9af00db");
pub const WTS_QUERY_MF_FORMAT_SUPPORT = Guid.initString("41869ad0-6332-4dc8-95d5-db749e2f1d94");
pub const WRDS_SERVICE_ID_GRAPHICS_GUID = Guid.initString("d2993f4d-02cf-4280-8c48-1624b44f8706");
pub const PROPERTY_DYNAMIC_TIME_ZONE_INFORMATION = Guid.initString("0cdfd28e-d0b9-4c1f-a5eb-6d1f6c6535b9");
pub const PROPERTY_TYPE_GET_FAST_RECONNECT = Guid.initString("6212d757-0043-4862-99c3-9f3059ac2a3b");
pub const PROPERTY_TYPE_GET_FAST_RECONNECT_USER_SID = Guid.initString("197c427a-0135-4b6d-9c5e-e6579a0ab625");
pub const PROPERTY_TYPE_ENABLE_UNIVERSAL_APPS_FOR_CUSTOM_SHELL = Guid.initString("ed2c3fda-338d-4d3f-81a3-e767310d908e");
pub const CONNECTION_PROPERTY_IDLE_TIME_WARNING = Guid.initString("693f7ff5-0c4e-4d17-b8e0-1f70325e5d58");
pub const CONNECTION_PROPERTY_CURSOR_BLINK_DISABLED = Guid.initString("4b150580-fea4-4d3c-9de4-7433a66618f7");

//--------------------------------------------------------------------------------
// Section: Types (254)
//--------------------------------------------------------------------------------
pub const AE_POSITION_FLAGS = enum(i32) {
    INVALID = 0,
    DISCONTINUOUS = 1,
    CONTINUOUS = 2,
    QPC_ERROR = 4,
};
pub const POSITION_INVALID = AE_POSITION_FLAGS.INVALID;
pub const POSITION_DISCONTINUOUS = AE_POSITION_FLAGS.DISCONTINUOUS;
pub const POSITION_CONTINUOUS = AE_POSITION_FLAGS.CONTINUOUS;
pub const POSITION_QPC_ERROR = AE_POSITION_FLAGS.QPC_ERROR;

pub const AE_CURRENT_POSITION = extern struct {
    u64DevicePosition: u64,
    u64StreamPosition: u64,
    u64PaddingFrames: u64,
    hnsQPCPosition: i64,
    f32FramesPerSecond: f32,
    Flag: AE_POSITION_FLAGS,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpoint_Value = Guid.initString("30a99515-1527-4451-af9f-00c5f0234daf");
pub const IID_IAudioEndpoint = &IID_IAudioEndpoint_Value;
pub const IAudioEndpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpoint,
                ppFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpoint,
                ppFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFramesPerPacket: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpoint,
                pFramesPerPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpoint,
                pFramesPerPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpoint,
                pLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpoint,
                pLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpoint,
                streamFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpoint,
                streamFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpoint,
                eventHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpoint,
                eventHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpoint_GetFrameFormat(self: *const T, ppFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpoint.VTable, @ptrCast(self.vtable)).GetFrameFormat(@as(*const IAudioEndpoint, @ptrCast(self)), ppFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpoint_GetFramesPerPacket(self: *const T, pFramesPerPacket: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpoint.VTable, @ptrCast(self.vtable)).GetFramesPerPacket(@as(*const IAudioEndpoint, @ptrCast(self)), pFramesPerPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpoint_GetLatency(self: *const T, pLatency: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpoint.VTable, @ptrCast(self.vtable)).GetLatency(@as(*const IAudioEndpoint, @ptrCast(self)), pLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpoint_SetStreamFlags(self: *const T, streamFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpoint.VTable, @ptrCast(self.vtable)).SetStreamFlags(@as(*const IAudioEndpoint, @ptrCast(self)), streamFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpoint_SetEventHandle(self: *const T, eventHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpoint.VTable, @ptrCast(self.vtable)).SetEventHandle(@as(*const IAudioEndpoint, @ptrCast(self)), eventHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointRT_Value = Guid.initString("dfd2005f-a6e5-4d39-a265-939ada9fbb4d");
pub const IID_IAudioEndpointRT = &IID_IAudioEndpointRT_Value;
pub const IAudioEndpointRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentPadding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointRT,
                pPadding: ?*i64,
                pAeCurrentPosition: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioEndpointRT,
                pPadding: ?*i64,
                pAeCurrentPosition: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ProcessingComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPinInactive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPinActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointRT_GetCurrentPadding(self: *const T, pPadding: ?*i64, pAeCurrentPosition: ?*AE_CURRENT_POSITION) callconv(.Inline) void {
            return @as(*const IAudioEndpointRT.VTable, @ptrCast(self.vtable)).GetCurrentPadding(@as(*const IAudioEndpointRT, @ptrCast(self)), pPadding, pAeCurrentPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointRT_ProcessingComplete(self: *const T) callconv(.Inline) void {
            return @as(*const IAudioEndpointRT.VTable, @ptrCast(self.vtable)).ProcessingComplete(@as(*const IAudioEndpointRT, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointRT_SetPinInactive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointRT.VTable, @ptrCast(self.vtable)).SetPinInactive(@as(*const IAudioEndpointRT, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointRT_SetPinActive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointRT.VTable, @ptrCast(self.vtable)).SetPinActive(@as(*const IAudioEndpointRT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioInputEndpointRT_Value = Guid.initString("8026ab61-92b2-43c1-a1df-5c37ebd08d82");
pub const IID_IAudioInputEndpointRT = &IID_IAudioInputEndpointRT_Value;
pub const IAudioInputEndpointRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputDataPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioInputEndpointRT,
                pConnectionProperty: ?*APO_CONNECTION_PROPERTY,
                pAeTimeStamp: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioInputEndpointRT,
                pConnectionProperty: ?*APO_CONNECTION_PROPERTY,
                pAeTimeStamp: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ReleaseInputDataPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioInputEndpointRT,
                u32FrameCount: u32,
                pDataPointer: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioInputEndpointRT,
                u32FrameCount: u32,
                pDataPointer: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PulseEndpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioInputEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioInputEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioInputEndpointRT_GetInputDataPointer(self: *const T, pConnectionProperty: ?*APO_CONNECTION_PROPERTY, pAeTimeStamp: ?*AE_CURRENT_POSITION) callconv(.Inline) void {
            return @as(*const IAudioInputEndpointRT.VTable, @ptrCast(self.vtable)).GetInputDataPointer(@as(*const IAudioInputEndpointRT, @ptrCast(self)), pConnectionProperty, pAeTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioInputEndpointRT_ReleaseInputDataPointer(self: *const T, u32FrameCount: u32, pDataPointer: usize) callconv(.Inline) void {
            return @as(*const IAudioInputEndpointRT.VTable, @ptrCast(self.vtable)).ReleaseInputDataPointer(@as(*const IAudioInputEndpointRT, @ptrCast(self)), u32FrameCount, pDataPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioInputEndpointRT_PulseEndpoint(self: *const T) callconv(.Inline) void {
            return @as(*const IAudioInputEndpointRT.VTable, @ptrCast(self.vtable)).PulseEndpoint(@as(*const IAudioInputEndpointRT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioOutputEndpointRT_Value = Guid.initString("8fa906e4-c31c-4e31-932e-19a66385e9aa");
pub const IID_IAudioOutputEndpointRT = &IID_IAudioOutputEndpointRT_Value;
pub const IAudioOutputEndpointRT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOutputDataPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioOutputEndpointRT,
                u32FrameCount: u32,
                pAeTimeStamp: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn(
                self: *const IAudioOutputEndpointRT,
                u32FrameCount: u32,
                pAeTimeStamp: ?*AE_CURRENT_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        ReleaseOutputDataPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioOutputEndpointRT,
                pConnectionProperty: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioOutputEndpointRT,
                pConnectionProperty: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PulseEndpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioOutputEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioOutputEndpointRT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioOutputEndpointRT_GetOutputDataPointer(self: *const T, u32FrameCount: u32, pAeTimeStamp: ?*AE_CURRENT_POSITION) callconv(.Inline) usize {
            return @as(*const IAudioOutputEndpointRT.VTable, @ptrCast(self.vtable)).GetOutputDataPointer(@as(*const IAudioOutputEndpointRT, @ptrCast(self)), u32FrameCount, pAeTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioOutputEndpointRT_ReleaseOutputDataPointer(self: *const T, pConnectionProperty: ?*const APO_CONNECTION_PROPERTY) callconv(.Inline) void {
            return @as(*const IAudioOutputEndpointRT.VTable, @ptrCast(self.vtable)).ReleaseOutputDataPointer(@as(*const IAudioOutputEndpointRT, @ptrCast(self)), pConnectionProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioOutputEndpointRT_PulseEndpoint(self: *const T) callconv(.Inline) void {
            return @as(*const IAudioOutputEndpointRT.VTable, @ptrCast(self.vtable)).PulseEndpoint(@as(*const IAudioOutputEndpointRT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioDeviceEndpoint_Value = Guid.initString("d4952f5a-a0b2-4cc4-8b82-9358488dd8ac");
pub const IID_IAudioDeviceEndpoint = &IID_IAudioDeviceEndpoint_Value;
pub const IAudioDeviceEndpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioDeviceEndpoint,
                MaxPeriod: i64,
                u32LatencyCoefficient: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioDeviceEndpoint,
                MaxPeriod: i64,
                u32LatencyCoefficient: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRTCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioDeviceEndpoint,
                pbIsRTCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioDeviceEndpoint,
                pbIsRTCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventDrivenCapable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioDeviceEndpoint,
                pbisEventCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioDeviceEndpoint,
                pbisEventCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteExclusiveModeParametersToSharedMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioDeviceEndpoint,
                hTargetProcess: usize,
                hnsPeriod: i64,
                hnsBufferDuration: i64,
                u32LatencyCoefficient: u32,
                pu32SharedMemorySize: ?*u32,
                phSharedMemory: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioDeviceEndpoint,
                hTargetProcess: usize,
                hnsPeriod: i64,
                hnsBufferDuration: i64,
                u32LatencyCoefficient: u32,
                pu32SharedMemorySize: ?*u32,
                phSharedMemory: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioDeviceEndpoint_SetBuffer(self: *const T, MaxPeriod: i64, u32LatencyCoefficient: u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioDeviceEndpoint.VTable, @ptrCast(self.vtable)).SetBuffer(@as(*const IAudioDeviceEndpoint, @ptrCast(self)), MaxPeriod, u32LatencyCoefficient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioDeviceEndpoint_GetRTCaps(self: *const T, pbIsRTCapable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAudioDeviceEndpoint.VTable, @ptrCast(self.vtable)).GetRTCaps(@as(*const IAudioDeviceEndpoint, @ptrCast(self)), pbIsRTCapable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioDeviceEndpoint_GetEventDrivenCapable(self: *const T, pbisEventCapable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAudioDeviceEndpoint.VTable, @ptrCast(self.vtable)).GetEventDrivenCapable(@as(*const IAudioDeviceEndpoint, @ptrCast(self)), pbisEventCapable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioDeviceEndpoint_WriteExclusiveModeParametersToSharedMemory(self: *const T, hTargetProcess: usize, hnsPeriod: i64, hnsBufferDuration: i64, u32LatencyCoefficient: u32, pu32SharedMemorySize: ?*u32, phSharedMemory: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IAudioDeviceEndpoint.VTable, @ptrCast(self.vtable)).WriteExclusiveModeParametersToSharedMemory(@as(*const IAudioDeviceEndpoint, @ptrCast(self)), hTargetProcess, hnsPeriod, hnsBufferDuration, u32LatencyCoefficient, pu32SharedMemorySize, phSharedMemory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointControl_Value = Guid.initString("c684b72a-6df4-4774-bdf9-76b77509b653");
pub const IID_IAudioEndpointControl = &IID_IAudioEndpointControl_Value;
pub const IAudioEndpointControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointControl_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointControl.VTable, @ptrCast(self.vtable)).Start(@as(*const IAudioEndpointControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointControl_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointControl.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAudioEndpointControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointControl_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IAudioEndpointControl, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type has a FreeFunc 'WTSVirtualChannelClose', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HwtsVirtualChannelHandle = isize;

const CLSID_TSUserExInterfaces_Value = Guid.initString("0910dd01-df8c-11d1-ae27-00c04fa35813");
pub const CLSID_TSUserExInterfaces = &CLSID_TSUserExInterfaces_Value;

const CLSID_ADsTSUserEx_Value = Guid.initString("e2e9cae6-1e7b-4b8e-babd-e9bf6292ac29");
pub const CLSID_ADsTSUserEx = &CLSID_ADsTSUserEx_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IADsTSUserEx_Value = Guid.initString("c4930e79-2989-4462-8a60-2fcf2f2955ef");
pub const IID_IADsTSUserEx = &IID_IADsTSUserEx_Value;
pub const IADsTSUserEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalServicesProfilePath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TerminalServicesProfilePath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalServicesHomeDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TerminalServicesHomeDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalServicesHomeDrive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TerminalServicesHomeDrive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableRemoteControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableRemoteControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxDisconnectionTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxDisconnectionTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxConnectionTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxConnectionTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxIdleTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxIdleTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReconnectionAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReconnectionAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BrokenConnectionAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BrokenConnectionAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectClientDrivesAtLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectClientDrivesAtLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectClientPrintersAtLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectClientPrintersAtLogon: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultToMainPrinter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultToMainPrinter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                NewVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalServicesWorkDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TerminalServicesWorkDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TerminalServicesInitialProgram: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TerminalServicesInitialProgram: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IADsTSUserEx,
                pNewVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_TerminalServicesProfilePath(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_TerminalServicesProfilePath(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_TerminalServicesProfilePath(self: *const T, pNewVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_TerminalServicesProfilePath(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_TerminalServicesHomeDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_TerminalServicesHomeDirectory(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_TerminalServicesHomeDirectory(self: *const T, pNewVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_TerminalServicesHomeDirectory(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_TerminalServicesHomeDrive(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_TerminalServicesHomeDrive(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_TerminalServicesHomeDrive(self: *const T, pNewVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_TerminalServicesHomeDrive(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_AllowLogon(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_AllowLogon(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_AllowLogon(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_AllowLogon(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_EnableRemoteControl(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_EnableRemoteControl(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_EnableRemoteControl(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_EnableRemoteControl(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_MaxDisconnectionTime(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_MaxDisconnectionTime(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_MaxDisconnectionTime(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_MaxDisconnectionTime(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_MaxConnectionTime(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_MaxConnectionTime(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_MaxConnectionTime(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_MaxConnectionTime(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_MaxIdleTime(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_MaxIdleTime(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_MaxIdleTime(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_MaxIdleTime(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_ReconnectionAction(self: *const T, pNewVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_ReconnectionAction(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_ReconnectionAction(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_ReconnectionAction(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_BrokenConnectionAction(self: *const T, pNewVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_BrokenConnectionAction(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_BrokenConnectionAction(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_BrokenConnectionAction(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_ConnectClientDrivesAtLogon(self: *const T, pNewVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_ConnectClientDrivesAtLogon(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_ConnectClientDrivesAtLogon(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_ConnectClientDrivesAtLogon(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_ConnectClientPrintersAtLogon(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_ConnectClientPrintersAtLogon(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_ConnectClientPrintersAtLogon(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_ConnectClientPrintersAtLogon(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_DefaultToMainPrinter(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_DefaultToMainPrinter(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_DefaultToMainPrinter(self: *const T, NewVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_DefaultToMainPrinter(@as(*const IADsTSUserEx, @ptrCast(self)), NewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_TerminalServicesWorkDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_TerminalServicesWorkDirectory(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_TerminalServicesWorkDirectory(self: *const T, pNewVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_TerminalServicesWorkDirectory(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_get_TerminalServicesInitialProgram(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).get_TerminalServicesInitialProgram(@as(*const IADsTSUserEx, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADsTSUserEx_put_TerminalServicesInitialProgram(self: *const T, pNewVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IADsTSUserEx.VTable, @ptrCast(self.vtable)).put_TerminalServicesInitialProgram(@as(*const IADsTSUserEx, @ptrCast(self)), pNewVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AAAuthSchemes = enum(i32) {
    MIN = 0,
    BASIC = 1,
    NTLM = 2,
    SC = 3,
    LOGGEDONCREDENTIALS = 4,
    NEGOTIATE = 5,
    ANY = 6,
    COOKIE = 7,
    DIGEST = 8,
    ORGID = 9,
    CONID = 10,
    SSPI_NTLM = 11,
    MAX = 12,
};
pub const AA_AUTH_MIN = AAAuthSchemes.MIN;
pub const AA_AUTH_BASIC = AAAuthSchemes.BASIC;
pub const AA_AUTH_NTLM = AAAuthSchemes.NTLM;
pub const AA_AUTH_SC = AAAuthSchemes.SC;
pub const AA_AUTH_LOGGEDONCREDENTIALS = AAAuthSchemes.LOGGEDONCREDENTIALS;
pub const AA_AUTH_NEGOTIATE = AAAuthSchemes.NEGOTIATE;
pub const AA_AUTH_ANY = AAAuthSchemes.ANY;
pub const AA_AUTH_COOKIE = AAAuthSchemes.COOKIE;
pub const AA_AUTH_DIGEST = AAAuthSchemes.DIGEST;
pub const AA_AUTH_ORGID = AAAuthSchemes.ORGID;
pub const AA_AUTH_CONID = AAAuthSchemes.CONID;
pub const AA_AUTH_SSPI_NTLM = AAAuthSchemes.SSPI_NTLM;
pub const AA_AUTH_MAX = AAAuthSchemes.MAX;

pub const AAAccountingDataType = enum(i32) {
    MAIN_SESSION_CREATION = 0,
    SUB_SESSION_CREATION = 1,
    SUB_SESSION_CLOSED = 2,
    MAIN_SESSION_CLOSED = 3,
};
pub const AA_MAIN_SESSION_CREATION = AAAccountingDataType.MAIN_SESSION_CREATION;
pub const AA_SUB_SESSION_CREATION = AAAccountingDataType.SUB_SESSION_CREATION;
pub const AA_SUB_SESSION_CLOSED = AAAccountingDataType.SUB_SESSION_CLOSED;
pub const AA_MAIN_SESSION_CLOSED = AAAccountingDataType.MAIN_SESSION_CLOSED;

pub const AAAccountingData = extern struct {
    userName: ?BSTR,
    clientName: ?BSTR,
    authType: AAAuthSchemes,
    resourceName: ?BSTR,
    portNumber: i32,
    protocolName: ?BSTR,
    numberOfBytesReceived: i32,
    numberOfBytesTransfered: i32,
    reasonForDisconnect: ?BSTR,
    mainSessionId: Guid,
    subSessionId: i32,
};

pub const SESSION_TIMEOUT_ACTION_TYPE = enum(i32) {
    DISCONNECT = 0,
    SILENT_REAUTH = 1,
};
pub const SESSION_TIMEOUT_ACTION_DISCONNECT = SESSION_TIMEOUT_ACTION_TYPE.DISCONNECT;
pub const SESSION_TIMEOUT_ACTION_SILENT_REAUTH = SESSION_TIMEOUT_ACTION_TYPE.SILENT_REAUTH;

pub const PolicyAttributeType = enum(i32) {
    EnableAllRedirections = 0,
    DisableAllRedirections = 1,
    DriveRedirectionDisabled = 2,
    PrinterRedirectionDisabled = 3,
    PortRedirectionDisabled = 4,
    ClipboardRedirectionDisabled = 5,
    PnpRedirectionDisabled = 6,
    AllowOnlySDRServers = 7,
};
pub const EnableAllRedirections = PolicyAttributeType.EnableAllRedirections;
pub const DisableAllRedirections = PolicyAttributeType.DisableAllRedirections;
pub const DriveRedirectionDisabled = PolicyAttributeType.DriveRedirectionDisabled;
pub const PrinterRedirectionDisabled = PolicyAttributeType.PrinterRedirectionDisabled;
pub const PortRedirectionDisabled = PolicyAttributeType.PortRedirectionDisabled;
pub const ClipboardRedirectionDisabled = PolicyAttributeType.ClipboardRedirectionDisabled;
pub const PnpRedirectionDisabled = PolicyAttributeType.PnpRedirectionDisabled;
pub const AllowOnlySDRServers = PolicyAttributeType.AllowOnlySDRServers;

pub const AATrustClassID = enum(i32) {
    UNTRUSTED = 0,
    TRUSTEDUSER_UNTRUSTEDCLIENT = 1,
    TRUSTEDUSER_TRUSTEDCLIENT = 2,
};
pub const AA_UNTRUSTED = AATrustClassID.UNTRUSTED;
pub const AA_TRUSTEDUSER_UNTRUSTEDCLIENT = AATrustClassID.TRUSTEDUSER_UNTRUSTEDCLIENT;
pub const AA_TRUSTEDUSER_TRUSTEDCLIENT = AATrustClassID.TRUSTEDUSER_TRUSTEDCLIENT;

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGAuthorizeConnectionSink_Value = Guid.initString("c27ece33-7781-4318-98ef-1cf2da7b7005");
pub const IID_ITSGAuthorizeConnectionSink = &IID_ITSGAuthorizeConnectionSink_Value;
pub const ITSGAuthorizeConnectionSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnectionAuthorized: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthorizeConnectionSink,
                hrIn: HRESULT,
                mainSessionId: Guid,
                cbSoHResponse: u32,
                pbSoHResponse: [*:0]u8,
                idleTimeout: u32,
                sessionTimeout: u32,
                sessionTimeoutAction: SESSION_TIMEOUT_ACTION_TYPE,
                trustClass: AATrustClassID,
                policyAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthorizeConnectionSink,
                hrIn: HRESULT,
                mainSessionId: Guid,
                cbSoHResponse: u32,
                pbSoHResponse: [*:0]u8,
                idleTimeout: u32,
                sessionTimeout: u32,
                sessionTimeoutAction: SESSION_TIMEOUT_ACTION_TYPE,
                trustClass: AATrustClassID,
                policyAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthorizeConnectionSink_OnConnectionAuthorized(self: *const T, hrIn: HRESULT, mainSessionId: Guid, cbSoHResponse: u32, pbSoHResponse: [*:0]u8, idleTimeout: u32, sessionTimeout: u32, sessionTimeoutAction: SESSION_TIMEOUT_ACTION_TYPE, trustClass: AATrustClassID, policyAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthorizeConnectionSink.VTable, @ptrCast(self.vtable)).OnConnectionAuthorized(@as(*const ITSGAuthorizeConnectionSink, @ptrCast(self)), hrIn, mainSessionId, cbSoHResponse, pbSoHResponse, idleTimeout, sessionTimeout, sessionTimeoutAction, trustClass, policyAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGAuthorizeResourceSink_Value = Guid.initString("feddfcd4-fa12-4435-ae55-7ad1a9779af7");
pub const IID_ITSGAuthorizeResourceSink = &IID_ITSGAuthorizeResourceSink_Value;
pub const ITSGAuthorizeResourceSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChannelAuthorized: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthorizeResourceSink,
                hrIn: HRESULT,
                mainSessionId: Guid,
                subSessionId: i32,
                allowedResourceNames: [*]?BSTR,
                numAllowedResourceNames: u32,
                failedResourceNames: [*]?BSTR,
                numFailedResourceNames: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthorizeResourceSink,
                hrIn: HRESULT,
                mainSessionId: Guid,
                subSessionId: i32,
                allowedResourceNames: [*]?BSTR,
                numAllowedResourceNames: u32,
                failedResourceNames: [*]?BSTR,
                numFailedResourceNames: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthorizeResourceSink_OnChannelAuthorized(self: *const T, hrIn: HRESULT, mainSessionId: Guid, subSessionId: i32, allowedResourceNames: [*]?BSTR, numAllowedResourceNames: u32, failedResourceNames: [*]?BSTR, numFailedResourceNames: u32) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthorizeResourceSink.VTable, @ptrCast(self.vtable)).OnChannelAuthorized(@as(*const ITSGAuthorizeResourceSink, @ptrCast(self)), hrIn, mainSessionId, subSessionId, allowedResourceNames, numAllowedResourceNames, failedResourceNames, numFailedResourceNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGPolicyEngine_Value = Guid.initString("8bc24f08-6223-42f4-a5b4-8e37cd135bbd");
pub const IID_ITSGPolicyEngine = &IID_ITSGPolicyEngine_Value;
pub const ITSGPolicyEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AuthorizeConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGPolicyEngine,
                mainSessionId: Guid,
                username: ?BSTR,
                authType: AAAuthSchemes,
                clientMachineIP: ?BSTR,
                clientMachineName: ?BSTR,
                sohData: [*:0]u8,
                numSOHBytes: u32,
                cookieData: [*:0]u8,
                numCookieBytes: u32,
                userToken: HANDLE_PTR,
                pSink: ?*ITSGAuthorizeConnectionSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGPolicyEngine,
                mainSessionId: Guid,
                username: ?BSTR,
                authType: AAAuthSchemes,
                clientMachineIP: ?BSTR,
                clientMachineName: ?BSTR,
                sohData: [*:0]u8,
                numSOHBytes: u32,
                cookieData: [*:0]u8,
                numCookieBytes: u32,
                userToken: HANDLE_PTR,
                pSink: ?*ITSGAuthorizeConnectionSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AuthorizeResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGPolicyEngine,
                mainSessionId: Guid,
                subSessionId: i32,
                username: ?BSTR,
                resourceNames: [*]?BSTR,
                numResources: u32,
                alternateResourceNames: [*]?BSTR,
                numAlternateResourceName: u32,
                portNumber: u32,
                operation: ?BSTR,
                cookie: [*:0]u8,
                numBytesInCookie: u32,
                pSink: ?*ITSGAuthorizeResourceSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGPolicyEngine,
                mainSessionId: Guid,
                subSessionId: i32,
                username: ?BSTR,
                resourceNames: [*]?BSTR,
                numResources: u32,
                alternateResourceNames: [*]?BSTR,
                numAlternateResourceName: u32,
                portNumber: u32,
                operation: ?BSTR,
                cookie: [*:0]u8,
                numBytesInCookie: u32,
                pSink: ?*ITSGAuthorizeResourceSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGPolicyEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGPolicyEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsQuarantineEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGPolicyEngine,
                quarantineEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGPolicyEngine,
                quarantineEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGPolicyEngine_AuthorizeConnection(self: *const T, mainSessionId: Guid, username: ?BSTR, authType: AAAuthSchemes, clientMachineIP: ?BSTR, clientMachineName: ?BSTR, sohData: [*:0]u8, numSOHBytes: u32, cookieData: [*:0]u8, numCookieBytes: u32, userToken: HANDLE_PTR, pSink: ?*ITSGAuthorizeConnectionSink) callconv(.Inline) HRESULT {
            return @as(*const ITSGPolicyEngine.VTable, @ptrCast(self.vtable)).AuthorizeConnection(@as(*const ITSGPolicyEngine, @ptrCast(self)), mainSessionId, username, authType, clientMachineIP, clientMachineName, sohData, numSOHBytes, cookieData, numCookieBytes, userToken, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGPolicyEngine_AuthorizeResource(self: *const T, mainSessionId: Guid, subSessionId: i32, username: ?BSTR, resourceNames: [*]?BSTR, numResources: u32, alternateResourceNames: [*]?BSTR, numAlternateResourceName: u32, portNumber: u32, operation: ?BSTR, cookie: [*:0]u8, numBytesInCookie: u32, pSink: ?*ITSGAuthorizeResourceSink) callconv(.Inline) HRESULT {
            return @as(*const ITSGPolicyEngine.VTable, @ptrCast(self.vtable)).AuthorizeResource(@as(*const ITSGPolicyEngine, @ptrCast(self)), mainSessionId, subSessionId, username, resourceNames, numResources, alternateResourceNames, numAlternateResourceName, portNumber, operation, cookie, numBytesInCookie, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGPolicyEngine_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITSGPolicyEngine.VTable, @ptrCast(self.vtable)).Refresh(@as(*const ITSGPolicyEngine, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGPolicyEngine_IsQuarantineEnabled(self: *const T, quarantineEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITSGPolicyEngine.VTable, @ptrCast(self.vtable)).IsQuarantineEnabled(@as(*const ITSGPolicyEngine, @ptrCast(self)), quarantineEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGAccountingEngine_Value = Guid.initString("4ce2a0c9-e874-4f1a-86f4-06bbb9115338");
pub const IID_ITSGAccountingEngine = &IID_ITSGAccountingEngine_Value;
pub const ITSGAccountingEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoAccounting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAccountingEngine,
                accountingDataType: AAAccountingDataType,
                accountingData: AAAccountingData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAccountingEngine,
                accountingDataType: AAAccountingDataType,
                accountingData: AAAccountingData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAccountingEngine_DoAccounting(self: *const T, accountingDataType: AAAccountingDataType, accountingData: AAAccountingData) callconv(.Inline) HRESULT {
            return @as(*const ITSGAccountingEngine.VTable, @ptrCast(self.vtable)).DoAccounting(@as(*const ITSGAccountingEngine, @ptrCast(self)), accountingDataType, accountingData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGAuthenticateUserSink_Value = Guid.initString("2c3e2e73-a782-47f9-8dfb-77ee1ed27a03");
pub const IID_ITSGAuthenticateUserSink = &IID_ITSGAuthenticateUserSink_Value;
pub const ITSGAuthenticateUserSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUserAuthenticated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticateUserSink,
                userName: ?BSTR,
                userDomain: ?BSTR,
                context: usize,
                userToken: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticateUserSink,
                userName: ?BSTR,
                userDomain: ?BSTR,
                context: usize,
                userToken: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUserAuthenticationFailed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
                genericErrorCode: HRESULT,
                specificErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
                genericErrorCode: HRESULT,
                specificErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReauthenticateUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticateUserSink,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticateUserSink_OnUserAuthenticated(self: *const T, userName: ?BSTR, userDomain: ?BSTR, context: usize, userToken: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticateUserSink.VTable, @ptrCast(self.vtable)).OnUserAuthenticated(@as(*const ITSGAuthenticateUserSink, @ptrCast(self)), userName, userDomain, context, userToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticateUserSink_OnUserAuthenticationFailed(self: *const T, context: usize, genericErrorCode: HRESULT, specificErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticateUserSink.VTable, @ptrCast(self.vtable)).OnUserAuthenticationFailed(@as(*const ITSGAuthenticateUserSink, @ptrCast(self)), context, genericErrorCode, specificErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticateUserSink_ReauthenticateUser(self: *const T, context: usize) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticateUserSink.VTable, @ptrCast(self.vtable)).ReauthenticateUser(@as(*const ITSGAuthenticateUserSink, @ptrCast(self)), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticateUserSink_DisconnectUser(self: *const T, context: usize) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticateUserSink.VTable, @ptrCast(self.vtable)).DisconnectUser(@as(*const ITSGAuthenticateUserSink, @ptrCast(self)), context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITSGAuthenticationEngine_Value = Guid.initString("9ee3e5bf-04ab-4691-998c-d7f622321a56");
pub const IID_ITSGAuthenticationEngine = &IID_ITSGAuthenticationEngine_Value;
pub const ITSGAuthenticationEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AuthenticateUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticationEngine,
                mainSessionId: Guid,
                cookieData: ?*u8,
                numCookieBytes: u32,
                context: usize,
                pSink: ?*ITSGAuthenticateUserSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticationEngine,
                mainSessionId: Guid,
                cookieData: ?*u8,
                numCookieBytes: u32,
                context: usize,
                pSink: ?*ITSGAuthenticateUserSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAuthentication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSGAuthenticationEngine,
                mainSessionId: Guid,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSGAuthenticationEngine,
                mainSessionId: Guid,
                context: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticationEngine_AuthenticateUser(self: *const T, mainSessionId: Guid, cookieData: ?*u8, numCookieBytes: u32, context: usize, pSink: ?*ITSGAuthenticateUserSink) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticationEngine.VTable, @ptrCast(self.vtable)).AuthenticateUser(@as(*const ITSGAuthenticationEngine, @ptrCast(self)), mainSessionId, cookieData, numCookieBytes, context, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSGAuthenticationEngine_CancelAuthentication(self: *const T, mainSessionId: Guid, context: usize) callconv(.Inline) HRESULT {
            return @as(*const ITSGAuthenticationEngine.VTable, @ptrCast(self.vtable)).CancelAuthentication(@as(*const ITSGAuthenticationEngine, @ptrCast(self)), mainSessionId, context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WTS_CONNECTSTATE_CLASS = enum(i32) {
    Active = 0,
    Connected = 1,
    ConnectQuery = 2,
    Shadow = 3,
    Disconnected = 4,
    Idle = 5,
    Listen = 6,
    Reset = 7,
    Down = 8,
    Init = 9,
};
pub const WTSActive = WTS_CONNECTSTATE_CLASS.Active;
pub const WTSConnected = WTS_CONNECTSTATE_CLASS.Connected;
pub const WTSConnectQuery = WTS_CONNECTSTATE_CLASS.ConnectQuery;
pub const WTSShadow = WTS_CONNECTSTATE_CLASS.Shadow;
pub const WTSDisconnected = WTS_CONNECTSTATE_CLASS.Disconnected;
pub const WTSIdle = WTS_CONNECTSTATE_CLASS.Idle;
pub const WTSListen = WTS_CONNECTSTATE_CLASS.Listen;
pub const WTSReset = WTS_CONNECTSTATE_CLASS.Reset;
pub const WTSDown = WTS_CONNECTSTATE_CLASS.Down;
pub const WTSInit = WTS_CONNECTSTATE_CLASS.Init;

pub const WTS_SERVER_INFOW = extern struct {
    pServerName: ?PWSTR,
};

pub const WTS_SERVER_INFOA = extern struct {
    pServerName: ?PSTR,
};

pub const WTS_SESSION_INFOW = extern struct {
    SessionId: u32,
    pWinStationName: ?PWSTR,
    State: WTS_CONNECTSTATE_CLASS,
};

pub const WTS_SESSION_INFOA = extern struct {
    SessionId: u32,
    pWinStationName: ?PSTR,
    State: WTS_CONNECTSTATE_CLASS,
};

pub const WTS_SESSION_INFO_1W = extern struct {
    ExecEnvId: u32,
    State: WTS_CONNECTSTATE_CLASS,
    SessionId: u32,
    pSessionName: ?PWSTR,
    pHostName: ?PWSTR,
    pUserName: ?PWSTR,
    pDomainName: ?PWSTR,
    pFarmName: ?PWSTR,
};

pub const WTS_SESSION_INFO_1A = extern struct {
    ExecEnvId: u32,
    State: WTS_CONNECTSTATE_CLASS,
    SessionId: u32,
    pSessionName: ?PSTR,
    pHostName: ?PSTR,
    pUserName: ?PSTR,
    pDomainName: ?PSTR,
    pFarmName: ?PSTR,
};

pub const WTS_PROCESS_INFOW = extern struct {
    SessionId: u32,
    ProcessId: u32,
    pProcessName: ?PWSTR,
    pUserSid: ?PSID,
};

pub const WTS_PROCESS_INFOA = extern struct {
    SessionId: u32,
    ProcessId: u32,
    pProcessName: ?PSTR,
    pUserSid: ?PSID,
};

pub const WTS_INFO_CLASS = enum(i32) {
    InitialProgram = 0,
    ApplicationName = 1,
    WorkingDirectory = 2,
    OEMId = 3,
    SessionId = 4,
    UserName = 5,
    WinStationName = 6,
    DomainName = 7,
    ConnectState = 8,
    ClientBuildNumber = 9,
    ClientName = 10,
    ClientDirectory = 11,
    ClientProductId = 12,
    ClientHardwareId = 13,
    ClientAddress = 14,
    ClientDisplay = 15,
    ClientProtocolType = 16,
    IdleTime = 17,
    LogonTime = 18,
    IncomingBytes = 19,
    OutgoingBytes = 20,
    IncomingFrames = 21,
    OutgoingFrames = 22,
    ClientInfo = 23,
    SessionInfo = 24,
    SessionInfoEx = 25,
    ConfigInfo = 26,
    ValidationInfo = 27,
    SessionAddressV4 = 28,
    IsRemoteSession = 29,
};
pub const WTSInitialProgram = WTS_INFO_CLASS.InitialProgram;
pub const WTSApplicationName = WTS_INFO_CLASS.ApplicationName;
pub const WTSWorkingDirectory = WTS_INFO_CLASS.WorkingDirectory;
pub const WTSOEMId = WTS_INFO_CLASS.OEMId;
pub const WTSSessionId = WTS_INFO_CLASS.SessionId;
pub const WTSUserName = WTS_INFO_CLASS.UserName;
pub const WTSWinStationName = WTS_INFO_CLASS.WinStationName;
pub const WTSDomainName = WTS_INFO_CLASS.DomainName;
pub const WTSConnectState = WTS_INFO_CLASS.ConnectState;
pub const WTSClientBuildNumber = WTS_INFO_CLASS.ClientBuildNumber;
pub const WTSClientName = WTS_INFO_CLASS.ClientName;
pub const WTSClientDirectory = WTS_INFO_CLASS.ClientDirectory;
pub const WTSClientProductId = WTS_INFO_CLASS.ClientProductId;
pub const WTSClientHardwareId = WTS_INFO_CLASS.ClientHardwareId;
pub const WTSClientAddress = WTS_INFO_CLASS.ClientAddress;
pub const WTSClientDisplay = WTS_INFO_CLASS.ClientDisplay;
pub const WTSClientProtocolType = WTS_INFO_CLASS.ClientProtocolType;
pub const WTSIdleTime = WTS_INFO_CLASS.IdleTime;
pub const WTSLogonTime = WTS_INFO_CLASS.LogonTime;
pub const WTSIncomingBytes = WTS_INFO_CLASS.IncomingBytes;
pub const WTSOutgoingBytes = WTS_INFO_CLASS.OutgoingBytes;
pub const WTSIncomingFrames = WTS_INFO_CLASS.IncomingFrames;
pub const WTSOutgoingFrames = WTS_INFO_CLASS.OutgoingFrames;
pub const WTSClientInfo = WTS_INFO_CLASS.ClientInfo;
pub const WTSSessionInfo = WTS_INFO_CLASS.SessionInfo;
pub const WTSSessionInfoEx = WTS_INFO_CLASS.SessionInfoEx;
pub const WTSConfigInfo = WTS_INFO_CLASS.ConfigInfo;
pub const WTSValidationInfo = WTS_INFO_CLASS.ValidationInfo;
pub const WTSSessionAddressV4 = WTS_INFO_CLASS.SessionAddressV4;
pub const WTSIsRemoteSession = WTS_INFO_CLASS.IsRemoteSession;

pub const WTSCONFIGINFOW = extern struct {
    version: u32,
    fConnectClientDrivesAtLogon: u32,
    fConnectPrinterAtLogon: u32,
    fDisablePrinterRedirection: u32,
    fDisableDefaultMainClientPrinter: u32,
    ShadowSettings: u32,
    LogonUserName: [21]u16,
    LogonDomain: [18]u16,
    WorkDirectory: [261]u16,
    InitialProgram: [261]u16,
    ApplicationName: [261]u16,
};

pub const WTSCONFIGINFOA = extern struct {
    version: u32,
    fConnectClientDrivesAtLogon: u32,
    fConnectPrinterAtLogon: u32,
    fDisablePrinterRedirection: u32,
    fDisableDefaultMainClientPrinter: u32,
    ShadowSettings: u32,
    LogonUserName: [21]CHAR,
    LogonDomain: [18]CHAR,
    WorkDirectory: [261]CHAR,
    InitialProgram: [261]CHAR,
    ApplicationName: [261]CHAR,
};

pub const WTSINFOW = extern struct {
    State: WTS_CONNECTSTATE_CLASS,
    SessionId: u32,
    IncomingBytes: u32,
    OutgoingBytes: u32,
    IncomingFrames: u32,
    OutgoingFrames: u32,
    IncomingCompressedBytes: u32,
    OutgoingCompressedBytes: u32,
    WinStationName: [32]u16,
    Domain: [17]u16,
    UserName: [21]u16,
    ConnectTime: LARGE_INTEGER,
    DisconnectTime: LARGE_INTEGER,
    LastInputTime: LARGE_INTEGER,
    LogonTime: LARGE_INTEGER,
    CurrentTime: LARGE_INTEGER,
};

pub const WTSINFOA = extern struct {
    State: WTS_CONNECTSTATE_CLASS,
    SessionId: u32,
    IncomingBytes: u32,
    OutgoingBytes: u32,
    IncomingFrames: u32,
    OutgoingFrames: u32,
    IncomingCompressedBytes: u32,
    OutgoingCompressedBy: u32,
    WinStationName: [32]CHAR,
    Domain: [17]CHAR,
    UserName: [21]CHAR,
    ConnectTime: LARGE_INTEGER,
    DisconnectTime: LARGE_INTEGER,
    LastInputTime: LARGE_INTEGER,
    LogonTime: LARGE_INTEGER,
    CurrentTime: LARGE_INTEGER,
};

pub const WTSINFOEX_LEVEL1_W = extern struct {
    SessionId: u32,
    SessionState: WTS_CONNECTSTATE_CLASS,
    SessionFlags: i32,
    WinStationName: [33]u16,
    UserName: [21]u16,
    DomainName: [18]u16,
    LogonTime: LARGE_INTEGER,
    ConnectTime: LARGE_INTEGER,
    DisconnectTime: LARGE_INTEGER,
    LastInputTime: LARGE_INTEGER,
    CurrentTime: LARGE_INTEGER,
    IncomingBytes: u32,
    OutgoingBytes: u32,
    IncomingFrames: u32,
    OutgoingFrames: u32,
    IncomingCompressedBytes: u32,
    OutgoingCompressedBytes: u32,
};

pub const WTSINFOEX_LEVEL1_A = extern struct {
    SessionId: u32,
    SessionState: WTS_CONNECTSTATE_CLASS,
    SessionFlags: i32,
    WinStationName: [33]CHAR,
    UserName: [21]CHAR,
    DomainName: [18]CHAR,
    LogonTime: LARGE_INTEGER,
    ConnectTime: LARGE_INTEGER,
    DisconnectTime: LARGE_INTEGER,
    LastInputTime: LARGE_INTEGER,
    CurrentTime: LARGE_INTEGER,
    IncomingBytes: u32,
    OutgoingBytes: u32,
    IncomingFrames: u32,
    OutgoingFrames: u32,
    IncomingCompressedBytes: u32,
    OutgoingCompressedBytes: u32,
};

pub const WTSINFOEX_LEVEL_W = extern union {
    WTSInfoExLevel1: WTSINFOEX_LEVEL1_W,
};

pub const WTSINFOEX_LEVEL_A = extern union {
    WTSInfoExLevel1: WTSINFOEX_LEVEL1_A,
};

pub const WTSINFOEXW = extern struct {
    Level: u32,
    Data: WTSINFOEX_LEVEL_W,
};

pub const WTSINFOEXA = extern struct {
    Level: u32,
    Data: WTSINFOEX_LEVEL_A,
};

pub const WTSCLIENTW = extern struct {
    ClientName: [21]u16,
    Domain: [18]u16,
    UserName: [21]u16,
    WorkDirectory: [261]u16,
    InitialProgram: [261]u16,
    EncryptionLevel: u8,
    ClientAddressFamily: u32,
    ClientAddress: [31]u16,
    HRes: u16,
    VRes: u16,
    ColorDepth: u16,
    ClientDirectory: [261]u16,
    ClientBuildNumber: u32,
    ClientHardwareId: u32,
    ClientProductId: u16,
    OutBufCountHost: u16,
    OutBufCountClient: u16,
    OutBufLength: u16,
    DeviceId: [261]u16,
};

pub const WTSCLIENTA = extern struct {
    ClientName: [21]CHAR,
    Domain: [18]CHAR,
    UserName: [21]CHAR,
    WorkDirectory: [261]CHAR,
    InitialProgram: [261]CHAR,
    EncryptionLevel: u8,
    ClientAddressFamily: u32,
    ClientAddress: [31]u16,
    HRes: u16,
    VRes: u16,
    ColorDepth: u16,
    ClientDirectory: [261]CHAR,
    ClientBuildNumber: u32,
    ClientHardwareId: u32,
    ClientProductId: u16,
    OutBufCountHost: u16,
    OutBufCountClient: u16,
    OutBufLength: u16,
    DeviceId: [261]CHAR,
};

pub const _WTS_PRODUCT_INFOA = extern struct {
    CompanyName: [256]CHAR,
    ProductID: [4]CHAR,
};

pub const _WTS_PRODUCT_INFOW = extern struct {
    CompanyName: [256]u16,
    ProductID: [4]u16,
};

pub const WTS_VALIDATION_INFORMATIONA = extern struct {
    ProductInfo: _WTS_PRODUCT_INFOA,
    License: [16384]u8,
    LicenseLength: u32,
    HardwareID: [20]u8,
    HardwareIDLength: u32,
};

pub const WTS_VALIDATION_INFORMATIONW = extern struct {
    ProductInfo: _WTS_PRODUCT_INFOW,
    License: [16384]u8,
    LicenseLength: u32,
    HardwareID: [20]u8,
    HardwareIDLength: u32,
};

pub const WTS_CLIENT_ADDRESS = extern struct {
    AddressFamily: u32,
    Address: [20]u8,
};

pub const WTS_CLIENT_DISPLAY = extern struct {
    HorizontalResolution: u32,
    VerticalResolution: u32,
    ColorDepth: u32,
};

pub const WTS_CONFIG_CLASS = enum(i32) {
    InitialProgram = 0,
    WorkingDirectory = 1,
    fInheritInitialProgram = 2,
    fAllowLogonTerminalServer = 3,
    TimeoutSettingsConnections = 4,
    TimeoutSettingsDisconnections = 5,
    TimeoutSettingsIdle = 6,
    fDeviceClientDrives = 7,
    fDeviceClientPrinters = 8,
    fDeviceClientDefaultPrinter = 9,
    BrokenTimeoutSettings = 10,
    ReconnectSettings = 11,
    ModemCallbackSettings = 12,
    ModemCallbackPhoneNumber = 13,
    ShadowingSettings = 14,
    TerminalServerProfilePath = 15,
    TerminalServerHomeDir = 16,
    TerminalServerHomeDirDrive = 17,
    fTerminalServerRemoteHomeDir = 18,
    User = 19,
};
pub const WTSUserConfigInitialProgram = WTS_CONFIG_CLASS.InitialProgram;
pub const WTSUserConfigWorkingDirectory = WTS_CONFIG_CLASS.WorkingDirectory;
pub const WTSUserConfigfInheritInitialProgram = WTS_CONFIG_CLASS.fInheritInitialProgram;
pub const WTSUserConfigfAllowLogonTerminalServer = WTS_CONFIG_CLASS.fAllowLogonTerminalServer;
pub const WTSUserConfigTimeoutSettingsConnections = WTS_CONFIG_CLASS.TimeoutSettingsConnections;
pub const WTSUserConfigTimeoutSettingsDisconnections = WTS_CONFIG_CLASS.TimeoutSettingsDisconnections;
pub const WTSUserConfigTimeoutSettingsIdle = WTS_CONFIG_CLASS.TimeoutSettingsIdle;
pub const WTSUserConfigfDeviceClientDrives = WTS_CONFIG_CLASS.fDeviceClientDrives;
pub const WTSUserConfigfDeviceClientPrinters = WTS_CONFIG_CLASS.fDeviceClientPrinters;
pub const WTSUserConfigfDeviceClientDefaultPrinter = WTS_CONFIG_CLASS.fDeviceClientDefaultPrinter;
pub const WTSUserConfigBrokenTimeoutSettings = WTS_CONFIG_CLASS.BrokenTimeoutSettings;
pub const WTSUserConfigReconnectSettings = WTS_CONFIG_CLASS.ReconnectSettings;
pub const WTSUserConfigModemCallbackSettings = WTS_CONFIG_CLASS.ModemCallbackSettings;
pub const WTSUserConfigModemCallbackPhoneNumber = WTS_CONFIG_CLASS.ModemCallbackPhoneNumber;
pub const WTSUserConfigShadowingSettings = WTS_CONFIG_CLASS.ShadowingSettings;
pub const WTSUserConfigTerminalServerProfilePath = WTS_CONFIG_CLASS.TerminalServerProfilePath;
pub const WTSUserConfigTerminalServerHomeDir = WTS_CONFIG_CLASS.TerminalServerHomeDir;
pub const WTSUserConfigTerminalServerHomeDirDrive = WTS_CONFIG_CLASS.TerminalServerHomeDirDrive;
pub const WTSUserConfigfTerminalServerRemoteHomeDir = WTS_CONFIG_CLASS.fTerminalServerRemoteHomeDir;
pub const WTSUserConfigUser = WTS_CONFIG_CLASS.User;

pub const WTS_CONFIG_SOURCE = enum(i32) {
    M = 0,
};
pub const WTSUserConfigSourceSAM = WTS_CONFIG_SOURCE.M;

pub const WTSUSERCONFIGA = extern struct {
    Source: u32,
    InheritInitialProgram: u32,
    AllowLogonTerminalServer: u32,
    TimeoutSettingsConnections: u32,
    TimeoutSettingsDisconnections: u32,
    TimeoutSettingsIdle: u32,
    DeviceClientDrives: u32,
    DeviceClientPrinters: u32,
    ClientDefaultPrinter: u32,
    BrokenTimeoutSettings: u32,
    ReconnectSettings: u32,
    ShadowingSettings: u32,
    TerminalServerRemoteHomeDir: u32,
    InitialProgram: [261]CHAR,
    WorkDirectory: [261]CHAR,
    TerminalServerProfilePath: [261]CHAR,
    TerminalServerHomeDir: [261]CHAR,
    TerminalServerHomeDirDrive: [4]CHAR,
};

pub const WTSUSERCONFIGW = extern struct {
    Source: u32,
    InheritInitialProgram: u32,
    AllowLogonTerminalServer: u32,
    TimeoutSettingsConnections: u32,
    TimeoutSettingsDisconnections: u32,
    TimeoutSettingsIdle: u32,
    DeviceClientDrives: u32,
    DeviceClientPrinters: u32,
    ClientDefaultPrinter: u32,
    BrokenTimeoutSettings: u32,
    ReconnectSettings: u32,
    ShadowingSettings: u32,
    TerminalServerRemoteHomeDir: u32,
    InitialProgram: [261]u16,
    WorkDirectory: [261]u16,
    TerminalServerProfilePath: [261]u16,
    TerminalServerHomeDir: [261]u16,
    TerminalServerHomeDirDrive: [4]u16,
};

pub const WTS_VIRTUAL_CLASS = enum(i32) {
    ClientData = 0,
    FileHandle = 1,
};
pub const WTSVirtualClientData = WTS_VIRTUAL_CLASS.ClientData;
pub const WTSVirtualFileHandle = WTS_VIRTUAL_CLASS.FileHandle;

pub const WTS_SESSION_ADDRESS = extern struct {
    AddressFamily: u32,
    Address: [20]u8,
};

pub const WTS_PROCESS_INFO_EXW = extern struct {
    SessionId: u32,
    ProcessId: u32,
    pProcessName: ?PWSTR,
    pUserSid: ?PSID,
    NumberOfThreads: u32,
    HandleCount: u32,
    PagefileUsage: u32,
    PeakPagefileUsage: u32,
    WorkingSetSize: u32,
    PeakWorkingSetSize: u32,
    UserTime: LARGE_INTEGER,
    KernelTime: LARGE_INTEGER,
};

pub const WTS_PROCESS_INFO_EXA = extern struct {
    SessionId: u32,
    ProcessId: u32,
    pProcessName: ?PSTR,
    pUserSid: ?PSID,
    NumberOfThreads: u32,
    HandleCount: u32,
    PagefileUsage: u32,
    PeakPagefileUsage: u32,
    WorkingSetSize: u32,
    PeakWorkingSetSize: u32,
    UserTime: LARGE_INTEGER,
    KernelTime: LARGE_INTEGER,
};

pub const WTS_TYPE_CLASS = enum(i32) {
    ProcessInfoLevel0 = 0,
    ProcessInfoLevel1 = 1,
    SessionInfoLevel1 = 2,
};
pub const WTSTypeProcessInfoLevel0 = WTS_TYPE_CLASS.ProcessInfoLevel0;
pub const WTSTypeProcessInfoLevel1 = WTS_TYPE_CLASS.ProcessInfoLevel1;
pub const WTSTypeSessionInfoLevel1 = WTS_TYPE_CLASS.SessionInfoLevel1;

pub const WTSLISTENERCONFIGW = extern struct {
    version: u32,
    fEnableListener: u32,
    MaxConnectionCount: u32,
    fPromptForPassword: u32,
    fInheritColorDepth: u32,
    ColorDepth: u32,
    fInheritBrokenTimeoutSettings: u32,
    BrokenTimeoutSettings: u32,
    fDisablePrinterRedirection: u32,
    fDisableDriveRedirection: u32,
    fDisableComPortRedirection: u32,
    fDisableLPTPortRedirection: u32,
    fDisableClipboardRedirection: u32,
    fDisableAudioRedirection: u32,
    fDisablePNPRedirection: u32,
    fDisableDefaultMainClientPrinter: u32,
    LanAdapter: u32,
    PortNumber: u32,
    fInheritShadowSettings: u32,
    ShadowSettings: u32,
    TimeoutSettingsConnection: u32,
    TimeoutSettingsDisconnection: u32,
    TimeoutSettingsIdle: u32,
    SecurityLayer: u32,
    MinEncryptionLevel: u32,
    UserAuthentication: u32,
    Comment: [61]u16,
    LogonUserName: [21]u16,
    LogonDomain: [18]u16,
    WorkDirectory: [261]u16,
    InitialProgram: [261]u16,
};

pub const WTSLISTENERCONFIGA = extern struct {
    version: u32,
    fEnableListener: u32,
    MaxConnectionCount: u32,
    fPromptForPassword: u32,
    fInheritColorDepth: u32,
    ColorDepth: u32,
    fInheritBrokenTimeoutSettings: u32,
    BrokenTimeoutSettings: u32,
    fDisablePrinterRedirection: u32,
    fDisableDriveRedirection: u32,
    fDisableComPortRedirection: u32,
    fDisableLPTPortRedirection: u32,
    fDisableClipboardRedirection: u32,
    fDisableAudioRedirection: u32,
    fDisablePNPRedirection: u32,
    fDisableDefaultMainClientPrinter: u32,
    LanAdapter: u32,
    PortNumber: u32,
    fInheritShadowSettings: u32,
    ShadowSettings: u32,
    TimeoutSettingsConnection: u32,
    TimeoutSettingsDisconnection: u32,
    TimeoutSettingsIdle: u32,
    SecurityLayer: u32,
    MinEncryptionLevel: u32,
    UserAuthentication: u32,
    Comment: [61]CHAR,
    LogonUserName: [21]CHAR,
    LogonDomain: [18]CHAR,
    WorkDirectory: [261]CHAR,
    InitialProgram: [261]CHAR,
};

pub const WTSSBX_MACHINE_DRAIN = enum(i32) {
    UNSPEC = 0,
    OFF = 1,
    ON = 2,
};
pub const WTSSBX_MACHINE_DRAIN_UNSPEC = WTSSBX_MACHINE_DRAIN.UNSPEC;
pub const WTSSBX_MACHINE_DRAIN_OFF = WTSSBX_MACHINE_DRAIN.OFF;
pub const WTSSBX_MACHINE_DRAIN_ON = WTSSBX_MACHINE_DRAIN.ON;

pub const WTSSBX_MACHINE_SESSION_MODE = enum(i32) {
    UNSPEC = 0,
    SINGLE = 1,
    MULTIPLE = 2,
};
pub const WTSSBX_MACHINE_SESSION_MODE_UNSPEC = WTSSBX_MACHINE_SESSION_MODE.UNSPEC;
pub const WTSSBX_MACHINE_SESSION_MODE_SINGLE = WTSSBX_MACHINE_SESSION_MODE.SINGLE;
pub const WTSSBX_MACHINE_SESSION_MODE_MULTIPLE = WTSSBX_MACHINE_SESSION_MODE.MULTIPLE;

pub const WTSSBX_ADDRESS_FAMILY = enum(i32) {
    UNSPEC = 0,
    INET = 1,
    INET6 = 2,
    IPX = 3,
    NETBIOS = 4,
};
pub const WTSSBX_ADDRESS_FAMILY_AF_UNSPEC = WTSSBX_ADDRESS_FAMILY.UNSPEC;
pub const WTSSBX_ADDRESS_FAMILY_AF_INET = WTSSBX_ADDRESS_FAMILY.INET;
pub const WTSSBX_ADDRESS_FAMILY_AF_INET6 = WTSSBX_ADDRESS_FAMILY.INET6;
pub const WTSSBX_ADDRESS_FAMILY_AF_IPX = WTSSBX_ADDRESS_FAMILY.IPX;
pub const WTSSBX_ADDRESS_FAMILY_AF_NETBIOS = WTSSBX_ADDRESS_FAMILY.NETBIOS;

pub const WTSSBX_IP_ADDRESS = extern struct {
    AddressFamily: WTSSBX_ADDRESS_FAMILY,
    Address: [16]u8,
    PortNumber: u16,
    dwScope: u32,
};

pub const WTSSBX_MACHINE_STATE = enum(i32) {
    UNSPEC = 0,
    READY = 1,
    SYNCHRONIZING = 2,
};
pub const WTSSBX_MACHINE_STATE_UNSPEC = WTSSBX_MACHINE_STATE.UNSPEC;
pub const WTSSBX_MACHINE_STATE_READY = WTSSBX_MACHINE_STATE.READY;
pub const WTSSBX_MACHINE_STATE_SYNCHRONIZING = WTSSBX_MACHINE_STATE.SYNCHRONIZING;

pub const WTSSBX_MACHINE_CONNECT_INFO = extern struct {
    wczMachineFQDN: [257]u16,
    wczMachineNetBiosName: [17]u16,
    dwNumOfIPAddr: u32,
    IPaddr: [12]WTSSBX_IP_ADDRESS,
};

pub const WTSSBX_MACHINE_INFO = extern struct {
    ClientConnectInfo: WTSSBX_MACHINE_CONNECT_INFO,
    wczFarmName: [257]u16,
    InternalIPAddress: WTSSBX_IP_ADDRESS,
    dwMaxSessionsLimit: u32,
    ServerWeight: u32,
    SingleSessionMode: WTSSBX_MACHINE_SESSION_MODE,
    InDrain: WTSSBX_MACHINE_DRAIN,
    MachineState: WTSSBX_MACHINE_STATE,
};

pub const WTSSBX_SESSION_STATE = enum(i32) {
    UNSPEC = 0,
    ACTIVE = 1,
    DISCONNECTED = 2,
};
pub const WTSSBX_SESSION_STATE_UNSPEC = WTSSBX_SESSION_STATE.UNSPEC;
pub const WTSSBX_SESSION_STATE_ACTIVE = WTSSBX_SESSION_STATE.ACTIVE;
pub const WTSSBX_SESSION_STATE_DISCONNECTED = WTSSBX_SESSION_STATE.DISCONNECTED;

pub const WTSSBX_SESSION_INFO = extern struct {
    wszUserName: [105]u16,
    wszDomainName: [257]u16,
    ApplicationType: [257]u16,
    dwSessionId: u32,
    CreateTime: FILETIME,
    DisconnectTime: FILETIME,
    SessionState: WTSSBX_SESSION_STATE,
};

pub const WTSSBX_NOTIFICATION_TYPE = enum(i32) {
    REMOVED = 1,
    CHANGED = 2,
    ADDED = 4,
    RESYNC = 8,
};
pub const WTSSBX_NOTIFICATION_REMOVED = WTSSBX_NOTIFICATION_TYPE.REMOVED;
pub const WTSSBX_NOTIFICATION_CHANGED = WTSSBX_NOTIFICATION_TYPE.CHANGED;
pub const WTSSBX_NOTIFICATION_ADDED = WTSSBX_NOTIFICATION_TYPE.ADDED;
pub const WTSSBX_NOTIFICATION_RESYNC = WTSSBX_NOTIFICATION_TYPE.RESYNC;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSSBPlugin_Value = Guid.initString("dc44be78-b18d-4399-b210-641bf67a002c");
pub const IID_IWTSSBPlugin = &IID_IWTSSBPlugin_Value;
pub const IWTSSBPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
                PluginCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
                PluginCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WTSSBX_MachineChangeNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
                NotificationType: WTSSBX_NOTIFICATION_TYPE,
                MachineId: i32,
                pMachineInfo: ?*WTSSBX_MACHINE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
                NotificationType: WTSSBX_NOTIFICATION_TYPE,
                MachineId: i32,
                pMachineInfo: ?*WTSSBX_MACHINE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WTSSBX_SessionChangeNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
                NotificationType: WTSSBX_NOTIFICATION_TYPE,
                MachineId: i32,
                NumOfSessions: u32,
                SessionInfo: [*]WTSSBX_SESSION_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
                NotificationType: WTSSBX_NOTIFICATION_TYPE,
                MachineId: i32,
                NumOfSessions: u32,
                SessionInfo: [*]WTSSBX_SESSION_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WTSSBX_GetMostSuitableServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
                UserName: ?PWSTR,
                DomainName: ?PWSTR,
                ApplicationType: ?PWSTR,
                FarmName: ?PWSTR,
                pMachineId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
                UserName: ?PWSTR,
                DomainName: ?PWSTR,
                ApplicationType: ?PWSTR,
                FarmName: ?PWSTR,
                pMachineId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WTSSBX_GetUserExternalSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSSBPlugin,
                UserName: ?PWSTR,
                DomainName: ?PWSTR,
                ApplicationType: ?PWSTR,
                RedirectorInternalIP: ?*WTSSBX_IP_ADDRESS,
                pSessionId: ?*u32,
                pMachineConnectInfo: ?*WTSSBX_MACHINE_CONNECT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSSBPlugin,
                UserName: ?PWSTR,
                DomainName: ?PWSTR,
                ApplicationType: ?PWSTR,
                RedirectorInternalIP: ?*WTSSBX_IP_ADDRESS,
                pSessionId: ?*u32,
                pMachineConnectInfo: ?*WTSSBX_MACHINE_CONNECT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_Initialize(self: *const T, PluginCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWTSSBPlugin, @ptrCast(self)), PluginCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_WTSSBX_MachineChangeNotification(self: *const T, NotificationType: WTSSBX_NOTIFICATION_TYPE, MachineId: i32, pMachineInfo: ?*WTSSBX_MACHINE_INFO) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).WTSSBX_MachineChangeNotification(@as(*const IWTSSBPlugin, @ptrCast(self)), NotificationType, MachineId, pMachineInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_WTSSBX_SessionChangeNotification(self: *const T, NotificationType: WTSSBX_NOTIFICATION_TYPE, MachineId: i32, NumOfSessions: u32, SessionInfo: [*]WTSSBX_SESSION_INFO) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).WTSSBX_SessionChangeNotification(@as(*const IWTSSBPlugin, @ptrCast(self)), NotificationType, MachineId, NumOfSessions, SessionInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_WTSSBX_GetMostSuitableServer(self: *const T, UserName: ?PWSTR, DomainName: ?PWSTR, ApplicationType: ?PWSTR, FarmName: ?PWSTR, pMachineId: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).WTSSBX_GetMostSuitableServer(@as(*const IWTSSBPlugin, @ptrCast(self)), UserName, DomainName, ApplicationType, FarmName, pMachineId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_Terminated(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).Terminated(@as(*const IWTSSBPlugin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSSBPlugin_WTSSBX_GetUserExternalSession(self: *const T, UserName: ?PWSTR, DomainName: ?PWSTR, ApplicationType: ?PWSTR, RedirectorInternalIP: ?*WTSSBX_IP_ADDRESS, pSessionId: ?*u32, pMachineConnectInfo: ?*WTSSBX_MACHINE_CONNECT_INFO) callconv(.Inline) HRESULT {
            return @as(*const IWTSSBPlugin.VTable, @ptrCast(self.vtable)).WTSSBX_GetUserExternalSession(@as(*const IWTSSBPlugin, @ptrCast(self)), UserName, DomainName, ApplicationType, RedirectorInternalIP, pSessionId, pMachineConnectInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CHANNEL_DEF = extern struct {
    name: [8]CHAR align(1),
    options: u32 align(1),
};

pub const CHANNEL_PDU_HEADER = extern struct {
    length: u32,
    flags: u32,
};

pub const PCHANNEL_INIT_EVENT_FN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pInitHandle: ?*anyopaque,
        event: u32,
        pData: ?*anyopaque,
        dataLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        pInitHandle: ?*anyopaque,
        event: u32,
        pData: ?*anyopaque,
        dataLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PCHANNEL_OPEN_EVENT_FN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        openHandle: u32,
        event: u32,
        pData: ?*anyopaque,
        dataLength: u32,
        totalLength: u32,
        dataFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        openHandle: u32,
        event: u32,
        pData: ?*anyopaque,
        dataLength: u32,
        totalLength: u32,
        dataFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PVIRTUALCHANNELINIT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ppInitHandle: ?*?*anyopaque,
        pChannel: ?*CHANNEL_DEF,
        channelCount: i32,
        versionRequested: u32,
        pChannelInitEventProc: ?PCHANNEL_INIT_EVENT_FN,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        ppInitHandle: ?*?*anyopaque,
        pChannel: ?*CHANNEL_DEF,
        channelCount: i32,
        versionRequested: u32,
        pChannelInitEventProc: ?PCHANNEL_INIT_EVENT_FN,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PVIRTUALCHANNELOPEN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pInitHandle: ?*anyopaque,
        pOpenHandle: ?*u32,
        pChannelName: ?[*]u8,
        pChannelOpenEventProc: ?PCHANNEL_OPEN_EVENT_FN,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pInitHandle: ?*anyopaque,
        pOpenHandle: ?*u32,
        pChannelName: ?[*]u8,
        pChannelOpenEventProc: ?PCHANNEL_OPEN_EVENT_FN,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PVIRTUALCHANNELCLOSE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        openHandle: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        openHandle: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PVIRTUALCHANNELWRITE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        openHandle: u32,
        pData: ?*anyopaque,
        dataLength: u32,
        pUserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        openHandle: u32,
        pData: ?*anyopaque,
        dataLength: u32,
        pUserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const CHANNEL_ENTRY_POINTS = extern struct {
    cbSize: u32,
    protocolVersion: u32,
    pVirtualChannelInit: ?PVIRTUALCHANNELINIT,
    pVirtualChannelOpen: ?PVIRTUALCHANNELOPEN,
    pVirtualChannelClose: ?PVIRTUALCHANNELCLOSE,
    pVirtualChannelWrite: ?PVIRTUALCHANNELWRITE,
};

pub const PVIRTUALCHANNELENTRY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pEntryPoints: ?*CHANNEL_ENTRY_POINTS,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pEntryPoints: ?*CHANNEL_ENTRY_POINTS,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

const CLSID_Workspace_Value = Guid.initString("4f1dfca6-3aad-48e1-8406-4bc21a501d7c");
pub const CLSID_Workspace = &CLSID_Workspace_Value;

// TODO: this type is limited to platform 'windows6.1'
const IID_IWorkspaceClientExt_Value = Guid.initString("12b952f4-41ca-4f21-a829-a6d07d9a16e5");
pub const IID_IWorkspaceClientExt = &IID_IWorkspaceClientExt_Value;
pub const IWorkspaceClientExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResourceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceClientExt,
                bstrWorkspaceId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceClientExt,
                bstrWorkspaceId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourceDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceClientExt,
                bstrWorkspaceDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceClientExt,
                bstrWorkspaceDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IssueDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceClientExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceClientExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceClientExt_GetResourceId(self: *const T, bstrWorkspaceId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceClientExt.VTable, @ptrCast(self.vtable)).GetResourceId(@as(*const IWorkspaceClientExt, @ptrCast(self)), bstrWorkspaceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceClientExt_GetResourceDisplayName(self: *const T, bstrWorkspaceDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceClientExt.VTable, @ptrCast(self.vtable)).GetResourceDisplayName(@as(*const IWorkspaceClientExt, @ptrCast(self)), bstrWorkspaceDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceClientExt_IssueDisconnect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceClientExt.VTable, @ptrCast(self.vtable)).IssueDisconnect(@as(*const IWorkspaceClientExt, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWorkspace_Value = Guid.initString("b922bbb8-4c55-4fea-8496-beb0b44285e5");
pub const IID_IWorkspace = &IID_IWorkspace_Value;
pub const IWorkspace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWorkspaceNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace,
                psaWkspNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace,
                psaWkspNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartRemoteApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace,
                bstrWorkspaceId: ?BSTR,
                psaParams: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace,
                bstrWorkspaceId: ?BSTR,
                psaParams: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace,
                pulProcessId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace,
                pulProcessId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace_GetWorkspaceNames(self: *const T, psaWkspNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace.VTable, @ptrCast(self.vtable)).GetWorkspaceNames(@as(*const IWorkspace, @ptrCast(self)), psaWkspNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace_StartRemoteApplication(self: *const T, bstrWorkspaceId: ?BSTR, psaParams: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace.VTable, @ptrCast(self.vtable)).StartRemoteApplication(@as(*const IWorkspace, @ptrCast(self)), bstrWorkspaceId, psaParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace_GetProcessId(self: *const T, pulProcessId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace.VTable, @ptrCast(self.vtable)).GetProcessId(@as(*const IWorkspace, @ptrCast(self)), pulProcessId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWorkspace2_Value = Guid.initString("96d8d7cf-783e-4286-834c-ebc0e95f783c");
pub const IID_IWorkspace2 = &IID_IWorkspace2_Value;
pub const IWorkspace2 = extern struct {
    pub const VTable = extern struct {
        base: IWorkspace.VTable,
        StartRemoteApplicationEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace2,
                bstrWorkspaceId: ?BSTR,
                bstrRequestingAppId: ?BSTR,
                bstrRequestingAppFamilyName: ?BSTR,
                bLaunchIntoImmersiveClient: i16,
                bstrImmersiveClientActivationContext: ?BSTR,
                psaParams: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace2,
                bstrWorkspaceId: ?BSTR,
                bstrRequestingAppId: ?BSTR,
                bstrRequestingAppFamilyName: ?BSTR,
                bLaunchIntoImmersiveClient: i16,
                bstrImmersiveClientActivationContext: ?BSTR,
                psaParams: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWorkspace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace2_StartRemoteApplicationEx(self: *const T, bstrWorkspaceId: ?BSTR, bstrRequestingAppId: ?BSTR, bstrRequestingAppFamilyName: ?BSTR, bLaunchIntoImmersiveClient: i16, bstrImmersiveClientActivationContext: ?BSTR, psaParams: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace2.VTable, @ptrCast(self.vtable)).StartRemoteApplicationEx(@as(*const IWorkspace2, @ptrCast(self)), bstrWorkspaceId, bstrRequestingAppId, bstrRequestingAppFamilyName, bLaunchIntoImmersiveClient, bstrImmersiveClientActivationContext, psaParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IWorkspace3_Value = Guid.initString("1becbe4a-d654-423b-afeb-be8d532c13c6");
pub const IID_IWorkspace3 = &IID_IWorkspace3_Value;
pub const IWorkspace3 = extern struct {
    pub const VTable = extern struct {
        base: IWorkspace2.VTable,
        GetClaimsToken2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace3,
                bstrClaimsHint: ?BSTR,
                bstrUserHint: ?BSTR,
                claimCookie: u32,
                hwndCredUiParent: u32,
                rectCredUiParent: RECT,
                pbstrAccessToken: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace3,
                bstrClaimsHint: ?BSTR,
                bstrUserHint: ?BSTR,
                claimCookie: u32,
                hwndCredUiParent: u32,
                rectCredUiParent: RECT,
                pbstrAccessToken: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClaimsToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspace3,
                bstrAccessToken: ?BSTR,
                ullAccessTokenExpiration: u64,
                bstrRefreshToken: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspace3,
                bstrAccessToken: ?BSTR,
                ullAccessTokenExpiration: u64,
                bstrRefreshToken: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWorkspace2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace3_GetClaimsToken2(self: *const T, bstrClaimsHint: ?BSTR, bstrUserHint: ?BSTR, claimCookie: u32, hwndCredUiParent: u32, rectCredUiParent: RECT, pbstrAccessToken: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace3.VTable, @ptrCast(self.vtable)).GetClaimsToken2(@as(*const IWorkspace3, @ptrCast(self)), bstrClaimsHint, bstrUserHint, claimCookie, hwndCredUiParent, rectCredUiParent, pbstrAccessToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspace3_SetClaimsToken(self: *const T, bstrAccessToken: ?BSTR, ullAccessTokenExpiration: u64, bstrRefreshToken: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspace3.VTable, @ptrCast(self.vtable)).SetClaimsToken(@as(*const IWorkspace3, @ptrCast(self)), bstrAccessToken, ullAccessTokenExpiration, bstrRefreshToken);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWorkspaceRegistration_Value = Guid.initString("b922bbb8-4c55-4fea-8496-beb0b44285e6");
pub const IID_IWorkspaceRegistration = &IID_IWorkspaceRegistration_Value;
pub const IWorkspaceRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceRegistration,
                pUnk: ?*IWorkspaceClientExt,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceRegistration,
                pUnk: ?*IWorkspaceClientExt,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceRegistration,
                dwCookieConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceRegistration,
                dwCookieConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceRegistration_AddResource(self: *const T, pUnk: ?*IWorkspaceClientExt, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceRegistration.VTable, @ptrCast(self.vtable)).AddResource(@as(*const IWorkspaceRegistration, @ptrCast(self)), pUnk, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceRegistration_RemoveResource(self: *const T, dwCookieConnection: u32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceRegistration.VTable, @ptrCast(self.vtable)).RemoveResource(@as(*const IWorkspaceRegistration, @ptrCast(self)), dwCookieConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IWorkspaceRegistration2_Value = Guid.initString("cf59f654-39bb-44d8-94d0-4635728957e9");
pub const IID_IWorkspaceRegistration2 = &IID_IWorkspaceRegistration2_Value;
pub const IWorkspaceRegistration2 = extern struct {
    pub const VTable = extern struct {
        base: IWorkspaceRegistration.VTable,
        AddResourceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceRegistration2,
                pUnk: ?*IWorkspaceClientExt,
                bstrEventLogUploadAddress: ?BSTR,
                pdwCookie: ?*u32,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceRegistration2,
                pUnk: ?*IWorkspaceClientExt,
                bstrEventLogUploadAddress: ?BSTR,
                pdwCookie: ?*u32,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveResourceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceRegistration2,
                dwCookieConnection: u32,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceRegistration2,
                dwCookieConnection: u32,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWorkspaceRegistration.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceRegistration2_AddResourceEx(self: *const T, pUnk: ?*IWorkspaceClientExt, bstrEventLogUploadAddress: ?BSTR, pdwCookie: ?*u32, correlationId: Guid) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceRegistration2.VTable, @ptrCast(self.vtable)).AddResourceEx(@as(*const IWorkspaceRegistration2, @ptrCast(self)), pUnk, bstrEventLogUploadAddress, pdwCookie, correlationId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceRegistration2_RemoveResourceEx(self: *const T, dwCookieConnection: u32, correlationId: Guid) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceRegistration2.VTable, @ptrCast(self.vtable)).RemoveResourceEx(@as(*const IWorkspaceRegistration2, @ptrCast(self)), dwCookieConnection, correlationId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWorkspaceScriptable_Value = Guid.initString("efea49a2-dda5-429d-8f42-b23b92c4c347");
pub const IID_IWorkspaceScriptable = &IID_IWorkspaceScriptable_Value;
pub const IWorkspaceScriptable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        DisconnectWorkspace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartWorkspace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsWorkspaceCredentialSpecified: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bCountUnauthenticatedCredentials: i16,
                pbCredExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bCountUnauthenticatedCredentials: i16,
                pbCredExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsWorkspaceSSOEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                pbSSOEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                pbSSOEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearWorkspaceCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAuthenticated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bstrUserName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceId: ?BSTR,
                bstrUserName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectWorkspaceByFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable,
                bstrWorkspaceFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_DisconnectWorkspace(self: *const T, bstrWorkspaceId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).DisconnectWorkspace(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_StartWorkspace(self: *const T, bstrWorkspaceId: ?BSTR, bstrUserName: ?BSTR, bstrPassword: ?BSTR, bstrWorkspaceParams: ?BSTR, lTimeout: i32, lFlags: i32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).StartWorkspace(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceId, bstrUserName, bstrPassword, bstrWorkspaceParams, lTimeout, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_IsWorkspaceCredentialSpecified(self: *const T, bstrWorkspaceId: ?BSTR, bCountUnauthenticatedCredentials: i16, pbCredExist: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).IsWorkspaceCredentialSpecified(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceId, bCountUnauthenticatedCredentials, pbCredExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_IsWorkspaceSSOEnabled(self: *const T, pbSSOEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).IsWorkspaceSSOEnabled(@as(*const IWorkspaceScriptable, @ptrCast(self)), pbSSOEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_ClearWorkspaceCredential(self: *const T, bstrWorkspaceId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).ClearWorkspaceCredential(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_OnAuthenticated(self: *const T, bstrWorkspaceId: ?BSTR, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).OnAuthenticated(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceId, bstrUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable_DisconnectWorkspaceByFriendlyName(self: *const T, bstrWorkspaceFriendlyName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable.VTable, @ptrCast(self.vtable)).DisconnectWorkspaceByFriendlyName(@as(*const IWorkspaceScriptable, @ptrCast(self)), bstrWorkspaceFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWorkspaceScriptable2_Value = Guid.initString("efea49a2-dda5-429d-8f42-b33ba2c4c348");
pub const IID_IWorkspaceScriptable2 = &IID_IWorkspaceScriptable2_Value;
pub const IWorkspaceScriptable2 = extern struct {
    pub const VTable = extern struct {
        base: IWorkspaceScriptable.VTable,
        StartWorkspaceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable2,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
                bstrRedirectorName: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrAppContainer: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable2,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
                bstrRedirectorName: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrAppContainer: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResourceDismissed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable2,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable2,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWorkspaceScriptable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable2_StartWorkspaceEx(self: *const T, bstrWorkspaceId: ?BSTR, bstrWorkspaceFriendlyName: ?BSTR, bstrRedirectorName: ?BSTR, bstrUserName: ?BSTR, bstrPassword: ?BSTR, bstrAppContainer: ?BSTR, bstrWorkspaceParams: ?BSTR, lTimeout: i32, lFlags: i32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable2.VTable, @ptrCast(self.vtable)).StartWorkspaceEx(@as(*const IWorkspaceScriptable2, @ptrCast(self)), bstrWorkspaceId, bstrWorkspaceFriendlyName, bstrRedirectorName, bstrUserName, bstrPassword, bstrAppContainer, bstrWorkspaceParams, lTimeout, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable2_ResourceDismissed(self: *const T, bstrWorkspaceId: ?BSTR, bstrWorkspaceFriendlyName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable2.VTable, @ptrCast(self.vtable)).ResourceDismissed(@as(*const IWorkspaceScriptable2, @ptrCast(self)), bstrWorkspaceId, bstrWorkspaceFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IWorkspaceScriptable3_Value = Guid.initString("531e6512-2cbf-4bd2-80a5-d90a71636a9a");
pub const IID_IWorkspaceScriptable3 = &IID_IWorkspaceScriptable3_Value;
pub const IWorkspaceScriptable3 = extern struct {
    pub const VTable = extern struct {
        base: IWorkspaceScriptable2.VTable,
        StartWorkspaceEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceScriptable3,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
                bstrRedirectorName: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrAppContainer: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
                bstrEventLogUploadAddress: ?BSTR,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceScriptable3,
                bstrWorkspaceId: ?BSTR,
                bstrWorkspaceFriendlyName: ?BSTR,
                bstrRedirectorName: ?BSTR,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
                bstrAppContainer: ?BSTR,
                bstrWorkspaceParams: ?BSTR,
                lTimeout: i32,
                lFlags: i32,
                bstrEventLogUploadAddress: ?BSTR,
                correlationId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWorkspaceScriptable2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceScriptable3_StartWorkspaceEx2(self: *const T, bstrWorkspaceId: ?BSTR, bstrWorkspaceFriendlyName: ?BSTR, bstrRedirectorName: ?BSTR, bstrUserName: ?BSTR, bstrPassword: ?BSTR, bstrAppContainer: ?BSTR, bstrWorkspaceParams: ?BSTR, lTimeout: i32, lFlags: i32, bstrEventLogUploadAddress: ?BSTR, correlationId: Guid) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceScriptable3.VTable, @ptrCast(self.vtable)).StartWorkspaceEx2(@as(*const IWorkspaceScriptable3, @ptrCast(self)), bstrWorkspaceId, bstrWorkspaceFriendlyName, bstrRedirectorName, bstrUserName, bstrPassword, bstrAppContainer, bstrWorkspaceParams, lTimeout, lFlags, bstrEventLogUploadAddress, correlationId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWorkspaceReportMessage_Value = Guid.initString("a7c06739-500f-4e8c-99a8-2bd6955899eb");
pub const IID_IWorkspaceReportMessage = &IID_IWorkspaceReportMessage_Value;
pub const IWorkspaceReportMessage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterErrorLogMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceReportMessage,
                bstrMessage: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceReportMessage,
                bstrMessage: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsErrorMessageRegistered: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceReportMessage,
                bstrWkspId: ?BSTR,
                dwErrorType: u32,
                bstrErrorMessageType: ?BSTR,
                dwErrorCode: u32,
                pfErrorExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceReportMessage,
                bstrWkspId: ?BSTR,
                dwErrorType: u32,
                bstrErrorMessageType: ?BSTR,
                dwErrorCode: u32,
                pfErrorExist: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterErrorEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceReportMessage,
                bstrWkspId: ?BSTR,
                dwErrorType: u32,
                bstrErrorMessageType: ?BSTR,
                dwErrorCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceReportMessage,
                bstrWkspId: ?BSTR,
                dwErrorType: u32,
                bstrErrorMessageType: ?BSTR,
                dwErrorCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceReportMessage_RegisterErrorLogMessage(self: *const T, bstrMessage: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceReportMessage.VTable, @ptrCast(self.vtable)).RegisterErrorLogMessage(@as(*const IWorkspaceReportMessage, @ptrCast(self)), bstrMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceReportMessage_IsErrorMessageRegistered(self: *const T, bstrWkspId: ?BSTR, dwErrorType: u32, bstrErrorMessageType: ?BSTR, dwErrorCode: u32, pfErrorExist: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceReportMessage.VTable, @ptrCast(self.vtable)).IsErrorMessageRegistered(@as(*const IWorkspaceReportMessage, @ptrCast(self)), bstrWkspId, dwErrorType, bstrErrorMessageType, dwErrorCode, pfErrorExist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceReportMessage_RegisterErrorEvent(self: *const T, bstrWkspId: ?BSTR, dwErrorType: u32, bstrErrorMessageType: ?BSTR, dwErrorCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceReportMessage.VTable, @ptrCast(self.vtable)).RegisterErrorEvent(@as(*const IWorkspaceReportMessage, @ptrCast(self)), bstrWkspId, dwErrorType, bstrErrorMessageType, dwErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__ITSWkspEvents_Value = Guid.initString("b922bbb8-4c55-4fea-8496-beb0b44285e9");
pub const IID__ITSWkspEvents = &IID__ITSWkspEvents_Value;
pub const _ITSWkspEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TSSD_AddrV46Type = enum(i32) {
    UNDEFINED = 0,
    IPv4 = 4,
    IPv6 = 6,
};
pub const TSSD_ADDR_UNDEFINED = TSSD_AddrV46Type.UNDEFINED;
pub const TSSD_ADDR_IPv4 = TSSD_AddrV46Type.IPv4;
pub const TSSD_ADDR_IPv6 = TSSD_AddrV46Type.IPv6;

pub const TSSB_NOTIFICATION_TYPE = enum(i32) {
    INVALID = 0,
    TARGET_CHANGE = 1,
    SESSION_CHANGE = 2,
    CONNECTION_REQUEST_CHANGE = 4,
};
pub const TSSB_NOTIFY_INVALID = TSSB_NOTIFICATION_TYPE.INVALID;
pub const TSSB_NOTIFY_TARGET_CHANGE = TSSB_NOTIFICATION_TYPE.TARGET_CHANGE;
pub const TSSB_NOTIFY_SESSION_CHANGE = TSSB_NOTIFICATION_TYPE.SESSION_CHANGE;
pub const TSSB_NOTIFY_CONNECTION_REQUEST_CHANGE = TSSB_NOTIFICATION_TYPE.CONNECTION_REQUEST_CHANGE;

pub const TARGET_STATE = enum(i32) {
    UNKNOWN = 1,
    INITIALIZING = 2,
    RUNNING = 3,
    DOWN = 4,
    HIBERNATED = 5,
    CHECKED_OUT = 6,
    STOPPED = 7,
    INVALID = 8,
    STARTING = 9,
    STOPPING = 10,
    MAXSTATE = 11,
};
pub const TARGET_UNKNOWN = TARGET_STATE.UNKNOWN;
pub const TARGET_INITIALIZING = TARGET_STATE.INITIALIZING;
pub const TARGET_RUNNING = TARGET_STATE.RUNNING;
pub const TARGET_DOWN = TARGET_STATE.DOWN;
pub const TARGET_HIBERNATED = TARGET_STATE.HIBERNATED;
pub const TARGET_CHECKED_OUT = TARGET_STATE.CHECKED_OUT;
pub const TARGET_STOPPED = TARGET_STATE.STOPPED;
pub const TARGET_INVALID = TARGET_STATE.INVALID;
pub const TARGET_STARTING = TARGET_STATE.STARTING;
pub const TARGET_STOPPING = TARGET_STATE.STOPPING;
pub const TARGET_MAXSTATE = TARGET_STATE.MAXSTATE;

pub const TARGET_CHANGE_TYPE = enum(i32) {
    CHANGE_UNSPEC = 1,
    EXTERNALIP_CHANGED = 2,
    INTERNALIP_CHANGED = 4,
    JOINED = 8,
    REMOVED = 16,
    STATE_CHANGED = 32,
    IDLE = 64,
    PENDING = 128,
    INUSE = 256,
    PATCH_STATE_CHANGED = 512,
    FARM_MEMBERSHIP_CHANGED = 1024,
};
pub const TARGET_CHANGE_UNSPEC = TARGET_CHANGE_TYPE.CHANGE_UNSPEC;
pub const TARGET_EXTERNALIP_CHANGED = TARGET_CHANGE_TYPE.EXTERNALIP_CHANGED;
pub const TARGET_INTERNALIP_CHANGED = TARGET_CHANGE_TYPE.INTERNALIP_CHANGED;
pub const TARGET_JOINED = TARGET_CHANGE_TYPE.JOINED;
pub const TARGET_REMOVED = TARGET_CHANGE_TYPE.REMOVED;
pub const TARGET_STATE_CHANGED = TARGET_CHANGE_TYPE.STATE_CHANGED;
pub const TARGET_IDLE = TARGET_CHANGE_TYPE.IDLE;
pub const TARGET_PENDING = TARGET_CHANGE_TYPE.PENDING;
pub const TARGET_INUSE = TARGET_CHANGE_TYPE.INUSE;
pub const TARGET_PATCH_STATE_CHANGED = TARGET_CHANGE_TYPE.PATCH_STATE_CHANGED;
pub const TARGET_FARM_MEMBERSHIP_CHANGED = TARGET_CHANGE_TYPE.FARM_MEMBERSHIP_CHANGED;

pub const TARGET_TYPE = enum(i32) {
    UNKNOWN = 0,
    FARM = 1,
    NONFARM = 2,
};
pub const UNKNOWN = TARGET_TYPE.UNKNOWN;
pub const FARM = TARGET_TYPE.FARM;
pub const NONFARM = TARGET_TYPE.NONFARM;

pub const TARGET_PATCH_STATE = enum(i32) {
    UNKNOWN = 0,
    NOT_STARTED = 1,
    IN_PROGRESS = 2,
    COMPLETED = 3,
    FAILED = 4,
};
pub const TARGET_PATCH_UNKNOWN = TARGET_PATCH_STATE.UNKNOWN;
pub const TARGET_PATCH_NOT_STARTED = TARGET_PATCH_STATE.NOT_STARTED;
pub const TARGET_PATCH_IN_PROGRESS = TARGET_PATCH_STATE.IN_PROGRESS;
pub const TARGET_PATCH_COMPLETED = TARGET_PATCH_STATE.COMPLETED;
pub const TARGET_PATCH_FAILED = TARGET_PATCH_STATE.FAILED;

pub const CLIENT_MESSAGE_TYPE = enum(i32) {
    INVALID = 0,
    STATUS = 1,
    ERROR = 2,
};
pub const CLIENT_MESSAGE_CONNECTION_INVALID = CLIENT_MESSAGE_TYPE.INVALID;
pub const CLIENT_MESSAGE_CONNECTION_STATUS = CLIENT_MESSAGE_TYPE.STATUS;
pub const CLIENT_MESSAGE_CONNECTION_ERROR = CLIENT_MESSAGE_TYPE.ERROR;

pub const CONNECTION_CHANGE_NOTIFICATION = enum(i32) {
    INVALID = 0,
    PENDING = 1,
    FAILED = 2,
    TIMEDOUT = 3,
    SUCCEEDED = 4,
    CANCELLED = 5,
    LB_COMPLETED = 6,
    QUERY_PL_COMPLETED = 7,
    ORCH_COMPLETED = 8,
};
pub const CONNECTION_REQUEST_INVALID = CONNECTION_CHANGE_NOTIFICATION.INVALID;
pub const CONNECTION_REQUEST_PENDING = CONNECTION_CHANGE_NOTIFICATION.PENDING;
pub const CONNECTION_REQUEST_FAILED = CONNECTION_CHANGE_NOTIFICATION.FAILED;
pub const CONNECTION_REQUEST_TIMEDOUT = CONNECTION_CHANGE_NOTIFICATION.TIMEDOUT;
pub const CONNECTION_REQUEST_SUCCEEDED = CONNECTION_CHANGE_NOTIFICATION.SUCCEEDED;
pub const CONNECTION_REQUEST_CANCELLED = CONNECTION_CHANGE_NOTIFICATION.CANCELLED;
pub const CONNECTION_REQUEST_LB_COMPLETED = CONNECTION_CHANGE_NOTIFICATION.LB_COMPLETED;
pub const CONNECTION_REQUEST_QUERY_PL_COMPLETED = CONNECTION_CHANGE_NOTIFICATION.QUERY_PL_COMPLETED;
pub const CONNECTION_REQUEST_ORCH_COMPLETED = CONNECTION_CHANGE_NOTIFICATION.ORCH_COMPLETED;

pub const RD_FARM_TYPE = enum(i32) {
    RDSH = 0,
    TEMP_VM = 1,
    MANUAL_PERSONAL_VM = 2,
    AUTO_PERSONAL_VM = 3,
    MANUAL_PERSONAL_RDSH = 4,
    AUTO_PERSONAL_RDSH = 5,
    TYPE_UNKNOWN = -1,
};
pub const RD_FARM_RDSH = RD_FARM_TYPE.RDSH;
pub const RD_FARM_TEMP_VM = RD_FARM_TYPE.TEMP_VM;
pub const RD_FARM_MANUAL_PERSONAL_VM = RD_FARM_TYPE.MANUAL_PERSONAL_VM;
pub const RD_FARM_AUTO_PERSONAL_VM = RD_FARM_TYPE.AUTO_PERSONAL_VM;
pub const RD_FARM_MANUAL_PERSONAL_RDSH = RD_FARM_TYPE.MANUAL_PERSONAL_RDSH;
pub const RD_FARM_AUTO_PERSONAL_RDSH = RD_FARM_TYPE.AUTO_PERSONAL_RDSH;
pub const RD_FARM_TYPE_UNKNOWN = RD_FARM_TYPE.TYPE_UNKNOWN;

pub const PLUGIN_TYPE = enum(i32) {
    UNKNOWN_PLUGIN = 0,
    POLICY_PLUGIN = 1,
    RESOURCE_PLUGIN = 2,
    LOAD_BALANCING_PLUGIN = 4,
    PLACEMENT_PLUGIN = 8,
    ORCHESTRATION_PLUGIN = 16,
    PROVISIONING_PLUGIN = 32,
    TASK_PLUGIN = 64,
};
pub const UNKNOWN_PLUGIN = PLUGIN_TYPE.UNKNOWN_PLUGIN;
pub const POLICY_PLUGIN = PLUGIN_TYPE.POLICY_PLUGIN;
pub const RESOURCE_PLUGIN = PLUGIN_TYPE.RESOURCE_PLUGIN;
pub const LOAD_BALANCING_PLUGIN = PLUGIN_TYPE.LOAD_BALANCING_PLUGIN;
pub const PLACEMENT_PLUGIN = PLUGIN_TYPE.PLACEMENT_PLUGIN;
pub const ORCHESTRATION_PLUGIN = PLUGIN_TYPE.ORCHESTRATION_PLUGIN;
pub const PROVISIONING_PLUGIN = PLUGIN_TYPE.PROVISIONING_PLUGIN;
pub const TASK_PLUGIN = PLUGIN_TYPE.TASK_PLUGIN;

pub const TSSESSION_STATE = enum(i32) {
    INVALID = -1,
    ACTIVE = 0,
    CONNECTED = 1,
    CONNECTQUERY = 2,
    SHADOW = 3,
    DISCONNECTED = 4,
    IDLE = 5,
    LISTEN = 6,
    RESET = 7,
    DOWN = 8,
    INIT = 9,
    MAX = 10,
};
pub const STATE_INVALID = TSSESSION_STATE.INVALID;
pub const STATE_ACTIVE = TSSESSION_STATE.ACTIVE;
pub const STATE_CONNECTED = TSSESSION_STATE.CONNECTED;
pub const STATE_CONNECTQUERY = TSSESSION_STATE.CONNECTQUERY;
pub const STATE_SHADOW = TSSESSION_STATE.SHADOW;
pub const STATE_DISCONNECTED = TSSESSION_STATE.DISCONNECTED;
pub const STATE_IDLE = TSSESSION_STATE.IDLE;
pub const STATE_LISTEN = TSSESSION_STATE.LISTEN;
pub const STATE_RESET = TSSESSION_STATE.RESET;
pub const STATE_DOWN = TSSESSION_STATE.DOWN;
pub const STATE_INIT = TSSESSION_STATE.INIT;
pub const STATE_MAX = TSSESSION_STATE.MAX;

pub const TARGET_OWNER = enum(i32) {
    UNKNOWN = 0,
    MS_TS_PLUGIN = 1,
    MS_VM_PLUGIN = 2,
};
pub const OWNER_UNKNOWN = TARGET_OWNER.UNKNOWN;
pub const OWNER_MS_TS_PLUGIN = TARGET_OWNER.MS_TS_PLUGIN;
pub const OWNER_MS_VM_PLUGIN = TARGET_OWNER.MS_VM_PLUGIN;

pub const CLIENT_DISPLAY = extern struct {
    HorizontalResolution: u32,
    VerticalResolution: u32,
    ColorDepth: u32,
};

pub const TSSD_ConnectionPoint = extern struct {
    ServerAddressB: [16]u8,
    AddressType: TSSD_AddrV46Type,
    PortNumber: u16,
    AddressScope: u32,
};

pub const VM_NOTIFY_STATUS = enum(i32) {
    PENDING = 0,
    IN_PROGRESS = 1,
    COMPLETE = 2,
    FAILED = 3,
    CANCELED = 4,
};
pub const VM_NOTIFY_STATUS_PENDING = VM_NOTIFY_STATUS.PENDING;
pub const VM_NOTIFY_STATUS_IN_PROGRESS = VM_NOTIFY_STATUS.IN_PROGRESS;
pub const VM_NOTIFY_STATUS_COMPLETE = VM_NOTIFY_STATUS.COMPLETE;
pub const VM_NOTIFY_STATUS_FAILED = VM_NOTIFY_STATUS.FAILED;
pub const VM_NOTIFY_STATUS_CANCELED = VM_NOTIFY_STATUS.CANCELED;

pub const VM_NOTIFY_ENTRY = extern struct {
    VmName: [128]u16,
    VmHost: [128]u16,
};

pub const VM_PATCH_INFO = extern struct {
    dwNumEntries: u32,
    pVmNames: ?*?PWSTR,
};

pub const VM_NOTIFY_INFO = extern struct {
    dwNumEntries: u32,
    ppVmEntries: ?*?*VM_NOTIFY_ENTRY,
};

pub const VM_HOST_NOTIFY_STATUS = enum(i32) {
    PENDING = 0,
    IN_PROGRESS = 1,
    COMPLETE = 2,
    FAILED = 3,
};
pub const VM_HOST_STATUS_INIT_PENDING = VM_HOST_NOTIFY_STATUS.PENDING;
pub const VM_HOST_STATUS_INIT_IN_PROGRESS = VM_HOST_NOTIFY_STATUS.IN_PROGRESS;
pub const VM_HOST_STATUS_INIT_COMPLETE = VM_HOST_NOTIFY_STATUS.COMPLETE;
pub const VM_HOST_STATUS_INIT_FAILED = VM_HOST_NOTIFY_STATUS.FAILED;

pub const RDV_TASK_STATUS = enum(i32) {
    UNKNOWN = 0,
    SEARCHING = 1,
    DOWNLOADING = 2,
    APPLYING = 3,
    REBOOTING = 4,
    REBOOTED = 5,
    SUCCESS = 6,
    FAILED = 7,
    TIMEOUT = 8,
};
pub const RDV_TASK_STATUS_UNKNOWN = RDV_TASK_STATUS.UNKNOWN;
pub const RDV_TASK_STATUS_SEARCHING = RDV_TASK_STATUS.SEARCHING;
pub const RDV_TASK_STATUS_DOWNLOADING = RDV_TASK_STATUS.DOWNLOADING;
pub const RDV_TASK_STATUS_APPLYING = RDV_TASK_STATUS.APPLYING;
pub const RDV_TASK_STATUS_REBOOTING = RDV_TASK_STATUS.REBOOTING;
pub const RDV_TASK_STATUS_REBOOTED = RDV_TASK_STATUS.REBOOTED;
pub const RDV_TASK_STATUS_SUCCESS = RDV_TASK_STATUS.SUCCESS;
pub const RDV_TASK_STATUS_FAILED = RDV_TASK_STATUS.FAILED;
pub const RDV_TASK_STATUS_TIMEOUT = RDV_TASK_STATUS.TIMEOUT;

pub const TS_SB_SORT_BY = enum(i32) {
    NONE = 0,
    NAME = 1,
    PROP = 2,
};
pub const TS_SB_SORT_BY_NONE = TS_SB_SORT_BY.NONE;
pub const TS_SB_SORT_BY_NAME = TS_SB_SORT_BY.NAME;
pub const TS_SB_SORT_BY_PROP = TS_SB_SORT_BY.PROP;

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPlugin_Value = Guid.initString("48cd7406-caab-465f-a5d6-baa863b9ea4f");
pub const IID_ITsSbPlugin = &IID_ITsSbPlugin_Value;
pub const ITsSbPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPlugin,
                pProvider: ?*ITsSbProvider,
                pNotifySink: ?*ITsSbPluginNotifySink,
                pPropertySet: ?*ITsSbPluginPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPlugin,
                pProvider: ?*ITsSbProvider,
                pNotifySink: ?*ITsSbPluginNotifySink,
                pPropertySet: ?*ITsSbPluginPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPlugin,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPlugin,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPlugin_Initialize(self: *const T, pProvider: ?*ITsSbProvider, pNotifySink: ?*ITsSbPluginNotifySink, pPropertySet: ?*ITsSbPluginPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPlugin.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITsSbPlugin, @ptrCast(self)), pProvider, pNotifySink, pPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPlugin_Terminate(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPlugin.VTable, @ptrCast(self.vtable)).Terminate(@as(*const ITsSbPlugin, @ptrCast(self)), hr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbResourcePlugin_Value = Guid.initString("ea8db42c-98ed-4535-a88b-2a164f35490f");
pub const IID_ITsSbResourcePlugin = &IID_ITsSbResourcePlugin_Value;
pub const ITsSbResourcePlugin = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbServiceNotification_Value = Guid.initString("86cb68ae-86e0-4f57-8a64-bb7406bc5550");
pub const IID_ITsSbServiceNotification = &IID_ITsSbServiceNotification_Value;
pub const ITsSbServiceNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyServiceFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbServiceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbServiceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyServiceSuccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbServiceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbServiceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbServiceNotification_NotifyServiceFailure(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITsSbServiceNotification.VTable, @ptrCast(self.vtable)).NotifyServiceFailure(@as(*const ITsSbServiceNotification, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbServiceNotification_NotifyServiceSuccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITsSbServiceNotification.VTable, @ptrCast(self.vtable)).NotifyServiceSuccess(@as(*const ITsSbServiceNotification, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbLoadBalancing_Value = Guid.initString("24329274-9eb7-11dc-ae98-f2b456d89593");
pub const IID_ITsSbLoadBalancing = &IID_ITsSbLoadBalancing_Value;
pub const ITsSbLoadBalancing = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
        GetMostSuitableTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbLoadBalancing,
                pConnection: ?*ITsSbClientConnection,
                pLBSink: ?*ITsSbLoadBalancingNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbLoadBalancing,
                pConnection: ?*ITsSbClientConnection,
                pLBSink: ?*ITsSbLoadBalancingNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbLoadBalancing_GetMostSuitableTarget(self: *const T, pConnection: ?*ITsSbClientConnection, pLBSink: ?*ITsSbLoadBalancingNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbLoadBalancing.VTable, @ptrCast(self.vtable)).GetMostSuitableTarget(@as(*const ITsSbLoadBalancing, @ptrCast(self)), pConnection, pLBSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPlacement_Value = Guid.initString("daadee5f-6d32-480e-9e36-ddab2329f06d");
pub const IID_ITsSbPlacement = &IID_ITsSbPlacement_Value;
pub const ITsSbPlacement = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
        QueryEnvironmentForTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPlacement,
                pConnection: ?*ITsSbClientConnection,
                pPlacementSink: ?*ITsSbPlacementNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPlacement,
                pConnection: ?*ITsSbClientConnection,
                pPlacementSink: ?*ITsSbPlacementNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPlacement_QueryEnvironmentForTarget(self: *const T, pConnection: ?*ITsSbClientConnection, pPlacementSink: ?*ITsSbPlacementNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPlacement.VTable, @ptrCast(self.vtable)).QueryEnvironmentForTarget(@as(*const ITsSbPlacement, @ptrCast(self)), pConnection, pPlacementSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbOrchestration_Value = Guid.initString("64fc1172-9eb7-11dc-8b00-3aba56d89593");
pub const IID_ITsSbOrchestration = &IID_ITsSbOrchestration_Value;
pub const ITsSbOrchestration = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
        PrepareTargetForConnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbOrchestration,
                pConnection: ?*ITsSbClientConnection,
                pOrchestrationNotifySink: ?*ITsSbOrchestrationNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbOrchestration,
                pConnection: ?*ITsSbClientConnection,
                pOrchestrationNotifySink: ?*ITsSbOrchestrationNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbOrchestration_PrepareTargetForConnect(self: *const T, pConnection: ?*ITsSbClientConnection, pOrchestrationNotifySink: ?*ITsSbOrchestrationNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbOrchestration.VTable, @ptrCast(self.vtable)).PrepareTargetForConnect(@as(*const ITsSbOrchestration, @ptrCast(self)), pConnection, pOrchestrationNotifySink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbEnvironment_Value = Guid.initString("8c87f7f7-bf51-4a5c-87bf-8e94fb6e2256");
pub const IID_ITsSbEnvironment = &IID_ITsSbEnvironment_Value;
pub const ITsSbEnvironment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbEnvironment,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbEnvironment,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServerWeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbEnvironment,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbEnvironment,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnvironmentPropertySet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbEnvironment,
                ppPropertySet: ?*?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbEnvironment,
                ppPropertySet: ?*?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnvironmentPropertySet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbEnvironment,
                pVal: ?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbEnvironment,
                pVal: ?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbEnvironment_get_Name(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbEnvironment.VTable, @ptrCast(self.vtable)).get_Name(@as(*const ITsSbEnvironment, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbEnvironment_get_ServerWeight(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbEnvironment.VTable, @ptrCast(self.vtable)).get_ServerWeight(@as(*const ITsSbEnvironment, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbEnvironment_get_EnvironmentPropertySet(self: *const T, ppPropertySet: ?*?*ITsSbEnvironmentPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbEnvironment.VTable, @ptrCast(self.vtable)).get_EnvironmentPropertySet(@as(*const ITsSbEnvironment, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbEnvironment_put_EnvironmentPropertySet(self: *const T, pVal: ?*ITsSbEnvironmentPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbEnvironment.VTable, @ptrCast(self.vtable)).put_EnvironmentPropertySet(@as(*const ITsSbEnvironment, @ptrCast(self)), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbLoadBalanceResult_Value = Guid.initString("24fdb7ac-fea6-11dc-9672-9a8956d89593");
pub const IID_ITsSbLoadBalanceResult = &IID_ITsSbLoadBalanceResult_Value;
pub const ITsSbLoadBalanceResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbLoadBalanceResult,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbLoadBalanceResult,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbLoadBalanceResult_get_TargetName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbLoadBalanceResult.VTable, @ptrCast(self.vtable)).get_TargetName(@as(*const ITsSbLoadBalanceResult, @ptrCast(self)), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbTarget_Value = Guid.initString("16616ecc-272d-411d-b324-126893033856");
pub const IID_ITsSbTarget = &IID_ITsSbTarget_Value;
pub const ITsSbTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FarmName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FarmName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetFQDN: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                TargetFqdnName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                TargetFqdnName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetFQDN: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetNetbios: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                TargetNetbiosName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                TargetNetbiosName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetNetbios: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                SOCKADDR: [*]TSSD_ConnectionPoint,
                numAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                SOCKADDR: [*]TSSD_ConnectionPoint,
                numAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpAddresses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                SOCKADDR: [*]TSSD_ConnectionPoint,
                numAddresses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                SOCKADDR: [*]TSSD_ConnectionPoint,
                numAddresses: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                State: TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                State: TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetPropertySet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                ppPropertySet: ?*?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                ppPropertySet: ?*?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetPropertySet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pVal: ?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pVal: ?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnvironmentName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnvironmentName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumSessions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pNumSessions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pNumSessions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumPendingConnections: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pNumPendingConnections: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pNumPendingConnections: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetLoad: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTarget,
                pTargetLoad: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTarget,
                pTargetLoad: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetName(@as(*const ITsSbTarget, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_TargetName(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_TargetName(@as(*const ITsSbTarget, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_FarmName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_FarmName(@as(*const ITsSbTarget, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_FarmName(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_FarmName(@as(*const ITsSbTarget, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetFQDN(self: *const T, TargetFqdnName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetFQDN(@as(*const ITsSbTarget, @ptrCast(self)), TargetFqdnName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_TargetFQDN(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_TargetFQDN(@as(*const ITsSbTarget, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetNetbios(self: *const T, TargetNetbiosName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetNetbios(@as(*const ITsSbTarget, @ptrCast(self)), TargetNetbiosName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_TargetNetbios(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_TargetNetbios(@as(*const ITsSbTarget, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_IpAddresses(self: *const T, SOCKADDR: [*]TSSD_ConnectionPoint, numAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_IpAddresses(@as(*const ITsSbTarget, @ptrCast(self)), SOCKADDR, numAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_IpAddresses(self: *const T, SOCKADDR: [*]TSSD_ConnectionPoint, numAddresses: u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_IpAddresses(@as(*const ITsSbTarget, @ptrCast(self)), SOCKADDR, numAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetState(self: *const T, pState: ?*TARGET_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetState(@as(*const ITsSbTarget, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_TargetState(self: *const T, State: TARGET_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_TargetState(@as(*const ITsSbTarget, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetPropertySet(self: *const T, ppPropertySet: ?*?*ITsSbTargetPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetPropertySet(@as(*const ITsSbTarget, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_TargetPropertySet(self: *const T, pVal: ?*ITsSbTargetPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_TargetPropertySet(@as(*const ITsSbTarget, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_EnvironmentName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_EnvironmentName(@as(*const ITsSbTarget, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_put_EnvironmentName(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).put_EnvironmentName(@as(*const ITsSbTarget, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_NumSessions(self: *const T, pNumSessions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_NumSessions(@as(*const ITsSbTarget, @ptrCast(self)), pNumSessions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_NumPendingConnections(self: *const T, pNumPendingConnections: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_NumPendingConnections(@as(*const ITsSbTarget, @ptrCast(self)), pNumPendingConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTarget_get_TargetLoad(self: *const T, pTargetLoad: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTarget.VTable, @ptrCast(self.vtable)).get_TargetLoad(@as(*const ITsSbTarget, @ptrCast(self)), pTargetLoad);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbSession_Value = Guid.initString("d453aac7-b1d8-4c5e-ba34-9afb4c8c5510");
pub const IID_ITsSbSession = &IID_ITsSbSession_Value;
pub const ITsSbSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                targetName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                targetName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TargetName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                targetName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                targetName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Username: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                userName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                userName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Domain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                domain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                domain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pState: ?*TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pState: ?*TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                State: TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                State: TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreateTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreateTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                Time: FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                Time: FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisconnectTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisconnectTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                Time: FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                Time: FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialProgram: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                app: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                app: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialProgram: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                Application: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                Application: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientDisplay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pClientDisplay: ?*CLIENT_DISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pClientDisplay: ?*CLIENT_DISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientDisplay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pClientDisplay: CLIENT_DISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pClientDisplay: CLIENT_DISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProtocolType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProtocolType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbSession,
                Val: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbSession,
                Val: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_SessionId(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_SessionId(@as(*const ITsSbSession, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_TargetName(self: *const T, targetName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_TargetName(@as(*const ITsSbSession, @ptrCast(self)), targetName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_TargetName(self: *const T, targetName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_TargetName(@as(*const ITsSbSession, @ptrCast(self)), targetName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_Username(self: *const T, userName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_Username(@as(*const ITsSbSession, @ptrCast(self)), userName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_Domain(self: *const T, domain: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_Domain(@as(*const ITsSbSession, @ptrCast(self)), domain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_State(self: *const T, pState: ?*TSSESSION_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_State(@as(*const ITsSbSession, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_State(self: *const T, State: TSSESSION_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_State(@as(*const ITsSbSession, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_CreateTime(self: *const T, pTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_CreateTime(@as(*const ITsSbSession, @ptrCast(self)), pTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_CreateTime(self: *const T, Time: FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_CreateTime(@as(*const ITsSbSession, @ptrCast(self)), Time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_DisconnectTime(self: *const T, pTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_DisconnectTime(@as(*const ITsSbSession, @ptrCast(self)), pTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_DisconnectTime(self: *const T, Time: FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_DisconnectTime(@as(*const ITsSbSession, @ptrCast(self)), Time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_InitialProgram(self: *const T, app: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_InitialProgram(@as(*const ITsSbSession, @ptrCast(self)), app);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_InitialProgram(self: *const T, Application: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_InitialProgram(@as(*const ITsSbSession, @ptrCast(self)), Application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_ClientDisplay(self: *const T, pClientDisplay: ?*CLIENT_DISPLAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_ClientDisplay(@as(*const ITsSbSession, @ptrCast(self)), pClientDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_ClientDisplay(self: *const T, pClientDisplay: CLIENT_DISPLAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_ClientDisplay(@as(*const ITsSbSession, @ptrCast(self)), pClientDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_get_ProtocolType(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).get_ProtocolType(@as(*const ITsSbSession, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbSession_put_ProtocolType(self: *const T, Val: u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbSession.VTable, @ptrCast(self.vtable)).put_ProtocolType(@as(*const ITsSbSession, @ptrCast(self)), Val);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbResourceNotification_Value = Guid.initString("65d3e85a-c39b-11dc-b92d-3cd255d89593");
pub const IID_ITsSbResourceNotification = &IID_ITsSbResourceNotification_Value;
pub const ITsSbResourceNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifySessionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotification,
                changeType: TSSESSION_STATE,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotification,
                changeType: TSSESSION_STATE,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyTargetChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotification,
                TargetChangeType: u32,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotification,
                TargetChangeType: u32,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyClientConnectionStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotification,
                ChangeType: CONNECTION_CHANGE_NOTIFICATION,
                pConnection: ?*ITsSbClientConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotification,
                ChangeType: CONNECTION_CHANGE_NOTIFICATION,
                pConnection: ?*ITsSbClientConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotification_NotifySessionChange(self: *const T, changeType: TSSESSION_STATE, pSession: ?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotification.VTable, @ptrCast(self.vtable)).NotifySessionChange(@as(*const ITsSbResourceNotification, @ptrCast(self)), changeType, pSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotification_NotifyTargetChange(self: *const T, TargetChangeType: u32, pTarget: ?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotification.VTable, @ptrCast(self.vtable)).NotifyTargetChange(@as(*const ITsSbResourceNotification, @ptrCast(self)), TargetChangeType, pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotification_NotifyClientConnectionStateChange(self: *const T, ChangeType: CONNECTION_CHANGE_NOTIFICATION, pConnection: ?*ITsSbClientConnection) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotification.VTable, @ptrCast(self.vtable)).NotifyClientConnectionStateChange(@as(*const ITsSbResourceNotification, @ptrCast(self)), ChangeType, pConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbResourceNotificationEx_Value = Guid.initString("a8a47fde-ca91-44d2-b897-3aa28a43b2b7");
pub const IID_ITsSbResourceNotificationEx = &IID_ITsSbResourceNotificationEx_Value;
pub const ITsSbResourceNotificationEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifySessionChangeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotificationEx,
                targetName: ?BSTR,
                userName: ?BSTR,
                domain: ?BSTR,
                sessionId: u32,
                sessionState: TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotificationEx,
                targetName: ?BSTR,
                userName: ?BSTR,
                domain: ?BSTR,
                sessionId: u32,
                sessionState: TSSESSION_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyTargetChangeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotificationEx,
                targetName: ?BSTR,
                targetChangeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotificationEx,
                targetName: ?BSTR,
                targetChangeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyClientConnectionStateChangeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourceNotificationEx,
                userName: ?BSTR,
                domain: ?BSTR,
                initialProgram: ?BSTR,
                poolName: ?BSTR,
                targetName: ?BSTR,
                connectionChangeType: CONNECTION_CHANGE_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourceNotificationEx,
                userName: ?BSTR,
                domain: ?BSTR,
                initialProgram: ?BSTR,
                poolName: ?BSTR,
                targetName: ?BSTR,
                connectionChangeType: CONNECTION_CHANGE_NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotificationEx_NotifySessionChangeEx(self: *const T, targetName: ?BSTR, userName: ?BSTR, domain: ?BSTR, sessionId: u32, sessionState: TSSESSION_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotificationEx.VTable, @ptrCast(self.vtable)).NotifySessionChangeEx(@as(*const ITsSbResourceNotificationEx, @ptrCast(self)), targetName, userName, domain, sessionId, sessionState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotificationEx_NotifyTargetChangeEx(self: *const T, targetName: ?BSTR, targetChangeType: u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotificationEx.VTable, @ptrCast(self.vtable)).NotifyTargetChangeEx(@as(*const ITsSbResourceNotificationEx, @ptrCast(self)), targetName, targetChangeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourceNotificationEx_NotifyClientConnectionStateChangeEx(self: *const T, userName: ?BSTR, domain: ?BSTR, initialProgram: ?BSTR, poolName: ?BSTR, targetName: ?BSTR, connectionChangeType: CONNECTION_CHANGE_NOTIFICATION) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourceNotificationEx.VTable, @ptrCast(self.vtable)).NotifyClientConnectionStateChangeEx(@as(*const ITsSbResourceNotificationEx, @ptrCast(self)), userName, domain, initialProgram, poolName, targetName, connectionChangeType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbTaskInfo_Value = Guid.initString("523d1083-89be-48dd-99ea-04e82ffa7265");
pub const IID_ITsSbTaskInfo = &IID_ITsSbTaskInfo_Value;
pub const ITsSbTaskInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pStartTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pStartTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pEndTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pEndTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Deadline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pDeadline: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pDeadline: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Identifier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Label: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pLabel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pLabel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Context: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pContext: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pContext: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Plugin: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pPlugin: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pPlugin: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbTaskInfo,
                pStatus: ?*RDV_TASK_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbTaskInfo,
                pStatus: ?*RDV_TASK_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_TargetId(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_TargetId(@as(*const ITsSbTaskInfo, @ptrCast(self)), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_StartTime(self: *const T, pStartTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_StartTime(@as(*const ITsSbTaskInfo, @ptrCast(self)), pStartTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_EndTime(self: *const T, pEndTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_EndTime(@as(*const ITsSbTaskInfo, @ptrCast(self)), pEndTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Deadline(self: *const T, pDeadline: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Deadline(@as(*const ITsSbTaskInfo, @ptrCast(self)), pDeadline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Identifier(self: *const T, pIdentifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Identifier(@as(*const ITsSbTaskInfo, @ptrCast(self)), pIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Label(self: *const T, pLabel: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Label(@as(*const ITsSbTaskInfo, @ptrCast(self)), pLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Context(self: *const T, pContext: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Context(@as(*const ITsSbTaskInfo, @ptrCast(self)), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Plugin(self: *const T, pPlugin: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Plugin(@as(*const ITsSbTaskInfo, @ptrCast(self)), pPlugin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskInfo_get_Status(self: *const T, pStatus: ?*RDV_TASK_STATUS) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskInfo.VTable, @ptrCast(self.vtable)).get_Status(@as(*const ITsSbTaskInfo, @ptrCast(self)), pStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbTaskPlugin_Value = Guid.initString("fa22ef0f-8705-41be-93bc-44bdbcf1c9c4");
pub const IID_ITsSbTaskPlugin = &IID_ITsSbTaskPlugin_Value;
pub const ITsSbTaskPlugin = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
        InitializeTaskPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPlugin,
                pITsSbTaskPluginNotifySink: ?*ITsSbTaskPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPlugin,
                pITsSbTaskPluginNotifySink: ?*ITsSbTaskPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTaskQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPlugin,
                pszHostName: ?BSTR,
                SbTaskInfoSize: u32,
                pITsSbTaskInfo: [*]?*ITsSbTaskInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPlugin,
                pszHostName: ?BSTR,
                SbTaskInfoSize: u32,
                pITsSbTaskInfo: [*]?*ITsSbTaskInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPlugin_InitializeTaskPlugin(self: *const T, pITsSbTaskPluginNotifySink: ?*ITsSbTaskPluginNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPlugin.VTable, @ptrCast(self.vtable)).InitializeTaskPlugin(@as(*const ITsSbTaskPlugin, @ptrCast(self)), pITsSbTaskPluginNotifySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPlugin_SetTaskQueue(self: *const T, pszHostName: ?BSTR, SbTaskInfoSize: u32, pITsSbTaskInfo: [*]?*ITsSbTaskInfo) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPlugin.VTable, @ptrCast(self.vtable)).SetTaskQueue(@as(*const ITsSbTaskPlugin, @ptrCast(self)), pszHostName, SbTaskInfoSize, pITsSbTaskInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPropertySet_Value = Guid.initString("5c025171-bb1e-4baf-a212-6d5e9774b33b");
pub const IID_ITsSbPropertySet = &IID_ITsSbPropertySet_Value;
pub const ITsSbPropertySet = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyBag.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPluginPropertySet_Value = Guid.initString("95006e34-7eff-4b6c-bb40-49a4fda7cea6");
pub const IID_ITsSbPluginPropertySet = &IID_ITsSbPluginPropertySet_Value;
pub const ITsSbPluginPropertySet = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPropertySet.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPropertySet.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbClientConnectionPropertySet_Value = Guid.initString("e51995b0-46d6-11dd-aa21-cedc55d89593");
pub const IID_ITsSbClientConnectionPropertySet = &IID_ITsSbClientConnectionPropertySet_Value;
pub const ITsSbClientConnectionPropertySet = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPropertySet.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPropertySet.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbTargetPropertySet_Value = Guid.initString("f7bda5d6-994c-4e11-a079-2763b61830ac");
pub const IID_ITsSbTargetPropertySet = &IID_ITsSbTargetPropertySet_Value;
pub const ITsSbTargetPropertySet = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPropertySet.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPropertySet.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbEnvironmentPropertySet_Value = Guid.initString("d0d1bf7e-7acf-11dd-a243-e51156d89593");
pub const IID_ITsSbEnvironmentPropertySet = &IID_ITsSbEnvironmentPropertySet_Value;
pub const ITsSbEnvironmentPropertySet = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPropertySet.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPropertySet.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbBaseNotifySink_Value = Guid.initString("808a6537-1282-4989-9e09-f43938b71722");
pub const IID_ITsSbBaseNotifySink = &IID_ITsSbBaseNotifySink_Value;
pub const ITsSbBaseNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbBaseNotifySink,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbBaseNotifySink,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnReportStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbBaseNotifySink,
                messageType: CLIENT_MESSAGE_TYPE,
                messageID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbBaseNotifySink,
                messageType: CLIENT_MESSAGE_TYPE,
                messageID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbBaseNotifySink_OnError(self: *const T, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbBaseNotifySink.VTable, @ptrCast(self.vtable)).OnError(@as(*const ITsSbBaseNotifySink, @ptrCast(self)), hrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbBaseNotifySink_OnReportStatus(self: *const T, messageType: CLIENT_MESSAGE_TYPE, messageID: u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbBaseNotifySink.VTable, @ptrCast(self.vtable)).OnReportStatus(@as(*const ITsSbBaseNotifySink, @ptrCast(self)), messageType, messageID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPluginNotifySink_Value = Guid.initString("44dfe30b-c3be-40f5-bf82-7a95bb795adf");
pub const IID_ITsSbPluginNotifySink = &IID_ITsSbPluginNotifySink_Value;
pub const ITsSbPluginNotifySink = extern struct {
    pub const VTable = extern struct {
        base: ITsSbBaseNotifySink.VTable,
        OnInitialized: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPluginNotifySink,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPluginNotifySink,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTerminated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbBaseNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPluginNotifySink_OnInitialized(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPluginNotifySink.VTable, @ptrCast(self.vtable)).OnInitialized(@as(*const ITsSbPluginNotifySink, @ptrCast(self)), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPluginNotifySink_OnTerminated(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPluginNotifySink.VTable, @ptrCast(self.vtable)).OnTerminated(@as(*const ITsSbPluginNotifySink, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbLoadBalancingNotifySink_Value = Guid.initString("5f8a8297-3244-4e6a-958a-27c822c1e141");
pub const IID_ITsSbLoadBalancingNotifySink = &IID_ITsSbLoadBalancingNotifySink_Value;
pub const ITsSbLoadBalancingNotifySink = extern struct {
    pub const VTable = extern struct {
        base: ITsSbBaseNotifySink.VTable,
        OnGetMostSuitableTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbLoadBalancingNotifySink,
                pLBResult: ?*ITsSbLoadBalanceResult,
                fIsNewConnection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbLoadBalancingNotifySink,
                pLBResult: ?*ITsSbLoadBalanceResult,
                fIsNewConnection: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbBaseNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbLoadBalancingNotifySink_OnGetMostSuitableTarget(self: *const T, pLBResult: ?*ITsSbLoadBalanceResult, fIsNewConnection: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITsSbLoadBalancingNotifySink.VTable, @ptrCast(self.vtable)).OnGetMostSuitableTarget(@as(*const ITsSbLoadBalancingNotifySink, @ptrCast(self)), pLBResult, fIsNewConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbPlacementNotifySink_Value = Guid.initString("68a0c487-2b4f-46c2-94a1-6ce685183634");
pub const IID_ITsSbPlacementNotifySink = &IID_ITsSbPlacementNotifySink_Value;
pub const ITsSbPlacementNotifySink = extern struct {
    pub const VTable = extern struct {
        base: ITsSbBaseNotifySink.VTable,
        OnQueryEnvironmentCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbPlacementNotifySink,
                pEnvironment: ?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbPlacementNotifySink,
                pEnvironment: ?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbBaseNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbPlacementNotifySink_OnQueryEnvironmentCompleted(self: *const T, pEnvironment: ?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbPlacementNotifySink.VTable, @ptrCast(self.vtable)).OnQueryEnvironmentCompleted(@as(*const ITsSbPlacementNotifySink, @ptrCast(self)), pEnvironment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbOrchestrationNotifySink_Value = Guid.initString("36c37d61-926b-442f-bca5-118c6d50dcf2");
pub const IID_ITsSbOrchestrationNotifySink = &IID_ITsSbOrchestrationNotifySink_Value;
pub const ITsSbOrchestrationNotifySink = extern struct {
    pub const VTable = extern struct {
        base: ITsSbBaseNotifySink.VTable,
        OnReadyToConnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbOrchestrationNotifySink,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbOrchestrationNotifySink,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbBaseNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbOrchestrationNotifySink_OnReadyToConnect(self: *const T, pTarget: ?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbOrchestrationNotifySink.VTable, @ptrCast(self.vtable)).OnReadyToConnect(@as(*const ITsSbOrchestrationNotifySink, @ptrCast(self)), pTarget);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbTaskPluginNotifySink_Value = Guid.initString("6aaf899e-c2ec-45ee-aa37-45e60895261a");
pub const IID_ITsSbTaskPluginNotifySink = &IID_ITsSbTaskPluginNotifySink_Value;
pub const ITsSbTaskPluginNotifySink = extern struct {
    pub const VTable = extern struct {
        base: ITsSbBaseNotifySink.VTable,
        OnSetTaskTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                TaskStartTime: FILETIME,
                TaskEndTime: FILETIME,
                TaskDeadline: FILETIME,
                szTaskLabel: ?BSTR,
                szTaskIdentifier: ?BSTR,
                szTaskPlugin: ?BSTR,
                dwTaskStatus: u32,
                saContext: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                TaskStartTime: FILETIME,
                TaskEndTime: FILETIME,
                TaskDeadline: FILETIME,
                szTaskLabel: ?BSTR,
                szTaskIdentifier: ?BSTR,
                szTaskPlugin: ?BSTR,
                dwTaskStatus: u32,
                saContext: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDeleteTaskTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                szTaskIdentifier: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                szTaskIdentifier: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUpdateTaskStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                TaskIdentifier: ?BSTR,
                TaskStatus: RDV_TASK_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPluginNotifySink,
                szTargetName: ?BSTR,
                TaskIdentifier: ?BSTR,
                TaskStatus: RDV_TASK_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnReportTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbTaskPluginNotifySink,
                szHostName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbTaskPluginNotifySink,
                szHostName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbBaseNotifySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPluginNotifySink_OnSetTaskTime(self: *const T, szTargetName: ?BSTR, TaskStartTime: FILETIME, TaskEndTime: FILETIME, TaskDeadline: FILETIME, szTaskLabel: ?BSTR, szTaskIdentifier: ?BSTR, szTaskPlugin: ?BSTR, dwTaskStatus: u32, saContext: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPluginNotifySink.VTable, @ptrCast(self.vtable)).OnSetTaskTime(@as(*const ITsSbTaskPluginNotifySink, @ptrCast(self)), szTargetName, TaskStartTime, TaskEndTime, TaskDeadline, szTaskLabel, szTaskIdentifier, szTaskPlugin, dwTaskStatus, saContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPluginNotifySink_OnDeleteTaskTime(self: *const T, szTargetName: ?BSTR, szTaskIdentifier: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPluginNotifySink.VTable, @ptrCast(self.vtable)).OnDeleteTaskTime(@as(*const ITsSbTaskPluginNotifySink, @ptrCast(self)), szTargetName, szTaskIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPluginNotifySink_OnUpdateTaskStatus(self: *const T, szTargetName: ?BSTR, TaskIdentifier: ?BSTR, TaskStatus: RDV_TASK_STATUS) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPluginNotifySink.VTable, @ptrCast(self.vtable)).OnUpdateTaskStatus(@as(*const ITsSbTaskPluginNotifySink, @ptrCast(self)), szTargetName, TaskIdentifier, TaskStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbTaskPluginNotifySink_OnReportTasks(self: *const T, szHostName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbTaskPluginNotifySink.VTable, @ptrCast(self.vtable)).OnReportTasks(@as(*const ITsSbTaskPluginNotifySink, @ptrCast(self)), szHostName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbClientConnection_Value = Guid.initString("18857499-ad61-4b1b-b7df-cbcd41fb8338");
pub const IID_ITsSbClientConnection = &IID_ITsSbClientConnection_Value;
pub const ITsSbClientConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Domain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialProgram: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LoadBalanceResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                ppVal: ?*?*ITsSbLoadBalanceResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                ppVal: ?*?*ITsSbLoadBalanceResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FarmName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                contextId: ?BSTR,
                context: VARIANT,
                existingContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbClientConnection,
                contextId: ?BSTR,
                context: VARIANT,
                existingContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                contextId: ?BSTR,
                context: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbClientConnection,
                contextId: ?BSTR,
                context: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Environment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionError: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SamUserAccount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientConnectionPropertySet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                ppPropertySet: ?*?*ITsSbClientConnectionPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                ppPropertySet: ?*?*ITsSbClientConnectionPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFirstAssignment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                ppVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                ppVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RdFarmType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pRdFarmType: ?*RD_FARM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pRdFarmType: ?*RD_FARM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserSidString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                pszUserSidString: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITsSbClientConnection,
                pszUserSidString: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisconnectedSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbClientConnection,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbClientConnection,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_UserName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_UserName(@as(*const ITsSbClientConnection, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_Domain(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_Domain(@as(*const ITsSbClientConnection, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_InitialProgram(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_InitialProgram(@as(*const ITsSbClientConnection, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_LoadBalanceResult(self: *const T, ppVal: ?*?*ITsSbLoadBalanceResult) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_LoadBalanceResult(@as(*const ITsSbClientConnection, @ptrCast(self)), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_FarmName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_FarmName(@as(*const ITsSbClientConnection, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_PutContext(self: *const T, contextId: ?BSTR, context: VARIANT, existingContext: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).PutContext(@as(*const ITsSbClientConnection, @ptrCast(self)), contextId, context, existingContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_GetContext(self: *const T, contextId: ?BSTR, context: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).GetContext(@as(*const ITsSbClientConnection, @ptrCast(self)), contextId, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_Environment(self: *const T, ppEnvironment: ?*?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_Environment(@as(*const ITsSbClientConnection, @ptrCast(self)), ppEnvironment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_ConnectionError(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_ConnectionError(@as(*const ITsSbClientConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_SamUserAccount(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_SamUserAccount(@as(*const ITsSbClientConnection, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_ClientConnectionPropertySet(self: *const T, ppPropertySet: ?*?*ITsSbClientConnectionPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_ClientConnectionPropertySet(@as(*const ITsSbClientConnection, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_IsFirstAssignment(self: *const T, ppVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_IsFirstAssignment(@as(*const ITsSbClientConnection, @ptrCast(self)), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_RdFarmType(self: *const T, pRdFarmType: ?*RD_FARM_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_RdFarmType(@as(*const ITsSbClientConnection, @ptrCast(self)), pRdFarmType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_get_UserSidString(self: *const T, pszUserSidString: ?*?*i8) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).get_UserSidString(@as(*const ITsSbClientConnection, @ptrCast(self)), pszUserSidString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbClientConnection_GetDisconnectedSession(self: *const T, ppSession: ?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbClientConnection.VTable, @ptrCast(self.vtable)).GetDisconnectedSession(@as(*const ITsSbClientConnection, @ptrCast(self)), ppSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbProvider_Value = Guid.initString("87a4098f-6d7b-44dd-bc17-8ce44e370d52");
pub const IID_ITsSbProvider = &IID_ITsSbProvider_Value;
pub const ITsSbProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTargetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                EnvironmentName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                EnvironmentName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLoadBalanceResultObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                ppLBResult: ?*?*ITsSbLoadBalanceResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                ppLBResult: ?*?*ITsSbLoadBalanceResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSessionObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                UserName: ?BSTR,
                Domain: ?BSTR,
                SessionId: u32,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                TargetName: ?BSTR,
                UserName: ?BSTR,
                Domain: ?BSTR,
                SessionId: u32,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePluginPropertySet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbPluginPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbPluginPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTargetPropertySetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbTargetPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEnvironmentObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                Name: ?BSTR,
                ServerWeight: u32,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                Name: ?BSTR,
                ServerWeight: u32,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourcePluginStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppStore: ?*?*ITsSbResourcePluginStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppStore: ?*?*ITsSbResourcePluginStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterPluginStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppStore: ?*?*ITsSbFilterPluginStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppStore: ?*?*ITsSbFilterPluginStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                notificationType: u32,
                ResourceToMonitor: ?BSTR,
                pPluginNotification: ?*ITsSbResourceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                notificationType: u32,
                ResourceToMonitor: ?BSTR,
                pPluginNotification: ?*ITsSbResourceNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterForNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                notificationType: u32,
                ResourceToMonitor: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                notificationType: u32,
                ResourceToMonitor: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstanceOfGlobalStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppGlobalStore: ?*?*ITsSbGlobalStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppGlobalStore: ?*?*ITsSbGlobalStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEnvironmentPropertySetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvider,
                ppPropertySet: ?*?*ITsSbEnvironmentPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateTargetObject(self: *const T, TargetName: ?BSTR, EnvironmentName: ?BSTR, ppTarget: ?*?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateTargetObject(@as(*const ITsSbProvider, @ptrCast(self)), TargetName, EnvironmentName, ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateLoadBalanceResultObject(self: *const T, TargetName: ?BSTR, ppLBResult: ?*?*ITsSbLoadBalanceResult) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateLoadBalanceResultObject(@as(*const ITsSbProvider, @ptrCast(self)), TargetName, ppLBResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateSessionObject(self: *const T, TargetName: ?BSTR, UserName: ?BSTR, Domain: ?BSTR, SessionId: u32, ppSession: ?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateSessionObject(@as(*const ITsSbProvider, @ptrCast(self)), TargetName, UserName, Domain, SessionId, ppSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreatePluginPropertySet(self: *const T, ppPropertySet: ?*?*ITsSbPluginPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreatePluginPropertySet(@as(*const ITsSbProvider, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateTargetPropertySetObject(self: *const T, ppPropertySet: ?*?*ITsSbTargetPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateTargetPropertySetObject(@as(*const ITsSbProvider, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateEnvironmentObject(self: *const T, Name: ?BSTR, ServerWeight: u32, ppEnvironment: ?*?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateEnvironmentObject(@as(*const ITsSbProvider, @ptrCast(self)), Name, ServerWeight, ppEnvironment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_GetResourcePluginStore(self: *const T, ppStore: ?*?*ITsSbResourcePluginStore) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).GetResourcePluginStore(@as(*const ITsSbProvider, @ptrCast(self)), ppStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_GetFilterPluginStore(self: *const T, ppStore: ?*?*ITsSbFilterPluginStore) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).GetFilterPluginStore(@as(*const ITsSbProvider, @ptrCast(self)), ppStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_RegisterForNotification(self: *const T, notificationType: u32, ResourceToMonitor: ?BSTR, pPluginNotification: ?*ITsSbResourceNotification) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).RegisterForNotification(@as(*const ITsSbProvider, @ptrCast(self)), notificationType, ResourceToMonitor, pPluginNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_UnRegisterForNotification(self: *const T, notificationType: u32, ResourceToMonitor: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).UnRegisterForNotification(@as(*const ITsSbProvider, @ptrCast(self)), notificationType, ResourceToMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_GetInstanceOfGlobalStore(self: *const T, ppGlobalStore: ?*?*ITsSbGlobalStore) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).GetInstanceOfGlobalStore(@as(*const ITsSbProvider, @ptrCast(self)), ppGlobalStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvider_CreateEnvironmentPropertySetObject(self: *const T, ppPropertySet: ?*?*ITsSbEnvironmentPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvider.VTable, @ptrCast(self.vtable)).CreateEnvironmentPropertySetObject(@as(*const ITsSbProvider, @ptrCast(self)), ppPropertySet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbResourcePluginStore_Value = Guid.initString("5c38f65f-bcf1-4036-a6bf-9e3cccae0b63");
pub const IID_ITsSbResourcePluginStore = &IID_ITsSbResourcePluginStore_Value;
pub const ITsSbResourcePluginStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                TargetName: ?BSTR,
                FarmName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                TargetName: ?BSTR,
                FarmName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySessionBySessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                dwSessionId: u32,
                TargetName: ?BSTR,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                dwSessionId: u32,
                TargetName: ?BSTR,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTargetToStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSessionToStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEnvironmentToStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEnvironmentFromStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                bIgnoreOwner: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                bIgnoreOwner: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateFarms: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pdwCount: ?*u32,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pdwCount: ?*u32,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryEnvironment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                ppEnvironment: ?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateEnvironments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
                bForceWrite: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
                bForceWrite: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveEnvironment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
                bForceWrite: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
                bForceWrite: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                TargetName: ?BSTR,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                TargetName: ?BSTR,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironmentProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                EnvironmentName: ?BSTR,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                newState: TARGET_STATE,
                pOldState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                newState: TARGET_STATE,
                pOldState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSessionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                sbSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                sbSession: ?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                FarmName: ?BSTR,
                EnvName: ?BSTR,
                sortByFieldId: TS_SB_SORT_BY,
                sortyByPropName: ?BSTR,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                FarmName: ?BSTR,
                EnvName: ?BSTR,
                sortByFieldId: TS_SB_SORT_BY,
                sortyByPropName: ?BSTR,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSessions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                userName: ?BSTR,
                userDomain: ?BSTR,
                poolName: ?BSTR,
                initialProgram: ?BSTR,
                pSessionState: ?*TSSESSION_STATE,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                userName: ?BSTR,
                userDomain: ?BSTR,
                poolName: ?BSTR,
                initialProgram: ?BSTR,
                pSessionState: ?*TSSESSION_STATE,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFarmProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                farmName: ?BSTR,
                propertyName: ?BSTR,
                pVarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                farmName: ?BSTR,
                propertyName: ?BSTR,
                pVarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                hostName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                hostName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTargetPropertyWithVersionCheck: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pTarget: ?*ITsSbTarget,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironmentPropertyWithVersionCheck: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pEnvironment: ?*ITsSbEnvironment,
                PropertyName: ?BSTR,
                pProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquireTargetLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                dwTimeout: u32,
                ppContext: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                targetName: ?BSTR,
                dwTimeout: u32,
                ppContext: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseTargetLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                pContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                pContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestAndSetServerState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                ServerFQDN: ?BSTR,
                NewState: TARGET_STATE,
                TestState: TARGET_STATE,
                pInitState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                ServerFQDN: ?BSTR,
                NewState: TARGET_STATE,
                TestState: TARGET_STATE,
                pInitState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServerWaitingToStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                serverName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                serverName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServerState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                ServerFQDN: ?BSTR,
                pState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                PoolName: ?BSTR,
                ServerFQDN: ?BSTR,
                pState: ?*TARGET_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServerDrainMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbResourcePluginStore,
                ServerFQDN: ?BSTR,
                DrainMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbResourcePluginStore,
                ServerFQDN: ?BSTR,
                DrainMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_QueryTarget(self: *const T, TargetName: ?BSTR, FarmName: ?BSTR, ppTarget: ?*?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).QueryTarget(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), TargetName, FarmName, ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_QuerySessionBySessionId(self: *const T, dwSessionId: u32, TargetName: ?BSTR, ppSession: ?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).QuerySessionBySessionId(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), dwSessionId, TargetName, ppSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_AddTargetToStore(self: *const T, pTarget: ?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).AddTargetToStore(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_AddSessionToStore(self: *const T, pSession: ?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).AddSessionToStore(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_AddEnvironmentToStore(self: *const T, pEnvironment: ?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).AddEnvironmentToStore(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pEnvironment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_RemoveEnvironmentFromStore(self: *const T, EnvironmentName: ?BSTR, bIgnoreOwner: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).RemoveEnvironmentFromStore(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), EnvironmentName, bIgnoreOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_EnumerateFarms(self: *const T, pdwCount: ?*u32, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).EnumerateFarms(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pdwCount, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_QueryEnvironment(self: *const T, EnvironmentName: ?BSTR, ppEnvironment: ?*?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).QueryEnvironment(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), EnvironmentName, ppEnvironment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_EnumerateEnvironments(self: *const T, pdwCount: ?*u32, pVal: [*]?*?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).EnumerateEnvironments(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pdwCount, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SaveTarget(self: *const T, pTarget: ?*ITsSbTarget, bForceWrite: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SaveTarget(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pTarget, bForceWrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SaveEnvironment(self: *const T, pEnvironment: ?*ITsSbEnvironment, bForceWrite: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SaveEnvironment(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pEnvironment, bForceWrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SaveSession(self: *const T, pSession: ?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SaveSession(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetTargetProperty(self: *const T, TargetName: ?BSTR, PropertyName: ?BSTR, pProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetTargetProperty(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), TargetName, PropertyName, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetEnvironmentProperty(self: *const T, EnvironmentName: ?BSTR, PropertyName: ?BSTR, pProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetEnvironmentProperty(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), EnvironmentName, PropertyName, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetTargetState(self: *const T, targetName: ?BSTR, newState: TARGET_STATE, pOldState: ?*TARGET_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetTargetState(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), targetName, newState, pOldState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetSessionState(self: *const T, sbSession: ?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetSessionState(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), sbSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_EnumerateTargets(self: *const T, FarmName: ?BSTR, EnvName: ?BSTR, sortByFieldId: TS_SB_SORT_BY, sortyByPropName: ?BSTR, pdwCount: ?*u32, pVal: [*]?*?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).EnumerateTargets(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), FarmName, EnvName, sortByFieldId, sortyByPropName, pdwCount, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_EnumerateSessions(self: *const T, targetName: ?BSTR, userName: ?BSTR, userDomain: ?BSTR, poolName: ?BSTR, initialProgram: ?BSTR, pSessionState: ?*TSSESSION_STATE, pdwCount: ?*u32, ppVal: [*]?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).EnumerateSessions(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), targetName, userName, userDomain, poolName, initialProgram, pSessionState, pdwCount, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_GetFarmProperty(self: *const T, farmName: ?BSTR, propertyName: ?BSTR, pVarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).GetFarmProperty(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), farmName, propertyName, pVarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_DeleteTarget(self: *const T, targetName: ?BSTR, hostName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).DeleteTarget(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), targetName, hostName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetTargetPropertyWithVersionCheck(self: *const T, pTarget: ?*ITsSbTarget, PropertyName: ?BSTR, pProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetTargetPropertyWithVersionCheck(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pTarget, PropertyName, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetEnvironmentPropertyWithVersionCheck(self: *const T, pEnvironment: ?*ITsSbEnvironment, PropertyName: ?BSTR, pProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetEnvironmentPropertyWithVersionCheck(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pEnvironment, PropertyName, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_AcquireTargetLock(self: *const T, targetName: ?BSTR, dwTimeout: u32, ppContext: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).AcquireTargetLock(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), targetName, dwTimeout, ppContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_ReleaseTargetLock(self: *const T, pContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).ReleaseTargetLock(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_TestAndSetServerState(self: *const T, PoolName: ?BSTR, ServerFQDN: ?BSTR, NewState: TARGET_STATE, TestState: TARGET_STATE, pInitState: ?*TARGET_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).TestAndSetServerState(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), PoolName, ServerFQDN, NewState, TestState, pInitState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetServerWaitingToStart(self: *const T, PoolName: ?BSTR, serverName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetServerWaitingToStart(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), PoolName, serverName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_GetServerState(self: *const T, PoolName: ?BSTR, ServerFQDN: ?BSTR, pState: ?*TARGET_STATE) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).GetServerState(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), PoolName, ServerFQDN, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbResourcePluginStore_SetServerDrainMode(self: *const T, ServerFQDN: ?BSTR, DrainMode: u32) callconv(.Inline) HRESULT {
            return @as(*const ITsSbResourcePluginStore.VTable, @ptrCast(self.vtable)).SetServerDrainMode(@as(*const ITsSbResourcePluginStore, @ptrCast(self)), ServerFQDN, DrainMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbFilterPluginStore_Value = Guid.initString("85b44b0f-ed78-413f-9702-fa6d3b5ee755");
pub const IID_ITsSbFilterPluginStore = &IID_ITsSbFilterPluginStore_Value;
pub const ITsSbFilterPluginStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SaveProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbFilterPluginStore,
                pPropertySet: ?*ITsSbPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbFilterPluginStore,
                pPropertySet: ?*ITsSbPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbFilterPluginStore,
                ppPropertySet: ?*?*ITsSbPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbFilterPluginStore,
                ppPropertySet: ?*?*ITsSbPropertySet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbFilterPluginStore,
                propertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbFilterPluginStore,
                propertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbFilterPluginStore_SaveProperties(self: *const T, pPropertySet: ?*ITsSbPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbFilterPluginStore.VTable, @ptrCast(self.vtable)).SaveProperties(@as(*const ITsSbFilterPluginStore, @ptrCast(self)), pPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbFilterPluginStore_EnumerateProperties(self: *const T, ppPropertySet: ?*?*ITsSbPropertySet) callconv(.Inline) HRESULT {
            return @as(*const ITsSbFilterPluginStore.VTable, @ptrCast(self.vtable)).EnumerateProperties(@as(*const ITsSbFilterPluginStore, @ptrCast(self)), ppPropertySet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbFilterPluginStore_DeleteProperties(self: *const T, propertyName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbFilterPluginStore.VTable, @ptrCast(self.vtable)).DeleteProperties(@as(*const ITsSbFilterPluginStore, @ptrCast(self)), propertyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbGlobalStore_Value = Guid.initString("9ab60f7b-bd72-4d9f-8a3a-a0ea5574e635");
pub const IID_ITsSbGlobalStore = &IID_ITsSbGlobalStore_Value;
pub const ITsSbGlobalStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                TargetName: ?BSTR,
                FarmName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                TargetName: ?BSTR,
                FarmName: ?BSTR,
                ppTarget: ?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySessionBySessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                dwSessionId: u32,
                TargetName: ?BSTR,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                dwSessionId: u32,
                TargetName: ?BSTR,
                ppSession: ?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateFarms: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                pdwCount: ?*u32,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                pdwCount: ?*u32,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                FarmName: ?BSTR,
                EnvName: ?BSTR,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                FarmName: ?BSTR,
                EnvName: ?BSTR,
                pdwCount: ?*u32,
                pVal: [*]?*?*ITsSbTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateEnvironmentsByProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbEnvironment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateSessions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                targetName: ?BSTR,
                userName: ?BSTR,
                userDomain: ?BSTR,
                poolName: ?BSTR,
                initialProgram: ?BSTR,
                pSessionState: ?*TSSESSION_STATE,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                ProviderName: ?BSTR,
                targetName: ?BSTR,
                userName: ?BSTR,
                userDomain: ?BSTR,
                poolName: ?BSTR,
                initialProgram: ?BSTR,
                pSessionState: ?*TSSESSION_STATE,
                pdwCount: ?*u32,
                ppVal: [*]?*?*ITsSbSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFarmProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGlobalStore,
                farmName: ?BSTR,
                propertyName: ?BSTR,
                pVarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGlobalStore,
                farmName: ?BSTR,
                propertyName: ?BSTR,
                pVarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_QueryTarget(self: *const T, ProviderName: ?BSTR, TargetName: ?BSTR, FarmName: ?BSTR, ppTarget: ?*?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).QueryTarget(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, TargetName, FarmName, ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_QuerySessionBySessionId(self: *const T, ProviderName: ?BSTR, dwSessionId: u32, TargetName: ?BSTR, ppSession: ?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).QuerySessionBySessionId(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, dwSessionId, TargetName, ppSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_EnumerateFarms(self: *const T, ProviderName: ?BSTR, pdwCount: ?*u32, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).EnumerateFarms(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, pdwCount, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_EnumerateTargets(self: *const T, ProviderName: ?BSTR, FarmName: ?BSTR, EnvName: ?BSTR, pdwCount: ?*u32, pVal: [*]?*?*ITsSbTarget) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).EnumerateTargets(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, FarmName, EnvName, pdwCount, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_EnumerateEnvironmentsByProvider(self: *const T, ProviderName: ?BSTR, pdwCount: ?*u32, ppVal: [*]?*?*ITsSbEnvironment) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).EnumerateEnvironmentsByProvider(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, pdwCount, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_EnumerateSessions(self: *const T, ProviderName: ?BSTR, targetName: ?BSTR, userName: ?BSTR, userDomain: ?BSTR, poolName: ?BSTR, initialProgram: ?BSTR, pSessionState: ?*TSSESSION_STATE, pdwCount: ?*u32, ppVal: [*]?*?*ITsSbSession) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).EnumerateSessions(@as(*const ITsSbGlobalStore, @ptrCast(self)), ProviderName, targetName, userName, userDomain, poolName, initialProgram, pSessionState, pdwCount, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGlobalStore_GetFarmProperty(self: *const T, farmName: ?BSTR, propertyName: ?BSTR, pVarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGlobalStore.VTable, @ptrCast(self.vtable)).GetFarmProperty(@as(*const ITsSbGlobalStore, @ptrCast(self)), farmName, propertyName, pVarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbProvisioningPluginNotifySink_Value = Guid.initString("aca87a8e-818b-4581-a032-49c3dfb9c701");
pub const IID_ITsSbProvisioningPluginNotifySink = &IID_ITsSbProvisioningPluginNotifySink_Value;
pub const ITsSbProvisioningPluginNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnJobCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyInfo: ?*VM_NOTIFY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyInfo: ?*VM_NOTIFY_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnVirtualMachineStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyEntry: ?*VM_NOTIFY_ENTRY,
                VmNotifyStatus: VM_NOTIFY_STATUS,
                ErrorCode: HRESULT,
                ErrorDescr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyEntry: ?*VM_NOTIFY_ENTRY,
                VmNotifyStatus: VM_NOTIFY_STATUS,
                ErrorCode: HRESULT,
                ErrorDescr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnJobCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                ResultCode: HRESULT,
                ResultDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                ResultCode: HRESULT,
                ResultDescription: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnJobCancelled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockVirtualMachine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyEntry: ?*VM_NOTIFY_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                pVmNotifyEntry: ?*VM_NOTIFY_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnVirtualMachineHostStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                VmHost: ?BSTR,
                VmHostNotifyStatus: VM_HOST_NOTIFY_STATUS,
                ErrorCode: HRESULT,
                ErrorDescr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioningPluginNotifySink,
                VmHost: ?BSTR,
                VmHostNotifyStatus: VM_HOST_NOTIFY_STATUS,
                ErrorCode: HRESULT,
                ErrorDescr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_OnJobCreated(self: *const T, pVmNotifyInfo: ?*VM_NOTIFY_INFO) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).OnJobCreated(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)), pVmNotifyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_OnVirtualMachineStatusChanged(self: *const T, pVmNotifyEntry: ?*VM_NOTIFY_ENTRY, VmNotifyStatus: VM_NOTIFY_STATUS, ErrorCode: HRESULT, ErrorDescr: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).OnVirtualMachineStatusChanged(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)), pVmNotifyEntry, VmNotifyStatus, ErrorCode, ErrorDescr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_OnJobCompleted(self: *const T, ResultCode: HRESULT, ResultDescription: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).OnJobCompleted(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)), ResultCode, ResultDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_OnJobCancelled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).OnJobCancelled(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_LockVirtualMachine(self: *const T, pVmNotifyEntry: ?*VM_NOTIFY_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).LockVirtualMachine(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)), pVmNotifyEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioningPluginNotifySink_OnVirtualMachineHostStatusChanged(self: *const T, VmHost: ?BSTR, VmHostNotifyStatus: VM_HOST_NOTIFY_STATUS, ErrorCode: HRESULT, ErrorDescr: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioningPluginNotifySink.VTable, @ptrCast(self.vtable)).OnVirtualMachineHostStatusChanged(@as(*const ITsSbProvisioningPluginNotifySink, @ptrCast(self)), VmHost, VmHostNotifyStatus, ErrorCode, ErrorDescr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_ITsSbProvisioning_Value = Guid.initString("2f6f0dbb-9e4f-462b-9c3f-fccc3dcb6232");
pub const IID_ITsSbProvisioning = &IID_ITsSbProvisioning_Value;
pub const ITsSbProvisioning = extern struct {
    pub const VTable = extern struct {
        base: ITsSbPlugin.VTable,
        CreateVirtualMachines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PatchVirtualMachines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
                pVMPatchInfo: ?*VM_PATCH_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
                pVMPatchInfo: ?*VM_PATCH_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteVirtualMachines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioning,
                JobXmlString: ?BSTR,
                JobGuid: ?BSTR,
                pSink: ?*ITsSbProvisioningPluginNotifySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelJob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbProvisioning,
                JobGuid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbProvisioning,
                JobGuid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITsSbPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioning_CreateVirtualMachines(self: *const T, JobXmlString: ?BSTR, JobGuid: ?BSTR, pSink: ?*ITsSbProvisioningPluginNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioning.VTable, @ptrCast(self.vtable)).CreateVirtualMachines(@as(*const ITsSbProvisioning, @ptrCast(self)), JobXmlString, JobGuid, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioning_PatchVirtualMachines(self: *const T, JobXmlString: ?BSTR, JobGuid: ?BSTR, pSink: ?*ITsSbProvisioningPluginNotifySink, pVMPatchInfo: ?*VM_PATCH_INFO) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioning.VTable, @ptrCast(self.vtable)).PatchVirtualMachines(@as(*const ITsSbProvisioning, @ptrCast(self)), JobXmlString, JobGuid, pSink, pVMPatchInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioning_DeleteVirtualMachines(self: *const T, JobXmlString: ?BSTR, JobGuid: ?BSTR, pSink: ?*ITsSbProvisioningPluginNotifySink) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioning.VTable, @ptrCast(self.vtable)).DeleteVirtualMachines(@as(*const ITsSbProvisioning, @ptrCast(self)), JobXmlString, JobGuid, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbProvisioning_CancelJob(self: *const T, JobGuid: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITsSbProvisioning.VTable, @ptrCast(self.vtable)).CancelJob(@as(*const ITsSbProvisioning, @ptrCast(self)), JobGuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2016'
const IID_ITsSbGenericNotifySink_Value = Guid.initString("4c4c8c4f-300b-46ad-9164-8468a7e7568c");
pub const IID_ITsSbGenericNotifySink = &IID_ITsSbGenericNotifySink_Value;
pub const ITsSbGenericNotifySink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGenericNotifySink,
                Status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGenericNotifySink,
                Status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWaitTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITsSbGenericNotifySink,
                pftTimeout: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITsSbGenericNotifySink,
                pftTimeout: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGenericNotifySink_OnCompleted(self: *const T, Status: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGenericNotifySink.VTable, @ptrCast(self.vtable)).OnCompleted(@as(*const ITsSbGenericNotifySink, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITsSbGenericNotifySink_GetWaitTimeout(self: *const T, pftTimeout: ?*FILETIME) callconv(.Inline) HRESULT {
            return @as(*const ITsSbGenericNotifySink.VTable, @ptrCast(self.vtable)).GetWaitTimeout(@as(*const ITsSbGenericNotifySink, @ptrCast(self)), pftTimeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const pluginResource = extern struct {
    alias: [256]u16,
    name: [256]u16,
    resourceFileContents: ?PWSTR,
    fileExtension: [256]u16,
    resourcePluginType: [256]u16,
    isDiscoverable: u8,
    resourceType: i32,
    pceIconSize: u32,
    iconContents: ?*u8,
    pcePluginBlobSize: u32,
    blobContents: ?*u8,
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ItsPubPlugin_Value = Guid.initString("70c04b05-f347-412b-822f-36c99c54ca45");
pub const IID_ItsPubPlugin = &IID_ItsPubPlugin_Value;
pub const ItsPubPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResourceList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin,
                userID: ?[*:0]const u16,
                pceAppListSize: ?*i32,
                resourceList: ?*?*pluginResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin,
                userID: ?[*:0]const u16,
                pceAppListSize: ?*i32,
                resourceList: ?*?*pluginResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin,
                alias: ?[*:0]const u16,
                flags: i32,
                resource: ?*pluginResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin,
                alias: ?[*:0]const u16,
                flags: i32,
                resource: ?*pluginResource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCacheLastUpdateTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin,
                lastUpdateTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin,
                lastUpdateTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pluginName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ItsPubPlugin,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ItsPubPlugin,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pluginVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ItsPubPlugin,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ItsPubPlugin,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin,
                resourceType: ?*u32,
                resourceLocation: ?PWSTR,
                endPointName: ?PWSTR,
                userID: ?PWSTR,
                alias: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin,
                resourceType: ?*u32,
                resourceLocation: ?PWSTR,
                endPointName: ?PWSTR,
                userID: ?PWSTR,
                alias: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_GetResourceList(self: *const T, userID: ?[*:0]const u16, pceAppListSize: ?*i32, resourceList: ?*?*pluginResource) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).GetResourceList(@as(*const ItsPubPlugin, @ptrCast(self)), userID, pceAppListSize, resourceList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_GetResource(self: *const T, alias: ?[*:0]const u16, flags: i32, resource: ?*pluginResource) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).GetResource(@as(*const ItsPubPlugin, @ptrCast(self)), alias, flags, resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_GetCacheLastUpdateTime(self: *const T, lastUpdateTime: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).GetCacheLastUpdateTime(@as(*const ItsPubPlugin, @ptrCast(self)), lastUpdateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_get_pluginName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).get_pluginName(@as(*const ItsPubPlugin, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_get_pluginVersion(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).get_pluginVersion(@as(*const ItsPubPlugin, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin_ResolveResource(self: *const T, resourceType: ?*u32, resourceLocation: ?PWSTR, endPointName: ?PWSTR, userID: ?PWSTR, alias: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin.VTable, @ptrCast(self.vtable)).ResolveResource(@as(*const ItsPubPlugin, @ptrCast(self)), resourceType, resourceLocation, endPointName, userID, alias);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const pluginResource2FileAssociation = extern struct {
    extName: [256]u16,
    primaryHandler: u8,
    pceIconSize: u32,
    iconContents: ?*u8,
};

pub const pluginResource2 = extern struct {
    resourceV1: pluginResource,
    pceFileAssocListSize: u32,
    fileAssocList: ?*pluginResource2FileAssociation,
    securityDescriptor: ?PWSTR,
    pceFolderListSize: u32,
    folderList: ?*?*u16,
};

pub const TSPUB_PLUGIN_PD_RESOLUTION_TYPE = enum(i32) {
    OR_CREATE = 0,
    EXISTING = 1,
};
pub const TSPUB_PLUGIN_PD_QUERY_OR_CREATE = TSPUB_PLUGIN_PD_RESOLUTION_TYPE.OR_CREATE;
pub const TSPUB_PLUGIN_PD_QUERY_EXISTING = TSPUB_PLUGIN_PD_RESOLUTION_TYPE.EXISTING;

pub const TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE = enum(i32) {
    NEW = 0,
    EXISTING = 1,
};
pub const TSPUB_PLUGIN_PD_ASSIGNMENT_NEW = TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE.NEW;
pub const TSPUB_PLUGIN_PD_ASSIGNMENT_EXISTING = TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE.EXISTING;

// TODO: this type is limited to platform 'windows8.0'
const IID_ItsPubPlugin2_Value = Guid.initString("fa4ce418-aad7-4ec6-bad1-0a321ba465d5");
pub const IID_ItsPubPlugin2 = &IID_ItsPubPlugin2_Value;
pub const ItsPubPlugin2 = extern struct {
    pub const VTable = extern struct {
        base: ItsPubPlugin.VTable,
        GetResource2List: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin2,
                userID: ?[*:0]const u16,
                pceAppListSize: ?*i32,
                resourceList: ?*?*pluginResource2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin2,
                userID: ?[*:0]const u16,
                pceAppListSize: ?*i32,
                resourceList: ?*?*pluginResource2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResource2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin2,
                alias: ?[*:0]const u16,
                flags: i32,
                resource: ?*pluginResource2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin2,
                alias: ?[*:0]const u16,
                flags: i32,
                resource: ?*pluginResource2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolvePersonalDesktop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin2,
                userId: ?[*:0]const u16,
                poolId: ?[*:0]const u16,
                ePdResolutionType: TSPUB_PLUGIN_PD_RESOLUTION_TYPE,
                pPdAssignmentType: ?*TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE,
                endPointName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin2,
                userId: ?[*:0]const u16,
                poolId: ?[*:0]const u16,
                ePdResolutionType: TSPUB_PLUGIN_PD_RESOLUTION_TYPE,
                pPdAssignmentType: ?*TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE,
                endPointName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePersonalDesktopAssignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ItsPubPlugin2,
                userId: ?[*:0]const u16,
                poolId: ?[*:0]const u16,
                endpointName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ItsPubPlugin2,
                userId: ?[*:0]const u16,
                poolId: ?[*:0]const u16,
                endpointName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ItsPubPlugin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin2_GetResource2List(self: *const T, userID: ?[*:0]const u16, pceAppListSize: ?*i32, resourceList: ?*?*pluginResource2) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin2.VTable, @ptrCast(self.vtable)).GetResource2List(@as(*const ItsPubPlugin2, @ptrCast(self)), userID, pceAppListSize, resourceList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin2_GetResource2(self: *const T, alias: ?[*:0]const u16, flags: i32, resource: ?*pluginResource2) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin2.VTable, @ptrCast(self.vtable)).GetResource2(@as(*const ItsPubPlugin2, @ptrCast(self)), alias, flags, resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin2_ResolvePersonalDesktop(self: *const T, userId: ?[*:0]const u16, poolId: ?[*:0]const u16, ePdResolutionType: TSPUB_PLUGIN_PD_RESOLUTION_TYPE, pPdAssignmentType: ?*TSPUB_PLUGIN_PD_ASSIGNMENT_TYPE, endPointName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin2.VTable, @ptrCast(self.vtable)).ResolvePersonalDesktop(@as(*const ItsPubPlugin2, @ptrCast(self)), userId, poolId, ePdResolutionType, pPdAssignmentType, endPointName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ItsPubPlugin2_DeletePersonalDesktopAssignment(self: *const T, userId: ?[*:0]const u16, poolId: ?[*:0]const u16, endpointName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ItsPubPlugin2.VTable, @ptrCast(self.vtable)).DeletePersonalDesktopAssignment(@as(*const ItsPubPlugin2, @ptrCast(self)), userId, poolId, endpointName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWorkspaceResTypeRegistry_Value = Guid.initString("1d428c79-6e2e-4351-a361-c0401a03a0ba");
pub const IID_IWorkspaceResTypeRegistry = &IID_IWorkspaceResTypeRegistry_Value;
pub const IWorkspaceResTypeRegistry = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        AddResourceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                bstrLauncher: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                bstrLauncher: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteResourceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisteredFileExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                psaFileExtensions: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                psaFileExtensions: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourceTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                pbstrLauncher: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                pbstrLauncher: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyResourceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                bstrLauncher: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWorkspaceResTypeRegistry,
                fMachineWide: i16,
                bstrFileExtension: ?BSTR,
                bstrLauncher: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceResTypeRegistry_AddResourceType(self: *const T, fMachineWide: i16, bstrFileExtension: ?BSTR, bstrLauncher: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceResTypeRegistry.VTable, @ptrCast(self.vtable)).AddResourceType(@as(*const IWorkspaceResTypeRegistry, @ptrCast(self)), fMachineWide, bstrFileExtension, bstrLauncher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceResTypeRegistry_DeleteResourceType(self: *const T, fMachineWide: i16, bstrFileExtension: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceResTypeRegistry.VTable, @ptrCast(self.vtable)).DeleteResourceType(@as(*const IWorkspaceResTypeRegistry, @ptrCast(self)), fMachineWide, bstrFileExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceResTypeRegistry_GetRegisteredFileExtensions(self: *const T, fMachineWide: i16, psaFileExtensions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceResTypeRegistry.VTable, @ptrCast(self.vtable)).GetRegisteredFileExtensions(@as(*const IWorkspaceResTypeRegistry, @ptrCast(self)), fMachineWide, psaFileExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceResTypeRegistry_GetResourceTypeInfo(self: *const T, fMachineWide: i16, bstrFileExtension: ?BSTR, pbstrLauncher: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceResTypeRegistry.VTable, @ptrCast(self.vtable)).GetResourceTypeInfo(@as(*const IWorkspaceResTypeRegistry, @ptrCast(self)), fMachineWide, bstrFileExtension, pbstrLauncher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWorkspaceResTypeRegistry_ModifyResourceType(self: *const T, fMachineWide: i16, bstrFileExtension: ?BSTR, bstrLauncher: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWorkspaceResTypeRegistry.VTable, @ptrCast(self.vtable)).ModifyResourceType(@as(*const IWorkspaceResTypeRegistry, @ptrCast(self)), fMachineWide, bstrFileExtension, bstrLauncher);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSPlugin_Value = Guid.initString("a1230201-1439-4e62-a414-190d0ac3d40e");
pub const IID_IWTSPlugin = &IID_IWTSPlugin_Value;
pub const IWTSPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSPlugin,
                pChannelMgr: ?*IWTSVirtualChannelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSPlugin,
                pChannelMgr: ?*IWTSVirtualChannelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Connected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSPlugin,
                dwDisconnectCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSPlugin,
                dwDisconnectCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSPlugin_Initialize(self: *const T, pChannelMgr: ?*IWTSVirtualChannelManager) callconv(.Inline) HRESULT {
            return @as(*const IWTSPlugin.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWTSPlugin, @ptrCast(self)), pChannelMgr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSPlugin_Connected(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSPlugin.VTable, @ptrCast(self.vtable)).Connected(@as(*const IWTSPlugin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSPlugin_Disconnected(self: *const T, dwDisconnectCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSPlugin.VTable, @ptrCast(self.vtable)).Disconnected(@as(*const IWTSPlugin, @ptrCast(self)), dwDisconnectCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSPlugin_Terminated(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSPlugin.VTable, @ptrCast(self.vtable)).Terminated(@as(*const IWTSPlugin, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSListener_Value = Guid.initString("a1230206-9a39-4d58-8674-cdb4dff4e73b");
pub const IID_IWTSListener = &IID_IWTSListener_Value;
pub const IWTSListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSListener,
                ppPropertyBag: ?*?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSListener,
                ppPropertyBag: ?*?*IPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSListener_GetConfiguration(self: *const T, ppPropertyBag: ?*?*IPropertyBag) callconv(.Inline) HRESULT {
            return @as(*const IWTSListener.VTable, @ptrCast(self.vtable)).GetConfiguration(@as(*const IWTSListener, @ptrCast(self)), ppPropertyBag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSListenerCallback_Value = Guid.initString("a1230203-d6a7-11d8-b9fd-000bdbd1f198");
pub const IID_IWTSListenerCallback = &IID_IWTSListenerCallback_Value;
pub const IWTSListenerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNewChannelConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSListenerCallback,
                pChannel: ?*IWTSVirtualChannel,
                data: ?BSTR,
                pbAccept: ?*BOOL,
                ppCallback: ?*?*IWTSVirtualChannelCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSListenerCallback,
                pChannel: ?*IWTSVirtualChannel,
                data: ?BSTR,
                pbAccept: ?*BOOL,
                ppCallback: ?*?*IWTSVirtualChannelCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSListenerCallback_OnNewChannelConnection(self: *const T, pChannel: ?*IWTSVirtualChannel, data: ?BSTR, pbAccept: ?*BOOL, ppCallback: ?*?*IWTSVirtualChannelCallback) callconv(.Inline) HRESULT {
            return @as(*const IWTSListenerCallback.VTable, @ptrCast(self.vtable)).OnNewChannelConnection(@as(*const IWTSListenerCallback, @ptrCast(self)), pChannel, data, pbAccept, ppCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSVirtualChannelCallback_Value = Guid.initString("a1230204-d6a7-11d8-b9fd-000bdbd1f198");
pub const IID_IWTSVirtualChannelCallback = &IID_IWTSVirtualChannelCallback_Value;
pub const IWTSVirtualChannelCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataReceived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSVirtualChannelCallback,
                cbSize: u32,
                pBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSVirtualChannelCallback,
                cbSize: u32,
                pBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSVirtualChannelCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSVirtualChannelCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSVirtualChannelCallback_OnDataReceived(self: *const T, cbSize: u32, pBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IWTSVirtualChannelCallback.VTable, @ptrCast(self.vtable)).OnDataReceived(@as(*const IWTSVirtualChannelCallback, @ptrCast(self)), cbSize, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSVirtualChannelCallback_OnClose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSVirtualChannelCallback.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IWTSVirtualChannelCallback, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSVirtualChannelManager_Value = Guid.initString("a1230205-d6a7-11d8-b9fd-000bdbd1f198");
pub const IID_IWTSVirtualChannelManager = &IID_IWTSVirtualChannelManager_Value;
pub const IWTSVirtualChannelManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSVirtualChannelManager,
                pszChannelName: ?*const u8,
                uFlags: u32,
                pListenerCallback: ?*IWTSListenerCallback,
                ppListener: ?*?*IWTSListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSVirtualChannelManager,
                pszChannelName: ?*const u8,
                uFlags: u32,
                pListenerCallback: ?*IWTSListenerCallback,
                ppListener: ?*?*IWTSListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSVirtualChannelManager_CreateListener(self: *const T, pszChannelName: ?*const u8, uFlags: u32, pListenerCallback: ?*IWTSListenerCallback, ppListener: ?*?*IWTSListener) callconv(.Inline) HRESULT {
            return @as(*const IWTSVirtualChannelManager.VTable, @ptrCast(self.vtable)).CreateListener(@as(*const IWTSVirtualChannelManager, @ptrCast(self)), pszChannelName, uFlags, pListenerCallback, ppListener);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWTSVirtualChannel_Value = Guid.initString("a1230207-d6a7-11d8-b9fd-000bdbd1f198");
pub const IID_IWTSVirtualChannel = &IID_IWTSVirtualChannel_Value;
pub const IWTSVirtualChannel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSVirtualChannel,
                cbSize: u32,
                pBuffer: [*:0]u8,
                pReserved: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSVirtualChannel,
                cbSize: u32,
                pBuffer: [*:0]u8,
                pReserved: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSVirtualChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSVirtualChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSVirtualChannel_Write(self: *const T, cbSize: u32, pBuffer: [*:0]u8, pReserved: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWTSVirtualChannel.VTable, @ptrCast(self.vtable)).Write(@as(*const IWTSVirtualChannel, @ptrCast(self)), cbSize, pBuffer, pReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSVirtualChannel_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSVirtualChannel.VTable, @ptrCast(self.vtable)).Close(@as(*const IWTSVirtualChannel, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWTSPluginServiceProvider_Value = Guid.initString("d3e07363-087c-476c-86a7-dbb15f46ddb4");
pub const IID_IWTSPluginServiceProvider = &IID_IWTSPluginServiceProvider_Value;
pub const IWTSPluginServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSPluginServiceProvider,
                ServiceId: Guid,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSPluginServiceProvider,
                ServiceId: Guid,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSPluginServiceProvider_GetService(self: *const T, ServiceId: Guid, ppunkObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWTSPluginServiceProvider.VTable, @ptrCast(self.vtable)).GetService(@as(*const IWTSPluginServiceProvider, @ptrCast(self)), ServiceId, ppunkObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BITMAP_RENDERER_STATISTICS = extern struct {
    dwFramesDelivered: u32,
    dwFramesDropped: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWTSBitmapRenderer_Value = Guid.initString("5b7acc97-f3c9-46f7-8c5b-fa685d3441b1");
pub const IID_IWTSBitmapRenderer = &IID_IWTSBitmapRenderer_Value;
pub const IWTSBitmapRenderer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSBitmapRenderer,
                imageFormat: Guid,
                dwWidth: u32,
                dwHeight: u32,
                cbStride: i32,
                cbImageBuffer: u32,
                pImageBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSBitmapRenderer,
                imageFormat: Guid,
                dwWidth: u32,
                dwHeight: u32,
                cbStride: i32,
                cbImageBuffer: u32,
                pImageBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRendererStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSBitmapRenderer,
                pStatistics: ?*BITMAP_RENDERER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSBitmapRenderer,
                pStatistics: ?*BITMAP_RENDERER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSBitmapRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSBitmapRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSBitmapRenderer_Render(self: *const T, imageFormat: Guid, dwWidth: u32, dwHeight: u32, cbStride: i32, cbImageBuffer: u32, pImageBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IWTSBitmapRenderer.VTable, @ptrCast(self.vtable)).Render(@as(*const IWTSBitmapRenderer, @ptrCast(self)), imageFormat, dwWidth, dwHeight, cbStride, cbImageBuffer, pImageBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSBitmapRenderer_GetRendererStatistics(self: *const T, pStatistics: ?*BITMAP_RENDERER_STATISTICS) callconv(.Inline) HRESULT {
            return @as(*const IWTSBitmapRenderer.VTable, @ptrCast(self.vtable)).GetRendererStatistics(@as(*const IWTSBitmapRenderer, @ptrCast(self)), pStatistics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSBitmapRenderer_RemoveMapping(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSBitmapRenderer.VTable, @ptrCast(self.vtable)).RemoveMapping(@as(*const IWTSBitmapRenderer, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWTSBitmapRendererCallback_Value = Guid.initString("d782928e-fe4e-4e77-ae90-9cd0b3e3b353");
pub const IID_IWTSBitmapRendererCallback = &IID_IWTSBitmapRendererCallback_Value;
pub const IWTSBitmapRendererCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTargetSizeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSBitmapRendererCallback,
                rcNewSize: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSBitmapRendererCallback,
                rcNewSize: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSBitmapRendererCallback_OnTargetSizeChanged(self: *const T, rcNewSize: RECT) callconv(.Inline) HRESULT {
            return @as(*const IWTSBitmapRendererCallback.VTable, @ptrCast(self.vtable)).OnTargetSizeChanged(@as(*const IWTSBitmapRendererCallback, @ptrCast(self)), rcNewSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWTSBitmapRenderService_Value = Guid.initString("ea326091-05fe-40c1-b49c-3d2ef4626a0e");
pub const IID_IWTSBitmapRenderService = &IID_IWTSBitmapRenderService_Value;
pub const IWTSBitmapRenderService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMappedRenderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSBitmapRenderService,
                mappingId: u64,
                pMappedRendererCallback: ?*IWTSBitmapRendererCallback,
                ppMappedRenderer: ?*?*IWTSBitmapRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSBitmapRenderService,
                mappingId: u64,
                pMappedRendererCallback: ?*IWTSBitmapRendererCallback,
                ppMappedRenderer: ?*?*IWTSBitmapRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSBitmapRenderService_GetMappedRenderer(self: *const T, mappingId: u64, pMappedRendererCallback: ?*IWTSBitmapRendererCallback, ppMappedRenderer: ?*?*IWTSBitmapRenderer) callconv(.Inline) HRESULT {
            return @as(*const IWTSBitmapRenderService.VTable, @ptrCast(self.vtable)).GetMappedRenderer(@as(*const IWTSBitmapRenderService, @ptrCast(self)), mappingId, pMappedRendererCallback, ppMappedRenderer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWRdsGraphicsChannelEvents_Value = Guid.initString("67f2368c-d674-4fae-66a5-d20628a640d2");
pub const IID_IWRdsGraphicsChannelEvents = &IID_IWRdsGraphicsChannelEvents_Value;
pub const IWRdsGraphicsChannelEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataReceived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelEvents,
                cbSize: u32,
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelEvents,
                cbSize: u32,
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChannelOpened: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelEvents,
                OpenResult: HRESULT,
                pOpenContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelEvents,
                OpenResult: HRESULT,
                pOpenContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataSent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelEvents,
                pWriteContext: ?*IUnknown,
                bCancelled: BOOL,
                pBuffer: ?*u8,
                cbBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelEvents,
                pWriteContext: ?*IUnknown,
                bCancelled: BOOL,
                pBuffer: ?*u8,
                cbBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMetricsUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelEvents,
                bandwidth: u32,
                RTT: u32,
                lastSentByteIndex: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelEvents,
                bandwidth: u32,
                RTT: u32,
                lastSentByteIndex: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelEvents_OnDataReceived(self: *const T, cbSize: u32, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelEvents.VTable, @ptrCast(self.vtable)).OnDataReceived(@as(*const IWRdsGraphicsChannelEvents, @ptrCast(self)), cbSize, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelEvents_OnClose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelEvents.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IWRdsGraphicsChannelEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelEvents_OnChannelOpened(self: *const T, OpenResult: HRESULT, pOpenContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelEvents.VTable, @ptrCast(self.vtable)).OnChannelOpened(@as(*const IWRdsGraphicsChannelEvents, @ptrCast(self)), OpenResult, pOpenContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelEvents_OnDataSent(self: *const T, pWriteContext: ?*IUnknown, bCancelled: BOOL, pBuffer: ?*u8, cbBuffer: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelEvents.VTable, @ptrCast(self.vtable)).OnDataSent(@as(*const IWRdsGraphicsChannelEvents, @ptrCast(self)), pWriteContext, bCancelled, pBuffer, cbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelEvents_OnMetricsUpdate(self: *const T, bandwidth: u32, RTT: u32, lastSentByteIndex: u64) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelEvents.VTable, @ptrCast(self.vtable)).OnMetricsUpdate(@as(*const IWRdsGraphicsChannelEvents, @ptrCast(self)), bandwidth, RTT, lastSentByteIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWRdsGraphicsChannel_Value = Guid.initString("684b7a0b-edff-43ad-d5a2-4a8d5388f401");
pub const IID_IWRdsGraphicsChannel = &IID_IWRdsGraphicsChannel_Value;
pub const IWRdsGraphicsChannel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannel,
                cbSize: u32,
                pBuffer: ?*u8,
                pContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannel,
                cbSize: u32,
                pBuffer: ?*u8,
                pContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannel,
                pChannelEvents: ?*IWRdsGraphicsChannelEvents,
                pOpenContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannel,
                pChannelEvents: ?*IWRdsGraphicsChannelEvents,
                pOpenContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannel_Write(self: *const T, cbSize: u32, pBuffer: ?*u8, pContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannel.VTable, @ptrCast(self.vtable)).Write(@as(*const IWRdsGraphicsChannel, @ptrCast(self)), cbSize, pBuffer, pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannel_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannel.VTable, @ptrCast(self.vtable)).Close(@as(*const IWRdsGraphicsChannel, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannel_Open(self: *const T, pChannelEvents: ?*IWRdsGraphicsChannelEvents, pOpenContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannel.VTable, @ptrCast(self.vtable)).Open(@as(*const IWRdsGraphicsChannel, @ptrCast(self)), pChannelEvents, pOpenContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WRdsGraphicsChannelType = enum(i32) {
    GuaranteedDelivery = 0,
    BestEffortDelivery = 1,
};
pub const WRdsGraphicsChannelType_GuaranteedDelivery = WRdsGraphicsChannelType.GuaranteedDelivery;
pub const WRdsGraphicsChannelType_BestEffortDelivery = WRdsGraphicsChannelType.BestEffortDelivery;

// TODO: this type is limited to platform 'windows8.0'
const IID_IWRdsGraphicsChannelManager_Value = Guid.initString("0fd57159-e83e-476a-a8b9-4a7976e71e18");
pub const IID_IWRdsGraphicsChannelManager = &IID_IWRdsGraphicsChannelManager_Value;
pub const IWRdsGraphicsChannelManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsGraphicsChannelManager,
                pszChannelName: ?*const u8,
                channelType: WRdsGraphicsChannelType,
                ppVirtualChannel: ?*?*IWRdsGraphicsChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsGraphicsChannelManager,
                pszChannelName: ?*const u8,
                channelType: WRdsGraphicsChannelType,
                ppVirtualChannel: ?*?*IWRdsGraphicsChannel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsGraphicsChannelManager_CreateChannel(self: *const T, pszChannelName: ?*const u8, channelType: WRdsGraphicsChannelType, ppVirtualChannel: ?*?*IWRdsGraphicsChannel) callconv(.Inline) HRESULT {
            return @as(*const IWRdsGraphicsChannelManager.VTable, @ptrCast(self.vtable)).CreateChannel(@as(*const IWRdsGraphicsChannelManager, @ptrCast(self)), pszChannelName, channelType, ppVirtualChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RFX_GFX_RECT = extern struct {
    left: i32 align(1),
    top: i32 align(1),
    right: i32 align(1),
    bottom: i32 align(1),
};

pub const RFX_GFX_MSG_HEADER = extern struct {
    uMSGType: u16 align(1),
    cbSize: u16 align(1),
};

pub const RFX_GFX_MONITOR_INFO = extern struct {
    left: i32 align(1),
    top: i32 align(1),
    right: i32 align(1),
    bottom: i32 align(1),
    physicalWidth: u32 align(1),
    physicalHeight: u32 align(1),
    orientation: u32 align(1),
    primary: BOOL align(1),
};

pub const RFX_GFX_MSG_CLIENT_DESKTOP_INFO_REQUEST = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER,
};

pub const RFX_GFX_MSG_CLIENT_DESKTOP_INFO_RESPONSE = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER align(1),
    reserved: u32 align(1),
    monitorCount: u32 align(1),
    MonitorData: [16]RFX_GFX_MONITOR_INFO align(1),
    clientUniqueId: [32]u16 align(1),
};

pub const RFX_GFX_MSG_DESKTOP_CONFIG_CHANGE_NOTIFY = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER align(1),
    ulWidth: u32 align(1),
    ulHeight: u32 align(1),
    ulBpp: u32 align(1),
    Reserved: u32 align(1),
};

pub const RFX_GFX_MSG_DESKTOP_CONFIG_CHANGE_CONFIRM = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER,
};

pub const RFX_GFX_MSG_DESKTOP_INPUT_RESET = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER align(1),
    ulWidth: u32 align(1),
    ulHeight: u32 align(1),
};

pub const RFX_GFX_MSG_DISCONNECT_NOTIFY = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER align(1),
    DisconnectReason: u32 align(1),
};

pub const RFX_GFX_MSG_DESKTOP_RESEND_REQUEST = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER,
    RedrawRect: RFX_GFX_RECT,
};

pub const RFX_GFX_MSG_RDP_DATA = extern struct {
    channelHdr: RFX_GFX_MSG_HEADER,
    rdpData: [1]u8,
};

pub const WTS_SOCKADDR = extern struct {
    sin_family: u16,
    u: extern union {
        ipv4: extern struct {
            sin_port: u16,
            IN_ADDR: u32,
            sin_zero: [8]u8,
        },
        ipv6: extern struct {
            sin6_port: u16,
            sin6_flowinfo: u32,
            sin6_addr: [8]u16,
            sin6_scope_id: u32,
        },
    },
};

pub const WTS_SMALL_RECT = extern struct {
    Left: i16,
    Top: i16,
    Right: i16,
    Bottom: i16,
};

pub const WTS_RCM_SERVICE_STATE = enum(i32) {
    NONE = 0,
    START = 1,
    STOP = 2,
};
pub const WTS_SERVICE_NONE = WTS_RCM_SERVICE_STATE.NONE;
pub const WTS_SERVICE_START = WTS_RCM_SERVICE_STATE.START;
pub const WTS_SERVICE_STOP = WTS_RCM_SERVICE_STATE.STOP;

pub const WTS_RCM_DRAIN_STATE = enum(i32) {
    STATE_NONE = 0,
    IN_DRAIN = 1,
    NOT_IN_DRAIN = 2,
};
pub const WTS_DRAIN_STATE_NONE = WTS_RCM_DRAIN_STATE.STATE_NONE;
pub const WTS_DRAIN_IN_DRAIN = WTS_RCM_DRAIN_STATE.IN_DRAIN;
pub const WTS_DRAIN_NOT_IN_DRAIN = WTS_RCM_DRAIN_STATE.NOT_IN_DRAIN;

pub const WTS_SERVICE_STATE = extern struct {
    RcmServiceState: WTS_RCM_SERVICE_STATE,
    RcmDrainState: WTS_RCM_DRAIN_STATE,
};

pub const WTS_SESSION_ID = extern struct {
    SessionUniqueGuid: Guid,
    SessionId: u32,
};

pub const WTS_USER_CREDENTIAL = extern struct {
    UserName: [256]u16,
    Password: [256]u16,
    Domain: [256]u16,
};

pub const WTS_SYSTEMTIME = extern struct {
    wYear: u16,
    wMonth: u16,
    wDayOfWeek: u16,
    wDay: u16,
    wHour: u16,
    wMinute: u16,
    wSecond: u16,
    wMilliseconds: u16,
};

pub const WTS_TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: WTS_SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: WTS_SYSTEMTIME,
    DaylightBias: i32,
};

pub const WRDS_DYNAMIC_TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: WTS_SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: WTS_SYSTEMTIME,
    DaylightBias: i32,
    TimeZoneKeyName: [128]u16,
    DynamicDaylightTimeDisabled: u16,
};

pub const WTS_CLIENT_DATA = extern struct {
    fDisableCtrlAltDel: BOOLEAN,
    fDoubleClickDetect: BOOLEAN,
    fEnableWindowsKey: BOOLEAN,
    fHideTitleBar: BOOLEAN,
    fInheritAutoLogon: BOOL,
    fPromptForPassword: BOOLEAN,
    fUsingSavedCreds: BOOLEAN,
    Domain: [256]u16,
    UserName: [256]u16,
    Password: [256]u16,
    fPasswordIsScPin: BOOLEAN,
    fInheritInitialProgram: BOOL,
    WorkDirectory: [257]u16,
    InitialProgram: [257]u16,
    fMaximizeShell: BOOLEAN,
    EncryptionLevel: u8,
    PerformanceFlags: u32,
    ProtocolName: [9]u16,
    ProtocolType: u16,
    fInheritColorDepth: BOOL,
    HRes: u16,
    VRes: u16,
    ColorDepth: u16,
    DisplayDriverName: [9]u16,
    DisplayDeviceName: [20]u16,
    fMouse: BOOLEAN,
    KeyboardLayout: u32,
    KeyboardType: u32,
    KeyboardSubType: u32,
    KeyboardFunctionKey: u32,
    imeFileName: [33]u16,
    ActiveInputLocale: u32,
    fNoAudioPlayback: BOOLEAN,
    fRemoteConsoleAudio: BOOLEAN,
    AudioDriverName: [9]u16,
    ClientTimeZone: WTS_TIME_ZONE_INFORMATION,
    ClientName: [21]u16,
    SerialNumber: u32,
    ClientAddressFamily: u32,
    ClientAddress: [31]u16,
    ClientSockAddress: WTS_SOCKADDR,
    ClientDirectory: [257]u16,
    ClientBuildNumber: u32,
    ClientProductId: u16,
    OutBufCountHost: u16,
    OutBufCountClient: u16,
    OutBufLength: u16,
    ClientSessionId: u32,
    ClientDigProductId: [33]u16,
    fDisableCpm: BOOLEAN,
    fDisableCdm: BOOLEAN,
    fDisableCcm: BOOLEAN,
    fDisableLPT: BOOLEAN,
    fDisableClip: BOOLEAN,
    fDisablePNP: BOOLEAN,
};

pub const WTS_USER_DATA = extern struct {
    WorkDirectory: [257]u16,
    InitialProgram: [257]u16,
    UserTimeZone: WTS_TIME_ZONE_INFORMATION,
};

pub const WTS_POLICY_DATA = extern struct {
    fDisableEncryption: BOOLEAN,
    fDisableAutoReconnect: BOOLEAN,
    ColorDepth: u32,
    MinEncryptionLevel: u8,
    fDisableCpm: BOOLEAN,
    fDisableCdm: BOOLEAN,
    fDisableCcm: BOOLEAN,
    fDisableLPT: BOOLEAN,
    fDisableClip: BOOLEAN,
    fDisablePNPRedir: BOOLEAN,
};

pub const WTS_PROTOCOL_CACHE = extern struct {
    CacheReads: u32,
    CacheHits: u32,
};

pub const WTS_CACHE_STATS_UN = extern union {
    ProtocolCache: [4]WTS_PROTOCOL_CACHE,
    TShareCacheStats: u32,
    Reserved: [20]u32,
};

pub const WTS_CACHE_STATS = extern struct {
    Specific: u32,
    Data: WTS_CACHE_STATS_UN,
    ProtocolType: u16,
    Length: u16,
};

pub const WTS_PROTOCOL_COUNTERS = extern struct {
    WdBytes: u32,
    WdFrames: u32,
    WaitForOutBuf: u32,
    Frames: u32,
    Bytes: u32,
    CompressedBytes: u32,
    CompressFlushes: u32,
    Errors: u32,
    Timeouts: u32,
    AsyncFramingError: u32,
    AsyncOverrunError: u32,
    AsyncOverflowError: u32,
    AsyncParityError: u32,
    TdErrors: u32,
    ProtocolType: u16,
    Length: u16,
    Specific: u16,
    Reserved: [100]u32,
};

pub const WTS_PROTOCOL_STATUS = extern struct {
    Output: WTS_PROTOCOL_COUNTERS,
    Input: WTS_PROTOCOL_COUNTERS,
    Cache: WTS_CACHE_STATS,
    AsyncSignal: u32,
    AsyncSignalMask: u32,
    Counters: [100]LARGE_INTEGER,
};

pub const WTS_DISPLAY_IOCTL = extern struct {
    pDisplayIOCtlData: [256]u8,
    cbDisplayIOCtlData: u32,
};

pub const WTS_LOGON_ERROR_REDIRECTOR_RESPONSE = enum(i32) {
    INVALID = 0,
    NOT_HANDLED = 1,
    HANDLED_SHOW = 2,
    HANDLED_DONT_SHOW = 3,
    HANDLED_DONT_SHOW_START_OVER = 4,
};
pub const WTS_LOGON_ERR_INVALID = WTS_LOGON_ERROR_REDIRECTOR_RESPONSE.INVALID;
pub const WTS_LOGON_ERR_NOT_HANDLED = WTS_LOGON_ERROR_REDIRECTOR_RESPONSE.NOT_HANDLED;
pub const WTS_LOGON_ERR_HANDLED_SHOW = WTS_LOGON_ERROR_REDIRECTOR_RESPONSE.HANDLED_SHOW;
pub const WTS_LOGON_ERR_HANDLED_DONT_SHOW = WTS_LOGON_ERROR_REDIRECTOR_RESPONSE.HANDLED_DONT_SHOW;
pub const WTS_LOGON_ERR_HANDLED_DONT_SHOW_START_OVER = WTS_LOGON_ERROR_REDIRECTOR_RESPONSE.HANDLED_DONT_SHOW_START_OVER;

pub const WTS_PROPERTY_VALUE = extern struct {
    Type: u16,
    u: extern union {
        ulVal: u32,
        strVal: extern struct {
            size: u32,
            pstrVal: ?PWSTR,
        },
        bVal: extern struct {
            size: u32,
            pbVal: ?PSTR,
        },
        guidVal: Guid,
    },
};

pub const WTS_CERT_TYPE = enum(i32) {
    INVALID = 0,
    PROPRIETORY = 1,
    X509 = 2,
};
pub const WTS_CERT_TYPE_INVALID = WTS_CERT_TYPE.INVALID;
pub const WTS_CERT_TYPE_PROPRIETORY = WTS_CERT_TYPE.PROPRIETORY;
pub const WTS_CERT_TYPE_X509 = WTS_CERT_TYPE.X509;

pub const WTS_LICENSE_CAPABILITIES = extern struct {
    KeyExchangeAlg: u32,
    ProtocolVer: u32,
    fAuthenticateServer: BOOL,
    CertType: WTS_CERT_TYPE,
    cbClientName: u32,
    rgbClientName: [42]u8,
};

pub const WRDS_CONNECTION_SETTING_LEVEL = enum(i32) {
    INVALID = 0,
    @"1" = 1,
};
pub const WRDS_CONNECTION_SETTING_LEVEL_INVALID = WRDS_CONNECTION_SETTING_LEVEL.INVALID;
pub const WRDS_CONNECTION_SETTING_LEVEL_1 = WRDS_CONNECTION_SETTING_LEVEL.@"1";

pub const WRDS_LISTENER_SETTING_LEVEL = enum(i32) {
    INVALID = 0,
    @"1" = 1,
};
pub const WRDS_LISTENER_SETTING_LEVEL_INVALID = WRDS_LISTENER_SETTING_LEVEL.INVALID;
pub const WRDS_LISTENER_SETTING_LEVEL_1 = WRDS_LISTENER_SETTING_LEVEL.@"1";

pub const WRDS_SETTING_TYPE = enum(i32) {
    INVALID = 0,
    MACHINE = 1,
    USER = 2,
    SAM = 3,
};
pub const WRDS_SETTING_TYPE_INVALID = WRDS_SETTING_TYPE.INVALID;
pub const WRDS_SETTING_TYPE_MACHINE = WRDS_SETTING_TYPE.MACHINE;
pub const WRDS_SETTING_TYPE_USER = WRDS_SETTING_TYPE.USER;
pub const WRDS_SETTING_TYPE_SAM = WRDS_SETTING_TYPE.SAM;

pub const WRDS_SETTING_STATUS = enum(i32) {
    NOTAPPLICABLE = -1,
    DISABLED = 0,
    ENABLED = 1,
    NOTCONFIGURED = 2,
};
pub const WRDS_SETTING_STATUS_NOTAPPLICABLE = WRDS_SETTING_STATUS.NOTAPPLICABLE;
pub const WRDS_SETTING_STATUS_DISABLED = WRDS_SETTING_STATUS.DISABLED;
pub const WRDS_SETTING_STATUS_ENABLED = WRDS_SETTING_STATUS.ENABLED;
pub const WRDS_SETTING_STATUS_NOTCONFIGURED = WRDS_SETTING_STATUS.NOTCONFIGURED;

pub const WRDS_SETTING_LEVEL = enum(i32) {
    INVALID = 0,
    @"1" = 1,
};
pub const WRDS_SETTING_LEVEL_INVALID = WRDS_SETTING_LEVEL.INVALID;
pub const WRDS_SETTING_LEVEL_1 = WRDS_SETTING_LEVEL.@"1";

pub const WRDS_LISTENER_SETTINGS_1 = extern struct {
    MaxProtocolListenerConnectionCount: u32,
    SecurityDescriptorSize: u32,
    pSecurityDescriptor: ?*u8,
};

pub const WRDS_LISTENER_SETTING = extern union {
    WRdsListenerSettings1: WRDS_LISTENER_SETTINGS_1,
};

pub const WRDS_LISTENER_SETTINGS = extern struct {
    WRdsListenerSettingLevel: WRDS_LISTENER_SETTING_LEVEL,
    WRdsListenerSetting: WRDS_LISTENER_SETTING,
};

pub const WRDS_CONNECTION_SETTINGS_1 = extern struct {
    fInheritInitialProgram: BOOLEAN,
    fInheritColorDepth: BOOLEAN,
    fHideTitleBar: BOOLEAN,
    fInheritAutoLogon: BOOLEAN,
    fMaximizeShell: BOOLEAN,
    fDisablePNP: BOOLEAN,
    fPasswordIsScPin: BOOLEAN,
    fPromptForPassword: BOOLEAN,
    fDisableCpm: BOOLEAN,
    fDisableCdm: BOOLEAN,
    fDisableCcm: BOOLEAN,
    fDisableLPT: BOOLEAN,
    fDisableClip: BOOLEAN,
    fResetBroken: BOOLEAN,
    fDisableEncryption: BOOLEAN,
    fDisableAutoReconnect: BOOLEAN,
    fDisableCtrlAltDel: BOOLEAN,
    fDoubleClickDetect: BOOLEAN,
    fEnableWindowsKey: BOOLEAN,
    fUsingSavedCreds: BOOLEAN,
    fMouse: BOOLEAN,
    fNoAudioPlayback: BOOLEAN,
    fRemoteConsoleAudio: BOOLEAN,
    EncryptionLevel: u8,
    ColorDepth: u16,
    ProtocolType: u16,
    HRes: u16,
    VRes: u16,
    ClientProductId: u16,
    OutBufCountHost: u16,
    OutBufCountClient: u16,
    OutBufLength: u16,
    KeyboardLayout: u32,
    MaxConnectionTime: u32,
    MaxDisconnectionTime: u32,
    MaxIdleTime: u32,
    PerformanceFlags: u32,
    KeyboardType: u32,
    KeyboardSubType: u32,
    KeyboardFunctionKey: u32,
    ActiveInputLocale: u32,
    SerialNumber: u32,
    ClientAddressFamily: u32,
    ClientBuildNumber: u32,
    ClientSessionId: u32,
    WorkDirectory: [257]u16,
    InitialProgram: [257]u16,
    UserName: [256]u16,
    Domain: [256]u16,
    Password: [256]u16,
    ProtocolName: [9]u16,
    DisplayDriverName: [9]u16,
    DisplayDeviceName: [20]u16,
    imeFileName: [33]u16,
    AudioDriverName: [9]u16,
    ClientName: [21]u16,
    ClientAddress: [31]u16,
    ClientDirectory: [257]u16,
    ClientDigProductId: [33]u16,
    ClientSockAddress: WTS_SOCKADDR,
    ClientTimeZone: WTS_TIME_ZONE_INFORMATION,
    WRdsListenerSettings: WRDS_LISTENER_SETTINGS,
    EventLogActivityId: Guid,
    ContextSize: u32,
    ContextData: ?*u8,
};

pub const WRDS_SETTINGS_1 = extern struct {
    WRdsDisableClipStatus: WRDS_SETTING_STATUS,
    WRdsDisableClipValue: u32,
    WRdsDisableLPTStatus: WRDS_SETTING_STATUS,
    WRdsDisableLPTValue: u32,
    WRdsDisableCcmStatus: WRDS_SETTING_STATUS,
    WRdsDisableCcmValue: u32,
    WRdsDisableCdmStatus: WRDS_SETTING_STATUS,
    WRdsDisableCdmValue: u32,
    WRdsDisableCpmStatus: WRDS_SETTING_STATUS,
    WRdsDisableCpmValue: u32,
    WRdsDisablePnpStatus: WRDS_SETTING_STATUS,
    WRdsDisablePnpValue: u32,
    WRdsEncryptionLevelStatus: WRDS_SETTING_STATUS,
    WRdsEncryptionValue: u32,
    WRdsColorDepthStatus: WRDS_SETTING_STATUS,
    WRdsColorDepthValue: u32,
    WRdsDisableAutoReconnecetStatus: WRDS_SETTING_STATUS,
    WRdsDisableAutoReconnecetValue: u32,
    WRdsDisableEncryptionStatus: WRDS_SETTING_STATUS,
    WRdsDisableEncryptionValue: u32,
    WRdsResetBrokenStatus: WRDS_SETTING_STATUS,
    WRdsResetBrokenValue: u32,
    WRdsMaxIdleTimeStatus: WRDS_SETTING_STATUS,
    WRdsMaxIdleTimeValue: u32,
    WRdsMaxDisconnectTimeStatus: WRDS_SETTING_STATUS,
    WRdsMaxDisconnectTimeValue: u32,
    WRdsMaxConnectTimeStatus: WRDS_SETTING_STATUS,
    WRdsMaxConnectTimeValue: u32,
    WRdsKeepAliveStatus: WRDS_SETTING_STATUS,
    WRdsKeepAliveStartValue: BOOLEAN,
    WRdsKeepAliveIntervalValue: u32,
};

pub const WRDS_CONNECTION_SETTING = extern union {
    WRdsConnectionSettings1: WRDS_CONNECTION_SETTINGS_1,
};

pub const WRDS_CONNECTION_SETTINGS = extern struct {
    WRdsConnectionSettingLevel: WRDS_CONNECTION_SETTING_LEVEL,
    WRdsConnectionSetting: WRDS_CONNECTION_SETTING,
};

pub const WRDS_SETTING = extern union {
    WRdsSettings1: WRDS_SETTINGS_1,
};

pub const WRDS_SETTINGS = extern struct {
    WRdsSettingType: WRDS_SETTING_TYPE,
    WRdsSettingLevel: WRDS_SETTING_LEVEL,
    WRdsSetting: WRDS_SETTING,
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolManager_Value = Guid.initString("f9eaf6cc-ed79-4f01-821d-1f881b9f66cc");
pub const IID_IWTSProtocolManager = &IID_IWTSProtocolManager_Value;
pub const IWTSProtocolManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolManager,
                wszListenerName: ?PWSTR,
                pProtocolListener: ?*?*IWTSProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolManager,
                wszListenerName: ?PWSTR,
                pProtocolListener: ?*?*IWTSProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyServiceStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolManager,
                pTSServiceStateChange: ?*WTS_SERVICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolManager,
                pTSServiceStateChange: ?*WTS_SERVICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionOfServiceStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionOfServiceStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolManager_CreateListener(self: *const T, wszListenerName: ?PWSTR, pProtocolListener: ?*?*IWTSProtocolListener) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolManager.VTable, @ptrCast(self.vtable)).CreateListener(@as(*const IWTSProtocolManager, @ptrCast(self)), wszListenerName, pProtocolListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolManager_NotifyServiceStateChange(self: *const T, pTSServiceStateChange: ?*WTS_SERVICE_STATE) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolManager.VTable, @ptrCast(self.vtable)).NotifyServiceStateChange(@as(*const IWTSProtocolManager, @ptrCast(self)), pTSServiceStateChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolManager_NotifySessionOfServiceStart(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionOfServiceStart(@as(*const IWTSProtocolManager, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolManager_NotifySessionOfServiceStop(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionOfServiceStop(@as(*const IWTSProtocolManager, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolManager_NotifySessionStateChange(self: *const T, SessionId: ?*WTS_SESSION_ID, EventId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionStateChange(@as(*const IWTSProtocolManager, @ptrCast(self)), SessionId, EventId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolListener_Value = Guid.initString("23083765-45f0-4394-8f69-32b2bc0ef4ca");
pub const IID_IWTSProtocolListener = &IID_IWTSProtocolListener_Value;
pub const IWTSProtocolListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolListener,
                pCallback: ?*IWTSProtocolListenerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolListener,
                pCallback: ?*IWTSProtocolListenerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopListen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolListener_StartListen(self: *const T, pCallback: ?*IWTSProtocolListenerCallback) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolListener.VTable, @ptrCast(self.vtable)).StartListen(@as(*const IWTSProtocolListener, @ptrCast(self)), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolListener_StopListen(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolListener.VTable, @ptrCast(self.vtable)).StopListen(@as(*const IWTSProtocolListener, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolListenerCallback_Value = Guid.initString("23083765-1a2d-4de2-97de-4a35f260f0b3");
pub const IID_IWTSProtocolListenerCallback = &IID_IWTSProtocolListenerCallback_Value;
pub const IWTSProtocolListenerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolListenerCallback,
                pConnection: ?*IWTSProtocolConnection,
                pCallback: ?*?*IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolListenerCallback,
                pConnection: ?*IWTSProtocolConnection,
                pCallback: ?*?*IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolListenerCallback_OnConnected(self: *const T, pConnection: ?*IWTSProtocolConnection, pCallback: ?*?*IWTSProtocolConnectionCallback) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolListenerCallback.VTable, @ptrCast(self.vtable)).OnConnected(@as(*const IWTSProtocolListenerCallback, @ptrCast(self)), pConnection, pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolConnection_Value = Guid.initString("23083765-9095-4648-98bf-ef81c914032d");
pub const IID_IWTSProtocolConnection = &IID_IWTSProtocolConnection_Value;
pub const IWTSProtocolConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLogonErrorRedirector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                ppLogonErrorRedir: ?*?*IWTSProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                ppLogonErrorRedir: ?*?*IWTSProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendPolicyData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pPolicyData: ?*WTS_POLICY_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pPolicyData: ?*WTS_POLICY_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcceptConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pClientData: ?*WTS_CLIENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pClientData: ?*WTS_CLIENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pUserCreds: ?*WTS_USER_CREDENTIAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pUserCreds: ?*WTS_USER_CREDENTIAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLicenseConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                ppLicenseConnection: ?*?*IWTSProtocolLicenseConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                ppLicenseConnection: ?*?*IWTSProtocolLicenseConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AuthenticateClientToSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pKeyboardHandle: ?*HANDLE_PTR,
                pMouseHandle: ?*HANDLE_PTR,
                pBeepHandle: ?*HANDLE_PTR,
                pVideoHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pKeyboardHandle: ?*HANDLE_PTR,
                pMouseHandle: ?*HANDLE_PTR,
                pBeepHandle: ?*HANDLE_PTR,
                pVideoHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUserAllowedToLogon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                SessionId: u32,
                UserToken: HANDLE_PTR,
                pDomainName: ?PWSTR,
                pUserName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                SessionId: u32,
                UserToken: HANDLE_PTR,
                pDomainName: ?PWSTR,
                pUserName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionArbitrationEnumeration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                hUserToken: HANDLE_PTR,
                bSingleSessionPerUserEnabled: BOOL,
                pSessionIdArray: [*]u32,
                pdwSessionIdentifierCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                hUserToken: HANDLE_PTR,
                bSingleSessionPerUserEnabled: BOOL,
                pSessionIdArray: [*]u32,
                pdwSessionIdentifierCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogonNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                hClientToken: HANDLE_PTR,
                wszUserName: ?PWSTR,
                wszDomainName: ?PWSTR,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                hClientToken: HANDLE_PTR,
                wszUserName: ?PWSTR,
                wszDomainName: ?PWSTR,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pPolicyData: ?*WTS_POLICY_DATA,
                pClientData: ?*WTS_USER_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pPolicyData: ?*WTS_POLICY_DATA,
                pClientData: ?*WTS_USER_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pProtocolStatus: ?*WTS_PROTOCOL_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pProtocolStatus: ?*WTS_PROTOCOL_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastInputTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                pLastInputTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                pLastInputTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                ulError: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                ulError: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendBeep: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                Frequency: u32,
                Duration: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                Frequency: u32,
                Duration: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVirtualChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                szEndpointName: ?PSTR,
                bStatic: BOOL,
                RequestedPriority: u32,
                phChannel: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                szEndpointName: ?PSTR,
                bStatic: BOOL,
                RequestedPriority: u32,
                phChannel: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                QueryType: Guid,
                ulNumEntriesIn: u32,
                ulNumEntriesOut: u32,
                pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE,
                pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                QueryType: Guid,
                ulNumEntriesIn: u32,
                ulNumEntriesOut: u32,
                pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE,
                pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShadowConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnection,
                ppShadowConnection: ?*?*IWTSProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnection,
                ppShadowConnection: ?*?*IWTSProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetLogonErrorRedirector(self: *const T, ppLogonErrorRedir: ?*?*IWTSProtocolLogonErrorRedirector) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetLogonErrorRedirector(@as(*const IWTSProtocolConnection, @ptrCast(self)), ppLogonErrorRedir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_SendPolicyData(self: *const T, pPolicyData: ?*WTS_POLICY_DATA) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).SendPolicyData(@as(*const IWTSProtocolConnection, @ptrCast(self)), pPolicyData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_AcceptConnection(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).AcceptConnection(@as(*const IWTSProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetClientData(self: *const T, pClientData: ?*WTS_CLIENT_DATA) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetClientData(@as(*const IWTSProtocolConnection, @ptrCast(self)), pClientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetUserCredentials(self: *const T, pUserCreds: ?*WTS_USER_CREDENTIAL) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetUserCredentials(@as(*const IWTSProtocolConnection, @ptrCast(self)), pUserCreds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetLicenseConnection(self: *const T, ppLicenseConnection: ?*?*IWTSProtocolLicenseConnection) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetLicenseConnection(@as(*const IWTSProtocolConnection, @ptrCast(self)), ppLicenseConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_AuthenticateClientToSession(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).AuthenticateClientToSession(@as(*const IWTSProtocolConnection, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_NotifySessionId(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).NotifySessionId(@as(*const IWTSProtocolConnection, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetProtocolHandles(self: *const T, pKeyboardHandle: ?*HANDLE_PTR, pMouseHandle: ?*HANDLE_PTR, pBeepHandle: ?*HANDLE_PTR, pVideoHandle: ?*HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetProtocolHandles(@as(*const IWTSProtocolConnection, @ptrCast(self)), pKeyboardHandle, pMouseHandle, pBeepHandle, pVideoHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_ConnectNotify(self: *const T, SessionId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).ConnectNotify(@as(*const IWTSProtocolConnection, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_IsUserAllowedToLogon(self: *const T, SessionId: u32, UserToken: HANDLE_PTR, pDomainName: ?PWSTR, pUserName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).IsUserAllowedToLogon(@as(*const IWTSProtocolConnection, @ptrCast(self)), SessionId, UserToken, pDomainName, pUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_SessionArbitrationEnumeration(self: *const T, hUserToken: HANDLE_PTR, bSingleSessionPerUserEnabled: BOOL, pSessionIdArray: [*]u32, pdwSessionIdentifierCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).SessionArbitrationEnumeration(@as(*const IWTSProtocolConnection, @ptrCast(self)), hUserToken, bSingleSessionPerUserEnabled, pSessionIdArray, pdwSessionIdentifierCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_LogonNotify(self: *const T, hClientToken: HANDLE_PTR, wszUserName: ?PWSTR, wszDomainName: ?PWSTR, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).LogonNotify(@as(*const IWTSProtocolConnection, @ptrCast(self)), hClientToken, wszUserName, wszDomainName, SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetUserData(self: *const T, pPolicyData: ?*WTS_POLICY_DATA, pClientData: ?*WTS_USER_DATA) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetUserData(@as(*const IWTSProtocolConnection, @ptrCast(self)), pPolicyData, pClientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_DisconnectNotify(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).DisconnectNotify(@as(*const IWTSProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).Close(@as(*const IWTSProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetProtocolStatus(self: *const T, pProtocolStatus: ?*WTS_PROTOCOL_STATUS) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetProtocolStatus(@as(*const IWTSProtocolConnection, @ptrCast(self)), pProtocolStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetLastInputTime(self: *const T, pLastInputTime: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetLastInputTime(@as(*const IWTSProtocolConnection, @ptrCast(self)), pLastInputTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_SetErrorInfo(self: *const T, ulError: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).SetErrorInfo(@as(*const IWTSProtocolConnection, @ptrCast(self)), ulError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_SendBeep(self: *const T, Frequency: u32, Duration: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).SendBeep(@as(*const IWTSProtocolConnection, @ptrCast(self)), Frequency, Duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_CreateVirtualChannel(self: *const T, szEndpointName: ?PSTR, bStatic: BOOL, RequestedPriority: u32, phChannel: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).CreateVirtualChannel(@as(*const IWTSProtocolConnection, @ptrCast(self)), szEndpointName, bStatic, RequestedPriority, phChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_QueryProperty(self: *const T, QueryType: Guid, ulNumEntriesIn: u32, ulNumEntriesOut: u32, pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE, pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).QueryProperty(@as(*const IWTSProtocolConnection, @ptrCast(self)), QueryType, ulNumEntriesIn, ulNumEntriesOut, pPropertyEntriesIn, pPropertyEntriesOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnection_GetShadowConnection(self: *const T, ppShadowConnection: ?*?*IWTSProtocolShadowConnection) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnection.VTable, @ptrCast(self.vtable)).GetShadowConnection(@as(*const IWTSProtocolConnection, @ptrCast(self)), ppShadowConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolConnectionCallback_Value = Guid.initString("23083765-75eb-41fe-b4fb-e086242afa0f");
pub const IID_IWTSProtocolConnectionCallback = &IID_IWTSProtocolConnectionCallback_Value;
pub const IWTSProtocolConnectionCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrokenConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnectionCallback,
                Reason: u32,
                Source: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnectionCallback,
                Reason: u32,
                Source: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopScreenUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedrawWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnectionCallback,
                rect: ?*WTS_SMALL_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnectionCallback,
                rect: ?*WTS_SMALL_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayIOCtl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolConnectionCallback,
                DisplayIOCtl: ?*WTS_DISPLAY_IOCTL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolConnectionCallback,
                DisplayIOCtl: ?*WTS_DISPLAY_IOCTL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnectionCallback_OnReady(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).OnReady(@as(*const IWTSProtocolConnectionCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnectionCallback_BrokenConnection(self: *const T, Reason: u32, Source: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).BrokenConnection(@as(*const IWTSProtocolConnectionCallback, @ptrCast(self)), Reason, Source);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnectionCallback_StopScreenUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).StopScreenUpdates(@as(*const IWTSProtocolConnectionCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnectionCallback_RedrawWindow(self: *const T, rect: ?*WTS_SMALL_RECT) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).RedrawWindow(@as(*const IWTSProtocolConnectionCallback, @ptrCast(self)), rect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolConnectionCallback_DisplayIOCtl(self: *const T, DisplayIOCtl: ?*WTS_DISPLAY_IOCTL) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).DisplayIOCtl(@as(*const IWTSProtocolConnectionCallback, @ptrCast(self)), DisplayIOCtl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolShadowConnection_Value = Guid.initString("ee3b0c14-37fb-456b-bab3-6d6cd51e13bf");
pub const IID_IWTSProtocolShadowConnection = &IID_IWTSProtocolShadowConnection_Value;
pub const IWTSProtocolShadowConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolShadowConnection,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                HotKeyVk: u8,
                HotkeyModifiers: u16,
                pShadowCallback: ?*IWTSProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolShadowConnection,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                HotKeyVk: u8,
                HotkeyModifiers: u16,
                pShadowCallback: ?*IWTSProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolShadowConnection,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolShadowConnection,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolShadowConnection_Start(self: *const T, pTargetServerName: ?PWSTR, TargetSessionId: u32, HotKeyVk: u8, HotkeyModifiers: u16, pShadowCallback: ?*IWTSProtocolShadowCallback) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolShadowConnection.VTable, @ptrCast(self.vtable)).Start(@as(*const IWTSProtocolShadowConnection, @ptrCast(self)), pTargetServerName, TargetSessionId, HotKeyVk, HotkeyModifiers, pShadowCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolShadowConnection_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolShadowConnection.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWTSProtocolShadowConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolShadowConnection_DoTarget(self: *const T, pParam1: [*:0]u8, Param1Size: u32, pParam2: [*:0]u8, Param2Size: u32, pParam3: [*:0]u8, Param3Size: u32, pParam4: [*:0]u8, Param4Size: u32, pClientName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolShadowConnection.VTable, @ptrCast(self.vtable)).DoTarget(@as(*const IWTSProtocolShadowConnection, @ptrCast(self)), pParam1, Param1Size, pParam2, Param2Size, pParam3, Param3Size, pParam4, Param4Size, pClientName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolShadowCallback_Value = Guid.initString("503a2504-aae5-4ab1-93e0-6d1c4bc6f71a");
pub const IID_IWTSProtocolShadowCallback = &IID_IWTSProtocolShadowCallback_Value;
pub const IWTSProtocolShadowCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StopShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeTargetShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolShadowCallback,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolShadowCallback,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolShadowCallback_StopShadow(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolShadowCallback.VTable, @ptrCast(self.vtable)).StopShadow(@as(*const IWTSProtocolShadowCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolShadowCallback_InvokeTargetShadow(self: *const T, pTargetServerName: ?PWSTR, TargetSessionId: u32, pParam1: [*:0]u8, Param1Size: u32, pParam2: [*:0]u8, Param2Size: u32, pParam3: [*:0]u8, Param3Size: u32, pParam4: [*:0]u8, Param4Size: u32, pClientName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolShadowCallback.VTable, @ptrCast(self.vtable)).InvokeTargetShadow(@as(*const IWTSProtocolShadowCallback, @ptrCast(self)), pTargetServerName, TargetSessionId, pParam1, Param1Size, pParam2, Param2Size, pParam3, Param3Size, pParam4, Param4Size, pClientName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolLicenseConnection_Value = Guid.initString("23083765-178c-4079-8e4a-fea6496a4d70");
pub const IID_IWTSProtocolLicenseConnection = &IID_IWTSProtocolLicenseConnection_Value;
pub const IWTSProtocolLicenseConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestLicensingCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLicenseConnection,
                ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES,
                pcbLicenseCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLicenseConnection,
                ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES,
                pcbLicenseCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendClientLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLicenseConnection,
                pClientLicense: [*:0]u8,
                cbClientLicense: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLicenseConnection,
                pClientLicense: [*:0]u8,
                cbClientLicense: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestClientLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLicenseConnection,
                Reserve1: [*:0]u8,
                Reserve2: u32,
                ppClientLicense: [*:0]u8,
                pcbClientLicense: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLicenseConnection,
                Reserve1: [*:0]u8,
                Reserve2: u32,
                ppClientLicense: [*:0]u8,
                pcbClientLicense: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProtocolComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLicenseConnection,
                ulComplete: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLicenseConnection,
                ulComplete: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLicenseConnection_RequestLicensingCapabilities(self: *const T, ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES, pcbLicenseCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).RequestLicensingCapabilities(@as(*const IWTSProtocolLicenseConnection, @ptrCast(self)), ppLicenseCapabilities, pcbLicenseCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLicenseConnection_SendClientLicense(self: *const T, pClientLicense: [*:0]u8, cbClientLicense: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).SendClientLicense(@as(*const IWTSProtocolLicenseConnection, @ptrCast(self)), pClientLicense, cbClientLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLicenseConnection_RequestClientLicense(self: *const T, Reserve1: [*:0]u8, Reserve2: u32, ppClientLicense: [*:0]u8, pcbClientLicense: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).RequestClientLicense(@as(*const IWTSProtocolLicenseConnection, @ptrCast(self)), Reserve1, Reserve2, ppClientLicense, pcbClientLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLicenseConnection_ProtocolComplete(self: *const T, ulComplete: u32) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).ProtocolComplete(@as(*const IWTSProtocolLicenseConnection, @ptrCast(self)), ulComplete);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IWTSProtocolLogonErrorRedirector_Value = Guid.initString("fd9b61a7-2916-4627-8dee-4328711ad6cb");
pub const IID_IWTSProtocolLogonErrorRedirector = &IID_IWTSProtocolLogonErrorRedirector_Value;
pub const IWTSProtocolLogonErrorRedirector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBeginPainting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                pszMessage: ?[*:0]const u16,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                pszMessage: ?[*:0]const u16,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectLogonError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                ntsStatus: i32,
                ntsSubstatus: i32,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWTSProtocolLogonErrorRedirector,
                ntsStatus: i32,
                ntsSubstatus: i32,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLogonErrorRedirector_OnBeginPainting(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).OnBeginPainting(@as(*const IWTSProtocolLogonErrorRedirector, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLogonErrorRedirector_RedirectStatus(self: *const T, pszMessage: ?[*:0]const u16, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectStatus(@as(*const IWTSProtocolLogonErrorRedirector, @ptrCast(self)), pszMessage, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLogonErrorRedirector_RedirectMessage(self: *const T, pszCaption: ?[*:0]const u16, pszMessage: ?[*:0]const u16, uType: u32, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectMessage(@as(*const IWTSProtocolLogonErrorRedirector, @ptrCast(self)), pszCaption, pszMessage, uType, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWTSProtocolLogonErrorRedirector_RedirectLogonError(self: *const T, ntsStatus: i32, ntsSubstatus: i32, pszCaption: ?[*:0]const u16, pszMessage: ?[*:0]const u16, uType: u32, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWTSProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectLogonError(@as(*const IWTSProtocolLogonErrorRedirector, @ptrCast(self)), ntsStatus, ntsSubstatus, pszCaption, pszMessage, uType, pResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolSettings_Value = Guid.initString("654a5a6a-2550-47eb-b6f7-ebd637475265");
pub const IID_IWRdsProtocolSettings = &IID_IWRdsProtocolSettings_Value;
pub const IWRdsProtocolSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolSettings,
                WRdsSettingType: WRDS_SETTING_TYPE,
                WRdsSettingLevel: WRDS_SETTING_LEVEL,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolSettings,
                WRdsSettingType: WRDS_SETTING_TYPE,
                WRdsSettingLevel: WRDS_SETTING_LEVEL,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MergeSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolSettings,
                pWRdsSettings: ?*WRDS_SETTINGS,
                WRdsConnectionSettingLevel: WRDS_CONNECTION_SETTING_LEVEL,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolSettings,
                pWRdsSettings: ?*WRDS_SETTINGS,
                WRdsConnectionSettingLevel: WRDS_CONNECTION_SETTING_LEVEL,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolSettings_GetSettings(self: *const T, WRdsSettingType: WRDS_SETTING_TYPE, WRdsSettingLevel: WRDS_SETTING_LEVEL, pWRdsSettings: ?*WRDS_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolSettings.VTable, @ptrCast(self.vtable)).GetSettings(@as(*const IWRdsProtocolSettings, @ptrCast(self)), WRdsSettingType, WRdsSettingLevel, pWRdsSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolSettings_MergeSettings(self: *const T, pWRdsSettings: ?*WRDS_SETTINGS, WRdsConnectionSettingLevel: WRDS_CONNECTION_SETTING_LEVEL, pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolSettings.VTable, @ptrCast(self.vtable)).MergeSettings(@as(*const IWRdsProtocolSettings, @ptrCast(self)), pWRdsSettings, WRdsConnectionSettingLevel, pWRdsConnectionSettings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolManager_Value = Guid.initString("dc796967-3abb-40cd-a446-105276b58950");
pub const IID_IWRdsProtocolManager = &IID_IWRdsProtocolManager_Value;
pub const IWRdsProtocolManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                pIWRdsSettings: ?*IWRdsProtocolSettings,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                pIWRdsSettings: ?*IWRdsProtocolSettings,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateListener: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                wszListenerName: ?PWSTR,
                pProtocolListener: ?*?*IWRdsProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                wszListenerName: ?PWSTR,
                pProtocolListener: ?*?*IWRdsProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyServiceStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                pTSServiceStateChange: ?*WTS_SERVICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                pTSServiceStateChange: ?*WTS_SERVICE_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionOfServiceStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionOfServiceStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                SessionId: ?*WTS_SESSION_ID,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySettingsChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
                pWRdsSettings: ?*WRDS_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Uninitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_Initialize(self: *const T, pIWRdsSettings: ?*IWRdsProtocolSettings, pWRdsSettings: ?*WRDS_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWRdsProtocolManager, @ptrCast(self)), pIWRdsSettings, pWRdsSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_CreateListener(self: *const T, wszListenerName: ?PWSTR, pProtocolListener: ?*?*IWRdsProtocolListener) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).CreateListener(@as(*const IWRdsProtocolManager, @ptrCast(self)), wszListenerName, pProtocolListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_NotifyServiceStateChange(self: *const T, pTSServiceStateChange: ?*WTS_SERVICE_STATE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).NotifyServiceStateChange(@as(*const IWRdsProtocolManager, @ptrCast(self)), pTSServiceStateChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_NotifySessionOfServiceStart(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionOfServiceStart(@as(*const IWRdsProtocolManager, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_NotifySessionOfServiceStop(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionOfServiceStop(@as(*const IWRdsProtocolManager, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_NotifySessionStateChange(self: *const T, SessionId: ?*WTS_SESSION_ID, EventId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).NotifySessionStateChange(@as(*const IWRdsProtocolManager, @ptrCast(self)), SessionId, EventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_NotifySettingsChange(self: *const T, pWRdsSettings: ?*WRDS_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).NotifySettingsChange(@as(*const IWRdsProtocolManager, @ptrCast(self)), pWRdsSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolManager_Uninitialize(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolManager.VTable, @ptrCast(self.vtable)).Uninitialize(@as(*const IWRdsProtocolManager, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolListener_Value = Guid.initString("fcbc131b-c686-451d-a773-e279e230f540");
pub const IID_IWRdsProtocolListener = &IID_IWRdsProtocolListener_Value;
pub const IWRdsProtocolListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolListener,
                WRdsListenerSettingLevel: WRDS_LISTENER_SETTING_LEVEL,
                pWRdsListenerSettings: ?*WRDS_LISTENER_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolListener,
                WRdsListenerSettingLevel: WRDS_LISTENER_SETTING_LEVEL,
                pWRdsListenerSettings: ?*WRDS_LISTENER_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartListen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolListener,
                pCallback: ?*IWRdsProtocolListenerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolListener,
                pCallback: ?*IWRdsProtocolListenerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopListen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolListener,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolListener_GetSettings(self: *const T, WRdsListenerSettingLevel: WRDS_LISTENER_SETTING_LEVEL, pWRdsListenerSettings: ?*WRDS_LISTENER_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolListener.VTable, @ptrCast(self.vtable)).GetSettings(@as(*const IWRdsProtocolListener, @ptrCast(self)), WRdsListenerSettingLevel, pWRdsListenerSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolListener_StartListen(self: *const T, pCallback: ?*IWRdsProtocolListenerCallback) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolListener.VTable, @ptrCast(self.vtable)).StartListen(@as(*const IWRdsProtocolListener, @ptrCast(self)), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolListener_StopListen(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolListener.VTable, @ptrCast(self.vtable)).StopListen(@as(*const IWRdsProtocolListener, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolListenerCallback_Value = Guid.initString("3ab27e5b-4449-4dc1-b74a-91621d4fe984");
pub const IID_IWRdsProtocolListenerCallback = &IID_IWRdsProtocolListenerCallback_Value;
pub const IWRdsProtocolListenerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolListenerCallback,
                pConnection: ?*IWRdsProtocolConnection,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
                pCallback: ?*?*IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolListenerCallback,
                pConnection: ?*IWRdsProtocolConnection,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
                pCallback: ?*?*IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolListenerCallback_OnConnected(self: *const T, pConnection: ?*IWRdsProtocolConnection, pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS, pCallback: ?*?*IWRdsProtocolConnectionCallback) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolListenerCallback.VTable, @ptrCast(self.vtable)).OnConnected(@as(*const IWRdsProtocolListenerCallback, @ptrCast(self)), pConnection, pWRdsConnectionSettings, pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolConnection_Value = Guid.initString("324ed94f-fdaf-4ff6-81a8-42abe755830b");
pub const IID_IWRdsProtocolConnection = &IID_IWRdsProtocolConnection_Value;
pub const IWRdsProtocolConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLogonErrorRedirector: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                ppLogonErrorRedir: ?*?*IWRdsProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                ppLogonErrorRedir: ?*?*IWRdsProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcceptConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pClientData: ?*WTS_CLIENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pClientData: ?*WTS_CLIENT_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClientMonitorData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pNumMonitors: ?*u32,
                pPrimaryMonitor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pNumMonitors: ?*u32,
                pPrimaryMonitor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pUserCreds: ?*WTS_USER_CREDENTIAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pUserCreds: ?*WTS_USER_CREDENTIAL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLicenseConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                ppLicenseConnection: ?*?*IWRdsProtocolLicenseConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                ppLicenseConnection: ?*?*IWRdsProtocolLicenseConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AuthenticateClientToSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifySessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
                SessionHandle: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                SessionId: ?*WTS_SESSION_ID,
                SessionHandle: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pKeyboardHandle: ?*HANDLE_PTR,
                pMouseHandle: ?*HANDLE_PTR,
                pBeepHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pKeyboardHandle: ?*HANDLE_PTR,
                pMouseHandle: ?*HANDLE_PTR,
                pBeepHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pVideoHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pVideoHandle: ?*HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUserAllowedToLogon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
                UserToken: HANDLE_PTR,
                pDomainName: ?PWSTR,
                pUserName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
                UserToken: HANDLE_PTR,
                pDomainName: ?PWSTR,
                pUserName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionArbitrationEnumeration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                hUserToken: HANDLE_PTR,
                bSingleSessionPerUserEnabled: BOOL,
                pSessionIdArray: [*]u32,
                pdwSessionIdentifierCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                hUserToken: HANDLE_PTR,
                bSingleSessionPerUserEnabled: BOOL,
                pSessionIdArray: [*]u32,
                pdwSessionIdentifierCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogonNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                hClientToken: HANDLE_PTR,
                wszUserName: ?PWSTR,
                wszDomainName: ?PWSTR,
                SessionId: ?*WTS_SESSION_ID,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                hClientToken: HANDLE_PTR,
                wszUserName: ?PWSTR,
                wszDomainName: ?PWSTR,
                SessionId: ?*WTS_SESSION_ID,
                pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                DisconnectReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                DisconnectReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pProtocolStatus: ?*WTS_PROTOCOL_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pProtocolStatus: ?*WTS_PROTOCOL_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastInputTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                pLastInputTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                pLastInputTime: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                ulError: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                ulError: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVirtualChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                szEndpointName: ?PSTR,
                bStatic: BOOL,
                RequestedPriority: u32,
                phChannel: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                szEndpointName: ?PSTR,
                bStatic: BOOL,
                RequestedPriority: u32,
                phChannel: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                QueryType: Guid,
                ulNumEntriesIn: u32,
                ulNumEntriesOut: u32,
                pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE,
                pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                QueryType: Guid,
                ulNumEntriesIn: u32,
                ulNumEntriesOut: u32,
                pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE,
                pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShadowConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                ppShadowConnection: ?*?*IWRdsProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                ppShadowConnection: ?*?*IWRdsProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyCommandProcessCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnection,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetLogonErrorRedirector(self: *const T, ppLogonErrorRedir: ?*?*IWRdsProtocolLogonErrorRedirector) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetLogonErrorRedirector(@as(*const IWRdsProtocolConnection, @ptrCast(self)), ppLogonErrorRedir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_AcceptConnection(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).AcceptConnection(@as(*const IWRdsProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetClientData(self: *const T, pClientData: ?*WTS_CLIENT_DATA) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetClientData(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pClientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetClientMonitorData(self: *const T, pNumMonitors: ?*u32, pPrimaryMonitor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetClientMonitorData(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pNumMonitors, pPrimaryMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetUserCredentials(self: *const T, pUserCreds: ?*WTS_USER_CREDENTIAL) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetUserCredentials(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pUserCreds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetLicenseConnection(self: *const T, ppLicenseConnection: ?*?*IWRdsProtocolLicenseConnection) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetLicenseConnection(@as(*const IWRdsProtocolConnection, @ptrCast(self)), ppLicenseConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_AuthenticateClientToSession(self: *const T, SessionId: ?*WTS_SESSION_ID) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).AuthenticateClientToSession(@as(*const IWRdsProtocolConnection, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_NotifySessionId(self: *const T, SessionId: ?*WTS_SESSION_ID, SessionHandle: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).NotifySessionId(@as(*const IWRdsProtocolConnection, @ptrCast(self)), SessionId, SessionHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetInputHandles(self: *const T, pKeyboardHandle: ?*HANDLE_PTR, pMouseHandle: ?*HANDLE_PTR, pBeepHandle: ?*HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetInputHandles(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pKeyboardHandle, pMouseHandle, pBeepHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetVideoHandle(self: *const T, pVideoHandle: ?*HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetVideoHandle(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pVideoHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_ConnectNotify(self: *const T, SessionId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).ConnectNotify(@as(*const IWRdsProtocolConnection, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_IsUserAllowedToLogon(self: *const T, SessionId: u32, UserToken: HANDLE_PTR, pDomainName: ?PWSTR, pUserName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).IsUserAllowedToLogon(@as(*const IWRdsProtocolConnection, @ptrCast(self)), SessionId, UserToken, pDomainName, pUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_SessionArbitrationEnumeration(self: *const T, hUserToken: HANDLE_PTR, bSingleSessionPerUserEnabled: BOOL, pSessionIdArray: [*]u32, pdwSessionIdentifierCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).SessionArbitrationEnumeration(@as(*const IWRdsProtocolConnection, @ptrCast(self)), hUserToken, bSingleSessionPerUserEnabled, pSessionIdArray, pdwSessionIdentifierCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_LogonNotify(self: *const T, hClientToken: HANDLE_PTR, wszUserName: ?PWSTR, wszDomainName: ?PWSTR, SessionId: ?*WTS_SESSION_ID, pWRdsConnectionSettings: ?*WRDS_CONNECTION_SETTINGS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).LogonNotify(@as(*const IWRdsProtocolConnection, @ptrCast(self)), hClientToken, wszUserName, wszDomainName, SessionId, pWRdsConnectionSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_PreDisconnect(self: *const T, DisconnectReason: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).PreDisconnect(@as(*const IWRdsProtocolConnection, @ptrCast(self)), DisconnectReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_DisconnectNotify(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).DisconnectNotify(@as(*const IWRdsProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).Close(@as(*const IWRdsProtocolConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetProtocolStatus(self: *const T, pProtocolStatus: ?*WTS_PROTOCOL_STATUS) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetProtocolStatus(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pProtocolStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetLastInputTime(self: *const T, pLastInputTime: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetLastInputTime(@as(*const IWRdsProtocolConnection, @ptrCast(self)), pLastInputTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_SetErrorInfo(self: *const T, ulError: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).SetErrorInfo(@as(*const IWRdsProtocolConnection, @ptrCast(self)), ulError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_CreateVirtualChannel(self: *const T, szEndpointName: ?PSTR, bStatic: BOOL, RequestedPriority: u32, phChannel: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).CreateVirtualChannel(@as(*const IWRdsProtocolConnection, @ptrCast(self)), szEndpointName, bStatic, RequestedPriority, phChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_QueryProperty(self: *const T, QueryType: Guid, ulNumEntriesIn: u32, ulNumEntriesOut: u32, pPropertyEntriesIn: [*]WTS_PROPERTY_VALUE, pPropertyEntriesOut: [*]WTS_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).QueryProperty(@as(*const IWRdsProtocolConnection, @ptrCast(self)), QueryType, ulNumEntriesIn, ulNumEntriesOut, pPropertyEntriesIn, pPropertyEntriesOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_GetShadowConnection(self: *const T, ppShadowConnection: ?*?*IWRdsProtocolShadowConnection) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).GetShadowConnection(@as(*const IWRdsProtocolConnection, @ptrCast(self)), ppShadowConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnection_NotifyCommandProcessCreated(self: *const T, SessionId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnection.VTable, @ptrCast(self.vtable)).NotifyCommandProcessCreated(@as(*const IWRdsProtocolConnection, @ptrCast(self)), SessionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolConnectionCallback_Value = Guid.initString("f1d70332-d070-4ef1-a088-78313536c2d6");
pub const IID_IWRdsProtocolConnectionCallback = &IID_IWRdsProtocolConnectionCallback_Value;
pub const IWRdsProtocolConnectionCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BrokenConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionCallback,
                Reason: u32,
                Source: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionCallback,
                Reason: u32,
                Source: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopScreenUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedrawWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionCallback,
                rect: ?*WTS_SMALL_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionCallback,
                rect: ?*WTS_SMALL_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionCallback,
                pConnectionId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionCallback,
                pConnectionId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionCallback_OnReady(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).OnReady(@as(*const IWRdsProtocolConnectionCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionCallback_BrokenConnection(self: *const T, Reason: u32, Source: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).BrokenConnection(@as(*const IWRdsProtocolConnectionCallback, @ptrCast(self)), Reason, Source);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionCallback_StopScreenUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).StopScreenUpdates(@as(*const IWRdsProtocolConnectionCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionCallback_RedrawWindow(self: *const T, rect: ?*WTS_SMALL_RECT) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).RedrawWindow(@as(*const IWRdsProtocolConnectionCallback, @ptrCast(self)), rect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionCallback_GetConnectionId(self: *const T, pConnectionId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionCallback.VTable, @ptrCast(self.vtable)).GetConnectionId(@as(*const IWRdsProtocolConnectionCallback, @ptrCast(self)), pConnectionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolShadowConnection_Value = Guid.initString("9ae85ce6-cade-4548-8feb-99016597f60a");
pub const IID_IWRdsProtocolShadowConnection = &IID_IWRdsProtocolShadowConnection_Value;
pub const IWRdsProtocolShadowConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolShadowConnection,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                HotKeyVk: u8,
                HotkeyModifiers: u16,
                pShadowCallback: ?*IWRdsProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolShadowConnection,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                HotKeyVk: u8,
                HotkeyModifiers: u16,
                pShadowCallback: ?*IWRdsProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolShadowConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolShadowConnection,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolShadowConnection,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolShadowConnection_Start(self: *const T, pTargetServerName: ?PWSTR, TargetSessionId: u32, HotKeyVk: u8, HotkeyModifiers: u16, pShadowCallback: ?*IWRdsProtocolShadowCallback) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolShadowConnection.VTable, @ptrCast(self.vtable)).Start(@as(*const IWRdsProtocolShadowConnection, @ptrCast(self)), pTargetServerName, TargetSessionId, HotKeyVk, HotkeyModifiers, pShadowCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolShadowConnection_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolShadowConnection.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWRdsProtocolShadowConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolShadowConnection_DoTarget(self: *const T, pParam1: [*:0]u8, Param1Size: u32, pParam2: [*:0]u8, Param2Size: u32, pParam3: [*:0]u8, Param3Size: u32, pParam4: [*:0]u8, Param4Size: u32, pClientName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolShadowConnection.VTable, @ptrCast(self.vtable)).DoTarget(@as(*const IWRdsProtocolShadowConnection, @ptrCast(self)), pParam1, Param1Size, pParam2, Param2Size, pParam3, Param3Size, pParam4, Param4Size, pClientName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolShadowCallback_Value = Guid.initString("e0667ce0-0372-40d6-adb2-a0f3322674d6");
pub const IID_IWRdsProtocolShadowCallback = &IID_IWRdsProtocolShadowCallback_Value;
pub const IWRdsProtocolShadowCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StopShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolShadowCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeTargetShadow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolShadowCallback,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolShadowCallback,
                pTargetServerName: ?PWSTR,
                TargetSessionId: u32,
                pParam1: [*:0]u8,
                Param1Size: u32,
                pParam2: [*:0]u8,
                Param2Size: u32,
                pParam3: [*:0]u8,
                Param3Size: u32,
                pParam4: [*:0]u8,
                Param4Size: u32,
                pClientName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolShadowCallback_StopShadow(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolShadowCallback.VTable, @ptrCast(self.vtable)).StopShadow(@as(*const IWRdsProtocolShadowCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolShadowCallback_InvokeTargetShadow(self: *const T, pTargetServerName: ?PWSTR, TargetSessionId: u32, pParam1: [*:0]u8, Param1Size: u32, pParam2: [*:0]u8, Param2Size: u32, pParam3: [*:0]u8, Param3Size: u32, pParam4: [*:0]u8, Param4Size: u32, pClientName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolShadowCallback.VTable, @ptrCast(self.vtable)).InvokeTargetShadow(@as(*const IWRdsProtocolShadowCallback, @ptrCast(self)), pTargetServerName, TargetSessionId, pParam1, Param1Size, pParam2, Param2Size, pParam3, Param3Size, pParam4, Param4Size, pClientName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolLicenseConnection_Value = Guid.initString("1d6a145f-d095-4424-957a-407fae822d84");
pub const IID_IWRdsProtocolLicenseConnection = &IID_IWRdsProtocolLicenseConnection_Value;
pub const IWRdsProtocolLicenseConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestLicensingCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLicenseConnection,
                ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES,
                pcbLicenseCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLicenseConnection,
                ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES,
                pcbLicenseCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendClientLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLicenseConnection,
                pClientLicense: [*:0]u8,
                cbClientLicense: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLicenseConnection,
                pClientLicense: [*:0]u8,
                cbClientLicense: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestClientLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLicenseConnection,
                Reserve1: [*:0]u8,
                Reserve2: u32,
                ppClientLicense: [*:0]u8,
                pcbClientLicense: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLicenseConnection,
                Reserve1: [*:0]u8,
                Reserve2: u32,
                ppClientLicense: [*:0]u8,
                pcbClientLicense: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProtocolComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLicenseConnection,
                ulComplete: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLicenseConnection,
                ulComplete: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLicenseConnection_RequestLicensingCapabilities(self: *const T, ppLicenseCapabilities: ?*WTS_LICENSE_CAPABILITIES, pcbLicenseCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).RequestLicensingCapabilities(@as(*const IWRdsProtocolLicenseConnection, @ptrCast(self)), ppLicenseCapabilities, pcbLicenseCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLicenseConnection_SendClientLicense(self: *const T, pClientLicense: [*:0]u8, cbClientLicense: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).SendClientLicense(@as(*const IWRdsProtocolLicenseConnection, @ptrCast(self)), pClientLicense, cbClientLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLicenseConnection_RequestClientLicense(self: *const T, Reserve1: [*:0]u8, Reserve2: u32, ppClientLicense: [*:0]u8, pcbClientLicense: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).RequestClientLicense(@as(*const IWRdsProtocolLicenseConnection, @ptrCast(self)), Reserve1, Reserve2, ppClientLicense, pcbClientLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLicenseConnection_ProtocolComplete(self: *const T, ulComplete: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLicenseConnection.VTable, @ptrCast(self.vtable)).ProtocolComplete(@as(*const IWRdsProtocolLicenseConnection, @ptrCast(self)), ulComplete);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IWRdsProtocolLogonErrorRedirector_Value = Guid.initString("519fe83b-142a-4120-a3d5-a405d315281a");
pub const IID_IWRdsProtocolLogonErrorRedirector = &IID_IWRdsProtocolLogonErrorRedirector_Value;
pub const IWRdsProtocolLogonErrorRedirector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBeginPainting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                pszMessage: ?[*:0]const u16,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                pszMessage: ?[*:0]const u16,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RedirectLogonError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                ntsStatus: i32,
                ntsSubstatus: i32,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolLogonErrorRedirector,
                ntsStatus: i32,
                ntsSubstatus: i32,
                pszCaption: ?[*:0]const u16,
                pszMessage: ?[*:0]const u16,
                uType: u32,
                pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLogonErrorRedirector_OnBeginPainting(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).OnBeginPainting(@as(*const IWRdsProtocolLogonErrorRedirector, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLogonErrorRedirector_RedirectStatus(self: *const T, pszMessage: ?[*:0]const u16, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectStatus(@as(*const IWRdsProtocolLogonErrorRedirector, @ptrCast(self)), pszMessage, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLogonErrorRedirector_RedirectMessage(self: *const T, pszCaption: ?[*:0]const u16, pszMessage: ?[*:0]const u16, uType: u32, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectMessage(@as(*const IWRdsProtocolLogonErrorRedirector, @ptrCast(self)), pszCaption, pszMessage, uType, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolLogonErrorRedirector_RedirectLogonError(self: *const T, ntsStatus: i32, ntsSubstatus: i32, pszCaption: ?[*:0]const u16, pszMessage: ?[*:0]const u16, uType: u32, pResponse: ?*WTS_LOGON_ERROR_REDIRECTOR_RESPONSE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolLogonErrorRedirector.VTable, @ptrCast(self.vtable)).RedirectLogonError(@as(*const IWRdsProtocolLogonErrorRedirector, @ptrCast(self)), ntsStatus, ntsSubstatus, pszCaption, pszMessage, uType, pResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWRdsWddmIddProps_Value = Guid.initString("1382df4d-a289-43d1-a184-144726f9af90");
pub const IID_IWRdsWddmIddProps = &IID_IWRdsWddmIddProps_Value;
pub const IWRdsWddmIddProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHardwareId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsWddmIddProps,
                pDisplayDriverHardwareId: [*:0]u16,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsWddmIddProps,
                pDisplayDriverHardwareId: [*:0]u16,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDriverLoad: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsWddmIddProps,
                SessionId: u32,
                DriverHandle: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsWddmIddProps,
                SessionId: u32,
                DriverHandle: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDriverUnload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsWddmIddProps,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsWddmIddProps,
                SessionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableWddmIdd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsWddmIddProps,
                Enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsWddmIddProps,
                Enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsWddmIddProps_GetHardwareId(self: *const T, pDisplayDriverHardwareId: [*:0]u16, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsWddmIddProps.VTable, @ptrCast(self.vtable)).GetHardwareId(@as(*const IWRdsWddmIddProps, @ptrCast(self)), pDisplayDriverHardwareId, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsWddmIddProps_OnDriverLoad(self: *const T, SessionId: u32, DriverHandle: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @as(*const IWRdsWddmIddProps.VTable, @ptrCast(self.vtable)).OnDriverLoad(@as(*const IWRdsWddmIddProps, @ptrCast(self)), SessionId, DriverHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsWddmIddProps_OnDriverUnload(self: *const T, SessionId: u32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsWddmIddProps.VTable, @ptrCast(self.vtable)).OnDriverUnload(@as(*const IWRdsWddmIddProps, @ptrCast(self)), SessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsWddmIddProps_EnableWddmIdd(self: *const T, Enabled: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IWRdsWddmIddProps.VTable, @ptrCast(self.vtable)).EnableWddmIdd(@as(*const IWRdsWddmIddProps, @ptrCast(self)), Enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWRdsProtocolConnectionSettings_Value = Guid.initString("83fcf5d3-f6f4-ea94-9cd2-32f280e1e510");
pub const IID_IWRdsProtocolConnectionSettings = &IID_IWRdsProtocolConnectionSettings_Value;
pub const IWRdsProtocolConnectionSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetConnectionSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionSettings,
                PropertyID: Guid,
                pPropertyEntriesIn: ?*WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionSettings,
                PropertyID: Guid,
                pPropertyEntriesIn: ?*WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsProtocolConnectionSettings,
                PropertyID: Guid,
                pPropertyEntriesOut: ?*WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsProtocolConnectionSettings,
                PropertyID: Guid,
                pPropertyEntriesOut: ?*WTS_PROPERTY_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionSettings_SetConnectionSetting(self: *const T, PropertyID: Guid, pPropertyEntriesIn: ?*WTS_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionSettings.VTable, @ptrCast(self.vtable)).SetConnectionSetting(@as(*const IWRdsProtocolConnectionSettings, @ptrCast(self)), PropertyID, pPropertyEntriesIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsProtocolConnectionSettings_GetConnectionSetting(self: *const T, PropertyID: Guid, pPropertyEntriesOut: ?*WTS_PROPERTY_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IWRdsProtocolConnectionSettings.VTable, @ptrCast(self.vtable)).GetConnectionSetting(@as(*const IWRdsProtocolConnectionSettings, @ptrCast(self)), PropertyID, pPropertyEntriesOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWRdsEnhancedFastReconnectArbitrator_Value = Guid.initString("5718ae9b-47f2-499f-b634-d8175bd51131");
pub const IID_IWRdsEnhancedFastReconnectArbitrator = &IID_IWRdsEnhancedFastReconnectArbitrator_Value;
pub const IWRdsEnhancedFastReconnectArbitrator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSessionForEnhancedFastReconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWRdsEnhancedFastReconnectArbitrator,
                pSessionIdArray: ?*i32,
                dwSessionCount: u32,
                pResultSessionId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWRdsEnhancedFastReconnectArbitrator,
                pSessionIdArray: ?*i32,
                dwSessionCount: u32,
                pResultSessionId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWRdsEnhancedFastReconnectArbitrator_GetSessionForEnhancedFastReconnect(self: *const T, pSessionIdArray: ?*i32, dwSessionCount: u32, pResultSessionId: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWRdsEnhancedFastReconnectArbitrator.VTable, @ptrCast(self.vtable)).GetSessionForEnhancedFastReconnect(@as(*const IWRdsEnhancedFastReconnectArbitrator, @ptrCast(self)), pSessionIdArray, dwSessionCount, pResultSessionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PasswordEncodingType = enum(i32) {
    @"8" = 0,
    @"16LE" = 1,
    @"16BE" = 2,
};
pub const PasswordEncodingUTF8 = PasswordEncodingType.@"8";
pub const PasswordEncodingUTF16LE = PasswordEncodingType.@"16LE";
pub const PasswordEncodingUTF16BE = PasswordEncodingType.@"16BE";

// TODO: this type is limited to platform 'windows8.0'
const IID_IRemoteDesktopClientSettings_Value = Guid.initString("48a0f2a7-2713-431f-bbac-6f4558e7d64d");
pub const IID_IRemoteDesktopClientSettings = &IID_IRemoteDesktopClientSettings_Value;
pub const IRemoteDesktopClientSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ApplySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientSettings,
                rdpFileContents: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientSettings,
                rdpFileContents: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RetrieveSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientSettings,
                rdpFileContents: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientSettings,
                rdpFileContents: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRdpProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientSettings,
                propertyName: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientSettings,
                propertyName: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRdpProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientSettings,
                propertyName: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientSettings,
                propertyName: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientSettings_ApplySettings(self: *const T, rdpFileContents: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientSettings.VTable, @ptrCast(self.vtable)).ApplySettings(@as(*const IRemoteDesktopClientSettings, @ptrCast(self)), rdpFileContents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientSettings_RetrieveSettings(self: *const T, rdpFileContents: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientSettings.VTable, @ptrCast(self.vtable)).RetrieveSettings(@as(*const IRemoteDesktopClientSettings, @ptrCast(self)), rdpFileContents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientSettings_GetRdpProperty(self: *const T, propertyName: ?BSTR, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientSettings.VTable, @ptrCast(self.vtable)).GetRdpProperty(@as(*const IRemoteDesktopClientSettings, @ptrCast(self)), propertyName, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientSettings_SetRdpProperty(self: *const T, propertyName: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientSettings.VTable, @ptrCast(self.vtable)).SetRdpProperty(@as(*const IRemoteDesktopClientSettings, @ptrCast(self)), propertyName, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RemoteActionType = enum(i32) {
    Charms = 0,
    Appbar = 1,
    Snap = 2,
    StartScreen = 3,
    AppSwitch = 4,
};
pub const RemoteActionCharms = RemoteActionType.Charms;
pub const RemoteActionAppbar = RemoteActionType.Appbar;
pub const RemoteActionSnap = RemoteActionType.Snap;
pub const RemoteActionStartScreen = RemoteActionType.StartScreen;
pub const RemoteActionAppSwitch = RemoteActionType.AppSwitch;

pub const SnapshotEncodingType = enum(i32) {
    i = 0,
};
pub const SnapshotEncodingDataUri = SnapshotEncodingType.i;

pub const SnapshotFormatType = enum(i32) {
    Png = 0,
    Jpeg = 1,
    Bmp = 2,
};
pub const SnapshotFormatPng = SnapshotFormatType.Png;
pub const SnapshotFormatJpeg = SnapshotFormatType.Jpeg;
pub const SnapshotFormatBmp = SnapshotFormatType.Bmp;

// TODO: this type is limited to platform 'windows8.0'
const IID_IRemoteDesktopClientActions_Value = Guid.initString("7d54bc4e-1028-45d4-8b0a-b9b6bffba176");
pub const IID_IRemoteDesktopClientActions = &IID_IRemoteDesktopClientActions_Value;
pub const IRemoteDesktopClientActions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SuspendScreenUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeScreenUpdates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteRemoteAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientActions,
                remoteAction: RemoteActionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientActions,
                remoteAction: RemoteActionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSnapshot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClientActions,
                snapshotEncoding: SnapshotEncodingType,
                snapshotFormat: SnapshotFormatType,
                snapshotWidth: u32,
                snapshotHeight: u32,
                snapshotData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClientActions,
                snapshotEncoding: SnapshotEncodingType,
                snapshotFormat: SnapshotFormatType,
                snapshotWidth: u32,
                snapshotHeight: u32,
                snapshotData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientActions_SuspendScreenUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientActions.VTable, @ptrCast(self.vtable)).SuspendScreenUpdates(@as(*const IRemoteDesktopClientActions, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientActions_ResumeScreenUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientActions.VTable, @ptrCast(self.vtable)).ResumeScreenUpdates(@as(*const IRemoteDesktopClientActions, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientActions_ExecuteRemoteAction(self: *const T, remoteAction: RemoteActionType) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientActions.VTable, @ptrCast(self.vtable)).ExecuteRemoteAction(@as(*const IRemoteDesktopClientActions, @ptrCast(self)), remoteAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientActions_GetSnapshot(self: *const T, snapshotEncoding: SnapshotEncodingType, snapshotFormat: SnapshotFormatType, snapshotWidth: u32, snapshotHeight: u32, snapshotData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientActions.VTable, @ptrCast(self.vtable)).GetSnapshot(@as(*const IRemoteDesktopClientActions, @ptrCast(self)), snapshotEncoding, snapshotFormat, snapshotWidth, snapshotHeight, snapshotData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IRemoteDesktopClientTouchPointer_Value = Guid.initString("260ec22d-8cbc-44b5-9e88-2a37f6c93ae9");
pub const IID_IRemoteDesktopClientTouchPointer = &IID_IRemoteDesktopClientTouchPointer_Value;
pub const IRemoteDesktopClientTouchPointer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                enabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                enabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventsEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                eventsEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                eventsEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventsEnabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                eventsEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                eventsEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PointerSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                pointerSpeed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                pointerSpeed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PointerSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClientTouchPointer,
                pointerSpeed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClientTouchPointer,
                pointerSpeed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_put_EventsEnabled(self: *const T, eventsEnabled: i16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).put_EventsEnabled(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), eventsEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_get_EventsEnabled(self: *const T, eventsEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).get_EventsEnabled(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), eventsEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_put_PointerSpeed(self: *const T, pointerSpeed: u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).put_PointerSpeed(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), pointerSpeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClientTouchPointer_get_PointerSpeed(self: *const T, pointerSpeed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClientTouchPointer.VTable, @ptrCast(self.vtable)).get_PointerSpeed(@as(*const IRemoteDesktopClientTouchPointer, @ptrCast(self)), pointerSpeed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KeyCombinationType = enum(i32) {
    Home = 0,
    Left = 1,
    Up = 2,
    Right = 3,
    Down = 4,
    Scroll = 5,
};
pub const KeyCombinationHome = KeyCombinationType.Home;
pub const KeyCombinationLeft = KeyCombinationType.Left;
pub const KeyCombinationUp = KeyCombinationType.Up;
pub const KeyCombinationRight = KeyCombinationType.Right;
pub const KeyCombinationDown = KeyCombinationType.Down;
pub const KeyCombinationScroll = KeyCombinationType.Scroll;

// TODO: this type is limited to platform 'windows8.0'
const IID_IRemoteDesktopClient_Value = Guid.initString("57d25668-625a-4905-be4e-304caa13f89c");
pub const IID_IRemoteDesktopClient = &IID_IRemoteDesktopClient_Value;
pub const IRemoteDesktopClient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                width: u32,
                height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
                width: u32,
                height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Settings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                settings: ?*?*IRemoteDesktopClientSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClient,
                settings: ?*?*IRemoteDesktopClientSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Actions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                actions: ?*?*IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClient,
                actions: ?*?*IRemoteDesktopClientActions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TouchPointer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                touchPointer: ?*?*IRemoteDesktopClientTouchPointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRemoteDesktopClient,
                touchPointer: ?*?*IRemoteDesktopClientTouchPointer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteSavedCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                serverName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
                serverName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateSessionDisplaySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                width: u32,
                height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
                width: u32,
                height: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        attachEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                eventName: ?BSTR,
                callback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
                eventName: ?BSTR,
                callback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        detachEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDesktopClient,
                eventName: ?BSTR,
                callback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDesktopClient,
                eventName: ?BSTR,
                callback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_Connect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).Connect(@as(*const IRemoteDesktopClient, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IRemoteDesktopClient, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_Reconnect(self: *const T, width: u32, height: u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).Reconnect(@as(*const IRemoteDesktopClient, @ptrCast(self)), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_get_Settings(self: *const T, settings: ?*?*IRemoteDesktopClientSettings) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).get_Settings(@as(*const IRemoteDesktopClient, @ptrCast(self)), settings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_get_Actions(self: *const T, actions: ?*?*IRemoteDesktopClientActions) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).get_Actions(@as(*const IRemoteDesktopClient, @ptrCast(self)), actions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_get_TouchPointer(self: *const T, touchPointer: ?*?*IRemoteDesktopClientTouchPointer) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).get_TouchPointer(@as(*const IRemoteDesktopClient, @ptrCast(self)), touchPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_DeleteSavedCredentials(self: *const T, serverName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).DeleteSavedCredentials(@as(*const IRemoteDesktopClient, @ptrCast(self)), serverName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_UpdateSessionDisplaySettings(self: *const T, width: u32, height: u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).UpdateSessionDisplaySettings(@as(*const IRemoteDesktopClient, @ptrCast(self)), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_attachEvent(self: *const T, eventName: ?BSTR, callback: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).attachEvent(@as(*const IRemoteDesktopClient, @ptrCast(self)), eventName, callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDesktopClient_detachEvent(self: *const T, eventName: ?BSTR, callback: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDesktopClient.VTable, @ptrCast(self.vtable)).detachEvent(@as(*const IRemoteDesktopClient, @ptrCast(self)), eventName, callback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteSystemAdditionalInfoProvider_Value = Guid.initString("eeaa3d5f-ec63-4d27-af38-e86b1d7292cb");
pub const IID_IRemoteSystemAdditionalInfoProvider = &IID_IRemoteSystemAdditionalInfoProvider_Value;
pub const IRemoteSystemAdditionalInfoProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdditionalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteSystemAdditionalInfoProvider,
                deduplicationId: ?*?HSTRING,
                riid: ?*const Guid,
                mapView: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteSystemAdditionalInfoProvider,
                deduplicationId: ?*?HSTRING,
                riid: ?*const Guid,
                mapView: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteSystemAdditionalInfoProvider_GetAdditionalInfo(self: *const T, deduplicationId: ?*?HSTRING, riid: ?*const Guid, mapView: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IRemoteSystemAdditionalInfoProvider.VTable, @ptrCast(self.vtable)).GetAdditionalInfo(@as(*const IRemoteSystemAdditionalInfoProvider, @ptrCast(self)), deduplicationId, riid, mapView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WTSSESSION_NOTIFICATION = extern struct {
    cbSize: u32,
    dwSessionId: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (65)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSStopRemoteControlSession(
    LogonId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSStartRemoteControlSessionW(
    pTargetServerName: ?PWSTR,
    TargetLogonId: u32,
    HotkeyVk: u8,
    HotkeyModifiers: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSStartRemoteControlSessionA(
    pTargetServerName: ?PSTR,
    TargetLogonId: u32,
    HotkeyVk: u8,
    HotkeyModifiers: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSConnectSessionA(
    LogonId: u32,
    TargetLogonId: u32,
    pPassword: ?PSTR,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSConnectSessionW(
    LogonId: u32,
    TargetLogonId: u32,
    pPassword: ?PWSTR,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateServersW(
    pDomainName: ?PWSTR,
    Reserved: u32,
    Version: u32,
    ppServerInfo: ?*?*WTS_SERVER_INFOW,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateServersA(
    pDomainName: ?PSTR,
    Reserved: u32,
    Version: u32,
    ppServerInfo: ?*?*WTS_SERVER_INFOA,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSOpenServerW(
    pServerName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSOpenServerA(
    pServerName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSOpenServerExW(
    pServerName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSOpenServerExA(
    pServerName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSCloseServer(
    hServer: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateSessionsW(
    hServer: ?HANDLE,
    Reserved: u32,
    Version: u32,
    ppSessionInfo: ?*?*WTS_SESSION_INFOW,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateSessionsA(
    hServer: ?HANDLE,
    Reserved: u32,
    Version: u32,
    ppSessionInfo: ?*?*WTS_SESSION_INFOA,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateSessionsExW(
    hServer: ?HANDLE,
    pLevel: ?*u32,
    Filter: u32,
    ppSessionInfo: ?*?*WTS_SESSION_INFO_1W,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateSessionsExA(
    hServer: ?HANDLE,
    pLevel: ?*u32,
    Filter: u32,
    ppSessionInfo: ?*?*WTS_SESSION_INFO_1A,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateProcessesW(
    hServer: ?HANDLE,
    Reserved: u32,
    Version: u32,
    ppProcessInfo: ?*?*WTS_PROCESS_INFOW,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSEnumerateProcessesA(
    hServer: ?HANDLE,
    Reserved: u32,
    Version: u32,
    ppProcessInfo: ?*?*WTS_PROCESS_INFOA,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSTerminateProcess(
    hServer: ?HANDLE,
    ProcessId: u32,
    ExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSQuerySessionInformationW(
    hServer: ?HANDLE,
    SessionId: u32,
    WTSInfoClass: WTS_INFO_CLASS,
    ppBuffer: ?*?PWSTR,
    pBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSQuerySessionInformationA(
    hServer: ?HANDLE,
    SessionId: u32,
    WTSInfoClass: WTS_INFO_CLASS,
    ppBuffer: ?*?PSTR,
    pBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSQueryUserConfigW(
    pServerName: ?PWSTR,
    pUserName: ?PWSTR,
    WTSConfigClass: WTS_CONFIG_CLASS,
    ppBuffer: ?*?PWSTR,
    pBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSQueryUserConfigA(
    pServerName: ?PSTR,
    pUserName: ?PSTR,
    WTSConfigClass: WTS_CONFIG_CLASS,
    ppBuffer: ?*?PSTR,
    pBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSSetUserConfigW(
    pServerName: ?PWSTR,
    pUserName: ?PWSTR,
    WTSConfigClass: WTS_CONFIG_CLASS,
    // TODO: what to do with BytesParamIndex 4?
    pBuffer: ?PWSTR,
    DataLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSSetUserConfigA(
    pServerName: ?PSTR,
    pUserName: ?PSTR,
    WTSConfigClass: WTS_CONFIG_CLASS,
    // TODO: what to do with BytesParamIndex 4?
    pBuffer: ?PSTR,
    DataLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSSendMessageW(
    hServer: ?HANDLE,
    SessionId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pTitle: ?PWSTR,
    TitleLength: u32,
    // TODO: what to do with BytesParamIndex 5?
    pMessage: ?PWSTR,
    MessageLength: u32,
    Style: MESSAGEBOX_STYLE,
    Timeout: u32,
    pResponse: ?*MESSAGEBOX_RESULT,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSSendMessageA(
    hServer: ?HANDLE,
    SessionId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pTitle: ?PSTR,
    TitleLength: u32,
    // TODO: what to do with BytesParamIndex 5?
    pMessage: ?PSTR,
    MessageLength: u32,
    Style: MESSAGEBOX_STYLE,
    Timeout: u32,
    pResponse: ?*MESSAGEBOX_RESULT,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSDisconnectSession(
    hServer: ?HANDLE,
    SessionId: u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSLogoffSession(
    hServer: ?HANDLE,
    SessionId: u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSShutdownSystem(
    hServer: ?HANDLE,
    ShutdownFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSWaitSystemEvent(
    hServer: ?HANDLE,
    EventMask: u32,
    pEventFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelOpen(
    hServer: ?HANDLE,
    SessionId: u32,
    pVirtualName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HwtsVirtualChannelHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelOpenEx(
    SessionId: u32,
    pVirtualName: ?PSTR,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HwtsVirtualChannelHandle;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelClose(
    hChannelHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelRead(
    hChannelHandle: ?HANDLE,
    TimeOut: u32,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?[*]u8,
    BufferSize: u32,
    pBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelWrite(
    hChannelHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    Buffer: ?[*]u8,
    Length: u32,
    pBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelPurgeInput(
    hChannelHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelPurgeOutput(
    hChannelHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSVirtualChannelQuery(
    hChannelHandle: ?HANDLE,
    param1: WTS_VIRTUAL_CLASS,
    ppBuffer: ?*?*anyopaque,
    pBytesReturned: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSFreeMemory(
    pMemory: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSRegisterSessionNotification(
    hWnd: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSUnRegisterSessionNotification(
    hWnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSRegisterSessionNotificationEx(
    hServer: ?HANDLE,
    hWnd: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSUnRegisterSessionNotificationEx(
    hServer: ?HANDLE,
    hWnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "wtsapi32" fn WTSQueryUserToken(
    SessionId: u32,
    phToken: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSFreeMemoryExW(
    WTSTypeClass: WTS_TYPE_CLASS,
    pMemory: ?*anyopaque,
    NumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSFreeMemoryExA(
    WTSTypeClass: WTS_TYPE_CLASS,
    pMemory: ?*anyopaque,
    NumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateProcessesExW(
    hServer: ?HANDLE,
    pLevel: ?*u32,
    SessionId: u32,
    ppProcessInfo: ?*?PWSTR,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateProcessesExA(
    hServer: ?HANDLE,
    pLevel: ?*u32,
    SessionId: u32,
    ppProcessInfo: ?*?PSTR,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateListenersW(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListeners: ?[*]?*u16,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSEnumerateListenersA(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListeners: ?[*]?*i8,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSQueryListenerConfigW(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PWSTR,
    pBuffer: ?*WTSLISTENERCONFIGW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSQueryListenerConfigA(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PSTR,
    pBuffer: ?*WTSLISTENERCONFIGA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSCreateListenerW(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PWSTR,
    pBuffer: ?*WTSLISTENERCONFIGW,
    flag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSCreateListenerA(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PSTR,
    pBuffer: ?*WTSLISTENERCONFIGA,
    flag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSSetListenerSecurityW(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PWSTR,
    SecurityInformation: u32,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSSetListenerSecurityA(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PSTR,
    SecurityInformation: u32,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSGetListenerSecurityW(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PWSTR,
    SecurityInformation: u32,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wtsapi32" fn WTSGetListenerSecurityA(
    hServer: ?HANDLE,
    pReserved: ?*anyopaque,
    Reserved: u32,
    pListenerName: ?PSTR,
    SecurityInformation: u32,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wtsapi32" fn WTSEnableChildSessions(
    bEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wtsapi32" fn WTSIsChildSessionsEnabled(
    pbEnabled: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wtsapi32" fn WTSGetChildSessionId(
    pSessionId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wtsapi32" fn WTSSetRenderHint(
    pRenderHintID: ?*u64,
    hwndOwner: ?HWND,
    renderHintType: u32,
    cbHintDataLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    pHintData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn ProcessIdToSessionId(
    dwProcessId: u32,
    pSessionId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn WTSGetActiveConsoleSessionId(
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (34)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WTS_SERVER_INFO = thismodule.WTS_SERVER_INFOA;
        pub const WTS_SESSION_INFO = thismodule.WTS_SESSION_INFOA;
        pub const WTS_SESSION_INFO_1 = thismodule.WTS_SESSION_INFO_1A;
        pub const WTS_PROCESS_INFO = thismodule.WTS_PROCESS_INFOA;
        pub const WTSCONFIGINFO = thismodule.WTSCONFIGINFOA;
        pub const WTSINFO = thismodule.WTSINFOA;
        pub const WTSINFOEX_LEVEL1_ = thismodule.WTSINFOEX_LEVEL1_A;
        pub const WTSINFOEX_LEVEL_ = thismodule.WTSINFOEX_LEVEL_A;
        pub const WTSINFOEX = thismodule.WTSINFOEXA;
        pub const WTSCLIENT = thismodule.WTSCLIENTA;
        pub const _WTS_PRODUCT_INFO = thismodule._WTS_PRODUCT_INFOA;
        pub const WTS_VALIDATION_INFORMATION = thismodule.WTS_VALIDATION_INFORMATIONA;
        pub const WTSUSERCONFIG = thismodule.WTSUSERCONFIGA;
        pub const WTS_PROCESS_INFO_EX = thismodule.WTS_PROCESS_INFO_EXA;
        pub const WTSLISTENERCONFIG = thismodule.WTSLISTENERCONFIGA;
        pub const WTSStartRemoteControlSession = thismodule.WTSStartRemoteControlSessionA;
        pub const WTSConnectSession = thismodule.WTSConnectSessionA;
        pub const WTSEnumerateServers = thismodule.WTSEnumerateServersA;
        pub const WTSOpenServer = thismodule.WTSOpenServerA;
        pub const WTSOpenServerEx = thismodule.WTSOpenServerExA;
        pub const WTSEnumerateSessions = thismodule.WTSEnumerateSessionsA;
        pub const WTSEnumerateSessionsEx = thismodule.WTSEnumerateSessionsExA;
        pub const WTSEnumerateProcesses = thismodule.WTSEnumerateProcessesA;
        pub const WTSQuerySessionInformation = thismodule.WTSQuerySessionInformationA;
        pub const WTSQueryUserConfig = thismodule.WTSQueryUserConfigA;
        pub const WTSSetUserConfig = thismodule.WTSSetUserConfigA;
        pub const WTSSendMessage = thismodule.WTSSendMessageA;
        pub const WTSFreeMemoryEx = thismodule.WTSFreeMemoryExA;
        pub const WTSEnumerateProcessesEx = thismodule.WTSEnumerateProcessesExA;
        pub const WTSEnumerateListeners = thismodule.WTSEnumerateListenersA;
        pub const WTSQueryListenerConfig = thismodule.WTSQueryListenerConfigA;
        pub const WTSCreateListener = thismodule.WTSCreateListenerA;
        pub const WTSSetListenerSecurity = thismodule.WTSSetListenerSecurityA;
        pub const WTSGetListenerSecurity = thismodule.WTSGetListenerSecurityA;
    },
    .wide => struct {
        pub const WTS_SERVER_INFO = thismodule.WTS_SERVER_INFOW;
        pub const WTS_SESSION_INFO = thismodule.WTS_SESSION_INFOW;
        pub const WTS_SESSION_INFO_1 = thismodule.WTS_SESSION_INFO_1W;
        pub const WTS_PROCESS_INFO = thismodule.WTS_PROCESS_INFOW;
        pub const WTSCONFIGINFO = thismodule.WTSCONFIGINFOW;
        pub const WTSINFO = thismodule.WTSINFOW;
        pub const WTSINFOEX_LEVEL1_ = thismodule.WTSINFOEX_LEVEL1_W;
        pub const WTSINFOEX_LEVEL_ = thismodule.WTSINFOEX_LEVEL_W;
        pub const WTSINFOEX = thismodule.WTSINFOEXW;
        pub const WTSCLIENT = thismodule.WTSCLIENTW;
        pub const _WTS_PRODUCT_INFO = thismodule._WTS_PRODUCT_INFOW;
        pub const WTS_VALIDATION_INFORMATION = thismodule.WTS_VALIDATION_INFORMATIONW;
        pub const WTSUSERCONFIG = thismodule.WTSUSERCONFIGW;
        pub const WTS_PROCESS_INFO_EX = thismodule.WTS_PROCESS_INFO_EXW;
        pub const WTSLISTENERCONFIG = thismodule.WTSLISTENERCONFIGW;
        pub const WTSStartRemoteControlSession = thismodule.WTSStartRemoteControlSessionW;
        pub const WTSConnectSession = thismodule.WTSConnectSessionW;
        pub const WTSEnumerateServers = thismodule.WTSEnumerateServersW;
        pub const WTSOpenServer = thismodule.WTSOpenServerW;
        pub const WTSOpenServerEx = thismodule.WTSOpenServerExW;
        pub const WTSEnumerateSessions = thismodule.WTSEnumerateSessionsW;
        pub const WTSEnumerateSessionsEx = thismodule.WTSEnumerateSessionsExW;
        pub const WTSEnumerateProcesses = thismodule.WTSEnumerateProcessesW;
        pub const WTSQuerySessionInformation = thismodule.WTSQuerySessionInformationW;
        pub const WTSQueryUserConfig = thismodule.WTSQueryUserConfigW;
        pub const WTSSetUserConfig = thismodule.WTSSetUserConfigW;
        pub const WTSSendMessage = thismodule.WTSSendMessageW;
        pub const WTSFreeMemoryEx = thismodule.WTSFreeMemoryExW;
        pub const WTSEnumerateProcessesEx = thismodule.WTSEnumerateProcessesExW;
        pub const WTSEnumerateListeners = thismodule.WTSEnumerateListenersW;
        pub const WTSQueryListenerConfig = thismodule.WTSQueryListenerConfigW;
        pub const WTSCreateListener = thismodule.WTSCreateListenerW;
        pub const WTSSetListenerSecurity = thismodule.WTSSetListenerSecurityW;
        pub const WTSGetListenerSecurity = thismodule.WTSGetListenerSecurityW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WTS_SERVER_INFO = *opaque{};
        pub const WTS_SESSION_INFO = *opaque{};
        pub const WTS_SESSION_INFO_1 = *opaque{};
        pub const WTS_PROCESS_INFO = *opaque{};
        pub const WTSCONFIGINFO = *opaque{};
        pub const WTSINFO = *opaque{};
        pub const WTSINFOEX_LEVEL1_ = *opaque{};
        pub const WTSINFOEX_LEVEL_ = *opaque{};
        pub const WTSINFOEX = *opaque{};
        pub const WTSCLIENT = *opaque{};
        pub const _WTS_PRODUCT_INFO = *opaque{};
        pub const WTS_VALIDATION_INFORMATION = *opaque{};
        pub const WTSUSERCONFIG = *opaque{};
        pub const WTS_PROCESS_INFO_EX = *opaque{};
        pub const WTSLISTENERCONFIG = *opaque{};
        pub const WTSStartRemoteControlSession = *opaque{};
        pub const WTSConnectSession = *opaque{};
        pub const WTSEnumerateServers = *opaque{};
        pub const WTSOpenServer = *opaque{};
        pub const WTSOpenServerEx = *opaque{};
        pub const WTSEnumerateSessions = *opaque{};
        pub const WTSEnumerateSessionsEx = *opaque{};
        pub const WTSEnumerateProcesses = *opaque{};
        pub const WTSQuerySessionInformation = *opaque{};
        pub const WTSQueryUserConfig = *opaque{};
        pub const WTSSetUserConfig = *opaque{};
        pub const WTSSendMessage = *opaque{};
        pub const WTSFreeMemoryEx = *opaque{};
        pub const WTSEnumerateProcessesEx = *opaque{};
        pub const WTSEnumerateListeners = *opaque{};
        pub const WTSQueryListenerConfig = *opaque{};
        pub const WTSCreateListener = *opaque{};
        pub const WTSSetListenerSecurity = *opaque{};
        pub const WTSGetListenerSecurity = *opaque{};
    } else struct {
        pub const WTS_SERVER_INFO = @compileError("'WTS_SERVER_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WTS_SESSION_INFO = @compileError("'WTS_SESSION_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WTS_SESSION_INFO_1 = @compileError("'WTS_SESSION_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const WTS_PROCESS_INFO = @compileError("'WTS_PROCESS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WTSCONFIGINFO = @compileError("'WTSCONFIGINFO' requires that UNICODE be set to true or false in the root module");
        pub const WTSINFO = @compileError("'WTSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WTSINFOEX_LEVEL1_ = @compileError("'WTSINFOEX_LEVEL1_' requires that UNICODE be set to true or false in the root module");
        pub const WTSINFOEX_LEVEL_ = @compileError("'WTSINFOEX_LEVEL_' requires that UNICODE be set to true or false in the root module");
        pub const WTSINFOEX = @compileError("'WTSINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const WTSCLIENT = @compileError("'WTSCLIENT' requires that UNICODE be set to true or false in the root module");
        pub const _WTS_PRODUCT_INFO = @compileError("'_WTS_PRODUCT_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WTS_VALIDATION_INFORMATION = @compileError("'WTS_VALIDATION_INFORMATION' requires that UNICODE be set to true or false in the root module");
        pub const WTSUSERCONFIG = @compileError("'WTSUSERCONFIG' requires that UNICODE be set to true or false in the root module");
        pub const WTS_PROCESS_INFO_EX = @compileError("'WTS_PROCESS_INFO_EX' requires that UNICODE be set to true or false in the root module");
        pub const WTSLISTENERCONFIG = @compileError("'WTSLISTENERCONFIG' requires that UNICODE be set to true or false in the root module");
        pub const WTSStartRemoteControlSession = @compileError("'WTSStartRemoteControlSession' requires that UNICODE be set to true or false in the root module");
        pub const WTSConnectSession = @compileError("'WTSConnectSession' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateServers = @compileError("'WTSEnumerateServers' requires that UNICODE be set to true or false in the root module");
        pub const WTSOpenServer = @compileError("'WTSOpenServer' requires that UNICODE be set to true or false in the root module");
        pub const WTSOpenServerEx = @compileError("'WTSOpenServerEx' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateSessions = @compileError("'WTSEnumerateSessions' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateSessionsEx = @compileError("'WTSEnumerateSessionsEx' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateProcesses = @compileError("'WTSEnumerateProcesses' requires that UNICODE be set to true or false in the root module");
        pub const WTSQuerySessionInformation = @compileError("'WTSQuerySessionInformation' requires that UNICODE be set to true or false in the root module");
        pub const WTSQueryUserConfig = @compileError("'WTSQueryUserConfig' requires that UNICODE be set to true or false in the root module");
        pub const WTSSetUserConfig = @compileError("'WTSSetUserConfig' requires that UNICODE be set to true or false in the root module");
        pub const WTSSendMessage = @compileError("'WTSSendMessage' requires that UNICODE be set to true or false in the root module");
        pub const WTSFreeMemoryEx = @compileError("'WTSFreeMemoryEx' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateProcessesEx = @compileError("'WTSEnumerateProcessesEx' requires that UNICODE be set to true or false in the root module");
        pub const WTSEnumerateListeners = @compileError("'WTSEnumerateListeners' requires that UNICODE be set to true or false in the root module");
        pub const WTSQueryListenerConfig = @compileError("'WTSQueryListenerConfig' requires that UNICODE be set to true or false in the root module");
        pub const WTSCreateListener = @compileError("'WTSCreateListener' requires that UNICODE be set to true or false in the root module");
        pub const WTSSetListenerSecurity = @compileError("'WTSSetListenerSecurity' requires that UNICODE be set to true or false in the root module");
        pub const WTSGetListenerSecurity = @compileError("'WTSGetListenerSecurity' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (26)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const APO_CONNECTION_PROPERTY = @import("../media/audio/apo.zig").APO_CONNECTION_PROPERTY;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HANDLE_PTR = @import("../foundation.zig").HANDLE_PTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HSTRING = @import("../system/win_rt.zig").HSTRING;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const MESSAGEBOX_RESULT = @import("../ui/windows_and_messaging.zig").MESSAGEBOX_RESULT;
const MESSAGEBOX_STYLE = @import("../ui/windows_and_messaging.zig").MESSAGEBOX_STYLE;
const PSECURITY_DESCRIPTOR = @import("../security.zig").PSECURITY_DESCRIPTOR;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const VARIANT = @import("../system/com.zig").VARIANT;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PCHANNEL_INIT_EVENT_FN")) { _ = PCHANNEL_INIT_EVENT_FN; }
    if (@hasDecl(@This(), "PCHANNEL_OPEN_EVENT_FN")) { _ = PCHANNEL_OPEN_EVENT_FN; }
    if (@hasDecl(@This(), "PVIRTUALCHANNELINIT")) { _ = PVIRTUALCHANNELINIT; }
    if (@hasDecl(@This(), "PVIRTUALCHANNELOPEN")) { _ = PVIRTUALCHANNELOPEN; }
    if (@hasDecl(@This(), "PVIRTUALCHANNELCLOSE")) { _ = PVIRTUALCHANNELCLOSE; }
    if (@hasDecl(@This(), "PVIRTUALCHANNELWRITE")) { _ = PVIRTUALCHANNELWRITE; }
    if (@hasDecl(@This(), "PVIRTUALCHANNELENTRY")) { _ = PVIRTUALCHANNELENTRY; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
