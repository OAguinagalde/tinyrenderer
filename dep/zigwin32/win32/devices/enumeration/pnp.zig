//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (47)
//--------------------------------------------------------------------------------
pub const UPNP_E_ROOT_ELEMENT_EXPECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const UPNP_E_DEVICE_ELEMENT_EXPECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const UPNP_E_SERVICE_ELEMENT_EXPECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const UPNP_E_SERVICE_NODE_INCOMPLETE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const UPNP_E_DEVICE_NODE_INCOMPLETE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const UPNP_E_ICON_ELEMENT_EXPECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const UPNP_E_ICON_NODE_INCOMPLETE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const UPNP_E_INVALID_ACTION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const UPNP_E_INVALID_ARGUMENTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const UPNP_E_OUT_OF_SYNC = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const UPNP_E_ACTION_REQUEST_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const UPNP_E_TRANSPORT_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const UPNP_E_VARIABLE_VALUE_UNKNOWN = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const UPNP_E_INVALID_VARIABLE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const UPNP_E_DEVICE_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const UPNP_E_PROTOCOL_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const UPNP_E_ERROR_PROCESSING_RESPONSE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const UPNP_E_DEVICE_TIMEOUT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const UPNP_E_INVALID_DOCUMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220224));
pub const UPNP_E_EVENT_SUBSCRIPTION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220223));
pub const FAULT_INVALID_ACTION = @as(u32, 401);
pub const FAULT_INVALID_ARG = @as(u32, 402);
pub const FAULT_INVALID_SEQUENCE_NUMBER = @as(u32, 403);
pub const FAULT_INVALID_VARIABLE = @as(u32, 404);
pub const FAULT_DEVICE_INTERNAL_ERROR = @as(u32, 501);
pub const FAULT_ACTION_SPECIFIC_BASE = @as(u32, 600);
pub const FAULT_ACTION_SPECIFIC_MAX = @as(u32, 899);
pub const UPNP_E_ACTION_SPECIFIC_BASE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220736));
pub const UPNP_ADDRESSFAMILY_IPv4 = @as(u32, 1);
pub const UPNP_ADDRESSFAMILY_IPv6 = @as(u32, 2);
pub const UPNP_ADDRESSFAMILY_BOTH = @as(u32, 3);
pub const UPNP_SERVICE_DELAY_SCPD_AND_SUBSCRIPTION = @as(u32, 1);
pub const UPNP_E_REQUIRED_ELEMENT_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180512));
pub const UPNP_E_DUPLICATE_NOT_ALLOWED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180511));
pub const UPNP_E_DUPLICATE_SERVICE_ID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180510));
pub const UPNP_E_INVALID_DESCRIPTION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180509));
pub const UPNP_E_INVALID_SERVICE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180508));
pub const UPNP_E_INVALID_ICON = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180507));
pub const UPNP_E_INVALID_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180506));
pub const UPNP_E_INVALID_ROOT_NAMESPACE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180505));
pub const UPNP_E_SUFFIX_TOO_LONG = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180504));
pub const UPNP_E_URLBASE_PRESENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180503));
pub const UPNP_E_VALUE_TOO_LONG = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180496));
pub const UPNP_E_DEVICE_RUNNING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180495));
pub const UPNP_E_DEVICE_NOTREGISTERED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147180494));
pub const REMOTE_ADDRESS_VALUE_NAME = "RemoteAddress";
pub const ADDRESS_FAMILY_VALUE_NAME = "AddressFamily";

//--------------------------------------------------------------------------------
// Section: Types (41)
//--------------------------------------------------------------------------------
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const HSWDEVICE = *opaque{};

pub const SW_DEVICE_CAPABILITIES = enum(i32) {
    None = 0,
    Removable = 1,
    SilentInstall = 2,
    NoDisplayInUI = 4,
    DriverRequired = 8,
};
pub const SWDeviceCapabilitiesNone = SW_DEVICE_CAPABILITIES.None;
pub const SWDeviceCapabilitiesRemovable = SW_DEVICE_CAPABILITIES.Removable;
pub const SWDeviceCapabilitiesSilentInstall = SW_DEVICE_CAPABILITIES.SilentInstall;
pub const SWDeviceCapabilitiesNoDisplayInUI = SW_DEVICE_CAPABILITIES.NoDisplayInUI;
pub const SWDeviceCapabilitiesDriverRequired = SW_DEVICE_CAPABILITIES.DriverRequired;

pub const SW_DEVICE_CREATE_INFO = extern struct {
    cbSize: u32,
    pszInstanceId: ?[*:0]const u16,
    pszzHardwareIds: ?[*]const u16,
    pszzCompatibleIds: ?[*]const u16,
    pContainerId: ?*const Guid,
    CapabilityFlags: u32,
    pszDeviceDescription: ?[*:0]const u16,
    pszDeviceLocation: ?[*:0]const u16,
    pSecurityDescriptor: ?*const SECURITY_DESCRIPTOR,
};

pub const SW_DEVICE_LIFETIME = enum(i32) {
    Handle = 0,
    ParentPresent = 1,
    Max = 2,
};
pub const SWDeviceLifetimeHandle = SW_DEVICE_LIFETIME.Handle;
pub const SWDeviceLifetimeParentPresent = SW_DEVICE_LIFETIME.ParentPresent;
pub const SWDeviceLifetimeMax = SW_DEVICE_LIFETIME.Max;

pub const SW_DEVICE_CREATE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hSwDevice: ?HSWDEVICE,
        CreateResult: HRESULT,
        pContext: ?*anyopaque,
        pszDeviceInstanceId: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hSwDevice: ?HSWDEVICE,
        CreateResult: HRESULT,
        pContext: ?*anyopaque,
        pszDeviceInstanceId: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

const CLSID_UPnPDeviceFinder_Value = Guid.initString("e2085f28-feb7-404a-b8e7-e659bdeaaa02");
pub const CLSID_UPnPDeviceFinder = &CLSID_UPnPDeviceFinder_Value;

const CLSID_UPnPDevices_Value = Guid.initString("b9e84ffd-ad3c-40a4-b835-0882ebcbaaa8");
pub const CLSID_UPnPDevices = &CLSID_UPnPDevices_Value;

const CLSID_UPnPDevice_Value = Guid.initString("a32552c5-ba61-457a-b59a-a2561e125e33");
pub const CLSID_UPnPDevice = &CLSID_UPnPDevice_Value;

const CLSID_UPnPServices_Value = Guid.initString("c0bc4b4a-a406-4efc-932f-b8546b8100cc");
pub const CLSID_UPnPServices = &CLSID_UPnPServices_Value;

const CLSID_UPnPService_Value = Guid.initString("c624ba95-fbcb-4409-8c03-8cceec533ef1");
pub const CLSID_UPnPService = &CLSID_UPnPService_Value;

const CLSID_UPnPDescriptionDocument_Value = Guid.initString("1d8a9b47-3a28-4ce2-8a4b-bd34e45bceeb");
pub const CLSID_UPnPDescriptionDocument = &CLSID_UPnPDescriptionDocument_Value;

const CLSID_UPnPDeviceFinderEx_Value = Guid.initString("181b54fc-380b-4a75-b3f1-4ac45e9605b0");
pub const CLSID_UPnPDeviceFinderEx = &CLSID_UPnPDeviceFinderEx_Value;

const CLSID_UPnPDescriptionDocumentEx_Value = Guid.initString("33fd0563-d81a-4393-83cc-0195b1da2f91");
pub const CLSID_UPnPDescriptionDocumentEx = &CLSID_UPnPDescriptionDocumentEx_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDeviceFinder_Value = Guid.initString("adda3d55-6f72-4319-bff9-18600a539b10");
pub const IID_IUPnPDeviceFinder = &IID_IUPnPDeviceFinder_Value;
pub const IUPnPDeviceFinder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FindByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinder,
                bstrTypeURI: ?BSTR,
                dwFlags: u32,
                pDevices: ?*?*IUPnPDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinder,
                bstrTypeURI: ?BSTR,
                dwFlags: u32,
                pDevices: ?*?*IUPnPDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAsyncFind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinder,
                bstrTypeURI: ?BSTR,
                dwFlags: u32,
                punkDeviceFinderCallback: ?*IUnknown,
                plFindData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinder,
                bstrTypeURI: ?BSTR,
                dwFlags: u32,
                punkDeviceFinderCallback: ?*IUnknown,
                plFindData: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartAsyncFind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinder,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinder,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncFind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinder,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinder,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindByUDN: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinder,
                bstrUDN: ?BSTR,
                pDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinder,
                bstrUDN: ?BSTR,
                pDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinder_FindByType(self: *const T, bstrTypeURI: ?BSTR, dwFlags: u32, pDevices: ?*?*IUPnPDevices) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinder.VTable, @ptrCast(self.vtable)).FindByType(@as(*const IUPnPDeviceFinder, @ptrCast(self)), bstrTypeURI, dwFlags, pDevices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinder_CreateAsyncFind(self: *const T, bstrTypeURI: ?BSTR, dwFlags: u32, punkDeviceFinderCallback: ?*IUnknown, plFindData: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinder.VTable, @ptrCast(self.vtable)).CreateAsyncFind(@as(*const IUPnPDeviceFinder, @ptrCast(self)), bstrTypeURI, dwFlags, punkDeviceFinderCallback, plFindData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinder_StartAsyncFind(self: *const T, lFindData: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinder.VTable, @ptrCast(self.vtable)).StartAsyncFind(@as(*const IUPnPDeviceFinder, @ptrCast(self)), lFindData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinder_CancelAsyncFind(self: *const T, lFindData: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinder.VTable, @ptrCast(self.vtable)).CancelAsyncFind(@as(*const IUPnPDeviceFinder, @ptrCast(self)), lFindData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinder_FindByUDN(self: *const T, bstrUDN: ?BSTR, pDevice: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinder.VTable, @ptrCast(self.vtable)).FindByUDN(@as(*const IUPnPDeviceFinder, @ptrCast(self)), bstrUDN, pDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUPnPAddressFamilyControl_Value = Guid.initString("e3bf6178-694e-459f-a5a6-191ea0ffa1c7");
pub const IID_IUPnPAddressFamilyControl = &IID_IUPnPAddressFamilyControl_Value;
pub const IUPnPAddressFamilyControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAddressFamily: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPAddressFamilyControl,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPAddressFamilyControl,
                dwFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAddressFamily: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPAddressFamilyControl,
                pdwFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPAddressFamilyControl,
                pdwFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPAddressFamilyControl_SetAddressFamily(self: *const T, dwFlags: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPAddressFamilyControl.VTable, @ptrCast(self.vtable)).SetAddressFamily(@as(*const IUPnPAddressFamilyControl, @ptrCast(self)), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPAddressFamilyControl_GetAddressFamily(self: *const T, pdwFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPAddressFamilyControl.VTable, @ptrCast(self.vtable)).GetAddressFamily(@as(*const IUPnPAddressFamilyControl, @ptrCast(self)), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUPnPHttpHeaderControl_Value = Guid.initString("0405af4f-8b5c-447c-80f2-b75984a31f3c");
pub const IID_IUPnPHttpHeaderControl = &IID_IUPnPHttpHeaderControl_Value;
pub const IUPnPHttpHeaderControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRequestHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPHttpHeaderControl,
                bstrHttpHeaders: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPHttpHeaderControl,
                bstrHttpHeaders: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPHttpHeaderControl_AddRequestHeaders(self: *const T, bstrHttpHeaders: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPHttpHeaderControl.VTable, @ptrCast(self.vtable)).AddRequestHeaders(@as(*const IUPnPHttpHeaderControl, @ptrCast(self)), bstrHttpHeaders);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDeviceFinderCallback_Value = Guid.initString("415a984a-88b3-49f3-92af-0508bedf0d6c");
pub const IID_IUPnPDeviceFinderCallback = &IID_IUPnPDeviceFinderCallback_Value;
pub const IUPnPDeviceFinderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeviceAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
                pDevice: ?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
                pDevice: ?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
                bstrUDN: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
                bstrUDN: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinderCallback,
                lFindData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinderCallback_DeviceAdded(self: *const T, lFindData: i32, pDevice: ?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinderCallback.VTable, @ptrCast(self.vtable)).DeviceAdded(@as(*const IUPnPDeviceFinderCallback, @ptrCast(self)), lFindData, pDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinderCallback_DeviceRemoved(self: *const T, lFindData: i32, bstrUDN: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinderCallback.VTable, @ptrCast(self.vtable)).DeviceRemoved(@as(*const IUPnPDeviceFinderCallback, @ptrCast(self)), lFindData, bstrUDN);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinderCallback_SearchComplete(self: *const T, lFindData: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinderCallback.VTable, @ptrCast(self.vtable)).SearchComplete(@as(*const IUPnPDeviceFinderCallback, @ptrCast(self)), lFindData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPServices_Value = Guid.initString("3f8c8e9e-9a7a-4dc8-bc41-ff31fa374956");
pub const IID_IUPnPServices = &IID_IUPnPServices_Value;
pub const IUPnPServices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPServices,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPServices,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPServices,
                bstrServiceId: ?BSTR,
                ppService: ?*?*IUPnPService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPServices,
                bstrServiceId: ?BSTR,
                ppService: ?*?*IUPnPService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServices_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUPnPServices, @ptrCast(self)), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServices_get__NewEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUPnPServices, @ptrCast(self)), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServices_get_Item(self: *const T, bstrServiceId: ?BSTR, ppService: ?*?*IUPnPService) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUPnPServices, @ptrCast(self)), bstrServiceId, ppService);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPService_Value = Guid.initString("a295019c-dc65-47dd-90dc-7fe918a1ab44");
pub const IID_IUPnPService = &IID_IUPnPService_Value;
pub const IUPnPService = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        QueryStateVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPService,
                bstrVariableName: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPService,
                bstrVariableName: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPService,
                bstrActionName: ?BSTR,
                vInActionArgs: VARIANT,
                pvOutActionArgs: ?*VARIANT,
                pvRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPService,
                bstrActionName: ?BSTR,
                vInActionArgs: VARIANT,
                pvOutActionArgs: ?*VARIANT,
                pvRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceTypeIdentifier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPService,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPService,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPService,
                pUnkCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPService,
                pUnkCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPService,
                pbstrId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPService,
                pbstrId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastTransportStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPService,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPService,
                plValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_QueryStateVariable(self: *const T, bstrVariableName: ?BSTR, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).QueryStateVariable(@as(*const IUPnPService, @ptrCast(self)), bstrVariableName, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_InvokeAction(self: *const T, bstrActionName: ?BSTR, vInActionArgs: VARIANT, pvOutActionArgs: ?*VARIANT, pvRetVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).InvokeAction(@as(*const IUPnPService, @ptrCast(self)), bstrActionName, vInActionArgs, pvOutActionArgs, pvRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_get_ServiceTypeIdentifier(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).get_ServiceTypeIdentifier(@as(*const IUPnPService, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_AddCallback(self: *const T, pUnkCallback: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).AddCallback(@as(*const IUPnPService, @ptrCast(self)), pUnkCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_get_Id(self: *const T, pbstrId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).get_Id(@as(*const IUPnPService, @ptrCast(self)), pbstrId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPService_get_LastTransportStatus(self: *const T, plValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPService.VTable, @ptrCast(self.vtable)).get_LastTransportStatus(@as(*const IUPnPService, @ptrCast(self)), plValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUPnPAsyncResult_Value = Guid.initString("4d65fd08-d13e-4274-9c8b-dd8d028c8644");
pub const IID_IUPnPAsyncResult = &IID_IUPnPAsyncResult_Value;
pub const IUPnPAsyncResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsyncOperationComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPAsyncResult,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPAsyncResult,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPAsyncResult_AsyncOperationComplete(self: *const T, ullRequestID: u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPAsyncResult.VTable, @ptrCast(self.vtable)).AsyncOperationComplete(@as(*const IUPnPAsyncResult, @ptrCast(self)), ullRequestID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUPnPServiceAsync_Value = Guid.initString("098bdaf5-5ec1-49e7-a260-b3a11dd8680c");
pub const IID_IUPnPServiceAsync = &IID_IUPnPServiceAsync_Value;
pub const IUPnPServiceAsync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginInvokeAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                bstrActionName: ?BSTR,
                vInActionArgs: VARIANT,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                bstrActionName: ?BSTR,
                vInActionArgs: VARIANT,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInvokeAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pvOutActionArgs: ?*VARIANT,
                pvRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pvOutActionArgs: ?*VARIANT,
                pvRetVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginQueryStateVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                bstrVariableName: ?BSTR,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                bstrVariableName: ?BSTR,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndQueryStateVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginSubscribeToEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                pUnkCallback: ?*IUnknown,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                pUnkCallback: ?*IUnknown,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSubscribeToEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginSCPDDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                pAsyncResult: ?*IUPnPAsyncResult,
                pullRequestID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSCPDDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pbstrSCPDDoc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
                pbstrSCPDDoc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceAsync,
                ullRequestID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_BeginInvokeAction(self: *const T, bstrActionName: ?BSTR, vInActionArgs: VARIANT, pAsyncResult: ?*IUPnPAsyncResult, pullRequestID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).BeginInvokeAction(@as(*const IUPnPServiceAsync, @ptrCast(self)), bstrActionName, vInActionArgs, pAsyncResult, pullRequestID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_EndInvokeAction(self: *const T, ullRequestID: u64, pvOutActionArgs: ?*VARIANT, pvRetVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).EndInvokeAction(@as(*const IUPnPServiceAsync, @ptrCast(self)), ullRequestID, pvOutActionArgs, pvRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_BeginQueryStateVariable(self: *const T, bstrVariableName: ?BSTR, pAsyncResult: ?*IUPnPAsyncResult, pullRequestID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).BeginQueryStateVariable(@as(*const IUPnPServiceAsync, @ptrCast(self)), bstrVariableName, pAsyncResult, pullRequestID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_EndQueryStateVariable(self: *const T, ullRequestID: u64, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).EndQueryStateVariable(@as(*const IUPnPServiceAsync, @ptrCast(self)), ullRequestID, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_BeginSubscribeToEvents(self: *const T, pUnkCallback: ?*IUnknown, pAsyncResult: ?*IUPnPAsyncResult, pullRequestID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).BeginSubscribeToEvents(@as(*const IUPnPServiceAsync, @ptrCast(self)), pUnkCallback, pAsyncResult, pullRequestID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_EndSubscribeToEvents(self: *const T, ullRequestID: u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).EndSubscribeToEvents(@as(*const IUPnPServiceAsync, @ptrCast(self)), ullRequestID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_BeginSCPDDownload(self: *const T, pAsyncResult: ?*IUPnPAsyncResult, pullRequestID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).BeginSCPDDownload(@as(*const IUPnPServiceAsync, @ptrCast(self)), pAsyncResult, pullRequestID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_EndSCPDDownload(self: *const T, ullRequestID: u64, pbstrSCPDDoc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).EndSCPDDownload(@as(*const IUPnPServiceAsync, @ptrCast(self)), ullRequestID, pbstrSCPDDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceAsync_CancelAsyncOperation(self: *const T, ullRequestID: u64) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceAsync.VTable, @ptrCast(self.vtable)).CancelAsyncOperation(@as(*const IUPnPServiceAsync, @ptrCast(self)), ullRequestID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPServiceCallback_Value = Guid.initString("31fadca9-ab73-464b-b67d-5c1d0f83c8b8");
pub const IID_IUPnPServiceCallback = &IID_IUPnPServiceCallback_Value;
pub const IUPnPServiceCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StateVariableChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceCallback,
                pus: ?*IUPnPService,
                pcwszStateVarName: ?[*:0]const u16,
                vaValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceCallback,
                pus: ?*IUPnPService,
                pcwszStateVarName: ?[*:0]const u16,
                vaValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceInstanceDied: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceCallback,
                pus: ?*IUPnPService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceCallback,
                pus: ?*IUPnPService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceCallback_StateVariableChanged(self: *const T, pus: ?*IUPnPService, pcwszStateVarName: ?[*:0]const u16, vaValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceCallback.VTable, @ptrCast(self.vtable)).StateVariableChanged(@as(*const IUPnPServiceCallback, @ptrCast(self)), pus, pcwszStateVarName, vaValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceCallback_ServiceInstanceDied(self: *const T, pus: ?*IUPnPService) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceCallback.VTable, @ptrCast(self.vtable)).ServiceInstanceDied(@as(*const IUPnPServiceCallback, @ptrCast(self)), pus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUPnPServiceEnumProperty_Value = Guid.initString("38873b37-91bb-49f4-b249-2e8efbb8a816");
pub const IID_IUPnPServiceEnumProperty = &IID_IUPnPServiceEnumProperty_Value;
pub const IUPnPServiceEnumProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetServiceEnumProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceEnumProperty,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceEnumProperty,
                dwMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceEnumProperty_SetServiceEnumProperty(self: *const T, dwMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceEnumProperty.VTable, @ptrCast(self.vtable)).SetServiceEnumProperty(@as(*const IUPnPServiceEnumProperty, @ptrCast(self)), dwMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IUPnPServiceDocumentAccess_Value = Guid.initString("21905529-0a5e-4589-825d-7e6d87ea6998");
pub const IID_IUPnPServiceDocumentAccess = &IID_IUPnPServiceDocumentAccess_Value;
pub const IUPnPServiceDocumentAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceDocumentAccess,
                pbstrDocUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceDocumentAccess,
                pbstrDocUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPServiceDocumentAccess,
                pbstrDoc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPServiceDocumentAccess,
                pbstrDoc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceDocumentAccess_GetDocumentURL(self: *const T, pbstrDocUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceDocumentAccess.VTable, @ptrCast(self.vtable)).GetDocumentURL(@as(*const IUPnPServiceDocumentAccess, @ptrCast(self)), pbstrDocUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPServiceDocumentAccess_GetDocument(self: *const T, pbstrDoc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPServiceDocumentAccess.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IUPnPServiceDocumentAccess, @ptrCast(self)), pbstrDoc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDevices_Value = Guid.initString("fdbc0c73-bda3-4c66-ac4f-f2d96fdad68c");
pub const IID_IUPnPDevices = &IID_IUPnPDevices_Value;
pub const IUPnPDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevices,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevices,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevices,
                bstrUDN: ?BSTR,
                ppDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevices,
                bstrUDN: ?BSTR,
                ppDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevices_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IUPnPDevices, @ptrCast(self)), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevices_get__NewEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IUPnPDevices, @ptrCast(self)), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevices_get_Item(self: *const T, bstrUDN: ?BSTR, ppDevice: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IUPnPDevices, @ptrCast(self)), bstrUDN, ppDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDevice_Value = Guid.initString("3d44d0d1-98c9-4889-acd1-f9d674bf2221");
pub const IID_IUPnPDevice = &IID_IUPnPDevice_Value;
pub const IUPnPDevice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRootDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pvarb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pvarb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                ppudRootDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                ppudRootDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                ppudDeviceParent: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                ppudDeviceParent: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HasChildren: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pvarb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pvarb: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                ppudChildren: ?*?*IUPnPDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                ppudChildren: ?*?*IUPnPDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueDeviceName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PresentationURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ManufacturerName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ManufacturerURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModelName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModelNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModelURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UPC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SerialNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IconURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDevice,
                bstrEncodingFormat: ?BSTR,
                lSizeX: i32,
                lSizeY: i32,
                lBitDepth: i32,
                pbstrIconURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDevice,
                bstrEncodingFormat: ?BSTR,
                lSizeX: i32,
                lSizeY: i32,
                lBitDepth: i32,
                pbstrIconURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Services: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDevice,
                ppusServices: ?*?*IUPnPServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDevice,
                ppusServices: ?*?*IUPnPServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_IsRootDevice(self: *const T, pvarb: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_IsRootDevice(@as(*const IUPnPDevice, @ptrCast(self)), pvarb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_RootDevice(self: *const T, ppudRootDevice: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_RootDevice(@as(*const IUPnPDevice, @ptrCast(self)), ppudRootDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ParentDevice(self: *const T, ppudDeviceParent: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ParentDevice(@as(*const IUPnPDevice, @ptrCast(self)), ppudDeviceParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_HasChildren(self: *const T, pvarb: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_HasChildren(@as(*const IUPnPDevice, @ptrCast(self)), pvarb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_Children(self: *const T, ppudChildren: ?*?*IUPnPDevices) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_Children(@as(*const IUPnPDevice, @ptrCast(self)), ppudChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_UniqueDeviceName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_UniqueDeviceName(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_FriendlyName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_FriendlyName(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_Type(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_PresentationURL(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_PresentationURL(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ManufacturerName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ManufacturerName(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ManufacturerURL(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ManufacturerURL(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ModelName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ModelName(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ModelNumber(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ModelNumber(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_Description(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_ModelURL(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_ModelURL(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_UPC(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_UPC(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_SerialNumber(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_SerialNumber(@as(*const IUPnPDevice, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_IconURL(self: *const T, bstrEncodingFormat: ?BSTR, lSizeX: i32, lSizeY: i32, lBitDepth: i32, pbstrIconURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).IconURL(@as(*const IUPnPDevice, @ptrCast(self)), bstrEncodingFormat, lSizeX, lSizeY, lBitDepth, pbstrIconURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDevice_get_Services(self: *const T, ppusServices: ?*?*IUPnPServices) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDevice.VTable, @ptrCast(self.vtable)).get_Services(@as(*const IUPnPDevice, @ptrCast(self)), ppusServices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDeviceDocumentAccess_Value = Guid.initString("e7772804-3287-418e-9072-cf2b47238981");
pub const IID_IUPnPDeviceDocumentAccess = &IID_IUPnPDeviceDocumentAccess_Value;
pub const IUPnPDeviceDocumentAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceDocumentAccess,
                pbstrDocument: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceDocumentAccess,
                pbstrDocument: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceDocumentAccess_GetDocumentURL(self: *const T, pbstrDocument: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceDocumentAccess.VTable, @ptrCast(self.vtable)).GetDocumentURL(@as(*const IUPnPDeviceDocumentAccess, @ptrCast(self)), pbstrDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUPnPDeviceDocumentAccessEx_Value = Guid.initString("c4bc4050-6178-4bd1-a4b8-6398321f3247");
pub const IID_IUPnPDeviceDocumentAccessEx = &IID_IUPnPDeviceDocumentAccessEx_Value;
pub const IUPnPDeviceDocumentAccessEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceDocumentAccessEx,
                pbstrDocument: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceDocumentAccessEx,
                pbstrDocument: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceDocumentAccessEx_GetDocument(self: *const T, pbstrDocument: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceDocumentAccessEx.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IUPnPDeviceDocumentAccessEx, @ptrCast(self)), pbstrDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDescriptionDocument_Value = Guid.initString("11d1c1b2-7daa-4c9e-9595-7f82ed206d1e");
pub const IID_IUPnPDescriptionDocument = &IID_IUPnPDescriptionDocument_Value;
pub const IUPnPDescriptionDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                plReadyState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                plReadyState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                bstrUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                bstrUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                bstrUrl: ?BSTR,
                punkCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                bstrUrl: ?BSTR,
                punkCallback: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LoadResult: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                phrError: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                phrError: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RootDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                ppudRootDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                ppudRootDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceByUDN: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocument,
                bstrUDN: ?BSTR,
                ppudDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocument,
                bstrUDN: ?BSTR,
                ppudDevice: ?*?*IUPnPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_get_ReadyState(self: *const T, plReadyState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).get_ReadyState(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), plReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_Load(self: *const T, bstrUrl: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).Load(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), bstrUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_LoadAsync(self: *const T, bstrUrl: ?BSTR, punkCallback: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).LoadAsync(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), bstrUrl, punkCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_get_LoadResult(self: *const T, phrError: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).get_LoadResult(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), phrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).Abort(@as(*const IUPnPDescriptionDocument, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_RootDevice(self: *const T, ppudRootDevice: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).RootDevice(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), ppudRootDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocument_DeviceByUDN(self: *const T, bstrUDN: ?BSTR, ppudDevice: ?*?*IUPnPDevice) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocument.VTable, @ptrCast(self.vtable)).DeviceByUDN(@as(*const IUPnPDescriptionDocument, @ptrCast(self)), bstrUDN, ppudDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUPnPDeviceFinderAddCallbackWithInterface_Value = Guid.initString("983dfc0b-1796-44df-8975-ca545b620ee5");
pub const IID_IUPnPDeviceFinderAddCallbackWithInterface = &IID_IUPnPDeviceFinderAddCallbackWithInterface_Value;
pub const IUPnPDeviceFinderAddCallbackWithInterface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeviceAddedWithInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceFinderAddCallbackWithInterface,
                lFindData: i32,
                pDevice: ?*IUPnPDevice,
                pguidInterface: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceFinderAddCallbackWithInterface,
                lFindData: i32,
                pDevice: ?*IUPnPDevice,
                pguidInterface: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceFinderAddCallbackWithInterface_DeviceAddedWithInterface(self: *const T, lFindData: i32, pDevice: ?*IUPnPDevice, pguidInterface: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceFinderAddCallbackWithInterface.VTable, @ptrCast(self.vtable)).DeviceAddedWithInterface(@as(*const IUPnPDeviceFinderAddCallbackWithInterface, @ptrCast(self)), lFindData, pDevice, pguidInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDescriptionDocumentCallback_Value = Guid.initString("77394c69-5486-40d6-9bc3-4991983e02da");
pub const IID_IUPnPDescriptionDocumentCallback = &IID_IUPnPDescriptionDocumentCallback_Value;
pub const IUPnPDescriptionDocumentCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDescriptionDocumentCallback,
                hrLoadResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDescriptionDocumentCallback,
                hrLoadResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDescriptionDocumentCallback_LoadComplete(self: *const T, hrLoadResult: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDescriptionDocumentCallback.VTable, @ptrCast(self.vtable)).LoadComplete(@as(*const IUPnPDescriptionDocumentCallback, @ptrCast(self)), hrLoadResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_UPnPRegistrar_Value = Guid.initString("204810b9-73b2-11d4-bf42-00b0d0118b56");
pub const CLSID_UPnPRegistrar = &CLSID_UPnPRegistrar_Value;

const CLSID_UPnPRemoteEndpointInfo_Value = Guid.initString("2e5e84e9-4049-4244-b728-2d24227157c7");
pub const CLSID_UPnPRemoteEndpointInfo = &CLSID_UPnPRemoteEndpointInfo_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPEventSink_Value = Guid.initString("204810b4-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPEventSink = &IID_IUPnPEventSink_Value;
pub const IUPnPEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPEventSink,
                cChanges: u32,
                rgdispidChanges: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPEventSink,
                cChanges: u32,
                rgdispidChanges: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStateChangedSafe: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPEventSink,
                varsadispidChanges: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPEventSink,
                varsadispidChanges: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPEventSink_OnStateChanged(self: *const T, cChanges: u32, rgdispidChanges: [*]i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPEventSink.VTable, @ptrCast(self.vtable)).OnStateChanged(@as(*const IUPnPEventSink, @ptrCast(self)), cChanges, rgdispidChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPEventSink_OnStateChangedSafe(self: *const T, varsadispidChanges: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IUPnPEventSink.VTable, @ptrCast(self.vtable)).OnStateChangedSafe(@as(*const IUPnPEventSink, @ptrCast(self)), varsadispidChanges);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPEventSource_Value = Guid.initString("204810b5-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPEventSource = &IID_IUPnPEventSource_Value;
pub const IUPnPEventSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPEventSource,
                pesSubscriber: ?*IUPnPEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPEventSource,
                pesSubscriber: ?*IUPnPEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPEventSource,
                pesSubscriber: ?*IUPnPEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPEventSource,
                pesSubscriber: ?*IUPnPEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPEventSource_Advise(self: *const T, pesSubscriber: ?*IUPnPEventSink) callconv(.Inline) HRESULT {
            return @as(*const IUPnPEventSource.VTable, @ptrCast(self.vtable)).Advise(@as(*const IUPnPEventSource, @ptrCast(self)), pesSubscriber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPEventSource_Unadvise(self: *const T, pesSubscriber: ?*IUPnPEventSink) callconv(.Inline) HRESULT {
            return @as(*const IUPnPEventSource.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IUPnPEventSource, @ptrCast(self)), pesSubscriber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPRegistrar_Value = Guid.initString("204810b6-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPRegistrar = &IID_IUPnPRegistrar_Value;
pub const IUPnPRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrXMLDesc: ?BSTR,
                bstrProgIDDeviceControlClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
                pbstrDeviceIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrXMLDesc: ?BSTR,
                bstrProgIDDeviceControlClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
                pbstrDeviceIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterRunningDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrXMLDesc: ?BSTR,
                punkDeviceControl: ?*IUnknown,
                bstrInitString: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
                pbstrDeviceIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrXMLDesc: ?BSTR,
                punkDeviceControl: ?*IUnknown,
                bstrInitString: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
                pbstrDeviceIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterDeviceProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrProviderName: ?BSTR,
                bstrProgIDProviderClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrProviderName: ?BSTR,
                bstrProgIDProviderClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUniqueDeviceName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrTemplateUDN: ?BSTR,
                pbstrUDN: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrTemplateUDN: ?BSTR,
                pbstrUDN: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrDeviceIdentifier: ?BSTR,
                fPermanent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrDeviceIdentifier: ?BSTR,
                fPermanent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterDeviceProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRegistrar,
                bstrProviderName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRegistrar,
                bstrProviderName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_RegisterDevice(self: *const T, bstrXMLDesc: ?BSTR, bstrProgIDDeviceControlClass: ?BSTR, bstrInitString: ?BSTR, bstrContainerId: ?BSTR, bstrResourcePath: ?BSTR, nLifeTime: i32, pbstrDeviceIdentifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).RegisterDevice(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrXMLDesc, bstrProgIDDeviceControlClass, bstrInitString, bstrContainerId, bstrResourcePath, nLifeTime, pbstrDeviceIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_RegisterRunningDevice(self: *const T, bstrXMLDesc: ?BSTR, punkDeviceControl: ?*IUnknown, bstrInitString: ?BSTR, bstrResourcePath: ?BSTR, nLifeTime: i32, pbstrDeviceIdentifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).RegisterRunningDevice(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrXMLDesc, punkDeviceControl, bstrInitString, bstrResourcePath, nLifeTime, pbstrDeviceIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_RegisterDeviceProvider(self: *const T, bstrProviderName: ?BSTR, bstrProgIDProviderClass: ?BSTR, bstrInitString: ?BSTR, bstrContainerId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).RegisterDeviceProvider(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrProviderName, bstrProgIDProviderClass, bstrInitString, bstrContainerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_GetUniqueDeviceName(self: *const T, bstrDeviceIdentifier: ?BSTR, bstrTemplateUDN: ?BSTR, pbstrUDN: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).GetUniqueDeviceName(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrDeviceIdentifier, bstrTemplateUDN, pbstrUDN);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_UnregisterDevice(self: *const T, bstrDeviceIdentifier: ?BSTR, fPermanent: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).UnregisterDevice(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrDeviceIdentifier, fPermanent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRegistrar_UnregisterDeviceProvider(self: *const T, bstrProviderName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRegistrar.VTable, @ptrCast(self.vtable)).UnregisterDeviceProvider(@as(*const IUPnPRegistrar, @ptrCast(self)), bstrProviderName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPReregistrar_Value = Guid.initString("204810b7-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPReregistrar = &IID_IUPnPReregistrar_Value;
pub const IUPnPReregistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReregisterDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPReregistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrXMLDesc: ?BSTR,
                bstrProgIDDeviceControlClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPReregistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrXMLDesc: ?BSTR,
                bstrProgIDDeviceControlClass: ?BSTR,
                bstrInitString: ?BSTR,
                bstrContainerId: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReregisterRunningDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPReregistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrXMLDesc: ?BSTR,
                punkDeviceControl: ?*IUnknown,
                bstrInitString: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPReregistrar,
                bstrDeviceIdentifier: ?BSTR,
                bstrXMLDesc: ?BSTR,
                punkDeviceControl: ?*IUnknown,
                bstrInitString: ?BSTR,
                bstrResourcePath: ?BSTR,
                nLifeTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPReregistrar_ReregisterDevice(self: *const T, bstrDeviceIdentifier: ?BSTR, bstrXMLDesc: ?BSTR, bstrProgIDDeviceControlClass: ?BSTR, bstrInitString: ?BSTR, bstrContainerId: ?BSTR, bstrResourcePath: ?BSTR, nLifeTime: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPReregistrar.VTable, @ptrCast(self.vtable)).ReregisterDevice(@as(*const IUPnPReregistrar, @ptrCast(self)), bstrDeviceIdentifier, bstrXMLDesc, bstrProgIDDeviceControlClass, bstrInitString, bstrContainerId, bstrResourcePath, nLifeTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPReregistrar_ReregisterRunningDevice(self: *const T, bstrDeviceIdentifier: ?BSTR, bstrXMLDesc: ?BSTR, punkDeviceControl: ?*IUnknown, bstrInitString: ?BSTR, bstrResourcePath: ?BSTR, nLifeTime: i32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPReregistrar.VTable, @ptrCast(self.vtable)).ReregisterRunningDevice(@as(*const IUPnPReregistrar, @ptrCast(self)), bstrDeviceIdentifier, bstrXMLDesc, punkDeviceControl, bstrInitString, bstrResourcePath, nLifeTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDeviceControl_Value = Guid.initString("204810ba-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPDeviceControl = &IID_IUPnPDeviceControl_Value;
pub const IUPnPDeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceControl,
                bstrXMLDesc: ?BSTR,
                bstrDeviceIdentifier: ?BSTR,
                bstrInitString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceControl,
                bstrXMLDesc: ?BSTR,
                bstrDeviceIdentifier: ?BSTR,
                bstrInitString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceControl,
                bstrUDN: ?BSTR,
                bstrServiceId: ?BSTR,
                ppdispService: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceControl,
                bstrUDN: ?BSTR,
                bstrServiceId: ?BSTR,
                ppdispService: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceControl_Initialize(self: *const T, bstrXMLDesc: ?BSTR, bstrDeviceIdentifier: ?BSTR, bstrInitString: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceControl.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IUPnPDeviceControl, @ptrCast(self)), bstrXMLDesc, bstrDeviceIdentifier, bstrInitString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceControl_GetServiceObject(self: *const T, bstrUDN: ?BSTR, bstrServiceId: ?BSTR, ppdispService: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceControl.VTable, @ptrCast(self.vtable)).GetServiceObject(@as(*const IUPnPDeviceControl, @ptrCast(self)), bstrUDN, bstrServiceId, ppdispService);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUPnPDeviceControlHttpHeaders_Value = Guid.initString("204810bb-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPDeviceControlHttpHeaders = &IID_IUPnPDeviceControlHttpHeaders_Value;
pub const IUPnPDeviceControlHttpHeaders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdditionalResponseHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceControlHttpHeaders,
                bstrHttpResponseHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceControlHttpHeaders,
                bstrHttpResponseHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceControlHttpHeaders_GetAdditionalResponseHeaders(self: *const T, bstrHttpResponseHeaders: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceControlHttpHeaders.VTable, @ptrCast(self.vtable)).GetAdditionalResponseHeaders(@as(*const IUPnPDeviceControlHttpHeaders, @ptrCast(self)), bstrHttpResponseHeaders);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPDeviceProvider_Value = Guid.initString("204810b8-73b2-11d4-bf42-00b0d0118b56");
pub const IID_IUPnPDeviceProvider = &IID_IUPnPDeviceProvider_Value;
pub const IUPnPDeviceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceProvider,
                bstrInitString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceProvider,
                bstrInitString: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPDeviceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPDeviceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceProvider_Start(self: *const T, bstrInitString: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceProvider.VTable, @ptrCast(self.vtable)).Start(@as(*const IUPnPDeviceProvider, @ptrCast(self)), bstrInitString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPDeviceProvider_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IUPnPDeviceProvider.VTable, @ptrCast(self.vtable)).Stop(@as(*const IUPnPDeviceProvider, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUPnPRemoteEndpointInfo_Value = Guid.initString("c92eb863-0269-4aff-9c72-75321bba2952");
pub const IID_IUPnPRemoteEndpointInfo = &IID_IUPnPRemoteEndpointInfo_Value;
pub const IUPnPRemoteEndpointInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDwordValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pdwValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuidValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pguidValue: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUPnPRemoteEndpointInfo,
                bstrValueName: ?BSTR,
                pguidValue: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRemoteEndpointInfo_GetDwordValue(self: *const T, bstrValueName: ?BSTR, pdwValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRemoteEndpointInfo.VTable, @ptrCast(self.vtable)).GetDwordValue(@as(*const IUPnPRemoteEndpointInfo, @ptrCast(self)), bstrValueName, pdwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRemoteEndpointInfo_GetStringValue(self: *const T, bstrValueName: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRemoteEndpointInfo.VTable, @ptrCast(self.vtable)).GetStringValue(@as(*const IUPnPRemoteEndpointInfo, @ptrCast(self)), bstrValueName, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPRemoteEndpointInfo_GetGuidValue(self: *const T, bstrValueName: ?BSTR, pguidValue: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IUPnPRemoteEndpointInfo.VTable, @ptrCast(self.vtable)).GetGuidValue(@as(*const IUPnPRemoteEndpointInfo, @ptrCast(self)), bstrValueName, pguidValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (9)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDeviceCreate(
    pszEnumeratorName: ?[*:0]const u16,
    pszParentDeviceInstance: ?[*:0]const u16,
    pCreateInfo: ?*const SW_DEVICE_CREATE_INFO,
    cPropertyCount: u32,
    pProperties: ?[*]const DEVPROPERTY,
    pCallback: ?SW_DEVICE_CREATE_CALLBACK,
    pContext: ?*anyopaque,
    phSwDevice: ?*isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDeviceClose(
    hSwDevice: ?HSWDEVICE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.1'
pub extern "cfgmgr32" fn SwDeviceSetLifetime(
    hSwDevice: ?HSWDEVICE,
    Lifetime: SW_DEVICE_LIFETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "cfgmgr32" fn SwDeviceGetLifetime(
    hSwDevice: ?HSWDEVICE,
    pLifetime: ?*SW_DEVICE_LIFETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDevicePropertySet(
    hSwDevice: ?HSWDEVICE,
    cPropertyCount: u32,
    pProperties: [*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDeviceInterfaceRegister(
    hSwDevice: ?HSWDEVICE,
    pInterfaceClassGuid: ?*const Guid,
    pszReferenceString: ?[*:0]const u16,
    cPropertyCount: u32,
    pProperties: ?[*]const DEVPROPERTY,
    fEnabled: BOOL,
    ppszDeviceInterfaceId: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwMemFree(
    pMem: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDeviceInterfaceSetState(
    hSwDevice: ?HSWDEVICE,
    pszDeviceInterfaceId: ?[*:0]const u16,
    fEnabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "cfgmgr32" fn SwDeviceInterfacePropertySet(
    hSwDevice: ?HSWDEVICE,
    pszDeviceInterfaceId: ?[*:0]const u16,
    cPropertyCount: u32,
    pProperties: [*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (10)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const DEVPROPERTY = @import("../../devices/properties.zig").DEVPROPERTY;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const SECURITY_DESCRIPTOR = @import("../../security.zig").SECURITY_DESCRIPTOR;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SW_DEVICE_CREATE_CALLBACK")) { _ = SW_DEVICE_CREATE_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
