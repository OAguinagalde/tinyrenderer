//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const DEVPKEY_AudioEndpointPlugin_FactoryCLSID = PROPERTYKEY { .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 1 };
pub const DEVPKEY_AudioEndpointPlugin_DataFlow = PROPERTYKEY { .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 2 };
pub const DEVPKEY_AudioEndpointPlugin_PnPInterface = PROPERTYKEY { .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 3 };
pub const DEVPKEY_AudioEndpointPlugin2_FactoryCLSID = PROPERTYKEY { .fmtid = Guid.initString("12d83bd7-cf12-46be-8540-812710d3021c"), .pid = 4 };

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointFormatControl_Value = Guid.initString("784cfd40-9f89-456e-a1a6-873b006a664e");
pub const IID_IAudioEndpointFormatControl = &IID_IAudioEndpointFormatControl_Value;
pub const IAudioEndpointFormatControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetToDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointFormatControl,
                ResetFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointFormatControl,
                ResetFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointFormatControl_ResetToDefault(self: *const T, ResetFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointFormatControl.VTable, @ptrCast(self.vtable)).ResetToDefault(@as(*const IAudioEndpointFormatControl, @ptrCast(self)), ResetFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EndpointConnectorType = enum(i32) {
    HostProcessConnector = 0,
    OffloadConnector = 1,
    LoopbackConnector = 2,
    KeywordDetectorConnector = 3,
    ConnectorCount = 4,
};
pub const eHostProcessConnector = EndpointConnectorType.HostProcessConnector;
pub const eOffloadConnector = EndpointConnectorType.OffloadConnector;
pub const eLoopbackConnector = EndpointConnectorType.LoopbackConnector;
pub const eKeywordDetectorConnector = EndpointConnectorType.KeywordDetectorConnector;
pub const eConnectorCount = EndpointConnectorType.ConnectorCount;

pub const AUDIO_ENDPOINT_SHARED_CREATE_PARAMS = extern struct {
    u32Size: u32,
    u32TSSessionId: u32,
    targetEndpointConnectorType: EndpointConnectorType,
    wfxDeviceFormat: WAVEFORMATEX,
};

const IID_IAudioEndpointOffloadStreamVolume_Value = Guid.initString("64f1dd49-71ca-4281-8672-3a9eddd1d0b6");
pub const IID_IAudioEndpointOffloadStreamVolume = &IID_IAudioEndpointOffloadStreamVolume_Value;
pub const IAudioEndpointOffloadStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVolumeChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                u32ChannelCount: u32,
                pf32Volumes: ?*f32,
                u32CurveType: AUDIO_CURVE_TYPE,
                pCurveDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                u32ChannelCount: u32,
                pf32Volumes: ?*f32,
                u32CurveType: AUDIO_CURVE_TYPE,
                pCurveDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                u32ChannelCount: u32,
                pf32Volumes: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamVolume,
                u32ChannelCount: u32,
                pf32Volumes: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_GetVolumeChannelCount(self: *const T, pu32ChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).GetVolumeChannelCount(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), pu32ChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_SetChannelVolumes(self: *const T, u32ChannelCount: u32, pf32Volumes: ?*f32, u32CurveType: AUDIO_CURVE_TYPE, pCurveDuration: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumes(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), u32ChannelCount, pf32Volumes, u32CurveType, pCurveDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_GetChannelVolumes(self: *const T, u32ChannelCount: u32, pf32Volumes: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumes(@as(*const IAudioEndpointOffloadStreamVolume, @ptrCast(self)), u32ChannelCount, pf32Volumes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioEndpointOffloadStreamMute_Value = Guid.initString("dfe21355-5ec2-40e0-8d6b-710ac3c00249");
pub const IID_IAudioEndpointOffloadStreamMute = &IID_IAudioEndpointOffloadStreamMute_Value;
pub const IAudioEndpointOffloadStreamMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamMute,
                bMuted: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamMute,
                bMuted: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamMute,
                pbMuted: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamMute,
                pbMuted: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMute_SetMute(self: *const T, bMuted: u8) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamMute.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioEndpointOffloadStreamMute, @ptrCast(self)), bMuted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMute_GetMute(self: *const T, pbMuted: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamMute.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioEndpointOffloadStreamMute, @ptrCast(self)), pbMuted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEndpointOffloadStreamMeter_Value = Guid.initString("e1546dce-9dd1-418b-9ab2-348ced161c86");
pub const IID_IAudioEndpointOffloadStreamMeter = &IID_IAudioEndpointOffloadStreamMeter_Value;
pub const IAudioEndpointOffloadStreamMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMeterChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamMeter,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamMeter,
                pu32ChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMeteringData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointOffloadStreamMeter,
                u32ChannelCount: u32,
                pf32PeakValues: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointOffloadStreamMeter,
                u32ChannelCount: u32,
                pf32PeakValues: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMeter_GetMeterChannelCount(self: *const T, pu32ChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamMeter.VTable, @ptrCast(self.vtable)).GetMeterChannelCount(@as(*const IAudioEndpointOffloadStreamMeter, @ptrCast(self)), pu32ChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMeter_GetMeteringData(self: *const T, u32ChannelCount: u32, pf32PeakValues: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointOffloadStreamMeter.VTable, @ptrCast(self.vtable)).GetMeteringData(@as(*const IAudioEndpointOffloadStreamMeter, @ptrCast(self)), u32ChannelCount, pf32PeakValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAudioEndpointLastBufferControl_Value = Guid.initString("f8520dd3-8f9d-4437-9861-62f584c33dd6");
pub const IID_IAudioEndpointLastBufferControl = &IID_IAudioEndpointLastBufferControl_Value;
pub const IAudioEndpointLastBufferControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsLastBufferControlSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointLastBufferControl,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IAudioEndpointLastBufferControl,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        ReleaseOutputDataPointerForLastBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointLastBufferControl,
                pConnectionProperty: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IAudioEndpointLastBufferControl,
                pConnectionProperty: ?*const APO_CONNECTION_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointLastBufferControl_IsLastBufferControlSupported(self: *const T) callconv(.Inline) BOOL {
            return @as(*const IAudioEndpointLastBufferControl.VTable, @ptrCast(self.vtable)).IsLastBufferControlSupported(@as(*const IAudioEndpointLastBufferControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointLastBufferControl_ReleaseOutputDataPointerForLastBuffer(self: *const T, pConnectionProperty: ?*const APO_CONNECTION_PROPERTY) callconv(.Inline) void {
            return @as(*const IAudioEndpointLastBufferControl.VTable, @ptrCast(self.vtable)).ReleaseOutputDataPointerForLastBuffer(@as(*const IAudioEndpointLastBufferControl, @ptrCast(self)), pConnectionProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioLfxControl_Value = Guid.initString("076a6922-d802-4f83-baf6-409d9ca11bfe");
pub const IID_IAudioLfxControl = &IID_IAudioLfxControl_Value;
pub const IAudioLfxControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocalEffectsState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioLfxControl,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioLfxControl,
                bEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalEffectsState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioLfxControl,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioLfxControl,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLfxControl_SetLocalEffectsState(self: *const T, bEnabled: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAudioLfxControl.VTable, @ptrCast(self.vtable)).SetLocalEffectsState(@as(*const IAudioLfxControl, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLfxControl_GetLocalEffectsState(self: *const T, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAudioLfxControl.VTable, @ptrCast(self.vtable)).GetLocalEffectsState(@as(*const IAudioLfxControl, @ptrCast(self)), pbEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHardwareAudioEngineBase_Value = Guid.initString("eddce3e4-f3c1-453a-b461-223563cbd886");
pub const IID_IHardwareAudioEngineBase = &IID_IHardwareAudioEngineBase_Value;
pub const IHardwareAudioEngineBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableOffloadConnectorCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHardwareAudioEngineBase,
                _pwstrDeviceId: ?PWSTR,
                _uConnectorId: u32,
                _pAvailableConnectorInstanceCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHardwareAudioEngineBase,
                _pwstrDeviceId: ?PWSTR,
                _uConnectorId: u32,
                _pAvailableConnectorInstanceCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _bRequestDeviceFormat: BOOL,
                _ppwfxFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _bRequestDeviceFormat: BOOL,
                _ppwfxFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineDeviceFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _pwfxFormat: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _pwfxFormat: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGfxState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGfxState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _pbEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHardwareAudioEngineBase,
                pDevice: ?*IMMDevice,
                _pbEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetAvailableOffloadConnectorCount(self: *const T, _pwstrDeviceId: ?PWSTR, _uConnectorId: u32, _pAvailableConnectorInstanceCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetAvailableOffloadConnectorCount(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), _pwstrDeviceId, _uConnectorId, _pAvailableConnectorInstanceCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetEngineFormat(self: *const T, pDevice: ?*IMMDevice, _bRequestDeviceFormat: BOOL, _ppwfxFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetEngineFormat(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), pDevice, _bRequestDeviceFormat, _ppwfxFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_SetEngineDeviceFormat(self: *const T, pDevice: ?*IMMDevice, _pwfxFormat: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).SetEngineDeviceFormat(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), pDevice, _pwfxFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_SetGfxState(self: *const T, pDevice: ?*IMMDevice, _bEnable: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).SetGfxState(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), pDevice, _bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetGfxState(self: *const T, pDevice: ?*IMMDevice, _pbEnable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHardwareAudioEngineBase.VTable, @ptrCast(self.vtable)).GetGfxState(@as(*const IHardwareAudioEngineBase, @ptrCast(self)), pDevice, _pbEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value = Guid.initString("9f2f7b66-65ac-4fa6-8ae4-123c78b89313");
pub const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN = &CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolumeCallback_Value = Guid.initString("657804fa-d6ad-4496-8a60-352752af4f89");
pub const IID_IAudioEndpointVolumeCallback = &IID_IAudioEndpointVolumeCallback_Value;
pub const IAudioEndpointVolumeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolumeCallback,
                pNotify: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolumeCallback,
                pNotify: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolumeCallback_OnNotify(self: *const T, pNotify: ?*AUDIO_VOLUME_NOTIFICATION_DATA) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolumeCallback.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IAudioEndpointVolumeCallback, @ptrCast(self)), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolume_Value = Guid.initString("5cdf2c82-841e-4546-9722-0cf74078229a");
pub const IID_IAudioEndpointVolume = &IID_IAudioEndpointVolume_Value;
pub const IAudioEndpointVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterControlChangeNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pNotify: ?*IAudioEndpointVolumeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pNotify: ?*IAudioEndpointVolumeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterControlChangeNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pNotify: ?*IAudioEndpointVolumeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pNotify: ?*IAudioEndpointVolumeCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pnChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pnChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMasterVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMasterVolumeLevelScalar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                fLevel: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                fLevel: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterVolumeLevelScalar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolumeLevelScalar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                fLevel: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                fLevel: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolumeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolumeLevelScalar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                nChannel: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                bMute: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                bMute: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolumeStepInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pnStep: ?*u32,
                pnStepCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pnStep: ?*u32,
                pnStepCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VolumeStepUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VolumeStepDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHardwareSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pdwHardwareSupportMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pdwHardwareSupportMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolumeRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolume,
                pflVolumeMindB: ?*f32,
                pflVolumeMaxdB: ?*f32,
                pflVolumeIncrementdB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolume,
                pflVolumeMindB: ?*f32,
                pflVolumeMaxdB: ?*f32,
                pflVolumeIncrementdB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_RegisterControlChangeNotify(self: *const T, pNotify: ?*IAudioEndpointVolumeCallback) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).RegisterControlChangeNotify(@as(*const IAudioEndpointVolume, @ptrCast(self)), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_UnregisterControlChangeNotify(self: *const T, pNotify: ?*IAudioEndpointVolumeCallback) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).UnregisterControlChangeNotify(@as(*const IAudioEndpointVolume, @ptrCast(self)), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelCount(self: *const T, pnChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioEndpointVolume, @ptrCast(self)), pnChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMasterVolumeLevel(self: *const T, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMasterVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMasterVolumeLevelScalar(self: *const T, fLevel: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMasterVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), fLevel, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMasterVolumeLevel(self: *const T, pfLevelDB: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMasterVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), pfLevelDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMasterVolumeLevelScalar(self: *const T, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMasterVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetChannelVolumeLevel(self: *const T, nChannel: u32, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), nChannel, fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetChannelVolumeLevelScalar(self: *const T, nChannel: u32, fLevel: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetChannelVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), nChannel, fLevel, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelVolumeLevel(self: *const T, nChannel: u32, pfLevelDB: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumeLevel(@as(*const IAudioEndpointVolume, @ptrCast(self)), nChannel, pfLevelDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelVolumeLevelScalar(self: *const T, nChannel: u32, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetChannelVolumeLevelScalar(@as(*const IAudioEndpointVolume, @ptrCast(self)), nChannel, pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMute(self: *const T, bMute: BOOL, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioEndpointVolume, @ptrCast(self)), bMute, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMute(self: *const T, pbMute: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioEndpointVolume, @ptrCast(self)), pbMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetVolumeStepInfo(self: *const T, pnStep: ?*u32, pnStepCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetVolumeStepInfo(@as(*const IAudioEndpointVolume, @ptrCast(self)), pnStep, pnStepCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_VolumeStepUp(self: *const T, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).VolumeStepUp(@as(*const IAudioEndpointVolume, @ptrCast(self)), pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_VolumeStepDown(self: *const T, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).VolumeStepDown(@as(*const IAudioEndpointVolume, @ptrCast(self)), pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_QueryHardwareSupport(self: *const T, pdwHardwareSupportMask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).QueryHardwareSupport(@as(*const IAudioEndpointVolume, @ptrCast(self)), pdwHardwareSupportMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetVolumeRange(self: *const T, pflVolumeMindB: ?*f32, pflVolumeMaxdB: ?*f32, pflVolumeIncrementdB: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolume.VTable, @ptrCast(self.vtable)).GetVolumeRange(@as(*const IAudioEndpointVolume, @ptrCast(self)), pflVolumeMindB, pflVolumeMaxdB, pflVolumeIncrementdB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointVolumeEx_Value = Guid.initString("66e11784-f695-4f28-a505-a7080081a78f");
pub const IID_IAudioEndpointVolumeEx = &IID_IAudioEndpointVolumeEx_Value;
pub const IAudioEndpointVolumeEx = extern struct {
    pub const VTable = extern struct {
        base: IAudioEndpointVolume.VTable,
        GetVolumeRangeChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioEndpointVolumeEx,
                iChannel: u32,
                pflVolumeMindB: ?*f32,
                pflVolumeMaxdB: ?*f32,
                pflVolumeIncrementdB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioEndpointVolumeEx,
                iChannel: u32,
                pflVolumeMindB: ?*f32,
                pflVolumeMaxdB: ?*f32,
                pflVolumeIncrementdB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioEndpointVolume.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolumeEx_GetVolumeRangeChannel(self: *const T, iChannel: u32, pflVolumeMindB: ?*f32, pflVolumeMaxdB: ?*f32, pflVolumeIncrementdB: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioEndpointVolumeEx.VTable, @ptrCast(self.vtable)).GetVolumeRangeChannel(@as(*const IAudioEndpointVolumeEx, @ptrCast(self)), iChannel, pflVolumeMindB, pflVolumeMaxdB, pflVolumeIncrementdB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMeterInformation_Value = Guid.initString("c02216f6-8c67-4b5b-9d00-d008e73e0064");
pub const IID_IAudioMeterInformation = &IID_IAudioMeterInformation_Value;
pub const IAudioMeterInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPeakValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMeterInformation,
                pfPeak: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMeterInformation,
                pfPeak: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMeteringChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMeterInformation,
                pnChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMeterInformation,
                pnChannelCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelsPeakValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMeterInformation,
                u32ChannelCount: u32,
                afPeakValues: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMeterInformation,
                u32ChannelCount: u32,
                afPeakValues: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHardwareSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMeterInformation,
                pdwHardwareSupportMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMeterInformation,
                pdwHardwareSupportMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetPeakValue(self: *const T, pfPeak: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetPeakValue(@as(*const IAudioMeterInformation, @ptrCast(self)), pfPeak);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetMeteringChannelCount(self: *const T, pnChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetMeteringChannelCount(@as(*const IAudioMeterInformation, @ptrCast(self)), pnChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetChannelsPeakValues(self: *const T, u32ChannelCount: u32, afPeakValues: [*]f32) callconv(.Inline) HRESULT {
            return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).GetChannelsPeakValues(@as(*const IAudioMeterInformation, @ptrCast(self)), u32ChannelCount, afPeakValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_QueryHardwareSupport(self: *const T, pdwHardwareSupportMask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAudioMeterInformation.VTable, @ptrCast(self.vtable)).QueryHardwareSupport(@as(*const IAudioMeterInformation, @ptrCast(self)), pdwHardwareSupportMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const APO_CONNECTION_PROPERTY = @import("../../media/audio/apo.zig").APO_CONNECTION_PROPERTY;
const AUDIO_CURVE_TYPE = @import("../../media/kernel_streaming.zig").AUDIO_CURVE_TYPE;
const AUDIO_VOLUME_NOTIFICATION_DATA = @import("../../media/audio.zig").AUDIO_VOLUME_NOTIFICATION_DATA;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IMMDevice = @import("../../media/audio.zig").IMMDevice;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PROPERTYKEY = @import("../../ui/shell/properties_system.zig").PROPERTYKEY;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
