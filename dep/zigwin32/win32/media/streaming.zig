//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (16)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFDeviceTransform_Value = Guid.initString("d818fbd8-fc46-42f2-87ac-1ea2d1f9bf32");
pub const IID_IMFDeviceTransform = &IID_IMFDeviceTransform_Value;
pub const IMFDeviceTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputAvailableType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                dwTypeIndex: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                dwTypeIndex: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCurrentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputAvailableType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                dwTypeIndex: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                dwTypeIndex: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCurrentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                pMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwOutputStreamID: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                pcInputStreams: ?*u32,
                pcOutputStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                pcInputStreams: ?*u32,
                pcOutputStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputIDArraySize: u32,
                pdwInputStreamIds: ?*u32,
                dwOutputIDArraySize: u32,
                pdwOutputStreamIds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputIDArraySize: u32,
                pdwInputStreamIds: ?*u32,
                dwOutputIDArraySize: u32,
                pdwOutputStreamIds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pSample: ?*IMFSample,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwInputStreamID: u32,
                pSample: ?*IMFSample,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                eMessage: MFT_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                eMessage: MFT_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwFlags: u32,
                cOutputBufferCount: u32,
                pOutputSample: ?*MFT_OUTPUT_DATA_BUFFER,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwFlags: u32,
                cOutputBufferCount: u32,
                pOutputSample: ?*MFT_OUTPUT_DATA_BUFFER,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
                value: DeviceStreamState,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
                value: DeviceStreamState,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
                value: DeviceStreamState,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
                value: DeviceStreamState,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStreamPreferredState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamID: u32,
                value: ?*DeviceStreamState,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushInputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushOutputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransform,
                dwStreamIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransform,
                dwStreamIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_InitializeTransform(self: *const T, pAttributes: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).InitializeTransform(@as(*const IMFDeviceTransform, @ptrCast(self)), pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetInputAvailableType(self: *const T, dwInputStreamID: u32, dwTypeIndex: u32, pMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputAvailableType(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputStreamID, dwTypeIndex, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetInputCurrentType(self: *const T, dwInputStreamID: u32, pMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputCurrentType(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputStreamID, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetInputStreamAttributes(self: *const T, dwInputStreamID: u32, ppAttributes: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamAttributes(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputStreamID, ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetOutputAvailableType(self: *const T, dwOutputStreamID: u32, dwTypeIndex: u32, pMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputAvailableType(@as(*const IMFDeviceTransform, @ptrCast(self)), dwOutputStreamID, dwTypeIndex, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetOutputCurrentType(self: *const T, dwOutputStreamID: u32, pMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputCurrentType(@as(*const IMFDeviceTransform, @ptrCast(self)), dwOutputStreamID, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetOutputStreamAttributes(self: *const T, dwOutputStreamID: u32, ppAttributes: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamAttributes(@as(*const IMFDeviceTransform, @ptrCast(self)), dwOutputStreamID, ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetStreamCount(self: *const T, pcInputStreams: ?*u32, pcOutputStreams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFDeviceTransform, @ptrCast(self)), pcInputStreams, pcOutputStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetStreamIDs(self: *const T, dwInputIDArraySize: u32, pdwInputStreamIds: ?*u32, dwOutputIDArraySize: u32, pdwOutputStreamIds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetStreamIDs(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputIDArraySize, pdwInputStreamIds, dwOutputIDArraySize, pdwOutputStreamIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_ProcessEvent(self: *const T, dwInputStreamID: u32, pEvent: ?*IMFMediaEvent) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessEvent(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputStreamID, pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_ProcessInput(self: *const T, dwInputStreamID: u32, pSample: ?*IMFSample, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessInput(@as(*const IMFDeviceTransform, @ptrCast(self)), dwInputStreamID, pSample, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_ProcessMessage(self: *const T, eMessage: MFT_MESSAGE_TYPE, ulParam: usize) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessMessage(@as(*const IMFDeviceTransform, @ptrCast(self)), eMessage, ulParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_ProcessOutput(self: *const T, dwFlags: u32, cOutputBufferCount: u32, pOutputSample: ?*MFT_OUTPUT_DATA_BUFFER, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).ProcessOutput(@as(*const IMFDeviceTransform, @ptrCast(self)), dwFlags, cOutputBufferCount, pOutputSample, pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_SetInputStreamState(self: *const T, dwStreamID: u32, pMediaType: ?*IMFMediaType, value: DeviceStreamState, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).SetInputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamID, pMediaType, value, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetInputStreamState(self: *const T, dwStreamID: u32, value: ?*DeviceStreamState) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamID, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_SetOutputStreamState(self: *const T, dwStreamID: u32, pMediaType: ?*IMFMediaType, value: DeviceStreamState, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).SetOutputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamID, pMediaType, value, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetOutputStreamState(self: *const T, dwStreamID: u32, value: ?*DeviceStreamState) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamState(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamID, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_GetInputStreamPreferredState(self: *const T, dwStreamID: u32, value: ?*DeviceStreamState, ppMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).GetInputStreamPreferredState(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamID, value, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_FlushInputStream(self: *const T, dwStreamIndex: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).FlushInputStream(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamIndex, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransform_FlushOutputStream(self: *const T, dwStreamIndex: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransform.VTable, @ptrCast(self.vtable)).FlushOutputStream(@as(*const IMFDeviceTransform, @ptrCast(self)), dwStreamIndex, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IMFDeviceTransformCallback_Value = Guid.initString("6d5cb646-29ec-41fb-8179-8c4c6d750811");
pub const IID_IMFDeviceTransformCallback = &IID_IMFDeviceTransformCallback_Value;
pub const IMFDeviceTransformCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBufferSent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMFDeviceTransformCallback,
                pCallbackAttributes: ?*IMFAttributes,
                pinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMFDeviceTransformCallback,
                pCallbackAttributes: ?*IMFAttributes,
                pinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDeviceTransformCallback_OnBufferSent(self: *const T, pCallbackAttributes: ?*IMFAttributes, pinId: u32) callconv(.Inline) HRESULT {
            return @as(*const IMFDeviceTransformCallback.VTable, @ptrCast(self.vtable)).OnBufferSent(@as(*const IMFDeviceTransformCallback, @ptrCast(self)), pCallbackAttributes, pinId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TRANSFER_VIDEO_FRAME_FLAGS = enum(i32) {
    DEFAULT = 0,
    STRETCH = 1,
    IGNORE_PAR = 2,
};
pub const MF_TRANSFER_VIDEO_FRAME_DEFAULT = MF_TRANSFER_VIDEO_FRAME_FLAGS.DEFAULT;
pub const MF_TRANSFER_VIDEO_FRAME_STRETCH = MF_TRANSFER_VIDEO_FRAME_FLAGS.STRETCH;
pub const MF_TRANSFER_VIDEO_FRAME_IGNORE_PAR = MF_TRANSFER_VIDEO_FRAME_FLAGS.IGNORE_PAR;

pub const MF_MEDIASOURCE_STATUS_INFO = enum(i32) {
    FULLYSUPPORTED = 0,
    UNKNOWN = 1,
};
pub const MF_MEDIASOURCE_STATUS_INFO_FULLYSUPPORTED = MF_MEDIASOURCE_STATUS_INFO.FULLYSUPPORTED;
pub const MF_MEDIASOURCE_STATUS_INFO_UNKNOWN = MF_MEDIASOURCE_STATUS_INFO.UNKNOWN;

pub const FaceRectInfoBlobHeader = extern struct {
    Size: u32,
    Count: u32,
};

pub const FaceRectInfo = extern struct {
    Region: RECT,
    confidenceLevel: i32,
};

pub const FaceCharacterizationBlobHeader = extern struct {
    Size: u32,
    Count: u32,
};

pub const FaceCharacterization = extern struct {
    BlinkScoreLeft: u32,
    BlinkScoreRight: u32,
    FacialExpression: u32,
    FacialExpressionScore: u32,
};

pub const CapturedMetadataExposureCompensation = extern struct {
    Flags: u64,
    Value: i32,
};

pub const CapturedMetadataISOGains = extern struct {
    AnalogGain: f32,
    DigitalGain: f32,
};

pub const CapturedMetadataWhiteBalanceGains = extern struct {
    R: f32,
    G: f32,
    B: f32,
};

pub const MetadataTimeStamps = extern struct {
    Flags: u32,
    Device: i64,
    Presentation: i64,
};

pub const HistogramGrid = extern struct {
    Width: u32,
    Height: u32,
    Region: RECT,
};

pub const HistogramBlobHeader = extern struct {
    Size: u32,
    Histograms: u32,
};

pub const HistogramHeader = extern struct {
    Size: u32,
    Bins: u32,
    FourCC: u32,
    ChannelMasks: u32,
    Grid: HistogramGrid,
};

pub const HistogramDataHeader = extern struct {
    Size: u32,
    ChannelMask: u32,
    Linear: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const DeviceStreamState = @import("../media/media_foundation.zig").DeviceStreamState;
const HRESULT = @import("../foundation.zig").HRESULT;
const IMFAttributes = @import("../media/media_foundation.zig").IMFAttributes;
const IMFMediaEvent = @import("../media/media_foundation.zig").IMFMediaEvent;
const IMFMediaType = @import("../media/media_foundation.zig").IMFMediaType;
const IMFSample = @import("../media/media_foundation.zig").IMFSample;
const IUnknown = @import("../system/com.zig").IUnknown;
const MFT_MESSAGE_TYPE = @import("../media/media_foundation.zig").MFT_MESSAGE_TYPE;
const MFT_OUTPUT_DATA_BUFFER = @import("../media/media_foundation.zig").MFT_OUTPUT_DATA_BUFFER;
const RECT = @import("../foundation.zig").RECT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
